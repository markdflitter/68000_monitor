00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 14:55:18

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; swap first and second args in download_byte
00000000                             9  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            10  ; revisit use of bytes and longs, eg for checksum
00000000                            11  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            12  ; Review for any other savings
00000000                            13  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            14  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            15  
00000000                            16  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            17  ; keep track of highest address hit during srec download
00000000                            18  ; fix the reset vector so that it jumps to the start
00000000                            19  ; implement backspace
00000000                            20  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            21  ; fix being able to enter random chars when W'ing
00000000                            22  ; ram check at startup?  Not sure if this is a good idea!
00000000                            23  ; byte W?
00000000                            24  
00000000                            25      ;ORG  $0
00200000                            26      ORG  $200000
00200000                            27  
00200000  =00000000                 28  DEBUG               EQU 0
00200000                            29  
00200000                            30  ; constants
00200000  =00000000                 31  ROM                 EQU $0
00200000  =00200000                 32  RAM                 EQU $200000
00200000                            33     
00200000  =00C00000                 34  DUART_BASE          EQU $C00000
00200000  =00000000                 35  DUART_MRA_          EQU $0
00200000  =00000001                 36  DUART_CSRA_         EQU $1
00200000  =00000001                 37  DUART_SRA_          EQU $1
00200000  =00000002                 38  DUART_CRA_          EQU $2
00200000  =00000003                 39  DUART_TXA_          EQU $3
00200000  =00000003                 40  DUART_RXA_          EQU $3
00200000  =00000004                 41  DUART_ACR_          EQU $4
00200000  =00000005                 42  DUART_IMR_          EQU $5
00200000  =00000008                 43  DUART_MRB_          EQU $8
00200000  =00000009                 44  DUART_CSRB_         EQU $9
00200000  =00000009                 45  DUART_SRB_          EQU $9
00200000  =0000000A                 46  DUART_CRB_          EQU $A
00200000  =0000000B                 47  DUART_TXB_          EQU $B
00200000  =0000000B                 48  DUART_RXB_          EQU $B
00200000  =0000000C                 49  DUART_IVR_          EQU $C
00200000  =0000000D                 50  DUART_OPCR_         EQU $D
00200000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00200000                            53  
00200000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            60  
00200000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            67  
00200000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            74  
00200000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 76  DISPLAY_            EQU $0
00200000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            78  
00200000                            79  ; macros
00200000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            81  ; the input register is changed during the process
00200000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            83  BIN2HEX MACRO
00200000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            86      MOVE.B \1,\2
00200000                            87      ANDI.L #$F,\2
00200000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            89      ENDM
00200000                            90  
00200000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            92  ; the input register is changed during the process
00200000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            94  HEX2BIN MACRO
00200000                            95      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            96      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                            97      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                            98      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                            99      ENDM
00200000                           100  
00200000                           101  ; send a single char to the serial port
00200000                           102  ; \1 = char to send, \2 = data register to use for status poll
00200000                           103  ; will stamp on D0 and D1 in debug mode
00200000                           104  PRINT_CHAR MACRO
00200000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           106      IFEQ DEBUG
00200000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           108          BTST #2,\2                              ; check for space to send
00200000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           111      ENDC
00200000                           112      
00200000                           113      IFNE DEBUG
00200000                           114          MOVE.B \1,D1
00200000                           115          MOVE.L #6,D0   
00200000                           116          TRAP #15                                ; write to terminal in simulator
00200000                           117      ENDC
00200000                           118  
00200000                           119      ENDM
00200000                           120  
00200000                           121  ; send CR,LF to the serial port
00200000                           122  ; \1 = data register to use for status poll
00200000                           123  PRINT_CRLF MACRO
00200000                           124      PRINT_CHAR #13,\1                           ; CR
00200000                           125      PRINT_CHAR #10,\1                           ; LF
00200000                           126      ENDM
00200000                           127  
00200000                           128  ; send C-style, zero terminated string to the serial port
00200000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           130  PRINT_STR MACRO
00200000                           131  LOOP\@
00200000                           132      CMP.B #0,(\1)                               ; 0 -> done
00200000                           133      BEQ EXIT\@
00200000                           134      PRINT_CHAR (\1)+,\2
00200000                           135      BRA LOOP\@
00200000                           136  EXIT\@
00200000                           137      ENDM
00200000                           138    
00200000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           141  PRINT_REG MACRO
00200000                           142      PRINT_CHAR #'0',\2                          ;0x header
00200000                           143      PRINT_CHAR #'x',\2
00200000                           144      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           145  LOOP\@
00200000                           146      BIN2HEX \1,\3,\5
00200000                           147      PRINT_CHAR \3,\2
00200000                           148      DBEQ \4,LOOP\@
00200000                           149      ENDM
00200000                           150    
00200000                           151  ; wait for a char from the serial port
00200000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           153  ; will stamp on D0 and D1 in debug mode
00200000                           154  WAIT_CHAR MACRO
00200000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           156  
00200000                           157      IFEQ DEBUG
00200000                           158          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           159          BTST #0,\2                              ; check for character
00200000                           160          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           161      ENDC
00200000                           162      
00200000                           163      READ_CHAR \1
00200000                           164  
00200000                           165      IFEQ DEBUG
00200000                           166          PRINT_CHAR \1,\2                        ; echo it back
00200000                           167      ENDC
00200000                           168      ENDM
00200000                           169      
00200000                           170  ; read a char from the serial port - assumes that there is one!
00200000                           171  ; \ 1= data register for read char
00200000                           172  ; will stamp on D0 and D1 in debug mode
00200000                           173  READ_CHAR MACRO
00200000                           174      IFEQ DEBUG
00200000                           175          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           176      ENDC
00200000                           177      IFNE DEBUG
00200000                           178          MOVE.L #5,D0    
00200000                           179          TRAP #15                                ; read from keyboard in simulator
00200000                           180          MOVE.L D1,\1
00200000                           181      ENDC
00200000                           182       
00200000                           183      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           184      BEQ START
00200000                           185      ENDM
00200000                           186      
00200000                           187      
00200000                           188  ; read data from the download serial port
00200000                           189  ; \ 1= data register for read char
00200000                           190  DOWNLOAD MACRO
00200000                           191  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           192  
00200000                           193      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           194      BTST #0,\1                                  ; check for character
00200000                           195      BEQ CONTINUE\@                              ; nothing, continue
00200000                           196   
00200000                           197      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           198  CONTINUE\@
00200000                           199      MOVE.B DUART_SRB,\1                         ; read download status register
00200000                           200      BTST #0,\1                                  ; check for character
00200000                           201      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           202      
00200000                           203      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           204      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           205      
00200000                           206      ENDM
00200000                           207      
00200000                           208  ; read two hex digits from the download serial port and convert to a byte
00200000                           209  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           210  DOWNLOAD_BYTE MACRO
00200000                           211      MOVE.B #2,\4
00200000                           212      WHILE.B \4 <GT> 0 DO
00200000                           213          LSL.L #4,\1                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200000                           214          DOWNLOAD \2
00200000                           215          PRINT_CHAR \2,\3
00200000                           216          HEX2BIN \2,\2,\6
00200000                           217          OR.B \2,\1
00200000                           218          SUB.B #1,\4
00200000                           219      ENDW
00200000                           220      
00200000                           221      MOVE.L #0,\2                        ; rextract latest byte of address and add into checksum
00200000                           222      MOVE.B \1,\2
00200000                           223      ADD.L \1,\5
00200000                           224  
00200000                           225      ENDM
00200000                           226      
00200000                           227  
00200000                           228  ; register catalogue
00200000                           229  ; D0 - used for simulator I/O
00200000                           230  ; D1 - used for simulator I/O
00200000                           231  ; D2 - read character
00200000                           232  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           233  ; D6 - working register used in R/W
00200000                           234  ; D7 - address accumulator, reset by download
00200000                           235  ; A0 - address of string to print 
00200000                           236  
00200000                           237  ; start vector
00200000= 00000000                 238  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 239  RESET    DC.L START                             ; RESET
00200008                           240      
00200008                           241  ; start of program  
00200008                           242  START
00200008  13FC 0000 00E00001       243      MOVE.B #0,DISPLAY
00200010                           244  
00200010                           245  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       246      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       247      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     248      NOP
00200022  13FC 0040 00C00005       249      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     250      NOP
0020002C  13FC 0030 00C00005       251      MOVE.B #$30,DUART_CRA
00200034  4E71                     252      NOP
00200036  13FC 0020 00C00005       253      MOVE.B #$20,DUART_CRA
0020003E  4E71                     254      NOP
00200040  13FC 0010 00C00005       255      MOVE.B #$10,DUART_CRA   
00200048                           256  
00200048  13FC 000A 00C00015       257      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       258      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     259      NOP
0020005A  13FC 0040 00C00015       260      MOVE.B #$40,DUART_CRB           
00200062  4E71                     261      NOP
00200064  13FC 0030 00C00015       262      MOVE.B #$30,DUART_CRB
0020006C  4E71                     263      NOP
0020006E  13FC 0020 00C00015       264      MOVE.B #$20,DUART_CRB
00200076  4E71                     265      NOP
00200078  13FC 0010 00C00015       266      MOVE.B #$10,DUART_CRB   
00200080                           267  
00200080                           268  ;initialise UART
00200080  13FC 0000 00C00009       269      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       270      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       271      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           272  
00200098                           273  ; channel A
00200098  13FC 0013 00C00001       274      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       275      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       276      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       277      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           278  
002000B8                           279  ; channel B
002000B8  13FC 0013 00C00011       280      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       281      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       282      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       283      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           284  
002000D8                           285m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           286m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      287m     IFEQ DEBUG
002000D8  1639 00C00003            288m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                289m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     290m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       291m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           292m     ENDC
002000EC                           293m     
002000EC                 FALSE     294m     IFNE DEBUG
002000EC                           295m     ENDC
002000EC                           296m 
002000EC                           297m     ENDM
002000EC                           298  
002000EC  13FC 0001 00E00001       299      MOVE.B #1,DISPLAY
002000F4                           300         
002000F4                           301m     PRINT_CRLF D3
002000F4                           302mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           303mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      304mm     IFEQ DEBUG
002000F4  1639 00C00003            305mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                306mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     307mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       308mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           309mm     ENDC
00200108                           310mm     
00200108                 FALSE     311mm     IFNE DEBUG
00200108                           312mm     ENDC
00200108                           313mm 
00200108                           314mm     ENDM
00200108                           315mm     PRINT_CHAR #10,D3                           ; LF
00200108                           316mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      317mm     IFEQ DEBUG
00200108  1639 00C00003            318mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                319mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     320mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       321mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           322mm     ENDC
0020011C                           323mm     
0020011C                 FALSE     324mm     IFNE DEBUG
0020011C                           325mm     ENDC
0020011C                           326mm 
0020011C                           327mm     ENDM
0020011C                           328m     ENDM
0020011C                           329  
0020011C  41F9 00200EB0            330      LEA VERSION,A0
00200122                           331m     PRINT_STR A0,D3
00200122                           332m LOOP_5
00200122  0C10 0000                333m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 0016                334m     BEQ EXIT_5
0020012A                           335mm     PRINT_CHAR (A0)+,D3
0020012A                           336mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      337mm     IFEQ DEBUG
0020012A  1639 00C00003            338mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                339mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     340mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            341mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           342mm     ENDC
0020013C                           343mm     
0020013C                 FALSE     344mm     IFNE DEBUG
0020013C                           345mm     ENDC
0020013C                           346mm 
0020013C                           347mm     ENDM
0020013C  60E4                     348m     BRA LOOP_5
0020013E                           349m EXIT_5
0020013E                           350m     ENDM
0020013E                           351m     PRINT_CRLF D3
0020013E                           352mm     PRINT_CHAR #13,D3                           ; CR
0020013E                           353mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020013E                 TRUE      354mm     IFEQ DEBUG
0020013E  1639 00C00003            355mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200144  0803 0002                356mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200148  67F4                     357mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014A  13FC 000D 00C00007       358mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200152                           359mm     ENDC
00200152                           360mm     
00200152                 FALSE     361mm     IFNE DEBUG
00200152                           362mm     ENDC
00200152                           363mm 
00200152                           364mm     ENDM
00200152                           365mm     PRINT_CHAR #10,D3                           ; LF
00200152                           366mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200152                 TRUE      367mm     IFEQ DEBUG
00200152  1639 00C00003            368mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200158  0803 0002                369mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020015C  67F4                     370mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0020015E  13FC 000A 00C00007       371mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200166                           372mm     ENDC
00200166                           373mm     
00200166                 FALSE     374mm     IFNE DEBUG
00200166                           375mm     ENDC
00200166                           376mm 
00200166                           377mm     ENDM
00200166                           378m     ENDM
00200166                           379m     PRINT_CHAR #7,D3
00200166                           380m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200166                 TRUE      381m     IFEQ DEBUG
00200166  1639 00C00003            382m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020016C  0803 0002                383m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200170  67F4                     384m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200172  13FC 0007 00C00007       385m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017A                           386m     ENDC
0020017A                           387m     
0020017A                 FALSE     388m     IFNE DEBUG
0020017A                           389m     ENDC
0020017A                           390m 
0020017A                           391m     ENDM
0020017A                           392  
0020017A  7E00                     393      MOVE.L #0,D7                                ; address accumulator
0020017C                           394  
0020017C  13FC 0002 00E00001       395      MOVE.B #2,DISPLAY
00200184                           396  MAIN_LOOP
00200184                           397m     PRINT_CHAR #'>',D3                          ; prompt
00200184                           398m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200184                 TRUE      399m     IFEQ DEBUG
00200184  1639 00C00003            400m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018A  0803 0002                401m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020018E  67F4                     402m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200190  13FC 003E 00C00007       403m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200198                           404m     ENDC
00200198                           405m     
00200198                 FALSE     406m     IFNE DEBUG
00200198                           407m     ENDC
00200198                           408m 
00200198                           409m     ENDM
00200198                           410m     PRINT_CHAR #32,D3                           ; space
00200198                           411m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200198                 TRUE      412m     IFEQ DEBUG
00200198  1639 00C00003            413m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020019E  0803 0002                414m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A2  67F4                     415m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A4  13FC 0020 00C00007       416m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001AC                           417m     ENDC
002001AC                           418m     
002001AC                 FALSE     419m     IFNE DEBUG
002001AC                           420m     ENDC
002001AC                           421m 
002001AC                           422m     ENDM
002001AC                           423      
002001AC                           424  GET_INPUT
002001AC                           425m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001AC                           426m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001AC                           427m 
002001AC                 TRUE      428m     IFEQ DEBUG
002001AC  1639 00C00003            429m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B2  0803 0000                430m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001B6  67F4                     431m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001B8                           432m     ENDC
002001B8                           433m     
002001B8                           434mm     READ_CHAR D2
002001B8                 TRUE      435mm     IFEQ DEBUG
002001B8  1439 00C00007            436mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001BE                           437mm     ENDC
002001BE                 FALSE     438mm     IFNE DEBUG
002001BE                           439mm     ENDC
002001BE                           440mm      
002001BE  B43C 001B                441mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C2  6700 FE44                442mm     BEQ START
002001C6                           443mm     ENDM
002001C6                           444m 
002001C6                 TRUE      445m     IFEQ DEBUG
002001C6                           446mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001C6                           447mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001C6                 TRUE      448mm     IFEQ DEBUG
002001C6  1639 00C00003            449mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001CC  0803 0002                450mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D0  67F4                     451mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D2  13C2 00C00007            452mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001D8                           453mm     ENDC
002001D8                           454mm     
002001D8                 FALSE     455mm     IFNE DEBUG
002001D8                           456mm     ENDC
002001D8                           457mm 
002001D8                           458mm     ENDM
002001D8                           459m     ENDC
002001D8                           460m     ENDM
002001D8                           461      
002001D8  B43C 0030                462      CMP.B #'0',D2
002001DC  6700 0CB2                463      BEQ HEX_DIGIT
002001E0  B43C 0031                464      CMP.B #'1',D2
002001E4  6700 0CAA                465      BEQ HEX_DIGIT
002001E8  B43C 0032                466      CMP.B #'2',D2
002001EC  6700 0CA2                467      BEQ HEX_DIGIT
002001F0  B43C 0033                468      CMP.B #'3',D2
002001F4  6700 0C9A                469      BEQ HEX_DIGIT
002001F8  B43C 0034                470      CMP.B #'4',D2
002001FC  6700 0C92                471      BEQ HEX_DIGIT
00200200  B43C 0035                472      CMP.B #'5',D2
00200204  6700 0C8A                473      BEQ HEX_DIGIT
00200208  B43C 0036                474      CMP.B #'6',D2
0020020C  6700 0C82                475      BEQ HEX_DIGIT
00200210  B43C 0037                476      CMP.B #'7',D2
00200214  6700 0C7A                477      BEQ HEX_DIGIT
00200218  B43C 0038                478      CMP.B #'8',D2
0020021C  6700 0C72                479      BEQ HEX_DIGIT
00200220  B43C 0039                480      CMP.B #'9',D2
00200224  6700 0C6A                481      BEQ HEX_DIGIT
00200228  B43C 0061                482      CMP.B #'a',D2
0020022C  6700 0C62                483      BEQ HEX_DIGIT
00200230  B43C 0062                484      CMP.B #'b',D2
00200234  6700 0C5A                485      BEQ HEX_DIGIT
00200238  B43C 0063                486      CMP.B #'c',D2
0020023C  6700 0C52                487      BEQ HEX_DIGIT
00200240  B43C 0064                488      CMP.B #'d',D2
00200244  6700 0C4A                489      BEQ HEX_DIGIT
00200248  B43C 0065                490      CMP.B #'e',D2
0020024C  6700 0C42                491      BEQ HEX_DIGIT
00200250  B43C 0066                492      CMP.B #'f',D2
00200254  6700 0C3A                493      BEQ HEX_DIGIT
00200258                           494      
00200258  B43C 0077                495      CMP.B #'w',D2
0020025C  6700 015A                496      BEQ W
00200260                           497      
00200260  B43C 006C                498      CMP.B #'l',D2
00200264  6700 0ABE                499      BEQ L 
00200268                           500  
00200268                           501m     PRINT_CRLF D3
00200268                           502mm     PRINT_CHAR #13,D3                           ; CR
00200268                           503mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200268                 TRUE      504mm     IFEQ DEBUG
00200268  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020026E  0803 0002                506mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200272  67F4                     507mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200274  13FC 000D 00C00007       508mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020027C                           509mm     ENDC
0020027C                           510mm     
0020027C                 FALSE     511mm     IFNE DEBUG
0020027C                           512mm     ENDC
0020027C                           513mm 
0020027C                           514mm     ENDM
0020027C                           515mm     PRINT_CHAR #10,D3                           ; LF
0020027C                           516mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020027C                 TRUE      517mm     IFEQ DEBUG
0020027C  1639 00C00003            518mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200282  0803 0002                519mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200286  67F4                     520mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00200288  13FC 000A 00C00007       521mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200290                           522mm     ENDC
00200290                           523mm     
00200290                 FALSE     524mm     IFNE DEBUG
00200290                           525mm     ENDC
00200290                           526mm 
00200290                           527mm     ENDM
00200290                           528m     ENDM
00200290                           529   
00200290  B43C 003F                530      CMP.B #'?',D2
00200294  6700 0050                531      BEQ H
00200298                           532  
00200298  B43C 0076                533      CMP.B #'v',D2
0020029C  6700 006E                534      BEQ V
002002A0                           535      
002002A0  B43C 0072                536      CMP.B #'r',D2
002002A4  6700 008C                537      BEQ R
002002A8                           538  
002002A8  B43C 0073                539      CMP.B #'s',D2
002002AC  6700 01D0                540      BEQ S
002002B0                           541  
002002B0  B43C 0067                542      CMP.B #'g',D2
002002B4  6700 0960                543      BEQ G   
002002B8                           544  
002002B8  B43C 007A                545      CMP.B #'z',D2
002002BC  6700 0960                546      BEQ Z   
002002C0                           547  
002002C0  41F9 00200F72            548      LEA HUH,A0
002002C6                           549m     PRINT_STR A0,D3
002002C6                           550m LOOP_19
002002C6  0C10 0000                551m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CA  6700 0016                552m     BEQ EXIT_19
002002CE                           553mm     PRINT_CHAR (A0)+,D3
002002CE                           554mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002CE                 TRUE      555mm     IFEQ DEBUG
002002CE  1639 00C00003            556mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D4  0803 0002                557mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002D8  67F4                     558mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DA  13D8 00C00007            559mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E0                           560mm     ENDC
002002E0                           561mm     
002002E0                 FALSE     562mm     IFNE DEBUG
002002E0                           563mm     ENDC
002002E0                           564mm 
002002E0                           565mm     ENDM
002002E0  60E4                     566m     BRA LOOP_19
002002E2                           567m EXIT_19
002002E2                           568m     ENDM
002002E2                           569                         
002002E2  6000 FEA0                570      BRA MAIN_LOOP
002002E6                           571      
002002E6                           572  ; commands
002002E6                           573  H   
002002E6  41F9 00200ECD            574      LEA HELP,A0
002002EC                           575m     PRINT_STR A0,D3
002002EC                           576m LOOP_21
002002EC  0C10 0000                577m     CMP.B #0,(A0)                               ; 0 -> DONE
002002F0  6700 0016                578m     BEQ EXIT_21
002002F4                           579mm     PRINT_CHAR (A0)+,D3
002002F4                           580mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002F4                 TRUE      581mm     IFEQ DEBUG
002002F4  1639 00C00003            582mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002FA  0803 0002                583mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002FE  67F4                     584mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00200300  13D8 00C00007            585mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200306                           586mm     ENDC
00200306                           587mm     
00200306                 FALSE     588mm     IFNE DEBUG
00200306                           589mm     ENDC
00200306                           590mm 
00200306                           591mm     ENDM
00200306  60E4                     592m     BRA LOOP_21
00200308                           593m EXIT_21
00200308                           594m     ENDM
00200308  6000 FE7A                595      BRA MAIN_LOOP
0020030C                           596  
0020030C                           597  V   
0020030C  41F9 00200EB0            598      LEA VERSION,A0
00200312                           599m     PRINT_STR A0,D3       
00200312                           600m LOOP_23
00200312  0C10 0000                601m     CMP.B #0,(A0)                               ; 0 -> DONE
00200316  6700 0016                602m     BEQ EXIT_23
0020031A                           603mm     PRINT_CHAR (A0)+,D3
0020031A                           604mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020031A                 TRUE      605mm     IFEQ DEBUG
0020031A  1639 00C00003            606mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200320  0803 0002                607mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200324  67F4                     608mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200326  13D8 00C00007            609mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020032C                           610mm     ENDC
0020032C                           611mm     
0020032C                 FALSE     612mm     IFNE DEBUG
0020032C                           613mm     ENDC
0020032C                           614mm 
0020032C                           615mm     ENDM
0020032C  60E4                     616m     BRA LOOP_23
0020032E                           617m EXIT_23
0020032E                           618m     ENDM
0020032E  6000 FE54                619      BRA MAIN_LOOP
00200332                           620      
00200332                           621  R   
00200332  2047                     622      MOVE.L D7,A0                                ; address accumulator -> address register
00200334  2A10                     623      MOVE.L (A0),D5                              ; read the memory and print it
00200336                           624m     PRINT_REG D5,D3,D7,D6,A0
00200336                           625mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200336                           626mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200336                 TRUE      627mm     IFEQ DEBUG
00200336  1639 00C00003            628mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020033C  0803 0002                629mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200340  67F4                     630mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200342  13FC 0030 00C00007       631mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020034A                           632mm     ENDC
0020034A                           633mm     
0020034A                 FALSE     634mm     IFNE DEBUG
0020034A                           635mm     ENDC
0020034A                           636mm 
0020034A                           637mm     ENDM
0020034A                           638mm     PRINT_CHAR #'x',D3
0020034A                           639mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034A                 TRUE      640mm     IFEQ DEBUG
0020034A  1639 00C00003            641mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200350  0803 0002                642mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200354  67F4                     643mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
00200356  13FC 0078 00C00007       644mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020035E                           645mm     ENDC
0020035E                           646mm     
0020035E                 FALSE     647mm     IFNE DEBUG
0020035E                           648mm     ENDC
0020035E                           649mm 
0020035E                           650mm     ENDM
0020035E  7C07                     651m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200360                           652m LOOP_25
00200360                           653mm     BIN2HEX D5,D7,A0
00200360  41F9 00200FD6            654mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200366  E99D                     655mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200368  1E05                     656mm     MOVE.B D5,D7
0020036A  0287 0000000F            657mm     ANDI.L #$F,D7
00200370  1E30 7000                658mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00200374                           659mm     ENDM
00200374                           660mm     PRINT_CHAR D7,D3
00200374                           661mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200374                 TRUE      662mm     IFEQ DEBUG
00200374  1639 00C00003            663mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020037A  0803 0002                664mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020037E  67F4                     665mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200380  13C7 00C00007            666mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200386                           667mm     ENDC
00200386                           668mm     
00200386                 FALSE     669mm     IFNE DEBUG
00200386                           670mm     ENDC
00200386                           671mm 
00200386                           672mm     ENDM
00200386  57CE FFD8                673m     DBEQ D6,LOOP_25
0020038A                           674m     ENDM
0020038A                           675m     PRINT_CRLF D3
0020038A                           676mm     PRINT_CHAR #13,D3                           ; CR
0020038A                           677mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      678mm     IFEQ DEBUG
0020038A  1639 00C00003            679mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                680mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     681mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
00200396  13FC 000D 00C00007       682mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020039E                           683mm     ENDC
0020039E                           684mm     
0020039E                 FALSE     685mm     IFNE DEBUG
0020039E                           686mm     ENDC
0020039E                           687mm 
0020039E                           688mm     ENDM
0020039E                           689mm     PRINT_CHAR #10,D3                           ; LF
0020039E                           690mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020039E                 TRUE      691mm     IFEQ DEBUG
0020039E  1639 00C00003            692mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A4  0803 0002                693mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003A8  67F4                     694mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003AA  13FC 000A 00C00007       695mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B2                           696mm     ENDC
002003B2                           697mm     
002003B2                 FALSE     698mm     IFNE DEBUG
002003B2                           699mm     ENDC
002003B2                           700mm 
002003B2                           701mm     ENDM
002003B2                           702m     ENDM
002003B2  7E00                     703      MOVE.L #0,D7                                ; clear the now used address accumulator
002003B4  6000 FDCE                704      BRA MAIN_LOOP
002003B8                           705  
002003B8                           706  W
002003B8  7A00                     707      MOVE.L #0,D5                                ; D5 will be the value to write            
002003BA                           708  
002003BA                           709m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003BA                           710m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003BA                           711m 
002003BA                 TRUE      712m     IFEQ DEBUG
002003BA  1639 00C00003            713m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003C0  0803 0000                714m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003C4  67F4                     715m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003C6                           716m     ENDC
002003C6                           717m     
002003C6                           718mm     READ_CHAR D2
002003C6                 TRUE      719mm     IFEQ DEBUG
002003C6  1439 00C00007            720mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003CC                           721mm     ENDC
002003CC                 FALSE     722mm     IFNE DEBUG
002003CC                           723mm     ENDC
002003CC                           724mm      
002003CC  B43C 001B                725mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003D0  6700 FC36                726mm     BEQ START
002003D4                           727mm     ENDM
002003D4                           728m 
002003D4                 TRUE      729m     IFEQ DEBUG
002003D4                           730mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003D4                           731mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D4                 TRUE      732mm     IFEQ DEBUG
002003D4  1639 00C00003            733mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003DA  0803 0002                734mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003DE  67F4                     735mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003E0  13C2 00C00007            736mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003E6                           737mm     ENDC
002003E6                           738mm     
002003E6                 FALSE     739mm     IFNE DEBUG
002003E6                           740mm     ENDC
002003E6                           741mm 
002003E6                           742mm     ENDM
002003E6                           743m     ENDC
002003E6                           744m     ENDM
002003E6                           745m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003E6  41F9 00200FE6            746m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002003EC  0402 0030                747m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002003F0  C4BC 000000FF            748m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002003F6  1430 2000                749m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002003FA                           750m     ENDM
002003FA  1A02                     751      MOVE.B D2,D5                                ; put at bottom of D5
002003FC                           752  
002003FC  3C3C 0006                753      MOVE #6,D6                                  ; 7 bytes left to read
00200400                           754      
00200400                           755  READ_DATA_TO_POKE
00200400  E98D                     756      LSL.L #4,D5                                 ; make what we have so far more significant
00200402                           757m     WAIT_CHAR D2,D3                             ; next character -> D2
00200402                           758m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200402                           759m 
00200402                 TRUE      760m     IFEQ DEBUG
00200402  1639 00C00003            761m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200408  0803 0000                762m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020040C  67F4                     763m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
0020040E                           764m     ENDC
0020040E                           765m     
0020040E                           766mm     READ_CHAR D2
0020040E                 TRUE      767mm     IFEQ DEBUG
0020040E  1439 00C00007            768mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200414                           769mm     ENDC
00200414                 FALSE     770mm     IFNE DEBUG
00200414                           771mm     ENDC
00200414                           772mm      
00200414  B43C 001B                773mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200418  6700 FBEE                774mm     BEQ START
0020041C                           775mm     ENDM
0020041C                           776m 
0020041C                 TRUE      777m     IFEQ DEBUG
0020041C                           778mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0020041C                           779mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041C                 TRUE      780mm     IFEQ DEBUG
0020041C  1639 00C00003            781mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200422  0803 0002                782mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200426  67F4                     783mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200428  13C2 00C00007            784mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020042E                           785mm     ENDC
0020042E                           786mm     
0020042E                 FALSE     787mm     IFNE DEBUG
0020042E                           788mm     ENDC
0020042E                           789mm 
0020042E                           790mm     ENDM
0020042E                           791m     ENDC
0020042E                           792m     ENDM
0020042E                           793m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0020042E  41F9 00200FE6            794m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200434  0402 0030                795m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200438  C4BC 000000FF            796m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020043E  1430 2000                797m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200442                           798m     ENDM
00200442  8A02                     799      OR.B D2,D5
00200444  023C 00FB                800      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200448  57CE FFB6                801      DBEQ D6,READ_DATA_TO_POKE
0020044C                           802      
0020044C  2047                     803      MOVE.L D7,A0                                ; address accumulator -> address register
0020044E  7E00                     804      MOVE.L #0,D7                                ; clear the now used address accumulator
00200450                           805      
00200450  2085                     806      MOVE.L D5,(A0)                              ; write the data
00200452                           807  
00200452                           808m     PRINT_CRLF D3
00200452                           809mm     PRINT_CHAR #13,D3                           ; CR
00200452                           810mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200452                 TRUE      811mm     IFEQ DEBUG
00200452  1639 00C00003            812mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200458  0803 0002                813mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020045C  67F4                     814mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0020045E  13FC 000D 00C00007       815mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200466                           816mm     ENDC
00200466                           817mm     
00200466                 FALSE     818mm     IFNE DEBUG
00200466                           819mm     ENDC
00200466                           820mm 
00200466                           821mm     ENDM
00200466                           822mm     PRINT_CHAR #10,D3                           ; LF
00200466                           823mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200466                 TRUE      824mm     IFEQ DEBUG
00200466  1639 00C00003            825mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020046C  0803 0002                826mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200470  67F4                     827mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00200472  13FC 000A 00C00007       828mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047A                           829mm     ENDC
0020047A                           830mm     
0020047A                 FALSE     831mm     IFNE DEBUG
0020047A                           832mm     ENDC
0020047A                           833mm 
0020047A                           834mm     ENDM
0020047A                           835m     ENDM
0020047A  6000 FD08                836      BRA MAIN_LOOP
0020047E                           837  
0020047E                           838  ; register map for S
0020047E                           839  ; A0 - start address
0020047E                           840  ; A1 - offset
0020047E                           841  ; A2 - next address to write
0020047E                           842  ; A3 - next location (jmp)
0020047E                           843  ; A4 - Working Address Register
0020047E                           844  ; D0 - record count
0020047E                           845  ; D1 - 'S', record type, data byte
0020047E                           846  ; D2 - checksum
0020047E                           847  ; D3 - data byte count
0020047E                           848  ; D4 - read address, moved into A2
0020047E                           849  ; D5 - temp
0020047E                           850  ; D6 - temp
0020047E                           851  ; D7 - temp
0020047E                           852  S
0020047E  2078 0000                853      MOVE.L 0,A0                                 ; start address -> A0
00200482  2247                     854      MOVE.L D7,A1                                ; grab the address accumulator (offset) into A1
00200484                           855      
00200484  7000                     856      MOVE.L #0,D0                                ; count of records read -> D0
00200486                           857          
00200486                           858  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
00200486                           859m     DOWNLOAD D1                 
00200486                           860m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200486                           861m 
00200486  1239 00C00003            862m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0020048C  0801 0000                863m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200490  6700 0010                864m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00200494                           865m  
00200494                           866mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00200494                 TRUE      867mm     IFEQ DEBUG
00200494  1239 00C00007            868mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
0020049A                           869mm     ENDC
0020049A                 FALSE     870mm     IFNE DEBUG
0020049A                           871mm     ENDC
0020049A                           872mm      
0020049A  B23C 001B                873mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0020049E  6700 FB68                874mm     BEQ START
002004A2                           875mm     ENDM
002004A2                           876m CONTINUE_44
002004A2  1239 00C00013            877m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
002004A8  0801 0000                878m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002004AC  67D8                     879m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004AE                           880m     
002004AE  1239 00C00017            881m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
002004B4  13C1 00E00001            882m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
002004BA                           883m     
002004BA                           884m     ENDM
002004BA  B23C 0053                885      CMP.B #'S',D1                               ; found S?    
002004BE  66C6                     886      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004C0                           887      
002004C0                           888m     PRINT_CHAR #'S',D5                          ; print the S
002004C0                           889m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004C0                 TRUE      890m     IFEQ DEBUG
002004C0  1A39 00C00003            891m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002004C6  0805 0002                892m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002004CA  67F4                     893m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004CC  13FC 0053 00C00007       894m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004D4                           895m     ENDC
002004D4                           896m     
002004D4                 FALSE     897m     IFNE DEBUG
002004D4                           898m     ENDC
002004D4                           899m 
002004D4                           900m     ENDM
002004D4  5280                     901      ADD.L #1,D0                                 ; read another S record, increment count
002004D6                           902      
002004D6                           903m     DOWNLOAD D1                                 ; read the record identifier and echo it back
002004D6                           904m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004D6                           905m 
002004D6  1239 00C00003            906m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
002004DC  0801 0000                907m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002004E0  6700 0010                908m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004E4                           909m  
002004E4                           910mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
002004E4                 TRUE      911mm     IFEQ DEBUG
002004E4  1239 00C00007            912mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
002004EA                           913mm     ENDC
002004EA                 FALSE     914mm     IFNE DEBUG
002004EA                           915mm     ENDC
002004EA                           916mm      
002004EA  B23C 001B                917mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
002004EE  6700 FB18                918mm     BEQ START
002004F2                           919mm     ENDM
002004F2                           920m CONTINUE_47
002004F2  1239 00C00013            921m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
002004F8  0801 0000                922m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002004FC  67D8                     923m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
002004FE                           924m     
002004FE  1239 00C00017            925m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
00200504  13C1 00E00001            926m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
0020050A                           927m     
0020050A                           928m     ENDM
0020050A                           929m     PRINT_CHAR D1,D5
0020050A                           930m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020050A                 TRUE      931m     IFEQ DEBUG
0020050A  1A39 00C00003            932m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200510  0805 0002                933m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200514  67F4                     934m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200516  13C1 00C00007            935m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020051C                           936m     ENDC
0020051C                           937m     
0020051C                 FALSE     938m     IFNE DEBUG
0020051C                           939m     ENDC
0020051C                           940m 
0020051C                           941m     ENDM
0020051C                           942  
0020051C  7400                     943      MOVE.L #0,D2                                ; clear the checksum
0020051E                           944  
0020051E  7600                     945      MOVE.L #0,D3                                ; read the 2 digit byte count -> D3
00200520                           946m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00200520  1E3C 0002                947m     MOVE.B #2,D7
00200524                           948m     WHILE.B D7 <GT> 0 DO
00200524                           949ms _10000000
00200524  BE38 0000                950ms     CMP.B   0,D7
00200528  6F00 0064                951ms     BLE _10000001
0020052C  E98B                     952m         LSL.L #4,D3                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0020052E                           953mm         DOWNLOAD D5
0020052E                           954mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020052E                           955mm 
0020052E  1A39 00C00003            956mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200534  0805 0000                957mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200538  6700 0010                958mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0020053C                           959mm  
0020053C                           960mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0020053C                 TRUE      961mmm     IFEQ DEBUG
0020053C  1A39 00C00007            962mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00200542                           963mmm     ENDC
00200542                 FALSE     964mmm     IFNE DEBUG
00200542                           965mmm     ENDC
00200542                           966mmm      
00200542  BA3C 001B                967mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200546  6700 FAC0                968mmm     BEQ START
0020054A                           969mmm     ENDM
0020054A                           970mm CONTINUE_51
0020054A  1A39 00C00013            971mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200550  0805 0000                972mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200554  67D8                     973mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200556                           974mm     
00200556  1A39 00C00017            975mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0020055C  13C5 00E00001            976mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200562                           977mm     
00200562                           978mm     ENDM
00200562                           979mm         PRINT_CHAR D5,D6
00200562                           980mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200562                 TRUE      981mm     IFEQ DEBUG
00200562  1C39 00C00003            982mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200568  0806 0002                983mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020056C  67F4                     984mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0020056E  13C5 00C00007            985mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200574                           986mm     ENDC
00200574                           987mm     
00200574                 FALSE     988mm     IFNE DEBUG
00200574                           989mm     ENDC
00200574                           990mm 
00200574                           991mm     ENDM
00200574                           992mm         HEX2BIN D5,D5,A4
00200574  49F9 00200FE6            993mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0020057A  0405 0030                994mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020057E  CABC 000000FF            995mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200584  1A34 5000                996mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00200588                           997mm     ENDM
00200588  8605                     998m         OR.B D5,D3
0020058A  5307                     999m         SUB.B #1,D7
0020058C                          1000m     ENDW
0020058C  6096                    1001ms     BRA _10000000
0020058E                          1002ms _10000001
0020058E                          1003m     
0020058E  7A00                    1004m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200590  1A03                    1005m     MOVE.B D3,D5
00200592  D483                    1006m     ADD.L D3,D2
00200594                          1007m 
00200594                          1008m     ENDM
00200594                          1009  
00200594                          1010      IF.B D1 <EQ> #'0' THEN.L                    ; header, just ignore it
00200594  B23C 0030               1011s     CMP.B   #'0',D1
00200598  6600 0032               1012s     BNE.L   _00000000
0020059C                          1013m         PRINT_CRLF D5
0020059C                          1014mm     PRINT_CHAR #13,D5                           ; CR
0020059C                          1015mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020059C                 TRUE     1016mm     IFEQ DEBUG
0020059C  1A39 00C00003           1017mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002005A2  0805 0002               1018mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002005A6  67F4                    1019mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
002005A8  13FC 000D 00C00007      1020mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005B0                          1021mm     ENDC
002005B0                          1022mm     
002005B0                 FALSE    1023mm     IFNE DEBUG
002005B0                          1024mm     ENDC
002005B0                          1025mm 
002005B0                          1026mm     ENDM
002005B0                          1027mm     PRINT_CHAR #10,D5                           ; LF
002005B0                          1028mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B0                 TRUE     1029mm     IFEQ DEBUG
002005B0  1A39 00C00003           1030mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002005B6  0805 0002               1031mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002005BA  67F4                    1032mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005BC  13FC 000A 00C00007      1033mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005C4                          1034mm     ENDC
002005C4                          1035mm     
002005C4                 FALSE    1036mm     IFNE DEBUG
002005C4                          1037mm     ENDC
002005C4                          1038mm 
002005C4                          1039mm     ENDM
002005C4                          1040m     ENDM
002005C4  6000 FEC0               1041          BRA WAIT_FOR_SRECORD
002005C8                          1042      ELSE
002005C8  6000 040A               1043s     BRA _00000001
002005CC                          1044s _00000000
002005CC                          1045          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
002005CC  B23C 0031               1046s     CMP.B   #'1',D1
002005D0  6708                    1047s     BEQ.S   _00000002
002005D2  B23C 0032               1048s     CMP.B   #'2',D1
002005D6  6600 0202               1049s     BNE.L   _00000003
002005DA                          1050s _00000002
002005DA  5783                    1051              SUB.L #3,D3                         ; subtract three bytes for 16 bit address and 1 byte checksum
002005DC                          1052      
002005DC  7800                    1053              MOVE.L #0,D4                        ; read two bytes of address
002005DE                          1054m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
002005DE  1E3C 0002               1055m     MOVE.B #2,D7
002005E2                          1056m     WHILE.B D7 <GT> 0 DO
002005E2                          1057ms _10000002
002005E2  BE38 0000               1058ms     CMP.B   0,D7
002005E6  6F00 0064               1059ms     BLE _10000003
002005EA  E98C                    1060m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002005EC                          1061mm         DOWNLOAD D5
002005EC                          1062mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005EC                          1063mm 
002005EC  1A39 00C00003           1064mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002005F2  0805 0000               1065mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002005F6  6700 0010               1066mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
002005FA                          1067mm  
002005FA                          1068mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002005FA                 TRUE     1069mmm     IFEQ DEBUG
002005FA  1A39 00C00007           1070mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00200600                          1071mmm     ENDC
00200600                 FALSE    1072mmm     IFNE DEBUG
00200600                          1073mmm     ENDC
00200600                          1074mmm      
00200600  BA3C 001B               1075mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200604  6700 FA02               1076mmm     BEQ START
00200608                          1077mmm     ENDM
00200608                          1078mm CONTINUE_59
00200608  1A39 00C00013           1079mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0020060E  0805 0000               1080mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200612  67D8                    1081mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00200614                          1082mm     
00200614  1A39 00C00017           1083mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0020061A  13C5 00E00001           1084mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200620                          1085mm     
00200620                          1086mm     ENDM
00200620                          1087mm         PRINT_CHAR D5,D6
00200620                          1088mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200620                 TRUE     1089mm     IFEQ DEBUG
00200620  1C39 00C00003           1090mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200626  0806 0002               1091mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020062A  67F4                    1092mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
0020062C  13C5 00C00007           1093mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200632                          1094mm     ENDC
00200632                          1095mm     
00200632                 FALSE    1096mm     IFNE DEBUG
00200632                          1097mm     ENDC
00200632                          1098mm 
00200632                          1099mm     ENDM
00200632                          1100mm         HEX2BIN D5,D5,A4
00200632  49F9 00200FE6           1101mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200638  0405 0030               1102mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020063C  CABC 000000FF           1103mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200642  1A34 5000               1104mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00200646                          1105mm     ENDM
00200646  8805                    1106m         OR.B D5,D4
00200648  5307                    1107m         SUB.B #1,D7
0020064A                          1108m     ENDW
0020064A  6096                    1109ms     BRA _10000002
0020064C                          1110ms _10000003
0020064C                          1111m     
0020064C  7A00                    1112m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020064E  1A04                    1113m     MOVE.B D4,D5
00200650  D484                    1114m     ADD.L D4,D2
00200652                          1115m 
00200652                          1116m     ENDM
00200652                          1117m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
00200652  1E3C 0002               1118m     MOVE.B #2,D7
00200656                          1119m     WHILE.B D7 <GT> 0 DO
00200656                          1120ms _10000004
00200656  BE38 0000               1121ms     CMP.B   0,D7
0020065A  6F00 0064               1122ms     BLE _10000005
0020065E  E98C                    1123m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200660                          1124mm         DOWNLOAD D5
00200660                          1125mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200660                          1126mm 
00200660  1A39 00C00003           1127mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200666  0805 0000               1128mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020066A  6700 0010               1129mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0020066E                          1130mm  
0020066E                          1131mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0020066E                 TRUE     1132mmm     IFEQ DEBUG
0020066E  1A39 00C00007           1133mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00200674                          1134mmm     ENDC
00200674                 FALSE    1135mmm     IFNE DEBUG
00200674                          1136mmm     ENDC
00200674                          1137mmm      
00200674  BA3C 001B               1138mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200678  6700 F98E               1139mmm     BEQ START
0020067C                          1140mmm     ENDM
0020067C                          1141mm CONTINUE_64
0020067C  1A39 00C00013           1142mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200682  0805 0000               1143mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200686  67D8                    1144mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00200688                          1145mm     
00200688  1A39 00C00017           1146mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0020068E  13C5 00E00001           1147mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200694                          1148mm     
00200694                          1149mm     ENDM
00200694                          1150mm         PRINT_CHAR D5,D6
00200694                          1151mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200694                 TRUE     1152mm     IFEQ DEBUG
00200694  1C39 00C00003           1153mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020069A  0806 0002               1154mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020069E  67F4                    1155mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006A0  13C5 00C00007           1156mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006A6                          1157mm     ENDC
002006A6                          1158mm     
002006A6                 FALSE    1159mm     IFNE DEBUG
002006A6                          1160mm     ENDC
002006A6                          1161mm 
002006A6                          1162mm     ENDM
002006A6                          1163mm         HEX2BIN D5,D5,A4
002006A6  49F9 00200FE6           1164mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
002006AC  0405 0030               1165mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006B0  CABC 000000FF           1166mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
002006B6  1A34 5000               1167mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
002006BA                          1168mm     ENDM
002006BA  8805                    1169m         OR.B D5,D4
002006BC  5307                    1170m         SUB.B #1,D7
002006BE                          1171m     ENDW
002006BE  6096                    1172ms     BRA _10000004
002006C0                          1173ms _10000005
002006C0                          1174m     
002006C0  7A00                    1175m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006C2  1A04                    1176m     MOVE.B D4,D5
002006C4  D484                    1177m     ADD.L D4,D2
002006C6                          1178m 
002006C6                          1179m     ENDM
002006C6                          1180              
002006C6                          1181              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
002006C6  B23C 0032               1182s     CMP.B   #'2',D1
002006CA  6600 0078               1183s     BNE.L   _00000004
002006CE  5383                    1184                  SUB.L #1,D3                     ; subtract an extra bytes for 24 bit address    
002006D0                          1185m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
002006D0  1E3C 0002               1186m     MOVE.B #2,D7
002006D4                          1187m     WHILE.B D7 <GT> 0 DO
002006D4                          1188ms _10000006
002006D4  BE38 0000               1189ms     CMP.B   0,D7
002006D8  6F00 0064               1190ms     BLE _10000007
002006DC  E98C                    1191m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002006DE                          1192mm         DOWNLOAD D5
002006DE                          1193mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006DE                          1194mm 
002006DE  1A39 00C00003           1195mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002006E4  0805 0000               1196mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002006E8  6700 0010               1197mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
002006EC                          1198mm  
002006EC                          1199mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002006EC                 TRUE     1200mmm     IFEQ DEBUG
002006EC  1A39 00C00007           1201mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
002006F2                          1202mmm     ENDC
002006F2                 FALSE    1203mmm     IFNE DEBUG
002006F2                          1204mmm     ENDC
002006F2                          1205mmm      
002006F2  BA3C 001B               1206mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002006F6  6700 F910               1207mmm     BEQ START
002006FA                          1208mmm     ENDM
002006FA                          1209mm CONTINUE_69
002006FA  1A39 00C00013           1210mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200700  0805 0000               1211mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200704  67D8                    1212mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00200706                          1213mm     
00200706  1A39 00C00017           1214mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0020070C  13C5 00E00001           1215mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200712                          1216mm     
00200712                          1217mm     ENDM
00200712                          1218mm         PRINT_CHAR D5,D6
00200712                          1219mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200712                 TRUE     1220mm     IFEQ DEBUG
00200712  1C39 00C00003           1221mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200718  0806 0002               1222mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020071C  67F4                    1223mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0020071E  13C5 00C00007           1224mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200724                          1225mm     ENDC
00200724                          1226mm     
00200724                 FALSE    1227mm     IFNE DEBUG
00200724                          1228mm     ENDC
00200724                          1229mm 
00200724                          1230mm     ENDM
00200724                          1231mm         HEX2BIN D5,D5,A4
00200724  49F9 00200FE6           1232mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0020072A  0405 0030               1233mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020072E  CABC 000000FF           1234mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200734  1A34 5000               1235mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00200738                          1236mm     ENDM
00200738  8805                    1237m         OR.B D5,D4
0020073A  5307                    1238m         SUB.B #1,D7
0020073C                          1239m     ENDW
0020073C  6096                    1240ms     BRA _10000006
0020073E                          1241ms _10000007
0020073E                          1242m     
0020073E  7A00                    1243m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200740  1A04                    1244m     MOVE.B D4,D5
00200742  D484                    1245m     ADD.L D4,D2
00200744                          1246m 
00200744                          1247m     ENDM
00200744                          1248              ENDI
00200744                          1249s _00000004
00200744                          1250              
00200744  2444                    1251              MOVE.L D4,A2                        ; put the address in an address register
00200746  D5C9                    1252              ADD.L A1,A2                         ; add in the offset
00200748                          1253  
00200748                          1254              WHILE.L D3 <GT> #0 DO               ; read the data bytes                
00200748                          1255s _10000008
00200748  B6BC 00000000           1256s     CMP.L   #0,D3
0020074E  6F00 0080               1257s     BLE _10000009
00200752  7200                    1258                  MOVE.L #0,D1                    ; D1 holds the byte
00200754                          1259m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00200754  1E3C 0002               1260m     MOVE.B #2,D7
00200758                          1261m     WHILE.B D7 <GT> 0 DO
00200758                          1262ms _1000000A
00200758  BE38 0000               1263ms     CMP.B   0,D7
0020075C  6F00 0064               1264ms     BLE _1000000B
00200760  E989                    1265m         LSL.L #4,D1                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200762                          1266mm         DOWNLOAD D5
00200762                          1267mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200762                          1268mm 
00200762  1A39 00C00003           1269mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200768  0805 0000               1270mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020076C  6700 0010               1271mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00200770                          1272mm  
00200770                          1273mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200770                 TRUE     1274mmm     IFEQ DEBUG
00200770  1A39 00C00007           1275mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00200776                          1276mmm     ENDC
00200776                 FALSE    1277mmm     IFNE DEBUG
00200776                          1278mmm     ENDC
00200776                          1279mmm      
00200776  BA3C 001B               1280mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020077A  6700 F88C               1281mmm     BEQ START
0020077E                          1282mmm     ENDM
0020077E                          1283mm CONTINUE_74
0020077E  1A39 00C00013           1284mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200784  0805 0000               1285mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200788  67D8                    1286mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0020078A                          1287mm     
0020078A  1A39 00C00017           1288mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00200790  13C5 00E00001           1289mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200796                          1290mm     
00200796                          1291mm     ENDM
00200796                          1292mm         PRINT_CHAR D5,D6
00200796                          1293mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200796                 TRUE     1294mm     IFEQ DEBUG
00200796  1C39 00C00003           1295mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020079C  0806 0002               1296mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002007A0  67F4                    1297mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
002007A2  13C5 00C00007           1298mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007A8                          1299mm     ENDC
002007A8                          1300mm     
002007A8                 FALSE    1301mm     IFNE DEBUG
002007A8                          1302mm     ENDC
002007A8                          1303mm 
002007A8                          1304mm     ENDM
002007A8                          1305mm         HEX2BIN D5,D5,A4
002007A8  49F9 00200FE6           1306mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
002007AE  0405 0030               1307mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007B2  CABC 000000FF           1308mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
002007B8  1A34 5000               1309mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
002007BC                          1310mm     ENDM
002007BC  8205                    1311m         OR.B D5,D1
002007BE  5307                    1312m         SUB.B #1,D7
002007C0                          1313m     ENDW
002007C0  6096                    1314ms     BRA _1000000A
002007C2                          1315ms _1000000B
002007C2                          1316m     
002007C2  7A00                    1317m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007C4  1A01                    1318m     MOVE.B D1,D5
002007C6  D481                    1319m     ADD.L D1,D2
002007C8                          1320m 
002007C8                          1321m     ENDM
002007C8                          1322                          
002007C8  14C1                    1323                  MOVE.B D1,(A2)+                 ; store it!
002007CA                          1324  
002007CA  5383                    1325                  SUB.L #1,D3                     ; 1 less byte to go
002007CC                          1326              ENDW
002007CC  6000 FF7A               1327s     BRA _10000008
002007D0                          1328s _10000009
002007D0                          1329          
002007D0  47F9 00200486           1330              LEA WAIT_FOR_SRECORD,A3             ; next place to go
002007D6                          1331          ELSE
002007D6  6000 01FC               1332s     BRA _00000005
002007DA                          1333s _00000003
002007DA                          1334              IF.B D1 <EQ> #'8' THEN.L            ; termination record, exit
002007DA  B23C 0038               1335s     CMP.B   #'8',D1
002007DE  6600 016C               1336s     BNE.L   _00000006
002007E2  7800                    1337                  MOVE.L #0,D4                    ; read the 24 bit start address
002007E4                          1338m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
002007E4  1E3C 0002               1339m     MOVE.B #2,D7
002007E8                          1340m     WHILE.B D7 <GT> 0 DO
002007E8                          1341ms _1000000C
002007E8  BE38 0000               1342ms     CMP.B   0,D7
002007EC  6F00 0064               1343ms     BLE _1000000D
002007F0  E98C                    1344m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002007F2                          1345mm         DOWNLOAD D5
002007F2                          1346mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007F2                          1347mm 
002007F2  1A39 00C00003           1348mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002007F8  0805 0000               1349mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002007FC  6700 0010               1350mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
00200800                          1351mm  
00200800                          1352mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200800                 TRUE     1353mmm     IFEQ DEBUG
00200800  1A39 00C00007           1354mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00200806                          1355mmm     ENDC
00200806                 FALSE    1356mmm     IFNE DEBUG
00200806                          1357mmm     ENDC
00200806                          1358mmm      
00200806  BA3C 001B               1359mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020080A  6700 F7FC               1360mmm     BEQ START
0020080E                          1361mmm     ENDM
0020080E                          1362mm CONTINUE_79
0020080E  1A39 00C00013           1363mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200814  0805 0000               1364mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200818  67D8                    1365mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
0020081A                          1366mm     
0020081A  1A39 00C00017           1367mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00200820  13C5 00E00001           1368mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200826                          1369mm     
00200826                          1370mm     ENDM
00200826                          1371mm         PRINT_CHAR D5,D6
00200826                          1372mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200826                 TRUE     1373mm     IFEQ DEBUG
00200826  1C39 00C00003           1374mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020082C  0806 0002               1375mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200830  67F4                    1376mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00200832  13C5 00C00007           1377mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200838                          1378mm     ENDC
00200838                          1379mm     
00200838                 FALSE    1380mm     IFNE DEBUG
00200838                          1381mm     ENDC
00200838                          1382mm 
00200838                          1383mm     ENDM
00200838                          1384mm         HEX2BIN D5,D5,A4
00200838  49F9 00200FE6           1385mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0020083E  0405 0030               1386mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200842  CABC 000000FF           1387mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200848  1A34 5000               1388mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
0020084C                          1389mm     ENDM
0020084C  8805                    1390m         OR.B D5,D4
0020084E  5307                    1391m         SUB.B #1,D7
00200850                          1392m     ENDW
00200850  6096                    1393ms     BRA _1000000C
00200852                          1394ms _1000000D
00200852                          1395m     
00200852  7A00                    1396m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200854  1A04                    1397m     MOVE.B D4,D5
00200856  D484                    1398m     ADD.L D4,D2
00200858                          1399m 
00200858                          1400m     ENDM
00200858                          1401m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00200858  1E3C 0002               1402m     MOVE.B #2,D7
0020085C                          1403m     WHILE.B D7 <GT> 0 DO
0020085C                          1404ms _1000000E
0020085C  BE38 0000               1405ms     CMP.B   0,D7
00200860  6F00 0064               1406ms     BLE _1000000F
00200864  E98C                    1407m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200866                          1408mm         DOWNLOAD D5
00200866                          1409mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200866                          1410mm 
00200866  1A39 00C00003           1411mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020086C  0805 0000               1412mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200870  6700 0010               1413mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00200874                          1414mm  
00200874                          1415mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200874                 TRUE     1416mmm     IFEQ DEBUG
00200874  1A39 00C00007           1417mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0020087A                          1418mmm     ENDC
0020087A                 FALSE    1419mmm     IFNE DEBUG
0020087A                          1420mmm     ENDC
0020087A                          1421mmm      
0020087A  BA3C 001B               1422mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020087E  6700 F788               1423mmm     BEQ START
00200882                          1424mmm     ENDM
00200882                          1425mm CONTINUE_84
00200882  1A39 00C00013           1426mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200888  0805 0000               1427mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020088C  67D8                    1428mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0020088E                          1429mm     
0020088E  1A39 00C00017           1430mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00200894  13C5 00E00001           1431mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0020089A                          1432mm     
0020089A                          1433mm     ENDM
0020089A                          1434mm         PRINT_CHAR D5,D6
0020089A                          1435mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020089A                 TRUE     1436mm     IFEQ DEBUG
0020089A  1C39 00C00003           1437mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002008A0  0806 0002               1438mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002008A4  67F4                    1439mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008A6  13C5 00C00007           1440mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008AC                          1441mm     ENDC
002008AC                          1442mm     
002008AC                 FALSE    1443mm     IFNE DEBUG
002008AC                          1444mm     ENDC
002008AC                          1445mm 
002008AC                          1446mm     ENDM
002008AC                          1447mm         HEX2BIN D5,D5,A4
002008AC  49F9 00200FE6           1448mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
002008B2  0405 0030               1449mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008B6  CABC 000000FF           1450mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
002008BC  1A34 5000               1451mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
002008C0                          1452mm     ENDM
002008C0  8805                    1453m         OR.B D5,D4
002008C2  5307                    1454m         SUB.B #1,D7
002008C4                          1455m     ENDW
002008C4  6096                    1456ms     BRA _1000000E
002008C6                          1457ms _1000000F
002008C6                          1458m     
002008C6  7A00                    1459m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002008C8  1A04                    1460m     MOVE.B D4,D5
002008CA  D484                    1461m     ADD.L D4,D2
002008CC                          1462m 
002008CC                          1463m     ENDM
002008CC                          1464m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
002008CC  1E3C 0002               1465m     MOVE.B #2,D7
002008D0                          1466m     WHILE.B D7 <GT> 0 DO
002008D0                          1467ms _10000010
002008D0  BE38 0000               1468ms     CMP.B   0,D7
002008D4  6F00 0064               1469ms     BLE _10000011
002008D8  E98C                    1470m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002008DA                          1471mm         DOWNLOAD D5
002008DA                          1472mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008DA                          1473mm 
002008DA  1A39 00C00003           1474mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002008E0  0805 0000               1475mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002008E4  6700 0010               1476mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
002008E8                          1477mm  
002008E8                          1478mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002008E8                 TRUE     1479mmm     IFEQ DEBUG
002008E8  1A39 00C00007           1480mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
002008EE                          1481mmm     ENDC
002008EE                 FALSE    1482mmm     IFNE DEBUG
002008EE                          1483mmm     ENDC
002008EE                          1484mmm      
002008EE  BA3C 001B               1485mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002008F2  6700 F714               1486mmm     BEQ START
002008F6                          1487mmm     ENDM
002008F6                          1488mm CONTINUE_89
002008F6  1A39 00C00013           1489mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
002008FC  0805 0000               1490mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200900  67D8                    1491mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00200902                          1492mm     
00200902  1A39 00C00017           1493mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00200908  13C5 00E00001           1494mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0020090E                          1495mm     
0020090E                          1496mm     ENDM
0020090E                          1497mm         PRINT_CHAR D5,D6
0020090E                          1498mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020090E                 TRUE     1499mm     IFEQ DEBUG
0020090E  1C39 00C00003           1500mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200914  0806 0002               1501mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200918  67F4                    1502mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0020091A  13C5 00C00007           1503mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200920                          1504mm     ENDC
00200920                          1505mm     
00200920                 FALSE    1506mm     IFNE DEBUG
00200920                          1507mm     ENDC
00200920                          1508mm 
00200920                          1509mm     ENDM
00200920                          1510mm         HEX2BIN D5,D5,A4
00200920  49F9 00200FE6           1511mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200926  0405 0030               1512mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020092A  CABC 000000FF           1513mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200930  1A34 5000               1514mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00200934                          1515mm     ENDM
00200934  8805                    1516m         OR.B D5,D4
00200936  5307                    1517m         SUB.B #1,D7
00200938                          1518m     ENDW
00200938  6096                    1519ms     BRA _10000010
0020093A                          1520ms _10000011
0020093A                          1521m     
0020093A  7A00                    1522m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020093C  1A04                    1523m     MOVE.B D4,D5
0020093E  D484                    1524m     ADD.L D4,D2
00200940                          1525m 
00200940                          1526m     ENDM
00200940                          1527                    
00200940  2044                    1528                  MOVE.L D4,A0                    ; start address -> A0
00200942                          1529                  
00200942  47F9 00200B1E           1530                  LEA DOWNLOAD_DONE,A3            ; next place to go
00200948                          1531              ELSE
00200948  6000 008A               1532s     BRA _00000007
0020094C                          1533s _00000006
0020094C                          1534m                 PRINT_CRLF D5
0020094C                          1535mm     PRINT_CHAR #13,D5                           ; CR
0020094C                          1536mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020094C                 TRUE     1537mm     IFEQ DEBUG
0020094C  1A39 00C00003           1538mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200952  0805 0002               1539mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200956  67F4                    1540mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00200958  13FC 000D 00C00007      1541mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200960                          1542mm     ENDC
00200960                          1543mm     
00200960                 FALSE    1544mm     IFNE DEBUG
00200960                          1545mm     ENDC
00200960                          1546mm 
00200960                          1547mm     ENDM
00200960                          1548mm     PRINT_CHAR #10,D5                           ; LF
00200960                          1549mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200960                 TRUE     1550mm     IFEQ DEBUG
00200960  1A39 00C00003           1551mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200966  0805 0002               1552mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020096A  67F4                    1553mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0020096C  13FC 000A 00C00007      1554mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200974                          1555mm     ENDC
00200974                          1556mm     
00200974                 FALSE    1557mm     IFNE DEBUG
00200974                          1558mm     ENDC
00200974                          1559mm 
00200974                          1560mm     ENDM
00200974                          1561m     ENDM
00200974                          1562              
00200974  49F9 00200F9B           1563                  LEA UNREC,A4                    ; warn for unrecognised type
0020097A                          1564m                 PRINT_STR A4,D5
0020097A                          1565m LOOP_96
0020097A  0C14 0000               1566m     CMP.B #0,(A4)                               ; 0 -> DONE
0020097E  6700 0016               1567m     BEQ EXIT_96
00200982                          1568mm     PRINT_CHAR (A4)+,D5
00200982                          1569mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200982                 TRUE     1570mm     IFEQ DEBUG
00200982  1A39 00C00003           1571mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200988  0805 0002               1572mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020098C  67F4                    1573mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0020098E  13DC 00C00007           1574mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200994                          1575mm     ENDC
00200994                          1576mm     
00200994                 FALSE    1577mm     IFNE DEBUG
00200994                          1578mm     ENDC
00200994                          1579mm 
00200994                          1580mm     ENDM
00200994  60E4                    1581m     BRA LOOP_96
00200996                          1582m EXIT_96
00200996                          1583m     ENDM
00200996                          1584m                 PRINT_CHAR D1,D5
00200996                          1585m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200996                 TRUE     1586m     IFEQ DEBUG
00200996  1A39 00C00003           1587m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020099C  0805 0002               1588m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009A0  67F4                    1589m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
002009A2  13C1 00C00007           1590m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A8                          1591m     ENDC
002009A8                          1592m     
002009A8                 FALSE    1593m     IFNE DEBUG
002009A8                          1594m     ENDC
002009A8                          1595m 
002009A8                          1596m     ENDM
002009A8                          1597m                 PRINT_CRLF D5
002009A8                          1598mm     PRINT_CHAR #13,D5                           ; CR
002009A8                          1599mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009A8                 TRUE     1600mm     IFEQ DEBUG
002009A8  1A39 00C00003           1601mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009AE  0805 0002               1602mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009B2  67F4                    1603mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
002009B4  13FC 000D 00C00007      1604mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009BC                          1605mm     ENDC
002009BC                          1606mm     
002009BC                 FALSE    1607mm     IFNE DEBUG
002009BC                          1608mm     ENDC
002009BC                          1609mm 
002009BC                          1610mm     ENDM
002009BC                          1611mm     PRINT_CHAR #10,D5                           ; LF
002009BC                          1612mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BC                 TRUE     1613mm     IFEQ DEBUG
002009BC  1A39 00C00003           1614mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009C2  0805 0002               1615mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009C6  67F4                    1616mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
002009C8  13FC 000A 00C00007      1617mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009D0                          1618mm     ENDC
002009D0                          1619mm     
002009D0                 FALSE    1620mm     IFNE DEBUG
002009D0                          1621mm     ENDC
002009D0                          1622mm 
002009D0                          1623mm     ENDM
002009D0                          1624m     ENDM
002009D0                          1625              
002009D0  6000 FAB4               1626                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
002009D4                          1627              ENDI
002009D4                          1628s _00000007
002009D4                          1629          ENDI
002009D4                          1630s _00000005
002009D4                          1631      ENDI
002009D4                          1632s _00000001
002009D4                          1633      
002009D4  7800                    1634      MOVE.L #0,D4                                ; read the checksum from the data stream add to our checksum: should make it FF
002009D6                          1635m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
002009D6  1E3C 0002               1636m     MOVE.B #2,D7
002009DA                          1637m     WHILE.B D7 <GT> 0 DO
002009DA                          1638ms _10000012
002009DA  BE38 0000               1639ms     CMP.B   0,D7
002009DE  6F00 0064               1640ms     BLE _10000013
002009E2  E98C                    1641m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002009E4                          1642mm         DOWNLOAD D5
002009E4                          1643mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009E4                          1644mm 
002009E4  1A39 00C00003           1645mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002009EA  0805 0000               1646mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002009EE  6700 0010               1647mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
002009F2                          1648mm  
002009F2                          1649mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002009F2                 TRUE     1650mmm     IFEQ DEBUG
002009F2  1A39 00C00007           1651mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
002009F8                          1652mmm     ENDC
002009F8                 FALSE    1653mmm     IFNE DEBUG
002009F8                          1654mmm     ENDC
002009F8                          1655mmm      
002009F8  BA3C 001B               1656mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002009FC  6700 F60A               1657mmm     BEQ START
00200A00                          1658mmm     ENDM
00200A00                          1659mm CONTINUE_103
00200A00  1A39 00C00013           1660mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00200A06  0805 0000               1661mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200A0A  67D8                    1662mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00200A0C                          1663mm     
00200A0C  1A39 00C00017           1664mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00200A12  13C5 00E00001           1665mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00200A18                          1666mm     
00200A18                          1667mm     ENDM
00200A18                          1668mm         PRINT_CHAR D5,D6
00200A18                          1669mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A18                 TRUE     1670mm     IFEQ DEBUG
00200A18  1C39 00C00003           1671mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200A1E  0806 0002               1672mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200A22  67F4                    1673mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00200A24  13C5 00C00007           1674mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A2A                          1675mm     ENDC
00200A2A                          1676mm     
00200A2A                 FALSE    1677mm     IFNE DEBUG
00200A2A                          1678mm     ENDC
00200A2A                          1679mm 
00200A2A                          1680mm     ENDM
00200A2A                          1681mm         HEX2BIN D5,D5,A4
00200A2A  49F9 00200FE6           1682mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200A30  0405 0030               1683mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A34  CABC 000000FF           1684mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00200A3A  1A34 5000               1685mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A3E                          1686mm     ENDM
00200A3E  8805                    1687m         OR.B D5,D4
00200A40  5307                    1688m         SUB.B #1,D7
00200A42                          1689m     ENDW
00200A42  6096                    1690ms     BRA _10000012
00200A44                          1691ms _10000013
00200A44                          1692m     
00200A44  7A00                    1693m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200A46  1A04                    1694m     MOVE.B D4,D5
00200A48  D484                    1695m     ADD.L D4,D2
00200A4A                          1696m 
00200A4A                          1697m     ENDM
00200A4A                          1698m     PRINT_CRLF D5
00200A4A                          1699mm     PRINT_CHAR #13,D5                           ; CR
00200A4A                          1700mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4A                 TRUE     1701mm     IFEQ DEBUG
00200A4A  1A39 00C00003           1702mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A50  0805 0002               1703mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A54  67F4                    1704mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A56  13FC 000D 00C00007      1705mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A5E                          1706mm     ENDC
00200A5E                          1707mm     
00200A5E                 FALSE    1708mm     IFNE DEBUG
00200A5E                          1709mm     ENDC
00200A5E                          1710mm 
00200A5E                          1711mm     ENDM
00200A5E                          1712mm     PRINT_CHAR #10,D5                           ; LF
00200A5E                          1713mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A5E                 TRUE     1714mm     IFEQ DEBUG
00200A5E  1A39 00C00003           1715mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A64  0805 0002               1716mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A68  67F4                    1717mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00200A6A  13FC 000A 00C00007      1718mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A72                          1719mm     ENDC
00200A72                          1720mm     
00200A72                 FALSE    1721mm     IFNE DEBUG
00200A72                          1722mm     ENDC
00200A72                          1723mm 
00200A72                          1724mm     ENDM
00200A72                          1725m     ENDM
00200A72                          1726          
00200A72                          1727      IF.B D2 <NE> #$FF THEN.L
00200A72  B43C 00FF               1728s     CMP.B   #$FF,D2
00200A76  6700 00A4               1729s     BEQ.L   _00000008
00200A7A  49F9 00200FB2           1730          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00200A80                          1731m         PRINT_STR A4,D5
00200A80                          1732m LOOP_110
00200A80  0C14 0000               1733m     CMP.B #0,(A4)                               ; 0 -> DONE
00200A84  6700 0016               1734m     BEQ EXIT_110
00200A88                          1735mm     PRINT_CHAR (A4)+,D5
00200A88                          1736mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A88                 TRUE     1737mm     IFEQ DEBUG
00200A88  1A39 00C00003           1738mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A8E  0805 0002               1739mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A92  67F4                    1740mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200A94  13DC 00C00007           1741mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200A9A                          1742mm     ENDC
00200A9A                          1743mm     
00200A9A                 FALSE    1744mm     IFNE DEBUG
00200A9A                          1745mm     ENDC
00200A9A                          1746mm 
00200A9A                          1747mm     ENDM
00200A9A  60E4                    1748m     BRA LOOP_110
00200A9C                          1749m EXIT_110
00200A9C                          1750m     ENDM
00200A9C                          1751m         PRINT_REG D0,D5,D2,D6,A4
00200A9C                          1752mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00200A9C                          1753mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A9C                 TRUE     1754mm     IFEQ DEBUG
00200A9C  1A39 00C00003           1755mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AA2  0805 0002               1756mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AA6  67F4                    1757mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00200AA8  13FC 0030 00C00007      1758mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AB0                          1759mm     ENDC
00200AB0                          1760mm     
00200AB0                 FALSE    1761mm     IFNE DEBUG
00200AB0                          1762mm     ENDC
00200AB0                          1763mm 
00200AB0                          1764mm     ENDM
00200AB0                          1765mm     PRINT_CHAR #'x',D5
00200AB0                          1766mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB0                 TRUE     1767mm     IFEQ DEBUG
00200AB0  1A39 00C00003           1768mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AB6  0805 0002               1769mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200ABA  67F4                    1770mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200ABC  13FC 0078 00C00007      1771mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AC4                          1772mm     ENDC
00200AC4                          1773mm     
00200AC4                 FALSE    1774mm     IFNE DEBUG
00200AC4                          1775mm     ENDC
00200AC4                          1776mm 
00200AC4                          1777mm     ENDM
00200AC4  7C07                    1778m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AC6                          1779m LOOP_112
00200AC6                          1780mm     BIN2HEX D0,D2,A4
00200AC6  49F9 00200FD6           1781mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200ACC  E998                    1782mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200ACE  1400                    1783mm     MOVE.B D0,D2
00200AD0  0282 0000000F           1784mm     ANDI.L #$F,D2
00200AD6  1434 2000               1785mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200ADA                          1786mm     ENDM
00200ADA                          1787mm     PRINT_CHAR D2,D5
00200ADA                          1788mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200ADA                 TRUE     1789mm     IFEQ DEBUG
00200ADA  1A39 00C00003           1790mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AE0  0805 0002               1791mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AE4  67F4                    1792mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200AE6  13C2 00C00007           1793mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AEC                          1794mm     ENDC
00200AEC                          1795mm     
00200AEC                 FALSE    1796mm     IFNE DEBUG
00200AEC                          1797mm     ENDC
00200AEC                          1798mm 
00200AEC                          1799mm     ENDM
00200AEC  57CE FFD8               1800m     DBEQ D6,LOOP_112
00200AF0                          1801m     ENDM
00200AF0                          1802m         PRINT_CRLF D5
00200AF0                          1803mm     PRINT_CHAR #13,D5                           ; CR
00200AF0                          1804mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF0                 TRUE     1805mm     IFEQ DEBUG
00200AF0  1A39 00C00003           1806mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AF6  0805 0002               1807mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AFA  67F4                    1808mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200AFC  13FC 000D 00C00007      1809mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B04                          1810mm     ENDC
00200B04                          1811mm     
00200B04                 FALSE    1812mm     IFNE DEBUG
00200B04                          1813mm     ENDC
00200B04                          1814mm 
00200B04                          1815mm     ENDM
00200B04                          1816mm     PRINT_CHAR #10,D5                           ; LF
00200B04                          1817mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B04                 TRUE     1818mm     IFEQ DEBUG
00200B04  1A39 00C00003           1819mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B0A  0805 0002               1820mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B0E  67F4                    1821mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B10  13FC 000A 00C00007      1822mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B18                          1823mm     ENDC
00200B18                          1824mm     
00200B18                 FALSE    1825mm     IFNE DEBUG
00200B18                          1826mm     ENDC
00200B18                          1827mm 
00200B18                          1828mm     ENDM
00200B18                          1829m     ENDM
00200B18  6000 F66A               1830          BRA MAIN_LOOP
00200B1C                          1831      ENDI
00200B1C                          1832s _00000008
00200B1C                          1833      
00200B1C  4ED3                    1834      JMP (A3)
00200B1E                          1835  DOWNLOAD_DONE
00200B1E                          1836m     PRINT_REG D0,D5,D6,D2,A1                    ; print out number of Srecords read
00200B1E                          1837mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00200B1E                          1838mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B1E                 TRUE     1839mm     IFEQ DEBUG
00200B1E  1A39 00C00003           1840mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B24  0805 0002               1841mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B28  67F4                    1842mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200B2A  13FC 0030 00C00007      1843mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B32                          1844mm     ENDC
00200B32                          1845mm     
00200B32                 FALSE    1846mm     IFNE DEBUG
00200B32                          1847mm     ENDC
00200B32                          1848mm 
00200B32                          1849mm     ENDM
00200B32                          1850mm     PRINT_CHAR #'x',D5
00200B32                          1851mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B32                 TRUE     1852mm     IFEQ DEBUG
00200B32  1A39 00C00003           1853mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B38  0805 0002               1854mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B3C  67F4                    1855mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200B3E  13FC 0078 00C00007      1856mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B46                          1857mm     ENDC
00200B46                          1858mm     
00200B46                 FALSE    1859mm     IFNE DEBUG
00200B46                          1860mm     ENDC
00200B46                          1861mm 
00200B46                          1862mm     ENDM
00200B46  7407                    1863m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B48                          1864m LOOP_120
00200B48                          1865mm     BIN2HEX D0,D6,A1
00200B48  43F9 00200FD6           1866mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200B4E  E998                    1867mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B50  1C00                    1868mm     MOVE.B D0,D6
00200B52  0286 0000000F           1869mm     ANDI.L #$F,D6
00200B58  1C31 6000               1870mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200B5C                          1871mm     ENDM
00200B5C                          1872mm     PRINT_CHAR D6,D5
00200B5C                          1873mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B5C                 TRUE     1874mm     IFEQ DEBUG
00200B5C  1A39 00C00003           1875mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B62  0805 0002               1876mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B66  67F4                    1877mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00200B68  13C6 00C00007           1878mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B6E                          1879mm     ENDC
00200B6E                          1880mm     
00200B6E                 FALSE    1881mm     IFNE DEBUG
00200B6E                          1882mm     ENDC
00200B6E                          1883mm 
00200B6E                          1884mm     ENDM
00200B6E  57CA FFD8               1885m     DBEQ D2,LOOP_120
00200B72                          1886m     ENDM
00200B72  43F9 00200F79           1887      LEA READ,A1
00200B78                          1888m     PRINT_STR A1,D5
00200B78                          1889m LOOP_125
00200B78  0C11 0000               1890m     CMP.B #0,(A1)                               ; 0 -> DONE
00200B7C  6700 0016               1891m     BEQ EXIT_125
00200B80                          1892mm     PRINT_CHAR (A1)+,D5
00200B80                          1893mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B80                 TRUE     1894mm     IFEQ DEBUG
00200B80  1A39 00C00003           1895mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B86  0805 0002               1896mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B8A  67F4                    1897mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200B8C  13D9 00C00007           1898mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200B92                          1899mm     ENDC
00200B92                          1900mm     
00200B92                 FALSE    1901mm     IFNE DEBUG
00200B92                          1902mm     ENDC
00200B92                          1903mm 
00200B92                          1904mm     ENDM
00200B92  60E4                    1905m     BRA LOOP_125
00200B94                          1906m EXIT_125
00200B94                          1907m     ENDM
00200B94  2E08                    1908      MOVE.L A0,D7                                ; set address accumulator to start address
00200B96                          1909m     PRINT_REG D7,D5,D6,D2,A1                    ; print out start address
00200B96                          1910mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00200B96                          1911mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B96                 TRUE     1912mm     IFEQ DEBUG
00200B96  1A39 00C00003           1913mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B9C  0805 0002               1914mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200BA0  67F4                    1915mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200BA2  13FC 0030 00C00007      1916mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BAA                          1917mm     ENDC
00200BAA                          1918mm     
00200BAA                 FALSE    1919mm     IFNE DEBUG
00200BAA                          1920mm     ENDC
00200BAA                          1921mm 
00200BAA                          1922mm     ENDM
00200BAA                          1923mm     PRINT_CHAR #'x',D5
00200BAA                          1924mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BAA                 TRUE     1925mm     IFEQ DEBUG
00200BAA  1A39 00C00003           1926mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200BB0  0805 0002               1927mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200BB4  67F4                    1928mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200BB6  13FC 0078 00C00007      1929mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BBE                          1930mm     ENDC
00200BBE                          1931mm     
00200BBE                 FALSE    1932mm     IFNE DEBUG
00200BBE                          1933mm     ENDC
00200BBE                          1934mm 
00200BBE                          1935mm     ENDM
00200BBE  7407                    1936m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200BC0                          1937m LOOP_127
00200BC0                          1938mm     BIN2HEX D7,D6,A1
00200BC0  43F9 00200FD6           1939mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200BC6  E99F                    1940mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200BC8  1C07                    1941mm     MOVE.B D7,D6
00200BCA  0286 0000000F           1942mm     ANDI.L #$F,D6
00200BD0  1C31 6000               1943mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200BD4                          1944mm     ENDM
00200BD4                          1945mm     PRINT_CHAR D6,D5
00200BD4                          1946mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BD4                 TRUE     1947mm     IFEQ DEBUG
00200BD4  1A39 00C00003           1948mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200BDA  0805 0002               1949mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200BDE  67F4                    1950mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200BE0  13C6 00C00007           1951mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200BE6                          1952mm     ENDC
00200BE6                          1953mm     
00200BE6                 FALSE    1954mm     IFNE DEBUG
00200BE6                          1955mm     ENDC
00200BE6                          1956mm 
00200BE6                          1957mm     ENDM
00200BE6  57CA FFD8               1958m     DBEQ D2,LOOP_127
00200BEA                          1959m     ENDM
00200BEA                          1960m     PRINT_CRLF D5     
00200BEA                          1961mm     PRINT_CHAR #13,D5                           ; CR
00200BEA                          1962mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BEA                 TRUE     1963mm     IFEQ DEBUG
00200BEA  1A39 00C00003           1964mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200BF0  0805 0002               1965mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200BF4  67F4                    1966mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200BF6  13FC 000D 00C00007      1967mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200BFE                          1968mm     ENDC
00200BFE                          1969mm     
00200BFE                 FALSE    1970mm     IFNE DEBUG
00200BFE                          1971mm     ENDC
00200BFE                          1972mm 
00200BFE                          1973mm     ENDM
00200BFE                          1974mm     PRINT_CHAR #10,D5                           ; LF
00200BFE                          1975mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1976mm     IFEQ DEBUG
00200BFE  1A39 00C00003           1977mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200C04  0805 0002               1978mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1979mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00200C0A  13FC 000A 00C00007      1980mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C12                          1981mm     ENDC
00200C12                          1982mm     
00200C12                 FALSE    1983mm     IFNE DEBUG
00200C12                          1984mm     ENDC
00200C12                          1985mm 
00200C12                          1986mm     ENDM
00200C12                          1987m     ENDM
00200C12                          1988          
00200C12  6000 F570               1989      BRA MAIN_LOOP
00200C16                          1990      
00200C16                          1991  G
00200C16  2047                    1992      MOVE.L D7,A0                                ; address accumulator -> address register
00200C18  3E3C 0000               1993      MOVE #0,D7                                  ; clear the now used address accumulator
00200C1C  4ED0                    1994      JMP (A0)                                    ; jump to it!
00200C1E                          1995      
00200C1E                          1996  Z
00200C1E  207C 00200000           1997      MOVE.L #RAM,A0                              ; address of RAM
00200C24  7000                    1998      MOVE.L #0,D0                                ; number of bytes
00200C26                          1999     
00200C26                          2000      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C26                          2001s _10000014
00200C26  B0BC 00040000           2002s     CMP.L   #$40000,D0
00200C2C  6E00 001A               2003s     BGT _10000015
00200C30  2200                    2004          MOVE.L D0,D1                            ; progress update
00200C32  E089                    2005          LSR.L #8,D1 
00200C34  E089                    2006          LSR.L #8,D1
00200C36  0281 0000000F           2007          ANDI.L #$F,D1
00200C3C  13C1 00E00001           2008          MOVE.B D1,DISPLAY
00200C42                          2009  
00200C42  20C0                    2010          MOVE.L D0,(A0)+ 
00200C44  5880                    2011          ADD.L #4,D0
00200C46                          2012      ENDW
00200C46  60DE                    2013s     BRA _10000014
00200C48                          2014s _10000015
00200C48                          2015   
00200C48  207C 00200000           2016      MOVE.L #RAM,A0                              ; address of RAM
00200C4E  7000                    2017      MOVE.L #0,D0                                ; number of bytes
00200C50                          2018     
00200C50                          2019      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C50                          2020s _10000016
00200C50  B0BC 00040000           2021s     CMP.L   #$40000,D0
00200C56  6E00 00C8               2022s     BGT _10000017
00200C5A  2200                    2023          MOVE.L D0,D1                            ; progress update
00200C5C  E089                    2024          LSR.L #8,D1
00200C5E  E089                    2025          LSR.L #8,D1
00200C60  0281 0000000F           2026          ANDI.L #$F,D1
00200C66  13C1 00E00001           2027          MOVE.B D1,DISPLAY
00200C6C                          2028  
00200C6C  2218                    2029          MOVE.L (A0)+,D1
00200C6E                          2030            
00200C6E                          2031          IF.L D0 <EQ> D1 THEN
00200C6E  B081                    2032s     CMP.L   D1,D0
00200C70  6600 0006               2033s     BNE _00000009
00200C74  6000 00A4               2034              BRA OK
00200C78                          2035          ENDI 
00200C78                          2036s _00000009
00200C78                          2037            
00200C78  43F9 00200FC4           2038          LEA RAM_ERROR,A1
00200C7E                          2039m         PRINT_STR A1,D1
00200C7E                          2040m LOOP_135
00200C7E  0C11 0000               2041m     CMP.B #0,(A1)                               ; 0 -> DONE
00200C82  6700 0016               2042m     BEQ EXIT_135
00200C86                          2043mm     PRINT_CHAR (A1)+,D1
00200C86                          2044mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C86                 TRUE     2045mm     IFEQ DEBUG
00200C86  1239 00C00003           2046mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200C8C  0801 0002               2047mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200C90  67F4                    2048mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C92  13D9 00C00007           2049mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200C98                          2050mm     ENDC
00200C98                          2051mm     
00200C98                 FALSE    2052mm     IFNE DEBUG
00200C98                          2053mm     ENDC
00200C98                          2054mm 
00200C98                          2055mm     ENDM
00200C98  60E4                    2056m     BRA LOOP_135
00200C9A                          2057m EXIT_135
00200C9A                          2058m     ENDM
00200C9A  2208                    2059          MOVE.L A0,D1
00200C9C  5981                    2060          SUB.L #4,D1
00200C9E                          2061m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200C9E                          2062mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200C9E                          2063mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C9E                 TRUE     2064mm     IFEQ DEBUG
00200C9E  1639 00C00003           2065mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CA4  0803 0002               2066mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CA8  67F4                    2067mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200CAA  13FC 0030 00C00007      2068mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CB2                          2069mm     ENDC
00200CB2                          2070mm     
00200CB2                 FALSE    2071mm     IFNE DEBUG
00200CB2                          2072mm     ENDC
00200CB2                          2073mm 
00200CB2                          2074mm     ENDM
00200CB2                          2075mm     PRINT_CHAR #'x',D3
00200CB2                          2076mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CB2                 TRUE     2077mm     IFEQ DEBUG
00200CB2  1639 00C00003           2078mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CB8  0803 0002               2079mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CBC  67F4                    2080mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00200CBE  13FC 0078 00C00007      2081mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CC6                          2082mm     ENDC
00200CC6                          2083mm     
00200CC6                 FALSE    2084mm     IFNE DEBUG
00200CC6                          2085mm     ENDC
00200CC6                          2086mm 
00200CC6                          2087mm     ENDM
00200CC6  7C07                    2088m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200CC8                          2089m LOOP_137
00200CC8                          2090mm     BIN2HEX D1,D2,A1
00200CC8  43F9 00200FD6           2091mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200CCE  E999                    2092mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200CD0  1401                    2093mm     MOVE.B D1,D2
00200CD2  0282 0000000F           2094mm     ANDI.L #$F,D2
00200CD8  1431 2000               2095mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200CDC                          2096mm     ENDM
00200CDC                          2097mm     PRINT_CHAR D2,D3
00200CDC                          2098mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CDC                 TRUE     2099mm     IFEQ DEBUG
00200CDC  1639 00C00003           2100mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CE2  0803 0002               2101mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CE6  67F4                    2102mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200CE8  13C2 00C00007           2103mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CEE                          2104mm     ENDC
00200CEE                          2105mm     
00200CEE                 FALSE    2106mm     IFNE DEBUG
00200CEE                          2107mm     ENDC
00200CEE                          2108mm 
00200CEE                          2109mm     ENDM
00200CEE  57CE FFD8               2110m     DBEQ D6,LOOP_137
00200CF2                          2111m     ENDM
00200CF2                          2112m         PRINT_CRLF D3
00200CF2                          2113mm     PRINT_CHAR #13,D3                           ; CR
00200CF2                          2114mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CF2                 TRUE     2115mm     IFEQ DEBUG
00200CF2  1639 00C00003           2116mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CF8  0803 0002               2117mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CFC  67F4                    2118mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00200CFE  13FC 000D 00C00007      2119mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D06                          2120mm     ENDC
00200D06                          2121mm     
00200D06                 FALSE    2122mm     IFNE DEBUG
00200D06                          2123mm     ENDC
00200D06                          2124mm 
00200D06                          2125mm     ENDM
00200D06                          2126mm     PRINT_CHAR #10,D3                           ; LF
00200D06                          2127mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D06                 TRUE     2128mm     IFEQ DEBUG
00200D06  1639 00C00003           2129mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D0C  0803 0002               2130mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D10  67F4                    2131mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200D12  13FC 000A 00C00007      2132mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D1A                          2133mm     ENDC
00200D1A                          2134mm     
00200D1A                 FALSE    2135mm     IFNE DEBUG
00200D1A                          2136mm     ENDC
00200D1A                          2137mm 
00200D1A                          2138mm     ENDM
00200D1A                          2139m     ENDM
00200D1A                          2140  OK    
00200D1A  5880                    2141          ADD.L #4,D0
00200D1C                          2142      ENDW
00200D1C  6000 FF32               2143s     BRA _10000016
00200D20                          2144s _10000017
00200D20                          2145      
00200D20  6000 F462               2146      BRA MAIN_LOOP
00200D24                          2147    
00200D24                          2148  L
00200D24  7A00                    2149      MOVE.L #0,D5                                ; D5 will be the length  to write            
00200D26                          2150  
00200D26                          2151m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200D26                          2152m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D26                          2153m 
00200D26                 TRUE     2154m     IFEQ DEBUG
00200D26  1639 00C00003           2155m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D2C  0803 0000               2156m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200D30  67F4                    2157m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00200D32                          2158m     ENDC
00200D32                          2159m     
00200D32                          2160mm     READ_CHAR D2
00200D32                 TRUE     2161mm     IFEQ DEBUG
00200D32  1439 00C00007           2162mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D38                          2163mm     ENDC
00200D38                 FALSE    2164mm     IFNE DEBUG
00200D38                          2165mm     ENDC
00200D38                          2166mm      
00200D38  B43C 001B               2167mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D3C  6700 F2CA               2168mm     BEQ START
00200D40                          2169mm     ENDM
00200D40                          2170m 
00200D40                 TRUE     2171m     IFEQ DEBUG
00200D40                          2172mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200D40                          2173mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D40                 TRUE     2174mm     IFEQ DEBUG
00200D40  1639 00C00003           2175mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D46  0803 0002               2176mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D4A  67F4                    2177mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00200D4C  13C2 00C00007           2178mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D52                          2179mm     ENDC
00200D52                          2180mm     
00200D52                 FALSE    2181mm     IFNE DEBUG
00200D52                          2182mm     ENDC
00200D52                          2183mm 
00200D52                          2184mm     ENDM
00200D52                          2185m     ENDC
00200D52                          2186m     ENDM
00200D52                          2187m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200D52  41F9 00200FE6           2188m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D58  0402 0030               2189m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D5C  C4BC 000000FF           2190m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D62  1430 2000               2191m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D66                          2192m     ENDM
00200D66  1A02                    2193      MOVE.B D2,D5                                ; put at bottom of D5
00200D68                          2194  
00200D68  3C3C 0002               2195      MOVE #2,D6                                  ; 3 bytes left to read
00200D6C                          2196      
00200D6C                          2197  READ_LENGTH
00200D6C  E98D                    2198      LSL.L #4,D5                                 ; make what we have so far more significant
00200D6E                          2199m     WAIT_CHAR D2,D3                             ; next character -> D2
00200D6E                          2200m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D6E                          2201m 
00200D6E                 TRUE     2202m     IFEQ DEBUG
00200D6E  1639 00C00003           2203m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D74  0803 0000               2204m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200D78  67F4                    2205m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00200D7A                          2206m     ENDC
00200D7A                          2207m     
00200D7A                          2208mm     READ_CHAR D2
00200D7A                 TRUE     2209mm     IFEQ DEBUG
00200D7A  1439 00C00007           2210mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D80                          2211mm     ENDC
00200D80                 FALSE    2212mm     IFNE DEBUG
00200D80                          2213mm     ENDC
00200D80                          2214mm      
00200D80  B43C 001B               2215mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D84  6700 F282               2216mm     BEQ START
00200D88                          2217mm     ENDM
00200D88                          2218m 
00200D88                 TRUE     2219m     IFEQ DEBUG
00200D88                          2220mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200D88                          2221mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D88                 TRUE     2222mm     IFEQ DEBUG
00200D88  1639 00C00003           2223mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D8E  0803 0002               2224mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D92  67F4                    2225mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00200D94  13C2 00C00007           2226mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D9A                          2227mm     ENDC
00200D9A                          2228mm     
00200D9A                 FALSE    2229mm     IFNE DEBUG
00200D9A                          2230mm     ENDC
00200D9A                          2231mm 
00200D9A                          2232mm     ENDM
00200D9A                          2233m     ENDC
00200D9A                          2234m     ENDM
00200D9A                          2235m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200D9A  41F9 00200FE6           2236m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DA0  0402 0030               2237m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DA4  C4BC 000000FF           2238m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DAA  1430 2000               2239m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DAE                          2240m     ENDM
00200DAE  8A02                    2241      OR.B D2,D5
00200DB0  023C 00FB               2242      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200DB4  57CE FFB6               2243      DBEQ D6,READ_LENGTH
00200DB8                          2244          
00200DB8                          2245m     PRINT_CRLF D3
00200DB8                          2246mm     PRINT_CHAR #13,D3                           ; CR
00200DB8                          2247mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DB8                 TRUE     2248mm     IFEQ DEBUG
00200DB8  1639 00C00003           2249mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DBE  0803 0002               2250mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DC2  67F4                    2251mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200DC4  13FC 000D 00C00007      2252mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DCC                          2253mm     ENDC
00200DCC                          2254mm     
00200DCC                 FALSE    2255mm     IFNE DEBUG
00200DCC                          2256mm     ENDC
00200DCC                          2257mm 
00200DCC                          2258mm     ENDM
00200DCC                          2259mm     PRINT_CHAR #10,D3                           ; LF
00200DCC                          2260mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DCC                 TRUE     2261mm     IFEQ DEBUG
00200DCC  1639 00C00003           2262mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DD2  0803 0002               2263mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DD6  67F4                    2264mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00200DD8  13FC 000A 00C00007      2265mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DE0                          2266mm     ENDC
00200DE0                          2267mm     
00200DE0                 FALSE    2268mm     IFNE DEBUG
00200DE0                          2269mm     ENDC
00200DE0                          2270mm 
00200DE0                          2271mm     ENDM
00200DE0                          2272m     ENDM
00200DE0                          2273  
00200DE0  207C 00000000           2274      MOVE.L #ROM,A0                              ; start of ROM
00200DE6                          2275      
00200DE6  2247                    2276      MOVE.L D7,A1                                ; address accumulator -> address register
00200DE8  7E00                    2277      MOVE.L #0,D7                                ; clear the now used address accumulator
00200DEA                          2278      
00200DEA  267C 00002AAA           2279      MOVE.L #$2AAA,A3
00200DF0  36BC AAAA               2280      MOVE.W #$AAAA,(A3)
00200DF4  267C 00001554           2281      MOVE.L #$1554,A3
00200DFA  36BC 5555               2282      MOVE.W #$5555,(A3)
00200DFE  267C 00002AAA           2283      MOVE.L #$2AAA,A3
00200E04  36BC 8080               2284      MOVE.W #$8080,(A3)
00200E08  267C 00002AAA           2285      MOVE.L #$2AAA,A3
00200E0E  36BC AAAA               2286      MOVE.W #$AAAA,(A3)
00200E12  267C 00001554           2287      MOVE.L #$1554,A3
00200E18  36BC 5555               2288      MOVE.W #$5555,(A3)
00200E1C  267C 00002AAA           2289      MOVE.L #$2AAA,A3
00200E22  36BC 2020               2290      MOVE.W #$2020,(A3)
00200E26                          2291      
00200E26  45F9 00200FFD           2292      LEA LOADING,A2                              ; important for timing
00200E2C                          2293m     PRINT_STR A2,D3
00200E2C                          2294m LOOP_156
00200E2C  0C12 0000               2295m     CMP.B #0,(A2)                               ; 0 -> DONE
00200E30  6700 0016               2296m     BEQ EXIT_156
00200E34                          2297mm     PRINT_CHAR (A2)+,D3
00200E34                          2298mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E34                 TRUE     2299mm     IFEQ DEBUG
00200E34  1639 00C00003           2300mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E3A  0803 0002               2301mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E3E  67F4                    2302mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200E40  13DA 00C00007           2303mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200E46                          2304mm     ENDC
00200E46                          2305mm     
00200E46                 FALSE    2306mm     IFNE DEBUG
00200E46                          2307mm     ENDC
00200E46                          2308mm 
00200E46                          2309mm     ENDM
00200E46  60E4                    2310m     BRA LOOP_156
00200E48                          2311m EXIT_156
00200E48                          2312m     ENDM
00200E48                          2313  
00200E48  023C 00FB               2314      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200E4C                          2315      
00200E4C                          2316      WHILE D5 <GT> #0 DO
00200E4C                          2317s _10000018
00200E4C  BA7C 0000               2318s     CMP.W   #0,D5
00200E50  6F00 001C               2319s     BLE _10000019
00200E54  5585                    2320          SUB.L #2,D5
00200E56                          2321            
00200E56  13D1 00E00001           2322          MOVE.B (A1),DISPLAY
00200E5C  3091                    2323          MOVE.W (A1),(A0)                        ; write the data
00200E5E                          2324        
00200E5E                          2325  WAIT_FOR_COMPLETE
00200E5E  3410                    2326          MOVE.W (A0),D2
00200E60                          2327  
00200E60                          2328          IF D2 <NE> (A1) THEN
00200E60  B451                    2329s     CMP.W   (A1),D2
00200E62  6700 0004               2330s     BEQ _0000000A
00200E66  60F6                    2331              BRA WAIT_FOR_COMPLETE
00200E68                          2332          ENDI
00200E68                          2333s _0000000A
00200E68                          2334        
00200E68  5488                    2335          ADD.L #2,A0
00200E6A  5489                    2336          ADD.L #2,A1
00200E6C                          2337      ENDW  
00200E6C  60DE                    2338s     BRA _10000018
00200E6E                          2339s _10000019
00200E6E                          2340      
00200E6E  267C 00002AAA           2341      MOVE.L #$2AAA,A3
00200E74  36BC AAAA               2342      MOVE.W #$AAAA,(A3)
00200E78  267C 00001554           2343      MOVE.L #$1554,A3
00200E7E  36BC 5555               2344      MOVE.W #$5555,(A3)
00200E82  267C 00002AAA           2345      MOVE.L #$2AAA,A3
00200E88  36BC A0A0               2346      MOVE.W #$A0A0,(A3)
00200E8C                          2347              
00200E8C  6000 F2F6               2348      BRA MAIN_LOOP
00200E90                          2349          
00200E90                          2350  HEX_DIGIT
00200E90  E98F                    2351      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200E92                          2352m     HEX2BIN D2,D2,A0
00200E92  41F9 00200FE6           2353m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200E98  0402 0030               2354m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E9C  C4BC 000000FF           2355m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EA2  1430 2000               2356m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EA6                          2357m     ENDM
00200EA6  8E02                    2358      OR.B D2,D7  
00200EA8  6000 F302               2359      BRA GET_INPUT
00200EAC                          2360  
00200EAC  FFFF FFFF               2361      SIMHALT                                     ; halt simulator
00200EB0                          2362  
00200EB0                          2363  ; strings
00200EB0= 4D 44 46 2D 6D 6F ...   2364  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',13,10,0
00200ECD= 3F 20 48 65 6C 70 ...   2365  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00200F72= 48 75 68 3F 0D 0A 00    2366  HUH     DC.B 'Huh?',13,10,0
00200F79= 20 53 20 72 65 63 ...   2367  READ    DC.B ' S records read, start address = ',0
00200F9B= 57 3A 20 55 6E 6B ...   2368  UNREC   DC.B 'W: Unknown Srec type: ',0
00200FB2= 57 3A 20 43 53 20 ...   2369  CS_FAILURE   DC.B 'W: CS failure at ',0
00200FC4= 57 3A 20 52 41 4D ...   2370  RAM_ERROR DC.B 'W: RAM error at: ',0
00200FD6= 30 31 32 33 34 35 ...   2371  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00200FE6= 00 01 02 03 04 05 ...   2372  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00200FFD= 4C 6F 61 64 69 6E ...   2373  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201011                          2374      
00201011                          2375      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200FD6
CONTINUE_103        200A00
CONTINUE_44         2004A2
CONTINUE_47         2004F2
CONTINUE_51         20054A
CONTINUE_59         200608
CONTINUE_64         20067C
CONTINUE_69         2006FA
CONTINUE_74         20077E
CONTINUE_79         20080E
CONTINUE_84         200882
CONTINUE_89         2008F6
CS_FAILURE          200FB2
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       200B1E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            200A9C
EXIT_125            200B94
EXIT_135            200C9A
EXIT_156            200E48
EXIT_19             2002E2
EXIT_21             200308
EXIT_23             20032E
EXIT_5              20013E
EXIT_96             200996
G                   200C16
GET_INPUT           2001AC
H                   2002E6
HELP                200ECD
HEX2BIN             134
HEX2BIN_LUT         200FE6
HEX_DIGIT           200E90
HUH                 200F72
L                   200D24
LOADING             200FFD
LOOP_110            200A80
LOOP_112            200AC6
LOOP_120            200B48
LOOP_125            200B78
LOOP_127            200BC0
LOOP_135            200C7E
LOOP_137            200CC8
LOOP_156            200E2C
LOOP_19             2002C6
LOOP_21             2002EC
LOOP_23             200312
LOOP_25             200360
LOOP_5              200122
LOOP_96             20097A
MAIN_LOOP           200184
OK                  200D1A
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200332
RAM                 200000
RAM_ERROR           200FC4
READ                200F79
READ_CHAR           805
READ_DATA_TO_POKE   200400
READ_LENGTH         200D6C
RESET               200004
ROM                 0
S                   20047E
STACK               200000
START               200008
UNREC               200F9B
V                   20030C
VERSION             200EB0
W                   2003B8
WAIT_CHAR           665
WAIT_FOR_COMPLETE   200E5E
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   200166
WAIT_FOR_READY_100  2009A8
WAIT_FOR_READY_101  2009BC
WAIT_FOR_READY_103  2009E4
WAIT_FOR_READY_105  200A18
WAIT_FOR_READY_108  200A4A
WAIT_FOR_READY_109  200A5E
WAIT_FOR_READY_11   200184
WAIT_FOR_READY_111  200A88
WAIT_FOR_READY_113  200A9C
WAIT_FOR_READY_114  200AB0
WAIT_FOR_READY_116  200ADA
WAIT_FOR_READY_118  200AF0
WAIT_FOR_READY_119  200B04
WAIT_FOR_READY_12   200198
WAIT_FOR_READY_121  200B1E
WAIT_FOR_READY_122  200B32
WAIT_FOR_READY_124  200B5C
WAIT_FOR_READY_126  200B80
WAIT_FOR_READY_128  200B96
WAIT_FOR_READY_129  200BAA
WAIT_FOR_READY_13   2001AC
WAIT_FOR_READY_131  200BD4
WAIT_FOR_READY_133  200BEA
WAIT_FOR_READY_134  200BFE
WAIT_FOR_READY_136  200C86
WAIT_FOR_READY_138  200C9E
WAIT_FOR_READY_139  200CB2
WAIT_FOR_READY_141  200CDC
WAIT_FOR_READY_143  200CF2
WAIT_FOR_READY_144  200D06
WAIT_FOR_READY_145  200D26
WAIT_FOR_READY_147  200D40
WAIT_FOR_READY_149  200D6E
WAIT_FOR_READY_15   2001C6
WAIT_FOR_READY_151  200D88
WAIT_FOR_READY_154  200DB8
WAIT_FOR_READY_155  200DCC
WAIT_FOR_READY_157  200E34
WAIT_FOR_READY_17   200268
WAIT_FOR_READY_18   20027C
WAIT_FOR_READY_20   2002CE
WAIT_FOR_READY_22   2002F4
WAIT_FOR_READY_24   20031A
WAIT_FOR_READY_26   200336
WAIT_FOR_READY_27   20034A
WAIT_FOR_READY_29   200374
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   20038A
WAIT_FOR_READY_32   20039E
WAIT_FOR_READY_33   2003BA
WAIT_FOR_READY_35   2003D4
WAIT_FOR_READY_37   200402
WAIT_FOR_READY_39   20041C
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   200452
WAIT_FOR_READY_43   200466
WAIT_FOR_READY_44   200486
WAIT_FOR_READY_46   2004C0
WAIT_FOR_READY_47   2004D6
WAIT_FOR_READY_49   20050A
WAIT_FOR_READY_51   20052E
WAIT_FOR_READY_53   200562
WAIT_FOR_READY_56   20059C
WAIT_FOR_READY_57   2005B0
WAIT_FOR_READY_59   2005EC
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   200620
WAIT_FOR_READY_64   200660
WAIT_FOR_READY_66   200694
WAIT_FOR_READY_69   2006DE
WAIT_FOR_READY_71   200712
WAIT_FOR_READY_74   200762
WAIT_FOR_READY_76   200796
WAIT_FOR_READY_79   2007F2
WAIT_FOR_READY_8    20013E
WAIT_FOR_READY_81   200826
WAIT_FOR_READY_84   200866
WAIT_FOR_READY_86   20089A
WAIT_FOR_READY_89   2008DA
WAIT_FOR_READY_9    200152
WAIT_FOR_READY_91   20090E
WAIT_FOR_READY_94   20094C
WAIT_FOR_READY_95   200960
WAIT_FOR_READY_97   200982
WAIT_FOR_READY_98   200996
WAIT_FOR_SRECORD    200486
Z                   200C1E
_00000000           2005CC
_00000001           2009D4
_00000002           2005DA
_00000003           2007DA
_00000004           200744
_00000005           2009D4
_00000006           20094C
_00000007           2009D4
_00000008           200B1C
_00000009           200C78
_0000000A           200E68
_10000000           200524
_10000001           20058E
_10000002           2005E2
_10000003           20064C
_10000004           200656
_10000005           2006C0
_10000006           2006D4
_10000007           20073E
_10000008           200748
_10000009           2007D0
_1000000A           200758
_1000000B           2007C2
_1000000C           2007E8
_1000000D           200852
_1000000E           20085C
_1000000F           2008C6
_10000010           2008D0
_10000011           20093A
_10000012           2009DA
_10000013           200A44
_10000014           200C26
_10000015           200C48
_10000016           200C50
_10000017           200D20
_10000018           200E4C
_10000019           200E6E
