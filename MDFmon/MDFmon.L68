00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 17:26:59

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ORG  $0
00000000                            21      ;ORG  $200000
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF,\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      PRINT_CHAR #'0',\2                              ;0x header
00000000                           143      PRINT_CHAR #'x',\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  
00000000                           227  ; register catalogue
00000000                           228  ; D0 - used for simulator I/O
00000000                           229  ; D1 - used for simulator I/O
00000000                           230  ; D2 - read character
00000000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           232  ; D6 - working register used in R/W
00000000                           233  ; D7 - address accumulator, reset by download
00000000                           234  ; A0 - address of string to print 
00000000                           235  
00000000                           236  ; start vector
00000000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 238  RESET    DC.L START                             ; RESET
00000008                           239      
00000008                           240  ; start of program  
00000008                           241  START
00000008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00000010                           243  
00000010                           244  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                           ; reset everyting
00000020  4E71                     247      NOP
00000022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     249      NOP
0000002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00000034  4E71                     251      NOP
00000036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0000003E  4E71                     253      NOP
00000040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00000048                           255  
00000048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                           ; reset everyting
00000058  4E71                     258      NOP
0000005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00000062  4E71                     260      NOP
00000064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0000006C  4E71                     262      NOP
0000006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00000076  4E71                     264      NOP
00000078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00000080                           266  
00000080                           267  ;initialise UART
00000080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00000098                           271  
00000098                           272  ; channel A
00000098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
000000A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
000000B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000000B8                           277  
000000B8                           278  ; channel B
000000B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000D8                           283  
000000D8                           284m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      286m     IFEQ DEBUG
000000D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           291m     ENDC
000000EC                           292m     
000000EC                 FALSE     293m     IFNE DEBUG
000000EC                           294m     ENDC
000000EC                           295m 
000000EC                           296m     ENDM
000000EC                           297  
000000EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
000000F4                           299         
000000F4                           300m     PRINT_CRLF D3,A0
000000F4  41F9 00000E9C            301m     LEA CRLF,A0
000000FA                           302mm     PRINT_STR A0,D3
000000FA                           303mm LOOP_3
000000FA  0C10 0000                304mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FE  6700 0016                305mm     BEQ EXIT_3
00000102                           306mmm     PRINT_CHAR (A0)+,D3
00000102                           307mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000102                 TRUE      308mmm     IFEQ DEBUG
00000102  1639 00C00003            309mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000108  0803 0002                310mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010C  67F4                     311mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
0000010E  13D8 00C00007            312mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000114                           313mmm     ENDC
00000114                           314mmm     
00000114                 FALSE     315mmm     IFNE DEBUG
00000114                           316mmm     ENDC
00000114                           317mmm 
00000114                           318mmm     ENDM
00000114  60E4                     319mm     BRA LOOP_3
00000116                           320mm EXIT_3
00000116                           321mm     ENDM
00000116                           322m     ENDM
00000116                           323  
00000116  41F9 00000D30            324      LEA VERSION,A0
0000011C                           325m     PRINT_STR A0,D3
0000011C                           326m LOOP_5
0000011C  0C10 0000                327m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000120  6700 0016                328m     BEQ EXIT_5
00000124                           329mm     PRINT_CHAR (A0)+,D3
00000124                           330mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000124                 TRUE      331mm     IFEQ DEBUG
00000124  1639 00C00003            332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000012A  0803 0002                333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012E  67F4                     334mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000130  13D8 00C00007            335mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000136                           336mm     ENDC
00000136                           337mm     
00000136                 FALSE     338mm     IFNE DEBUG
00000136                           339mm     ENDC
00000136                           340mm 
00000136                           341mm     ENDM
00000136  60E4                     342m     BRA LOOP_5
00000138                           343m EXIT_5
00000138                           344m     ENDM
00000138                           345m     PRINT_CRLF D3,A0
00000138  41F9 00000E9C            346m     LEA CRLF,A0
0000013E                           347mm     PRINT_STR A0,D3
0000013E                           348mm LOOP_8
0000013E  0C10 0000                349mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                350mm     BEQ EXIT_8
00000146                           351mmm     PRINT_CHAR (A0)+,D3
00000146                           352mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      353mmm     IFEQ DEBUG
00000146  1639 00C00003            354mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                355mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     356mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            357mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           358mmm     ENDC
00000158                           359mmm     
00000158                 FALSE     360mmm     IFNE DEBUG
00000158                           361mmm     ENDC
00000158                           362mmm 
00000158                           363mmm     ENDM
00000158  60E4                     364mm     BRA LOOP_8
0000015A                           365mm EXIT_8
0000015A                           366mm     ENDM
0000015A                           367m     ENDM
0000015A                           368  
0000015A  7E00                     369      MOVE.L #0,D7                                    ; address accumulator
0000015C                           370  
0000015C  13FC 0002 00E00001       371      MOVE.B #2,DISPLAY
00000164                           372  MAIN_LOOP
00000164                           373m     PRINT_CHAR #'>',D3                          ; prompt
00000164                           374m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000164                 TRUE      375m     IFEQ DEBUG
00000164  1639 00C00003            376m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016A  0803 0002                377m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000016E  67F4                     378m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000170  13FC 003E 00C00007       379m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000178                           380m     ENDC
00000178                           381m     
00000178                 FALSE     382m     IFNE DEBUG
00000178                           383m     ENDC
00000178                           384m 
00000178                           385m     ENDM
00000178                           386m     PRINT_CHAR #32,D3                           ; space
00000178                           387m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      388m     IFEQ DEBUG
00000178  1639 00C00003            389m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                390m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     391m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000184  13FC 0020 00C00007       392m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000018C                           393m     ENDC
0000018C                           394m     
0000018C                 FALSE     395m     IFNE DEBUG
0000018C                           396m     ENDC
0000018C                           397m 
0000018C                           398m     ENDM
0000018C                           399      
0000018C                           400  GET_INPUT
0000018C                           401m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000018C                           402m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000018C                 TRUE      403m     IFEQ DEBUG
0000018C  1639 00C00003            404m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000192  0803 0000                405m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000196  67F4                     406m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000198                           407m     ENDC
00000198                           408m     
00000198                           409mm     READ_CHAR D2
00000198                 TRUE      410mm     IFEQ DEBUG
00000198  1439 00C00007            411mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000019E                           412mm     ENDC
0000019E                 FALSE     413mm     IFNE DEBUG
0000019E                           414mm     ENDC
0000019E                           415mm      
0000019E  B43C 001B                416mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001A2  6700 FE64                417mm     BEQ START
000001A6                           418mm     ENDM
000001A6                           419m 
000001A6                 TRUE      420m     IFEQ DEBUG
000001A6                           421mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001A6                           422mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001A6                 TRUE      423mm     IFEQ DEBUG
000001A6  1639 00C00003            424mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001AC  0803 0002                425mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001B0  67F4                     426mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
000001B2  13C2 00C00007            427mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001B8                           428mm     ENDC
000001B8                           429mm     
000001B8                 FALSE     430mm     IFNE DEBUG
000001B8                           431mm     ENDC
000001B8                           432mm 
000001B8                           433mm     ENDM
000001B8                           434m     ENDC
000001B8                           435m     ENDM
000001B8                           436      
000001B8                           437      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001B8  B43C 0030                438s     CMP.B   #'0',D2
000001BC  6D00 000E                439s     BLT _00000000
000001C0  B43C 0039                440s     CMP.B   #'9',D2
000001C4  6E00 0006                441s     BGT _00000000
000001C8  6000 0B46                442          BRA HEX_DIGIT
000001CC                           443      ENDI
000001CC                           444s _00000000
000001CC                           445      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001CC  B43C 0041                446s     CMP.B   #'A',D2
000001D0  6D00 000E                447s     BLT _00000001
000001D4  B43C 0046                448s     CMP.B   #'F',D2
000001D8  6E00 0006                449s     BGT _00000001
000001DC  6000 0B32                450          BRA HEX_DIGIT
000001E0                           451      ENDI
000001E0                           452s _00000001
000001E0                           453          
000001E0  B43C 0077                454      CMP.B #'w',D2
000001E4  6700 0132                455      BEQ W
000001E8                           456      
000001E8  B43C 006C                457      CMP.B #'l',D2
000001EC  6700 0A22                458      BEQ L 
000001F0                           459  
000001F0                           460m     PRINT_CRLF D3,A0
000001F0  41F9 00000E9C            461m     LEA CRLF,A0
000001F6                           462mm     PRINT_STR A0,D3
000001F6                           463mm LOOP_16
000001F6  0C10 0000                464mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001FA  6700 0016                465mm     BEQ EXIT_16
000001FE                           466mmm     PRINT_CHAR (A0)+,D3
000001FE                           467mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001FE                 TRUE      468mmm     IFEQ DEBUG
000001FE  1639 00C00003            469mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000204  0803 0002                470mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000208  67F4                     471mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0000020A  13D8 00C00007            472mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000210                           473mmm     ENDC
00000210                           474mmm     
00000210                 FALSE     475mmm     IFNE DEBUG
00000210                           476mmm     ENDC
00000210                           477mmm 
00000210                           478mmm     ENDM
00000210  60E4                     479mm     BRA LOOP_16
00000212                           480mm EXIT_16
00000212                           481mm     ENDM
00000212                           482m     ENDM
00000212                           483   
00000212  B43C 003F                484      CMP.B #'?',D2
00000216  6700 0050                485      BEQ H
0000021A                           486  
0000021A  B43C 0076                487      CMP.B #'v',D2
0000021E  6700 0052                488      BEQ V
00000222                           489      
00000222  B43C 0072                490      CMP.B #'r',D2
00000226  6700 0070                491      BEQ R
0000022A                           492  
0000022A  B43C 0073                493      CMP.B #'s',D2
0000022E  6700 0166                494      BEQ S
00000232                           495  
00000232  B43C 0067                496      CMP.B #'g',D2
00000236  6700 08D0                497      BEQ G   
0000023A                           498  
0000023A  B43C 007A                499      CMP.B #'z',D2
0000023E  6700 08D0                500      BEQ Z   
00000242                           501  
00000242  41F9 00000DFD            502      LEA HUH,A0
00000248                           503m     PRINT_STR A0,D3
00000248                           504m LOOP_18
00000248  0C10 0000                505m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024C  6700 0016                506m     BEQ EXIT_18
00000250                           507mm     PRINT_CHAR (A0)+,D3
00000250                           508mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000250                 TRUE      509mm     IFEQ DEBUG
00000250  1639 00C00003            510mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000256  0803 0002                511mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000025A  67F4                     512mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000025C  13D8 00C00007            513mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000262                           514mm     ENDC
00000262                           515mm     
00000262                 FALSE     516mm     IFNE DEBUG
00000262                           517mm     ENDC
00000262                           518mm 
00000262                           519mm     ENDM
00000262  60E4                     520m     BRA LOOP_18
00000264                           521m EXIT_18
00000264                           522m     ENDM
00000264                           523                         
00000264  6000 FEFE                524      BRA MAIN_LOOP
00000268                           525      
00000268                           526  ; commands
00000268                           527  H   
00000268  41F9 00000D4D            528      LEA HELP,A0
0000026E  6000 0008                529      BRA PRINTSTR
00000272                           530  
00000272                           531  V   
00000272  41F9 00000D30            532      LEA VERSION,A0
00000278                           533  PRINTSTR
00000278                           534m     PRINT_STR A0,D3       
00000278                           535m LOOP_20
00000278  0C10 0000                536m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000027C  6700 0016                537m     BEQ EXIT_20
00000280                           538mm     PRINT_CHAR (A0)+,D3
00000280                           539mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000280                 TRUE      540mm     IFEQ DEBUG
00000280  1639 00C00003            541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000286  0803 0002                542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000028A  67F4                     543mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000028C  13D8 00C00007            544mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000292                           545mm     ENDC
00000292                           546mm     
00000292                 FALSE     547mm     IFNE DEBUG
00000292                           548mm     ENDC
00000292                           549mm 
00000292                           550mm     ENDM
00000292  60E4                     551m     BRA LOOP_20
00000294                           552m EXIT_20
00000294                           553m     ENDM
00000294  6000 FECE                554      BRA MAIN_LOOP
00000298                           555      
00000298                           556  R   
00000298  2047                     557      MOVE.L D7,A0                                    ; address accumulator -> address register
0000029A  2A10                     558      MOVE.L (A0),D5                                  ; read the memory and print it
0000029C                           559m     PRINT_REG D5,D3,D7,D6,A0
0000029C                           560mm     PRINT_CHAR #'0',D3                              ;0X HEADER
0000029C                           561mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      562mm     IFEQ DEBUG
0000029C  1639 00C00003            563mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                564mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     565mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
000002A8  13FC 0030 00C00007       566mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002B0                           567mm     ENDC
000002B0                           568mm     
000002B0                 FALSE     569mm     IFNE DEBUG
000002B0                           570mm     ENDC
000002B0                           571mm 
000002B0                           572mm     ENDM
000002B0                           573mm     PRINT_CHAR #'x',D3
000002B0                           574mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B0                 TRUE      575mm     IFEQ DEBUG
000002B0  1639 00C00003            576mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002B6  0803 0002                577mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002BA  67F4                     578mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
000002BC  13FC 0078 00C00007       579mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002C4                           580mm     ENDC
000002C4                           581mm     
000002C4                 FALSE     582mm     IFNE DEBUG
000002C4                           583mm     ENDC
000002C4                           584mm 
000002C4                           585mm     ENDM
000002C4  7C07                     586m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002C6                           587m LOOP_22
000002C6                           588mm     BIN2HEX D5,D7,A0
000002C6  41F9 00000E61            589mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
000002CC  E99D                     590mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002CE  1E05                     591mm     MOVE.B D5,D7
000002D0  0287 0000000F            592mm     ANDI.L #$F,D7
000002D6  1E30 7000                593mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
000002DA                           594mm     ENDM
000002DA                           595mm     PRINT_CHAR D7,D3
000002DA                           596mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DA                 TRUE      597mm     IFEQ DEBUG
000002DA  1639 00C00003            598mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002E0  0803 0002                599mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002E4  67F4                     600mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002E6  13C7 00C00007            601mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002EC                           602mm     ENDC
000002EC                           603mm     
000002EC                 FALSE     604mm     IFNE DEBUG
000002EC                           605mm     ENDC
000002EC                           606mm 
000002EC                           607mm     ENDM
000002EC  57CE FFD8                608m     DBEQ D6,LOOP_22
000002F0                           609m     ENDM
000002F0                           610m     PRINT_CRLF D3,A0
000002F0  41F9 00000E9C            611m     LEA CRLF,A0
000002F6                           612mm     PRINT_STR A0,D3
000002F6                           613mm LOOP_28
000002F6  0C10 0000                614mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002FA  6700 0016                615mm     BEQ EXIT_28
000002FE                           616mmm     PRINT_CHAR (A0)+,D3
000002FE                           617mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      618mmm     IFEQ DEBUG
000002FE  1639 00C00003            619mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000304  0803 0002                620mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000308  67F4                     621mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            622mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000310                           623mmm     ENDC
00000310                           624mmm     
00000310                 FALSE     625mmm     IFNE DEBUG
00000310                           626mmm     ENDC
00000310                           627mmm 
00000310                           628mmm     ENDM
00000310  60E4                     629mm     BRA LOOP_28
00000312                           630mm EXIT_28
00000312                           631mm     ENDM
00000312                           632m     ENDM
00000312  7E00                     633      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000314  6000 FE4E                634      BRA MAIN_LOOP
00000318                           635  
00000318                           636  W
00000318  7A00                     637      MOVE.L #0,D5                                    ; D5 will be the value to write            
0000031A                           638  
0000031A  3C3C 0007                639      MOVE #7,D6                                      ; 7 bytes left to read
0000031E                           640      
0000031E                           641  READ_DATA_TO_POKE
0000031E  E98D                     642      LSL.L #4,D5                                     ; make what we have so far more significant
00000320                           643m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000320                           644m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000320                 TRUE      645m     IFEQ DEBUG
00000320  1639 00C00003            646m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000326  0803 0000                647m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000032A  67F4                     648m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
0000032C                           649m     ENDC
0000032C                           650m     
0000032C                           651mm     READ_CHAR D2
0000032C                 TRUE      652mm     IFEQ DEBUG
0000032C  1439 00C00007            653mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000332                           654mm     ENDC
00000332                 FALSE     655mm     IFNE DEBUG
00000332                           656mm     ENDC
00000332                           657mm      
00000332  B43C 001B                658mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000336  6700 FCD0                659mm     BEQ START
0000033A                           660mm     ENDM
0000033A                           661m 
0000033A                 TRUE      662m     IFEQ DEBUG
0000033A                           663mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000033A                           664mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033A                 TRUE      665mm     IFEQ DEBUG
0000033A  1639 00C00003            666mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000340  0803 0002                667mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000344  67F4                     668mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00000346  13C2 00C00007            669mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000034C                           670mm     ENDC
0000034C                           671mm     
0000034C                 FALSE     672mm     IFNE DEBUG
0000034C                           673mm     ENDC
0000034C                           674mm 
0000034C                           675mm     ENDM
0000034C                           676m     ENDC
0000034C                           677m     ENDM
0000034C                           678m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0000034C  41F9 00000E71            679m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000352  0402 0030                680m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000356  C4BC 000000FF            681m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000035C  1430 2000                682m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000360                           683m     ENDM
00000360  8A02                     684      OR.B D2,D5
00000362  023C 00FB                685      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00000366  57CE FFB6                686      DBEQ D6,READ_DATA_TO_POKE
0000036A                           687      
0000036A  2047                     688      MOVE.L D7,A0                                    ; address accumulator -> address register
0000036C  7E00                     689      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000036E                           690      
0000036E  2085                     691      MOVE.L D5,(A0)                                  ; write the data
00000370                           692  
00000370                           693m     PRINT_CRLF D3,A0
00000370  41F9 00000E9C            694m     LEA CRLF,A0
00000376                           695mm     PRINT_STR A0,D3
00000376                           696mm LOOP_35
00000376  0C10 0000                697mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000037A  6700 0016                698mm     BEQ EXIT_35
0000037E                           699mmm     PRINT_CHAR (A0)+,D3
0000037E                           700mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      701mmm     IFEQ DEBUG
0000037E  1639 00C00003            702mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000384  0803 0002                703mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000388  67F4                     704mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0000038A  13D8 00C00007            705mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000390                           706mmm     ENDC
00000390                           707mmm     
00000390                 FALSE     708mmm     IFNE DEBUG
00000390                           709mmm     ENDC
00000390                           710mmm 
00000390                           711mmm     ENDM
00000390  60E4                     712mm     BRA LOOP_35
00000392                           713mm EXIT_35
00000392                           714mm     ENDM
00000392                           715m     ENDM
00000392  6000 FDD0                716      BRA MAIN_LOOP
00000396                           717  
00000396                           718  ; register map for S
00000396                           719  ; A0 - start address
00000396                           720  ; A1 - offset
00000396                           721  ; A2 - next address to write
00000396                           722  ; A3 - next location (jmp)
00000396                           723  ; A4 - Working Address Register
00000396                           724  ; D0 - record count
00000396                           725  ; D1 - 'S', record type, data byte
00000396                           726  ; D2 - checksum
00000396                           727  ; D3 - data byte count
00000396                           728  ; D4 - read address, moved into A2
00000396                           729  ; D5 - temp
00000396                           730  ; D6 - temp
00000396                           731  ; D7 - temp
00000396                           732  S
00000396  2078 0000                733      MOVE.L 0,A0                                     ; start address -> A0
0000039A  2247                     734      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000039C                           735      
0000039C  7000                     736      MOVE.L #0,D0                                    ; count of records read -> D0
0000039E                           737          
0000039E                           738  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000039E                           739m     DOWNLOAD D1                 
0000039E                           740m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                           741m 
0000039E  1239 00C00003            742m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003A4  0801 0000                743m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003A8  6700 0010                744m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
000003AC                           745m  
000003AC                           746mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003AC                 TRUE      747mm     IFEQ DEBUG
000003AC  1239 00C00007            748mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003B2                           749mm     ENDC
000003B2                 FALSE     750mm     IFNE DEBUG
000003B2                           751mm     ENDC
000003B2                           752mm      
000003B2  B23C 001B                753mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003B6  6700 FC50                754mm     BEQ START
000003BA                           755mm     ENDM
000003BA                           756m CONTINUE_37
000003BA  1239 00C00013            757m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003C0  0801 0000                758m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003C4  67D8                     759m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
000003C6                           760m     
000003C6  1239 00C00017            761m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003CC  13C1 00E00001            762m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003D2                           763m     
000003D2                           764m     ENDM
000003D2  B23C 0053                765      CMP.B #'S',D1                                   ; found S?    
000003D6  66C6                     766      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003D8                           767      
000003D8                           768m     PRINT_CHAR #'S',D5                          ; print the S
000003D8                           769m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D8                 TRUE      770m     IFEQ DEBUG
000003D8  1A39 00C00003            771m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003DE  0805 0002                772m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003E2  67F4                     773m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003E4  13FC 0053 00C00007       774m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003EC                           775m     ENDC
000003EC                           776m     
000003EC                 FALSE     777m     IFNE DEBUG
000003EC                           778m     ENDC
000003EC                           779m 
000003EC                           780m     ENDM
000003EC  5280                     781      ADD.L #1,D0                                     ; read another S record, increment count
000003EE                           782      
000003EE                           783m     DOWNLOAD D1                                 ; read the record identifier and echo it back
000003EE                           784m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EE                           785m 
000003EE  1239 00C00003            786m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003F4  0801 0000                787m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003F8  6700 0010                788m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003FC                           789m  
000003FC                           790mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003FC                 TRUE      791mm     IFEQ DEBUG
000003FC  1239 00C00007            792mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000402                           793mm     ENDC
00000402                 FALSE     794mm     IFNE DEBUG
00000402                           795mm     ENDC
00000402                           796mm      
00000402  B23C 001B                797mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000406  6700 FC00                798mm     BEQ START
0000040A                           799mm     ENDM
0000040A                           800m CONTINUE_40
0000040A  1239 00C00013            801m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000410  0801 0000                802m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000414  67D8                     803m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
00000416                           804m     
00000416  1239 00C00017            805m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000041C  13C1 00E00001            806m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000422                           807m     
00000422                           808m     ENDM
00000422                           809m     PRINT_CHAR D1,D5
00000422                           810m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000422                 TRUE      811m     IFEQ DEBUG
00000422  1A39 00C00003            812m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000428  0805 0002                813m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000042C  67F4                     814m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0000042E  13C1 00C00007            815m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000434                           816m     ENDC
00000434                           817m     
00000434                 FALSE     818m     IFNE DEBUG
00000434                           819m     ENDC
00000434                           820m 
00000434                           821m     ENDM
00000434                           822  
00000434  7400                     823      MOVE.L #0,D2                                    ; clear the checksum
00000436                           824  
00000436  7600                     825      MOVE.L #0,D3                                    ; read the 2 digit byte count -> D3
00000438                           826m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00000438  1E3C 0002                827m     MOVE.B #2,D7
0000043C                           828m     WHILE.B D7 <GT> 0 DO
0000043C                           829ms _10000000
0000043C  BE38 0000                830ms     CMP.B   0,D7
00000440  6F00 0064                831ms     BLE _10000001
00000444  E98B                     832m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000446                           833mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000446                           834mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000446                           835mm 
00000446  1A39 00C00003            836mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000044C  0805 0000                837mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000450  6700 0010                838mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000454                           839mm  
00000454                           840mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000454                 TRUE      841mmm     IFEQ DEBUG
00000454  1A39 00C00007            842mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000045A                           843mmm     ENDC
0000045A                 FALSE     844mmm     IFNE DEBUG
0000045A                           845mmm     ENDC
0000045A                           846mmm      
0000045A  BA3C 001B                847mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000045E  6700 FBA8                848mmm     BEQ START
00000462                           849mmm     ENDM
00000462                           850mm CONTINUE_44
00000462  1A39 00C00013            851mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000468  0805 0000                852mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000046C  67D8                     853mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0000046E                           854mm     
0000046E  1A39 00C00017            855mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000474  13C5 00E00001            856mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000047A                           857mm     
0000047A                           858mm     ENDM
0000047A                           859mm         PRINT_CHAR D5,D6
0000047A                           860mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047A                 TRUE      861mm     IFEQ DEBUG
0000047A  1C39 00C00003            862mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000480  0806 0002                863mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000484  67F4                     864mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000486  13C5 00C00007            865mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000048C                           866mm     ENDC
0000048C                           867mm     
0000048C                 FALSE     868mm     IFNE DEBUG
0000048C                           869mm     ENDC
0000048C                           870mm 
0000048C                           871mm     ENDM
0000048C                           872mm         HEX2BIN D5,D5,A4
0000048C  49F9 00000E71            873mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000492  0405 0030                874mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000496  CABC 000000FF            875mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000049C  1A34 5000                876mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000004A0                           877mm     ENDM
000004A0  8605                     878m         OR.B D5,D3
000004A2  5307                     879m         SUB.B #1,D7
000004A4                           880m     ENDW
000004A4  6096                     881ms     BRA _10000000
000004A6                           882ms _10000001
000004A6                           883m     
000004A6  7A00                     884m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000004A8  1A03                     885m     MOVE.B D3,D5
000004AA  D483                     886m     ADD.L D3,D2
000004AC                           887m 
000004AC                           888m     ENDM
000004AC                           889  
000004AC                           890      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004AC  B23C 0030                891s     CMP.B   #'0',D1
000004B0  6600 002C                892s     BNE.L   _00000002
000004B4                           893m         PRINT_CRLF D5,A4
000004B4  49F9 00000E9C            894m     LEA CRLF,A4
000004BA                           895mm     PRINT_STR A4,D5
000004BA                           896mm LOOP_49
000004BA  0C14 0000                897mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000004BE  6700 0016                898mm     BEQ EXIT_49
000004C2                           899mmm     PRINT_CHAR (A4)+,D5
000004C2                           900mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C2                 TRUE      901mmm     IFEQ DEBUG
000004C2  1A39 00C00003            902mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004C8  0805 0002                903mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004CC  67F4                     904mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
000004CE  13DC 00C00007            905mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000004D4                           906mmm     ENDC
000004D4                           907mmm     
000004D4                 FALSE     908mmm     IFNE DEBUG
000004D4                           909mmm     ENDC
000004D4                           910mmm 
000004D4                           911mmm     ENDM
000004D4  60E4                     912mm     BRA LOOP_49
000004D6                           913mm EXIT_49
000004D6                           914mm     ENDM
000004D6                           915m     ENDM
000004D6  6000 FEC6                916          BRA WAIT_FOR_SRECORD
000004DA                           917      ELSE
000004DA  6000 03FC                918s     BRA _00000003
000004DE                           919s _00000002
000004DE                           920          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000004DE  B23C 0031                921s     CMP.B   #'1',D1
000004E2  6708                     922s     BEQ.S   _00000004
000004E4  B23C 0032                923s     CMP.B   #'2',D1
000004E8  6600 0200                924s     BNE.L   _00000005
000004EC                           925s _00000004
000004EC  5783                     926              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004EE                           927      
000004EE  7800                     928              MOVE.L #0,D4                            ; read two bytes of address
000004F0                           929m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
000004F0  1E3C 0002                930m     MOVE.B #2,D7
000004F4                           931m     WHILE.B D7 <GT> 0 DO
000004F4                           932ms _10000002
000004F4  BE38 0000                933ms     CMP.B   0,D7
000004F8  6F00 0064                934ms     BLE _10000003
000004FC  E98C                     935m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004FE                           936mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004FE                           937mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                           938mm 
000004FE  1A39 00C00003            939mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000504  0805 0000                940mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000508  6700 0010                941mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
0000050C                           942mm  
0000050C                           943mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000050C                 TRUE      944mmm     IFEQ DEBUG
0000050C  1A39 00C00007            945mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000512                           946mmm     ENDC
00000512                 FALSE     947mmm     IFNE DEBUG
00000512                           948mmm     ENDC
00000512                           949mmm      
00000512  BA3C 001B                950mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000516  6700 FAF0                951mmm     BEQ START
0000051A                           952mmm     ENDM
0000051A                           953mm CONTINUE_52
0000051A  1A39 00C00013            954mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000520  0805 0000                955mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000524  67D8                     956mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
00000526                           957mm     
00000526  1A39 00C00017            958mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000052C  13C5 00E00001            959mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000532                           960mm     
00000532                           961mm     ENDM
00000532                           962mm         PRINT_CHAR D5,D6
00000532                           963mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000532                 TRUE      964mm     IFEQ DEBUG
00000532  1C39 00C00003            965mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000538  0806 0002                966mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000053C  67F4                     967mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
0000053E  13C5 00C00007            968mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000544                           969mm     ENDC
00000544                           970mm     
00000544                 FALSE     971mm     IFNE DEBUG
00000544                           972mm     ENDC
00000544                           973mm 
00000544                           974mm     ENDM
00000544                           975mm         HEX2BIN D5,D5,A4
00000544  49F9 00000E71            976mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000054A  0405 0030                977mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000054E  CABC 000000FF            978mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000554  1A34 5000                979mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000558                           980mm     ENDM
00000558  8805                     981m         OR.B D5,D4
0000055A  5307                     982m         SUB.B #1,D7
0000055C                           983m     ENDW
0000055C  6096                     984ms     BRA _10000002
0000055E                           985ms _10000003
0000055E                           986m     
0000055E  7A00                     987m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000560  1A04                     988m     MOVE.B D4,D5
00000562  D484                     989m     ADD.L D4,D2
00000564                           990m 
00000564                           991m     ENDM
00000564                           992m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
00000564  1E3C 0002                993m     MOVE.B #2,D7
00000568                           994m     WHILE.B D7 <GT> 0 DO
00000568                           995ms _10000004
00000568  BE38 0000                996ms     CMP.B   0,D7
0000056C  6F00 0064                997ms     BLE _10000005
00000570  E98C                     998m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000572                           999mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000572                          1000mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000572                          1001mm 
00000572  1A39 00C00003           1002mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000578  0805 0000               1003mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000057C  6700 0010               1004mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000580                          1005mm  
00000580                          1006mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000580                 TRUE     1007mmm     IFEQ DEBUG
00000580  1A39 00C00007           1008mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000586                          1009mmm     ENDC
00000586                 FALSE    1010mmm     IFNE DEBUG
00000586                          1011mmm     ENDC
00000586                          1012mmm      
00000586  BA3C 001B               1013mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000058A  6700 FA7C               1014mmm     BEQ START
0000058E                          1015mmm     ENDM
0000058E                          1016mm CONTINUE_57
0000058E  1A39 00C00013           1017mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000594  0805 0000               1018mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000598  67D8                    1019mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000059A                          1020mm     
0000059A  1A39 00C00017           1021mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005A0  13C5 00E00001           1022mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005A6                          1023mm     
000005A6                          1024mm     ENDM
000005A6                          1025mm         PRINT_CHAR D5,D6
000005A6                          1026mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A6                 TRUE     1027mm     IFEQ DEBUG
000005A6  1C39 00C00003           1028mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005AC  0806 0002               1029mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005B0  67F4                    1030mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
000005B2  13C5 00C00007           1031mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005B8                          1032mm     ENDC
000005B8                          1033mm     
000005B8                 FALSE    1034mm     IFNE DEBUG
000005B8                          1035mm     ENDC
000005B8                          1036mm 
000005B8                          1037mm     ENDM
000005B8                          1038mm         HEX2BIN D5,D5,A4
000005B8  49F9 00000E71           1039mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005BE  0405 0030               1040mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  CABC 000000FF           1041mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005C8  1A34 5000               1042mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005CC                          1043mm     ENDM
000005CC  8805                    1044m         OR.B D5,D4
000005CE  5307                    1045m         SUB.B #1,D7
000005D0                          1046m     ENDW
000005D0  6096                    1047ms     BRA _10000004
000005D2                          1048ms _10000005
000005D2                          1049m     
000005D2  7A00                    1050m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005D4  1A04                    1051m     MOVE.B D4,D5
000005D6  D484                    1052m     ADD.L D4,D2
000005D8                          1053m 
000005D8                          1054m     ENDM
000005D8                          1055              
000005D8                          1056              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
000005D8  B23C 0032               1057s     CMP.B   #'2',D1
000005DC  6600 0078               1058s     BNE.L   _00000006
000005E0  5383                    1059                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005E2                          1060m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005E2  1E3C 0002               1061m     MOVE.B #2,D7
000005E6                          1062m     WHILE.B D7 <GT> 0 DO
000005E6                          1063ms _10000006
000005E6  BE38 0000               1064ms     CMP.B   0,D7
000005EA  6F00 0064               1065ms     BLE _10000007
000005EE  E98C                    1066m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005F0                          1067mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005F0                          1068mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F0                          1069mm 
000005F0  1A39 00C00003           1070mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005F6  0805 0000               1071mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005FA  6700 0010               1072mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005FE                          1073mm  
000005FE                          1074mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005FE                 TRUE     1075mmm     IFEQ DEBUG
000005FE  1A39 00C00007           1076mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000604                          1077mmm     ENDC
00000604                 FALSE    1078mmm     IFNE DEBUG
00000604                          1079mmm     ENDC
00000604                          1080mmm      
00000604  BA3C 001B               1081mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000608  6700 F9FE               1082mmm     BEQ START
0000060C                          1083mmm     ENDM
0000060C                          1084mm CONTINUE_62
0000060C  1A39 00C00013           1085mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000612  0805 0000               1086mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000616  67D8                    1087mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
00000618                          1088mm     
00000618  1A39 00C00017           1089mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000061E  13C5 00E00001           1090mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000624                          1091mm     
00000624                          1092mm     ENDM
00000624                          1093mm         PRINT_CHAR D5,D6
00000624                          1094mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000624                 TRUE     1095mm     IFEQ DEBUG
00000624  1C39 00C00003           1096mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000062A  0806 0002               1097mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000062E  67F4                    1098mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
00000630  13C5 00C00007           1099mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000636                          1100mm     ENDC
00000636                          1101mm     
00000636                 FALSE    1102mm     IFNE DEBUG
00000636                          1103mm     ENDC
00000636                          1104mm 
00000636                          1105mm     ENDM
00000636                          1106mm         HEX2BIN D5,D5,A4
00000636  49F9 00000E71           1107mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000063C  0405 0030               1108mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000640  CABC 000000FF           1109mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000646  1A34 5000               1110mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000064A                          1111mm     ENDM
0000064A  8805                    1112m         OR.B D5,D4
0000064C  5307                    1113m         SUB.B #1,D7
0000064E                          1114m     ENDW
0000064E  6096                    1115ms     BRA _10000006
00000650                          1116ms _10000007
00000650                          1117m     
00000650  7A00                    1118m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000652  1A04                    1119m     MOVE.B D4,D5
00000654  D484                    1120m     ADD.L D4,D2
00000656                          1121m 
00000656                          1122m     ENDM
00000656                          1123              ENDI
00000656                          1124s _00000006
00000656                          1125              
00000656  2444                    1126                  MOVE.L D4,A2                            ; put the address in an address register
00000658  D5C9                    1127              ADD.L A1,A2                             ; add in the offset
0000065A                          1128  
0000065A                          1129              WHILE.L D3 <GT> #0 DO                   ; read the data bytes                
0000065A                          1130s _10000008
0000065A  B6BC 00000000           1131s     CMP.L   #0,D3
00000660  6F00 0080               1132s     BLE _10000009
00000664  7200                    1133                  MOVE.L #0,D1                        ; D1 holds the byte
00000666                          1134m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000666  1E3C 0002               1135m     MOVE.B #2,D7
0000066A                          1136m     WHILE.B D7 <GT> 0 DO
0000066A                          1137ms _1000000A
0000066A  BE38 0000               1138ms     CMP.B   0,D7
0000066E  6F00 0064               1139ms     BLE _1000000B
00000672  E989                    1140m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000674                          1141mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000674                          1142mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000674                          1143mm 
00000674  1A39 00C00003           1144mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000067A  0805 0000               1145mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000067E  6700 0010               1146mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
00000682                          1147mm  
00000682                          1148mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000682                 TRUE     1149mmm     IFEQ DEBUG
00000682  1A39 00C00007           1150mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000688                          1151mmm     ENDC
00000688                 FALSE    1152mmm     IFNE DEBUG
00000688                          1153mmm     ENDC
00000688                          1154mmm      
00000688  BA3C 001B               1155mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000068C  6700 F97A               1156mmm     BEQ START
00000690                          1157mmm     ENDM
00000690                          1158mm CONTINUE_67
00000690  1A39 00C00013           1159mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000696  0805 0000               1160mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000069A  67D8                    1161mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
0000069C                          1162mm     
0000069C  1A39 00C00017           1163mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006A2  13C5 00E00001           1164mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006A8                          1165mm     
000006A8                          1166mm     ENDM
000006A8                          1167mm         PRINT_CHAR D5,D6
000006A8                          1168mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A8                 TRUE     1169mm     IFEQ DEBUG
000006A8  1C39 00C00003           1170mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006AE  0806 0002               1171mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006B2  67F4                    1172mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
000006B4  13C5 00C00007           1173mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006BA                          1174mm     ENDC
000006BA                          1175mm     
000006BA                 FALSE    1176mm     IFNE DEBUG
000006BA                          1177mm     ENDC
000006BA                          1178mm 
000006BA                          1179mm     ENDM
000006BA                          1180mm         HEX2BIN D5,D5,A4
000006BA  49F9 00000E71           1181mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000006C0  0405 0030               1182mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006C4  CABC 000000FF           1183mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006CA  1A34 5000               1184mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006CE                          1185mm     ENDM
000006CE  8205                    1186m         OR.B D5,D1
000006D0  5307                    1187m         SUB.B #1,D7
000006D2                          1188m     ENDW
000006D2  6096                    1189ms     BRA _1000000A
000006D4                          1190ms _1000000B
000006D4                          1191m     
000006D4  7A00                    1192m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006D6  1A01                    1193m     MOVE.B D1,D5
000006D8  D481                    1194m     ADD.L D1,D2
000006DA                          1195m 
000006DA                          1196m     ENDM
000006DA                          1197                          
000006DA  14C1                    1198                  MOVE.B D1,(A2)+                     ; store it!
000006DC                          1199  
000006DC  5383                    1200                  SUB.L #1,D3                     ; 1 less byte to go
000006DE                          1201              ENDW
000006DE  6000 FF7A               1202s     BRA _10000008
000006E2                          1203s _10000009
000006E2                          1204          
000006E2  47F8 039E               1205              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006E6                          1206          ELSE
000006E6  6000 01F0               1207s     BRA _00000007
000006EA                          1208s _00000005
000006EA                          1209              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006EA  B23C 0038               1210s     CMP.B   #'8',D1
000006EE  6600 016C               1211s     BNE.L   _00000008
000006F2  7800                    1212                  MOVE.L #0,D4                    ; read the 24 bit start address
000006F4                          1213m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006F4  1E3C 0002               1214m     MOVE.B #2,D7
000006F8                          1215m     WHILE.B D7 <GT> 0 DO
000006F8                          1216ms _1000000C
000006F8  BE38 0000               1217ms     CMP.B   0,D7
000006FC  6F00 0064               1218ms     BLE _1000000D
00000700  E98C                    1219m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000702                          1220mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000702                          1221mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000702                          1222mm 
00000702  1A39 00C00003           1223mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000708  0805 0000               1224mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000070C  6700 0010               1225mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
00000710                          1226mm  
00000710                          1227mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000710                 TRUE     1228mmm     IFEQ DEBUG
00000710  1A39 00C00007           1229mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000716                          1230mmm     ENDC
00000716                 FALSE    1231mmm     IFNE DEBUG
00000716                          1232mmm     ENDC
00000716                          1233mmm      
00000716  BA3C 001B               1234mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000071A  6700 F8EC               1235mmm     BEQ START
0000071E                          1236mmm     ENDM
0000071E                          1237mm CONTINUE_72
0000071E  1A39 00C00013           1238mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000724  0805 0000               1239mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000728  67D8                    1240mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
0000072A                          1241mm     
0000072A  1A39 00C00017           1242mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000730  13C5 00E00001           1243mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000736                          1244mm     
00000736                          1245mm     ENDM
00000736                          1246mm         PRINT_CHAR D5,D6
00000736                          1247mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000736                 TRUE     1248mm     IFEQ DEBUG
00000736  1C39 00C00003           1249mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000073C  0806 0002               1250mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000740  67F4                    1251mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
00000742  13C5 00C00007           1252mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000748                          1253mm     ENDC
00000748                          1254mm     
00000748                 FALSE    1255mm     IFNE DEBUG
00000748                          1256mm     ENDC
00000748                          1257mm 
00000748                          1258mm     ENDM
00000748                          1259mm         HEX2BIN D5,D5,A4
00000748  49F9 00000E71           1260mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000074E  0405 0030               1261mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000752  CABC 000000FF           1262mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000758  1A34 5000               1263mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000075C                          1264mm     ENDM
0000075C  8805                    1265m         OR.B D5,D4
0000075E  5307                    1266m         SUB.B #1,D7
00000760                          1267m     ENDW
00000760  6096                    1268ms     BRA _1000000C
00000762                          1269ms _1000000D
00000762                          1270m     
00000762  7A00                    1271m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000764  1A04                    1272m     MOVE.B D4,D5
00000766  D484                    1273m     ADD.L D4,D2
00000768                          1274m 
00000768                          1275m     ENDM
00000768                          1276m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000768  1E3C 0002               1277m     MOVE.B #2,D7
0000076C                          1278m     WHILE.B D7 <GT> 0 DO
0000076C                          1279ms _1000000E
0000076C  BE38 0000               1280ms     CMP.B   0,D7
00000770  6F00 0064               1281ms     BLE _1000000F
00000774  E98C                    1282m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000776                          1283mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000776                          1284mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000776                          1285mm 
00000776  1A39 00C00003           1286mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000077C  0805 0000               1287mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000780  6700 0010               1288mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000784                          1289mm  
00000784                          1290mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000784                 TRUE     1291mmm     IFEQ DEBUG
00000784  1A39 00C00007           1292mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000078A                          1293mmm     ENDC
0000078A                 FALSE    1294mmm     IFNE DEBUG
0000078A                          1295mmm     ENDC
0000078A                          1296mmm      
0000078A  BA3C 001B               1297mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000078E  6700 F878               1298mmm     BEQ START
00000792                          1299mmm     ENDM
00000792                          1300mm CONTINUE_77
00000792  1A39 00C00013           1301mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000798  0805 0000               1302mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000079C  67D8                    1303mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000079E                          1304mm     
0000079E  1A39 00C00017           1305mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007A4  13C5 00E00001           1306mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007AA                          1307mm     
000007AA                          1308mm     ENDM
000007AA                          1309mm         PRINT_CHAR D5,D6
000007AA                          1310mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007AA                 TRUE     1311mm     IFEQ DEBUG
000007AA  1C39 00C00003           1312mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007B0  0806 0002               1313mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007B4  67F4                    1314mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
000007B6  13C5 00C00007           1315mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007BC                          1316mm     ENDC
000007BC                          1317mm     
000007BC                 FALSE    1318mm     IFNE DEBUG
000007BC                          1319mm     ENDC
000007BC                          1320mm 
000007BC                          1321mm     ENDM
000007BC                          1322mm         HEX2BIN D5,D5,A4
000007BC  49F9 00000E71           1323mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007C2  0405 0030               1324mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007C6  CABC 000000FF           1325mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007CC  1A34 5000               1326mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007D0                          1327mm     ENDM
000007D0  8805                    1328m         OR.B D5,D4
000007D2  5307                    1329m         SUB.B #1,D7
000007D4                          1330m     ENDW
000007D4  6096                    1331ms     BRA _1000000E
000007D6                          1332ms _1000000F
000007D6                          1333m     
000007D6  7A00                    1334m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007D8  1A04                    1335m     MOVE.B D4,D5
000007DA  D484                    1336m     ADD.L D4,D2
000007DC                          1337m 
000007DC                          1338m     ENDM
000007DC                          1339m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
000007DC  1E3C 0002               1340m     MOVE.B #2,D7
000007E0                          1341m     WHILE.B D7 <GT> 0 DO
000007E0                          1342ms _10000010
000007E0  BE38 0000               1343ms     CMP.B   0,D7
000007E4  6F00 0064               1344ms     BLE _10000011
000007E8  E98C                    1345m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007EA                          1346mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007EA                          1347mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007EA                          1348mm 
000007EA  1A39 00C00003           1349mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007F0  0805 0000               1350mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007F4  6700 0010               1351mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007F8                          1352mm  
000007F8                          1353mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007F8                 TRUE     1354mmm     IFEQ DEBUG
000007F8  1A39 00C00007           1355mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007FE                          1356mmm     ENDC
000007FE                 FALSE    1357mmm     IFNE DEBUG
000007FE                          1358mmm     ENDC
000007FE                          1359mmm      
000007FE  BA3C 001B               1360mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000802  6700 F804               1361mmm     BEQ START
00000806                          1362mmm     ENDM
00000806                          1363mm CONTINUE_82
00000806  1A39 00C00013           1364mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000080C  0805 0000               1365mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000810  67D8                    1366mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
00000812                          1367mm     
00000812  1A39 00C00017           1368mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000818  13C5 00E00001           1369mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000081E                          1370mm     
0000081E                          1371mm     ENDM
0000081E                          1372mm         PRINT_CHAR D5,D6
0000081E                          1373mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000081E                 TRUE     1374mm     IFEQ DEBUG
0000081E  1C39 00C00003           1375mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000824  0806 0002               1376mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000828  67F4                    1377mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
0000082A  13C5 00C00007           1378mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000830                          1379mm     ENDC
00000830                          1380mm     
00000830                 FALSE    1381mm     IFNE DEBUG
00000830                          1382mm     ENDC
00000830                          1383mm 
00000830                          1384mm     ENDM
00000830                          1385mm         HEX2BIN D5,D5,A4
00000830  49F9 00000E71           1386mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000836  0405 0030               1387mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000083A  CABC 000000FF           1388mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000840  1A34 5000               1389mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000844                          1390mm     ENDM
00000844  8805                    1391m         OR.B D5,D4
00000846  5307                    1392m         SUB.B #1,D7
00000848                          1393m     ENDW
00000848  6096                    1394ms     BRA _10000010
0000084A                          1395ms _10000011
0000084A                          1396m     
0000084A  7A00                    1397m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000084C  1A04                    1398m     MOVE.B D4,D5
0000084E  D484                    1399m     ADD.L D4,D2
00000850                          1400m 
00000850                          1401m     ENDM
00000850                          1402                    
00000850  2044                    1403                  MOVE.L D4,A0                    ; start address -> A0
00000852                          1404                  
00000852  47F9 00000A16           1405                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000858                          1406              ELSE
00000858  6000 007E               1407s     BRA _00000009
0000085C                          1408s _00000008
0000085C                          1409m                 PRINT_CRLF D5,A4
0000085C  49F9 00000E9C           1410m     LEA CRLF,A4
00000862                          1411mm     PRINT_STR A4,D5
00000862                          1412mm LOOP_87
00000862  0C14 0000               1413mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000866  6700 0016               1414mm     BEQ EXIT_87
0000086A                          1415mmm     PRINT_CHAR (A4)+,D5
0000086A                          1416mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000086A                 TRUE     1417mmm     IFEQ DEBUG
0000086A  1A39 00C00003           1418mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000870  0805 0002               1419mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000874  67F4                    1420mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00000876  13DC 00C00007           1421mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000087C                          1422mmm     ENDC
0000087C                          1423mmm     
0000087C                 FALSE    1424mmm     IFNE DEBUG
0000087C                          1425mmm     ENDC
0000087C                          1426mmm 
0000087C                          1427mmm     ENDM
0000087C  60E4                    1428mm     BRA LOOP_87
0000087E                          1429mm EXIT_87
0000087E                          1430mm     ENDM
0000087E                          1431m     ENDM
0000087E                          1432              
0000087E  49F9 00000E26           1433                  LEA UNREC,A4                    ; warn for unrecognised type
00000884                          1434m                 PRINT_STR A4,D5
00000884                          1435m LOOP_89
00000884  0C14 0000               1436m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000888  6700 0016               1437m     BEQ EXIT_89
0000088C                          1438mm     PRINT_CHAR (A4)+,D5
0000088C                          1439mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088C                 TRUE     1440mm     IFEQ DEBUG
0000088C  1A39 00C00003           1441mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000892  0805 0002               1442mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000896  67F4                    1443mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00000898  13DC 00C00007           1444mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000089E                          1445mm     ENDC
0000089E                          1446mm     
0000089E                 FALSE    1447mm     IFNE DEBUG
0000089E                          1448mm     ENDC
0000089E                          1449mm 
0000089E                          1450mm     ENDM
0000089E  60E4                    1451m     BRA LOOP_89
000008A0                          1452m EXIT_89
000008A0                          1453m     ENDM
000008A0                          1454m                 PRINT_CHAR D1,D5
000008A0                          1455m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A0                 TRUE     1456m     IFEQ DEBUG
000008A0  1A39 00C00003           1457m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008A6  0805 0002               1458m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008AA  67F4                    1459m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
000008AC  13C1 00C00007           1460m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008B2                          1461m     ENDC
000008B2                          1462m     
000008B2                 FALSE    1463m     IFNE DEBUG
000008B2                          1464m     ENDC
000008B2                          1465m 
000008B2                          1466m     ENDM
000008B2                          1467m                 PRINT_CRLF D5,A4
000008B2  49F9 00000E9C           1468m     LEA CRLF,A4
000008B8                          1469mm     PRINT_STR A4,D5
000008B8                          1470mm LOOP_93
000008B8  0C14 0000               1471mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008BC  6700 0016               1472mm     BEQ EXIT_93
000008C0                          1473mmm     PRINT_CHAR (A4)+,D5
000008C0                          1474mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008C0                 TRUE     1475mmm     IFEQ DEBUG
000008C0  1A39 00C00003           1476mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008C6  0805 0002               1477mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008CA  67F4                    1478mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
000008CC  13DC 00C00007           1479mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008D2                          1480mmm     ENDC
000008D2                          1481mmm     
000008D2                 FALSE    1482mmm     IFNE DEBUG
000008D2                          1483mmm     ENDC
000008D2                          1484mmm 
000008D2                          1485mmm     ENDM
000008D2  60E4                    1486mm     BRA LOOP_93
000008D4                          1487mm EXIT_93
000008D4                          1488mm     ENDM
000008D4                          1489m     ENDM
000008D4                          1490              
000008D4  6000 FAC8               1491                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
000008D8                          1492              ENDI
000008D8                          1493s _00000009
000008D8                          1494          ENDI
000008D8                          1495s _00000007
000008D8                          1496      ENDI
000008D8                          1497s _00000003
000008D8                          1498      
000008D8  7800                    1499      MOVE.L #0,D4                                    ; read the checksum from the data stream add to our checksum: should make it FF
000008DA                          1500m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
000008DA  1E3C 0002               1501m     MOVE.B #2,D7
000008DE                          1502m     WHILE.B D7 <GT> 0 DO
000008DE                          1503ms _10000012
000008DE  BE38 0000               1504ms     CMP.B   0,D7
000008E2  6F00 0064               1505ms     BLE _10000013
000008E6  E98C                    1506m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008E8                          1507mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008E8                          1508mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E8                          1509mm 
000008E8  1A39 00C00003           1510mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008EE  0805 0000               1511mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008F2  6700 0010               1512mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008F6                          1513mm  
000008F6                          1514mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008F6                 TRUE     1515mmm     IFEQ DEBUG
000008F6  1A39 00C00007           1516mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008FC                          1517mmm     ENDC
000008FC                 FALSE    1518mmm     IFNE DEBUG
000008FC                          1519mmm     ENDC
000008FC                          1520mmm      
000008FC  BA3C 001B               1521mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000900  6700 F706               1522mmm     BEQ START
00000904                          1523mmm     ENDM
00000904                          1524mm CONTINUE_96
00000904  1A39 00C00013           1525mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000090A  0805 0000               1526mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000090E  67D8                    1527mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
00000910                          1528mm     
00000910  1A39 00C00017           1529mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000916  13C5 00E00001           1530mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000091C                          1531mm     
0000091C                          1532mm     ENDM
0000091C                          1533mm         PRINT_CHAR D5,D6
0000091C                          1534mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000091C                 TRUE     1535mm     IFEQ DEBUG
0000091C  1C39 00C00003           1536mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000922  0806 0002               1537mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000926  67F4                    1538mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00000928  13C5 00C00007           1539mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000092E                          1540mm     ENDC
0000092E                          1541mm     
0000092E                 FALSE    1542mm     IFNE DEBUG
0000092E                          1543mm     ENDC
0000092E                          1544mm 
0000092E                          1545mm     ENDM
0000092E                          1546mm         HEX2BIN D5,D5,A4
0000092E  49F9 00000E71           1547mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000934  0405 0030               1548mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000938  CABC 000000FF           1549mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000093E  1A34 5000               1550mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000942                          1551mm     ENDM
00000942  8805                    1552m         OR.B D5,D4
00000944  5307                    1553m         SUB.B #1,D7
00000946                          1554m     ENDW
00000946  6096                    1555ms     BRA _10000012
00000948                          1556ms _10000013
00000948                          1557m     
00000948  7A00                    1558m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000094A  1A04                    1559m     MOVE.B D4,D5
0000094C  D484                    1560m     ADD.L D4,D2
0000094E                          1561m 
0000094E                          1562m     ENDM
0000094E                          1563m     PRINT_CRLF D5,A4
0000094E  49F9 00000E9C           1564m     LEA CRLF,A4
00000954                          1565mm     PRINT_STR A4,D5
00000954                          1566mm LOOP_101
00000954  0C14 0000               1567mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000958  6700 0016               1568mm     BEQ EXIT_101
0000095C                          1569mmm     PRINT_CHAR (A4)+,D5
0000095C                          1570mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                 TRUE     1571mmm     IFEQ DEBUG
0000095C  1A39 00C00003           1572mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000962  0805 0002               1573mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000966  67F4                    1574mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000968  13DC 00C00007           1575mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000096E                          1576mmm     ENDC
0000096E                          1577mmm     
0000096E                 FALSE    1578mmm     IFNE DEBUG
0000096E                          1579mmm     ENDC
0000096E                          1580mmm 
0000096E                          1581mmm     ENDM
0000096E  60E4                    1582mm     BRA LOOP_101
00000970                          1583mm EXIT_101
00000970                          1584mm     ENDM
00000970                          1585m     ENDM
00000970                          1586          
00000970                          1587      IF.B D2 <NE> #$FF THEN.L
00000970  B43C 00FF               1588s     CMP.B   #$FF,D2
00000974  6700 009E               1589s     BEQ.L   _0000000A
00000978  49F9 00000E3D           1590          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
0000097E                          1591m         PRINT_STR A4,D5
0000097E                          1592m LOOP_103
0000097E  0C14 0000               1593m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000982  6700 0016               1594m     BEQ EXIT_103
00000986                          1595mm     PRINT_CHAR (A4)+,D5
00000986                          1596mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000986                 TRUE     1597mm     IFEQ DEBUG
00000986  1A39 00C00003           1598mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000098C  0805 0002               1599mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000990  67F4                    1600mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
00000992  13DC 00C00007           1601mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000998                          1602mm     ENDC
00000998                          1603mm     
00000998                 FALSE    1604mm     IFNE DEBUG
00000998                          1605mm     ENDC
00000998                          1606mm 
00000998                          1607mm     ENDM
00000998  60E4                    1608m     BRA LOOP_103
0000099A                          1609m EXIT_103
0000099A                          1610m     ENDM
0000099A                          1611m         PRINT_REG D0,D5,D2,D6,A4
0000099A                          1612mm     PRINT_CHAR #'0',D5                              ;0X HEADER
0000099A                          1613mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099A                 TRUE     1614mm     IFEQ DEBUG
0000099A  1A39 00C00003           1615mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009A0  0805 0002               1616mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009A4  67F4                    1617mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
000009A6  13FC 0030 00C00007      1618mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000009AE                          1619mm     ENDC
000009AE                          1620mm     
000009AE                 FALSE    1621mm     IFNE DEBUG
000009AE                          1622mm     ENDC
000009AE                          1623mm 
000009AE                          1624mm     ENDM
000009AE                          1625mm     PRINT_CHAR #'x',D5
000009AE                          1626mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009AE                 TRUE     1627mm     IFEQ DEBUG
000009AE  1A39 00C00003           1628mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B4  0805 0002               1629mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009B8  67F4                    1630mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
000009BA  13FC 0078 00C00007      1631mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000009C2                          1632mm     ENDC
000009C2                          1633mm     
000009C2                 FALSE    1634mm     IFNE DEBUG
000009C2                          1635mm     ENDC
000009C2                          1636mm 
000009C2                          1637mm     ENDM
000009C2  7C07                    1638m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009C4                          1639m LOOP_105
000009C4                          1640mm     BIN2HEX D0,D2,A4
000009C4  49F9 00000E61           1641mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
000009CA  E998                    1642mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009CC  1400                    1643mm     MOVE.B D0,D2
000009CE  0282 0000000F           1644mm     ANDI.L #$F,D2
000009D4  1434 2000               1645mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
000009D8                          1646mm     ENDM
000009D8                          1647mm     PRINT_CHAR D2,D5
000009D8                          1648mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1649mm     IFEQ DEBUG
000009D8  1A39 00C00003           1650mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1651mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1652mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
000009E4  13C2 00C00007           1653mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009EA                          1654mm     ENDC
000009EA                          1655mm     
000009EA                 FALSE    1656mm     IFNE DEBUG
000009EA                          1657mm     ENDC
000009EA                          1658mm 
000009EA                          1659mm     ENDM
000009EA  57CE FFD8               1660m     DBEQ D6,LOOP_105
000009EE                          1661m     ENDM
000009EE                          1662m         PRINT_CRLF D5,A4
000009EE  49F9 00000E9C           1663m     LEA CRLF,A4
000009F4                          1664mm     PRINT_STR A4,D5
000009F4                          1665mm LOOP_111
000009F4  0C14 0000               1666mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009F8  6700 0016               1667mm     BEQ EXIT_111
000009FC                          1668mmm     PRINT_CHAR (A4)+,D5
000009FC                          1669mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FC                 TRUE     1670mmm     IFEQ DEBUG
000009FC  1A39 00C00003           1671mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A02  0805 0002               1672mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A06  67F4                    1673mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000A08  13DC 00C00007           1674mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A0E                          1675mmm     ENDC
00000A0E                          1676mmm     
00000A0E                 FALSE    1677mmm     IFNE DEBUG
00000A0E                          1678mmm     ENDC
00000A0E                          1679mmm 
00000A0E                          1680mmm     ENDM
00000A0E  60E4                    1681mm     BRA LOOP_111
00000A10                          1682mm EXIT_111
00000A10                          1683mm     ENDM
00000A10                          1684m     ENDM
00000A10  6000 F752               1685          BRA MAIN_LOOP
00000A14                          1686      ENDI
00000A14                          1687s _0000000A
00000A14                          1688      
00000A14  4ED3                    1689      JMP (A3)
00000A16                          1690  DOWNLOAD_DONE
00000A16                          1691m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A16                          1692mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A16                          1693mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1694mm     IFEQ DEBUG
00000A16  1A39 00C00003           1695mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A1C  0805 0002               1696mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1697mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000A22  13FC 0030 00C00007      1698mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A2A                          1699mm     ENDC
00000A2A                          1700mm     
00000A2A                 FALSE    1701mm     IFNE DEBUG
00000A2A                          1702mm     ENDC
00000A2A                          1703mm 
00000A2A                          1704mm     ENDM
00000A2A                          1705mm     PRINT_CHAR #'x',D5
00000A2A                          1706mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1707mm     IFEQ DEBUG
00000A2A  1A39 00C00003           1708mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A30  0805 0002               1709mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1710mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000A36  13FC 0078 00C00007      1711mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A3E                          1712mm     ENDC
00000A3E                          1713mm     
00000A3E                 FALSE    1714mm     IFNE DEBUG
00000A3E                          1715mm     ENDC
00000A3E                          1716mm 
00000A3E                          1717mm     ENDM
00000A3E  7407                    1718m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A40                          1719m LOOP_113
00000A40                          1720mm     BIN2HEX D0,D6,A1
00000A40  43F9 00000E61           1721mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A46  E998                    1722mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A48  1C00                    1723mm     MOVE.B D0,D6
00000A4A  0286 0000000F           1724mm     ANDI.L #$F,D6
00000A50  1C31 6000               1725mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A54                          1726mm     ENDM
00000A54                          1727mm     PRINT_CHAR D6,D5
00000A54                          1728mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A54                 TRUE     1729mm     IFEQ DEBUG
00000A54  1A39 00C00003           1730mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A5A  0805 0002               1731mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A5E  67F4                    1732mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A60  13C6 00C00007           1733mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A66                          1734mm     ENDC
00000A66                          1735mm     
00000A66                 FALSE    1736mm     IFNE DEBUG
00000A66                          1737mm     ENDC
00000A66                          1738mm 
00000A66                          1739mm     ENDM
00000A66  57CA FFD8               1740m     DBEQ D2,LOOP_113
00000A6A                          1741m     ENDM
00000A6A  43F9 00000E04           1742      LEA READ,A1
00000A70                          1743m     PRINT_STR A1,D5
00000A70                          1744m LOOP_118
00000A70  0C11 0000               1745m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A74  6700 0016               1746m     BEQ EXIT_118
00000A78                          1747mm     PRINT_CHAR (A1)+,D5
00000A78                          1748mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A78                 TRUE     1749mm     IFEQ DEBUG
00000A78  1A39 00C00003           1750mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A7E  0805 0002               1751mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A82  67F4                    1752mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A84  13D9 00C00007           1753mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A8A                          1754mm     ENDC
00000A8A                          1755mm     
00000A8A                 FALSE    1756mm     IFNE DEBUG
00000A8A                          1757mm     ENDC
00000A8A                          1758mm 
00000A8A                          1759mm     ENDM
00000A8A  60E4                    1760m     BRA LOOP_118
00000A8C                          1761m EXIT_118
00000A8C                          1762m     ENDM
00000A8C  2E08                    1763      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A8E                          1764m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A8E                          1765mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A8E                          1766mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A8E                 TRUE     1767mm     IFEQ DEBUG
00000A8E  1A39 00C00003           1768mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A94  0805 0002               1769mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A98  67F4                    1770mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A9A  13FC 0030 00C00007      1771mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AA2                          1772mm     ENDC
00000AA2                          1773mm     
00000AA2                 FALSE    1774mm     IFNE DEBUG
00000AA2                          1775mm     ENDC
00000AA2                          1776mm 
00000AA2                          1777mm     ENDM
00000AA2                          1778mm     PRINT_CHAR #'x',D5
00000AA2                          1779mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA2                 TRUE     1780mm     IFEQ DEBUG
00000AA2  1A39 00C00003           1781mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AA8  0805 0002               1782mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AAC  67F4                    1783mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000AAE  13FC 0078 00C00007      1784mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AB6                          1785mm     ENDC
00000AB6                          1786mm     
00000AB6                 FALSE    1787mm     IFNE DEBUG
00000AB6                          1788mm     ENDC
00000AB6                          1789mm 
00000AB6                          1790mm     ENDM
00000AB6  7407                    1791m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AB8                          1792m LOOP_120
00000AB8                          1793mm     BIN2HEX D7,D6,A1
00000AB8  43F9 00000E61           1794mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000ABE  E99F                    1795mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AC0  1C07                    1796mm     MOVE.B D7,D6
00000AC2  0286 0000000F           1797mm     ANDI.L #$F,D6
00000AC8  1C31 6000               1798mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000ACC                          1799mm     ENDM
00000ACC                          1800mm     PRINT_CHAR D6,D5
00000ACC                          1801mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACC                 TRUE     1802mm     IFEQ DEBUG
00000ACC  1A39 00C00003           1803mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AD2  0805 0002               1804mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AD6  67F4                    1805mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000AD8  13C6 00C00007           1806mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000ADE                          1807mm     ENDC
00000ADE                          1808mm     
00000ADE                 FALSE    1809mm     IFNE DEBUG
00000ADE                          1810mm     ENDC
00000ADE                          1811mm 
00000ADE                          1812mm     ENDM
00000ADE  57CA FFD8               1813m     DBEQ D2,LOOP_120
00000AE2                          1814m     ENDM
00000AE2                          1815m     PRINT_CRLF D5,A4     
00000AE2  49F9 00000E9C           1816m     LEA CRLF,A4
00000AE8                          1817mm     PRINT_STR A4,D5
00000AE8                          1818mm LOOP_126
00000AE8  0C14 0000               1819mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000AEC  6700 0016               1820mm     BEQ EXIT_126
00000AF0                          1821mmm     PRINT_CHAR (A4)+,D5
00000AF0                          1822mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                 TRUE     1823mmm     IFEQ DEBUG
00000AF0  1A39 00C00003           1824mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AF6  0805 0002               1825mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AFA  67F4                    1826mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AFC  13DC 00C00007           1827mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B02                          1828mmm     ENDC
00000B02                          1829mmm     
00000B02                 FALSE    1830mmm     IFNE DEBUG
00000B02                          1831mmm     ENDC
00000B02                          1832mmm 
00000B02                          1833mmm     ENDM
00000B02  60E4                    1834mm     BRA LOOP_126
00000B04                          1835mm EXIT_126
00000B04                          1836mm     ENDM
00000B04                          1837m     ENDM
00000B04                          1838          
00000B04  6000 F65E               1839      BRA MAIN_LOOP
00000B08                          1840      
00000B08                          1841  G
00000B08  2047                    1842      MOVE.L D7,A0                                    ; address accumulator -> address register
00000B0A  3E3C 0000               1843      MOVE #0,D7                                      ; clear the now used address accumulator
00000B0E  4ED0                    1844      JMP (A0)                                        ; jump to it!
00000B10                          1845      
00000B10                          1846  Z
00000B10  207C 00200000           1847      MOVE.L #RAM,A0                                  ; address of RAM
00000B16  7000                    1848      MOVE.L #0,D0                                    ; number of bytes
00000B18                          1849     
00000B18                          1850      WHILE.L D0 <LE> #$40000 DO                      ; read the data bytes
00000B18                          1851s _10000014
00000B18  B0BC 00040000           1852s     CMP.L   #$40000,D0
00000B1E  6E00 001A               1853s     BGT _10000015
00000B22  2200                    1854          MOVE.L D0,D1                                ; progress update
00000B24  E089                    1855          LSR.L #8,D1 
00000B26  E089                    1856          LSR.L #8,D1
00000B28  0281 0000000F           1857          ANDI.L #$F,D1
00000B2E  13C1 00E00001           1858          MOVE.B D1,DISPLAY
00000B34                          1859  
00000B34  20C0                    1860          MOVE.L D0,(A0)+ 
00000B36  5880                    1861          ADD.L #4,D0
00000B38                          1862      ENDW
00000B38  60DE                    1863s     BRA _10000014
00000B3A                          1864s _10000015
00000B3A                          1865   
00000B3A  207C 00200000           1866      MOVE.L #RAM,A0                                  ; address of RAM
00000B40  7000                    1867      MOVE.L #0,D0                                    ; number of bytes
00000B42                          1868     
00000B42                          1869      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000B42                          1870s _10000016
00000B42  B0BC 00040000           1871s     CMP.L   #$40000,D0
00000B48  6E00 00C2               1872s     BGT _10000017
00000B4C  2200                    1873          MOVE.L D0,D1                            ; progress update
00000B4E  E089                    1874          LSR.L #8,D1
00000B50  E089                    1875          LSR.L #8,D1
00000B52  0281 0000000F           1876          ANDI.L #$F,D1
00000B58  13C1 00E00001           1877          MOVE.B D1,DISPLAY
00000B5E                          1878  
00000B5E  2218                    1879          MOVE.L (A0)+,D1
00000B60                          1880            
00000B60                          1881          IF.L D0 <EQ> D1 THEN
00000B60  B081                    1882s     CMP.L   D1,D0
00000B62  6600 0006               1883s     BNE _0000000B
00000B66  6000 009E               1884              BRA OK
00000B6A                          1885          ENDI 
00000B6A                          1886s _0000000B
00000B6A                          1887            
00000B6A  43F9 00000E4F           1888          LEA RAM_ERROR,A1
00000B70                          1889m         PRINT_STR A1,D1
00000B70                          1890m LOOP_128
00000B70  0C11 0000               1891m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B74  6700 0016               1892m     BEQ EXIT_128
00000B78                          1893mm     PRINT_CHAR (A1)+,D1
00000B78                          1894mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B78                 TRUE     1895mm     IFEQ DEBUG
00000B78  1239 00C00003           1896mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B7E  0801 0002               1897mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B82  67F4                    1898mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B84  13D9 00C00007           1899mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B8A                          1900mm     ENDC
00000B8A                          1901mm     
00000B8A                 FALSE    1902mm     IFNE DEBUG
00000B8A                          1903mm     ENDC
00000B8A                          1904mm 
00000B8A                          1905mm     ENDM
00000B8A  60E4                    1906m     BRA LOOP_128
00000B8C                          1907m EXIT_128
00000B8C                          1908m     ENDM
00000B8C  2208                    1909          MOVE.L A0,D1
00000B8E  5981                    1910          SUB.L #4,D1
00000B90                          1911m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B90                          1912mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00000B90                          1913mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     1914mm     IFEQ DEBUG
00000B90  1639 00C00003           1915mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B96  0803 0002               1916mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    1917mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B9C  13FC 0030 00C00007      1918mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BA4                          1919mm     ENDC
00000BA4                          1920mm     
00000BA4                 FALSE    1921mm     IFNE DEBUG
00000BA4                          1922mm     ENDC
00000BA4                          1923mm 
00000BA4                          1924mm     ENDM
00000BA4                          1925mm     PRINT_CHAR #'x',D3
00000BA4                          1926mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     1927mm     IFEQ DEBUG
00000BA4  1639 00C00003           1928mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BAA  0803 0002               1929mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    1930mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000BB0  13FC 0078 00C00007      1931mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BB8                          1932mm     ENDC
00000BB8                          1933mm     
00000BB8                 FALSE    1934mm     IFNE DEBUG
00000BB8                          1935mm     ENDC
00000BB8                          1936mm 
00000BB8                          1937mm     ENDM
00000BB8  7C07                    1938m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBA                          1939m LOOP_130
00000BBA                          1940mm     BIN2HEX D1,D2,A1
00000BBA  43F9 00000E61           1941mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000BC0  E999                    1942mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC2  1401                    1943mm     MOVE.B D1,D2
00000BC4  0282 0000000F           1944mm     ANDI.L #$F,D2
00000BCA  1431 2000               1945mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BCE                          1946mm     ENDM
00000BCE                          1947mm     PRINT_CHAR D2,D3
00000BCE                          1948mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCE                 TRUE     1949mm     IFEQ DEBUG
00000BCE  1639 00C00003           1950mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BD4  0803 0002               1951mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD8  67F4                    1952mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000BDA  13C2 00C00007           1953mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BE0                          1954mm     ENDC
00000BE0                          1955mm     
00000BE0                 FALSE    1956mm     IFNE DEBUG
00000BE0                          1957mm     ENDC
00000BE0                          1958mm 
00000BE0                          1959mm     ENDM
00000BE0  57CE FFD8               1960m     DBEQ D6,LOOP_130
00000BE4                          1961m     ENDM
00000BE4                          1962m         PRINT_CRLF D3,A1
00000BE4  43F9 00000E9C           1963m     LEA CRLF,A1
00000BEA                          1964mm     PRINT_STR A1,D3
00000BEA                          1965mm LOOP_136
00000BEA  0C11 0000               1966mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BEE  6700 0016               1967mm     BEQ EXIT_136
00000BF2                          1968mmm     PRINT_CHAR (A1)+,D3
00000BF2                          1969mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF2                 TRUE     1970mmm     IFEQ DEBUG
00000BF2  1639 00C00003           1971mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BF8  0803 0002               1972mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BFC  67F4                    1973mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000BFE  13D9 00C00007           1974mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C04                          1975mmm     ENDC
00000C04                          1976mmm     
00000C04                 FALSE    1977mmm     IFNE DEBUG
00000C04                          1978mmm     ENDC
00000C04                          1979mmm 
00000C04                          1980mmm     ENDM
00000C04  60E4                    1981mm     BRA LOOP_136
00000C06                          1982mm EXIT_136
00000C06                          1983mm     ENDM
00000C06                          1984m     ENDM
00000C06                          1985  OK    
00000C06  5880                    1986          ADD.L #4,D0
00000C08                          1987      ENDW
00000C08  6000 FF38               1988s     BRA _10000016
00000C0C                          1989s _10000017
00000C0C                          1990      
00000C0C  6000 F556               1991      BRA MAIN_LOOP
00000C10                          1992    
00000C10                          1993  L
00000C10  7A00                    1994      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000C12                          1995  
00000C12                          1996      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000C12  3C3C 0000               1997s     MOVE.W  #0,D6
00000C16  6000 0048               1998s     BRA _20000001
00000C1A                          1999s _20000000
00000C1A  E98D                    2000          LSL.L #4,D5                                 ; make what we have so far more significant
00000C1C                          2001m         WAIT_CHAR D2,D3                             ; next character -> D2
00000C1C                          2002m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1C                 TRUE     2003m     IFEQ DEBUG
00000C1C  1639 00C00003           2004m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C22  0803 0000               2005m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000C26  67F4                    2006m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000C28                          2007m     ENDC
00000C28                          2008m     
00000C28                          2009mm     READ_CHAR D2
00000C28                 TRUE     2010mm     IFEQ DEBUG
00000C28  1439 00C00007           2011mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000C2E                          2012mm     ENDC
00000C2E                 FALSE    2013mm     IFNE DEBUG
00000C2E                          2014mm     ENDC
00000C2E                          2015mm      
00000C2E  B43C 001B               2016mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000C32  6700 F3D4               2017mm     BEQ START
00000C36                          2018mm     ENDM
00000C36                          2019m 
00000C36                 TRUE     2020m     IFEQ DEBUG
00000C36                          2021mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000C36                          2022mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C36                 TRUE     2023mm     IFEQ DEBUG
00000C36  1639 00C00003           2024mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C3C  0803 0002               2025mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C40  67F4                    2026mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000C42  13C2 00C00007           2027mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C48                          2028mm     ENDC
00000C48                          2029mm     
00000C48                 FALSE    2030mm     IFNE DEBUG
00000C48                          2031mm     ENDC
00000C48                          2032mm 
00000C48                          2033mm     ENDM
00000C48                          2034m     ENDC
00000C48                          2035m     ENDM
00000C48                          2036m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000C48  41F9 00000E71           2037m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000C4E  0402 0030               2038m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C52  C4BC 000000FF           2039m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000C58  1430 2000               2040m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000C5C                          2041m     ENDM
00000C5C  8A02                    2042          OR.B D2,D5
00000C5E                          2043      ENDF
00000C5E  5246                    2044s     ADD.W   #1,D6
00000C60                          2045s _20000001
00000C60  BC7C 0003               2046s     CMP.W   #3,D6
00000C64  6FB4                    2047s     BLE _20000000
00000C66                          2048            
00000C66                          2049m     PRINT_CRLF D3,A0
00000C66  41F9 00000E9C           2050m     LEA CRLF,A0
00000C6C                          2051mm     PRINT_STR A0,D3
00000C6C                          2052mm LOOP_143
00000C6C  0C10 0000               2053mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C70  6700 0016               2054mm     BEQ EXIT_143
00000C74                          2055mmm     PRINT_CHAR (A0)+,D3
00000C74                          2056mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C74                 TRUE     2057mmm     IFEQ DEBUG
00000C74  1639 00C00003           2058mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C7A  0803 0002               2059mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C7E  67F4                    2060mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C80  13D8 00C00007           2061mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C86                          2062mmm     ENDC
00000C86                          2063mmm     
00000C86                 FALSE    2064mmm     IFNE DEBUG
00000C86                          2065mmm     ENDC
00000C86                          2066mmm 
00000C86                          2067mmm     ENDM
00000C86  60E4                    2068mm     BRA LOOP_143
00000C88                          2069mm EXIT_143
00000C88                          2070mm     ENDM
00000C88                          2071m     ENDM
00000C88                          2072  
00000C88  207C 00000000           2073      MOVE.L #ROM,A0                                  ; start of ROM
00000C8E                          2074      
00000C8E  2247                    2075      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C90  7E00                    2076      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C92                          2077      
00000C92  31FC AAAA 2AAA          2078      MOVE.W #$AAAA,$2AAA
00000C98  31FC 5555 1554          2079      MOVE.W #$5555,$1554
00000C9E  31FC 8080 2AAA          2080      MOVE.W #$8080,$2AAA
00000CA4  31FC AAAA 2AAA          2081      MOVE.W #$AAAA,$2AAA
00000CAA  31FC 5555 1554          2082      MOVE.W #$5555,$1554
00000CB0  31FC 2020 2AAA          2083      MOVE.W #$2020,$2AAA
00000CB6                          2084      
00000CB6  45F9 00000E88           2085      LEA LOADING,A2                              ; important for timing
00000CBC                          2086m     PRINT_STR A2,D3
00000CBC                          2087m LOOP_145
00000CBC  0C12 0000               2088m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CC0  6700 0016               2089m     BEQ EXIT_145
00000CC4                          2090mm     PRINT_CHAR (A2)+,D3
00000CC4                          2091mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CC4                 TRUE     2092mm     IFEQ DEBUG
00000CC4  1639 00C00003           2093mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CCA  0803 0002               2094mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CCE  67F4                    2095mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000CD0  13DA 00C00007           2096mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CD6                          2097mm     ENDC
00000CD6                          2098mm     
00000CD6                 FALSE    2099mm     IFNE DEBUG
00000CD6                          2100mm     ENDC
00000CD6                          2101mm 
00000CD6                          2102mm     ENDM
00000CD6  60E4                    2103m     BRA LOOP_145
00000CD8                          2104m EXIT_145
00000CD8                          2105m     ENDM
00000CD8                          2106      
00000CD8                          2107      WHILE D5 <GT> #0 DO
00000CD8                          2108s _10000018
00000CD8  BA7C 0000               2109s     CMP.W   #0,D5
00000CDC  6F00 001C               2110s     BLE _10000019
00000CE0  5585                    2111          SUB.L #2,D5
00000CE2                          2112            
00000CE2  13D1 00E00001           2113          MOVE.B (A1),DISPLAY
00000CE8  3091                    2114          MOVE.W (A1),(A0)                            ; write the data
00000CEA                          2115        
00000CEA                          2116  WAIT_FOR_COMPLETE
00000CEA  3410                    2117          MOVE.W (A0),D2
00000CEC                          2118  
00000CEC                          2119          IF D2 <NE> (A1) THEN
00000CEC  B451                    2120s     CMP.W   (A1),D2
00000CEE  6700 0004               2121s     BEQ _0000000C
00000CF2  60F6                    2122              BRA WAIT_FOR_COMPLETE
00000CF4                          2123          ENDI
00000CF4                          2124s _0000000C
00000CF4                          2125        
00000CF4  5488                    2126          ADD.L #2,A0
00000CF6  5489                    2127          ADD.L #2,A1
00000CF8                          2128       ENDW  
00000CF8  60DE                    2129s     BRA _10000018
00000CFA                          2130s _10000019
00000CFA                          2131      
00000CFA  31FC AAAA 2AAA          2132      MOVE.W #$AAAA,$2AAA
00000D00  31FC 5555 1554          2133      MOVE.W #$5555,$1554
00000D06  31FC A0A0 2AAA          2134      MOVE.W #$A0A0,$2AAA
00000D0C                          2135              
00000D0C  6000 F456               2136      BRA MAIN_LOOP
00000D10                          2137          
00000D10                          2138  HEX_DIGIT
00000D10  E98F                    2139      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000D12                          2140m     HEX2BIN D2,D2,A0
00000D12  41F9 00000E71           2141m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000D18  0402 0030               2142m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D1C  C4BC 000000FF           2143m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000D22  1430 2000               2144m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000D26                          2145m     ENDM
00000D26  8E02                    2146      OR.B D2,D7  
00000D28  6000 F462               2147      BRA GET_INPUT
00000D2C                          2148  
00000D2C  FFFF FFFF               2149      SIMHALT                                         ; halt simulator
00000D30                          2150  
00000D30                          2151  ; strings
00000D30= 4D 44 46 2D 6D 6F ...   2152  VERSION DC.B 'MDF-mon V1.51 (10/04/2021)',CR,LF,NULL
00000D4D= 3F 09 09 09 68 65 ...   2153  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000D57= 5B 76 5D 09 09 09 ...   2154          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000D66= 78 78 78 78 78 78 ...   2155          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D7E= 78 78 78 78 78 78 ...   2156          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D9E= 5B 73 5D 09 09 09 ...   2157          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000DB8= 78 78 78 78 78 78 ...   2158          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000DC9= 5B 7A 5D 09 09 09 ...   2159          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000DDB= 78 78 78 78 78 78 ...   2160          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000DFD= 48 75 68 3F 0D 0A 00    2161  HUH     DC.B 'Huh?',CR,LF,NULL
00000E04= 20 53 20 72 65 63 ...   2162  READ    DC.B ' S records read, start address = ',NULL
00000E26= 57 3A 20 55 6E 6B ...   2163  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000E3D= 57 3A 20 43 53 20 ...   2164  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000E4F= 57 3A 20 52 41 4D ...   2165  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000E61= 30 31 32 33 34 35 ...   2166  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E71= 00 01 02 03 04 05 ...   2167  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E88= 4C 6F 61 64 69 6E ...   2168  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E9C= 0D 0A 00                2169  CRLF    DC.B CR,LF,NULL
00000E9F                          2170      
00000E9F                          2171      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         E61
CONTINUE_37         3BA
CONTINUE_40         40A
CONTINUE_44         462
CONTINUE_52         51A
CONTINUE_57         58E
CONTINUE_62         60C
CONTINUE_67         690
CONTINUE_72         71E
CONTINUE_77         792
CONTINUE_82         806
CONTINUE_96         904
CR                  D
CRLF                E9C
CS_FAILURE          E3D
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            962
DOWNLOAD_BYTE       C47
DOWNLOAD_DONE       A16
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_101            970
EXIT_103            99A
EXIT_111            A10
EXIT_118            A8C
EXIT_126            B04
EXIT_128            B8C
EXIT_136            C06
EXIT_143            C88
EXIT_145            CD8
EXIT_16             212
EXIT_18             264
EXIT_20             294
EXIT_28             312
EXIT_3              116
EXIT_35             392
EXIT_49             4D6
EXIT_5              138
EXIT_8              15A
EXIT_87             87E
EXIT_89             8A0
EXIT_93             8D4
G                   B08
GET_INPUT           18C
H                   268
HELP                D4D
HEX2BIN             134
HEX2BIN_LUT         E71
HEX_DIGIT           D10
HUH                 DFD
L                   C10
LF                  A
LOADING             E88
LOOP_101            954
LOOP_103            97E
LOOP_105            9C4
LOOP_111            9F4
LOOP_113            A40
LOOP_118            A70
LOOP_120            AB8
LOOP_126            AE8
LOOP_128            B70
LOOP_130            BBA
LOOP_136            BEA
LOOP_143            C6C
LOOP_145            CBC
LOOP_16             1F6
LOOP_18             248
LOOP_20             278
LOOP_22             2C6
LOOP_28             2F6
LOOP_3              FA
LOOP_35             376
LOOP_49             4BA
LOOP_5              11C
LOOP_8              13E
LOOP_87             862
LOOP_89             884
LOOP_93             8B8
MAIN_LOOP           164
NULL                0
OK                  C06
PRINTSTR            278
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
R                   298
RAM                 200000
RAM_ERROR           E4F
READ                E04
READ_CHAR           7FC
READ_DATA_TO_POKE   31E
RESET               4
ROM                 0
S                   396
STACK               0
START               8
TAB                 9
UNREC               E26
V                   272
VERSION             D30
W                   318
WAIT_CHAR           64D
WAIT_FOR_COMPLETE   CEA
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   164
WAIT_FOR_READY_102  95C
WAIT_FOR_READY_104  986
WAIT_FOR_READY_106  99A
WAIT_FOR_READY_107  9AE
WAIT_FOR_READY_109  9D8
WAIT_FOR_READY_11   178
WAIT_FOR_READY_112  9FC
WAIT_FOR_READY_114  A16
WAIT_FOR_READY_115  A2A
WAIT_FOR_READY_117  A54
WAIT_FOR_READY_119  A78
WAIT_FOR_READY_12   18C
WAIT_FOR_READY_121  A8E
WAIT_FOR_READY_122  AA2
WAIT_FOR_READY_124  ACC
WAIT_FOR_READY_127  AF0
WAIT_FOR_READY_129  B78
WAIT_FOR_READY_131  B90
WAIT_FOR_READY_132  BA4
WAIT_FOR_READY_134  BCE
WAIT_FOR_READY_137  BF2
WAIT_FOR_READY_138  C1C
WAIT_FOR_READY_14   1A6
WAIT_FOR_READY_140  C36
WAIT_FOR_READY_144  C74
WAIT_FOR_READY_146  CC4
WAIT_FOR_READY_17   1FE
WAIT_FOR_READY_19   250
WAIT_FOR_READY_21   280
WAIT_FOR_READY_23   29C
WAIT_FOR_READY_24   2B0
WAIT_FOR_READY_26   2DA
WAIT_FOR_READY_29   2FE
WAIT_FOR_READY_30   320
WAIT_FOR_READY_32   33A
WAIT_FOR_READY_36   37E
WAIT_FOR_READY_37   39E
WAIT_FOR_READY_39   3D8
WAIT_FOR_READY_4    102
WAIT_FOR_READY_40   3EE
WAIT_FOR_READY_42   422
WAIT_FOR_READY_44   446
WAIT_FOR_READY_46   47A
WAIT_FOR_READY_50   4C2
WAIT_FOR_READY_52   4FE
WAIT_FOR_READY_54   532
WAIT_FOR_READY_57   572
WAIT_FOR_READY_59   5A6
WAIT_FOR_READY_6    124
WAIT_FOR_READY_62   5F0
WAIT_FOR_READY_64   624
WAIT_FOR_READY_67   674
WAIT_FOR_READY_69   6A8
WAIT_FOR_READY_72   702
WAIT_FOR_READY_74   736
WAIT_FOR_READY_77   776
WAIT_FOR_READY_79   7AA
WAIT_FOR_READY_82   7EA
WAIT_FOR_READY_84   81E
WAIT_FOR_READY_88   86A
WAIT_FOR_READY_9    146
WAIT_FOR_READY_90   88C
WAIT_FOR_READY_91   8A0
WAIT_FOR_READY_94   8C0
WAIT_FOR_READY_96   8E8
WAIT_FOR_READY_98   91C
WAIT_FOR_SRECORD    39E
Z                   B10
_00000000           1CC
_00000001           1E0
_00000002           4DE
_00000003           8D8
_00000004           4EC
_00000005           6EA
_00000006           656
_00000007           8D8
_00000008           85C
_00000009           8D8
_0000000A           A14
_0000000B           B6A
_0000000C           CF4
_10000000           43C
_10000001           4A6
_10000002           4F4
_10000003           55E
_10000004           568
_10000005           5D2
_10000006           5E6
_10000007           650
_10000008           65A
_10000009           6E2
_1000000A           66A
_1000000B           6D4
_1000000C           6F8
_1000000D           762
_1000000E           76C
_1000000F           7D6
_10000010           7E0
_10000011           84A
_10000012           8DE
_10000013           948
_10000014           B18
_10000015           B3A
_10000016           B42
_10000017           C0C
_10000018           CD8
_10000019           CFA
_20000000           C1A
_20000001           C60
