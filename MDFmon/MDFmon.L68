00230008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 17:53:42

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ;ORG  $0
00230000                            21      ORG  $230000
00230000                            22  
00230000  =00000000                 23  DEBUG               EQU 0
00230000                            24  
00230000                            25  ; constants
00230000  =00000000                 26  NULL                EQU 0
00230000  =00000009                 27  TAB                 EQU 9
00230000  =0000000D                 28  CR                  EQU 13
00230000  =0000000A                 29  LF                  EQU 10
00230000                            30  
00230000  =00000000                 31  ROM                 EQU $0
00230000  =00200000                 32  RAM                 EQU $200000
00230000                            33     
00230000  =00C00000                 34  DUART_BASE          EQU $C00000
00230000  =00000000                 35  DUART_MRA_          EQU $0
00230000  =00000001                 36  DUART_CSRA_         EQU $1
00230000  =00000001                 37  DUART_SRA_          EQU $1
00230000  =00000002                 38  DUART_CRA_          EQU $2
00230000  =00000003                 39  DUART_TXA_          EQU $3
00230000  =00000003                 40  DUART_RXA_          EQU $3
00230000  =00000004                 41  DUART_ACR_          EQU $4
00230000  =00000005                 42  DUART_IMR_          EQU $5
00230000  =00000008                 43  DUART_MRB_          EQU $8
00230000  =00000009                 44  DUART_CSRB_         EQU $9
00230000  =00000009                 45  DUART_SRB_          EQU $9
00230000  =0000000A                 46  DUART_CRB_          EQU $A
00230000  =0000000B                 47  DUART_TXB_          EQU $B
00230000  =0000000B                 48  DUART_RXB_          EQU $B
00230000  =0000000C                 49  DUART_IVR_          EQU $C
00230000  =0000000D                 50  DUART_OPCR_         EQU $D
00230000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00230000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00230000                            53  
00230000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00230000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00230000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00230000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00230000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00230000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00230000                            60  
00230000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00230000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00230000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00230000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00230000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00230000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00230000                            67  
00230000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00230000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00230000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00230000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00230000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00230000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00230000                            74  
00230000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00230000  =00000000                 76  DISPLAY_            EQU $0
00230000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00230000                            78  
00230000                            79  ; macros
00230000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00230000                            81  ; the input register is changed during the process
00230000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00230000                            83  BIN2HEX MACRO
00230000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00230000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00230000                            86      MOVE.B \1,\2
00230000                            87      ANDI.L #$F,\2
00230000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00230000                            89      ENDM
00230000                            90  
00230000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00230000                            92  ; the input register is changed during the process
00230000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00230000                            94  HEX2BIN MACRO
00230000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00230000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00230000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00230000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00230000                            99      ENDM
00230000                           100  
00230000                           101  ; send a single char to the serial port
00230000                           102  ; \1 = char to send, \2 = data register to use for status poll
00230000                           103  ; will stamp on D0 and D1 in debug mode
00230000                           104  PRINT_CHAR MACRO
00230000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00230000                           106      IFEQ DEBUG
00230000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00230000                           108          BTST #2,\2                              ; check for space to send
00230000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00230000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00230000                           111      ENDC
00230000                           112      
00230000                           113      IFNE DEBUG
00230000                           114          MOVE.B \1,D1
00230000                           115          MOVE.L #6,D0   
00230000                           116          TRAP #15                                ; write to terminal in simulator
00230000                           117      ENDC
00230000                           118  
00230000                           119      ENDM
00230000                           120  
00230000                           121  ; send CR,LF to the serial port
00230000                           122  ; \1 = data register to use for status poll, /2 = working address register
00230000                           123  PRINT_CRLF MACRO
00230000                           124      LEA CRLF,\2
00230000                           125      PRINT_STR \2,\1
00230000                           126      ENDM
00230000                           127  
00230000                           128  ; send C-style, zero terminated string to the serial port
00230000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00230000                           130  PRINT_STR MACRO
00230000                           131  LOOP\@
00230000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00230000                           133      BEQ EXIT\@
00230000                           134      PRINT_CHAR (\1)+,\2
00230000                           135      BRA LOOP\@
00230000                           136  EXIT\@
00230000                           137      ENDM
00230000                           138    
00230000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00230000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00230000                           141  PRINT_REG MACRO
00230000                           142      PRINT_CHAR #'0',\2                              ;0x header
00230000                           143      PRINT_CHAR #'x',\2
00230000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00230000                           145  LOOP\@
00230000                           146      BIN2HEX \1,\3,\5
00230000                           147      PRINT_CHAR \3,\2
00230000                           148      DBEQ \4,LOOP\@
00230000                           149      ENDM
00230000                           150      
00230000                           151  ; wait for a char from the serial port
00230000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00230000                           153  ; will stamp on D0 and D1 in debug mode
00230000                           154  WAIT_CHAR MACRO
00230000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00230000                           156      IFEQ DEBUG
00230000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00230000                           158          BTST #0,\2                              ; check for character
00230000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00230000                           160      ENDC
00230000                           161      
00230000                           162      READ_CHAR \1
00230000                           163  
00230000                           164      IFEQ DEBUG
00230000                           165          PRINT_CHAR \1,\2                            ; echo it back
00230000                           166      ENDC
00230000                           167      ENDM
00230000                           168      
00230000                           169  ; read a char from the serial port - assumes that there is one!
00230000                           170  ; \ 1= data register for read char
00230000                           171  ; will stamp on D0 and D1 in debug mode
00230000                           172  READ_CHAR MACRO
00230000                           173      IFEQ DEBUG
00230000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00230000                           175      ENDC
00230000                           176      IFNE DEBUG
00230000                           177          MOVE.L #5,D0    
00230000                           178          TRAP #15                                    ; read from keyboard in simulator
00230000                           179          MOVE.L D1,\1
00230000                           180      ENDC
00230000                           181       
00230000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00230000                           183      BEQ START
00230000                           184      ENDM
00230000                           185      
00230000                           186      
00230000                           187  ; read data from the download serial port
00230000                           188  ; \ 1= data register for read char
00230000                           189  DOWNLOAD MACRO
00230000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00230000                           191  
00230000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00230000                           193      BTST #0,\1                                  ; check for character
00230000                           194      BEQ CONTINUE\@                              ; nothing, continue
00230000                           195   
00230000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00230000                           197  CONTINUE\@
00230000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00230000                           199      BTST #0,\1                                      ; check for character
00230000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00230000                           201      
00230000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00230000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00230000                           204      
00230000                           205      ENDM
00230000                           206      
00230000                           207  ; read two hex digits from the download serial port and convert to a byte
00230000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00230000                           209  DOWNLOAD_BYTE MACRO
00230000                           210      MOVE.B #2,\4
00230000                           211      WHILE.B \4 <GT> 0 DO
00230000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00230000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00230000                           214          PRINT_CHAR \2,\3
00230000                           215          HEX2BIN \2,\2,\6
00230000                           216          OR.B \2,\1
00230000                           217          SUB.B #1,\4
00230000                           218      ENDW
00230000                           219      
00230000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00230000                           221      MOVE.B \1,\2
00230000                           222      ADD.L \1,\5
00230000                           223  
00230000                           224      ENDM
00230000                           225      
00230000                           226  
00230000                           227  ; register catalogue
00230000                           228  ; D0 - used for simulator I/O
00230000                           229  ; D1 - used for simulator I/O
00230000                           230  ; D2 - read character
00230000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00230000                           232  ; D6 - working register used in R/W
00230000                           233  ; D7 - address accumulator, reset by download
00230000                           234  ; A0 - address of string to print 
00230000                           235  
00230000                           236  ; start vector
00230000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00230004= 00230008                 238  RESET    DC.L START                             ; RESET
00230008                           239      
00230008                           240  ; start of program  
00230008                           241  START
00230008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00230010                           243  
00230010                           244  ; reset the UART in case of warm start
00230010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00230018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                           ; reset everyting
00230020  4E71                     247      NOP
00230022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0023002A  4E71                     249      NOP
0023002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00230034  4E71                     251      NOP
00230036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0023003E  4E71                     253      NOP
00230040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00230048                           255  
00230048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00230050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                           ; reset everyting
00230058  4E71                     258      NOP
0023005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00230062  4E71                     260      NOP
00230064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0023006C  4E71                     262      NOP
0023006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00230076  4E71                     264      NOP
00230078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00230080                           266  
00230080                           267  ;initialise UART
00230080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00230088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00230090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00230098                           271  
00230098                           272  ; channel A
00230098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
002300A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
002300A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
002300B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
002300B8                           277  
002300B8                           278  ; channel B
002300B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
002300C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
002300C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
002300D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
002300D8                           283  
002300D8                           284m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
002300D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002300D8                 TRUE      286m     IFEQ DEBUG
002300D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002300DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002300E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002300E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002300EC                           291m     ENDC
002300EC                           292m     
002300EC                 FALSE     293m     IFNE DEBUG
002300EC                           294m     ENDC
002300EC                           295m 
002300EC                           296m     ENDM
002300EC                           297  
002300EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
002300F4                           299         
002300F4                           300m     PRINT_CRLF D3,A0
002300F4  41F9 00230E86            301m     LEA CRLF,A0
002300FA                           302mm     PRINT_STR A0,D3
002300FA                           303mm LOOP_3
002300FA  0C10 0000                304mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
002300FE  6700 0016                305mm     BEQ EXIT_3
00230102                           306mmm     PRINT_CHAR (A0)+,D3
00230102                           307mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230102                 TRUE      308mmm     IFEQ DEBUG
00230102  1639 00C00003            309mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230108  0803 0002                310mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0023010C  67F4                     311mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
0023010E  13D8 00C00007            312mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230114                           313mmm     ENDC
00230114                           314mmm     
00230114                 FALSE     315mmm     IFNE DEBUG
00230114                           316mmm     ENDC
00230114                           317mmm 
00230114                           318mmm     ENDM
00230114  60E4                     319mm     BRA LOOP_3
00230116                           320mm EXIT_3
00230116                           321mm     ENDM
00230116                           322m     ENDM
00230116                           323  
00230116  41F9 00230D1A            324      LEA VERSION,A0
0023011C                           325m     PRINT_STR A0,D3
0023011C                           326m LOOP_5
0023011C  0C10 0000                327m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00230120  6700 0016                328m     BEQ EXIT_5
00230124                           329mm     PRINT_CHAR (A0)+,D3
00230124                           330mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230124                 TRUE      331mm     IFEQ DEBUG
00230124  1639 00C00003            332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0023012A  0803 0002                333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0023012E  67F4                     334mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00230130  13D8 00C00007            335mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230136                           336mm     ENDC
00230136                           337mm     
00230136                 FALSE     338mm     IFNE DEBUG
00230136                           339mm     ENDC
00230136                           340mm 
00230136                           341mm     ENDM
00230136  60E4                     342m     BRA LOOP_5
00230138                           343m EXIT_5
00230138                           344m     ENDM
00230138                           345m     PRINT_CRLF D3,A0
00230138  41F9 00230E86            346m     LEA CRLF,A0
0023013E                           347mm     PRINT_STR A0,D3
0023013E                           348mm LOOP_8
0023013E  0C10 0000                349mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00230142  6700 0016                350mm     BEQ EXIT_8
00230146                           351mmm     PRINT_CHAR (A0)+,D3
00230146                           352mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230146                 TRUE      353mmm     IFEQ DEBUG
00230146  1639 00C00003            354mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0023014C  0803 0002                355mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230150  67F4                     356mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00230152  13D8 00C00007            357mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230158                           358mmm     ENDC
00230158                           359mmm     
00230158                 FALSE     360mmm     IFNE DEBUG
00230158                           361mmm     ENDC
00230158                           362mmm 
00230158                           363mmm     ENDM
00230158  60E4                     364mm     BRA LOOP_8
0023015A                           365mm EXIT_8
0023015A                           366mm     ENDM
0023015A                           367m     ENDM
0023015A                           368  
0023015A  7E00                     369      MOVE.L #0,D7                                    ; address accumulator
0023015C                           370  
0023015C  13FC 0002 00E00001       371      MOVE.B #2,DISPLAY
00230164                           372  MAIN_LOOP
00230164                           373m     PRINT_CHAR #'>',D3                          ; prompt
00230164                           374m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230164                 TRUE      375m     IFEQ DEBUG
00230164  1639 00C00003            376m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0023016A  0803 0002                377m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0023016E  67F4                     378m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00230170  13FC 003E 00C00007       379m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230178                           380m     ENDC
00230178                           381m     
00230178                 FALSE     382m     IFNE DEBUG
00230178                           383m     ENDC
00230178                           384m 
00230178                           385m     ENDM
00230178                           386m     PRINT_CHAR #32,D3                           ; space
00230178                           387m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230178                 TRUE      388m     IFEQ DEBUG
00230178  1639 00C00003            389m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0023017E  0803 0002                390m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230182  67F4                     391m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00230184  13FC 0020 00C00007       392m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
0023018C                           393m     ENDC
0023018C                           394m     
0023018C                 FALSE     395m     IFNE DEBUG
0023018C                           396m     ENDC
0023018C                           397m 
0023018C                           398m     ENDM
0023018C                           399      
0023018C                           400  GET_INPUT
0023018C                           401m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0023018C                           402m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023018C                 TRUE      403m     IFEQ DEBUG
0023018C  1639 00C00003            404m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00230192  0803 0000                405m         BTST #0,D3                              ; CHECK FOR CHARACTER
00230196  67F4                     406m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00230198                           407m     ENDC
00230198                           408m     
00230198                           409mm     READ_CHAR D2
00230198                 TRUE      410mm     IFEQ DEBUG
00230198  1439 00C00007            411mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0023019E                           412mm     ENDC
0023019E                 FALSE     413mm     IFNE DEBUG
0023019E                           414mm     ENDC
0023019E                           415mm      
0023019E  B43C 001B                416mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002301A2  6700 FE64                417mm     BEQ START
002301A6                           418mm     ENDM
002301A6                           419m 
002301A6                 TRUE      420m     IFEQ DEBUG
002301A6                           421mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
002301A6                           422mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002301A6                 TRUE      423mm     IFEQ DEBUG
002301A6  1639 00C00003            424mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002301AC  0803 0002                425mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002301B0  67F4                     426mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
002301B2  13C2 00C00007            427mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002301B8                           428mm     ENDC
002301B8                           429mm     
002301B8                 FALSE     430mm     IFNE DEBUG
002301B8                           431mm     ENDC
002301B8                           432mm 
002301B8                           433mm     ENDM
002301B8                           434m     ENDC
002301B8                           435m     ENDM
002301B8                           436      
002301B8                           437      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
002301B8  B43C 0030                438s     CMP.B   #'0',D2
002301BC  6D00 000E                439s     BLT _00000000
002301C0  B43C 0039                440s     CMP.B   #'9',D2
002301C4  6E00 0006                441s     BGT _00000000
002301C8  6000 0B30                442          BRA HEX_DIGIT
002301CC                           443      ENDI
002301CC                           444s _00000000
002301CC                           445      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
002301CC  B43C 0041                446s     CMP.B   #'A',D2
002301D0  6D00 000E                447s     BLT _00000001
002301D4  B43C 0046                448s     CMP.B   #'F',D2
002301D8  6E00 0006                449s     BGT _00000001
002301DC  6000 0B1C                450          BRA HEX_DIGIT
002301E0                           451      ENDI
002301E0                           452s _00000001
002301E0                           453          
002301E0  B43C 0077                454      CMP.B #'w',D2
002301E4  6700 0132                455      BEQ W
002301E8                           456      
002301E8  B43C 006C                457      CMP.B #'l',D2
002301EC  6700 0A0C                458      BEQ L 
002301F0                           459  
002301F0                           460m     PRINT_CRLF D3,A0
002301F0  41F9 00230E86            461m     LEA CRLF,A0
002301F6                           462mm     PRINT_STR A0,D3
002301F6                           463mm LOOP_16
002301F6  0C10 0000                464mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
002301FA  6700 0016                465mm     BEQ EXIT_16
002301FE                           466mmm     PRINT_CHAR (A0)+,D3
002301FE                           467mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002301FE                 TRUE      468mmm     IFEQ DEBUG
002301FE  1639 00C00003            469mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230204  0803 0002                470mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230208  67F4                     471mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0023020A  13D8 00C00007            472mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230210                           473mmm     ENDC
00230210                           474mmm     
00230210                 FALSE     475mmm     IFNE DEBUG
00230210                           476mmm     ENDC
00230210                           477mmm 
00230210                           478mmm     ENDM
00230210  60E4                     479mm     BRA LOOP_16
00230212                           480mm EXIT_16
00230212                           481mm     ENDM
00230212                           482m     ENDM
00230212                           483   
00230212  B43C 003F                484      CMP.B #'?',D2
00230216  6700 0050                485      BEQ H
0023021A                           486  
0023021A  B43C 0076                487      CMP.B #'v',D2
0023021E  6700 0052                488      BEQ V
00230222                           489      
00230222  B43C 0072                490      CMP.B #'r',D2
00230226  6700 0070                491      BEQ R
0023022A                           492  
0023022A  B43C 0073                493      CMP.B #'s',D2
0023022E  6700 0166                494      BEQ S
00230232                           495  
00230232  B43C 0067                496      CMP.B #'g',D2
00230236  6700 08CA                497      BEQ G   
0023023A                           498  
0023023A  B43C 007A                499      CMP.B #'z',D2
0023023E  6700 08CA                500      BEQ Z   
00230242                           501  
00230242  41F9 00230DE7            502      LEA HUH,A0
00230248                           503m     PRINT_STR A0,D3
00230248                           504m LOOP_18
00230248  0C10 0000                505m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0023024C  6700 0016                506m     BEQ EXIT_18
00230250                           507mm     PRINT_CHAR (A0)+,D3
00230250                           508mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230250                 TRUE      509mm     IFEQ DEBUG
00230250  1639 00C00003            510mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230256  0803 0002                511mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0023025A  67F4                     512mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0023025C  13D8 00C00007            513mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230262                           514mm     ENDC
00230262                           515mm     
00230262                 FALSE     516mm     IFNE DEBUG
00230262                           517mm     ENDC
00230262                           518mm 
00230262                           519mm     ENDM
00230262  60E4                     520m     BRA LOOP_18
00230264                           521m EXIT_18
00230264                           522m     ENDM
00230264                           523                         
00230264  6000 FEFE                524      BRA MAIN_LOOP
00230268                           525      
00230268                           526  ; commands
00230268                           527  H   
00230268  41F9 00230D37            528      LEA HELP,A0
0023026E  6000 0008                529      BRA PRINTSTR
00230272                           530  
00230272                           531  V   
00230272  41F9 00230D1A            532      LEA VERSION,A0
00230278                           533  PRINTSTR
00230278                           534m     PRINT_STR A0,D3       
00230278                           535m LOOP_20
00230278  0C10 0000                536m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0023027C  6700 0016                537m     BEQ EXIT_20
00230280                           538mm     PRINT_CHAR (A0)+,D3
00230280                           539mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230280                 TRUE      540mm     IFEQ DEBUG
00230280  1639 00C00003            541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230286  0803 0002                542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0023028A  67F4                     543mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0023028C  13D8 00C00007            544mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230292                           545mm     ENDC
00230292                           546mm     
00230292                 FALSE     547mm     IFNE DEBUG
00230292                           548mm     ENDC
00230292                           549mm 
00230292                           550mm     ENDM
00230292  60E4                     551m     BRA LOOP_20
00230294                           552m EXIT_20
00230294                           553m     ENDM
00230294  6000 FECE                554      BRA MAIN_LOOP
00230298                           555      
00230298                           556  R   
00230298  2047                     557      MOVE.L D7,A0                                    ; address accumulator -> address register
0023029A  2A10                     558      MOVE.L (A0),D5                                  ; read the memory and print it
0023029C                           559m     PRINT_REG D5,D3,D7,D6,A0
0023029C                           560mm     PRINT_CHAR #'0',D3                              ;0X HEADER
0023029C                           561mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023029C                 TRUE      562mm     IFEQ DEBUG
0023029C  1639 00C00003            563mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002302A2  0803 0002                564mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002302A6  67F4                     565mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
002302A8  13FC 0030 00C00007       566mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002302B0                           567mm     ENDC
002302B0                           568mm     
002302B0                 FALSE     569mm     IFNE DEBUG
002302B0                           570mm     ENDC
002302B0                           571mm 
002302B0                           572mm     ENDM
002302B0                           573mm     PRINT_CHAR #'x',D3
002302B0                           574mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002302B0                 TRUE      575mm     IFEQ DEBUG
002302B0  1639 00C00003            576mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002302B6  0803 0002                577mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002302BA  67F4                     578mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
002302BC  13FC 0078 00C00007       579mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002302C4                           580mm     ENDC
002302C4                           581mm     
002302C4                 FALSE     582mm     IFNE DEBUG
002302C4                           583mm     ENDC
002302C4                           584mm 
002302C4                           585mm     ENDM
002302C4  7C07                     586m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002302C6                           587m LOOP_22
002302C6                           588mm     BIN2HEX D5,D7,A0
002302C6  41F9 00230E4B            589mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002302CC  E99D                     590mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002302CE  1E05                     591mm     MOVE.B D5,D7
002302D0  0287 0000000F            592mm     ANDI.L #$F,D7
002302D6  1E30 7000                593mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
002302DA                           594mm     ENDM
002302DA                           595mm     PRINT_CHAR D7,D3
002302DA                           596mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002302DA                 TRUE      597mm     IFEQ DEBUG
002302DA  1639 00C00003            598mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002302E0  0803 0002                599mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002302E4  67F4                     600mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
002302E6  13C7 00C00007            601mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002302EC                           602mm     ENDC
002302EC                           603mm     
002302EC                 FALSE     604mm     IFNE DEBUG
002302EC                           605mm     ENDC
002302EC                           606mm 
002302EC                           607mm     ENDM
002302EC  57CE FFD8                608m     DBEQ D6,LOOP_22
002302F0                           609m     ENDM
002302F0                           610m     PRINT_CRLF D3,A0
002302F0  41F9 00230E86            611m     LEA CRLF,A0
002302F6                           612mm     PRINT_STR A0,D3
002302F6                           613mm LOOP_28
002302F6  0C10 0000                614mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
002302FA  6700 0016                615mm     BEQ EXIT_28
002302FE                           616mmm     PRINT_CHAR (A0)+,D3
002302FE                           617mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002302FE                 TRUE      618mmm     IFEQ DEBUG
002302FE  1639 00C00003            619mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230304  0803 0002                620mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230308  67F4                     621mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
0023030A  13D8 00C00007            622mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230310                           623mmm     ENDC
00230310                           624mmm     
00230310                 FALSE     625mmm     IFNE DEBUG
00230310                           626mmm     ENDC
00230310                           627mmm 
00230310                           628mmm     ENDM
00230310  60E4                     629mm     BRA LOOP_28
00230312                           630mm EXIT_28
00230312                           631mm     ENDM
00230312                           632m     ENDM
00230312  7E00                     633      MOVE.L #0,D7                                    ; clear the now used address accumulator
00230314  6000 FE4E                634      BRA MAIN_LOOP
00230318                           635  
00230318                           636  W
00230318  7A00                     637      MOVE.L #0,D5                                    ; D5 will be the value to write            
0023031A                           638  
0023031A  3C3C 0007                639      MOVE #7,D6                                      ; 7 bytes left to read
0023031E                           640      
0023031E                           641  READ_DATA_TO_POKE
0023031E  E98D                     642      LSL.L #4,D5                                     ; make what we have so far more significant
00230320                           643m     WAIT_CHAR D2,D3                                 ; next character -> D2
00230320                           644m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230320                 TRUE      645m     IFEQ DEBUG
00230320  1639 00C00003            646m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00230326  0803 0000                647m         BTST #0,D3                              ; CHECK FOR CHARACTER
0023032A  67F4                     648m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
0023032C                           649m     ENDC
0023032C                           650m     
0023032C                           651mm     READ_CHAR D2
0023032C                 TRUE      652mm     IFEQ DEBUG
0023032C  1439 00C00007            653mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00230332                           654mm     ENDC
00230332                 FALSE     655mm     IFNE DEBUG
00230332                           656mm     ENDC
00230332                           657mm      
00230332  B43C 001B                658mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00230336  6700 FCD0                659mm     BEQ START
0023033A                           660mm     ENDM
0023033A                           661m 
0023033A                 TRUE      662m     IFEQ DEBUG
0023033A                           663mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0023033A                           664mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023033A                 TRUE      665mm     IFEQ DEBUG
0023033A  1639 00C00003            666mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230340  0803 0002                667mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230344  67F4                     668mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00230346  13C2 00C00007            669mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0023034C                           670mm     ENDC
0023034C                           671mm     
0023034C                 FALSE     672mm     IFNE DEBUG
0023034C                           673mm     ENDC
0023034C                           674mm 
0023034C                           675mm     ENDM
0023034C                           676m     ENDC
0023034C                           677m     ENDM
0023034C                           678m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0023034C  41F9 00230E5B            679m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00230352  0402 0030                680m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230356  C4BC 000000FF            681m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0023035C  1430 2000                682m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00230360                           683m     ENDM
00230360  8A02                     684      OR.B D2,D5
00230362  023C 00FB                685      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00230366  57CE FFB6                686      DBEQ D6,READ_DATA_TO_POKE
0023036A                           687      
0023036A  2047                     688      MOVE.L D7,A0                                    ; address accumulator -> address register
0023036C  7E00                     689      MOVE.L #0,D7                                    ; clear the now used address accumulator
0023036E                           690      
0023036E  2085                     691      MOVE.L D5,(A0)                                  ; write the data
00230370                           692  
00230370                           693m     PRINT_CRLF D3,A0
00230370  41F9 00230E86            694m     LEA CRLF,A0
00230376                           695mm     PRINT_STR A0,D3
00230376                           696mm LOOP_35
00230376  0C10 0000                697mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0023037A  6700 0016                698mm     BEQ EXIT_35
0023037E                           699mmm     PRINT_CHAR (A0)+,D3
0023037E                           700mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023037E                 TRUE      701mmm     IFEQ DEBUG
0023037E  1639 00C00003            702mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230384  0803 0002                703mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230388  67F4                     704mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0023038A  13D8 00C00007            705mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230390                           706mmm     ENDC
00230390                           707mmm     
00230390                 FALSE     708mmm     IFNE DEBUG
00230390                           709mmm     ENDC
00230390                           710mmm 
00230390                           711mmm     ENDM
00230390  60E4                     712mm     BRA LOOP_35
00230392                           713mm EXIT_35
00230392                           714mm     ENDM
00230392                           715m     ENDM
00230392  6000 FDD0                716      BRA MAIN_LOOP
00230396                           717  
00230396                           718  ; register map for S
00230396                           719  ; A0 - start address
00230396                           720  ; A1 - offset
00230396                           721  ; A2 - next address to write
00230396                           722  ; A3 - next location (jmp)
00230396                           723  ; A4 - Working Address Register
00230396                           724  ; D0 - record count
00230396                           725  ; D1 - 'S', record type, data byte
00230396                           726  ; D2 - checksum
00230396                           727  ; D3 - data byte count
00230396                           728  ; D4 - read address, moved into A2
00230396                           729  ; D5 - temp
00230396                           730  ; D6 - temp
00230396                           731  ; D7 - temp
00230396                           732  S
00230396  2078 0000                733      MOVE.L 0,A0                                     ; start address -> A0
0023039A  2247                     734      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0023039C                           735      
0023039C  7000                     736      MOVE.L #0,D0                                    ; count of records read -> D0
0023039E                           737          
0023039E                           738  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0023039E                           739m     DOWNLOAD D1                 
0023039E                           740m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023039E                           741m 
0023039E  1239 00C00003            742m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
002303A4  0801 0000                743m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002303A8  6700 0010                744m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
002303AC                           745m  
002303AC                           746mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
002303AC                 TRUE      747mm     IFEQ DEBUG
002303AC  1239 00C00007            748mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
002303B2                           749mm     ENDC
002303B2                 FALSE     750mm     IFNE DEBUG
002303B2                           751mm     ENDC
002303B2                           752mm      
002303B2  B23C 001B                753mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
002303B6  6700 FC50                754mm     BEQ START
002303BA                           755mm     ENDM
002303BA                           756m CONTINUE_37
002303BA  1239 00C00013            757m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
002303C0  0801 0000                758m     BTST #0,D1                                      ; CHECK FOR CHARACTER
002303C4  67D8                     759m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
002303C6                           760m     
002303C6  1239 00C00017            761m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
002303CC  13C1 00E00001            762m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
002303D2                           763m     
002303D2                           764m     ENDM
002303D2  B23C 0053                765      CMP.B #'S',D1                                   ; found S?    
002303D6  66C6                     766      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
002303D8                           767      
002303D8                           768m     PRINT_CHAR #'S',D5                            ; print the S
002303D8                           769m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002303D8                 TRUE      770m     IFEQ DEBUG
002303D8  1A39 00C00003            771m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002303DE  0805 0002                772m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002303E2  67F4                     773m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
002303E4  13FC 0053 00C00007       774m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002303EC                           775m     ENDC
002303EC                           776m     
002303EC                 FALSE     777m     IFNE DEBUG
002303EC                           778m     ENDC
002303EC                           779m 
002303EC                           780m     ENDM
002303EC  5280                     781      ADD.L #1,D0                                     ; read another S record, increment count
002303EE                           782      
002303EE                           783m     DOWNLOAD D1                                     ; read the record identifier and echo it back
002303EE                           784m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002303EE                           785m 
002303EE  1239 00C00003            786m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
002303F4  0801 0000                787m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002303F8  6700 0010                788m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
002303FC                           789m  
002303FC                           790mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
002303FC                 TRUE      791mm     IFEQ DEBUG
002303FC  1239 00C00007            792mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00230402                           793mm     ENDC
00230402                 FALSE     794mm     IFNE DEBUG
00230402                           795mm     ENDC
00230402                           796mm      
00230402  B23C 001B                797mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00230406  6700 FC00                798mm     BEQ START
0023040A                           799mm     ENDM
0023040A                           800m CONTINUE_40
0023040A  1239 00C00013            801m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00230410  0801 0000                802m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00230414  67D8                     803m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
00230416                           804m     
00230416  1239 00C00017            805m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0023041C  13C1 00E00001            806m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00230422                           807m     
00230422                           808m     ENDM
00230422                           809m     PRINT_CHAR D1,D5
00230422                           810m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230422                 TRUE      811m     IFEQ DEBUG
00230422  1A39 00C00003            812m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230428  0805 0002                813m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0023042C  67F4                     814m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0023042E  13C1 00C00007            815m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230434                           816m     ENDC
00230434                           817m     
00230434                 FALSE     818m     IFNE DEBUG
00230434                           819m     ENDC
00230434                           820m 
00230434                           821m     ENDM
00230434                           822  
00230434  7400                     823      MOVE.L #0,D2                                    ; clear the checksum
00230436                           824  
00230436                           825      ;MOVE.L #0,D3                                   ; read the 2 digit byte count -> D3
00230436                           826m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00230436  1E3C 0002                827m     MOVE.B #2,D7
0023043A                           828m     WHILE.B D7 <GT> 0 DO
0023043A                           829ms _10000000
0023043A  BE38 0000                830ms     CMP.B   0,D7
0023043E  6F00 0064                831ms     BLE _10000001
00230442  E98B                     832m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00230444                           833mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00230444                           834mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230444                           835mm 
00230444  1A39 00C00003            836mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0023044A  0805 0000                837mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0023044E  6700 0010                838mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00230452                           839mm  
00230452                           840mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00230452                 TRUE      841mmm     IFEQ DEBUG
00230452  1A39 00C00007            842mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230458                           843mmm     ENDC
00230458                 FALSE     844mmm     IFNE DEBUG
00230458                           845mmm     ENDC
00230458                           846mmm      
00230458  BA3C 001B                847mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0023045C  6700 FBAA                848mmm     BEQ START
00230460                           849mmm     ENDM
00230460                           850mm CONTINUE_44
00230460  1A39 00C00013            851mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230466  0805 0000                852mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0023046A  67D8                     853mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0023046C                           854mm     
0023046C  1A39 00C00017            855mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00230472  13C5 00E00001            856mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00230478                           857mm     
00230478                           858mm     ENDM
00230478                           859mm         PRINT_CHAR D5,D6
00230478                           860mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230478                 TRUE      861mm     IFEQ DEBUG
00230478  1C39 00C00003            862mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0023047E  0806 0002                863mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00230482  67F4                     864mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00230484  13C5 00C00007            865mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0023048A                           866mm     ENDC
0023048A                           867mm     
0023048A                 FALSE     868mm     IFNE DEBUG
0023048A                           869mm     ENDC
0023048A                           870mm 
0023048A                           871mm     ENDM
0023048A                           872mm         HEX2BIN D5,D5,A4
0023048A  49F9 00230E5B            873mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00230490  0405 0030                874mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230494  CABC 000000FF            875mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0023049A  1A34 5000                876mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0023049E                           877mm     ENDM
0023049E  8605                     878m         OR.B D5,D3
002304A0  5307                     879m         SUB.B #1,D7
002304A2                           880m     ENDW
002304A2  6096                     881ms     BRA _10000000
002304A4                           882ms _10000001
002304A4                           883m     
002304A4  7A00                     884m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002304A6  1A03                     885m     MOVE.B D3,D5
002304A8  D483                     886m     ADD.L D3,D2
002304AA                           887m 
002304AA                           888m     ENDM
002304AA                           889  
002304AA                           890      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
002304AA  B23C 0030                891s     CMP.B   #'0',D1
002304AE  6600 002C                892s     BNE.L   _00000002
002304B2                           893m         PRINT_CRLF D5,A4
002304B2  49F9 00230E86            894m     LEA CRLF,A4
002304B8                           895mm     PRINT_STR A4,D5
002304B8                           896mm LOOP_49
002304B8  0C14 0000                897mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
002304BC  6700 0016                898mm     BEQ EXIT_49
002304C0                           899mmm     PRINT_CHAR (A4)+,D5
002304C0                           900mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002304C0                 TRUE      901mmm     IFEQ DEBUG
002304C0  1A39 00C00003            902mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002304C6  0805 0002                903mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002304CA  67F4                     904mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
002304CC  13DC 00C00007            905mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002304D2                           906mmm     ENDC
002304D2                           907mmm     
002304D2                 FALSE     908mmm     IFNE DEBUG
002304D2                           909mmm     ENDC
002304D2                           910mmm 
002304D2                           911mmm     ENDM
002304D2  60E4                     912mm     BRA LOOP_49
002304D4                           913mm EXIT_49
002304D4                           914mm     ENDM
002304D4                           915m     ENDM
002304D4  6000 FEC8                916          BRA WAIT_FOR_SRECORD
002304D8                           917      ELSE
002304D8  6000 03FA                918s     BRA _00000003
002304DC                           919s _00000002
002304DC                           920          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
002304DC  B23C 0031                921s     CMP.B   #'1',D1
002304E0  6708                     922s     BEQ.S   _00000004
002304E2  B23C 0032                923s     CMP.B   #'2',D1
002304E6  6600 01FE                924s     BNE.L   _00000005
002304EA                           925s _00000004
002304EA  5783                     926              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
002304EC                           927      
002304EC  7800                     928              MOVE.L #0,D4                            ; read two bytes of address
002304EE                           929m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
002304EE  1E3C 0002                930m     MOVE.B #2,D7
002304F2                           931m     WHILE.B D7 <GT> 0 DO
002304F2                           932ms _10000002
002304F2  BE38 0000                933ms     CMP.B   0,D7
002304F6  6F00 0064                934ms     BLE _10000003
002304FA  E98C                     935m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002304FC                           936mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002304FC                           937mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002304FC                           938mm 
002304FC  1A39 00C00003            939mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00230502  0805 0000                940mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00230506  6700 0010                941mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
0023050A                           942mm  
0023050A                           943mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0023050A                 TRUE      944mmm     IFEQ DEBUG
0023050A  1A39 00C00007            945mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230510                           946mmm     ENDC
00230510                 FALSE     947mmm     IFNE DEBUG
00230510                           948mmm     ENDC
00230510                           949mmm      
00230510  BA3C 001B                950mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00230514  6700 FAF2                951mmm     BEQ START
00230518                           952mmm     ENDM
00230518                           953mm CONTINUE_52
00230518  1A39 00C00013            954mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0023051E  0805 0000                955mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230522  67D8                     956mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
00230524                           957mm     
00230524  1A39 00C00017            958mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0023052A  13C5 00E00001            959mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00230530                           960mm     
00230530                           961mm     ENDM
00230530                           962mm         PRINT_CHAR D5,D6
00230530                           963mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230530                 TRUE      964mm     IFEQ DEBUG
00230530  1C39 00C00003            965mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00230536  0806 0002                966mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0023053A  67F4                     967mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
0023053C  13C5 00C00007            968mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230542                           969mm     ENDC
00230542                           970mm     
00230542                 FALSE     971mm     IFNE DEBUG
00230542                           972mm     ENDC
00230542                           973mm 
00230542                           974mm     ENDM
00230542                           975mm         HEX2BIN D5,D5,A4
00230542  49F9 00230E5B            976mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00230548  0405 0030                977mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0023054C  CABC 000000FF            978mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00230552  1A34 5000                979mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00230556                           980mm     ENDM
00230556  8805                     981m         OR.B D5,D4
00230558  5307                     982m         SUB.B #1,D7
0023055A                           983m     ENDW
0023055A  6096                     984ms     BRA _10000002
0023055C                           985ms _10000003
0023055C                           986m     
0023055C  7A00                     987m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0023055E  1A04                     988m     MOVE.B D4,D5
00230560  D484                     989m     ADD.L D4,D2
00230562                           990m 
00230562                           991m     ENDM
00230562                           992m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00230562  1E3C 0002                993m     MOVE.B #2,D7
00230566                           994m     WHILE.B D7 <GT> 0 DO
00230566                           995ms _10000004
00230566  BE38 0000                996ms     CMP.B   0,D7
0023056A  6F00 0064                997ms     BLE _10000005
0023056E  E98C                     998m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00230570                           999mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00230570                          1000mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230570                          1001mm 
00230570  1A39 00C00003           1002mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00230576  0805 0000               1003mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0023057A  6700 0010               1004mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
0023057E                          1005mm  
0023057E                          1006mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0023057E                 TRUE     1007mmm     IFEQ DEBUG
0023057E  1A39 00C00007           1008mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230584                          1009mmm     ENDC
00230584                 FALSE    1010mmm     IFNE DEBUG
00230584                          1011mmm     ENDC
00230584                          1012mmm      
00230584  BA3C 001B               1013mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00230588  6700 FA7E               1014mmm     BEQ START
0023058C                          1015mmm     ENDM
0023058C                          1016mm CONTINUE_57
0023058C  1A39 00C00013           1017mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230592  0805 0000               1018mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230596  67D8                    1019mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00230598                          1020mm     
00230598  1A39 00C00017           1021mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0023059E  13C5 00E00001           1022mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002305A4                          1023mm     
002305A4                          1024mm     ENDM
002305A4                          1025mm         PRINT_CHAR D5,D6
002305A4                          1026mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002305A4                 TRUE     1027mm     IFEQ DEBUG
002305A4  1C39 00C00003           1028mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002305AA  0806 0002               1029mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002305AE  67F4                    1030mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
002305B0  13C5 00C00007           1031mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002305B6                          1032mm     ENDC
002305B6                          1033mm     
002305B6                 FALSE    1034mm     IFNE DEBUG
002305B6                          1035mm     ENDC
002305B6                          1036mm 
002305B6                          1037mm     ENDM
002305B6                          1038mm         HEX2BIN D5,D5,A4
002305B6  49F9 00230E5B           1039mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002305BC  0405 0030               1040mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002305C0  CABC 000000FF           1041mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002305C6  1A34 5000               1042mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002305CA                          1043mm     ENDM
002305CA  8805                    1044m         OR.B D5,D4
002305CC  5307                    1045m         SUB.B #1,D7
002305CE                          1046m     ENDW
002305CE  6096                    1047ms     BRA _10000004
002305D0                          1048ms _10000005
002305D0                          1049m     
002305D0  7A00                    1050m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002305D2  1A04                    1051m     MOVE.B D4,D5
002305D4  D484                    1052m     ADD.L D4,D2
002305D6                          1053m 
002305D6                          1054m     ENDM
002305D6                          1055              
002305D6                          1056              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
002305D6  B23C 0032               1057s     CMP.B   #'2',D1
002305DA  6600 0078               1058s     BNE.L   _00000006
002305DE  5383                    1059                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
002305E0                          1060m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
002305E0  1E3C 0002               1061m     MOVE.B #2,D7
002305E4                          1062m     WHILE.B D7 <GT> 0 DO
002305E4                          1063ms _10000006
002305E4  BE38 0000               1064ms     CMP.B   0,D7
002305E8  6F00 0064               1065ms     BLE _10000007
002305EC  E98C                    1066m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002305EE                          1067mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002305EE                          1068mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002305EE                          1069mm 
002305EE  1A39 00C00003           1070mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002305F4  0805 0000               1071mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002305F8  6700 0010               1072mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
002305FC                          1073mm  
002305FC                          1074mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002305FC                 TRUE     1075mmm     IFEQ DEBUG
002305FC  1A39 00C00007           1076mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230602                          1077mmm     ENDC
00230602                 FALSE    1078mmm     IFNE DEBUG
00230602                          1079mmm     ENDC
00230602                          1080mmm      
00230602  BA3C 001B               1081mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00230606  6700 FA00               1082mmm     BEQ START
0023060A                          1083mmm     ENDM
0023060A                          1084mm CONTINUE_62
0023060A  1A39 00C00013           1085mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230610  0805 0000               1086mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230614  67D8                    1087mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
00230616                          1088mm     
00230616  1A39 00C00017           1089mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0023061C  13C5 00E00001           1090mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00230622                          1091mm     
00230622                          1092mm     ENDM
00230622                          1093mm         PRINT_CHAR D5,D6
00230622                          1094mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230622                 TRUE     1095mm     IFEQ DEBUG
00230622  1C39 00C00003           1096mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00230628  0806 0002               1097mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0023062C  67F4                    1098mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
0023062E  13C5 00C00007           1099mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230634                          1100mm     ENDC
00230634                          1101mm     
00230634                 FALSE    1102mm     IFNE DEBUG
00230634                          1103mm     ENDC
00230634                          1104mm 
00230634                          1105mm     ENDM
00230634                          1106mm         HEX2BIN D5,D5,A4
00230634  49F9 00230E5B           1107mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0023063A  0405 0030               1108mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0023063E  CABC 000000FF           1109mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00230644  1A34 5000               1110mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00230648                          1111mm     ENDM
00230648  8805                    1112m         OR.B D5,D4
0023064A  5307                    1113m         SUB.B #1,D7
0023064C                          1114m     ENDW
0023064C  6096                    1115ms     BRA _10000006
0023064E                          1116ms _10000007
0023064E                          1117m     
0023064E  7A00                    1118m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00230650  1A04                    1119m     MOVE.B D4,D5
00230652  D484                    1120m     ADD.L D4,D2
00230654                          1121m 
00230654                          1122m     ENDM
00230654                          1123              ENDI
00230654                          1124s _00000006
00230654                          1125              
00230654  2444                    1126                  MOVE.L D4,A2                            ; put the address in an address register
00230656  D5C9                    1127              ADD.L A1,A2                             ; add in the offset
00230658                          1128  
00230658                          1129              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
00230658                          1130s _10000008
00230658  B63C 0000               1131s     CMP.B   #0,D3
0023065C  6F00 007E               1132s     BLE _10000009
00230660                          1133m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00230660  1E3C 0002               1134m     MOVE.B #2,D7
00230664                          1135m     WHILE.B D7 <GT> 0 DO
00230664                          1136ms _1000000A
00230664  BE38 0000               1137ms     CMP.B   0,D7
00230668  6F00 0064               1138ms     BLE _1000000B
0023066C  E989                    1139m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
0023066E                          1140mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0023066E                          1141mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023066E                          1142mm 
0023066E  1A39 00C00003           1143mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00230674  0805 0000               1144mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00230678  6700 0010               1145mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
0023067C                          1146mm  
0023067C                          1147mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0023067C                 TRUE     1148mmm     IFEQ DEBUG
0023067C  1A39 00C00007           1149mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230682                          1150mmm     ENDC
00230682                 FALSE    1151mmm     IFNE DEBUG
00230682                          1152mmm     ENDC
00230682                          1153mmm      
00230682  BA3C 001B               1154mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00230686  6700 F980               1155mmm     BEQ START
0023068A                          1156mmm     ENDM
0023068A                          1157mm CONTINUE_67
0023068A  1A39 00C00013           1158mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230690  0805 0000               1159mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230694  67D8                    1160mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00230696                          1161mm     
00230696  1A39 00C00017           1162mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0023069C  13C5 00E00001           1163mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002306A2                          1164mm     
002306A2                          1165mm     ENDM
002306A2                          1166mm         PRINT_CHAR D5,D6
002306A2                          1167mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002306A2                 TRUE     1168mm     IFEQ DEBUG
002306A2  1C39 00C00003           1169mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002306A8  0806 0002               1170mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002306AC  67F4                    1171mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
002306AE  13C5 00C00007           1172mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002306B4                          1173mm     ENDC
002306B4                          1174mm     
002306B4                 FALSE    1175mm     IFNE DEBUG
002306B4                          1176mm     ENDC
002306B4                          1177mm 
002306B4                          1178mm     ENDM
002306B4                          1179mm         HEX2BIN D5,D5,A4
002306B4  49F9 00230E5B           1180mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002306BA  0405 0030               1181mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002306BE  CABC 000000FF           1182mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002306C4  1A34 5000               1183mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002306C8                          1184mm     ENDM
002306C8  8205                    1185m         OR.B D5,D1
002306CA  5307                    1186m         SUB.B #1,D7
002306CC                          1187m     ENDW
002306CC  6096                    1188ms     BRA _1000000A
002306CE                          1189ms _1000000B
002306CE                          1190m     
002306CE  7A00                    1191m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002306D0  1A01                    1192m     MOVE.B D1,D5
002306D2  D481                    1193m     ADD.L D1,D2
002306D4                          1194m 
002306D4                          1195m     ENDM
002306D4                          1196                          
002306D4  14C1                    1197                  MOVE.B D1,(A2)+                     ; store it!
002306D6                          1198  
002306D6  5303                    1199                  SUB.B #1,D3                     ; 1 less byte to go
002306D8                          1200              ENDW
002306D8  6000 FF7E               1201s     BRA _10000008
002306DC                          1202s _10000009
002306DC                          1203          
002306DC  47F9 0023039E           1204              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
002306E2                          1205          ELSE
002306E2  6000 01F0               1206s     BRA _00000007
002306E6                          1207s _00000005
002306E6                          1208              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
002306E6  B23C 0038               1209s     CMP.B   #'8',D1
002306EA  6600 016C               1210s     BNE.L   _00000008
002306EE  7800                    1211                  MOVE.L #0,D4                    ; read the 24 bit start address
002306F0                          1212m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
002306F0  1E3C 0002               1213m     MOVE.B #2,D7
002306F4                          1214m     WHILE.B D7 <GT> 0 DO
002306F4                          1215ms _1000000C
002306F4  BE38 0000               1216ms     CMP.B   0,D7
002306F8  6F00 0064               1217ms     BLE _1000000D
002306FC  E98C                    1218m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002306FE                          1219mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002306FE                          1220mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002306FE                          1221mm 
002306FE  1A39 00C00003           1222mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00230704  0805 0000               1223mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00230708  6700 0010               1224mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
0023070C                          1225mm  
0023070C                          1226mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0023070C                 TRUE     1227mmm     IFEQ DEBUG
0023070C  1A39 00C00007           1228mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230712                          1229mmm     ENDC
00230712                 FALSE    1230mmm     IFNE DEBUG
00230712                          1231mmm     ENDC
00230712                          1232mmm      
00230712  BA3C 001B               1233mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00230716  6700 F8F0               1234mmm     BEQ START
0023071A                          1235mmm     ENDM
0023071A                          1236mm CONTINUE_72
0023071A  1A39 00C00013           1237mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230720  0805 0000               1238mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230724  67D8                    1239mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
00230726                          1240mm     
00230726  1A39 00C00017           1241mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0023072C  13C5 00E00001           1242mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00230732                          1243mm     
00230732                          1244mm     ENDM
00230732                          1245mm         PRINT_CHAR D5,D6
00230732                          1246mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230732                 TRUE     1247mm     IFEQ DEBUG
00230732  1C39 00C00003           1248mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00230738  0806 0002               1249mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0023073C  67F4                    1250mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
0023073E  13C5 00C00007           1251mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230744                          1252mm     ENDC
00230744                          1253mm     
00230744                 FALSE    1254mm     IFNE DEBUG
00230744                          1255mm     ENDC
00230744                          1256mm 
00230744                          1257mm     ENDM
00230744                          1258mm         HEX2BIN D5,D5,A4
00230744  49F9 00230E5B           1259mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0023074A  0405 0030               1260mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0023074E  CABC 000000FF           1261mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00230754  1A34 5000               1262mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00230758                          1263mm     ENDM
00230758  8805                    1264m         OR.B D5,D4
0023075A  5307                    1265m         SUB.B #1,D7
0023075C                          1266m     ENDW
0023075C  6096                    1267ms     BRA _1000000C
0023075E                          1268ms _1000000D
0023075E                          1269m     
0023075E  7A00                    1270m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00230760  1A04                    1271m     MOVE.B D4,D5
00230762  D484                    1272m     ADD.L D4,D2
00230764                          1273m 
00230764                          1274m     ENDM
00230764                          1275m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00230764  1E3C 0002               1276m     MOVE.B #2,D7
00230768                          1277m     WHILE.B D7 <GT> 0 DO
00230768                          1278ms _1000000E
00230768  BE38 0000               1279ms     CMP.B   0,D7
0023076C  6F00 0064               1280ms     BLE _1000000F
00230770  E98C                    1281m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00230772                          1282mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00230772                          1283mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230772                          1284mm 
00230772  1A39 00C00003           1285mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00230778  0805 0000               1286mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0023077C  6700 0010               1287mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00230780                          1288mm  
00230780                          1289mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00230780                 TRUE     1290mmm     IFEQ DEBUG
00230780  1A39 00C00007           1291mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00230786                          1292mmm     ENDC
00230786                 FALSE    1293mmm     IFNE DEBUG
00230786                          1294mmm     ENDC
00230786                          1295mmm      
00230786  BA3C 001B               1296mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0023078A  6700 F87C               1297mmm     BEQ START
0023078E                          1298mmm     ENDM
0023078E                          1299mm CONTINUE_77
0023078E  1A39 00C00013           1300mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230794  0805 0000               1301mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230798  67D8                    1302mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0023079A                          1303mm     
0023079A  1A39 00C00017           1304mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002307A0  13C5 00E00001           1305mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002307A6                          1306mm     
002307A6                          1307mm     ENDM
002307A6                          1308mm         PRINT_CHAR D5,D6
002307A6                          1309mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002307A6                 TRUE     1310mm     IFEQ DEBUG
002307A6  1C39 00C00003           1311mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002307AC  0806 0002               1312mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002307B0  67F4                    1313mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
002307B2  13C5 00C00007           1314mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002307B8                          1315mm     ENDC
002307B8                          1316mm     
002307B8                 FALSE    1317mm     IFNE DEBUG
002307B8                          1318mm     ENDC
002307B8                          1319mm 
002307B8                          1320mm     ENDM
002307B8                          1321mm         HEX2BIN D5,D5,A4
002307B8  49F9 00230E5B           1322mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002307BE  0405 0030               1323mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002307C2  CABC 000000FF           1324mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002307C8  1A34 5000               1325mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002307CC                          1326mm     ENDM
002307CC  8805                    1327m         OR.B D5,D4
002307CE  5307                    1328m         SUB.B #1,D7
002307D0                          1329m     ENDW
002307D0  6096                    1330ms     BRA _1000000E
002307D2                          1331ms _1000000F
002307D2                          1332m     
002307D2  7A00                    1333m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002307D4  1A04                    1334m     MOVE.B D4,D5
002307D6  D484                    1335m     ADD.L D4,D2
002307D8                          1336m 
002307D8                          1337m     ENDM
002307D8                          1338m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
002307D8  1E3C 0002               1339m     MOVE.B #2,D7
002307DC                          1340m     WHILE.B D7 <GT> 0 DO
002307DC                          1341ms _10000010
002307DC  BE38 0000               1342ms     CMP.B   0,D7
002307E0  6F00 0064               1343ms     BLE _10000011
002307E4  E98C                    1344m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002307E6                          1345mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002307E6                          1346mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002307E6                          1347mm 
002307E6  1A39 00C00003           1348mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002307EC  0805 0000               1349mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002307F0  6700 0010               1350mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
002307F4                          1351mm  
002307F4                          1352mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002307F4                 TRUE     1353mmm     IFEQ DEBUG
002307F4  1A39 00C00007           1354mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002307FA                          1355mmm     ENDC
002307FA                 FALSE    1356mmm     IFNE DEBUG
002307FA                          1357mmm     ENDC
002307FA                          1358mmm      
002307FA  BA3C 001B               1359mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002307FE  6700 F808               1360mmm     BEQ START
00230802                          1361mmm     ENDM
00230802                          1362mm CONTINUE_82
00230802  1A39 00C00013           1363mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230808  0805 0000               1364mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0023080C  67D8                    1365mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
0023080E                          1366mm     
0023080E  1A39 00C00017           1367mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00230814  13C5 00E00001           1368mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0023081A                          1369mm     
0023081A                          1370mm     ENDM
0023081A                          1371mm         PRINT_CHAR D5,D6
0023081A                          1372mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023081A                 TRUE     1373mm     IFEQ DEBUG
0023081A  1C39 00C00003           1374mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00230820  0806 0002               1375mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00230824  67F4                    1376mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
00230826  13C5 00C00007           1377mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0023082C                          1378mm     ENDC
0023082C                          1379mm     
0023082C                 FALSE    1380mm     IFNE DEBUG
0023082C                          1381mm     ENDC
0023082C                          1382mm 
0023082C                          1383mm     ENDM
0023082C                          1384mm         HEX2BIN D5,D5,A4
0023082C  49F9 00230E5B           1385mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00230832  0405 0030               1386mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230836  CABC 000000FF           1387mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0023083C  1A34 5000               1388mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00230840                          1389mm     ENDM
00230840  8805                    1390m         OR.B D5,D4
00230842  5307                    1391m         SUB.B #1,D7
00230844                          1392m     ENDW
00230844  6096                    1393ms     BRA _10000010
00230846                          1394ms _10000011
00230846                          1395m     
00230846  7A00                    1396m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00230848  1A04                    1397m     MOVE.B D4,D5
0023084A  D484                    1398m     ADD.L D4,D2
0023084C                          1399m 
0023084C                          1400m     ENDM
0023084C                          1401                    
0023084C  2044                    1402                  MOVE.L D4,A0                    ; start address -> A0
0023084E                          1403                  
0023084E  47F9 00230A10           1404                  LEA DOWNLOAD_DONE,A3            ; next place to go
00230854                          1405              ELSE
00230854  6000 007E               1406s     BRA _00000009
00230858                          1407s _00000008
00230858                          1408m                 PRINT_CRLF D5,A4
00230858  49F9 00230E86           1409m     LEA CRLF,A4
0023085E                          1410mm     PRINT_STR A4,D5
0023085E                          1411mm LOOP_87
0023085E  0C14 0000               1412mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00230862  6700 0016               1413mm     BEQ EXIT_87
00230866                          1414mmm     PRINT_CHAR (A4)+,D5
00230866                          1415mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230866                 TRUE     1416mmm     IFEQ DEBUG
00230866  1A39 00C00003           1417mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0023086C  0805 0002               1418mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230870  67F4                    1419mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00230872  13DC 00C00007           1420mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230878                          1421mmm     ENDC
00230878                          1422mmm     
00230878                 FALSE    1423mmm     IFNE DEBUG
00230878                          1424mmm     ENDC
00230878                          1425mmm 
00230878                          1426mmm     ENDM
00230878  60E4                    1427mm     BRA LOOP_87
0023087A                          1428mm EXIT_87
0023087A                          1429mm     ENDM
0023087A                          1430m     ENDM
0023087A                          1431              
0023087A  49F9 00230E10           1432                  LEA UNREC,A4                    ; warn for unrecognised type
00230880                          1433m                 PRINT_STR A4,D5
00230880                          1434m LOOP_89
00230880  0C14 0000               1435m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00230884  6700 0016               1436m     BEQ EXIT_89
00230888                          1437mm     PRINT_CHAR (A4)+,D5
00230888                          1438mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230888                 TRUE     1439mm     IFEQ DEBUG
00230888  1A39 00C00003           1440mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0023088E  0805 0002               1441mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230892  67F4                    1442mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00230894  13DC 00C00007           1443mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0023089A                          1444mm     ENDC
0023089A                          1445mm     
0023089A                 FALSE    1446mm     IFNE DEBUG
0023089A                          1447mm     ENDC
0023089A                          1448mm 
0023089A                          1449mm     ENDM
0023089A  60E4                    1450m     BRA LOOP_89
0023089C                          1451m EXIT_89
0023089C                          1452m     ENDM
0023089C                          1453m                 PRINT_CHAR D1,D5
0023089C                          1454m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0023089C                 TRUE     1455m     IFEQ DEBUG
0023089C  1A39 00C00003           1456m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002308A2  0805 0002               1457m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002308A6  67F4                    1458m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
002308A8  13C1 00C00007           1459m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
002308AE                          1460m     ENDC
002308AE                          1461m     
002308AE                 FALSE    1462m     IFNE DEBUG
002308AE                          1463m     ENDC
002308AE                          1464m 
002308AE                          1465m     ENDM
002308AE                          1466m                 PRINT_CRLF D5,A4
002308AE  49F9 00230E86           1467m     LEA CRLF,A4
002308B4                          1468mm     PRINT_STR A4,D5
002308B4                          1469mm LOOP_93
002308B4  0C14 0000               1470mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
002308B8  6700 0016               1471mm     BEQ EXIT_93
002308BC                          1472mmm     PRINT_CHAR (A4)+,D5
002308BC                          1473mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002308BC                 TRUE     1474mmm     IFEQ DEBUG
002308BC  1A39 00C00003           1475mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002308C2  0805 0002               1476mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002308C6  67F4                    1477mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
002308C8  13DC 00C00007           1478mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002308CE                          1479mmm     ENDC
002308CE                          1480mmm     
002308CE                 FALSE    1481mmm     IFNE DEBUG
002308CE                          1482mmm     ENDC
002308CE                          1483mmm 
002308CE                          1484mmm     ENDM
002308CE  60E4                    1485mm     BRA LOOP_93
002308D0                          1486mm EXIT_93
002308D0                          1487mm     ENDM
002308D0                          1488m     ENDM
002308D0                          1489              
002308D0  6000 FACC               1490                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
002308D4                          1491              ENDI
002308D4                          1492s _00000009
002308D4                          1493          ENDI
002308D4                          1494s _00000007
002308D4                          1495      ENDI
002308D4                          1496s _00000003
002308D4                          1497      
002308D4                          1498m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
002308D4  1E3C 0002               1499m     MOVE.B #2,D7
002308D8                          1500m     WHILE.B D7 <GT> 0 DO
002308D8                          1501ms _10000012
002308D8  BE38 0000               1502ms     CMP.B   0,D7
002308DC  6F00 0064               1503ms     BLE _10000013
002308E0  E98C                    1504m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002308E2                          1505mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002308E2                          1506mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002308E2                          1507mm 
002308E2  1A39 00C00003           1508mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002308E8  0805 0000               1509mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002308EC  6700 0010               1510mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
002308F0                          1511mm  
002308F0                          1512mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002308F0                 TRUE     1513mmm     IFEQ DEBUG
002308F0  1A39 00C00007           1514mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002308F6                          1515mmm     ENDC
002308F6                 FALSE    1516mmm     IFNE DEBUG
002308F6                          1517mmm     ENDC
002308F6                          1518mmm      
002308F6  BA3C 001B               1519mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002308FA  6700 F70C               1520mmm     BEQ START
002308FE                          1521mmm     ENDM
002308FE                          1522mm CONTINUE_96
002308FE  1A39 00C00013           1523mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00230904  0805 0000               1524mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00230908  67D8                    1525mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
0023090A                          1526mm     
0023090A  1A39 00C00017           1527mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00230910  13C5 00E00001           1528mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00230916                          1529mm     
00230916                          1530mm     ENDM
00230916                          1531mm         PRINT_CHAR D5,D6
00230916                          1532mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230916                 TRUE     1533mm     IFEQ DEBUG
00230916  1C39 00C00003           1534mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0023091C  0806 0002               1535mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00230920  67F4                    1536mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00230922  13C5 00C00007           1537mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230928                          1538mm     ENDC
00230928                          1539mm     
00230928                 FALSE    1540mm     IFNE DEBUG
00230928                          1541mm     ENDC
00230928                          1542mm 
00230928                          1543mm     ENDM
00230928                          1544mm         HEX2BIN D5,D5,A4
00230928  49F9 00230E5B           1545mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0023092E  0405 0030               1546mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230932  CABC 000000FF           1547mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00230938  1A34 5000               1548mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0023093C                          1549mm     ENDM
0023093C  8805                    1550m         OR.B D5,D4
0023093E  5307                    1551m         SUB.B #1,D7
00230940                          1552m     ENDW
00230940  6096                    1553ms     BRA _10000012
00230942                          1554ms _10000013
00230942                          1555m     
00230942  7A00                    1556m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00230944  1A04                    1557m     MOVE.B D4,D5
00230946  D484                    1558m     ADD.L D4,D2
00230948                          1559m 
00230948                          1560m     ENDM
00230948                          1561m     PRINT_CRLF D5,A4
00230948  49F9 00230E86           1562m     LEA CRLF,A4
0023094E                          1563mm     PRINT_STR A4,D5
0023094E                          1564mm LOOP_101
0023094E  0C14 0000               1565mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00230952  6700 0016               1566mm     BEQ EXIT_101
00230956                          1567mmm     PRINT_CHAR (A4)+,D5
00230956                          1568mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230956                 TRUE     1569mmm     IFEQ DEBUG
00230956  1A39 00C00003           1570mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0023095C  0805 0002               1571mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230960  67F4                    1572mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00230962  13DC 00C00007           1573mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230968                          1574mmm     ENDC
00230968                          1575mmm     
00230968                 FALSE    1576mmm     IFNE DEBUG
00230968                          1577mmm     ENDC
00230968                          1578mmm 
00230968                          1579mmm     ENDM
00230968  60E4                    1580mm     BRA LOOP_101
0023096A                          1581mm EXIT_101
0023096A                          1582mm     ENDM
0023096A                          1583m     ENDM
0023096A                          1584          
0023096A                          1585      IF.B D2 <NE> #$FF THEN.L
0023096A  B43C 00FF               1586s     CMP.B   #$FF,D2
0023096E  6700 009E               1587s     BEQ.L   _0000000A
00230972  49F9 00230E27           1588          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00230978                          1589m         PRINT_STR A4,D5
00230978                          1590m LOOP_103
00230978  0C14 0000               1591m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0023097C  6700 0016               1592m     BEQ EXIT_103
00230980                          1593mm     PRINT_CHAR (A4)+,D5
00230980                          1594mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230980                 TRUE     1595mm     IFEQ DEBUG
00230980  1A39 00C00003           1596mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230986  0805 0002               1597mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0023098A  67F4                    1598mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0023098C  13DC 00C00007           1599mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230992                          1600mm     ENDC
00230992                          1601mm     
00230992                 FALSE    1602mm     IFNE DEBUG
00230992                          1603mm     ENDC
00230992                          1604mm 
00230992                          1605mm     ENDM
00230992  60E4                    1606m     BRA LOOP_103
00230994                          1607m EXIT_103
00230994                          1608m     ENDM
00230994                          1609m         PRINT_REG D0,D5,D2,D6,A4
00230994                          1610mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00230994                          1611mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230994                 TRUE     1612mm     IFEQ DEBUG
00230994  1A39 00C00003           1613mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0023099A  0805 0002               1614mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0023099E  67F4                    1615mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
002309A0  13FC 0030 00C00007      1616mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002309A8                          1617mm     ENDC
002309A8                          1618mm     
002309A8                 FALSE    1619mm     IFNE DEBUG
002309A8                          1620mm     ENDC
002309A8                          1621mm 
002309A8                          1622mm     ENDM
002309A8                          1623mm     PRINT_CHAR #'x',D5
002309A8                          1624mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002309A8                 TRUE     1625mm     IFEQ DEBUG
002309A8  1A39 00C00003           1626mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002309AE  0805 0002               1627mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002309B2  67F4                    1628mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
002309B4  13FC 0078 00C00007      1629mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002309BC                          1630mm     ENDC
002309BC                          1631mm     
002309BC                 FALSE    1632mm     IFNE DEBUG
002309BC                          1633mm     ENDC
002309BC                          1634mm 
002309BC                          1635mm     ENDM
002309BC  7C07                    1636m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002309BE                          1637m LOOP_105
002309BE                          1638mm     BIN2HEX D0,D2,A4
002309BE  49F9 00230E4B           1639mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
002309C4  E998                    1640mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002309C6  1400                    1641mm     MOVE.B D0,D2
002309C8  0282 0000000F           1642mm     ANDI.L #$F,D2
002309CE  1434 2000               1643mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002309D2                          1644mm     ENDM
002309D2                          1645mm     PRINT_CHAR D2,D5
002309D2                          1646mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002309D2                 TRUE     1647mm     IFEQ DEBUG
002309D2  1A39 00C00003           1648mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002309D8  0805 0002               1649mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002309DC  67F4                    1650mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
002309DE  13C2 00C00007           1651mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002309E4                          1652mm     ENDC
002309E4                          1653mm     
002309E4                 FALSE    1654mm     IFNE DEBUG
002309E4                          1655mm     ENDC
002309E4                          1656mm 
002309E4                          1657mm     ENDM
002309E4  57CE FFD8               1658m     DBEQ D6,LOOP_105
002309E8                          1659m     ENDM
002309E8                          1660m         PRINT_CRLF D5,A4
002309E8  49F9 00230E86           1661m     LEA CRLF,A4
002309EE                          1662mm     PRINT_STR A4,D5
002309EE                          1663mm LOOP_111
002309EE  0C14 0000               1664mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
002309F2  6700 0016               1665mm     BEQ EXIT_111
002309F6                          1666mmm     PRINT_CHAR (A4)+,D5
002309F6                          1667mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002309F6                 TRUE     1668mmm     IFEQ DEBUG
002309F6  1A39 00C00003           1669mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002309FC  0805 0002               1670mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A00  67F4                    1671mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00230A02  13DC 00C00007           1672mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230A08                          1673mmm     ENDC
00230A08                          1674mmm     
00230A08                 FALSE    1675mmm     IFNE DEBUG
00230A08                          1676mmm     ENDC
00230A08                          1677mmm 
00230A08                          1678mmm     ENDM
00230A08  60E4                    1679mm     BRA LOOP_111
00230A0A                          1680mm EXIT_111
00230A0A                          1681mm     ENDM
00230A0A                          1682m     ENDM
00230A0A  6000 F758               1683          BRA MAIN_LOOP
00230A0E                          1684      ENDI
00230A0E                          1685s _0000000A
00230A0E                          1686      
00230A0E  4ED3                    1687      JMP (A3)
00230A10                          1688  DOWNLOAD_DONE
00230A10                          1689m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00230A10                          1690mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00230A10                          1691mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A10                 TRUE     1692mm     IFEQ DEBUG
00230A10  1A39 00C00003           1693mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230A16  0805 0002               1694mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A1A  67F4                    1695mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00230A1C  13FC 0030 00C00007      1696mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230A24                          1697mm     ENDC
00230A24                          1698mm     
00230A24                 FALSE    1699mm     IFNE DEBUG
00230A24                          1700mm     ENDC
00230A24                          1701mm 
00230A24                          1702mm     ENDM
00230A24                          1703mm     PRINT_CHAR #'x',D5
00230A24                          1704mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A24                 TRUE     1705mm     IFEQ DEBUG
00230A24  1A39 00C00003           1706mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230A2A  0805 0002               1707mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A2E  67F4                    1708mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00230A30  13FC 0078 00C00007      1709mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230A38                          1710mm     ENDC
00230A38                          1711mm     
00230A38                 FALSE    1712mm     IFNE DEBUG
00230A38                          1713mm     ENDC
00230A38                          1714mm 
00230A38                          1715mm     ENDM
00230A38  7407                    1716m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00230A3A                          1717m LOOP_113
00230A3A                          1718mm     BIN2HEX D0,D6,A1
00230A3A  43F9 00230E4B           1719mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00230A40  E998                    1720mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00230A42  1C00                    1721mm     MOVE.B D0,D6
00230A44  0286 0000000F           1722mm     ANDI.L #$F,D6
00230A4A  1C31 6000               1723mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00230A4E                          1724mm     ENDM
00230A4E                          1725mm     PRINT_CHAR D6,D5
00230A4E                          1726mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A4E                 TRUE     1727mm     IFEQ DEBUG
00230A4E  1A39 00C00003           1728mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230A54  0805 0002               1729mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A58  67F4                    1730mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00230A5A  13C6 00C00007           1731mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230A60                          1732mm     ENDC
00230A60                          1733mm     
00230A60                 FALSE    1734mm     IFNE DEBUG
00230A60                          1735mm     ENDC
00230A60                          1736mm 
00230A60                          1737mm     ENDM
00230A60  57CA FFD8               1738m     DBEQ D2,LOOP_113
00230A64                          1739m     ENDM
00230A64  43F9 00230DEE           1740      LEA READ,A1
00230A6A                          1741m     PRINT_STR A1,D5
00230A6A                          1742m LOOP_118
00230A6A  0C11 0000               1743m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00230A6E  6700 0016               1744m     BEQ EXIT_118
00230A72                          1745mm     PRINT_CHAR (A1)+,D5
00230A72                          1746mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A72                 TRUE     1747mm     IFEQ DEBUG
00230A72  1A39 00C00003           1748mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230A78  0805 0002               1749mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A7C  67F4                    1750mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00230A7E  13D9 00C00007           1751mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230A84                          1752mm     ENDC
00230A84                          1753mm     
00230A84                 FALSE    1754mm     IFNE DEBUG
00230A84                          1755mm     ENDC
00230A84                          1756mm 
00230A84                          1757mm     ENDM
00230A84  60E4                    1758m     BRA LOOP_118
00230A86                          1759m EXIT_118
00230A86                          1760m     ENDM
00230A86  2E08                    1761      MOVE.L A0,D7                                    ; set address accumulator to start address
00230A88                          1762m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00230A88                          1763mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00230A88                          1764mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A88                 TRUE     1765mm     IFEQ DEBUG
00230A88  1A39 00C00003           1766mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230A8E  0805 0002               1767mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230A92  67F4                    1768mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00230A94  13FC 0030 00C00007      1769mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230A9C                          1770mm     ENDC
00230A9C                          1771mm     
00230A9C                 FALSE    1772mm     IFNE DEBUG
00230A9C                          1773mm     ENDC
00230A9C                          1774mm 
00230A9C                          1775mm     ENDM
00230A9C                          1776mm     PRINT_CHAR #'x',D5
00230A9C                          1777mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230A9C                 TRUE     1778mm     IFEQ DEBUG
00230A9C  1A39 00C00003           1779mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230AA2  0805 0002               1780mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230AA6  67F4                    1781mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00230AA8  13FC 0078 00C00007      1782mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230AB0                          1783mm     ENDC
00230AB0                          1784mm     
00230AB0                 FALSE    1785mm     IFNE DEBUG
00230AB0                          1786mm     ENDC
00230AB0                          1787mm 
00230AB0                          1788mm     ENDM
00230AB0  7407                    1789m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00230AB2                          1790m LOOP_120
00230AB2                          1791mm     BIN2HEX D7,D6,A1
00230AB2  43F9 00230E4B           1792mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00230AB8  E99F                    1793mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00230ABA  1C07                    1794mm     MOVE.B D7,D6
00230ABC  0286 0000000F           1795mm     ANDI.L #$F,D6
00230AC2  1C31 6000               1796mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00230AC6                          1797mm     ENDM
00230AC6                          1798mm     PRINT_CHAR D6,D5
00230AC6                          1799mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230AC6                 TRUE     1800mm     IFEQ DEBUG
00230AC6  1A39 00C00003           1801mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230ACC  0805 0002               1802mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230AD0  67F4                    1803mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00230AD2  13C6 00C00007           1804mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230AD8                          1805mm     ENDC
00230AD8                          1806mm     
00230AD8                 FALSE    1807mm     IFNE DEBUG
00230AD8                          1808mm     ENDC
00230AD8                          1809mm 
00230AD8                          1810mm     ENDM
00230AD8  57CA FFD8               1811m     DBEQ D2,LOOP_120
00230ADC                          1812m     ENDM
00230ADC                          1813m     PRINT_CRLF D5,A4     
00230ADC  49F9 00230E86           1814m     LEA CRLF,A4
00230AE2                          1815mm     PRINT_STR A4,D5
00230AE2                          1816mm LOOP_126
00230AE2  0C14 0000               1817mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00230AE6  6700 0016               1818mm     BEQ EXIT_126
00230AEA                          1819mmm     PRINT_CHAR (A4)+,D5
00230AEA                          1820mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230AEA                 TRUE     1821mmm     IFEQ DEBUG
00230AEA  1A39 00C00003           1822mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00230AF0  0805 0002               1823mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00230AF4  67F4                    1824mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00230AF6  13DC 00C00007           1825mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230AFC                          1826mmm     ENDC
00230AFC                          1827mmm     
00230AFC                 FALSE    1828mmm     IFNE DEBUG
00230AFC                          1829mmm     ENDC
00230AFC                          1830mmm 
00230AFC                          1831mmm     ENDM
00230AFC  60E4                    1832mm     BRA LOOP_126
00230AFE                          1833mm EXIT_126
00230AFE                          1834mm     ENDM
00230AFE                          1835m     ENDM
00230AFE                          1836          
00230AFE  6000 F664               1837      BRA MAIN_LOOP
00230B02                          1838      
00230B02                          1839  G
00230B02  2047                    1840      MOVE.L D7,A0                                    ; address accumulator -> address register
00230B04  3E3C 0000               1841      MOVE #0,D7                                      ; clear the now used address accumulator
00230B08  4ED0                    1842      JMP (A0)                                        ; jump to it!
00230B0A                          1843      
00230B0A                          1844  Z
00230B0A  207C 00200000           1845      MOVE.L #RAM,A0                                  ; address of RAM
00230B10                          1846      
00230B10                          1847      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00230B10  7000                    1848s     MOVE.L  #0,D0
00230B12  6000 0012               1849s     BRA _20000001
00230B16                          1850s _20000000
00230B16  2200                    1851              MOVE.L D0,D1                              ; progress update
00230B18  E089                    1852          LSR.L #8,D1 
00230B1A  E089                    1853          LSR.L #8,D1
00230B1C  13C1 00E00001           1854          MOVE.B D1,DISPLAY
00230B22                          1855  
00230B22  20C0                    1856          MOVE.L D0,(A0)+
00230B24                          1857      ENDF
00230B24  5880                    1858s     ADD.L   #4,D0
00230B26                          1859s _20000001
00230B26  B0BC 00040000           1860s     CMP.L   #$40000,D0
00230B2C  6FE8                    1861s     BLE _20000000
00230B2E                          1862   
00230B2E  207C 00200000           1863      MOVE.L #RAM,A0                                    ; address of RAM
00230B34                          1864     
00230B34                          1865      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00230B34  7000                    1866s     MOVE.L  #0,D0
00230B36  6000 00B4               1867s     BRA _20000003
00230B3A                          1868s _20000002
00230B3A  2200                    1869          MOVE.L D0,D1                              ; progress update
00230B3C  E089                    1870          LSR.L #8,D1
00230B3E  E089                    1871          LSR.L #8,D1
00230B40  13C1 00E00001           1872          MOVE.B D1,DISPLAY
00230B46                          1873  
00230B46  2218                    1874          MOVE.L (A0)+,D1
00230B48                          1875            
00230B48                          1876          IF.L D0 <NE> D1 THEN      
00230B48  B081                    1877s     CMP.L   D1,D0
00230B4A  6700 009E               1878s     BEQ _0000000B
00230B4E  43F9 00230E39           1879              LEA RAM_ERROR,A1
00230B54                          1880m             PRINT_STR A1,D1
00230B54                          1881m LOOP_128
00230B54  0C11 0000               1882m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00230B58  6700 0016               1883m     BEQ EXIT_128
00230B5C                          1884mm     PRINT_CHAR (A1)+,D1
00230B5C                          1885mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230B5C                 TRUE     1886mm     IFEQ DEBUG
00230B5C  1239 00C00003           1887mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00230B62  0801 0002               1888mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00230B66  67F4                    1889mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00230B68  13D9 00C00007           1890mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230B6E                          1891mm     ENDC
00230B6E                          1892mm     
00230B6E                 FALSE    1893mm     IFNE DEBUG
00230B6E                          1894mm     ENDC
00230B6E                          1895mm 
00230B6E                          1896mm     ENDM
00230B6E  60E4                    1897m     BRA LOOP_128
00230B70                          1898m EXIT_128
00230B70                          1899m     ENDM
00230B70  2208                    1900              MOVE.L A0,D1
00230B72  5981                    1901              SUB.L #4,D1
00230B74                          1902m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00230B74                          1903mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00230B74                          1904mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230B74                 TRUE     1905mm     IFEQ DEBUG
00230B74  1639 00C00003           1906mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230B7A  0803 0002               1907mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230B7E  67F4                    1908mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00230B80  13FC 0030 00C00007      1909mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230B88                          1910mm     ENDC
00230B88                          1911mm     
00230B88                 FALSE    1912mm     IFNE DEBUG
00230B88                          1913mm     ENDC
00230B88                          1914mm 
00230B88                          1915mm     ENDM
00230B88                          1916mm     PRINT_CHAR #'x',D3
00230B88                          1917mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230B88                 TRUE     1918mm     IFEQ DEBUG
00230B88  1639 00C00003           1919mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230B8E  0803 0002               1920mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230B92  67F4                    1921mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00230B94  13FC 0078 00C00007      1922mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00230B9C                          1923mm     ENDC
00230B9C                          1924mm     
00230B9C                 FALSE    1925mm     IFNE DEBUG
00230B9C                          1926mm     ENDC
00230B9C                          1927mm 
00230B9C                          1928mm     ENDM
00230B9C  7C07                    1929m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00230B9E                          1930m LOOP_130
00230B9E                          1931mm     BIN2HEX D1,D2,A1
00230B9E  43F9 00230E4B           1932mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00230BA4  E999                    1933mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00230BA6  1401                    1934mm     MOVE.B D1,D2
00230BA8  0282 0000000F           1935mm     ANDI.L #$F,D2
00230BAE  1431 2000               1936mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00230BB2                          1937mm     ENDM
00230BB2                          1938mm     PRINT_CHAR D2,D3
00230BB2                          1939mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230BB2                 TRUE     1940mm     IFEQ DEBUG
00230BB2  1639 00C00003           1941mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230BB8  0803 0002               1942mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230BBC  67F4                    1943mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00230BBE  13C2 00C00007           1944mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230BC4                          1945mm     ENDC
00230BC4                          1946mm     
00230BC4                 FALSE    1947mm     IFNE DEBUG
00230BC4                          1948mm     ENDC
00230BC4                          1949mm 
00230BC4                          1950mm     ENDM
00230BC4  57CE FFD8               1951m     DBEQ D6,LOOP_130
00230BC8                          1952m     ENDM
00230BC8                          1953m             PRINT_CRLF D3,A1
00230BC8  43F9 00230E86           1954m     LEA CRLF,A1
00230BCE                          1955mm     PRINT_STR A1,D3
00230BCE                          1956mm LOOP_136
00230BCE  0C11 0000               1957mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00230BD2  6700 0016               1958mm     BEQ EXIT_136
00230BD6                          1959mmm     PRINT_CHAR (A1)+,D3
00230BD6                          1960mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230BD6                 TRUE     1961mmm     IFEQ DEBUG
00230BD6  1639 00C00003           1962mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230BDC  0803 0002               1963mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230BE0  67F4                    1964mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00230BE2  13D9 00C00007           1965mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230BE8                          1966mmm     ENDC
00230BE8                          1967mmm     
00230BE8                 FALSE    1968mmm     IFNE DEBUG
00230BE8                          1969mmm     ENDC
00230BE8                          1970mmm 
00230BE8                          1971mmm     ENDM
00230BE8  60E4                    1972mm     BRA LOOP_136
00230BEA                          1973mm EXIT_136
00230BEA                          1974mm     ENDM
00230BEA                          1975m     ENDM
00230BEA                          1976          ENDI 
00230BEA                          1977s _0000000B
00230BEA                          1978      ENDF
00230BEA  5880                    1979s     ADD.L   #4,D0
00230BEC                          1980s _20000003
00230BEC  B0BC 00040000           1981s     CMP.L   #$40000,D0
00230BF2  6F00 FF46               1982s     BLE _20000002
00230BF6                          1983      
00230BF6  6000 F56C               1984      BRA MAIN_LOOP
00230BFA                          1985    
00230BFA                          1986  L
00230BFA  7A00                    1987      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00230BFC                          1988  
00230BFC                          1989      FOR D6 = #0 TO #3 DO                          ; read the length to write
00230BFC  3C3C 0000               1990s     MOVE.W  #0,D6
00230C00  6000 0048               1991s     BRA _20000005
00230C04                          1992s _20000004
00230C04  E98D                    1993          LSL.L #4,D5                                 ; make what we have so far more significant
00230C06                          1994m         WAIT_CHAR D2,D3                             ; next character -> D2
00230C06                          1995m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230C06                 TRUE     1996m     IFEQ DEBUG
00230C06  1639 00C00003           1997m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00230C0C  0803 0000               1998m         BTST #0,D3                              ; CHECK FOR CHARACTER
00230C10  67F4                    1999m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00230C12                          2000m     ENDC
00230C12                          2001m     
00230C12                          2002mm     READ_CHAR D2
00230C12                 TRUE     2003mm     IFEQ DEBUG
00230C12  1439 00C00007           2004mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00230C18                          2005mm     ENDC
00230C18                 FALSE    2006mm     IFNE DEBUG
00230C18                          2007mm     ENDC
00230C18                          2008mm      
00230C18  B43C 001B               2009mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00230C1C  6700 F3EA               2010mm     BEQ START
00230C20                          2011mm     ENDM
00230C20                          2012m 
00230C20                 TRUE     2013m     IFEQ DEBUG
00230C20                          2014mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00230C20                          2015mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230C20                 TRUE     2016mm     IFEQ DEBUG
00230C20  1639 00C00003           2017mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230C26  0803 0002               2018mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230C2A  67F4                    2019mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00230C2C  13C2 00C00007           2020mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00230C32                          2021mm     ENDC
00230C32                          2022mm     
00230C32                 FALSE    2023mm     IFNE DEBUG
00230C32                          2024mm     ENDC
00230C32                          2025mm 
00230C32                          2026mm     ENDM
00230C32                          2027m     ENDC
00230C32                          2028m     ENDM
00230C32                          2029m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00230C32  41F9 00230E5B           2030m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00230C38  0402 0030               2031m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230C3C  C4BC 000000FF           2032m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00230C42  1430 2000               2033m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00230C46                          2034m     ENDM
00230C46  8A02                    2035          OR.B D2,D5
00230C48                          2036      ENDF
00230C48  5246                    2037s     ADD.W   #1,D6
00230C4A                          2038s _20000005
00230C4A  BC7C 0003               2039s     CMP.W   #3,D6
00230C4E  6FB4                    2040s     BLE _20000004
00230C50                          2041            
00230C50                          2042m     PRINT_CRLF D3,A0
00230C50  41F9 00230E86           2043m     LEA CRLF,A0
00230C56                          2044mm     PRINT_STR A0,D3
00230C56                          2045mm LOOP_143
00230C56  0C10 0000               2046mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00230C5A  6700 0016               2047mm     BEQ EXIT_143
00230C5E                          2048mmm     PRINT_CHAR (A0)+,D3
00230C5E                          2049mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230C5E                 TRUE     2050mmm     IFEQ DEBUG
00230C5E  1639 00C00003           2051mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230C64  0803 0002               2052mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230C68  67F4                    2053mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00230C6A  13D8 00C00007           2054mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230C70                          2055mmm     ENDC
00230C70                          2056mmm     
00230C70                 FALSE    2057mmm     IFNE DEBUG
00230C70                          2058mmm     ENDC
00230C70                          2059mmm 
00230C70                          2060mmm     ENDM
00230C70  60E4                    2061mm     BRA LOOP_143
00230C72                          2062mm EXIT_143
00230C72                          2063mm     ENDM
00230C72                          2064m     ENDM
00230C72                          2065  
00230C72  207C 00000000           2066      MOVE.L #ROM,A0                                  ; start of ROM
00230C78                          2067      
00230C78  2247                    2068      MOVE.L D7,A1                                    ; address accumulator -> address register
00230C7A  7E00                    2069      MOVE.L #0,D7                                    ; clear the now used address accumulator
00230C7C                          2070      
00230C7C  31FC AAAA 2AAA          2071      MOVE.W #$AAAA,$2AAA
00230C82  31FC 5555 1554          2072      MOVE.W #$5555,$1554
00230C88  31FC 8080 2AAA          2073      MOVE.W #$8080,$2AAA
00230C8E  31FC AAAA 2AAA          2074      MOVE.W #$AAAA,$2AAA
00230C94  31FC 5555 1554          2075      MOVE.W #$5555,$1554
00230C9A  31FC 2020 2AAA          2076      MOVE.W #$2020,$2AAA
00230CA0                          2077      
00230CA0  45F9 00230E72           2078      LEA LOADING,A2                              ; important for timing
00230CA6                          2079m     PRINT_STR A2,D3
00230CA6                          2080m LOOP_145
00230CA6  0C12 0000               2081m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00230CAA  6700 0016               2082m     BEQ EXIT_145
00230CAE                          2083mm     PRINT_CHAR (A2)+,D3
00230CAE                          2084mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00230CAE                 TRUE     2085mm     IFEQ DEBUG
00230CAE  1639 00C00003           2086mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00230CB4  0803 0002               2087mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00230CB8  67F4                    2088mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00230CBA  13DA 00C00007           2089mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00230CC0                          2090mm     ENDC
00230CC0                          2091mm     
00230CC0                 FALSE    2092mm     IFNE DEBUG
00230CC0                          2093mm     ENDC
00230CC0                          2094mm 
00230CC0                          2095mm     ENDM
00230CC0  60E4                    2096m     BRA LOOP_145
00230CC2                          2097m EXIT_145
00230CC2                          2098m     ENDM
00230CC2                          2099      
00230CC2                          2100      WHILE D5 <GT> #0 DO
00230CC2                          2101s _10000014
00230CC2  BA7C 0000               2102s     CMP.W   #0,D5
00230CC6  6F00 001C               2103s     BLE _10000015
00230CCA  5585                    2104          SUB.L #2,D5
00230CCC                          2105            
00230CCC  13D1 00E00001           2106          MOVE.B (A1),DISPLAY
00230CD2  3091                    2107          MOVE.W (A1),(A0)                            ; write the data
00230CD4                          2108        
00230CD4                          2109  WAIT_FOR_COMPLETE
00230CD4  3410                    2110          MOVE.W (A0),D2
00230CD6                          2111  
00230CD6                          2112          IF D2 <NE> (A1) THEN
00230CD6  B451                    2113s     CMP.W   (A1),D2
00230CD8  6700 0004               2114s     BEQ _0000000C
00230CDC  60F6                    2115              BRA WAIT_FOR_COMPLETE
00230CDE                          2116          ENDI
00230CDE                          2117s _0000000C
00230CDE                          2118        
00230CDE  5488                    2119          ADD.L #2,A0
00230CE0  5489                    2120          ADD.L #2,A1
00230CE2                          2121       ENDW    
00230CE2  60DE                    2122s     BRA _10000014
00230CE4                          2123s _10000015
00230CE4                          2124      
00230CE4  31FC AAAA 2AAA          2125      MOVE.W #$AAAA,$2AAA
00230CEA  31FC 5555 1554          2126      MOVE.W #$5555,$1554
00230CF0  31FC A0A0 2AAA          2127      MOVE.W #$A0A0,$2AAA
00230CF6                          2128              
00230CF6  6000 F46C               2129      BRA MAIN_LOOP
00230CFA                          2130          
00230CFA                          2131  HEX_DIGIT
00230CFA  E98F                    2132      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00230CFC                          2133m     HEX2BIN D2,D2,A0
00230CFC  41F9 00230E5B           2134m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00230D02  0402 0030               2135m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00230D06  C4BC 000000FF           2136m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00230D0C  1430 2000               2137m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00230D10                          2138m     ENDM
00230D10  8E02                    2139      OR.B D2,D7  
00230D12  6000 F478               2140      BRA GET_INPUT
00230D16                          2141  
00230D16  FFFF FFFF               2142      SIMHALT                                         ; halt simulator
00230D1A                          2143  
00230D1A                          2144  ; strings
00230D1A= 4D 44 46 2D 6D 6F ...   2145  VERSION DC.B 'MDF-mon V1.54 (10/04/2021)',CR,LF,NULL
00230D37= 3F 09 09 09 68 65 ...   2146  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00230D41= 5B 76 5D 09 09 09 ...   2147          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00230D50= 78 78 78 78 78 78 ...   2148          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00230D68= 78 78 78 78 78 78 ...   2149          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00230D88= 5B 73 5D 09 09 09 ...   2150          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00230DA2= 78 78 78 78 78 78 ...   2151          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00230DB3= 5B 7A 5D 09 09 09 ...   2152          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00230DC5= 78 78 78 78 78 78 ...   2153          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00230DE7= 48 75 68 3F 0D 0A 00    2154  HUH     DC.B 'Huh?',CR,LF,NULL
00230DEE= 20 53 20 72 65 63 ...   2155  READ    DC.B ' S records read, start address = ',NULL
00230E10= 57 3A 20 55 6E 6B ...   2156  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00230E27= 57 3A 20 43 53 20 ...   2157  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00230E39= 57 3A 20 52 41 4D ...   2158  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00230E4B= 30 31 32 33 34 35 ...   2159  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00230E5B= 00 01 02 03 04 05 ...   2160  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00230E72= 4C 6F 61 64 69 6E ...   2161  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00230E86= 0D 0A 00                2162  CRLF    DC.B CR,LF,NULL
00230E89                          2163      
00230E89                          2164      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         230E4B
CONTINUE_37         2303BA
CONTINUE_40         23040A
CONTINUE_44         230460
CONTINUE_52         230518
CONTINUE_57         23058C
CONTINUE_62         23060A
CONTINUE_67         23068A
CONTINUE_72         23071A
CONTINUE_77         23078E
CONTINUE_82         230802
CONTINUE_96         2308FE
CR                  D
CRLF                230E86
CS_FAILURE          230E27
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            962
DOWNLOAD_BYTE       C47
DOWNLOAD_DONE       230A10
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_101            23096A
EXIT_103            230994
EXIT_111            230A0A
EXIT_118            230A86
EXIT_126            230AFE
EXIT_128            230B70
EXIT_136            230BEA
EXIT_143            230C72
EXIT_145            230CC2
EXIT_16             230212
EXIT_18             230264
EXIT_20             230294
EXIT_28             230312
EXIT_3              230116
EXIT_35             230392
EXIT_49             2304D4
EXIT_5              230138
EXIT_8              23015A
EXIT_87             23087A
EXIT_89             23089C
EXIT_93             2308D0
G                   230B02
GET_INPUT           23018C
H                   230268
HELP                230D37
HEX2BIN             134
HEX2BIN_LUT         230E5B
HEX_DIGIT           230CFA
HUH                 230DE7
L                   230BFA
LF                  A
LOADING             230E72
LOOP_101            23094E
LOOP_103            230978
LOOP_105            2309BE
LOOP_111            2309EE
LOOP_113            230A3A
LOOP_118            230A6A
LOOP_120            230AB2
LOOP_126            230AE2
LOOP_128            230B54
LOOP_130            230B9E
LOOP_136            230BCE
LOOP_143            230C56
LOOP_145            230CA6
LOOP_16             2301F6
LOOP_18             230248
LOOP_20             230278
LOOP_22             2302C6
LOOP_28             2302F6
LOOP_3              2300FA
LOOP_35             230376
LOOP_49             2304B8
LOOP_5              23011C
LOOP_8              23013E
LOOP_87             23085E
LOOP_89             230880
LOOP_93             2308B4
MAIN_LOOP           230164
NULL                0
PRINTSTR            230278
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
R                   230298
RAM                 200000
RAM_ERROR           230E39
READ                230DEE
READ_CHAR           7FC
READ_DATA_TO_POKE   23031E
RESET               230004
ROM                 0
S                   230396
STACK               230000
START               230008
TAB                 9
UNREC               230E10
V                   230272
VERSION             230D1A
W                   230318
WAIT_CHAR           64D
WAIT_FOR_COMPLETE   230CD4
WAIT_FOR_READY_1    2300D8
WAIT_FOR_READY_10   230164
WAIT_FOR_READY_102  230956
WAIT_FOR_READY_104  230980
WAIT_FOR_READY_106  230994
WAIT_FOR_READY_107  2309A8
WAIT_FOR_READY_109  2309D2
WAIT_FOR_READY_11   230178
WAIT_FOR_READY_112  2309F6
WAIT_FOR_READY_114  230A10
WAIT_FOR_READY_115  230A24
WAIT_FOR_READY_117  230A4E
WAIT_FOR_READY_119  230A72
WAIT_FOR_READY_12   23018C
WAIT_FOR_READY_121  230A88
WAIT_FOR_READY_122  230A9C
WAIT_FOR_READY_124  230AC6
WAIT_FOR_READY_127  230AEA
WAIT_FOR_READY_129  230B5C
WAIT_FOR_READY_131  230B74
WAIT_FOR_READY_132  230B88
WAIT_FOR_READY_134  230BB2
WAIT_FOR_READY_137  230BD6
WAIT_FOR_READY_138  230C06
WAIT_FOR_READY_14   2301A6
WAIT_FOR_READY_140  230C20
WAIT_FOR_READY_144  230C5E
WAIT_FOR_READY_146  230CAE
WAIT_FOR_READY_17   2301FE
WAIT_FOR_READY_19   230250
WAIT_FOR_READY_21   230280
WAIT_FOR_READY_23   23029C
WAIT_FOR_READY_24   2302B0
WAIT_FOR_READY_26   2302DA
WAIT_FOR_READY_29   2302FE
WAIT_FOR_READY_30   230320
WAIT_FOR_READY_32   23033A
WAIT_FOR_READY_36   23037E
WAIT_FOR_READY_37   23039E
WAIT_FOR_READY_39   2303D8
WAIT_FOR_READY_4    230102
WAIT_FOR_READY_40   2303EE
WAIT_FOR_READY_42   230422
WAIT_FOR_READY_44   230444
WAIT_FOR_READY_46   230478
WAIT_FOR_READY_50   2304C0
WAIT_FOR_READY_52   2304FC
WAIT_FOR_READY_54   230530
WAIT_FOR_READY_57   230570
WAIT_FOR_READY_59   2305A4
WAIT_FOR_READY_6    230124
WAIT_FOR_READY_62   2305EE
WAIT_FOR_READY_64   230622
WAIT_FOR_READY_67   23066E
WAIT_FOR_READY_69   2306A2
WAIT_FOR_READY_72   2306FE
WAIT_FOR_READY_74   230732
WAIT_FOR_READY_77   230772
WAIT_FOR_READY_79   2307A6
WAIT_FOR_READY_82   2307E6
WAIT_FOR_READY_84   23081A
WAIT_FOR_READY_88   230866
WAIT_FOR_READY_9    230146
WAIT_FOR_READY_90   230888
WAIT_FOR_READY_91   23089C
WAIT_FOR_READY_94   2308BC
WAIT_FOR_READY_96   2308E2
WAIT_FOR_READY_98   230916
WAIT_FOR_SRECORD    23039E
Z                   230B0A
_00000000           2301CC
_00000001           2301E0
_00000002           2304DC
_00000003           2308D4
_00000004           2304EA
_00000005           2306E6
_00000006           230654
_00000007           2308D4
_00000008           230858
_00000009           2308D4
_0000000A           230A0E
_0000000B           230BEA
_0000000C           230CDE
_10000000           23043A
_10000001           2304A4
_10000002           2304F2
_10000003           23055C
_10000004           230566
_10000005           2305D0
_10000006           2305E4
_10000007           23064E
_10000008           230658
_10000009           2306DC
_1000000A           230664
_1000000B           2306CE
_1000000C           2306F4
_1000000D           23075E
_1000000E           230768
_1000000F           2307D2
_10000010           2307DC
_10000011           230846
_10000012           2308D8
_10000013           230942
_10000014           230CC2
_10000015           230CE4
_20000000           230B16
_20000001           230B26
_20000002           230B3A
_20000003           230BEC
_20000004           230C04
_20000005           230C4A
