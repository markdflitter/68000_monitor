00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 13:13:10

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                             9  ; load SP with some version indication
00000000                            10  ; add command to write to eeprom to back patch start address
00000000                            11  ; something prints 'N' on starting...
00000000                            12  ; also garbage on serial port when starting
00000000                            13  ; use DBLoop?
00000000                            14  
00000000                            15  
00000000                            16  ; ideas, but no room to do them
00000000                            17  ;------------------------------
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; implement backspace
00000000                            20  ; fix being able to enter random chars when W'ing
00000000                            21  ; ram check at startup?  Not sure if this is a good idea!
00000000                            22  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            23  
00000000                            24      ORG  $0
00000000                            25  
00000000  =00000000                 26  DEBUG               EQU 0
00000000                            27  
00000000                            28  ; constants
00000000  =00000000                 29  NULL                EQU 0
00000000  =00000009                 30  TAB                 EQU 9
00000000  =0000000D                 31  CR                  EQU 13
00000000  =0000000A                 32  LF                  EQU 10
00000000                            33  
00000000  =00000000                 34  ROM                 EQU $0
00000000  =00200000                 35  RAM                 EQU $200000
00000000                            36     
00000000  =00C00000                 37  DUART_BASE          EQU $C00000
00000000  =00000000                 38  DUART_MRA_          EQU $0
00000000  =00000001                 39  DUART_CSRA_         EQU $1
00000000  =00000001                 40  DUART_SRA_          EQU $1
00000000  =00000002                 41  DUART_CRA_          EQU $2
00000000  =00000003                 42  DUART_TXA_          EQU $3
00000000  =00000003                 43  DUART_RXA_          EQU $3
00000000  =00000004                 44  DUART_ACR_          EQU $4
00000000  =00000005                 45  DUART_IMR_          EQU $5
00000000  =00000008                 46  DUART_MRB_          EQU $8
00000000  =00000009                 47  DUART_CSRB_         EQU $9
00000000  =00000009                 48  DUART_SRB_          EQU $9
00000000  =0000000A                 49  DUART_CRB_          EQU $A
00000000  =0000000B                 50  DUART_TXB_          EQU $B
00000000  =0000000B                 51  DUART_RXB_          EQU $B
00000000  =0000000C                 52  DUART_IVR_          EQU $C
00000000  =0000000D                 53  DUART_OPCR_         EQU $D
00000000  =0000000E                 54  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 55  DUART_RESET_OPR_    EQU $F
00000000                            56  
00000000  =00C00001                 57  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 58  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 59  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 60  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 61  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 62  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            63  
00000000  =00C00011                 64  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 65  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 66  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 67  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 68  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 69  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            70  
00000000  =00C00009                 71  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 72  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 73  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 74  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 75  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 76  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            77  
00000000  =00E00000                 78  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 79  DISPLAY_            EQU $0
00000000  =00E00001                 80  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            81  
00000000                            82  ; macros
00000000                            83  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            86  BIN2HEX MACRO
00000000                            87      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            88      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            89      MOVE.B \1,\2
00000000                            90      ANDI.L #$F,\2
00000000                            91      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            92      ENDM
00000000                            93  
00000000                            94  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            95  ; the input register is changed during the process
00000000                            96  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            97  HEX2BIN MACRO
00000000                            98      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            99      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           100      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           101      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                           102      ENDM
00000000                           103  
00000000                           104  ; send a single char to the serial port
00000000                           105  ; \1 = char to send, \2 = data register to use for status poll
00000000                           106  ; will stamp on D0 and D1 in debug mode
00000000                           107  PRINT_CHAR MACRO
00000000                           108  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           109      IFEQ DEBUG
00000000                           110          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           111          BTST #2,\2                              ; check for space to send
00000000                           112          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           113          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           114      ENDC
00000000                           115      
00000000                           116      IFNE DEBUG
00000000                           117          MOVE.B \1,D1
00000000                           118          MOVE.L #6,D0   
00000000                           119          TRAP #15                                ; write to terminal in simulator
00000000                           120      ENDC
00000000                           121  
00000000                           122      ENDM
00000000                           123  
00000000                           124  ; send CR,LF to the serial port
00000000                           125  ; \1 = data register to use for status poll, /2 = working address register
00000000                           126  PRINT_CRLF MACRO
00000000                           127      LEA CRLF(PC),\2
00000000                           128      PRINT_STR \2,\1
00000000                           129      ENDM
00000000                           130  
00000000                           131  ; send C-style, zero terminated string to the serial port
00000000                           132  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           133  PRINT_STR MACRO
00000000                           134  LOOP\@
00000000                           135      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           136      BEQ EXIT\@
00000000                           137      PRINT_CHAR (\1)+,\2
00000000                           138      BRA LOOP\@
00000000                           139  EXIT\@
00000000                           140      ENDM
00000000                           141    
00000000                           142  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           143  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           144  PRINT_REG MACRO
00000000                           145      LEA ox(PC),\5
00000000                           146      PRINT_STR \5,\2
00000000                           147      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           148  LOOP\@
00000000                           149      BIN2HEX \1,\3,\5
00000000                           150      PRINT_CHAR \3,\2
00000000                           151      DBEQ \4,LOOP\@
00000000                           152      ENDM
00000000                           153      
00000000                           154  ; wait for a char from the serial port
00000000                           155  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           156  ; will stamp on D0 and D1 in debug mode
00000000                           157  WAIT_CHAR MACRO
00000000                           158  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           159      IFEQ DEBUG
00000000                           160          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           161          BTST #0,\2                              ; check for character
00000000                           162          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           163      ENDC
00000000                           164      
00000000                           165      READ_CHAR \1
00000000                           166  
00000000                           167      IFEQ DEBUG
00000000                           168          PRINT_CHAR \1,\2                            ; echo it back
00000000                           169      ENDC
00000000                           170      ENDM
00000000                           171      
00000000                           172  ; read a char from the serial port - assumes that there is one!
00000000                           173  ; \ 1= data register for read char
00000000                           174  ; will stamp on D0 and D1 in debug mode
00000000                           175  READ_CHAR MACRO
00000000                           176      IFEQ DEBUG
00000000                           177          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           178      ENDC
00000000                           179      IFNE DEBUG
00000000                           180          MOVE.L #5,D0    
00000000                           181          TRAP #15                                    ; read from keyboard in simulator
00000000                           182          MOVE.L D1,\1
00000000                           183      ENDC
00000000                           184       
00000000                           185      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           186      BEQ START
00000000                           187      ENDM
00000000                           188      
00000000                           189      
00000000                           190  ; read data from the download serial port
00000000                           191  ; \ 1= data register for read char
00000000                           192  DOWNLOAD MACRO
00000000                           193  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           194  
00000000                           195      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           196      BTST #0,\1                                  ; check for character
00000000                           197      BEQ CONTINUE\@                              ; nothing, continue
00000000                           198   
00000000                           199      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           200  CONTINUE\@
00000000                           201      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           202      BTST #0,\1                                      ; check for character
00000000                           203      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           204      
00000000                           205      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           206      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           207      
00000000                           208      ENDM
00000000                           209      
00000000                           210  ; read two hex digits from the download serial port and convert to a byte
00000000                           211  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           212  DOWNLOAD_BYTE MACRO
00000000                           213      MOVE.B #2,\4
00000000                           214      WHILE.B \4 <GT> 0 DO
00000000                           215          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           216          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           217          PRINT_CHAR \2,\3
00000000                           218          HEX2BIN \2,\2,\6
00000000                           219          OR.B \2,\1
00000000                           220          SUB.B #1,\4
00000000                           221      ENDW
00000000                           222      
00000000                           223      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           224      MOVE.B \1,\2
00000000                           225      ADD.L \1,\5
00000000                           226  
00000000                           227      ENDM
00000000                           228      
00000000                           229  ; write word to EEPROM
00000000                           230  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           231  PROGRAM MACRO
00000000                           232    MOVE.W \1,\2                          ; write the data
00000000                           233        
00000000                           234  WAIT_FOR_COMPLETE\@
00000000                           235          MOVE.W \2,\3
00000000                           236  
00000000                           237          IF.W \3 <NE> \1 THEN
00000000                           238              BRA WAIT_FOR_COMPLETE\@
00000000                           239          ENDI
00000000                           240          ENDM
00000000                           241          
00000000                           242  ; register catalogue
00000000                           243  ; D0 - used for simulator I/O
00000000                           244  ; D1 - used for simulator I/O
00000000                           245  ; D2 - read character
00000000                           246  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           247  ; D6 - working register used in R/W
00000000                           248  ; D7 - address accumulator, reset by download
00000000                           249  ; A0 - address of string to print 
00000000                           250  
00000000                           251  ; start vector
00000000= 00000000                 252  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 253  RESET    DC.L START                             ; RESET
00000008                           254      
00000008                           255  ; start of program  
00000008                           256  START
00000008  13FC 0000 00E00001       257      MOVE.B #0,DISPLAY
00000010                           258  
00000010                           259  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       260      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       261      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           262      
00000020                           263      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                264s     MOVE.W  #$50,D1
00000024  6000 000E                265s     BRA _20000001
00000028                           266s _20000000
00000028  13C1 00C00005            267          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     268          NOP
00000030                           269      ENDF
00000030  0441 0010                270s     SUB.W   #$10,D1
00000034                           271s _20000001
00000034  B27C 0010                272s     CMP.W   #$10,D1
00000038  6CEE                     273s     BGE _20000000
0000003A                           274  
0000003A                           275      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                276s     MOVE.W  #$50,D1
0000003E  6000 000E                277s     BRA _20000003
00000042                           278s _20000002
00000042  13C1 00C00015            279          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     280          NOP
0000004A                           281      ENDF
0000004A  0441 0010                282s     SUB.W   #$10,D1
0000004E                           283s _20000003
0000004E  B27C 0010                284s     CMP.W   #$10,D1
00000052  6CEE                     285s     BGE _20000002
00000054                           286    
00000054                           287  ;initialise UART
00000054  13FC 0000 00C00009       288      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       289      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       290      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           291  
0000006C                           292  ; channel A
0000006C  13FC 0013 00C00001       293      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       294      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       295      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       296      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           297  
0000008C                           298  ; channel B
0000008C  13FC 0013 00C00011       299      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       300      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       301      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       302      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           303  
000000AC                           304      ;PRINT_CHAR '.',D3                              ; give the serial port chance to settle after reset
000000AC                           305  
000000AC  13FC 0001 00E00001       306      MOVE.B #1,DISPLAY
000000B4                           307         
000000B4                           308m     PRINT_CRLF D3,A0
000000B4  41FA 0E77                309m     LEA CRLF(PC),A0
000000B8                           310mm     PRINT_STR A0,D3
000000B8                           311mm LOOP_2
000000B8  0C10 0000                312mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000BC  6700 0016                313mm     BEQ EXIT_2
000000C0                           314mmm     PRINT_CHAR (A0)+,D3
000000C0                           315mmm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      316mmm     IFEQ DEBUG
000000C0  1639 00C00003            317mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000C6  0803 0002                318mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000CA  67F4                     319mmm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
000000CC  13D8 00C00007            320mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000D2                           321mmm     ENDC
000000D2                           322mmm     
000000D2                 FALSE     323mmm     IFNE DEBUG
000000D2                           324mmm     ENDC
000000D2                           325mmm 
000000D2                           326mmm     ENDM
000000D2  60E4                     327mm     BRA LOOP_2
000000D4                           328mm EXIT_2
000000D4                           329mm     ENDM
000000D4                           330m     ENDM
000000D4                           331  
000000D4  41FA 0CD8                332      LEA VERSION(PC),A0
000000D8                           333m     PRINT_STR A0,D3
000000D8                           334m LOOP_4
000000D8  0C10 0000                335m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000DC  6700 0016                336m     BEQ EXIT_4
000000E0                           337mm     PRINT_CHAR (A0)+,D3
000000E0                           338mm WAIT_FOR_READY_5                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E0                 TRUE      339mm     IFEQ DEBUG
000000E0  1639 00C00003            340mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000E6  0803 0002                341mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000EA  67F4                     342mm         BEQ WAIT_FOR_READY_5                    ; NO SPACE, CHECK AGAIN
000000EC  13D8 00C00007            343mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000F2                           344mm     ENDC
000000F2                           345mm     
000000F2                 FALSE     346mm     IFNE DEBUG
000000F2                           347mm     ENDC
000000F2                           348mm 
000000F2                           349mm     ENDM
000000F2  60E4                     350m     BRA LOOP_4
000000F4                           351m EXIT_4
000000F4                           352m     ENDM
000000F4                           353      
000000F4  41FA 0CD5                354      LEA HELPPROMPT(PC),A0
000000F8                           355m     PRINT_STR A0,D3
000000F8                           356m LOOP_6
000000F8  0C10 0000                357m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FC  6700 0016                358m     BEQ EXIT_6
00000100                           359mm     PRINT_CHAR (A0)+,D3
00000100                           360mm WAIT_FOR_READY_7                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000100                 TRUE      361mm     IFEQ DEBUG
00000100  1639 00C00003            362mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000106  0803 0002                363mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010A  67F4                     364mm         BEQ WAIT_FOR_READY_7                    ; NO SPACE, CHECK AGAIN
0000010C  13D8 00C00007            365mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000112                           366mm     ENDC
00000112                           367mm     
00000112                 FALSE     368mm     IFNE DEBUG
00000112                           369mm     ENDC
00000112                           370mm 
00000112                           371mm     ENDM
00000112  60E4                     372m     BRA LOOP_6
00000114                           373m EXIT_6
00000114                           374m     ENDM
00000114                           375      
00000114                           376m     PRINT_CRLF D3,A0
00000114  41FA 0E17                377m     LEA CRLF(PC),A0
00000118                           378mm     PRINT_STR A0,D3
00000118                           379mm LOOP_9
00000118  0C10 0000                380mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000011C  6700 0016                381mm     BEQ EXIT_9
00000120                           382mmm     PRINT_CHAR (A0)+,D3
00000120                           383mmm WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000120                 TRUE      384mmm     IFEQ DEBUG
00000120  1639 00C00003            385mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000126  0803 0002                386mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012A  67F4                     387mmm         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0000012C  13D8 00C00007            388mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000132                           389mmm     ENDC
00000132                           390mmm     
00000132                 FALSE     391mmm     IFNE DEBUG
00000132                           392mmm     ENDC
00000132                           393mmm 
00000132                           394mmm     ENDM
00000132  60E4                     395mm     BRA LOOP_9
00000134                           396mm EXIT_9
00000134                           397mm     ENDM
00000134                           398m     ENDM
00000134                           399  
00000134  7E00                     400      MOVE.L #0,D7                                    ; address accumulator
00000136                           401  
00000136  13FC 0002 00E00001       402      MOVE.B #2,DISPLAY
0000013E                           403  MAIN_LOOP
0000013E  41FA 0DF0                404      LEA PROMPT(PC),A0
00000142                           405m     PRINT_STR A0,D3
00000142                           406m LOOP_11
00000142  0C10 0000                407m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000146  6700 0016                408m     BEQ EXIT_11
0000014A                           409mm     PRINT_CHAR (A0)+,D3
0000014A                           410mm WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000014A                 TRUE      411mm     IFEQ DEBUG
0000014A  1639 00C00003            412mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000150  0803 0002                413mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000154  67F4                     414mm         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
00000156  13D8 00C00007            415mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000015C                           416mm     ENDC
0000015C                           417mm     
0000015C                 FALSE     418mm     IFNE DEBUG
0000015C                           419mm     ENDC
0000015C                           420mm 
0000015C                           421mm     ENDM
0000015C  60E4                     422m     BRA LOOP_11
0000015E                           423m EXIT_11
0000015E                           424m     ENDM
0000015E                           425      
0000015E                           426  GET_INPUT
0000015E                           427m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015E                           428m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015E                 TRUE      429m     IFEQ DEBUG
0000015E  1639 00C00003            430m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000164  0803 0000                431m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000168  67F4                     432m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
0000016A                           433m     ENDC
0000016A                           434m     
0000016A                           435mm     READ_CHAR D2
0000016A                 TRUE      436mm     IFEQ DEBUG
0000016A  1439 00C00007            437mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000170                           438mm     ENDC
00000170                 FALSE     439mm     IFNE DEBUG
00000170                           440mm     ENDC
00000170                           441mm      
00000170  B43C 001B                442mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000174  6700 FE92                443mm     BEQ START
00000178                           444mm     ENDM
00000178                           445m 
00000178                 TRUE      446m     IFEQ DEBUG
00000178                           447mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000178                           448mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      449mm     IFEQ DEBUG
00000178  1639 00C00003            450mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                451mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     452mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
00000184  13C2 00C00007            453mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000018A                           454mm     ENDC
0000018A                           455mm     
0000018A                 FALSE     456mm     IFNE DEBUG
0000018A                           457mm     ENDC
0000018A                           458mm 
0000018A                           459mm     ENDM
0000018A                           460m     ENDC
0000018A                           461m     ENDM
0000018A                           462      
0000018A                           463      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000018A  B43C 0030                464s     CMP.B   #'0',D2
0000018E  6D00 000E                465s     BLT _00000000
00000192  B43C 0039                466s     CMP.B   #'9',D2
00000196  6E00 0006                467s     BGT _00000000
0000019A  6000 0BF4                468          BRA HEX_DIGIT
0000019E                           469      ENDI
0000019E                           470s _00000000
0000019E                           471      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019E  B43C 0041                472s     CMP.B   #'A',D2
000001A2  6D00 000E                473s     BLT _00000001
000001A6  B43C 0046                474s     CMP.B   #'F',D2
000001AA  6E00 0006                475s     BGT _00000001
000001AE  6000 0BE0                476          BRA HEX_DIGIT
000001B2                           477      ENDI
000001B2                           478s _00000001
000001B2                           479          
000001B2  B43C 0077                480      CMP.B #'w',D2
000001B6  6700 011E                481      BEQ W
000001BA                           482      
000001BA  B43C 006C                483      CMP.B #'l',D2
000001BE  6700 09A0                484      BEQ L 
000001C2                           485  
000001C2                           486m     PRINT_CRLF D3,A0
000001C2  41FA 0D69                487m     LEA CRLF(PC),A0
000001C6                           488mm     PRINT_STR A0,D3
000001C6                           489mm LOOP_17
000001C6  0C10 0000                490mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001CA  6700 0016                491mm     BEQ EXIT_17
000001CE                           492mmm     PRINT_CHAR (A0)+,D3
000001CE                           493mmm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      494mmm     IFEQ DEBUG
000001CE  1639 00C00003            495mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001D4  0803 0002                496mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D8  67F4                     497mmm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
000001DA  13D8 00C00007            498mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001E0                           499mmm     ENDC
000001E0                           500mmm     
000001E0                 FALSE     501mmm     IFNE DEBUG
000001E0                           502mmm     ENDC
000001E0                           503mmm 
000001E0                           504mmm     ENDM
000001E0  60E4                     505mm     BRA LOOP_17
000001E2                           506mm EXIT_17
000001E2                           507mm     ENDM
000001E2                           508m     ENDM
000001E2                           509   
000001E2  B43C 003F                510      CMP.B #'?',D2
000001E6  6700 004E                511      BEQ H
000001EA                           512   
000001EA  B43C 0076                513      CMP.B #'v',D2
000001EE  6700 004E                514      BEQ V
000001F2                           515      
000001F2  B43C 0072                516      CMP.B #'r',D2
000001F6  6700 006A                517      BEQ R
000001FA                           518  
000001FA  B43C 0073                519      CMP.B #'s',D2
000001FE  6700 014A                520      BEQ S
00000202                           521  
00000202  B43C 0067                522      CMP.B #'g',D2
00000206  6700 086E                523      BEQ G   
0000020A                           524  
0000020A  B43C 007A                525      CMP.B #'z',D2
0000020E  6700 086E                526      BEQ Z   
00000212                           527  
00000212  41FA 0C7A                528      LEA HUH(PC),A0
00000216                           529m     PRINT_STR A0,D3
00000216                           530m LOOP_19
00000216  0C10 0000                531m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000021A  6700 0016                532m     BEQ EXIT_19
0000021E                           533mm     PRINT_CHAR (A0)+,D3
0000021E                           534mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021E                 TRUE      535mm     IFEQ DEBUG
0000021E  1639 00C00003            536mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000224  0803 0002                537mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000228  67F4                     538mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
0000022A  13D8 00C00007            539mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000230                           540mm     ENDC
00000230                           541mm     
00000230                 FALSE     542mm     IFNE DEBUG
00000230                           543mm     ENDC
00000230                           544mm 
00000230                           545mm     ENDM
00000230  60E4                     546m     BRA LOOP_19
00000232                           547m EXIT_19
00000232                           548m     ENDM
00000232                           549                         
00000232  6000 FF0A                550      BRA MAIN_LOOP
00000236                           551      
00000236                           552  ; commands
00000236                           553  H   
00000236  41FA 0BA6                554      LEA HELP(PC),A0
0000023A  6000 0006                555      BRA PRINTSTR
0000023E                           556  
0000023E                           557  V   
0000023E  41FA 0B6E                558      LEA VERSION(PC),A0
00000242                           559  PRINTSTR
00000242                           560m     PRINT_STR A0,D3       
00000242                           561m LOOP_21
00000242  0C10 0000                562m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000246  6700 0016                563m     BEQ EXIT_21
0000024A                           564mm     PRINT_CHAR (A0)+,D3
0000024A                           565mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024A                 TRUE      566mm     IFEQ DEBUG
0000024A  1639 00C00003            567mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000250  0803 0002                568mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000254  67F4                     569mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000256  13D8 00C00007            570mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000025C                           571mm     ENDC
0000025C                           572mm     
0000025C                 FALSE     573mm     IFNE DEBUG
0000025C                           574mm     ENDC
0000025C                           575mm 
0000025C                           576mm     ENDM
0000025C  60E4                     577m     BRA LOOP_21
0000025E                           578m EXIT_21
0000025E                           579m     ENDM
0000025E  6000 FEDE                580      BRA MAIN_LOOP
00000262                           581      
00000262                           582  R   
00000262  2047                     583      MOVE.L D7,A0                                    ; address accumulator -> address register
00000264  7E00                     584      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000266  2410                     585      MOVE.L (A0),D2                                  ; read the memory and print it
00000268                           586m     PRINT_REG D2,D3,D4,D5,A0
00000268  41FA 0CC9                587m     LEA OX(PC),A0
0000026C                           588mm     PRINT_STR A0,D3
0000026C                           589mm LOOP_24
0000026C  0C10 0000                590mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000270  6700 0016                591mm     BEQ EXIT_24
00000274                           592mmm     PRINT_CHAR (A0)+,D3
00000274                           593mmm WAIT_FOR_READY_25                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      594mmm     IFEQ DEBUG
00000274  1639 00C00003            595mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000027A  0803 0002                596mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000027E  67F4                     597mmm         BEQ WAIT_FOR_READY_25                   ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            598mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000286                           599mmm     ENDC
00000286                           600mmm     
00000286                 FALSE     601mmm     IFNE DEBUG
00000286                           602mmm     ENDC
00000286                           603mmm 
00000286                           604mmm     ENDM
00000286  60E4                     605mm     BRA LOOP_24
00000288                           606mm EXIT_24
00000288                           607mm     ENDM
00000288  7A07                     608m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           609m LOOP_23
0000028A                           610mm     BIN2HEX D2,D4,A0
0000028A  41FA 0C66                611mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
0000028E  E99A                     612mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1802                     613mm     MOVE.B D2,D4
00000292  0284 0000000F            614mm     ANDI.L #$F,D4
00000298  1830 4000                615mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           616mm     ENDM
0000029C                           617mm     PRINT_CHAR D4,D3
0000029C                           618mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      619mm     IFEQ DEBUG
0000029C  1639 00C00003            620mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                621mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     622mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002A8  13C4 00C00007            623mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002AE                           624mm     ENDC
000002AE                           625mm     
000002AE                 FALSE     626mm     IFNE DEBUG
000002AE                           627mm     ENDC
000002AE                           628mm 
000002AE                           629mm     ENDM
000002AE  57CD FFDA                630m     DBEQ D5,LOOP_23
000002B2                           631m     ENDM
000002B2                           632m     PRINT_CRLF D3,A0
000002B2  41FA 0C79                633m     LEA CRLF(PC),A0
000002B6                           634mm     PRINT_STR A0,D3
000002B6                           635mm LOOP_29
000002B6  0C10 0000                636mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002BA  6700 0016                637mm     BEQ EXIT_29
000002BE                           638mmm     PRINT_CHAR (A0)+,D3
000002BE                           639mmm WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      640mmm     IFEQ DEBUG
000002BE  1639 00C00003            641mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002C4  0803 0002                642mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002C8  67F4                     643mmm         BEQ WAIT_FOR_READY_30                   ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            644mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D0                           645mmm     ENDC
000002D0                           646mmm     
000002D0                 FALSE     647mmm     IFNE DEBUG
000002D0                           648mmm     ENDC
000002D0                           649mmm 
000002D0                           650mmm     ENDM
000002D0  60E4                     651mm     BRA LOOP_29
000002D2                           652mm EXIT_29
000002D2                           653mm     ENDM
000002D2                           654m     ENDM
000002D2  6000 FE6A                655      BRA MAIN_LOOP
000002D6                           656  
000002D6                           657  W
000002D6  3C3C 0007                658      MOVE #7,D6                                      ; 7 bytes left to read
000002DA                           659      
000002DA                           660  READ_DATA_TO_POKE
000002DA  E98D                     661      LSL.L #4,D5                                     ; make what we have so far more significant
000002DC                           662m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002DC                           663m WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DC                 TRUE      664m     IFEQ DEBUG
000002DC  1639 00C00003            665m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E2  0803 0000                666m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002E6  67F4                     667m         BEQ WAIT_FOR_READY_31                   ; NOTHING, CHECK AGAIN
000002E8                           668m     ENDC
000002E8                           669m     
000002E8                           670mm     READ_CHAR D2
000002E8                 TRUE      671mm     IFEQ DEBUG
000002E8  1439 00C00007            672mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002EE                           673mm     ENDC
000002EE                 FALSE     674mm     IFNE DEBUG
000002EE                           675mm     ENDC
000002EE                           676mm      
000002EE  B43C 001B                677mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002F2  6700 FD14                678mm     BEQ START
000002F6                           679mm     ENDM
000002F6                           680m 
000002F6                 TRUE      681m     IFEQ DEBUG
000002F6                           682mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000002F6                           683mm WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F6                 TRUE      684mm     IFEQ DEBUG
000002F6  1639 00C00003            685mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FC  0803 0002                686mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000300  67F4                     687mm         BEQ WAIT_FOR_READY_33                   ; NO SPACE, CHECK AGAIN
00000302  13C2 00C00007            688mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000308                           689mm     ENDC
00000308                           690mm     
00000308                 FALSE     691mm     IFNE DEBUG
00000308                           692mm     ENDC
00000308                           693mm 
00000308                           694mm     ENDM
00000308                           695m     ENDC
00000308                           696m     ENDM
00000308                           697m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000308  41FA 0BF8                698m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000030C  0402 0030                699m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000310  C4BC 000000FF            700m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000316  1430 2000                701m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
0000031A                           702m     ENDM
0000031A  8A02                     703      OR.B D2,D5
0000031C  57CE FFBC                704      DBEQ D6,READ_DATA_TO_POKE
00000320                           705      
00000320  2047                     706      MOVE.L D7,A0                                    ; address accumulator -> address register
00000322  7E00                     707      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000324                           708      
00000324  2085                     709      MOVE.L D5,(A0)                                  ; write the data
00000326                           710  
00000326                           711m     PRINT_CRLF D3,A0
00000326  41FA 0C05                712m     LEA CRLF(PC),A0
0000032A                           713mm     PRINT_STR A0,D3
0000032A                           714mm LOOP_36
0000032A  0C10 0000                715mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000032E  6700 0016                716mm     BEQ EXIT_36
00000332                           717mmm     PRINT_CHAR (A0)+,D3
00000332                           718mmm WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000332                 TRUE      719mmm     IFEQ DEBUG
00000332  1639 00C00003            720mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000338  0803 0002                721mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000033C  67F4                     722mmm         BEQ WAIT_FOR_READY_37                   ; NO SPACE, CHECK AGAIN
0000033E  13D8 00C00007            723mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000344                           724mmm     ENDC
00000344                           725mmm     
00000344                 FALSE     726mmm     IFNE DEBUG
00000344                           727mmm     ENDC
00000344                           728mmm 
00000344                           729mmm     ENDM
00000344  60E4                     730mm     BRA LOOP_36
00000346                           731mm EXIT_36
00000346                           732mm     ENDM
00000346                           733m     ENDM
00000346  6000 FDF6                734      BRA MAIN_LOOP
0000034A                           735  
0000034A                           736  ; register map for S
0000034A                           737  ; A0 - start address
0000034A                           738  ; A1 - offset
0000034A                           739  ; A2 - next address to write
0000034A                           740  ; A3 - next location (jmp)
0000034A                           741  ; A4 - Working Address Register
0000034A                           742  ; D0 - record count
0000034A                           743  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000034A                           744  ; D2 - checksum
0000034A                           745  ; D3 - data byte count
0000034A                           746  ; D4 - read address, moved into A2
0000034A                           747  ; D5 - temp
0000034A                           748  ; D6 - temp
0000034A                           749  ; D7 - temp
0000034A                           750  S
0000034A  2078 0000                751      MOVE.L 0,A0                                     ; start address -> A0
0000034E  2247                     752      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000350                           753      
00000350  7000                     754      MOVE.L #0,D0                                    ; count of records read -> D0
00000352                           755          
00000352                           756  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000352                           757m     DOWNLOAD D1                 
00000352                           758m WAIT_FOR_READY_38                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000352                           759m 
00000352  1239 00C00003            760m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000358  0801 0000                761m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000035C  6700 0010                762m     BEQ CONTINUE_38                             ; NOTHING, CONTINUE
00000360                           763m  
00000360                           764mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000360                 TRUE      765mm     IFEQ DEBUG
00000360  1239 00C00007            766mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000366                           767mm     ENDC
00000366                 FALSE     768mm     IFNE DEBUG
00000366                           769mm     ENDC
00000366                           770mm      
00000366  B23C 001B                771mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0000036A  6700 FC9C                772mm     BEQ START
0000036E                           773mm     ENDM
0000036E                           774m CONTINUE_38
0000036E  1239 00C00013            775m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000374  0801 0000                776m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000378  67D8                     777m     BEQ WAIT_FOR_READY_38                           ; NOTHING, CHECK AGAIN
0000037A                           778m     
0000037A  1239 00C00017            779m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000380  13C1 00E00001            780m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000386                           781m     
00000386                           782m     ENDM
00000386  B23C 0053                783      CMP.B #'S',D1                                   ; found S?    
0000038A  66C6                     784      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000038C                           785      
0000038C                           786m     PRINT_CHAR #'S',D5                            ; print the S
0000038C                           787m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038C                 TRUE      788m     IFEQ DEBUG
0000038C  1A39 00C00003            789m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000392  0805 0002                790m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000396  67F4                     791m         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
00000398  13FC 0053 00C00007       792m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003A0                           793m     ENDC
000003A0                           794m     
000003A0                 FALSE     795m     IFNE DEBUG
000003A0                           796m     ENDC
000003A0                           797m 
000003A0                           798m     ENDM
000003A0  5280                     799      ADD.L #1,D0                                     ; read another S record, increment count
000003A2                           800      
000003A2                           801m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003A2                           802m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A2                           803m 
000003A2  1239 00C00003            804m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003A8  0801 0000                805m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003AC  6700 0010                806m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
000003B0                           807m  
000003B0                           808mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003B0                 TRUE      809mm     IFEQ DEBUG
000003B0  1239 00C00007            810mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003B6                           811mm     ENDC
000003B6                 FALSE     812mm     IFNE DEBUG
000003B6                           813mm     ENDC
000003B6                           814mm      
000003B6  B23C 001B                815mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003BA  6700 FC4C                816mm     BEQ START
000003BE                           817mm     ENDM
000003BE                           818m CONTINUE_41
000003BE  1239 00C00013            819m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003C4  0801 0000                820m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003C8  67D8                     821m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003CA                           822m     
000003CA  1239 00C00017            823m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003D0  13C1 00E00001            824m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003D6                           825m     
000003D6                           826m     ENDM
000003D6                           827m     PRINT_CHAR D1,D5
000003D6                           828m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D6                 TRUE      829m     IFEQ DEBUG
000003D6  1A39 00C00003            830m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003DC  0805 0002                831m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003E0  67F4                     832m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
000003E2  13C1 00C00007            833m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003E8                           834m     ENDC
000003E8                           835m     
000003E8                 FALSE     836m     IFNE DEBUG
000003E8                           837m     ENDC
000003E8                           838m 
000003E8                           839m     ENDM
000003E8                           840  
000003E8  7400                     841      MOVE.L #0,D2                                    ; clear the checksum
000003EA                           842  
000003EA                           843m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003EA  1E3C 0002                844m     MOVE.B #2,D7
000003EE                           845m     WHILE.B D7 <GT> 0 DO
000003EE                           846ms _10000000
000003EE  BE38 0000                847ms     CMP.B   0,D7
000003F2  6F00 0062                848ms     BLE _10000001
000003F6  E98B                     849m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
000003F8                           850mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000003F8                           851mm WAIT_FOR_READY_45                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003F8                           852mm 
000003F8  1A39 00C00003            853mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000003FE  0805 0000                854mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000402  6700 0010                855mm     BEQ CONTINUE_45                             ; NOTHING, CONTINUE
00000406                           856mm  
00000406                           857mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000406                 TRUE      858mmm     IFEQ DEBUG
00000406  1A39 00C00007            859mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000040C                           860mmm     ENDC
0000040C                 FALSE     861mmm     IFNE DEBUG
0000040C                           862mmm     ENDC
0000040C                           863mmm      
0000040C  BA3C 001B                864mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000410  6700 FBF6                865mmm     BEQ START
00000414                           866mmm     ENDM
00000414                           867mm CONTINUE_45
00000414  1A39 00C00013            868mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000041A  0805 0000                869mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000041E  67D8                     870mm     BEQ WAIT_FOR_READY_45                           ; NOTHING, CHECK AGAIN
00000420                           871mm     
00000420  1A39 00C00017            872mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000426  13C5 00E00001            873mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000042C                           874mm     
0000042C                           875mm     ENDM
0000042C                           876mm         PRINT_CHAR D5,D6
0000042C                           877mm WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042C                 TRUE      878mm     IFEQ DEBUG
0000042C  1C39 00C00003            879mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000432  0806 0002                880mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000436  67F4                     881mm         BEQ WAIT_FOR_READY_47                   ; NO SPACE, CHECK AGAIN
00000438  13C5 00C00007            882mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000043E                           883mm     ENDC
0000043E                           884mm     
0000043E                 FALSE     885mm     IFNE DEBUG
0000043E                           886mm     ENDC
0000043E                           887mm 
0000043E                           888mm     ENDM
0000043E                           889mm         HEX2BIN D5,D5,A4
0000043E  49FA 0AC2                890mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000442  0405 0030                891mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000446  CABC 000000FF            892mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000044C  1A34 5000                893mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000450                           894mm     ENDM
00000450  8605                     895m         OR.B D5,D3
00000452  5307                     896m         SUB.B #1,D7
00000454                           897m     ENDW
00000454  6098                     898ms     BRA _10000000
00000456                           899ms _10000001
00000456                           900m     
00000456  7A00                     901m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000458  1A03                     902m     MOVE.B D3,D5
0000045A  D483                     903m     ADD.L D3,D2
0000045C                           904m 
0000045C                           905m     ENDM
0000045C                           906  
0000045C                           907      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000045C  B23C 0030                908s     CMP.B   #'0',D1
00000460  6600 002A                909s     BNE.L   _00000002
00000464                           910m         PRINT_CRLF D5,A4
00000464  49FA 0AC7                911m     LEA CRLF(PC),A4
00000468                           912mm     PRINT_STR A4,D5
00000468                           913mm LOOP_50
00000468  0C14 0000                914mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000046C  6700 0016                915mm     BEQ EXIT_50
00000470                           916mmm     PRINT_CHAR (A4)+,D5
00000470                           917mmm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000470                 TRUE      918mmm     IFEQ DEBUG
00000470  1A39 00C00003            919mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000476  0805 0002                920mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000047A  67F4                     921mmm         BEQ WAIT_FOR_READY_51                   ; NO SPACE, CHECK AGAIN
0000047C  13DC 00C00007            922mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000482                           923mmm     ENDC
00000482                           924mmm     
00000482                 FALSE     925mmm     IFNE DEBUG
00000482                           926mmm     ENDC
00000482                           927mmm 
00000482                           928mmm     ENDM
00000482  60E4                     929mm     BRA LOOP_50
00000484                           930mm EXIT_50
00000484                           931mm     ENDM
00000484                           932m     ENDM
00000484  6000 FECC                933          BRA WAIT_FOR_SRECORD
00000488                           934      ELSE
00000488  6000 03DE                935s     BRA _00000003
0000048C                           936s _00000002
0000048C                           937          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
0000048C  B23C 0031                938s     CMP.B   #'1',D1
00000490  6708                     939s     BEQ.S   _00000004
00000492  B23C 0032                940s     CMP.B   #'2',D1
00000496  6600 01F0                941s     BNE.L   _00000005
0000049A                           942s _00000004
0000049A  5783                     943              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000049C                           944      
0000049C  7800                     945              MOVE.L #0,D4                            ; read two bytes of address
0000049E                           946m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
0000049E  1E3C 0002                947m     MOVE.B #2,D7
000004A2                           948m     WHILE.B D7 <GT> 0 DO
000004A2                           949ms _10000002
000004A2  BE38 0000                950ms     CMP.B   0,D7
000004A6  6F00 0062                951ms     BLE _10000003
000004AA  E98C                     952m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004AC                           953mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004AC                           954mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AC                           955mm 
000004AC  1A39 00C00003            956mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004B2  0805 0000                957mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004B6  6700 0010                958mm     BEQ CONTINUE_53                             ; NOTHING, CONTINUE
000004BA                           959mm  
000004BA                           960mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004BA                 TRUE      961mmm     IFEQ DEBUG
000004BA  1A39 00C00007            962mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C0                           963mmm     ENDC
000004C0                 FALSE     964mmm     IFNE DEBUG
000004C0                           965mmm     ENDC
000004C0                           966mmm      
000004C0  BA3C 001B                967mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004C4  6700 FB42                968mmm     BEQ START
000004C8                           969mmm     ENDM
000004C8                           970mm CONTINUE_53
000004C8  1A39 00C00013            971mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004CE  0805 0000                972mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004D2  67D8                     973mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D4                           974mm     
000004D4  1A39 00C00017            975mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004DA  13C5 00E00001            976mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E0                           977mm     
000004E0                           978mm     ENDM
000004E0                           979mm         PRINT_CHAR D5,D6
000004E0                           980mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E0                 TRUE      981mm     IFEQ DEBUG
000004E0  1C39 00C00003            982mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004E6  0806 0002                983mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004EA  67F4                     984mm         BEQ WAIT_FOR_READY_55                   ; NO SPACE, CHECK AGAIN
000004EC  13C5 00C00007            985mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004F2                           986mm     ENDC
000004F2                           987mm     
000004F2                 FALSE     988mm     IFNE DEBUG
000004F2                           989mm     ENDC
000004F2                           990mm 
000004F2                           991mm     ENDM
000004F2                           992mm         HEX2BIN D5,D5,A4
000004F2  49FA 0A0E                993mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004F6  0405 0030                994mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004FA  CABC 000000FF            995mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000500  1A34 5000                996mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000504                           997mm     ENDM
00000504  8805                     998m         OR.B D5,D4
00000506  5307                     999m         SUB.B #1,D7
00000508                          1000m     ENDW
00000508  6098                    1001ms     BRA _10000002
0000050A                          1002ms _10000003
0000050A                          1003m     
0000050A  7A00                    1004m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000050C  1A04                    1005m     MOVE.B D4,D5
0000050E  D484                    1006m     ADD.L D4,D2
00000510                          1007m 
00000510                          1008m     ENDM
00000510                          1009m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000510  1E3C 0002               1010m     MOVE.B #2,D7
00000514                          1011m     WHILE.B D7 <GT> 0 DO
00000514                          1012ms _10000004
00000514  BE38 0000               1013ms     CMP.B   0,D7
00000518  6F00 0062               1014ms     BLE _10000005
0000051C  E98C                    1015m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000051E                          1016mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000051E                          1017mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000051E                          1018mm 
0000051E  1A39 00C00003           1019mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000524  0805 0000               1020mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000528  6700 0010               1021mm     BEQ CONTINUE_58                             ; NOTHING, CONTINUE
0000052C                          1022mm  
0000052C                          1023mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000052C                 TRUE     1024mmm     IFEQ DEBUG
0000052C  1A39 00C00007           1025mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000532                          1026mmm     ENDC
00000532                 FALSE    1027mmm     IFNE DEBUG
00000532                          1028mmm     ENDC
00000532                          1029mmm      
00000532  BA3C 001B               1030mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000536  6700 FAD0               1031mmm     BEQ START
0000053A                          1032mmm     ENDM
0000053A                          1033mm CONTINUE_58
0000053A  1A39 00C00013           1034mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000540  0805 0000               1035mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000544  67D8                    1036mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000546                          1037mm     
00000546  1A39 00C00017           1038mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000054C  13C5 00E00001           1039mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000552                          1040mm     
00000552                          1041mm     ENDM
00000552                          1042mm         PRINT_CHAR D5,D6
00000552                          1043mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000552                 TRUE     1044mm     IFEQ DEBUG
00000552  1C39 00C00003           1045mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000558  0806 0002               1046mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000055C  67F4                    1047mm         BEQ WAIT_FOR_READY_60                   ; NO SPACE, CHECK AGAIN
0000055E  13C5 00C00007           1048mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000564                          1049mm     ENDC
00000564                          1050mm     
00000564                 FALSE    1051mm     IFNE DEBUG
00000564                          1052mm     ENDC
00000564                          1053mm 
00000564                          1054mm     ENDM
00000564                          1055mm         HEX2BIN D5,D5,A4
00000564  49FA 099C               1056mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000568  0405 0030               1057mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000056C  CABC 000000FF           1058mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000572  1A34 5000               1059mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000576                          1060mm     ENDM
00000576  8805                    1061m         OR.B D5,D4
00000578  5307                    1062m         SUB.B #1,D7
0000057A                          1063m     ENDW
0000057A  6098                    1064ms     BRA _10000004
0000057C                          1065ms _10000005
0000057C                          1066m     
0000057C  7A00                    1067m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000057E  1A04                    1068m     MOVE.B D4,D5
00000580  D484                    1069m     ADD.L D4,D2
00000582                          1070m 
00000582                          1071m     ENDM
00000582                          1072              
00000582                          1073              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000582  B23C 0032               1074s     CMP.B   #'2',D1
00000586  6600 0076               1075s     BNE.L   _00000006
0000058A  5383                    1076                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000058C                          1077m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
0000058C  1E3C 0002               1078m     MOVE.B #2,D7
00000590                          1079m     WHILE.B D7 <GT> 0 DO
00000590                          1080ms _10000006
00000590  BE38 0000               1081ms     CMP.B   0,D7
00000594  6F00 0062               1082ms     BLE _10000007
00000598  E98C                    1083m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000059A                          1084mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000059A                          1085mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059A                          1086mm 
0000059A  1A39 00C00003           1087mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005A0  0805 0000               1088mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005A4  6700 0010               1089mm     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
000005A8                          1090mm  
000005A8                          1091mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005A8                 TRUE     1092mmm     IFEQ DEBUG
000005A8  1A39 00C00007           1093mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005AE                          1094mmm     ENDC
000005AE                 FALSE    1095mmm     IFNE DEBUG
000005AE                          1096mmm     ENDC
000005AE                          1097mmm      
000005AE  BA3C 001B               1098mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005B2  6700 FA54               1099mmm     BEQ START
000005B6                          1100mmm     ENDM
000005B6                          1101mm CONTINUE_63
000005B6  1A39 00C00013           1102mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005BC  0805 0000               1103mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005C0  67D8                    1104mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005C2                          1105mm     
000005C2  1A39 00C00017           1106mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005C8  13C5 00E00001           1107mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005CE                          1108mm     
000005CE                          1109mm     ENDM
000005CE                          1110mm         PRINT_CHAR D5,D6
000005CE                          1111mm WAIT_FOR_READY_65                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1112mm     IFEQ DEBUG
000005CE  1C39 00C00003           1113mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005D4  0806 0002               1114mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1115mm         BEQ WAIT_FOR_READY_65                   ; NO SPACE, CHECK AGAIN
000005DA  13C5 00C00007           1116mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005E0                          1117mm     ENDC
000005E0                          1118mm     
000005E0                 FALSE    1119mm     IFNE DEBUG
000005E0                          1120mm     ENDC
000005E0                          1121mm 
000005E0                          1122mm     ENDM
000005E0                          1123mm         HEX2BIN D5,D5,A4
000005E0  49FA 0920               1124mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005E4  0405 0030               1125mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005E8  CABC 000000FF           1126mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005EE  1A34 5000               1127mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005F2                          1128mm     ENDM
000005F2  8805                    1129m         OR.B D5,D4
000005F4  5307                    1130m         SUB.B #1,D7
000005F6                          1131m     ENDW
000005F6  6098                    1132ms     BRA _10000006
000005F8                          1133ms _10000007
000005F8                          1134m     
000005F8  7A00                    1135m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005FA  1A04                    1136m     MOVE.B D4,D5
000005FC  D484                    1137m     ADD.L D4,D2
000005FE                          1138m 
000005FE                          1139m     ENDM
000005FE                          1140              ENDI
000005FE                          1141s _00000006
000005FE                          1142              
000005FE  2444                    1143                  MOVE.L D4,A2                            ; put the address in an address register
00000600  D5C9                    1144              ADD.L A1,A2                             ; add in the offset
00000602                          1145  
00000602                          1146              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
00000602                          1147s _10000008
00000602  B63C 0000               1148s     CMP.B   #0,D3
00000606  6F00 007A               1149s     BLE _10000009
0000060A                          1150m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
0000060A  1E3C 0002               1151m     MOVE.B #2,D7
0000060E                          1152m     WHILE.B D7 <GT> 0 DO
0000060E                          1153ms _1000000A
0000060E  BE38 0000               1154ms     CMP.B   0,D7
00000612  6F00 0062               1155ms     BLE _1000000B
00000616  E989                    1156m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000618                          1157mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000618                          1158mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000618                          1159mm 
00000618  1A39 00C00003           1160mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000061E  0805 0000               1161mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000622  6700 0010               1162mm     BEQ CONTINUE_68                             ; NOTHING, CONTINUE
00000626                          1163mm  
00000626                          1164mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000626                 TRUE     1165mmm     IFEQ DEBUG
00000626  1A39 00C00007           1166mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000062C                          1167mmm     ENDC
0000062C                 FALSE    1168mmm     IFNE DEBUG
0000062C                          1169mmm     ENDC
0000062C                          1170mmm      
0000062C  BA3C 001B               1171mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000630  6700 F9D6               1172mmm     BEQ START
00000634                          1173mmm     ENDM
00000634                          1174mm CONTINUE_68
00000634  1A39 00C00013           1175mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000063A  0805 0000               1176mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000063E  67D8                    1177mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
00000640                          1178mm     
00000640  1A39 00C00017           1179mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000646  13C5 00E00001           1180mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000064C                          1181mm     
0000064C                          1182mm     ENDM
0000064C                          1183mm         PRINT_CHAR D5,D6
0000064C                          1184mm WAIT_FOR_READY_70                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000064C                 TRUE     1185mm     IFEQ DEBUG
0000064C  1C39 00C00003           1186mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000652  0806 0002               1187mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000656  67F4                    1188mm         BEQ WAIT_FOR_READY_70                   ; NO SPACE, CHECK AGAIN
00000658  13C5 00C00007           1189mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000065E                          1190mm     ENDC
0000065E                          1191mm     
0000065E                 FALSE    1192mm     IFNE DEBUG
0000065E                          1193mm     ENDC
0000065E                          1194mm 
0000065E                          1195mm     ENDM
0000065E                          1196mm         HEX2BIN D5,D5,A4
0000065E  49FA 08A2               1197mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000662  0405 0030               1198mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000666  CABC 000000FF           1199mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000066C  1A34 5000               1200mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000670                          1201mm     ENDM
00000670  8205                    1202m         OR.B D5,D1
00000672  5307                    1203m         SUB.B #1,D7
00000674                          1204m     ENDW
00000674  6098                    1205ms     BRA _1000000A
00000676                          1206ms _1000000B
00000676                          1207m     
00000676  7A00                    1208m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000678  1A01                    1209m     MOVE.B D1,D5
0000067A  D481                    1210m     ADD.L D1,D2
0000067C                          1211m 
0000067C                          1212m     ENDM
0000067C                          1213                          
0000067C  14C1                    1214                  MOVE.B D1,(A2)+                     ; store it!
0000067E                          1215  
0000067E  5303                    1216                  SUB.B #1,D3                      ; 1 less byte to go
00000680                          1217              ENDW
00000680  6080                    1218s     BRA _10000008
00000682                          1219s _10000009
00000682                          1220          
00000682  7200                    1221              MOVE.L #0,D1                         ; not done yet
00000684                          1222          ELSE
00000684  6000 01E2               1223s     BRA _00000007
00000688                          1224s _00000005
00000688                          1225              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000688  B23C 0038               1226s     CMP.B   #'8',D1
0000068C  6600 0164               1227s     BNE.L   _00000008
00000690  7800                    1228                  MOVE.L #0,D4                    ; read the 24 bit start address
00000692                          1229m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
00000692  1E3C 0002               1230m     MOVE.B #2,D7
00000696                          1231m     WHILE.B D7 <GT> 0 DO
00000696                          1232ms _1000000C
00000696  BE38 0000               1233ms     CMP.B   0,D7
0000069A  6F00 0062               1234ms     BLE _1000000D
0000069E  E98C                    1235m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006A0                          1236mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006A0                          1237mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A0                          1238mm 
000006A0  1A39 00C00003           1239mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006A6  0805 0000               1240mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006AA  6700 0010               1241mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
000006AE                          1242mm  
000006AE                          1243mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006AE                 TRUE     1244mmm     IFEQ DEBUG
000006AE  1A39 00C00007           1245mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006B4                          1246mmm     ENDC
000006B4                 FALSE    1247mmm     IFNE DEBUG
000006B4                          1248mmm     ENDC
000006B4                          1249mmm      
000006B4  BA3C 001B               1250mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006B8  6700 F94E               1251mmm     BEQ START
000006BC                          1252mmm     ENDM
000006BC                          1253mm CONTINUE_73
000006BC  1A39 00C00013           1254mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006C2  0805 0000               1255mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C6  67D8                    1256mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
000006C8                          1257mm     
000006C8  1A39 00C00017           1258mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006CE  13C5 00E00001           1259mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006D4                          1260mm     
000006D4                          1261mm     ENDM
000006D4                          1262mm         PRINT_CHAR D5,D6
000006D4                          1263mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D4                 TRUE     1264mm     IFEQ DEBUG
000006D4  1C39 00C00003           1265mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006DA  0806 0002               1266mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006DE  67F4                    1267mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
000006E0  13C5 00C00007           1268mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006E6                          1269mm     ENDC
000006E6                          1270mm     
000006E6                 FALSE    1271mm     IFNE DEBUG
000006E6                          1272mm     ENDC
000006E6                          1273mm 
000006E6                          1274mm     ENDM
000006E6                          1275mm         HEX2BIN D5,D5,A4
000006E6  49FA 081A               1276mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006EA  0405 0030               1277mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006EE  CABC 000000FF           1278mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006F4  1A34 5000               1279mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006F8                          1280mm     ENDM
000006F8  8805                    1281m         OR.B D5,D4
000006FA  5307                    1282m         SUB.B #1,D7
000006FC                          1283m     ENDW
000006FC  6098                    1284ms     BRA _1000000C
000006FE                          1285ms _1000000D
000006FE                          1286m     
000006FE  7A00                    1287m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000700  1A04                    1288m     MOVE.B D4,D5
00000702  D484                    1289m     ADD.L D4,D2
00000704                          1290m 
00000704                          1291m     ENDM
00000704                          1292m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000704  1E3C 0002               1293m     MOVE.B #2,D7
00000708                          1294m     WHILE.B D7 <GT> 0 DO
00000708                          1295ms _1000000E
00000708  BE38 0000               1296ms     CMP.B   0,D7
0000070C  6F00 0062               1297ms     BLE _1000000F
00000710  E98C                    1298m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000712                          1299mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000712                          1300mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                          1301mm 
00000712  1A39 00C00003           1302mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000718  0805 0000               1303mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000071C  6700 0010               1304mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
00000720                          1305mm  
00000720                          1306mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000720                 TRUE     1307mmm     IFEQ DEBUG
00000720  1A39 00C00007           1308mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000726                          1309mmm     ENDC
00000726                 FALSE    1310mmm     IFNE DEBUG
00000726                          1311mmm     ENDC
00000726                          1312mmm      
00000726  BA3C 001B               1313mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000072A  6700 F8DC               1314mmm     BEQ START
0000072E                          1315mmm     ENDM
0000072E                          1316mm CONTINUE_78
0000072E  1A39 00C00013           1317mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000734  0805 0000               1318mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000738  67D8                    1319mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
0000073A                          1320mm     
0000073A  1A39 00C00017           1321mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000740  13C5 00E00001           1322mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000746                          1323mm     
00000746                          1324mm     ENDM
00000746                          1325mm         PRINT_CHAR D5,D6
00000746                          1326mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000746                 TRUE     1327mm     IFEQ DEBUG
00000746  1C39 00C00003           1328mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000074C  0806 0002               1329mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000750  67F4                    1330mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
00000752  13C5 00C00007           1331mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000758                          1332mm     ENDC
00000758                          1333mm     
00000758                 FALSE    1334mm     IFNE DEBUG
00000758                          1335mm     ENDC
00000758                          1336mm 
00000758                          1337mm     ENDM
00000758                          1338mm         HEX2BIN D5,D5,A4
00000758  49FA 07A8               1339mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000075C  0405 0030               1340mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000760  CABC 000000FF           1341mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000766  1A34 5000               1342mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000076A                          1343mm     ENDM
0000076A  8805                    1344m         OR.B D5,D4
0000076C  5307                    1345m         SUB.B #1,D7
0000076E                          1346m     ENDW
0000076E  6098                    1347ms     BRA _1000000E
00000770                          1348ms _1000000F
00000770                          1349m     
00000770  7A00                    1350m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000772  1A04                    1351m     MOVE.B D4,D5
00000774  D484                    1352m     ADD.L D4,D2
00000776                          1353m 
00000776                          1354m     ENDM
00000776                          1355m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000776  1E3C 0002               1356m     MOVE.B #2,D7
0000077A                          1357m     WHILE.B D7 <GT> 0 DO
0000077A                          1358ms _10000010
0000077A  BE38 0000               1359ms     CMP.B   0,D7
0000077E  6F00 0062               1360ms     BLE _10000011
00000782  E98C                    1361m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000784                          1362mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000784                          1363mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                          1364mm 
00000784  1A39 00C00003           1365mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000078A  0805 0000               1366mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000078E  6700 0010               1367mm     BEQ CONTINUE_83                             ; NOTHING, CONTINUE
00000792                          1368mm  
00000792                          1369mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000792                 TRUE     1370mmm     IFEQ DEBUG
00000792  1A39 00C00007           1371mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000798                          1372mmm     ENDC
00000798                 FALSE    1373mmm     IFNE DEBUG
00000798                          1374mmm     ENDC
00000798                          1375mmm      
00000798  BA3C 001B               1376mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000079C  6700 F86A               1377mmm     BEQ START
000007A0                          1378mmm     ENDM
000007A0                          1379mm CONTINUE_83
000007A0  1A39 00C00013           1380mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007A6  0805 0000               1381mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007AA  67D8                    1382mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
000007AC                          1383mm     
000007AC  1A39 00C00017           1384mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007B2  13C5 00E00001           1385mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007B8                          1386mm     
000007B8                          1387mm     ENDM
000007B8                          1388mm         PRINT_CHAR D5,D6
000007B8                          1389mm WAIT_FOR_READY_85                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007B8                 TRUE     1390mm     IFEQ DEBUG
000007B8  1C39 00C00003           1391mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007BE  0806 0002               1392mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007C2  67F4                    1393mm         BEQ WAIT_FOR_READY_85                   ; NO SPACE, CHECK AGAIN
000007C4  13C5 00C00007           1394mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007CA                          1395mm     ENDC
000007CA                          1396mm     
000007CA                 FALSE    1397mm     IFNE DEBUG
000007CA                          1398mm     ENDC
000007CA                          1399mm 
000007CA                          1400mm     ENDM
000007CA                          1401mm         HEX2BIN D5,D5,A4
000007CA  49FA 0736               1402mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007CE  0405 0030               1403mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007D2  CABC 000000FF           1404mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007D8  1A34 5000               1405mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007DC                          1406mm     ENDM
000007DC  8805                    1407m         OR.B D5,D4
000007DE  5307                    1408m         SUB.B #1,D7
000007E0                          1409m     ENDW
000007E0  6098                    1410ms     BRA _10000010
000007E2                          1411ms _10000011
000007E2                          1412m     
000007E2  7A00                    1413m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007E4  1A04                    1414m     MOVE.B D4,D5
000007E6  D484                    1415m     ADD.L D4,D2
000007E8                          1416m 
000007E8                          1417m     ENDM
000007E8                          1418                            
000007E8  2044                    1419                  MOVE.L D4,A0                    ; start address -> A0
000007EA  D1C9                    1420                  ADD.L A1,A0                         ; add in the offset
000007EC                          1421  
000007EC  72FF                    1422                  MOVE.L #$FFFFFFFF,D1             ; done
000007EE                          1423              ELSE
000007EE  6000 0078               1424s     BRA _00000009
000007F2                          1425s _00000008
000007F2                          1426m                 PRINT_CRLF D5,A4
000007F2  49FA 0739               1427m     LEA CRLF(PC),A4
000007F6                          1428mm     PRINT_STR A4,D5
000007F6                          1429mm LOOP_88
000007F6  0C14 0000               1430mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000007FA  6700 0016               1431mm     BEQ EXIT_88
000007FE                          1432mmm     PRINT_CHAR (A4)+,D5
000007FE                          1433mmm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FE                 TRUE     1434mmm     IFEQ DEBUG
000007FE  1A39 00C00003           1435mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000804  0805 0002               1436mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000808  67F4                    1437mmm         BEQ WAIT_FOR_READY_89                   ; NO SPACE, CHECK AGAIN
0000080A  13DC 00C00007           1438mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000810                          1439mmm     ENDC
00000810                          1440mmm     
00000810                 FALSE    1441mmm     IFNE DEBUG
00000810                          1442mmm     ENDC
00000810                          1443mmm 
00000810                          1444mmm     ENDM
00000810  60E4                    1445mm     BRA LOOP_88
00000812                          1446mm EXIT_88
00000812                          1447mm     ENDM
00000812                          1448m     ENDM
00000812                          1449              
00000812  49FA 06A3               1450                  LEA UNREC(PC),A4                ; warn for unrecognised type
00000816                          1451m                 PRINT_STR A4,D5
00000816                          1452m LOOP_90
00000816  0C14 0000               1453m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000081A  6700 0016               1454m     BEQ EXIT_90
0000081E                          1455mm     PRINT_CHAR (A4)+,D5
0000081E                          1456mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000081E                 TRUE     1457mm     IFEQ DEBUG
0000081E  1A39 00C00003           1458mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000824  0805 0002               1459mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000828  67F4                    1460mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0000082A  13DC 00C00007           1461mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000830                          1462mm     ENDC
00000830                          1463mm     
00000830                 FALSE    1464mm     IFNE DEBUG
00000830                          1465mm     ENDC
00000830                          1466mm 
00000830                          1467mm     ENDM
00000830  60E4                    1468m     BRA LOOP_90
00000832                          1469m EXIT_90
00000832                          1470m     ENDM
00000832                          1471m                 PRINT_CHAR D1,D5
00000832                          1472m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000832                 TRUE     1473m     IFEQ DEBUG
00000832  1A39 00C00003           1474m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000838  0805 0002               1475m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000083C  67F4                    1476m         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
0000083E  13C1 00C00007           1477m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000844                          1478m     ENDC
00000844                          1479m     
00000844                 FALSE    1480m     IFNE DEBUG
00000844                          1481m     ENDC
00000844                          1482m 
00000844                          1483m     ENDM
00000844                          1484m                 PRINT_CRLF D5,A4
00000844  49FA 06E7               1485m     LEA CRLF(PC),A4
00000848                          1486mm     PRINT_STR A4,D5
00000848                          1487mm LOOP_94
00000848  0C14 0000               1488mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000084C  6700 0016               1489mm     BEQ EXIT_94
00000850                          1490mmm     PRINT_CHAR (A4)+,D5
00000850                          1491mmm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000850                 TRUE     1492mmm     IFEQ DEBUG
00000850  1A39 00C00003           1493mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000856  0805 0002               1494mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000085A  67F4                    1495mmm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0000085C  13DC 00C00007           1496mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000862                          1497mmm     ENDC
00000862                          1498mmm     
00000862                 FALSE    1499mmm     IFNE DEBUG
00000862                          1500mmm     ENDC
00000862                          1501mmm 
00000862                          1502mmm     ENDM
00000862  60E4                    1503mm     BRA LOOP_94
00000864                          1504mm EXIT_94
00000864                          1505mm     ENDM
00000864                          1506m     ENDM
00000864                          1507              
00000864  6000 FAEC               1508                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000868                          1509              ENDI
00000868                          1510s _00000009
00000868                          1511          ENDI
00000868                          1512s _00000007
00000868                          1513      ENDI
00000868                          1514s _00000003
00000868                          1515      
00000868                          1516m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000868  1E3C 0002               1517m     MOVE.B #2,D7
0000086C                          1518m     WHILE.B D7 <GT> 0 DO
0000086C                          1519ms _10000012
0000086C  BE38 0000               1520ms     CMP.B   0,D7
00000870  6F00 0062               1521ms     BLE _10000013
00000874  E98C                    1522m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000876                          1523mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000876                          1524mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000876                          1525mm 
00000876  1A39 00C00003           1526mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000087C  0805 0000               1527mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000880  6700 0010               1528mm     BEQ CONTINUE_97                             ; NOTHING, CONTINUE
00000884                          1529mm  
00000884                          1530mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000884                 TRUE     1531mmm     IFEQ DEBUG
00000884  1A39 00C00007           1532mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000088A                          1533mmm     ENDC
0000088A                 FALSE    1534mmm     IFNE DEBUG
0000088A                          1535mmm     ENDC
0000088A                          1536mmm      
0000088A  BA3C 001B               1537mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000088E  6700 F778               1538mmm     BEQ START
00000892                          1539mmm     ENDM
00000892                          1540mm CONTINUE_97
00000892  1A39 00C00013           1541mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000898  0805 0000               1542mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000089C  67D8                    1543mm     BEQ WAIT_FOR_READY_97                           ; NOTHING, CHECK AGAIN
0000089E                          1544mm     
0000089E  1A39 00C00017           1545mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008A4  13C5 00E00001           1546mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008AA                          1547mm     
000008AA                          1548mm     ENDM
000008AA                          1549mm         PRINT_CHAR D5,D6
000008AA                          1550mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AA                 TRUE     1551mm     IFEQ DEBUG
000008AA  1C39 00C00003           1552mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008B0  0806 0002               1553mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008B4  67F4                    1554mm         BEQ WAIT_FOR_READY_99                   ; NO SPACE, CHECK AGAIN
000008B6  13C5 00C00007           1555mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008BC                          1556mm     ENDC
000008BC                          1557mm     
000008BC                 FALSE    1558mm     IFNE DEBUG
000008BC                          1559mm     ENDC
000008BC                          1560mm 
000008BC                          1561mm     ENDM
000008BC                          1562mm         HEX2BIN D5,D5,A4
000008BC  49FA 0644               1563mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008C0  0405 0030               1564mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008C4  CABC 000000FF           1565mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008CA  1A34 5000               1566mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008CE                          1567mm     ENDM
000008CE  8805                    1568m         OR.B D5,D4
000008D0  5307                    1569m         SUB.B #1,D7
000008D2                          1570m     ENDW
000008D2  6098                    1571ms     BRA _10000012
000008D4                          1572ms _10000013
000008D4                          1573m     
000008D4  7A00                    1574m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008D6  1A04                    1575m     MOVE.B D4,D5
000008D8  D484                    1576m     ADD.L D4,D2
000008DA                          1577m 
000008DA                          1578m     ENDM
000008DA                          1579m     PRINT_CRLF D5,A4
000008DA  49FA 0651               1580m     LEA CRLF(PC),A4
000008DE                          1581mm     PRINT_STR A4,D5
000008DE                          1582mm LOOP_102
000008DE  0C14 0000               1583mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008E2  6700 0016               1584mm     BEQ EXIT_102
000008E6                          1585mmm     PRINT_CHAR (A4)+,D5
000008E6                          1586mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1587mmm     IFEQ DEBUG
000008E6  1A39 00C00003           1588mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008EC  0805 0002               1589mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1590mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
000008F2  13DC 00C00007           1591mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008F8                          1592mmm     ENDC
000008F8                          1593mmm     
000008F8                 FALSE    1594mmm     IFNE DEBUG
000008F8                          1595mmm     ENDC
000008F8                          1596mmm 
000008F8                          1597mmm     ENDM
000008F8  60E4                    1598mm     BRA LOOP_102
000008FA                          1599mm EXIT_102
000008FA                          1600mm     ENDM
000008FA                          1601m     ENDM
000008FA                          1602          
000008FA                          1603      IF.B D2 <NE> #$FF THEN.L
000008FA  B43C 00FF               1604s     CMP.B   #$FF,D2
000008FE  6700 0090               1605s     BEQ.L   _0000000A
00000902  49FA 05CA               1606          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
00000906                          1607m         PRINT_STR A4,D5
00000906                          1608m LOOP_104
00000906  0C14 0000               1609m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000090A  6700 0016               1610m     BEQ EXIT_104
0000090E                          1611mm     PRINT_CHAR (A4)+,D5
0000090E                          1612mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090E                 TRUE     1613mm     IFEQ DEBUG
0000090E  1A39 00C00003           1614mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000914  0805 0002               1615mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000918  67F4                    1616mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
0000091A  13DC 00C00007           1617mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000920                          1618mm     ENDC
00000920                          1619mm     
00000920                 FALSE    1620mm     IFNE DEBUG
00000920                          1621mm     ENDC
00000920                          1622mm 
00000920                          1623mm     ENDM
00000920  60E4                    1624m     BRA LOOP_104
00000922                          1625m EXIT_104
00000922                          1626m     ENDM
00000922                          1627m         PRINT_REG D0,D5,D2,D6,A4
00000922  49FA 060F               1628m     LEA OX(PC),A4
00000926                          1629mm     PRINT_STR A4,D5
00000926                          1630mm LOOP_107
00000926  0C14 0000               1631mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000092A  6700 0016               1632mm     BEQ EXIT_107
0000092E                          1633mmm     PRINT_CHAR (A4)+,D5
0000092E                          1634mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092E                 TRUE     1635mmm     IFEQ DEBUG
0000092E  1A39 00C00003           1636mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000934  0805 0002               1637mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000938  67F4                    1638mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
0000093A  13DC 00C00007           1639mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000940                          1640mmm     ENDC
00000940                          1641mmm     
00000940                 FALSE    1642mmm     IFNE DEBUG
00000940                          1643mmm     ENDC
00000940                          1644mmm 
00000940                          1645mmm     ENDM
00000940  60E4                    1646mm     BRA LOOP_107
00000942                          1647mm EXIT_107
00000942                          1648mm     ENDM
00000942  7C07                    1649m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000944                          1650m LOOP_106
00000944                          1651mm     BIN2HEX D0,D2,A4
00000944  49FA 05AC               1652mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
00000948  E998                    1653mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000094A  1400                    1654mm     MOVE.B D0,D2
0000094C  0282 0000000F           1655mm     ANDI.L #$F,D2
00000952  1434 2000               1656mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000956                          1657mm     ENDM
00000956                          1658mm     PRINT_CHAR D2,D5
00000956                          1659mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000956                 TRUE     1660mm     IFEQ DEBUG
00000956  1A39 00C00003           1661mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000095C  0805 0002               1662mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000960  67F4                    1663mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00000962  13C2 00C00007           1664mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000968                          1665mm     ENDC
00000968                          1666mm     
00000968                 FALSE    1667mm     IFNE DEBUG
00000968                          1668mm     ENDC
00000968                          1669mm 
00000968                          1670mm     ENDM
00000968  57CE FFDA               1671m     DBEQ D6,LOOP_106
0000096C                          1672m     ENDM
0000096C                          1673m         PRINT_CRLF D5,A4
0000096C  49FA 05BF               1674m     LEA CRLF(PC),A4
00000970                          1675mm     PRINT_STR A4,D5
00000970                          1676mm LOOP_112
00000970  0C14 0000               1677mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000974  6700 0016               1678mm     BEQ EXIT_112
00000978                          1679mmm     PRINT_CHAR (A4)+,D5
00000978                          1680mmm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000978                 TRUE     1681mmm     IFEQ DEBUG
00000978  1A39 00C00003           1682mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000097E  0805 0002               1683mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000982  67F4                    1684mmm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000984  13DC 00C00007           1685mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000098A                          1686mmm     ENDC
0000098A                          1687mmm     
0000098A                 FALSE    1688mmm     IFNE DEBUG
0000098A                          1689mmm     ENDC
0000098A                          1690mmm 
0000098A                          1691mmm     ENDM
0000098A  60E4                    1692mm     BRA LOOP_112
0000098C                          1693mm EXIT_112
0000098C                          1694mm     ENDM
0000098C                          1695m     ENDM
0000098C  6000 F7B0               1696          BRA MAIN_LOOP
00000990                          1697      ENDI
00000990                          1698s _0000000A
00000990                          1699      
00000990                          1700      IF D1 <EQ> #0 THEN
00000990  B27C 0000               1701s     CMP.W   #0,D1
00000994  6600 0006               1702s     BNE _0000000B
00000998  6000 F9B8               1703        BRA WAIT_FOR_SRECORD            
0000099C                          1704      ENDI
0000099C                          1705s _0000000B
0000099C                          1706  DOWNLOAD_DONE
0000099C                          1707m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
0000099C  43FA 0595               1708m     LEA OX(PC),A1
000009A0                          1709mm     PRINT_STR A1,D5
000009A0                          1710mm LOOP_115
000009A0  0C11 0000               1711mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009A4  6700 0016               1712mm     BEQ EXIT_115
000009A8                          1713mmm     PRINT_CHAR (A1)+,D5
000009A8                          1714mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A8                 TRUE     1715mmm     IFEQ DEBUG
000009A8  1A39 00C00003           1716mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009AE  0805 0002               1717mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009B2  67F4                    1718mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009B4  13D9 00C00007           1719mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009BA                          1720mmm     ENDC
000009BA                          1721mmm     
000009BA                 FALSE    1722mmm     IFNE DEBUG
000009BA                          1723mmm     ENDC
000009BA                          1724mmm 
000009BA                          1725mmm     ENDM
000009BA  60E4                    1726mm     BRA LOOP_115
000009BC                          1727mm EXIT_115
000009BC                          1728mm     ENDM
000009BC  7407                    1729m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009BE                          1730m LOOP_114
000009BE                          1731mm     BIN2HEX D0,D6,A1
000009BE  43FA 0532               1732mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009C2  E998                    1733mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009C4  1C00                    1734mm     MOVE.B D0,D6
000009C6  0286 0000000F           1735mm     ANDI.L #$F,D6
000009CC  1C31 6000               1736mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009D0                          1737mm     ENDM
000009D0                          1738mm     PRINT_CHAR D6,D5
000009D0                          1739mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D0                 TRUE     1740mm     IFEQ DEBUG
000009D0  1A39 00C00003           1741mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009D6  0805 0002               1742mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009DA  67F4                    1743mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
000009DC  13C6 00C00007           1744mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009E2                          1745mm     ENDC
000009E2                          1746mm     
000009E2                 FALSE    1747mm     IFNE DEBUG
000009E2                          1748mm     ENDC
000009E2                          1749mm 
000009E2                          1750mm     ENDM
000009E2  57CA FFDA               1751m     DBEQ D2,LOOP_114
000009E6                          1752m     ENDM
000009E6  43FA 04AD               1753      LEA READ(PC),A1
000009EA                          1754m     PRINT_STR A1,D5
000009EA                          1755m LOOP_119
000009EA  0C11 0000               1756m     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009EE  6700 0016               1757m     BEQ EXIT_119
000009F2                          1758mm     PRINT_CHAR (A1)+,D5
000009F2                          1759mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F2                 TRUE     1760mm     IFEQ DEBUG
000009F2  1A39 00C00003           1761mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009F8  0805 0002               1762mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009FC  67F4                    1763mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
000009FE  13D9 00C00007           1764mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A04                          1765mm     ENDC
00000A04                          1766mm     
00000A04                 FALSE    1767mm     IFNE DEBUG
00000A04                          1768mm     ENDC
00000A04                          1769mm 
00000A04                          1770mm     ENDM
00000A04  60E4                    1771m     BRA LOOP_119
00000A06                          1772m EXIT_119
00000A06                          1773m     ENDM
00000A06  2E08                    1774      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A08                          1775m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A08  43FA 0529               1776m     LEA OX(PC),A1
00000A0C                          1777mm     PRINT_STR A1,D5
00000A0C                          1778mm LOOP_122
00000A0C  0C11 0000               1779mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A10  6700 0016               1780mm     BEQ EXIT_122
00000A14                          1781mmm     PRINT_CHAR (A1)+,D5
00000A14                          1782mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A14                 TRUE     1783mmm     IFEQ DEBUG
00000A14  1A39 00C00003           1784mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A1A  0805 0002               1785mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A1E  67F4                    1786mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A20  13D9 00C00007           1787mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A26                          1788mmm     ENDC
00000A26                          1789mmm     
00000A26                 FALSE    1790mmm     IFNE DEBUG
00000A26                          1791mmm     ENDC
00000A26                          1792mmm 
00000A26                          1793mmm     ENDM
00000A26  60E4                    1794mm     BRA LOOP_122
00000A28                          1795mm EXIT_122
00000A28                          1796mm     ENDM
00000A28  7407                    1797m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A2A                          1798m LOOP_121
00000A2A                          1799mm     BIN2HEX D7,D6,A1
00000A2A  43FA 04C6               1800mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A2E  E99F                    1801mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A30  1C07                    1802mm     MOVE.B D7,D6
00000A32  0286 0000000F           1803mm     ANDI.L #$F,D6
00000A38  1C31 6000               1804mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A3C                          1805mm     ENDM
00000A3C                          1806mm     PRINT_CHAR D6,D5
00000A3C                          1807mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A3C                 TRUE     1808mm     IFEQ DEBUG
00000A3C  1A39 00C00003           1809mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A42  0805 0002               1810mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A46  67F4                    1811mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000A48  13C6 00C00007           1812mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A4E                          1813mm     ENDC
00000A4E                          1814mm     
00000A4E                 FALSE    1815mm     IFNE DEBUG
00000A4E                          1816mm     ENDC
00000A4E                          1817mm 
00000A4E                          1818mm     ENDM
00000A4E  57CA FFDA               1819m     DBEQ D2,LOOP_121
00000A52                          1820m     ENDM
00000A52                          1821m     PRINT_CRLF D5,A4     
00000A52  49FA 04D9               1822m     LEA CRLF(PC),A4
00000A56                          1823mm     PRINT_STR A4,D5
00000A56                          1824mm LOOP_127
00000A56  0C14 0000               1825mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A5A  6700 0016               1826mm     BEQ EXIT_127
00000A5E                          1827mmm     PRINT_CHAR (A4)+,D5
00000A5E                          1828mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5E                 TRUE     1829mmm     IFEQ DEBUG
00000A5E  1A39 00C00003           1830mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A64  0805 0002               1831mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A68  67F4                    1832mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A6A  13DC 00C00007           1833mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A70                          1834mmm     ENDC
00000A70                          1835mmm     
00000A70                 FALSE    1836mmm     IFNE DEBUG
00000A70                          1837mmm     ENDC
00000A70                          1838mmm 
00000A70                          1839mmm     ENDM
00000A70  60E4                    1840mm     BRA LOOP_127
00000A72                          1841mm EXIT_127
00000A72                          1842mm     ENDM
00000A72                          1843m     ENDM
00000A72                          1844          
00000A72  6000 F6CA               1845      BRA MAIN_LOOP
00000A76                          1846      
00000A76                          1847  G
00000A76  2047                    1848      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A78  3E3C 0000               1849      MOVE #0,D7                                      ; clear the now used address accumulator
00000A7C  4ED0                    1850      JMP (A0)                                        ; jump to it!
00000A7E                          1851      
00000A7E                          1852  Z
00000A7E  207C 00200000           1853      MOVE.L #RAM,A0                                  ; address of RAM
00000A84                          1854      
00000A84                          1855      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A84  7000                    1856s     MOVE.L  #0,D0
00000A86  6000 0012               1857s     BRA _20000005
00000A8A                          1858s _20000004
00000A8A  2200                    1859          MOVE.L D0,D1                              ; progress update
00000A8C  E089                    1860          LSR.L #8,D1 
00000A8E  E089                    1861          LSR.L #8,D1
00000A90  13C1 00E00001           1862          MOVE.B D1,DISPLAY
00000A96                          1863  
00000A96  20C0                    1864          MOVE.L D0,(A0)+
00000A98                          1865      ENDF
00000A98  5880                    1866s     ADD.L   #4,D0
00000A9A                          1867s _20000005
00000A9A  B0BC 00040000           1868s     CMP.L   #$40000,D0
00000AA0  6FE8                    1869s     BLE _20000004
00000AA2                          1870   
00000AA2  207C 00200000           1871      MOVE.L #RAM,A0                                    ; address of RAM
00000AA8                          1872     
00000AA8                          1873      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AA8  7000                    1874s     MOVE.L  #0,D0
00000AAA  6000 00A6               1875s     BRA _20000007
00000AAE                          1876s _20000006
00000AAE  2200                    1877          MOVE.L D0,D1                              ; progress update
00000AB0  E089                    1878          LSR.L #8,D1
00000AB2  E089                    1879          LSR.L #8,D1
00000AB4  13C1 00E00001           1880          MOVE.B D1,DISPLAY
00000ABA                          1881  
00000ABA  2218                    1882          MOVE.L (A0)+,D1
00000ABC                          1883            
00000ABC                          1884          IF.L D0 <NE> D1 THEN      
00000ABC  B081                    1885s     CMP.L   D1,D0
00000ABE  6700 0090               1886s     BEQ _0000000C
00000AC2  43FA 041C               1887              LEA RAM_ERROR(PC),A1
00000AC6                          1888m             PRINT_STR A1,D1
00000AC6                          1889m LOOP_129
00000AC6  0C11 0000               1890m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000ACA  6700 0016               1891m     BEQ EXIT_129
00000ACE                          1892mm     PRINT_CHAR (A1)+,D1
00000ACE                          1893mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACE                 TRUE     1894mm     IFEQ DEBUG
00000ACE  1239 00C00003           1895mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000AD4  0801 0002               1896mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000AD8  67F4                    1897mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000ADA  13D9 00C00007           1898mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AE0                          1899mm     ENDC
00000AE0                          1900mm     
00000AE0                 FALSE    1901mm     IFNE DEBUG
00000AE0                          1902mm     ENDC
00000AE0                          1903mm 
00000AE0                          1904mm     ENDM
00000AE0  60E4                    1905m     BRA LOOP_129
00000AE2                          1906m EXIT_129
00000AE2                          1907m     ENDM
00000AE2  2208                    1908              MOVE.L A0,D1
00000AE4  5981                    1909              SUB.L #4,D1
00000AE6                          1910m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AE6  43FA 044B               1911m     LEA OX(PC),A1
00000AEA                          1912mm     PRINT_STR A1,D3
00000AEA                          1913mm LOOP_132
00000AEA  0C11 0000               1914mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AEE  6700 0016               1915mm     BEQ EXIT_132
00000AF2                          1916mmm     PRINT_CHAR (A1)+,D3
00000AF2                          1917mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF2                 TRUE     1918mmm     IFEQ DEBUG
00000AF2  1639 00C00003           1919mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AF8  0803 0002               1920mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AFC  67F4                    1921mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000AFE  13D9 00C00007           1922mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B04                          1923mmm     ENDC
00000B04                          1924mmm     
00000B04                 FALSE    1925mmm     IFNE DEBUG
00000B04                          1926mmm     ENDC
00000B04                          1927mmm 
00000B04                          1928mmm     ENDM
00000B04  60E4                    1929mm     BRA LOOP_132
00000B06                          1930mm EXIT_132
00000B06                          1931mm     ENDM
00000B06  7C07                    1932m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B08                          1933m LOOP_131
00000B08                          1934mm     BIN2HEX D1,D2,A1
00000B08  43FA 03E8               1935mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B0C  E999                    1936mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B0E  1401                    1937mm     MOVE.B D1,D2
00000B10  0282 0000000F           1938mm     ANDI.L #$F,D2
00000B16  1431 2000               1939mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B1A                          1940mm     ENDM
00000B1A                          1941mm     PRINT_CHAR D2,D3
00000B1A                          1942mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1A                 TRUE     1943mm     IFEQ DEBUG
00000B1A  1639 00C00003           1944mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B20  0803 0002               1945mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B24  67F4                    1946mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00000B26  13C2 00C00007           1947mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B2C                          1948mm     ENDC
00000B2C                          1949mm     
00000B2C                 FALSE    1950mm     IFNE DEBUG
00000B2C                          1951mm     ENDC
00000B2C                          1952mm 
00000B2C                          1953mm     ENDM
00000B2C  57CE FFDA               1954m     DBEQ D6,LOOP_131
00000B30                          1955m     ENDM
00000B30                          1956m             PRINT_CRLF D3,A1
00000B30  43FA 03FB               1957m     LEA CRLF(PC),A1
00000B34                          1958mm     PRINT_STR A1,D3
00000B34                          1959mm LOOP_137
00000B34  0C11 0000               1960mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B38  6700 0016               1961mm     BEQ EXIT_137
00000B3C                          1962mmm     PRINT_CHAR (A1)+,D3
00000B3C                          1963mmm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     1964mmm     IFEQ DEBUG
00000B3C  1639 00C00003           1965mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B42  0803 0002               1966mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B46  67F4                    1967mmm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B48  13D9 00C00007           1968mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B4E                          1969mmm     ENDC
00000B4E                          1970mmm     
00000B4E                 FALSE    1971mmm     IFNE DEBUG
00000B4E                          1972mmm     ENDC
00000B4E                          1973mmm 
00000B4E                          1974mmm     ENDM
00000B4E  60E4                    1975mm     BRA LOOP_137
00000B50                          1976mm EXIT_137
00000B50                          1977mm     ENDM
00000B50                          1978m     ENDM
00000B50                          1979          ENDI 
00000B50                          1980s _0000000C
00000B50                          1981      ENDF
00000B50  5880                    1982s     ADD.L   #4,D0
00000B52                          1983s _20000007
00000B52  B0BC 00040000           1984s     CMP.L   #$40000,D0
00000B58  6F00 FF54               1985s     BLE _20000006
00000B5C                          1986      
00000B5C  6000 F5E0               1987      BRA MAIN_LOOP
00000B60                          1988    
00000B60                          1989  L
00000B60  7000                    1990      MOVE.L #0,D0                                    ; D0 will be the length  to write            
00000B62  7200                    1991      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B64                          1992  
00000B64                          1993      FOR D2 = #0 TO #7 DO                          ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B64  343C 0000               1994s     MOVE.W  #0,D2
00000B68  6000 0046               1995s     BRA _20000009
00000B6C                          1996s _20000008
00000B6C  E989                    1997          LSL.L #4,D1                                 ; make what we have so far more significant
00000B6E                          1998m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B6E                          1999m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B6E                 TRUE     2000m     IFEQ DEBUG
00000B6E  1839 00C00003           2001m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B74  0804 0000               2002m         BTST #0,D4                              ; CHECK FOR CHARACTER
00000B78  67F4                    2003m         BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00000B7A                          2004m     ENDC
00000B7A                          2005m     
00000B7A                          2006mm     READ_CHAR D3
00000B7A                 TRUE     2007mm     IFEQ DEBUG
00000B7A  1639 00C00007           2008mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B80                          2009mm     ENDC
00000B80                 FALSE    2010mm     IFNE DEBUG
00000B80                          2011mm     ENDC
00000B80                          2012mm      
00000B80  B63C 001B               2013mm     CMP.B #$1B,D3                               ; CHECK FOR ESCAPE AND GO TO START
00000B84  6700 F482               2014mm     BEQ START
00000B88                          2015mm     ENDM
00000B88                          2016m 
00000B88                 TRUE     2017m     IFEQ DEBUG
00000B88                          2018mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B88                          2019mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2020mm     IFEQ DEBUG
00000B88  1839 00C00003           2021mm         MOVE.B DUART_SRA,D4                     ; READ STATUS REGISTER
00000B8E  0804 0002               2022mm         BTST #2,D4                              ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2023mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B94  13C3 00C00007           2024mm         MOVE.B D3,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B9A                          2025mm     ENDC
00000B9A                          2026mm     
00000B9A                 FALSE    2027mm     IFNE DEBUG
00000B9A                          2028mm     ENDC
00000B9A                          2029mm 
00000B9A                          2030mm     ENDM
00000B9A                          2031m     ENDC
00000B9A                          2032m     ENDM
00000B9A                          2033m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000B9A  41FA 0366               2034m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000B9E  0403 0030               2035m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BA2  C6BC 000000FF           2036m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BA8  1630 3000               2037m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BAC                          2038m     ENDM
00000BAC  8203                    2039          OR.B D3,D1
00000BAE                          2040      ENDF
00000BAE  5242                    2041s     ADD.W   #1,D2
00000BB0                          2042s _20000009
00000BB0  B47C 0007               2043s     CMP.W   #7,D2
00000BB4  6FB6                    2044s     BLE _20000008
00000BB6                          2045      
00000BB6  3001                    2046      MOVE.W D1,D0                                  ; extract the LSword for the length
00000BB8  E089                    2047      LSR.L #8,D1                                   ; extract the MSword for the address
00000BBA  E089                    2048      LSR.L #8,D1                                   
00000BBC                          2049                        
00000BBC                          2050m     PRINT_CRLF D2,A1
00000BBC  43FA 036F               2051m     LEA CRLF(PC),A1
00000BC0                          2052mm     PRINT_STR A1,D2
00000BC0                          2053mm LOOP_144
00000BC0  0C11 0000               2054mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BC4  6700 0016               2055mm     BEQ EXIT_144
00000BC8                          2056mmm     PRINT_CHAR (A1)+,D2
00000BC8                          2057mmm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     2058mmm     IFEQ DEBUG
00000BC8  1439 00C00003           2059mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000BCE  0802 0002               2060mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    2061mmm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000BD4  13D9 00C00007           2062mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BDA                          2063mmm     ENDC
00000BDA                          2064mmm     
00000BDA                 FALSE    2065mmm     IFNE DEBUG
00000BDA                          2066mmm     ENDC
00000BDA                          2067mmm 
00000BDA                          2068mmm     ENDM
00000BDA  60E4                    2069mm     BRA LOOP_144
00000BDC                          2070mm EXIT_144
00000BDC                          2071mm     ENDM
00000BDC                          2072m     ENDM
00000BDC                          2073  
00000BDC  2041                    2074      MOVE.L D1,A0                                ; target address
00000BDE                          2075      
00000BDE  2247                    2076      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BE0  7E00                    2077      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BE2                          2078  
00000BE2  5089                    2079      ADD.L #8,A1                                   ; skip the initial stack pointer and reset vector for now
00000BE4  5180                    2080      SUB.L #8,D0
00000BE6                          2081      
00000BE6  31FC AAAA 2AAA          2082      MOVE.W #$AAAA,$2AAA
00000BEC  4E71                    2083      NOP
00000BEE  31FC 5555 1554          2084      MOVE.W #$5555,$1554
00000BF4  4E71                    2085      NOP
00000BF6  31FC 8080 2AAA          2086      MOVE.W #$8080,$2AAA
00000BFC  4E71                    2087      NOP
00000BFE  31FC AAAA 2AAA          2088      MOVE.W #$AAAA,$2AAA
00000C04  4E71                    2089      NOP
00000C06  31FC 5555 1554          2090      MOVE.W #$5555,$1554
00000C0C  4E71                    2091      NOP
00000C0E  31FC 2020 2AAA          2092      MOVE.W #$2020,$2AAA
00000C14                          2093      
00000C14  45FA 0303               2094      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00000C18                          2095m     PRINT_STR A2,D2
00000C18                          2096m LOOP_146
00000C18  0C12 0000               2097m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C1C  6700 0016               2098m     BEQ EXIT_146
00000C20                          2099mm     PRINT_CHAR (A2)+,D2
00000C20                          2100mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C20                 TRUE     2101mm     IFEQ DEBUG
00000C20  1439 00C00003           2102mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000C26  0802 0002               2103mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000C2A  67F4                    2104mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000C2C  13DA 00C00007           2105mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C32                          2106mm     ENDC
00000C32                          2107mm     
00000C32                 FALSE    2108mm     IFNE DEBUG
00000C32                          2109mm     ENDC
00000C32                          2110mm 
00000C32                          2111mm     ENDM
00000C32  60E4                    2112m     BRA LOOP_146
00000C34                          2113m EXIT_146
00000C34                          2114m     ENDM
00000C34                          2115      
00000C34  2409                    2116      MOVE.L A1,D2                
00000C36                          2117m     PRINT_REG D2,D3,D4,D5,A2
00000C36  45FA 02FB               2118m     LEA OX(PC),A2
00000C3A                          2119mm     PRINT_STR A2,D3
00000C3A                          2120mm LOOP_149
00000C3A  0C12 0000               2121mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C3E  6700 0016               2122mm     BEQ EXIT_149
00000C42                          2123mmm     PRINT_CHAR (A2)+,D3
00000C42                          2124mmm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C42                 TRUE     2125mmm     IFEQ DEBUG
00000C42  1639 00C00003           2126mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C48  0803 0002               2127mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C4C  67F4                    2128mmm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00000C4E  13DA 00C00007           2129mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C54                          2130mmm     ENDC
00000C54                          2131mmm     
00000C54                 FALSE    2132mmm     IFNE DEBUG
00000C54                          2133mmm     ENDC
00000C54                          2134mmm 
00000C54                          2135mmm     ENDM
00000C54  60E4                    2136mm     BRA LOOP_149
00000C56                          2137mm EXIT_149
00000C56                          2138mm     ENDM
00000C56  7A07                    2139m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C58                          2140m LOOP_148
00000C58                          2141mm     BIN2HEX D2,D4,A2
00000C58  45FA 0298               2142mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000C5C  E99A                    2143mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C5E  1802                    2144mm     MOVE.B D2,D4
00000C60  0284 0000000F           2145mm     ANDI.L #$F,D4
00000C66  1832 4000               2146mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000C6A                          2147mm     ENDM
00000C6A                          2148mm     PRINT_CHAR D4,D3
00000C6A                          2149mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6A                 TRUE     2150mm     IFEQ DEBUG
00000C6A  1639 00C00003           2151mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C70  0803 0002               2152mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C74  67F4                    2153mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000C76  13C4 00C00007           2154mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C7C                          2155mm     ENDC
00000C7C                          2156mm     
00000C7C                 FALSE    2157mm     IFNE DEBUG
00000C7C                          2158mm     ENDC
00000C7C                          2159mm 
00000C7C                          2160mm     ENDM
00000C7C  57CD FFDA               2161m     DBEQ D5,LOOP_148
00000C80                          2162m     ENDM
00000C80                          2163  
00000C80  45FA 02B4               2164      LEA TO(PC),A2
00000C84                          2165m     PRINT_STR A2,D3
00000C84                          2166m LOOP_153
00000C84  0C12 0000               2167m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C88  6700 0016               2168m     BEQ EXIT_153
00000C8C                          2169mm     PRINT_CHAR (A2)+,D3
00000C8C                          2170mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8C                 TRUE     2171mm     IFEQ DEBUG
00000C8C  1639 00C00003           2172mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C92  0803 0002               2173mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C96  67F4                    2174mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C98  13DA 00C00007           2175mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C9E                          2176mm     ENDC
00000C9E                          2177mm     
00000C9E                 FALSE    2178mm     IFNE DEBUG
00000C9E                          2179mm     ENDC
00000C9E                          2180mm 
00000C9E                          2181mm     ENDM
00000C9E  60E4                    2182m     BRA LOOP_153
00000CA0                          2183m EXIT_153
00000CA0                          2184m     ENDM
00000CA0                          2185      
00000CA0  2408                    2186      MOVE.L A0,D2                
00000CA2                          2187m     PRINT_REG D2,D3,D4,D5,A2
00000CA2  45FA 028F               2188m     LEA OX(PC),A2
00000CA6                          2189mm     PRINT_STR A2,D3
00000CA6                          2190mm LOOP_156
00000CA6  0C12 0000               2191mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CAA  6700 0016               2192mm     BEQ EXIT_156
00000CAE                          2193mmm     PRINT_CHAR (A2)+,D3
00000CAE                          2194mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAE                 TRUE     2195mmm     IFEQ DEBUG
00000CAE  1639 00C00003           2196mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB4  0803 0002               2197mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB8  67F4                    2198mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000CBA  13DA 00C00007           2199mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CC0                          2200mmm     ENDC
00000CC0                          2201mmm     
00000CC0                 FALSE    2202mmm     IFNE DEBUG
00000CC0                          2203mmm     ENDC
00000CC0                          2204mmm 
00000CC0                          2205mmm     ENDM
00000CC0  60E4                    2206mm     BRA LOOP_156
00000CC2                          2207mm EXIT_156
00000CC2                          2208mm     ENDM
00000CC2  7A07                    2209m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CC4                          2210m LOOP_155
00000CC4                          2211mm     BIN2HEX D2,D4,A2
00000CC4  45FA 022C               2212mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000CC8  E99A                    2213mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CCA  1802                    2214mm     MOVE.B D2,D4
00000CCC  0284 0000000F           2215mm     ANDI.L #$F,D4
00000CD2  1832 4000               2216mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000CD6                          2217mm     ENDM
00000CD6                          2218mm     PRINT_CHAR D4,D3
00000CD6                          2219mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD6                 TRUE     2220mm     IFEQ DEBUG
00000CD6  1639 00C00003           2221mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CDC  0803 0002               2222mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE0  67F4                    2223mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000CE2  13C4 00C00007           2224mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CE8                          2225mm     ENDC
00000CE8                          2226mm     
00000CE8                 FALSE    2227mm     IFNE DEBUG
00000CE8                          2228mm     ENDC
00000CE8                          2229mm 
00000CE8                          2230mm     ENDM
00000CE8  57CD FFDA               2231m     DBEQ D5,LOOP_155
00000CEC                          2232m     ENDM
00000CEC                          2233  
00000CEC                          2234m     PRINT_CRLF D3,A2
00000CEC  45FA 023F               2235m     LEA CRLF(PC),A2
00000CF0                          2236mm     PRINT_STR A2,D3
00000CF0                          2237mm LOOP_161
00000CF0  0C12 0000               2238mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CF4  6700 0016               2239mm     BEQ EXIT_161
00000CF8                          2240mmm     PRINT_CHAR (A2)+,D3
00000CF8                          2241mmm WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF8                 TRUE     2242mmm     IFEQ DEBUG
00000CF8  1639 00C00003           2243mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CFE  0803 0002               2244mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D02  67F4                    2245mmm         BEQ WAIT_FOR_READY_162                      ; NO SPACE, CHECK AGAIN
00000D04  13DA 00C00007           2246mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000D0A                          2247mmm     ENDC
00000D0A                          2248mmm     
00000D0A                 FALSE    2249mmm     IFNE DEBUG
00000D0A                          2250mmm     ENDC
00000D0A                          2251mmm 
00000D0A                          2252mmm     ENDM
00000D0A  60E4                    2253mm     BRA LOOP_161
00000D0C                          2254mm EXIT_161
00000D0C                          2255mm     ENDM
00000D0C                          2256m     ENDM
00000D0C                          2257  
00000D0C                          2258      WHILE D0 <GT> #0 DO
00000D0C                          2259s _10000014
00000D0C  B07C 0000               2260s     CMP.W   #0,D0
00000D10  6F00 001C               2261s     BLE _10000015
00000D14  5580                    2262          SUB.L #2,D0
00000D16                          2263        
00000D16  13D1 00E00001           2264          MOVE.B (A1),DISPLAY
00000D1C                          2265m         PROGRAM (A1),(A0),D2
00000D1C  3091                    2266m   MOVE.W (A1),(A0)                          ; WRITE THE DATA
00000D1E                          2267m       
00000D1E                          2268m WAIT_FOR_COMPLETE_163
00000D1E  3410                    2269m         MOVE.W (A0),D2
00000D20                          2270m 
00000D20                          2271m         IF.W D2 <NE> (A1) THEN
00000D20  B451                    2272ms     CMP.W   (A1),D2
00000D22  6700 0004               2273ms     BEQ _0000000D
00000D26  60F6                    2274m             BRA WAIT_FOR_COMPLETE_163
00000D28                          2275m         ENDI
00000D28                          2276ms _0000000D
00000D28                          2277m         ENDM
00000D28                          2278                
00000D28  5488                    2279          ADD.L #2,A0
00000D2A  5489                    2280          ADD.L #2,A1
00000D2C                          2281      ENDW
00000D2C  60DE                    2282s     BRA _10000014
00000D2E                          2283s _10000015
00000D2E                          2284      
00000D2E                          2285m     PROGRAM #0, $0, D2                         ; we're done, can now update the SP and start vector
00000D2E  31FC 0000 0000          2286m   MOVE.W #0,$0                          ; WRITE THE DATA
00000D34                          2287m       
00000D34                          2288m WAIT_FOR_COMPLETE_164
00000D34  3438 0000               2289m         MOVE.W $0,D2
00000D38                          2290m 
00000D38                          2291m         IF.W D2 <NE> #0 THEN
00000D38  B47C 0000               2292ms     CMP.W   #0,D2
00000D3C  6700 0004               2293ms     BEQ _0000000E
00000D40  60F2                    2294m             BRA WAIT_FOR_COMPLETE_164
00000D42                          2295m         ENDI
00000D42                          2296ms _0000000E
00000D42                          2297m         ENDM
00000D42                          2298m     PROGRAM #0, $2, D2                         ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D42  31FC 0000 0002          2299m   MOVE.W #0,$2                          ; WRITE THE DATA
00000D48                          2300m       
00000D48                          2301m WAIT_FOR_COMPLETE_165
00000D48  3438 0002               2302m         MOVE.W $2,D2
00000D4C                          2303m 
00000D4C                          2304m         IF.W D2 <NE> #0 THEN
00000D4C  B47C 0000               2305ms     CMP.W   #0,D2
00000D50  6700 0004               2306ms     BEQ _0000000F
00000D54  60F2                    2307m             BRA WAIT_FOR_COMPLETE_165
00000D56                          2308m         ENDI
00000D56                          2309ms _0000000F
00000D56                          2310m         ENDM
00000D56                          2311  
00000D56                          2312m     PROGRAM D1, $6, D2
00000D56  31C1 0006               2313m   MOVE.W D1,$6                          ; WRITE THE DATA
00000D5A                          2314m       
00000D5A                          2315m WAIT_FOR_COMPLETE_166
00000D5A  3438 0006               2316m         MOVE.W $6,D2
00000D5E                          2317m 
00000D5E                          2318m         IF.W D2 <NE> D1 THEN
00000D5E  B441                    2319ms     CMP.W   D1,D2
00000D60  6700 0004               2320ms     BEQ _00000010
00000D64  60F4                    2321m             BRA WAIT_FOR_COMPLETE_166
00000D66                          2322m         ENDI
00000D66                          2323ms _00000010
00000D66                          2324m         ENDM
00000D66  E089                    2325      LSR.L #8,D1
00000D68  E089                    2326      LSR.L #8,D1
00000D6A                          2327m     PROGRAM D1, $4, D2                         
00000D6A  31C1 0004               2328m   MOVE.W D1,$4                          ; WRITE THE DATA
00000D6E                          2329m       
00000D6E                          2330m WAIT_FOR_COMPLETE_167
00000D6E  3438 0004               2331m         MOVE.W $4,D2
00000D72                          2332m 
00000D72                          2333m         IF.W D2 <NE> D1 THEN
00000D72  B441                    2334ms     CMP.W   D1,D2
00000D74  6700 0004               2335ms     BEQ _00000011
00000D78  60F4                    2336m             BRA WAIT_FOR_COMPLETE_167
00000D7A                          2337m         ENDI
00000D7A                          2338ms _00000011
00000D7A                          2339m         ENDM
00000D7A                          2340  
00000D7A  31FC AAAA 2AAA          2341      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000D80  31FC 5555 1554          2342      MOVE.W #$5555,$1554
00000D86  31FC A0A0 2AAA          2343      MOVE.W #$A0A0,$2AAA
00000D8C                          2344              
00000D8C  6000 F3B0               2345      BRA MAIN_LOOP
00000D90                          2346          
00000D90                          2347  HEX_DIGIT
00000D90  E98F                    2348      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000D92                          2349m     HEX2BIN D2,D2,A0
00000D92  41FA 016E               2350m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000D96  0402 0030               2351m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D9A  C4BC 000000FF           2352m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000DA0  1430 2000               2353m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000DA4                          2354m     ENDM
00000DA4  8E02                    2355      OR.B D2,D7  
00000DA6  6000 F3B6               2356      BRA GET_INPUT
00000DAA                          2357  
00000DAA  FFFF FFFF               2358      SIMHALT                                     ; halt simulator
00000DAE                          2359  
00000DAE                          2360  ; strings
00000DAE= 4D 44 46 2D 6D 6F ...   2361  VERSION DC.B 'MDF-mon V1.64 (11/04/2021)',CR,LF,NULL
00000DCB= 50 72 65 73 73 20 ...   2362  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000DDE= 3F 09 09 09 68 65 ...   2363  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000DE8= 5B 76 5D 09 09 09 ...   2364          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000DF7= 78 78 78 78 78 78 ...   2365          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000E0F= 78 78 78 78 78 78 ...   2366          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000E2F= 5B 73 5D 09 09 09 ...   2367          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000E49= 78 78 78 78 78 78 ...   2368          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000E5A= 5B 7A 5D 09 09 09 ...   2369          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000E6C= 78 78 78 78 78 78 ...   2370          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000E8E= 48 75 68 3F 0D 0A 00    2371  HUH     DC.B 'Huh?',CR,LF,NULL
00000E95= 20 53 20 72 65 63 ...   2372  READ    DC.B ' S records read, start address = ',NULL
00000EB7= 57 3A 20 55 6E 6B ...   2373  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000ECE= 57 3A 20 43 53 20 ...   2374  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000EE0= 57 3A 20 52 41 4D ...   2375  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000EF2= 30 31 32 33 34 35 ...   2376  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000F02= 00 01 02 03 04 05 ...   2377  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000F19= 4C 6F 61 64 69 6E ...   2378  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000F2D= 0D 0A 00                2379  CRLF    DC.B CR,LF,NULL
00000F30= 3E 20 00                2380  PROMPT  DC.B '> ',NULL
00000F33= 30 78 00                2381  ox      DC.B '0x',NULL
00000F36= 20 2D 3E 20 00          2382  to      DC.B ' -> ',NULL
00000F3B                          2383      
00000F3B                          2384      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         EF2
CONTINUE_38         36E
CONTINUE_41         3BE
CONTINUE_45         414
CONTINUE_53         4C8
CONTINUE_58         53A
CONTINUE_63         5B6
CONTINUE_68         634
CONTINUE_73         6BC
CONTINUE_78         72E
CONTINUE_83         7A0
CONTINUE_97         892
CR                  D
CRLF                F2D
CS_FAILURE          ECE
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       C2D
DOWNLOAD_DONE       99C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            8FA
EXIT_104            922
EXIT_107            942
EXIT_11             15E
EXIT_112            98C
EXIT_115            9BC
EXIT_119            A06
EXIT_122            A28
EXIT_127            A72
EXIT_129            AE2
EXIT_132            B06
EXIT_137            B50
EXIT_144            BDC
EXIT_146            C34
EXIT_149            C56
EXIT_153            CA0
EXIT_156            CC2
EXIT_161            D0C
EXIT_17             1E2
EXIT_19             232
EXIT_2              D4
EXIT_21             25E
EXIT_24             288
EXIT_29             2D2
EXIT_36             346
EXIT_4              F4
EXIT_50             484
EXIT_6              114
EXIT_88             812
EXIT_9              134
EXIT_90             832
EXIT_94             864
G                   A76
GET_INPUT           15E
H                   236
HELP                DDE
HELPPROMPT          DCB
HEX2BIN             137
HEX2BIN_LUT         F02
HEX_DIGIT           D90
HUH                 E8E
L                   B60
LF                  A
LOADING             F19
LOOP_102            8DE
LOOP_104            906
LOOP_106            944
LOOP_107            926
LOOP_11             142
LOOP_112            970
LOOP_114            9BE
LOOP_115            9A0
LOOP_119            9EA
LOOP_121            A2A
LOOP_122            A0C
LOOP_127            A56
LOOP_129            AC6
LOOP_131            B08
LOOP_132            AEA
LOOP_137            B34
LOOP_144            BC0
LOOP_146            C18
LOOP_148            C58
LOOP_149            C3A
LOOP_153            C84
LOOP_155            CC4
LOOP_156            CA6
LOOP_161            CF0
LOOP_17             1C6
LOOP_19             216
LOOP_2              B8
LOOP_21             242
LOOP_23             28A
LOOP_24             26C
LOOP_29             2B6
LOOP_36             32A
LOOP_4              D8
LOOP_50             468
LOOP_6              F8
LOOP_88             7F6
LOOP_9              118
LOOP_90             816
LOOP_94             848
MAIN_LOOP           13E
NULL                0
OX                  F33
PRINTSTR            242
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROGRAM             E50
PROMPT              F30
R                   262
RAM                 200000
RAM_ERROR           EE0
READ                E95
READ_CHAR           7E2
READ_DATA_TO_POKE   2DA
RESET               4
ROM                 0
S                   34A
STACK               0
START               8
TAB                 9
TO                  F36
UNREC               EB7
V                   23E
VERSION             DAE
W                   2D6
WAIT_CHAR           633
WAIT_FOR_COMPLETE_163  D1E
WAIT_FOR_COMPLETE_164  D34
WAIT_FOR_COMPLETE_165  D48
WAIT_FOR_COMPLETE_166  D5A
WAIT_FOR_COMPLETE_167  D6E
WAIT_FOR_READY_10   120
WAIT_FOR_READY_103  8E6
WAIT_FOR_READY_105  90E
WAIT_FOR_READY_108  92E
WAIT_FOR_READY_110  956
WAIT_FOR_READY_113  978
WAIT_FOR_READY_116  9A8
WAIT_FOR_READY_118  9D0
WAIT_FOR_READY_12   14A
WAIT_FOR_READY_120  9F2
WAIT_FOR_READY_123  A14
WAIT_FOR_READY_125  A3C
WAIT_FOR_READY_128  A5E
WAIT_FOR_READY_13   15E
WAIT_FOR_READY_130  ACE
WAIT_FOR_READY_133  AF2
WAIT_FOR_READY_135  B1A
WAIT_FOR_READY_138  B3C
WAIT_FOR_READY_139  B6E
WAIT_FOR_READY_141  B88
WAIT_FOR_READY_145  BC8
WAIT_FOR_READY_147  C20
WAIT_FOR_READY_15   178
WAIT_FOR_READY_150  C42
WAIT_FOR_READY_152  C6A
WAIT_FOR_READY_154  C8C
WAIT_FOR_READY_157  CAE
WAIT_FOR_READY_159  CD6
WAIT_FOR_READY_162  CF8
WAIT_FOR_READY_18   1CE
WAIT_FOR_READY_20   21E
WAIT_FOR_READY_22   24A
WAIT_FOR_READY_25   274
WAIT_FOR_READY_27   29C
WAIT_FOR_READY_3    C0
WAIT_FOR_READY_30   2BE
WAIT_FOR_READY_31   2DC
WAIT_FOR_READY_33   2F6
WAIT_FOR_READY_37   332
WAIT_FOR_READY_38   352
WAIT_FOR_READY_40   38C
WAIT_FOR_READY_41   3A2
WAIT_FOR_READY_43   3D6
WAIT_FOR_READY_45   3F8
WAIT_FOR_READY_47   42C
WAIT_FOR_READY_5    E0
WAIT_FOR_READY_51   470
WAIT_FOR_READY_53   4AC
WAIT_FOR_READY_55   4E0
WAIT_FOR_READY_58   51E
WAIT_FOR_READY_60   552
WAIT_FOR_READY_63   59A
WAIT_FOR_READY_65   5CE
WAIT_FOR_READY_68   618
WAIT_FOR_READY_7    100
WAIT_FOR_READY_70   64C
WAIT_FOR_READY_73   6A0
WAIT_FOR_READY_75   6D4
WAIT_FOR_READY_78   712
WAIT_FOR_READY_80   746
WAIT_FOR_READY_83   784
WAIT_FOR_READY_85   7B8
WAIT_FOR_READY_89   7FE
WAIT_FOR_READY_91   81E
WAIT_FOR_READY_92   832
WAIT_FOR_READY_95   850
WAIT_FOR_READY_97   876
WAIT_FOR_READY_99   8AA
WAIT_FOR_SRECORD    352
Z                   A7E
_00000000           19E
_00000001           1B2
_00000002           48C
_00000003           868
_00000004           49A
_00000005           688
_00000006           5FE
_00000007           868
_00000008           7F2
_00000009           868
_0000000A           990
_0000000B           99C
_0000000C           B50
_0000000D           D28
_0000000E           D42
_0000000F           D56
_00000010           D66
_00000011           D7A
_10000000           3EE
_10000001           456
_10000002           4A2
_10000003           50A
_10000004           514
_10000005           57C
_10000006           590
_10000007           5F8
_10000008           602
_10000009           682
_1000000A           60E
_1000000B           676
_1000000C           696
_1000000D           6FE
_1000000E           708
_1000000F           770
_10000010           77A
_10000011           7E2
_10000012           86C
_10000013           8D4
_10000014           D0C
_10000015           D2E
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A8A
_20000005           A9A
_20000006           AAE
_20000007           B52
_20000008           B6C
_20000009           BB0
