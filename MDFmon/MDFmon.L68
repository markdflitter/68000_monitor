00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 14:51:24

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; revisit register usage in S record download
00000000                             9  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            10  ; swap first and second args in download_byte
00000000                            11  ; revisit use of bytes and longs, eg for checksum
00000000                            12  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            13  ; Review for any other savings
00000000                            14  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            15  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            16  
00000000                            17  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; fix the reset vector so that it jumps to the start
00000000                            20  ; implement backspace
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  ; fix being able to enter random chars when W'ing
00000000                            23  ; ram check at startup?  Not sure if this is a good idea!
00000000                            24  ; byte W?
00000000                            25  
00000000                            26      ORG  $0
00000000                            27      ;ORG  $230000
00000000                            28  
00000000  =00000000                 29  DEBUG               EQU 0
00000000                            30  
00000000                            31  ; constants
00000000  =00000000                 32  ROM                 EQU $0
00000000  =00200000                 33  RAM                 EQU $200000
00000000                            34     
00000000  =00C00000                 35  DUART_BASE          EQU $C00000
00000000  =00000000                 36  DUART_MRA_          EQU $0
00000000  =00000001                 37  DUART_CSRA_         EQU $1
00000000  =00000001                 38  DUART_SRA_          EQU $1
00000000  =00000002                 39  DUART_CRA_          EQU $2
00000000  =00000003                 40  DUART_TXA_          EQU $3
00000000  =00000003                 41  DUART_RXA_          EQU $3
00000000  =00000004                 42  DUART_ACR_          EQU $4
00000000  =00000005                 43  DUART_IMR_          EQU $5
00000000  =00000008                 44  DUART_MRB_          EQU $8
00000000  =00000009                 45  DUART_CSRB_         EQU $9
00000000  =00000009                 46  DUART_SRB_          EQU $9
00000000  =0000000A                 47  DUART_CRB_          EQU $A
00000000  =0000000B                 48  DUART_TXB_          EQU $B
00000000  =0000000B                 49  DUART_RXB_          EQU $B
00000000  =0000000C                 50  DUART_IVR_          EQU $C
00000000  =0000000D                 51  DUART_OPCR_         EQU $D
00000000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00000000                            54  
00000000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            61  
00000000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            68  
00000000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            75  
00000000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 77  DISPLAY_            EQU $0
00000000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            79  
00000000                            80  ; macros
00000000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            82  ; the input register is changed during the process
00000000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            84  BIN2HEX MACRO
00000000                            85      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            86      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            87      MOVE.B \1,\2
00000000                            88      ANDI.L #$F,\2
00000000                            89      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            90      ENDM
00000000                            91  
00000000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            93  ; the input register is changed during the process
00000000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            95  HEX2BIN MACRO
00000000                            96      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            97      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            98      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                            99      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                           100      ENDM
00000000                           101  
00000000                           102  ; send a single char to the serial port
00000000                           103  ; \1 = char to send, \2 = data register to use for status poll
00000000                           104  ; will stamp on D0 and D1 in debug mode
00000000                           105  PRINT_CHAR MACRO
00000000                           106  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           107      IFEQ DEBUG
00000000                           108          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           109          BTST #2,\2                              ; check for space to send
00000000                           110          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           111          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           112      ENDC
00000000                           113      
00000000                           114      IFNE DEBUG
00000000                           115          MOVE.B \1,D1
00000000                           116          MOVE.L #6,D0   
00000000                           117          TRAP #15                                ; write to terminal in simulator
00000000                           118      ENDC
00000000                           119  
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send CR,LF to the serial port
00000000                           123  ; \1 = data register to use for status poll
00000000                           124  PRINT_CRLF MACRO
00000000                           125      PRINT_CHAR #13,\1                           ; CR
00000000                           126      PRINT_CHAR #10,\1                           ; LF
00000000                           127      ENDM
00000000                           128  
00000000                           129  ; send C-style, zero terminated string to the serial port
00000000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           131  PRINT_STR MACRO
00000000                           132  LOOP\@
00000000                           133      CMP.B #0,(\1)                               ; 0 -> done
00000000                           134      BEQ EXIT\@
00000000                           135      PRINT_CHAR (\1)+,\2
00000000                           136      BRA LOOP\@
00000000                           137  EXIT\@
00000000                           138      ENDM
00000000                           139    
00000000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           142  PRINT_REG MACRO
00000000                           143      PRINT_CHAR #'0',\2                          ;0x header
00000000                           144      PRINT_CHAR #'x',\2
00000000                           145      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           146  LOOP\@
00000000                           147      BIN2HEX \1,\3,\5
00000000                           148      PRINT_CHAR \3,\2
00000000                           149      DBEQ \4,LOOP\@
00000000                           150      ENDM
00000000                           151    
00000000                           152  ; wait for a char from the serial port
00000000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           154  ; will stamp on D0 and D1 in debug mode
00000000                           155  WAIT_CHAR MACRO
00000000                           156  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           157  
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                        ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           195      BTST #0,\1                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           201      BTST #0,\1                                  ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; read two hex digits from the download serial port and convert to a byte
00000000                           210  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           211  DOWNLOAD_BYTE MACRO
00000000                           212      MOVE.B #2,\4
00000000                           213      WHILE.B \4 <GT> 0 DO
00000000                           214          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           215          DOWNLOAD \1
00000000                           216          PRINT_CHAR \1,\3
00000000                           217          HEX2BIN \1,\1,\6
00000000                           218          OR.B \1,\2
00000000                           219          SUB.B #1,\4
00000000                           220      ENDW
00000000                           221      
00000000                           222      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00000000                           223      MOVE.B \2,\1
00000000                           224      ADD.L \2,\5
00000000                           225  
00000000                           226      ENDM
00000000                           227      
00000000                           228  
00000000                           229  ; register catalogue
00000000                           230  ; D0 - used for simulator I/O
00000000                           231  ; D1 - used for simulator I/O
00000000                           232  ; D2 - read character
00000000                           233  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           234  ; D6 - working register used in R/W
00000000                           235  ; D7 - address accumulator, reset by download
00000000                           236  ; A0 - address of string to print 
00000000                           237  
00000000                           238  ; start vector
00000000= 00000000                 239  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 240  RESET    DC.L START                             ; RESET
00000008                           241      
00000008                           242  ; start of program  
00000008                           243  START
00000008  13FC 0000 00E00001       244      MOVE.B #0,DISPLAY
00000010                           245  
00000010                           246  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       247      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       248      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     249      NOP
00000022  13FC 0040 00C00005       250      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     251      NOP
0000002C  13FC 0030 00C00005       252      MOVE.B #$30,DUART_CRA
00000034  4E71                     253      NOP
00000036  13FC 0020 00C00005       254      MOVE.B #$20,DUART_CRA
0000003E  4E71                     255      NOP
00000040  13FC 0010 00C00005       256      MOVE.B #$10,DUART_CRA   
00000048                           257  
00000048  13FC 000A 00C00015       258      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       259      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     260      NOP
0000005A  13FC 0040 00C00015       261      MOVE.B #$40,DUART_CRB           
00000062  4E71                     262      NOP
00000064  13FC 0030 00C00015       263      MOVE.B #$30,DUART_CRB
0000006C  4E71                     264      NOP
0000006E  13FC 0020 00C00015       265      MOVE.B #$20,DUART_CRB
00000076  4E71                     266      NOP
00000078  13FC 0010 00C00015       267      MOVE.B #$10,DUART_CRB   
00000080                           268  
00000080                           269  ;initialise UART
00000080  13FC 0000 00C00009       270      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       271      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       272      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           273  
00000098                           274  ; channel A
00000098  13FC 0013 00C00001       275      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       276      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       277      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       278      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           279  
000000B8                           280  ; channel B
000000B8  13FC 0013 00C00011       281      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       282      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       283      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       284      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           285  
000000D8                           286m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           287m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      288m     IFEQ DEBUG
000000D8  1639 00C00003            289m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                290m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     291m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       292m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           293m     ENDC
000000EC                           294m     
000000EC                 FALSE     295m     IFNE DEBUG
000000EC                           296m     ENDC
000000EC                           297m 
000000EC                           298m     ENDM
000000EC                           299  
000000EC  13FC 0001 00E00001       300      MOVE.B #1,DISPLAY
000000F4                           301         
000000F4                           302m     PRINT_CRLF D3
000000F4                           303mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           304mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      305mm     IFEQ DEBUG
000000F4  1639 00C00003            306mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                307mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     308mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       309mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           310mm     ENDC
00000108                           311mm     
00000108                 FALSE     312mm     IFNE DEBUG
00000108                           313mm     ENDC
00000108                           314mm 
00000108                           315mm     ENDM
00000108                           316mm     PRINT_CHAR #10,D3                           ; LF
00000108                           317mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      318mm     IFEQ DEBUG
00000108  1639 00C00003            319mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                320mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     321mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       322mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           323mm     ENDC
0000011C                           324mm     
0000011C                 FALSE     325mm     IFNE DEBUG
0000011C                           326mm     ENDC
0000011C                           327mm 
0000011C                           328mm     ENDM
0000011C                           329m     ENDM
0000011C                           330  
0000011C  41F9 00000EAE            331      LEA VERSION,A0
00000122                           332m     PRINT_STR A0,D3
00000122                           333m LOOP_5
00000122  0C10 0000                334m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0016                335m     BEQ EXIT_5
0000012A                           336mm     PRINT_CHAR (A0)+,D3
0000012A                           337mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      338mm     IFEQ DEBUG
0000012A  1639 00C00003            339mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                340mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     341mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            342mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           343mm     ENDC
0000013C                           344mm     
0000013C                 FALSE     345mm     IFNE DEBUG
0000013C                           346mm     ENDC
0000013C                           347mm 
0000013C                           348mm     ENDM
0000013C  60E4                     349m     BRA LOOP_5
0000013E                           350m EXIT_5
0000013E                           351m     ENDM
0000013E                           352m     PRINT_CRLF D3
0000013E                           353mm     PRINT_CHAR #13,D3                           ; CR
0000013E                           354mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      355mm     IFEQ DEBUG
0000013E  1639 00C00003            356mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                357mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     358mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014A  13FC 000D 00C00007       359mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000152                           360mm     ENDC
00000152                           361mm     
00000152                 FALSE     362mm     IFNE DEBUG
00000152                           363mm     ENDC
00000152                           364mm 
00000152                           365mm     ENDM
00000152                           366mm     PRINT_CHAR #10,D3                           ; LF
00000152                           367mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      368mm     IFEQ DEBUG
00000152  1639 00C00003            369mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000158  0803 0002                370mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015C  67F4                     371mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0000015E  13FC 000A 00C00007       372mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000166                           373mm     ENDC
00000166                           374mm     
00000166                 FALSE     375mm     IFNE DEBUG
00000166                           376mm     ENDC
00000166                           377mm 
00000166                           378mm     ENDM
00000166                           379m     ENDM
00000166                           380m     PRINT_CHAR #7,D3
00000166                           381m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000166                 TRUE      382m     IFEQ DEBUG
00000166  1639 00C00003            383m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016C  0803 0002                384m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000170  67F4                     385m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000172  13FC 0007 00C00007       386m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017A                           387m     ENDC
0000017A                           388m     
0000017A                 FALSE     389m     IFNE DEBUG
0000017A                           390m     ENDC
0000017A                           391m 
0000017A                           392m     ENDM
0000017A                           393  
0000017A  7E00                     394      MOVE.L #0,D7                                ; address accumulator
0000017C                           395  
0000017C  13FC 0002 00E00001       396      MOVE.B #2,DISPLAY
00000184                           397  MAIN_LOOP
00000184                           398m     PRINT_CHAR #'>',D3                          ; prompt
00000184                           399m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000184                 TRUE      400m     IFEQ DEBUG
00000184  1639 00C00003            401m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018A  0803 0002                402m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000018E  67F4                     403m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000190  13FC 003E 00C00007       404m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000198                           405m     ENDC
00000198                           406m     
00000198                 FALSE     407m     IFNE DEBUG
00000198                           408m     ENDC
00000198                           409m 
00000198                           410m     ENDM
00000198                           411m     PRINT_CHAR #32,D3                           ; space
00000198                           412m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000198                 TRUE      413m     IFEQ DEBUG
00000198  1639 00C00003            414m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000019E  0803 0002                415m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A2  67F4                     416m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A4  13FC 0020 00C00007       417m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AC                           418m     ENDC
000001AC                           419m     
000001AC                 FALSE     420m     IFNE DEBUG
000001AC                           421m     ENDC
000001AC                           422m 
000001AC                           423m     ENDM
000001AC                           424      
000001AC                           425  GET_INPUT
000001AC                           426m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AC                           427m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AC                           428m 
000001AC                 TRUE      429m     IFEQ DEBUG
000001AC  1639 00C00003            430m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B2  0803 0000                431m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B6  67F4                     432m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001B8                           433m     ENDC
000001B8                           434m     
000001B8                           435mm     READ_CHAR D2
000001B8                 TRUE      436mm     IFEQ DEBUG
000001B8  1439 00C00007            437mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001BE                           438mm     ENDC
000001BE                 FALSE     439mm     IFNE DEBUG
000001BE                           440mm     ENDC
000001BE                           441mm      
000001BE  B43C 001B                442mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C2  6700 FE44                443mm     BEQ START
000001C6                           444mm     ENDM
000001C6                           445m 
000001C6                 TRUE      446m     IFEQ DEBUG
000001C6                           447mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C6                           448mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C6                 TRUE      449mm     IFEQ DEBUG
000001C6  1639 00C00003            450mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CC  0803 0002                451mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D0  67F4                     452mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D2  13C2 00C00007            453mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001D8                           454mm     ENDC
000001D8                           455mm     
000001D8                 FALSE     456mm     IFNE DEBUG
000001D8                           457mm     ENDC
000001D8                           458mm 
000001D8                           459mm     ENDM
000001D8                           460m     ENDC
000001D8                           461m     ENDM
000001D8                           462      
000001D8  B43C 0030                463      CMP.B #'0',D2
000001DC  6700 0CB0                464      BEQ HEX_DIGIT
000001E0  B43C 0031                465      CMP.B #'1',D2
000001E4  6700 0CA8                466      BEQ HEX_DIGIT
000001E8  B43C 0032                467      CMP.B #'2',D2
000001EC  6700 0CA0                468      BEQ HEX_DIGIT
000001F0  B43C 0033                469      CMP.B #'3',D2
000001F4  6700 0C98                470      BEQ HEX_DIGIT
000001F8  B43C 0034                471      CMP.B #'4',D2
000001FC  6700 0C90                472      BEQ HEX_DIGIT
00000200  B43C 0035                473      CMP.B #'5',D2
00000204  6700 0C88                474      BEQ HEX_DIGIT
00000208  B43C 0036                475      CMP.B #'6',D2
0000020C  6700 0C80                476      BEQ HEX_DIGIT
00000210  B43C 0037                477      CMP.B #'7',D2
00000214  6700 0C78                478      BEQ HEX_DIGIT
00000218  B43C 0038                479      CMP.B #'8',D2
0000021C  6700 0C70                480      BEQ HEX_DIGIT
00000220  B43C 0039                481      CMP.B #'9',D2
00000224  6700 0C68                482      BEQ HEX_DIGIT
00000228  B43C 0061                483      CMP.B #'a',D2
0000022C  6700 0C60                484      BEQ HEX_DIGIT
00000230  B43C 0062                485      CMP.B #'b',D2
00000234  6700 0C58                486      BEQ HEX_DIGIT
00000238  B43C 0063                487      CMP.B #'c',D2
0000023C  6700 0C50                488      BEQ HEX_DIGIT
00000240  B43C 0064                489      CMP.B #'d',D2
00000244  6700 0C48                490      BEQ HEX_DIGIT
00000248  B43C 0065                491      CMP.B #'e',D2
0000024C  6700 0C40                492      BEQ HEX_DIGIT
00000250  B43C 0066                493      CMP.B #'f',D2
00000254  6700 0C38                494      BEQ HEX_DIGIT
00000258                           495      
00000258  B43C 0077                496      CMP.B #'w',D2
0000025C  6700 015A                497      BEQ W
00000260                           498      
00000260  B43C 006C                499      CMP.B #'l',D2
00000264  6700 0ABC                500      BEQ L 
00000268                           501  
00000268                           502m     PRINT_CRLF D3
00000268                           503mm     PRINT_CHAR #13,D3                           ; CR
00000268                           504mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000268                 TRUE      505mm     IFEQ DEBUG
00000268  1639 00C00003            506mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000026E  0803 0002                507mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000272  67F4                     508mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000274  13FC 000D 00C00007       509mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000027C                           510mm     ENDC
0000027C                           511mm     
0000027C                 FALSE     512mm     IFNE DEBUG
0000027C                           513mm     ENDC
0000027C                           514mm 
0000027C                           515mm     ENDM
0000027C                           516mm     PRINT_CHAR #10,D3                           ; LF
0000027C                           517mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      518mm     IFEQ DEBUG
0000027C  1639 00C00003            519mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000282  0803 0002                520mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000286  67F4                     521mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00000288  13FC 000A 00C00007       522mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000290                           523mm     ENDC
00000290                           524mm     
00000290                 FALSE     525mm     IFNE DEBUG
00000290                           526mm     ENDC
00000290                           527mm 
00000290                           528mm     ENDM
00000290                           529m     ENDM
00000290                           530   
00000290  B43C 003F                531      CMP.B #'?',D2
00000294  6700 0050                532      BEQ H
00000298                           533  
00000298  B43C 0076                534      CMP.B #'v',D2
0000029C  6700 006E                535      BEQ V
000002A0                           536      
000002A0  B43C 0072                537      CMP.B #'r',D2
000002A4  6700 008C                538      BEQ R
000002A8                           539  
000002A8  B43C 0073                540      CMP.B #'s',D2
000002AC  6700 01D0                541      BEQ S
000002B0                           542  
000002B0  B43C 0067                543      CMP.B #'g',D2
000002B4  6700 095E                544      BEQ G   
000002B8                           545  
000002B8  B43C 007A                546      CMP.B #'z',D2
000002BC  6700 095E                547      BEQ Z   
000002C0                           548  
000002C0  41F9 00000F70            549      LEA HUH,A0
000002C6                           550m     PRINT_STR A0,D3
000002C6                           551m LOOP_19
000002C6  0C10 0000                552m     CMP.B #0,(A0)                               ; 0 -> DONE
000002CA  6700 0016                553m     BEQ EXIT_19
000002CE                           554mm     PRINT_CHAR (A0)+,D3
000002CE                           555mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002CE                 TRUE      556mm     IFEQ DEBUG
000002CE  1639 00C00003            557mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D4  0803 0002                558mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D8  67F4                     559mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
000002DA  13D8 00C00007            560mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E0                           561mm     ENDC
000002E0                           562mm     
000002E0                 FALSE     563mm     IFNE DEBUG
000002E0                           564mm     ENDC
000002E0                           565mm 
000002E0                           566mm     ENDM
000002E0  60E4                     567m     BRA LOOP_19
000002E2                           568m EXIT_19
000002E2                           569m     ENDM
000002E2                           570                         
000002E2  6000 FEA0                571      BRA MAIN_LOOP
000002E6                           572      
000002E6                           573  ; commands
000002E6                           574  H   
000002E6  41F9 00000ECB            575      LEA HELP,A0
000002EC                           576m     PRINT_STR A0,D3
000002EC                           577m LOOP_21
000002EC  0C10 0000                578m     CMP.B #0,(A0)                               ; 0 -> DONE
000002F0  6700 0016                579m     BEQ EXIT_21
000002F4                           580mm     PRINT_CHAR (A0)+,D3
000002F4                           581mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F4                 TRUE      582mm     IFEQ DEBUG
000002F4  1639 00C00003            583mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FA  0803 0002                584mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002FE  67F4                     585mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000300  13D8 00C00007            586mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000306                           587mm     ENDC
00000306                           588mm     
00000306                 FALSE     589mm     IFNE DEBUG
00000306                           590mm     ENDC
00000306                           591mm 
00000306                           592mm     ENDM
00000306  60E4                     593m     BRA LOOP_21
00000308                           594m EXIT_21
00000308                           595m     ENDM
00000308  6000 FE7A                596      BRA MAIN_LOOP
0000030C                           597  
0000030C                           598  V   
0000030C  41F9 00000EAE            599      LEA VERSION,A0
00000312                           600m     PRINT_STR A0,D3       
00000312                           601m LOOP_23
00000312  0C10 0000                602m     CMP.B #0,(A0)                               ; 0 -> DONE
00000316  6700 0016                603m     BEQ EXIT_23
0000031A                           604mm     PRINT_CHAR (A0)+,D3
0000031A                           605mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031A                 TRUE      606mm     IFEQ DEBUG
0000031A  1639 00C00003            607mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000320  0803 0002                608mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000324  67F4                     609mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000326  13D8 00C00007            610mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000032C                           611mm     ENDC
0000032C                           612mm     
0000032C                 FALSE     613mm     IFNE DEBUG
0000032C                           614mm     ENDC
0000032C                           615mm 
0000032C                           616mm     ENDM
0000032C  60E4                     617m     BRA LOOP_23
0000032E                           618m EXIT_23
0000032E                           619m     ENDM
0000032E  6000 FE54                620      BRA MAIN_LOOP
00000332                           621      
00000332                           622  R   
00000332  2047                     623      MOVE.L D7,A0                                ; address accumulator -> address register
00000334  2A10                     624      MOVE.L (A0),D5                              ; read the memory and print it
00000336                           625m     PRINT_REG D5,D3,D7,D6,A0
00000336                           626mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000336                           627mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000336                 TRUE      628mm     IFEQ DEBUG
00000336  1639 00C00003            629mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000033C  0803 0002                630mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000340  67F4                     631mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00000342  13FC 0030 00C00007       632mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000034A                           633mm     ENDC
0000034A                           634mm     
0000034A                 FALSE     635mm     IFNE DEBUG
0000034A                           636mm     ENDC
0000034A                           637mm 
0000034A                           638mm     ENDM
0000034A                           639mm     PRINT_CHAR #'x',D3
0000034A                           640mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000034A                 TRUE      641mm     IFEQ DEBUG
0000034A  1639 00C00003            642mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000350  0803 0002                643mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000354  67F4                     644mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
00000356  13FC 0078 00C00007       645mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000035E                           646mm     ENDC
0000035E                           647mm     
0000035E                 FALSE     648mm     IFNE DEBUG
0000035E                           649mm     ENDC
0000035E                           650mm 
0000035E                           651mm     ENDM
0000035E  7C07                     652m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000360                           653m LOOP_25
00000360                           654mm     BIN2HEX D5,D7,A0
00000360  41F9 00000FD4            655mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000366  E99D                     656mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000368  1E05                     657mm     MOVE.B D5,D7
0000036A  0287 0000000F            658mm     ANDI.L #$F,D7
00000370  1E30 7000                659mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000374                           660mm     ENDM
00000374                           661mm     PRINT_CHAR D7,D3
00000374                           662mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000374                 TRUE      663mm     IFEQ DEBUG
00000374  1639 00C00003            664mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000037A  0803 0002                665mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000037E  67F4                     666mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000380  13C7 00C00007            667mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000386                           668mm     ENDC
00000386                           669mm     
00000386                 FALSE     670mm     IFNE DEBUG
00000386                           671mm     ENDC
00000386                           672mm 
00000386                           673mm     ENDM
00000386  57CE FFD8                674m     DBEQ D6,LOOP_25
0000038A                           675m     ENDM
0000038A                           676m     PRINT_CRLF D3
0000038A                           677mm     PRINT_CHAR #13,D3                           ; CR
0000038A                           678mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                 TRUE      679mm     IFEQ DEBUG
0000038A  1639 00C00003            680mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000390  0803 0002                681mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000394  67F4                     682mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
00000396  13FC 000D 00C00007       683mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000039E                           684mm     ENDC
0000039E                           685mm     
0000039E                 FALSE     686mm     IFNE DEBUG
0000039E                           687mm     ENDC
0000039E                           688mm 
0000039E                           689mm     ENDM
0000039E                           690mm     PRINT_CHAR #10,D3                           ; LF
0000039E                           691mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                 TRUE      692mm     IFEQ DEBUG
0000039E  1639 00C00003            693mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003A4  0803 0002                694mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003A8  67F4                     695mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000003AA  13FC 000A 00C00007       696mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003B2                           697mm     ENDC
000003B2                           698mm     
000003B2                 FALSE     699mm     IFNE DEBUG
000003B2                           700mm     ENDC
000003B2                           701mm 
000003B2                           702mm     ENDM
000003B2                           703m     ENDM
000003B2  7E00                     704      MOVE.L #0,D7                                ; clear the now used address accumulator
000003B4  6000 FDCE                705      BRA MAIN_LOOP
000003B8                           706  
000003B8                           707  W
000003B8  7A00                     708      MOVE.L #0,D5                                ; D5 will be the value to write            
000003BA                           709  
000003BA                           710m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000003BA                           711m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BA                           712m 
000003BA                 TRUE      713m     IFEQ DEBUG
000003BA  1639 00C00003            714m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003C0  0803 0000                715m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003C4  67F4                     716m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
000003C6                           717m     ENDC
000003C6                           718m     
000003C6                           719mm     READ_CHAR D2
000003C6                 TRUE      720mm     IFEQ DEBUG
000003C6  1439 00C00007            721mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003CC                           722mm     ENDC
000003CC                 FALSE     723mm     IFNE DEBUG
000003CC                           724mm     ENDC
000003CC                           725mm      
000003CC  B43C 001B                726mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003D0  6700 FC36                727mm     BEQ START
000003D4                           728mm     ENDM
000003D4                           729m 
000003D4                 TRUE      730m     IFEQ DEBUG
000003D4                           731mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003D4                           732mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D4                 TRUE      733mm     IFEQ DEBUG
000003D4  1639 00C00003            734mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003DA  0803 0002                735mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003DE  67F4                     736mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
000003E0  13C2 00C00007            737mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003E6                           738mm     ENDC
000003E6                           739mm     
000003E6                 FALSE     740mm     IFNE DEBUG
000003E6                           741mm     ENDC
000003E6                           742mm 
000003E6                           743mm     ENDM
000003E6                           744m     ENDC
000003E6                           745m     ENDM
000003E6                           746m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003E6  41F9 00000FE4            747m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003EC  0402 0030                748m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F0  C4BC 000000FF            749m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003F6  1430 2000                750m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003FA                           751m     ENDM
000003FA  1A02                     752      MOVE.B D2,D5                                ; put at bottom of D5
000003FC                           753  
000003FC  3C3C 0006                754      MOVE #6,D6                                  ; 7 bytes left to read
00000400                           755      
00000400                           756  READ_DATA_TO_POKE
00000400  E98D                     757      LSL.L #4,D5                                 ; make what we have so far more significant
00000402                           758m     WAIT_CHAR D2,D3                             ; next character -> D2
00000402                           759m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           760m 
00000402                 TRUE      761m     IFEQ DEBUG
00000402  1639 00C00003            762m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000408  0803 0000                763m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000040C  67F4                     764m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
0000040E                           765m     ENDC
0000040E                           766m     
0000040E                           767mm     READ_CHAR D2
0000040E                 TRUE      768mm     IFEQ DEBUG
0000040E  1439 00C00007            769mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000414                           770mm     ENDC
00000414                 FALSE     771mm     IFNE DEBUG
00000414                           772mm     ENDC
00000414                           773mm      
00000414  B43C 001B                774mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                775mm     BEQ START
0000041C                           776mm     ENDM
0000041C                           777m 
0000041C                 TRUE      778m     IFEQ DEBUG
0000041C                           779mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000041C                           780mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      781mm     IFEQ DEBUG
0000041C  1639 00C00003            782mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000422  0803 0002                783mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000426  67F4                     784mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00000428  13C2 00C00007            785mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000042E                           786mm     ENDC
0000042E                           787mm     
0000042E                 FALSE     788mm     IFNE DEBUG
0000042E                           789mm     ENDC
0000042E                           790mm 
0000042E                           791mm     ENDM
0000042E                           792m     ENDC
0000042E                           793m     ENDM
0000042E                           794m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0000042E  41F9 00000FE4            795m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000434  0402 0030                796m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000438  C4BC 000000FF            797m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000043E  1430 2000                798m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000442                           799m     ENDM
00000442  8A02                     800      OR.B D2,D5
00000444  023C 00FB                801      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000448  57CE FFB6                802      DBEQ D6,READ_DATA_TO_POKE
0000044C                           803      
0000044C  2047                     804      MOVE.L D7,A0                                ; address accumulator -> address register
0000044E  7E00                     805      MOVE.L #0,D7                                ; clear the now used address accumulator
00000450                           806      
00000450  2085                     807      MOVE.L D5,(A0)                              ; write the data
00000452                           808  
00000452                           809m     PRINT_CRLF D3
00000452                           810mm     PRINT_CHAR #13,D3                           ; CR
00000452                           811mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                 TRUE      812mm     IFEQ DEBUG
00000452  1639 00C00003            813mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000458  0803 0002                814mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000045C  67F4                     815mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0000045E  13FC 000D 00C00007       816mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000466                           817mm     ENDC
00000466                           818mm     
00000466                 FALSE     819mm     IFNE DEBUG
00000466                           820mm     ENDC
00000466                           821mm 
00000466                           822mm     ENDM
00000466                           823mm     PRINT_CHAR #10,D3                           ; LF
00000466                           824mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000466                 TRUE      825mm     IFEQ DEBUG
00000466  1639 00C00003            826mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000046C  0803 0002                827mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000470  67F4                     828mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00000472  13FC 000A 00C00007       829mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000047A                           830mm     ENDC
0000047A                           831mm     
0000047A                 FALSE     832mm     IFNE DEBUG
0000047A                           833mm     ENDC
0000047A                           834mm 
0000047A                           835mm     ENDM
0000047A                           836m     ENDM
0000047A  6000 FD08                837      BRA MAIN_LOOP
0000047E                           838  
0000047E                           839  ; register map for S
0000047E                           840  ; A0 - start address
0000047E                           841  ; A1 - offset
0000047E                           842  ; A2 - next address to write
0000047E                           843  ; A3 - next location (jmp)
0000047E                           844  ; A4 - Working Address Register
0000047E                           845  ; D0 - record count
0000047E                           846  ; D1 - 'S', record type, data byte
0000047E                           847  ; D2 - checksum
0000047E                           848  ; D3 - data byte count
0000047E                           849  ; D4 - read address, moved into A2
0000047E                           850  ; D5 - temp
0000047E                           851  ; D6 - temp
0000047E                           852  ; D7 - temp
0000047E                           853  S
0000047E  2078 0000                854      MOVE.L 0,A0                                 ; start address -> A0
00000482  2247                     855      MOVE.L D7,A1                                ; grab the address accumulator (offset) into A1
00000484                           856      
00000484  7000                     857      MOVE.L #0,D0                                ; count of records read -> D0
00000486                           858          
00000486                           859  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
00000486                           860m     DOWNLOAD D1                 
00000486                           861m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                           862m 
00000486  1239 00C00003            863m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0000048C  0801 0000                864m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000490  6700 0010                865m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000494                           866m  
00000494                           867mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000494                 TRUE      868mm     IFEQ DEBUG
00000494  1239 00C00007            869mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
0000049A                           870mm     ENDC
0000049A                 FALSE     871mm     IFNE DEBUG
0000049A                           872mm     ENDC
0000049A                           873mm      
0000049A  B23C 001B                874mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0000049E  6700 FB68                875mm     BEQ START
000004A2                           876mm     ENDM
000004A2                           877m CONTINUE_44
000004A2  1239 00C00013            878m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
000004A8  0801 0000                879m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000004AC  67D8                     880m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
000004AE                           881m     
000004AE  1239 00C00017            882m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
000004B4  13C1 00E00001            883m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
000004BA                           884m     
000004BA                           885m     ENDM
000004BA  B23C 0053                886      CMP.B #'S',D1                               ; found S?    
000004BE  66C6                     887      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
000004C0                           888      
000004C0                           889m     PRINT_CHAR #'S',D5                          ; print the S
000004C0                           890m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                 TRUE      891m     IFEQ DEBUG
000004C0  1A39 00C00003            892m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004C6  0805 0002                893m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004CA  67F4                     894m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
000004CC  13FC 0053 00C00007       895m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000004D4                           896m     ENDC
000004D4                           897m     
000004D4                 FALSE     898m     IFNE DEBUG
000004D4                           899m     ENDC
000004D4                           900m 
000004D4                           901m     ENDM
000004D4  5280                     902      ADD.L #1,D0                                 ; read another S record, increment count
000004D6                           903      
000004D6                           904m     DOWNLOAD D1                                 ; read the record identifier and echo it back
000004D6                           905m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                           906m 
000004D6  1239 00C00003            907m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000004DC  0801 0000                908m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000004E0  6700 0010                909m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
000004E4                           910m  
000004E4                           911mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000004E4                 TRUE      912mm     IFEQ DEBUG
000004E4  1239 00C00007            913mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
000004EA                           914mm     ENDC
000004EA                 FALSE     915mm     IFNE DEBUG
000004EA                           916mm     ENDC
000004EA                           917mm      
000004EA  B23C 001B                918mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000004EE  6700 FB18                919mm     BEQ START
000004F2                           920mm     ENDM
000004F2                           921m CONTINUE_47
000004F2  1239 00C00013            922m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
000004F8  0801 0000                923m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000004FC  67D8                     924m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
000004FE                           925m     
000004FE  1239 00C00017            926m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
00000504  13C1 00E00001            927m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
0000050A                           928m     
0000050A                           929m     ENDM
0000050A                           930m     PRINT_CHAR D1,D5
0000050A                           931m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      932m     IFEQ DEBUG
0000050A  1A39 00C00003            933m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000510  0805 0002                934m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000514  67F4                     935m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00000516  13C1 00C00007            936m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000051C                           937m     ENDC
0000051C                           938m     
0000051C                 FALSE     939m     IFNE DEBUG
0000051C                           940m     ENDC
0000051C                           941m 
0000051C                           942m     ENDM
0000051C                           943  
0000051C  7400                     944      MOVE.L #0,D2                                ; clear the checksum
0000051E                           945  
0000051E  7600                     946      MOVE.L #0,D3                                ; read the 2 digit byte count -> D3
00000520                           947m     DOWNLOAD_BYTE D5,D3,D6,D7,D2,A4                                        
00000520  1E3C 0002                948m     MOVE.B #2,D7
00000524                           949m     WHILE.B D7 <GT> 0 DO
00000524                           950ms _10000000
00000524  BE38 0000                951ms     CMP.B   0,D7
00000528  6F00 0064                952ms     BLE _10000001
0000052C  E98B                     953m         LSL.L #4,D3                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000052E                           954mm         DOWNLOAD D5
0000052E                           955mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052E                           956mm 
0000052E  1A39 00C00003            957mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000534  0805 0000                958mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000538  6700 0010                959mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0000053C                           960mm  
0000053C                           961mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000053C                 TRUE      962mmm     IFEQ DEBUG
0000053C  1A39 00C00007            963mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000542                           964mmm     ENDC
00000542                 FALSE     965mmm     IFNE DEBUG
00000542                           966mmm     ENDC
00000542                           967mmm      
00000542  BA3C 001B                968mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000546  6700 FAC0                969mmm     BEQ START
0000054A                           970mmm     ENDM
0000054A                           971mm CONTINUE_51
0000054A  1A39 00C00013            972mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000550  0805 0000                973mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000554  67D8                     974mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00000556                           975mm     
00000556  1A39 00C00017            976mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000055C  13C5 00E00001            977mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000562                           978mm     
00000562                           979mm     ENDM
00000562                           980mm         PRINT_CHAR D5,D6
00000562                           981mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000562                 TRUE      982mm     IFEQ DEBUG
00000562  1C39 00C00003            983mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000568  0806 0002                984mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000056C  67F4                     985mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0000056E  13C5 00C00007            986mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000574                           987mm     ENDC
00000574                           988mm     
00000574                 FALSE     989mm     IFNE DEBUG
00000574                           990mm     ENDC
00000574                           991mm 
00000574                           992mm     ENDM
00000574                           993mm         HEX2BIN D5,D5,A4
00000574  49F9 00000FE4            994mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000057A  0405 0030                995mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  CABC 000000FF            996mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000584  1A34 5000                997mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000588                           998mm     ENDM
00000588  8605                     999m         OR.B D5,D3
0000058A  5307                    1000m         SUB.B #1,D7
0000058C                          1001m     ENDW
0000058C  6096                    1002ms     BRA _10000000
0000058E                          1003ms _10000001
0000058E                          1004m     
0000058E  7A00                    1005m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000590  1A03                    1006m     MOVE.B D3,D5
00000592  D483                    1007m     ADD.L D3,D2
00000594                          1008m 
00000594                          1009m     ENDM
00000594                          1010  
00000594                          1011      IF.B D1 <EQ> #'0' THEN.L                    ; header, just ignore it
00000594  B23C 0030               1012s     CMP.B   #'0',D1
00000598  6600 0032               1013s     BNE.L   _00000000
0000059C                          1014m         PRINT_CRLF D5
0000059C                          1015mm     PRINT_CHAR #13,D5                           ; CR
0000059C                          1016mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059C                 TRUE     1017mm     IFEQ DEBUG
0000059C  1A39 00C00003           1018mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000005A2  0805 0002               1019mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000005A6  67F4                    1020mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
000005A8  13FC 000D 00C00007      1021mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005B0                          1022mm     ENDC
000005B0                          1023mm     
000005B0                 FALSE    1024mm     IFNE DEBUG
000005B0                          1025mm     ENDC
000005B0                          1026mm 
000005B0                          1027mm     ENDM
000005B0                          1028mm     PRINT_CHAR #10,D5                           ; LF
000005B0                          1029mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                 TRUE     1030mm     IFEQ DEBUG
000005B0  1A39 00C00003           1031mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000005B6  0805 0002               1032mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000005BA  67F4                    1033mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
000005BC  13FC 000A 00C00007      1034mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005C4                          1035mm     ENDC
000005C4                          1036mm     
000005C4                 FALSE    1037mm     IFNE DEBUG
000005C4                          1038mm     ENDC
000005C4                          1039mm 
000005C4                          1040mm     ENDM
000005C4                          1041m     ENDM
000005C4  6000 FEC0               1042          BRA WAIT_FOR_SRECORD
000005C8                          1043      ELSE
000005C8  6000 0408               1044s     BRA _00000001
000005CC                          1045s _00000000
000005CC                          1046          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000005CC  B23C 0031               1047s     CMP.B   #'1',D1
000005D0  6708                    1048s     BEQ.S   _00000002
000005D2  B23C 0032               1049s     CMP.B   #'2',D1
000005D6  6600 0200               1050s     BNE.L   _00000003
000005DA                          1051s _00000002
000005DA  5783                    1052              SUB.L #3,D3                         ; subtract three bytes for 16 bit address and 1 byte checksum
000005DC                          1053      
000005DC  7800                    1054              MOVE.L #0,D4                        ; read two bytes of address
000005DE                          1055m             DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4     ; first byte                           
000005DE  1E3C 0002               1056m     MOVE.B #2,D7
000005E2                          1057m     WHILE.B D7 <GT> 0 DO
000005E2                          1058ms _10000002
000005E2  BE38 0000               1059ms     CMP.B   0,D7
000005E6  6F00 0064               1060ms     BLE _10000003
000005EA  E98C                    1061m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000005EC                          1062mm         DOWNLOAD D5
000005EC                          1063mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005EC                          1064mm 
000005EC  1A39 00C00003           1065mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005F2  0805 0000               1066mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005F6  6700 0010               1067mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
000005FA                          1068mm  
000005FA                          1069mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005FA                 TRUE     1070mmm     IFEQ DEBUG
000005FA  1A39 00C00007           1071mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000600                          1072mmm     ENDC
00000600                 FALSE    1073mmm     IFNE DEBUG
00000600                          1074mmm     ENDC
00000600                          1075mmm      
00000600  BA3C 001B               1076mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000604  6700 FA02               1077mmm     BEQ START
00000608                          1078mmm     ENDM
00000608                          1079mm CONTINUE_59
00000608  1A39 00C00013           1080mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000060E  0805 0000               1081mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000612  67D8                    1082mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00000614                          1083mm     
00000614  1A39 00C00017           1084mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000061A  13C5 00E00001           1085mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000620                          1086mm     
00000620                          1087mm     ENDM
00000620                          1088mm         PRINT_CHAR D5,D6
00000620                          1089mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                 TRUE     1090mm     IFEQ DEBUG
00000620  1C39 00C00003           1091mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000626  0806 0002               1092mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000062A  67F4                    1093mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
0000062C  13C5 00C00007           1094mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000632                          1095mm     ENDC
00000632                          1096mm     
00000632                 FALSE    1097mm     IFNE DEBUG
00000632                          1098mm     ENDC
00000632                          1099mm 
00000632                          1100mm     ENDM
00000632                          1101mm         HEX2BIN D5,D5,A4
00000632  49F9 00000FE4           1102mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000638  0405 0030               1103mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000063C  CABC 000000FF           1104mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000642  1A34 5000               1105mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000646                          1106mm     ENDM
00000646  8805                    1107m         OR.B D5,D4
00000648  5307                    1108m         SUB.B #1,D7
0000064A                          1109m     ENDW
0000064A  6096                    1110ms     BRA _10000002
0000064C                          1111ms _10000003
0000064C                          1112m     
0000064C  7A00                    1113m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000064E  1A04                    1114m     MOVE.B D4,D5
00000650  D484                    1115m     ADD.L D4,D2
00000652                          1116m 
00000652                          1117m     ENDM
00000652                          1118m             DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4     ; second one
00000652  1E3C 0002               1119m     MOVE.B #2,D7
00000656                          1120m     WHILE.B D7 <GT> 0 DO
00000656                          1121ms _10000004
00000656  BE38 0000               1122ms     CMP.B   0,D7
0000065A  6F00 0064               1123ms     BLE _10000005
0000065E  E98C                    1124m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000660                          1125mm         DOWNLOAD D5
00000660                          1126mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000660                          1127mm 
00000660  1A39 00C00003           1128mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000666  0805 0000               1129mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000066A  6700 0010               1130mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0000066E                          1131mm  
0000066E                          1132mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000066E                 TRUE     1133mmm     IFEQ DEBUG
0000066E  1A39 00C00007           1134mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000674                          1135mmm     ENDC
00000674                 FALSE    1136mmm     IFNE DEBUG
00000674                          1137mmm     ENDC
00000674                          1138mmm      
00000674  BA3C 001B               1139mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000678  6700 F98E               1140mmm     BEQ START
0000067C                          1141mmm     ENDM
0000067C                          1142mm CONTINUE_64
0000067C  1A39 00C00013           1143mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000682  0805 0000               1144mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000686  67D8                    1145mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000688                          1146mm     
00000688  1A39 00C00017           1147mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000068E  13C5 00E00001           1148mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000694                          1149mm     
00000694                          1150mm     ENDM
00000694                          1151mm         PRINT_CHAR D5,D6
00000694                          1152mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000694                 TRUE     1153mm     IFEQ DEBUG
00000694  1C39 00C00003           1154mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000069A  0806 0002               1155mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000069E  67F4                    1156mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
000006A0  13C5 00C00007           1157mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006A6                          1158mm     ENDC
000006A6                          1159mm     
000006A6                 FALSE    1160mm     IFNE DEBUG
000006A6                          1161mm     ENDC
000006A6                          1162mm 
000006A6                          1163mm     ENDM
000006A6                          1164mm         HEX2BIN D5,D5,A4
000006A6  49F9 00000FE4           1165mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000006AC  0405 0030               1166mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B0  CABC 000000FF           1167mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000006B6  1A34 5000               1168mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000006BA                          1169mm     ENDM
000006BA  8805                    1170m         OR.B D5,D4
000006BC  5307                    1171m         SUB.B #1,D7
000006BE                          1172m     ENDW
000006BE  6096                    1173ms     BRA _10000004
000006C0                          1174ms _10000005
000006C0                          1175m     
000006C0  7A00                    1176m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006C2  1A04                    1177m     MOVE.B D4,D5
000006C4  D484                    1178m     ADD.L D4,D2
000006C6                          1179m 
000006C6                          1180m     ENDM
000006C6                          1181              
000006C6                          1182              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
000006C6  B23C 0032               1183s     CMP.B   #'2',D1
000006CA  6600 0078               1184s     BNE.L   _00000004
000006CE  5383                    1185                  SUB.L #1,D3                     ; subtract an extra bytes for 24 bit address    
000006D0                          1186m                 DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4 ; 3rd byte       
000006D0  1E3C 0002               1187m     MOVE.B #2,D7
000006D4                          1188m     WHILE.B D7 <GT> 0 DO
000006D4                          1189ms _10000006
000006D4  BE38 0000               1190ms     CMP.B   0,D7
000006D8  6F00 0064               1191ms     BLE _10000007
000006DC  E98C                    1192m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000006DE                          1193mm         DOWNLOAD D5
000006DE                          1194mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DE                          1195mm 
000006DE  1A39 00C00003           1196mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006E4  0805 0000               1197mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006E8  6700 0010               1198mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
000006EC                          1199mm  
000006EC                          1200mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006EC                 TRUE     1201mmm     IFEQ DEBUG
000006EC  1A39 00C00007           1202mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000006F2                          1203mmm     ENDC
000006F2                 FALSE    1204mmm     IFNE DEBUG
000006F2                          1205mmm     ENDC
000006F2                          1206mmm      
000006F2  BA3C 001B               1207mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006F6  6700 F910               1208mmm     BEQ START
000006FA                          1209mmm     ENDM
000006FA                          1210mm CONTINUE_69
000006FA  1A39 00C00013           1211mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000700  0805 0000               1212mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000704  67D8                    1213mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00000706                          1214mm     
00000706  1A39 00C00017           1215mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000070C  13C5 00E00001           1216mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000712                          1217mm     
00000712                          1218mm     ENDM
00000712                          1219mm         PRINT_CHAR D5,D6
00000712                          1220mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1221mm     IFEQ DEBUG
00000712  1C39 00C00003           1222mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000718  0806 0002               1223mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1224mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0000071E  13C5 00C00007           1225mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000724                          1226mm     ENDC
00000724                          1227mm     
00000724                 FALSE    1228mm     IFNE DEBUG
00000724                          1229mm     ENDC
00000724                          1230mm 
00000724                          1231mm     ENDM
00000724                          1232mm         HEX2BIN D5,D5,A4
00000724  49F9 00000FE4           1233mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000072A  0405 0030               1234mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000072E  CABC 000000FF           1235mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000734  1A34 5000               1236mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000738                          1237mm     ENDM
00000738  8805                    1238m         OR.B D5,D4
0000073A  5307                    1239m         SUB.B #1,D7
0000073C                          1240m     ENDW
0000073C  6096                    1241ms     BRA _10000006
0000073E                          1242ms _10000007
0000073E                          1243m     
0000073E  7A00                    1244m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000740  1A04                    1245m     MOVE.B D4,D5
00000742  D484                    1246m     ADD.L D4,D2
00000744                          1247m 
00000744                          1248m     ENDM
00000744                          1249              ENDI
00000744                          1250s _00000004
00000744                          1251              
00000744  2444                    1252              MOVE.L D4,A2                        ; put the address in an address register
00000746  D5C9                    1253              ADD.L A1,A2                         ; add in the offset
00000748                          1254  
00000748                          1255              WHILE.L D3 <GT> #0 DO               ; read the data bytes                
00000748                          1256s _10000008
00000748  B6BC 00000000           1257s     CMP.L   #0,D3
0000074E  6F00 0080               1258s     BLE _10000009
00000752  7200                    1259                  MOVE.L #0,D1                    ; D1 holds the byte
00000754                          1260m                 DOWNLOAD_BYTE D5,D1,D6,D7,D2,A4 ; read it                               
00000754  1E3C 0002               1261m     MOVE.B #2,D7
00000758                          1262m     WHILE.B D7 <GT> 0 DO
00000758                          1263ms _1000000A
00000758  BE38 0000               1264ms     CMP.B   0,D7
0000075C  6F00 0064               1265ms     BLE _1000000B
00000760  E989                    1266m         LSL.L #4,D1                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000762                          1267mm         DOWNLOAD D5
00000762                          1268mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000762                          1269mm 
00000762  1A39 00C00003           1270mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000768  0805 0000               1271mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000076C  6700 0010               1272mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000770                          1273mm  
00000770                          1274mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000770                 TRUE     1275mmm     IFEQ DEBUG
00000770  1A39 00C00007           1276mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000776                          1277mmm     ENDC
00000776                 FALSE    1278mmm     IFNE DEBUG
00000776                          1279mmm     ENDC
00000776                          1280mmm      
00000776  BA3C 001B               1281mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000077A  6700 F88C               1282mmm     BEQ START
0000077E                          1283mmm     ENDM
0000077E                          1284mm CONTINUE_74
0000077E  1A39 00C00013           1285mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000784  0805 0000               1286mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000788  67D8                    1287mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0000078A                          1288mm     
0000078A  1A39 00C00017           1289mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000790  13C5 00E00001           1290mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000796                          1291mm     
00000796                          1292mm     ENDM
00000796                          1293mm         PRINT_CHAR D5,D6
00000796                          1294mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000796                 TRUE     1295mm     IFEQ DEBUG
00000796  1C39 00C00003           1296mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000079C  0806 0002               1297mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007A0  67F4                    1298mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
000007A2  13C5 00C00007           1299mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007A8                          1300mm     ENDC
000007A8                          1301mm     
000007A8                 FALSE    1302mm     IFNE DEBUG
000007A8                          1303mm     ENDC
000007A8                          1304mm 
000007A8                          1305mm     ENDM
000007A8                          1306mm         HEX2BIN D5,D5,A4
000007A8  49F9 00000FE4           1307mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000007AE  0405 0030               1308mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B2  CABC 000000FF           1309mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000007B8  1A34 5000               1310mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000007BC                          1311mm     ENDM
000007BC  8205                    1312m         OR.B D5,D1
000007BE  5307                    1313m         SUB.B #1,D7
000007C0                          1314m     ENDW
000007C0  6096                    1315ms     BRA _1000000A
000007C2                          1316ms _1000000B
000007C2                          1317m     
000007C2  7A00                    1318m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C4  1A01                    1319m     MOVE.B D1,D5
000007C6  D481                    1320m     ADD.L D1,D2
000007C8                          1321m 
000007C8                          1322m     ENDM
000007C8                          1323                          
000007C8  14C1                    1324                  MOVE.B D1,(A2)+                 ; store it!
000007CA                          1325  
000007CA  5383                    1326                  SUB.L #1,D3                     ; 1 less byte to go
000007CC                          1327              ENDW
000007CC  6000 FF7A               1328s     BRA _10000008
000007D0                          1329s _10000009
000007D0                          1330          
000007D0  47F8 0486               1331              LEA WAIT_FOR_SRECORD,A3             ; next place to go
000007D4                          1332          ELSE
000007D4  6000 01FC               1333s     BRA _00000005
000007D8                          1334s _00000003
000007D8                          1335              IF.B D1 <EQ> #'8' THEN.L            ; termination record, exit
000007D8  B23C 0038               1336s     CMP.B   #'8',D1
000007DC  6600 016C               1337s     BNE.L   _00000006
000007E0  7800                    1338                  MOVE.L #0,D4                    ; read the 24 bit start address
000007E2                          1339m                 DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4 ; top byte  
000007E2  1E3C 0002               1340m     MOVE.B #2,D7
000007E6                          1341m     WHILE.B D7 <GT> 0 DO
000007E6                          1342ms _1000000C
000007E6  BE38 0000               1343ms     CMP.B   0,D7
000007EA  6F00 0064               1344ms     BLE _1000000D
000007EE  E98C                    1345m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000007F0                          1346mm         DOWNLOAD D5
000007F0                          1347mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F0                          1348mm 
000007F0  1A39 00C00003           1349mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007F6  0805 0000               1350mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007FA  6700 0010               1351mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
000007FE                          1352mm  
000007FE                          1353mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007FE                 TRUE     1354mmm     IFEQ DEBUG
000007FE  1A39 00C00007           1355mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000804                          1356mmm     ENDC
00000804                 FALSE    1357mmm     IFNE DEBUG
00000804                          1358mmm     ENDC
00000804                          1359mmm      
00000804  BA3C 001B               1360mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000808  6700 F7FE               1361mmm     BEQ START
0000080C                          1362mmm     ENDM
0000080C                          1363mm CONTINUE_79
0000080C  1A39 00C00013           1364mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000812  0805 0000               1365mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000816  67D8                    1366mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
00000818                          1367mm     
00000818  1A39 00C00017           1368mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000081E  13C5 00E00001           1369mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000824                          1370mm     
00000824                          1371mm     ENDM
00000824                          1372mm         PRINT_CHAR D5,D6
00000824                          1373mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000824                 TRUE     1374mm     IFEQ DEBUG
00000824  1C39 00C00003           1375mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000082A  0806 0002               1376mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000082E  67F4                    1377mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00000830  13C5 00C00007           1378mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000836                          1379mm     ENDC
00000836                          1380mm     
00000836                 FALSE    1381mm     IFNE DEBUG
00000836                          1382mm     ENDC
00000836                          1383mm 
00000836                          1384mm     ENDM
00000836                          1385mm         HEX2BIN D5,D5,A4
00000836  49F9 00000FE4           1386mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000083C  0405 0030               1387mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000840  CABC 000000FF           1388mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000846  1A34 5000               1389mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
0000084A                          1390mm     ENDM
0000084A  8805                    1391m         OR.B D5,D4
0000084C  5307                    1392m         SUB.B #1,D7
0000084E                          1393m     ENDW
0000084E  6096                    1394ms     BRA _1000000C
00000850                          1395ms _1000000D
00000850                          1396m     
00000850  7A00                    1397m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000852  1A04                    1398m     MOVE.B D4,D5
00000854  D484                    1399m     ADD.L D4,D2
00000856                          1400m 
00000856                          1401m     ENDM
00000856                          1402m                 DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4 ; middle byte     
00000856  1E3C 0002               1403m     MOVE.B #2,D7
0000085A                          1404m     WHILE.B D7 <GT> 0 DO
0000085A                          1405ms _1000000E
0000085A  BE38 0000               1406ms     CMP.B   0,D7
0000085E  6F00 0064               1407ms     BLE _1000000F
00000862  E98C                    1408m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000864                          1409mm         DOWNLOAD D5
00000864                          1410mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000864                          1411mm 
00000864  1A39 00C00003           1412mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000086A  0805 0000               1413mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000086E  6700 0010               1414mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00000872                          1415mm  
00000872                          1416mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000872                 TRUE     1417mmm     IFEQ DEBUG
00000872  1A39 00C00007           1418mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000878                          1419mmm     ENDC
00000878                 FALSE    1420mmm     IFNE DEBUG
00000878                          1421mmm     ENDC
00000878                          1422mmm      
00000878  BA3C 001B               1423mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000087C  6700 F78A               1424mmm     BEQ START
00000880                          1425mmm     ENDM
00000880                          1426mm CONTINUE_84
00000880  1A39 00C00013           1427mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000886  0805 0000               1428mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000088A  67D8                    1429mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0000088C                          1430mm     
0000088C  1A39 00C00017           1431mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000892  13C5 00E00001           1432mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000898                          1433mm     
00000898                          1434mm     ENDM
00000898                          1435mm         PRINT_CHAR D5,D6
00000898                          1436mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000898                 TRUE     1437mm     IFEQ DEBUG
00000898  1C39 00C00003           1438mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000089E  0806 0002               1439mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008A2  67F4                    1440mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
000008A4  13C5 00C00007           1441mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008AA                          1442mm     ENDC
000008AA                          1443mm     
000008AA                 FALSE    1444mm     IFNE DEBUG
000008AA                          1445mm     ENDC
000008AA                          1446mm 
000008AA                          1447mm     ENDM
000008AA                          1448mm         HEX2BIN D5,D5,A4
000008AA  49F9 00000FE4           1449mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000008B0  0405 0030               1450mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B4  CABC 000000FF           1451mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000008BA  1A34 5000               1452mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000008BE                          1453mm     ENDM
000008BE  8805                    1454m         OR.B D5,D4
000008C0  5307                    1455m         SUB.B #1,D7
000008C2                          1456m     ENDW
000008C2  6096                    1457ms     BRA _1000000E
000008C4                          1458ms _1000000F
000008C4                          1459m     
000008C4  7A00                    1460m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C6  1A04                    1461m     MOVE.B D4,D5
000008C8  D484                    1462m     ADD.L D4,D2
000008CA                          1463m 
000008CA                          1464m     ENDM
000008CA                          1465m                 DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4 ; bottom byte
000008CA  1E3C 0002               1466m     MOVE.B #2,D7
000008CE                          1467m     WHILE.B D7 <GT> 0 DO
000008CE                          1468ms _10000010
000008CE  BE38 0000               1469ms     CMP.B   0,D7
000008D2  6F00 0064               1470ms     BLE _10000011
000008D6  E98C                    1471m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000008D8                          1472mm         DOWNLOAD D5
000008D8                          1473mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D8                          1474mm 
000008D8  1A39 00C00003           1475mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008DE  0805 0000               1476mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008E2  6700 0010               1477mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
000008E6                          1478mm  
000008E6                          1479mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008E6                 TRUE     1480mmm     IFEQ DEBUG
000008E6  1A39 00C00007           1481mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000008EC                          1482mmm     ENDC
000008EC                 FALSE    1483mmm     IFNE DEBUG
000008EC                          1484mmm     ENDC
000008EC                          1485mmm      
000008EC  BA3C 001B               1486mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008F0  6700 F716               1487mmm     BEQ START
000008F4                          1488mmm     ENDM
000008F4                          1489mm CONTINUE_89
000008F4  1A39 00C00013           1490mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000008FA  0805 0000               1491mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008FE  67D8                    1492mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00000900                          1493mm     
00000900  1A39 00C00017           1494mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000906  13C5 00E00001           1495mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000090C                          1496mm     
0000090C                          1497mm     ENDM
0000090C                          1498mm         PRINT_CHAR D5,D6
0000090C                          1499mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                 TRUE     1500mm     IFEQ DEBUG
0000090C  1C39 00C00003           1501mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000912  0806 0002               1502mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000916  67F4                    1503mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000918  13C5 00C00007           1504mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000091E                          1505mm     ENDC
0000091E                          1506mm     
0000091E                 FALSE    1507mm     IFNE DEBUG
0000091E                          1508mm     ENDC
0000091E                          1509mm 
0000091E                          1510mm     ENDM
0000091E                          1511mm         HEX2BIN D5,D5,A4
0000091E  49F9 00000FE4           1512mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000924  0405 0030               1513mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000928  CABC 000000FF           1514mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
0000092E  1A34 5000               1515mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000932                          1516mm     ENDM
00000932  8805                    1517m         OR.B D5,D4
00000934  5307                    1518m         SUB.B #1,D7
00000936                          1519m     ENDW
00000936  6096                    1520ms     BRA _10000010
00000938                          1521ms _10000011
00000938                          1522m     
00000938  7A00                    1523m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000093A  1A04                    1524m     MOVE.B D4,D5
0000093C  D484                    1525m     ADD.L D4,D2
0000093E                          1526m 
0000093E                          1527m     ENDM
0000093E                          1528                    
0000093E  2044                    1529                  MOVE.L D4,A0                    ; start address -> A0
00000940                          1530                  
00000940  47F9 00000B1C           1531                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000946                          1532              ELSE
00000946  6000 008A               1533s     BRA _00000007
0000094A                          1534s _00000006
0000094A                          1535m                 PRINT_CRLF D5
0000094A                          1536mm     PRINT_CHAR #13,D5                           ; CR
0000094A                          1537mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094A                 TRUE     1538mm     IFEQ DEBUG
0000094A  1A39 00C00003           1539mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000950  0805 0002               1540mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000954  67F4                    1541mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000956  13FC 000D 00C00007      1542mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000095E                          1543mm     ENDC
0000095E                          1544mm     
0000095E                 FALSE    1545mm     IFNE DEBUG
0000095E                          1546mm     ENDC
0000095E                          1547mm 
0000095E                          1548mm     ENDM
0000095E                          1549mm     PRINT_CHAR #10,D5                           ; LF
0000095E                          1550mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1551mm     IFEQ DEBUG
0000095E  1A39 00C00003           1552mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000964  0805 0002               1553mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000968  67F4                    1554mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0000096A  13FC 000A 00C00007      1555mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000972                          1556mm     ENDC
00000972                          1557mm     
00000972                 FALSE    1558mm     IFNE DEBUG
00000972                          1559mm     ENDC
00000972                          1560mm 
00000972                          1561mm     ENDM
00000972                          1562m     ENDM
00000972                          1563              
00000972  49F9 00000F99           1564                  LEA UNREC,A4                    ; warn for unrecognised type
00000978                          1565m                 PRINT_STR A4,D5
00000978                          1566m LOOP_96
00000978  0C14 0000               1567m     CMP.B #0,(A4)                               ; 0 -> DONE
0000097C  6700 0016               1568m     BEQ EXIT_96
00000980                          1569mm     PRINT_CHAR (A4)+,D5
00000980                          1570mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000980                 TRUE     1571mm     IFEQ DEBUG
00000980  1A39 00C00003           1572mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000986  0805 0002               1573mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000098A  67F4                    1574mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0000098C  13DC 00C00007           1575mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000992                          1576mm     ENDC
00000992                          1577mm     
00000992                 FALSE    1578mm     IFNE DEBUG
00000992                          1579mm     ENDC
00000992                          1580mm 
00000992                          1581mm     ENDM
00000992  60E4                    1582m     BRA LOOP_96
00000994                          1583m EXIT_96
00000994                          1584m     ENDM
00000994                          1585m                 PRINT_CHAR D1,D5
00000994                          1586m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000994                 TRUE     1587m     IFEQ DEBUG
00000994  1A39 00C00003           1588m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000099A  0805 0002               1589m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000099E  67F4                    1590m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000009A0  13C1 00C00007           1591m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009A6                          1592m     ENDC
000009A6                          1593m     
000009A6                 FALSE    1594m     IFNE DEBUG
000009A6                          1595m     ENDC
000009A6                          1596m 
000009A6                          1597m     ENDM
000009A6                          1598m                 PRINT_CRLF D5
000009A6                          1599mm     PRINT_CHAR #13,D5                           ; CR
000009A6                          1600mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A6                 TRUE     1601mm     IFEQ DEBUG
000009A6  1A39 00C00003           1602mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009AC  0805 0002               1603mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009B0  67F4                    1604mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000009B2  13FC 000D 00C00007      1605mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009BA                          1606mm     ENDC
000009BA                          1607mm     
000009BA                 FALSE    1608mm     IFNE DEBUG
000009BA                          1609mm     ENDC
000009BA                          1610mm 
000009BA                          1611mm     ENDM
000009BA                          1612mm     PRINT_CHAR #10,D5                           ; LF
000009BA                          1613mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BA                 TRUE     1614mm     IFEQ DEBUG
000009BA  1A39 00C00003           1615mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009C0  0805 0002               1616mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009C4  67F4                    1617mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
000009C6  13FC 000A 00C00007      1618mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009CE                          1619mm     ENDC
000009CE                          1620mm     
000009CE                 FALSE    1621mm     IFNE DEBUG
000009CE                          1622mm     ENDC
000009CE                          1623mm 
000009CE                          1624mm     ENDM
000009CE                          1625m     ENDM
000009CE                          1626              
000009CE  6000 FAB6               1627                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
000009D2                          1628              ENDI
000009D2                          1629s _00000007
000009D2                          1630          ENDI
000009D2                          1631s _00000005
000009D2                          1632      ENDI
000009D2                          1633s _00000001
000009D2                          1634      
000009D2  7800                    1635      MOVE.L #0,D4                                ; read the checksum from the data stream add to our checksum: should make it FF
000009D4                          1636m     DOWNLOAD_BYTE D5,D4,D6,D7,D2,A4                         
000009D4  1E3C 0002               1637m     MOVE.B #2,D7
000009D8                          1638m     WHILE.B D7 <GT> 0 DO
000009D8                          1639ms _10000012
000009D8  BE38 0000               1640ms     CMP.B   0,D7
000009DC  6F00 0064               1641ms     BLE _10000013
000009E0  E98C                    1642m         LSL.L #4,D4                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000009E2                          1643mm         DOWNLOAD D5
000009E2                          1644mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E2                          1645mm 
000009E2  1A39 00C00003           1646mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000009E8  0805 0000               1647mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000009EC  6700 0010               1648mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
000009F0                          1649mm  
000009F0                          1650mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000009F0                 TRUE     1651mmm     IFEQ DEBUG
000009F0  1A39 00C00007           1652mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000009F6                          1653mmm     ENDC
000009F6                 FALSE    1654mmm     IFNE DEBUG
000009F6                          1655mmm     ENDC
000009F6                          1656mmm      
000009F6  BA3C 001B               1657mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000009FA  6700 F60C               1658mmm     BEQ START
000009FE                          1659mmm     ENDM
000009FE                          1660mm CONTINUE_103
000009FE  1A39 00C00013           1661mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
00000A04  0805 0000               1662mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000A08  67D8                    1663mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00000A0A                          1664mm     
00000A0A  1A39 00C00017           1665mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000A10  13C5 00E00001           1666mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000A16                          1667mm     
00000A16                          1668mm     ENDM
00000A16                          1669mm         PRINT_CHAR D5,D6
00000A16                          1670mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1671mm     IFEQ DEBUG
00000A16  1C39 00C00003           1672mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000A1C  0806 0002               1673mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1674mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A22  13C5 00C00007           1675mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A28                          1676mm     ENDC
00000A28                          1677mm     
00000A28                 FALSE    1678mm     IFNE DEBUG
00000A28                          1679mm     ENDC
00000A28                          1680mm 
00000A28                          1681mm     ENDM
00000A28                          1682mm         HEX2BIN D5,D5,A4
00000A28  49F9 00000FE4           1683mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000A2E  0405 0030               1684mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A32  CABC 000000FF           1685mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000A38  1A34 5000               1686mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A3C                          1687mm     ENDM
00000A3C  8805                    1688m         OR.B D5,D4
00000A3E  5307                    1689m         SUB.B #1,D7
00000A40                          1690m     ENDW
00000A40  6096                    1691ms     BRA _10000012
00000A42                          1692ms _10000013
00000A42                          1693m     
00000A42  7A00                    1694m     MOVE.L #0,D5                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A44  1A04                    1695m     MOVE.B D4,D5
00000A46  D484                    1696m     ADD.L D4,D2
00000A48                          1697m 
00000A48                          1698m     ENDM
00000A48                          1699m     PRINT_CRLF D5
00000A48                          1700mm     PRINT_CHAR #13,D5                           ; CR
00000A48                          1701mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A48                 TRUE     1702mm     IFEQ DEBUG
00000A48  1A39 00C00003           1703mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A4E  0805 0002               1704mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A52  67F4                    1705mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A54  13FC 000D 00C00007      1706mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A5C                          1707mm     ENDC
00000A5C                          1708mm     
00000A5C                 FALSE    1709mm     IFNE DEBUG
00000A5C                          1710mm     ENDC
00000A5C                          1711mm 
00000A5C                          1712mm     ENDM
00000A5C                          1713mm     PRINT_CHAR #10,D5                           ; LF
00000A5C                          1714mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5C                 TRUE     1715mm     IFEQ DEBUG
00000A5C  1A39 00C00003           1716mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A62  0805 0002               1717mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A66  67F4                    1718mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A68  13FC 000A 00C00007      1719mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A70                          1720mm     ENDC
00000A70                          1721mm     
00000A70                 FALSE    1722mm     IFNE DEBUG
00000A70                          1723mm     ENDC
00000A70                          1724mm 
00000A70                          1725mm     ENDM
00000A70                          1726m     ENDM
00000A70                          1727          
00000A70                          1728      IF.B D2 <NE> #$FF THEN.L
00000A70  B43C 00FF               1729s     CMP.B   #$FF,D2
00000A74  6700 00A4               1730s     BEQ.L   _00000008
00000A78  49F9 00000FB0           1731          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000A7E                          1732m         PRINT_STR A4,D5
00000A7E                          1733m LOOP_110
00000A7E  0C14 0000               1734m     CMP.B #0,(A4)                               ; 0 -> DONE
00000A82  6700 0016               1735m     BEQ EXIT_110
00000A86                          1736mm     PRINT_CHAR (A4)+,D5
00000A86                          1737mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A86                 TRUE     1738mm     IFEQ DEBUG
00000A86  1A39 00C00003           1739mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A8C  0805 0002               1740mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A90  67F4                    1741mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A92  13DC 00C00007           1742mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A98                          1743mm     ENDC
00000A98                          1744mm     
00000A98                 FALSE    1745mm     IFNE DEBUG
00000A98                          1746mm     ENDC
00000A98                          1747mm 
00000A98                          1748mm     ENDM
00000A98  60E4                    1749m     BRA LOOP_110
00000A9A                          1750m EXIT_110
00000A9A                          1751m     ENDM
00000A9A                          1752m         PRINT_REG D0,D5,D2,D6,A4
00000A9A                          1753mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000A9A                          1754mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1755mm     IFEQ DEBUG
00000A9A  1A39 00C00003           1756mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AA0  0805 0002               1757mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1758mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000AA6  13FC 0030 00C00007      1759mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AAE                          1760mm     ENDC
00000AAE                          1761mm     
00000AAE                 FALSE    1762mm     IFNE DEBUG
00000AAE                          1763mm     ENDC
00000AAE                          1764mm 
00000AAE                          1765mm     ENDM
00000AAE                          1766mm     PRINT_CHAR #'x',D5
00000AAE                          1767mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAE                 TRUE     1768mm     IFEQ DEBUG
00000AAE  1A39 00C00003           1769mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AB4  0805 0002               1770mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AB8  67F4                    1771mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000ABA  13FC 0078 00C00007      1772mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AC2                          1773mm     ENDC
00000AC2                          1774mm     
00000AC2                 FALSE    1775mm     IFNE DEBUG
00000AC2                          1776mm     ENDC
00000AC2                          1777mm 
00000AC2                          1778mm     ENDM
00000AC2  7C07                    1779m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AC4                          1780m LOOP_112
00000AC4                          1781mm     BIN2HEX D0,D2,A4
00000AC4  49F9 00000FD4           1782mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000ACA  E998                    1783mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000ACC  1400                    1784mm     MOVE.B D0,D2
00000ACE  0282 0000000F           1785mm     ANDI.L #$F,D2
00000AD4  1434 2000               1786mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000AD8                          1787mm     ENDM
00000AD8                          1788mm     PRINT_CHAR D2,D5
00000AD8                          1789mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1790mm     IFEQ DEBUG
00000AD8  1A39 00C00003           1791mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ADE  0805 0002               1792mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1793mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000AE4  13C2 00C00007           1794mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AEA                          1795mm     ENDC
00000AEA                          1796mm     
00000AEA                 FALSE    1797mm     IFNE DEBUG
00000AEA                          1798mm     ENDC
00000AEA                          1799mm 
00000AEA                          1800mm     ENDM
00000AEA  57CE FFD8               1801m     DBEQ D6,LOOP_112
00000AEE                          1802m     ENDM
00000AEE                          1803m         PRINT_CRLF D5
00000AEE                          1804mm     PRINT_CHAR #13,D5                           ; CR
00000AEE                          1805mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEE                 TRUE     1806mm     IFEQ DEBUG
00000AEE  1A39 00C00003           1807mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AF4  0805 0002               1808mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AF8  67F4                    1809mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AFA  13FC 000D 00C00007      1810mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B02                          1811mm     ENDC
00000B02                          1812mm     
00000B02                 FALSE    1813mm     IFNE DEBUG
00000B02                          1814mm     ENDC
00000B02                          1815mm 
00000B02                          1816mm     ENDM
00000B02                          1817mm     PRINT_CHAR #10,D5                           ; LF
00000B02                          1818mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B02                 TRUE     1819mm     IFEQ DEBUG
00000B02  1A39 00C00003           1820mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B08  0805 0002               1821mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B0C  67F4                    1822mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B0E  13FC 000A 00C00007      1823mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B16                          1824mm     ENDC
00000B16                          1825mm     
00000B16                 FALSE    1826mm     IFNE DEBUG
00000B16                          1827mm     ENDC
00000B16                          1828mm 
00000B16                          1829mm     ENDM
00000B16                          1830m     ENDM
00000B16  6000 F66C               1831          BRA MAIN_LOOP
00000B1A                          1832      ENDI
00000B1A                          1833s _00000008
00000B1A                          1834      
00000B1A  4ED3                    1835      JMP (A3)
00000B1C                          1836  DOWNLOAD_DONE
00000B1C                          1837m     PRINT_REG D0,D5,D6,D2,A1                    ; print out number of Srecords read
00000B1C                          1838mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000B1C                          1839mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1C                 TRUE     1840mm     IFEQ DEBUG
00000B1C  1A39 00C00003           1841mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B22  0805 0002               1842mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B26  67F4                    1843mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B28  13FC 0030 00C00007      1844mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B30                          1845mm     ENDC
00000B30                          1846mm     
00000B30                 FALSE    1847mm     IFNE DEBUG
00000B30                          1848mm     ENDC
00000B30                          1849mm 
00000B30                          1850mm     ENDM
00000B30                          1851mm     PRINT_CHAR #'x',D5
00000B30                          1852mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1853mm     IFEQ DEBUG
00000B30  1A39 00C00003           1854mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B36  0805 0002               1855mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1856mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000B3C  13FC 0078 00C00007      1857mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B44                          1858mm     ENDC
00000B44                          1859mm     
00000B44                 FALSE    1860mm     IFNE DEBUG
00000B44                          1861mm     ENDC
00000B44                          1862mm 
00000B44                          1863mm     ENDM
00000B44  7407                    1864m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1865m LOOP_120
00000B46                          1866mm     BIN2HEX D0,D6,A1
00000B46  43F9 00000FD4           1867mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B4C  E998                    1868mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1C00                    1869mm     MOVE.B D0,D6
00000B50  0286 0000000F           1870mm     ANDI.L #$F,D6
00000B56  1C31 6000               1871mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1872mm     ENDM
00000B5A                          1873mm     PRINT_CHAR D6,D5
00000B5A                          1874mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1875mm     IFEQ DEBUG
00000B5A  1A39 00C00003           1876mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B60  0805 0002               1877mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1878mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B66  13C6 00C00007           1879mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1880mm     ENDC
00000B6C                          1881mm     
00000B6C                 FALSE    1882mm     IFNE DEBUG
00000B6C                          1883mm     ENDC
00000B6C                          1884mm 
00000B6C                          1885mm     ENDM
00000B6C  57CA FFD8               1886m     DBEQ D2,LOOP_120
00000B70                          1887m     ENDM
00000B70  43F9 00000F77           1888      LEA READ,A1
00000B76                          1889m     PRINT_STR A1,D5
00000B76                          1890m LOOP_125
00000B76  0C11 0000               1891m     CMP.B #0,(A1)                               ; 0 -> DONE
00000B7A  6700 0016               1892m     BEQ EXIT_125
00000B7E                          1893mm     PRINT_CHAR (A1)+,D5
00000B7E                          1894mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1895mm     IFEQ DEBUG
00000B7E  1A39 00C00003           1896mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B84  0805 0002               1897mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1898mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B8A  13D9 00C00007           1899mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1900mm     ENDC
00000B90                          1901mm     
00000B90                 FALSE    1902mm     IFNE DEBUG
00000B90                          1903mm     ENDC
00000B90                          1904mm 
00000B90                          1905mm     ENDM
00000B90  60E4                    1906m     BRA LOOP_125
00000B92                          1907m EXIT_125
00000B92                          1908m     ENDM
00000B92  2E08                    1909      MOVE.L A0,D7                                ; set address accumulator to start address
00000B94                          1910m     PRINT_REG D7,D5,D6,D2,A1                    ; print out start address
00000B94                          1911mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000B94                          1912mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B94                 TRUE     1913mm     IFEQ DEBUG
00000B94  1A39 00C00003           1914mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B9A  0805 0002               1915mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B9E  67F4                    1916mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BA0  13FC 0030 00C00007      1917mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BA8                          1918mm     ENDC
00000BA8                          1919mm     
00000BA8                 FALSE    1920mm     IFNE DEBUG
00000BA8                          1921mm     ENDC
00000BA8                          1922mm 
00000BA8                          1923mm     ENDM
00000BA8                          1924mm     PRINT_CHAR #'x',D5
00000BA8                          1925mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA8                 TRUE     1926mm     IFEQ DEBUG
00000BA8  1A39 00C00003           1927mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000BAE  0805 0002               1928mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000BB2  67F4                    1929mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BB4  13FC 0078 00C00007      1930mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BBC                          1931mm     ENDC
00000BBC                          1932mm     
00000BBC                 FALSE    1933mm     IFNE DEBUG
00000BBC                          1934mm     ENDC
00000BBC                          1935mm 
00000BBC                          1936mm     ENDM
00000BBC  7407                    1937m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBE                          1938m LOOP_127
00000BBE                          1939mm     BIN2HEX D7,D6,A1
00000BBE  43F9 00000FD4           1940mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000BC4  E99F                    1941mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC6  1C07                    1942mm     MOVE.B D7,D6
00000BC8  0286 0000000F           1943mm     ANDI.L #$F,D6
00000BCE  1C31 6000               1944mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000BD2                          1945mm     ENDM
00000BD2                          1946mm     PRINT_CHAR D6,D5
00000BD2                          1947mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                 TRUE     1948mm     IFEQ DEBUG
00000BD2  1A39 00C00003           1949mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000BD8  0805 0002               1950mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000BDC  67F4                    1951mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000BDE  13C6 00C00007           1952mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BE4                          1953mm     ENDC
00000BE4                          1954mm     
00000BE4                 FALSE    1955mm     IFNE DEBUG
00000BE4                          1956mm     ENDC
00000BE4                          1957mm 
00000BE4                          1958mm     ENDM
00000BE4  57CA FFD8               1959m     DBEQ D2,LOOP_127
00000BE8                          1960m     ENDM
00000BE8                          1961m     PRINT_CRLF D5     
00000BE8                          1962mm     PRINT_CHAR #13,D5                           ; CR
00000BE8                          1963mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE8                 TRUE     1964mm     IFEQ DEBUG
00000BE8  1A39 00C00003           1965mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000BEE  0805 0002               1966mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000BF2  67F4                    1967mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000BF4  13FC 000D 00C00007      1968mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BFC                          1969mm     ENDC
00000BFC                          1970mm     
00000BFC                 FALSE    1971mm     IFNE DEBUG
00000BFC                          1972mm     ENDC
00000BFC                          1973mm 
00000BFC                          1974mm     ENDM
00000BFC                          1975mm     PRINT_CHAR #10,D5                           ; LF
00000BFC                          1976mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BFC                 TRUE     1977mm     IFEQ DEBUG
00000BFC  1A39 00C00003           1978mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000C02  0805 0002               1979mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000C06  67F4                    1980mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C08  13FC 000A 00C00007      1981mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000C10                          1982mm     ENDC
00000C10                          1983mm     
00000C10                 FALSE    1984mm     IFNE DEBUG
00000C10                          1985mm     ENDC
00000C10                          1986mm 
00000C10                          1987mm     ENDM
00000C10                          1988m     ENDM
00000C10                          1989          
00000C10  6000 F572               1990      BRA MAIN_LOOP
00000C14                          1991      
00000C14                          1992  G
00000C14  2047                    1993      MOVE.L D7,A0                                ; address accumulator -> address register
00000C16  3E3C 0000               1994      MOVE #0,D7                                  ; clear the now used address accumulator
00000C1A  4ED0                    1995      JMP (A0)                                    ; jump to it!
00000C1C                          1996      
00000C1C                          1997  Z
00000C1C  207C 00200000           1998      MOVE.L #RAM,A0                              ; address of RAM
00000C22  7000                    1999      MOVE.L #0,D0                                ; number of bytes
00000C24                          2000     
00000C24                          2001      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C24                          2002s _10000014
00000C24  B0BC 00040000           2003s     CMP.L   #$40000,D0
00000C2A  6E00 001A               2004s     BGT _10000015
00000C2E  2200                    2005          MOVE.L D0,D1                            ; progress update
00000C30  E089                    2006          LSR.L #8,D1 
00000C32  E089                    2007          LSR.L #8,D1
00000C34  0281 0000000F           2008          ANDI.L #$F,D1
00000C3A  13C1 00E00001           2009          MOVE.B D1,DISPLAY
00000C40                          2010  
00000C40  20C0                    2011          MOVE.L D0,(A0)+ 
00000C42  5880                    2012          ADD.L #4,D0
00000C44                          2013      ENDW
00000C44  60DE                    2014s     BRA _10000014
00000C46                          2015s _10000015
00000C46                          2016   
00000C46  207C 00200000           2017      MOVE.L #RAM,A0                              ; address of RAM
00000C4C  7000                    2018      MOVE.L #0,D0                                ; number of bytes
00000C4E                          2019     
00000C4E                          2020      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C4E                          2021s _10000016
00000C4E  B0BC 00040000           2022s     CMP.L   #$40000,D0
00000C54  6E00 00C8               2023s     BGT _10000017
00000C58  2200                    2024          MOVE.L D0,D1                            ; progress update
00000C5A  E089                    2025          LSR.L #8,D1
00000C5C  E089                    2026          LSR.L #8,D1
00000C5E  0281 0000000F           2027          ANDI.L #$F,D1
00000C64  13C1 00E00001           2028          MOVE.B D1,DISPLAY
00000C6A                          2029  
00000C6A  2218                    2030          MOVE.L (A0)+,D1
00000C6C                          2031            
00000C6C                          2032          IF.L D0 <EQ> D1 THEN
00000C6C  B081                    2033s     CMP.L   D1,D0
00000C6E  6600 0006               2034s     BNE _00000009
00000C72  6000 00A4               2035              BRA OK
00000C76                          2036          ENDI 
00000C76                          2037s _00000009
00000C76                          2038            
00000C76  43F9 00000FC2           2039          LEA RAM_ERROR,A1
00000C7C                          2040m         PRINT_STR A1,D1
00000C7C                          2041m LOOP_135
00000C7C  0C11 0000               2042m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C80  6700 0016               2043m     BEQ EXIT_135
00000C84                          2044mm     PRINT_CHAR (A1)+,D1
00000C84                          2045mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C84                 TRUE     2046mm     IFEQ DEBUG
00000C84  1239 00C00003           2047mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C8A  0801 0002               2048mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C8E  67F4                    2049mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C90  13D9 00C00007           2050mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C96                          2051mm     ENDC
00000C96                          2052mm     
00000C96                 FALSE    2053mm     IFNE DEBUG
00000C96                          2054mm     ENDC
00000C96                          2055mm 
00000C96                          2056mm     ENDM
00000C96  60E4                    2057m     BRA LOOP_135
00000C98                          2058m EXIT_135
00000C98                          2059m     ENDM
00000C98  2208                    2060          MOVE.L A0,D1
00000C9A  5981                    2061          SUB.L #4,D1
00000C9C                          2062m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C9C                          2063mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000C9C                          2064mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9C                 TRUE     2065mm     IFEQ DEBUG
00000C9C  1639 00C00003           2066mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CA2  0803 0002               2067mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA6  67F4                    2068mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000CA8  13FC 0030 00C00007      2069mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CB0                          2070mm     ENDC
00000CB0                          2071mm     
00000CB0                 FALSE    2072mm     IFNE DEBUG
00000CB0                          2073mm     ENDC
00000CB0                          2074mm 
00000CB0                          2075mm     ENDM
00000CB0                          2076mm     PRINT_CHAR #'x',D3
00000CB0                          2077mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB0                 TRUE     2078mm     IFEQ DEBUG
00000CB0  1639 00C00003           2079mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB6  0803 0002               2080mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CBA  67F4                    2081mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CBC  13FC 0078 00C00007      2082mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CC4                          2083mm     ENDC
00000CC4                          2084mm     
00000CC4                 FALSE    2085mm     IFNE DEBUG
00000CC4                          2086mm     ENDC
00000CC4                          2087mm 
00000CC4                          2088mm     ENDM
00000CC4  7C07                    2089m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CC6                          2090m LOOP_137
00000CC6                          2091mm     BIN2HEX D1,D2,A1
00000CC6  43F9 00000FD4           2092mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000CCC  E999                    2093mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CCE  1401                    2094mm     MOVE.B D1,D2
00000CD0  0282 0000000F           2095mm     ANDI.L #$F,D2
00000CD6  1431 2000               2096mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000CDA                          2097mm     ENDM
00000CDA                          2098mm     PRINT_CHAR D2,D3
00000CDA                          2099mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDA                 TRUE     2100mm     IFEQ DEBUG
00000CDA  1639 00C00003           2101mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE0  0803 0002               2102mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE4  67F4                    2103mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CE6  13C2 00C00007           2104mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CEC                          2105mm     ENDC
00000CEC                          2106mm     
00000CEC                 FALSE    2107mm     IFNE DEBUG
00000CEC                          2108mm     ENDC
00000CEC                          2109mm 
00000CEC                          2110mm     ENDM
00000CEC  57CE FFD8               2111m     DBEQ D6,LOOP_137
00000CF0                          2112m     ENDM
00000CF0                          2113m         PRINT_CRLF D3
00000CF0                          2114mm     PRINT_CHAR #13,D3                           ; CR
00000CF0                          2115mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF0                 TRUE     2116mm     IFEQ DEBUG
00000CF0  1639 00C00003           2117mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CF6  0803 0002               2118mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CFA  67F4                    2119mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CFC  13FC 000D 00C00007      2120mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D04                          2121mm     ENDC
00000D04                          2122mm     
00000D04                 FALSE    2123mm     IFNE DEBUG
00000D04                          2124mm     ENDC
00000D04                          2125mm 
00000D04                          2126mm     ENDM
00000D04                          2127mm     PRINT_CHAR #10,D3                           ; LF
00000D04                          2128mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D04                 TRUE     2129mm     IFEQ DEBUG
00000D04  1639 00C00003           2130mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D0A  0803 0002               2131mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0E  67F4                    2132mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D10  13FC 000A 00C00007      2133mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D18                          2134mm     ENDC
00000D18                          2135mm     
00000D18                 FALSE    2136mm     IFNE DEBUG
00000D18                          2137mm     ENDC
00000D18                          2138mm 
00000D18                          2139mm     ENDM
00000D18                          2140m     ENDM
00000D18                          2141  OK    
00000D18  5880                    2142          ADD.L #4,D0
00000D1A                          2143      ENDW
00000D1A  6000 FF32               2144s     BRA _10000016
00000D1E                          2145s _10000017
00000D1E                          2146      
00000D1E  6000 F464               2147      BRA MAIN_LOOP
00000D22                          2148    
00000D22                          2149  L
00000D22  7A00                    2150      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000D24                          2151  
00000D24                          2152m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000D24                          2153m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D24                          2154m 
00000D24                 TRUE     2155m     IFEQ DEBUG
00000D24  1639 00C00003           2156m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D2A  0803 0000               2157m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D2E  67F4                    2158m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D30                          2159m     ENDC
00000D30                          2160m     
00000D30                          2161mm     READ_CHAR D2
00000D30                 TRUE     2162mm     IFEQ DEBUG
00000D30  1439 00C00007           2163mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D36                          2164mm     ENDC
00000D36                 FALSE    2165mm     IFNE DEBUG
00000D36                          2166mm     ENDC
00000D36                          2167mm      
00000D36  B43C 001B               2168mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D3A  6700 F2CC               2169mm     BEQ START
00000D3E                          2170mm     ENDM
00000D3E                          2171m 
00000D3E                 TRUE     2172m     IFEQ DEBUG
00000D3E                          2173mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D3E                          2174mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                 TRUE     2175mm     IFEQ DEBUG
00000D3E  1639 00C00003           2176mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D44  0803 0002               2177mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D48  67F4                    2178mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D4A  13C2 00C00007           2179mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D50                          2180mm     ENDC
00000D50                          2181mm     
00000D50                 FALSE    2182mm     IFNE DEBUG
00000D50                          2183mm     ENDC
00000D50                          2184mm 
00000D50                          2185mm     ENDM
00000D50                          2186m     ENDC
00000D50                          2187m     ENDM
00000D50                          2188m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D50  41F9 00000FE4           2189m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D56  0402 0030               2190m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D5A  C4BC 000000FF           2191m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D60  1430 2000               2192m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D64                          2193m     ENDM
00000D64  1A02                    2194      MOVE.B D2,D5                                ; put at bottom of D5
00000D66                          2195  
00000D66  3C3C 0002               2196      MOVE #2,D6                                  ; 3 bytes left to read
00000D6A                          2197      
00000D6A                          2198  READ_LENGTH
00000D6A  E98D                    2199      LSL.L #4,D5                                 ; make what we have so far more significant
00000D6C                          2200m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D6C                          2201m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6C                          2202m 
00000D6C                 TRUE     2203m     IFEQ DEBUG
00000D6C  1639 00C00003           2204m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D72  0803 0000               2205m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D76  67F4                    2206m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D78                          2207m     ENDC
00000D78                          2208m     
00000D78                          2209mm     READ_CHAR D2
00000D78                 TRUE     2210mm     IFEQ DEBUG
00000D78  1439 00C00007           2211mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D7E                          2212mm     ENDC
00000D7E                 FALSE    2213mm     IFNE DEBUG
00000D7E                          2214mm     ENDC
00000D7E                          2215mm      
00000D7E  B43C 001B               2216mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D82  6700 F284               2217mm     BEQ START
00000D86                          2218mm     ENDM
00000D86                          2219m 
00000D86                 TRUE     2220m     IFEQ DEBUG
00000D86                          2221mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D86                          2222mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D86                 TRUE     2223mm     IFEQ DEBUG
00000D86  1639 00C00003           2224mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D8C  0803 0002               2225mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D90  67F4                    2226mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000D92  13C2 00C00007           2227mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D98                          2228mm     ENDC
00000D98                          2229mm     
00000D98                 FALSE    2230mm     IFNE DEBUG
00000D98                          2231mm     ENDC
00000D98                          2232mm 
00000D98                          2233mm     ENDM
00000D98                          2234m     ENDC
00000D98                          2235m     ENDM
00000D98                          2236m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D98  41F9 00000FE4           2237m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D9E  0402 0030               2238m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DA2  C4BC 000000FF           2239m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000DA8  1430 2000               2240m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000DAC                          2241m     ENDM
00000DAC  8A02                    2242      OR.B D2,D5
00000DAE  023C 00FB               2243      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DB2  57CE FFB6               2244      DBEQ D6,READ_LENGTH
00000DB6                          2245          
00000DB6                          2246m     PRINT_CRLF D3
00000DB6                          2247mm     PRINT_CHAR #13,D3                           ; CR
00000DB6                          2248mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB6                 TRUE     2249mm     IFEQ DEBUG
00000DB6  1639 00C00003           2250mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DBC  0803 0002               2251mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DC0  67F4                    2252mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC2  13FC 000D 00C00007      2253mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DCA                          2254mm     ENDC
00000DCA                          2255mm     
00000DCA                 FALSE    2256mm     IFNE DEBUG
00000DCA                          2257mm     ENDC
00000DCA                          2258mm 
00000DCA                          2259mm     ENDM
00000DCA                          2260mm     PRINT_CHAR #10,D3                           ; LF
00000DCA                          2261mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DCA                 TRUE     2262mm     IFEQ DEBUG
00000DCA  1639 00C00003           2263mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DD0  0803 0002               2264mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DD4  67F4                    2265mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000DD6  13FC 000A 00C00007      2266mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DDE                          2267mm     ENDC
00000DDE                          2268mm     
00000DDE                 FALSE    2269mm     IFNE DEBUG
00000DDE                          2270mm     ENDC
00000DDE                          2271mm 
00000DDE                          2272mm     ENDM
00000DDE                          2273m     ENDM
00000DDE                          2274  
00000DDE  207C 00000000           2275      MOVE.L #ROM,A0                              ; start of ROM
00000DE4                          2276      
00000DE4  2247                    2277      MOVE.L D7,A1                                ; address accumulator -> address register
00000DE6  7E00                    2278      MOVE.L #0,D7                                ; clear the now used address accumulator
00000DE8                          2279      
00000DE8  267C 00002AAA           2280      MOVE.L #$2AAA,A3
00000DEE  36BC AAAA               2281      MOVE.W #$AAAA,(A3)
00000DF2  267C 00001554           2282      MOVE.L #$1554,A3
00000DF8  36BC 5555               2283      MOVE.W #$5555,(A3)
00000DFC  267C 00002AAA           2284      MOVE.L #$2AAA,A3
00000E02  36BC 8080               2285      MOVE.W #$8080,(A3)
00000E06  267C 00002AAA           2286      MOVE.L #$2AAA,A3
00000E0C  36BC AAAA               2287      MOVE.W #$AAAA,(A3)
00000E10  267C 00001554           2288      MOVE.L #$1554,A3
00000E16  36BC 5555               2289      MOVE.W #$5555,(A3)
00000E1A  267C 00002AAA           2290      MOVE.L #$2AAA,A3
00000E20  36BC 2020               2291      MOVE.W #$2020,(A3)
00000E24                          2292      
00000E24  45F9 00000FFB           2293      LEA LOADING,A2                              ; important for timing
00000E2A                          2294m     PRINT_STR A2,D3
00000E2A                          2295m LOOP_156
00000E2A  0C12 0000               2296m     CMP.B #0,(A2)                               ; 0 -> DONE
00000E2E  6700 0016               2297m     BEQ EXIT_156
00000E32                          2298mm     PRINT_CHAR (A2)+,D3
00000E32                          2299mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E32                 TRUE     2300mm     IFEQ DEBUG
00000E32  1639 00C00003           2301mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E38  0803 0002               2302mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E3C  67F4                    2303mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E3E  13DA 00C00007           2304mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E44                          2305mm     ENDC
00000E44                          2306mm     
00000E44                 FALSE    2307mm     IFNE DEBUG
00000E44                          2308mm     ENDC
00000E44                          2309mm 
00000E44                          2310mm     ENDM
00000E44  60E4                    2311m     BRA LOOP_156
00000E46                          2312m EXIT_156
00000E46                          2313m     ENDM
00000E46                          2314  
00000E46  023C 00FB               2315      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000E4A                          2316      
00000E4A                          2317      WHILE D5 <GT> #0 DO
00000E4A                          2318s _10000018
00000E4A  BA7C 0000               2319s     CMP.W   #0,D5
00000E4E  6F00 001C               2320s     BLE _10000019
00000E52  5585                    2321          SUB.L #2,D5
00000E54                          2322            
00000E54  13D1 00E00001           2323          MOVE.B (A1),DISPLAY
00000E5A  3091                    2324          MOVE.W (A1),(A0)                        ; write the data
00000E5C                          2325        
00000E5C                          2326  WAIT_FOR_COMPLETE
00000E5C  3410                    2327          MOVE.W (A0),D2
00000E5E                          2328  
00000E5E                          2329          IF D2 <NE> (A1) THEN
00000E5E  B451                    2330s     CMP.W   (A1),D2
00000E60  6700 0004               2331s     BEQ _0000000A
00000E64  60F6                    2332              BRA WAIT_FOR_COMPLETE
00000E66                          2333          ENDI
00000E66                          2334s _0000000A
00000E66                          2335        
00000E66  5488                    2336          ADD.L #2,A0
00000E68  5489                    2337          ADD.L #2,A1
00000E6A                          2338      ENDW  
00000E6A  60DE                    2339s     BRA _10000018
00000E6C                          2340s _10000019
00000E6C                          2341      
00000E6C  267C 00002AAA           2342      MOVE.L #$2AAA,A3
00000E72  36BC AAAA               2343      MOVE.W #$AAAA,(A3)
00000E76  267C 00001554           2344      MOVE.L #$1554,A3
00000E7C  36BC 5555               2345      MOVE.W #$5555,(A3)
00000E80  267C 00002AAA           2346      MOVE.L #$2AAA,A3
00000E86  36BC A0A0               2347      MOVE.W #$A0A0,(A3)
00000E8A                          2348              
00000E8A  6000 F2F8               2349      BRA MAIN_LOOP
00000E8E                          2350          
00000E8E                          2351  HEX_DIGIT
00000E8E  E98F                    2352      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000E90                          2353m     HEX2BIN D2,D2,A0
00000E90  41F9 00000FE4           2354m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000E96  0402 0030               2355m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E9A  C4BC 000000FF           2356m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EA0  1430 2000               2357m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000EA4                          2358m     ENDM
00000EA4  8E02                    2359      OR.B D2,D7  
00000EA6  6000 F304               2360      BRA GET_INPUT
00000EAA                          2361  
00000EAA  FFFF FFFF               2362      SIMHALT                                     ; halt simulator
00000EAE                          2363  
00000EAE                          2364  ; strings
00000EAE= 4D 44 46 2D 6D 6F ...   2365  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',13,10,0
00000ECB= 3F 20 48 65 6C 70 ...   2366  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00000F70= 48 75 68 3F 0D 0A 00    2367  HUH     DC.B 'Huh?',13,10,0
00000F77= 20 53 20 72 65 63 ...   2368  READ    DC.B ' S records read, start address = ',0
00000F99= 57 3A 20 55 6E 6B ...   2369  UNREC   DC.B 'W: Unknown Srec type: ',0
00000FB0= 57 3A 20 43 53 20 ...   2370  CS_FAILURE   DC.B 'W: CS failure at ',0
00000FC2= 57 3A 20 52 41 4D ...   2371  RAM_ERROR DC.B 'W: RAM error at: ',0
00000FD4= 30 31 32 33 34 35 ...   2372  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000FE4= 00 01 02 03 04 05 ...   2373  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000FFB= 4C 6F 61 64 69 6E ...   2374  LOADING  DC.B 'Loading EEPROM...',13,11,0
0000100F                          2375      
0000100F                          2376      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         FD4
CONTINUE_103        9FE
CONTINUE_44         4A2
CONTINUE_47         4F2
CONTINUE_51         54A
CONTINUE_59         608
CONTINUE_64         67C
CONTINUE_69         6FA
CONTINUE_74         77E
CONTINUE_79         80C
CONTINUE_84         880
CONTINUE_89         8F4
CS_FAILURE          FB0
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       B1C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            A9A
EXIT_125            B92
EXIT_135            C98
EXIT_156            E46
EXIT_19             2E2
EXIT_21             308
EXIT_23             32E
EXIT_5              13E
EXIT_96             994
G                   C14
GET_INPUT           1AC
H                   2E6
HELP                ECB
HEX2BIN             134
HEX2BIN_LUT         FE4
HEX_DIGIT           E8E
HUH                 F70
L                   D22
LOADING             FFB
LOOP_110            A7E
LOOP_112            AC4
LOOP_120            B46
LOOP_125            B76
LOOP_127            BBE
LOOP_135            C7C
LOOP_137            CC6
LOOP_156            E2A
LOOP_19             2C6
LOOP_21             2EC
LOOP_23             312
LOOP_25             360
LOOP_5              122
LOOP_96             978
MAIN_LOOP           184
OK                  D18
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   332
RAM                 200000
RAM_ERROR           FC2
READ                F77
READ_CHAR           805
READ_DATA_TO_POKE   400
READ_LENGTH         D6A
RESET               4
ROM                 0
S                   47E
STACK               0
START               8
UNREC               F99
V                   30C
VERSION             EAE
W                   3B8
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E5C
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   166
WAIT_FOR_READY_100  9A6
WAIT_FOR_READY_101  9BA
WAIT_FOR_READY_103  9E2
WAIT_FOR_READY_105  A16
WAIT_FOR_READY_108  A48
WAIT_FOR_READY_109  A5C
WAIT_FOR_READY_11   184
WAIT_FOR_READY_111  A86
WAIT_FOR_READY_113  A9A
WAIT_FOR_READY_114  AAE
WAIT_FOR_READY_116  AD8
WAIT_FOR_READY_118  AEE
WAIT_FOR_READY_119  B02
WAIT_FOR_READY_12   198
WAIT_FOR_READY_121  B1C
WAIT_FOR_READY_122  B30
WAIT_FOR_READY_124  B5A
WAIT_FOR_READY_126  B7E
WAIT_FOR_READY_128  B94
WAIT_FOR_READY_129  BA8
WAIT_FOR_READY_13   1AC
WAIT_FOR_READY_131  BD2
WAIT_FOR_READY_133  BE8
WAIT_FOR_READY_134  BFC
WAIT_FOR_READY_136  C84
WAIT_FOR_READY_138  C9C
WAIT_FOR_READY_139  CB0
WAIT_FOR_READY_141  CDA
WAIT_FOR_READY_143  CF0
WAIT_FOR_READY_144  D04
WAIT_FOR_READY_145  D24
WAIT_FOR_READY_147  D3E
WAIT_FOR_READY_149  D6C
WAIT_FOR_READY_15   1C6
WAIT_FOR_READY_151  D86
WAIT_FOR_READY_154  DB6
WAIT_FOR_READY_155  DCA
WAIT_FOR_READY_157  E32
WAIT_FOR_READY_17   268
WAIT_FOR_READY_18   27C
WAIT_FOR_READY_20   2CE
WAIT_FOR_READY_22   2F4
WAIT_FOR_READY_24   31A
WAIT_FOR_READY_26   336
WAIT_FOR_READY_27   34A
WAIT_FOR_READY_29   374
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_32   39E
WAIT_FOR_READY_33   3BA
WAIT_FOR_READY_35   3D4
WAIT_FOR_READY_37   402
WAIT_FOR_READY_39   41C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   452
WAIT_FOR_READY_43   466
WAIT_FOR_READY_44   486
WAIT_FOR_READY_46   4C0
WAIT_FOR_READY_47   4D6
WAIT_FOR_READY_49   50A
WAIT_FOR_READY_51   52E
WAIT_FOR_READY_53   562
WAIT_FOR_READY_56   59C
WAIT_FOR_READY_57   5B0
WAIT_FOR_READY_59   5EC
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   620
WAIT_FOR_READY_64   660
WAIT_FOR_READY_66   694
WAIT_FOR_READY_69   6DE
WAIT_FOR_READY_71   712
WAIT_FOR_READY_74   762
WAIT_FOR_READY_76   796
WAIT_FOR_READY_79   7F0
WAIT_FOR_READY_8    13E
WAIT_FOR_READY_81   824
WAIT_FOR_READY_84   864
WAIT_FOR_READY_86   898
WAIT_FOR_READY_89   8D8
WAIT_FOR_READY_9    152
WAIT_FOR_READY_91   90C
WAIT_FOR_READY_94   94A
WAIT_FOR_READY_95   95E
WAIT_FOR_READY_97   980
WAIT_FOR_READY_98   994
WAIT_FOR_SRECORD    486
Z                   C1C
_00000000           5CC
_00000001           9D2
_00000002           5DA
_00000003           7D8
_00000004           744
_00000005           9D2
_00000006           94A
_00000007           9D2
_00000008           B1A
_00000009           C76
_0000000A           E66
_10000000           524
_10000001           58E
_10000002           5E2
_10000003           64C
_10000004           656
_10000005           6C0
_10000006           6D4
_10000007           73E
_10000008           748
_10000009           7D0
_1000000A           758
_1000000B           7C2
_1000000C           7E6
_1000000D           850
_1000000E           85A
_1000000F           8C4
_10000010           8CE
_10000011           938
_10000012           9D8
_10000013           A42
_10000014           C24
_10000015           C46
_10000016           C4E
_10000017           D1E
_10000018           E4A
_10000019           E6C
