00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 04/04/2021 17:01:27

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; try running the monitor in RAM, grr, suddenly uses S2 records
00000000                             9  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            10  ; burn the monitor into eeprom from code
00000000                            11  ;ram CHECK AT STARTUP??? WIOLL PREVEWNT RUNNIG CODE FROM RAM THOUGH, SO need cold/warm start
00000000                            12  ; check for escape during Z
00000000                            13  ; fix the DUART base address
00000000                            14  ; tidy up layout (indentation and comments)
00000000                            15  ; stop using two registers in download
00000000                            16  ; add a .W and .B variants of PRINT_REG
00000000                            17  ; implement DOWNLOAD_BYTE
00000000                            18  ; fix being able to enter random chars when W'ing
00000000                            19  ;JMP -> BRA
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00E00000                 24  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 25  DISPLAY_            EQU $0
00000000  =00E00001                 26  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            27  
00000000  =00200000                 28  RAM                 EQU $200000
00000000                            29  
00000000  =00D30000                 30  DUART_BASE          EQU $D30000
00000000  =00000000                 31  DUART_MRA_          EQU $0
00000000  =00000001                 32  DUART_CSRA_         EQU $1
00000000  =00000001                 33  DUART_SRA_          EQU $1
00000000  =00000002                 34  DUART_CRA_          EQU $2
00000000  =00000003                 35  DUART_TXA_          EQU $3
00000000  =00000003                 36  DUART_RXA_          EQU $3
00000000  =00000004                 37  DUART_ACR_          EQU $4
00000000  =00000005                 38  DUART_IMR_          EQU $5
00000000  =00000008                 39  DUART_MRB_          EQU $8
00000000  =00000009                 40  DUART_CSRB_         EQU $9
00000000  =00000009                 41  DUART_SRB_          EQU $9
00000000  =0000000A                 42  DUART_CRB_          EQU $A
00000000  =0000000B                 43  DUART_TXB_          EQU $B
00000000  =0000000B                 44  DUART_RXB_          EQU $B
00000000  =0000000C                 45  DUART_IVR_          EQU $C
00000000  =0000000D                 46  DUART_OPCR_         EQU $D
00000000  =0000000E                 47  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 48  DUART_RESET_OPR_    EQU $F
00000000                            49  RRRR
00000000  =00D30001                 50  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 51  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 52  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 53  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 54  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 55  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            56  
00000000  =00D30011                 57  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 58  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 59  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 60  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 61  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 62  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            63  
00000000  =00D30009                 64  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 65  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 66  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 67  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 68  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 69  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            77    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78    MOVE.B \1,\2
00000000                            79    ANDI.L #$F,\2
00000000                            80    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            81    ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            88    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            89    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            90    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            91    ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99        MOVE.B DUART_SRA,\2           ; read status register
00000000                           100        BTST #2,\2                    ; check for space to send
00000000                           101        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                           102        MOVE.B \1,DUART_TXA           ; send the next character
00000000                           103      ENDC
00000000                           104      
00000000                           105      IFNE DEBUG
00000000                           106        MOVE.B \1,D1
00000000                           107        MOVE.L #6,D0   
00000000                           108        TRAP #15                      ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll
00000000                           115  PRINT_CRLF MACRO                  
00000000                           116      PRINT_CHAR #13,\1             ; CR
00000000                           117      PRINT_CHAR #10,\1             ; LF
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #0,(\1)                 ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      JMP LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           133  PRINT_REG MACRO
00000000                           134      PRINT_CHAR #'0',\2          ;0x header
00000000                           135      PRINT_CHAR #'x',\2
00000000                           136      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142    
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           148  
00000000                           149      IFEQ DEBUG
00000000                           150        MOVE.B DUART_SRA,\2         ; read status register
00000000                           151        BTST #0,\2                    ; check for character
00000000                           152        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           153      ENDC
00000000                           154      
00000000                           155      READ_CHAR \1
00000000                           156  
00000000                           157      IFEQ DEBUG
00000000                           158        PRINT_CHAR \1,\2            ; echo it back
00000000                           159      ENDC
00000000                           160      ENDM
00000000                           161      
00000000                           162  ; read a char from the serial port - assumes that there is one!
00000000                           163  ; \ 1= data register for read char
00000000                           164  ; will stamp on D0 and D1 in debug mode
00000000                           165  READ_CHAR MACRO
00000000                           166      IFEQ DEBUG
00000000                           167        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           168      ENDC
00000000                           169      IFNE DEBUG
00000000                           170        MOVE.L #5,D0    
00000000                           171        TRAP #15                    ; read from keyboard in simulator
00000000                           172        MOVE.L D1,\1
00000000                           173      ENDC
00000000                           174       
00000000                           175      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           176      BEQ START
00000000                           177      ENDM
00000000                           178      
00000000                           179      
00000000                           180  ; read data from the download serial port
00000000                           181  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           182  DOWNLOAD MACRO
00000000                           183  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           184  
00000000                           185      MOVE.B DUART_SRA,\2           ; check for command
00000000                           186      BTST #0,\2                    ; check for character
00000000                           187      BEQ CONTINUE\@                ; nothing, continue
00000000                           188   
00000000                           189      READ_CHAR \1
00000000                           190  CONTINUE\@
00000000                           191      MOVE.B DUART_SRB,\2         ; read status register
00000000                           192      BTST #0,\2                  ; check for character
00000000                           193      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           194      
00000000                           195      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           196      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           197      
00000000                           198      ENDM
00000000                           199  
00000000                           200  
00000000                           201  ; register catalogue
00000000                           202  ; D0 - used for simulator I/O
00000000                           203  ; D1 - used for simulator I/O
00000000                           204  ; D2 - read character
00000000                           205  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           206  ; D4 - count of S records read
00000000                           207  ; D5 - data to write / data read / byte count for S record load
00000000                           208  ; D6 - working register used in R/W and download
00000000                           209  ; D7 - address accumulator / reset by download
00000000                           210  ; A0 - address of string to print 
00000000                           211  
00000000                           212  ; start vector
00000000                           213      ORG  $0
00000000                           214  ;    ORG  $200000
00000000= 00000000                 215      DC.L $00000000              ; PC
00000004= 00000000                 216      DC.L $00000000              ; SP
00000008                           217      
00000008                           218  ; start of program  
00000008                           219  START
00000008  13FC 0000 00E00001       220      MOVE.B #0,DISPLAY
00000010                           221  
00000010                           222  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       223      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       224      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     225      NOP
00000022  13FC 0040 00D30005       226      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     227      NOP
0000002C  13FC 0030 00D30005       228      MOVE.B #$30,DUART_CRA
00000034  4E71                     229      NOP
00000036  13FC 0020 00D30005       230      MOVE.B #$20,DUART_CRA
0000003E  4E71                     231      NOP
00000040  13FC 0010 00D30005       232      MOVE.B #$10,DUART_CRA   
00000048                           233  
00000048  13FC 000A 00D30015       234      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       235      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     236      NOP
0000005A  13FC 0040 00D30015       237      MOVE.B #$40,DUART_CRB           
00000062  4E71                     238      NOP
00000064  13FC 0030 00D30015       239      MOVE.B #$30,DUART_CRB
0000006C  4E71                     240      NOP
0000006E  13FC 0020 00D30015       241      MOVE.B #$20,DUART_CRB
00000076  4E71                     242      NOP
00000078  13FC 0010 00D30015       243      MOVE.B #$10,DUART_CRB   
00000080                           244  
00000080                           245  ;initialise UART
00000080  13FC 0000 00D30009       246      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       247      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       248      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           249  
00000098                           250  ; channel A
00000098  13FC 0013 00D30001       251      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       252      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       253      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       254      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           255  
000000B8                           256  ; channel B
000000B8  13FC 0013 00D30011       257      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       258      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       259      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       260      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           261  
000000D8                           262m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           263m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      264m     IFEQ DEBUG
000000D8  1639 00D30003            265m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                266m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     267m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       268m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           269m     ENDC
000000EC                           270m     
000000EC                 FALSE     271m     IFNE DEBUG
000000EC                           272m     ENDC
000000EC                           273m 
000000EC                           274m     ENDM
000000EC                           275  
000000EC  13FC 0001 00E00001       276      MOVE.B #1,DISPLAY
000000F4                           277         
000000F4                           278m     PRINT_CRLF D3
000000F4                           279mm     PRINT_CHAR #13,D3             ; CR
000000F4                           280mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      281mm     IFEQ DEBUG
000000F4  1639 00D30003            282mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                283mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     284mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       285mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           286mm     ENDC
00000108                           287mm     
00000108                 FALSE     288mm     IFNE DEBUG
00000108                           289mm     ENDC
00000108                           290mm 
00000108                           291mm     ENDM
00000108                           292mm     PRINT_CHAR #10,D3             ; LF
00000108                           293mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      294mm     IFEQ DEBUG
00000108  1639 00D30003            295mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                296mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     297mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       298mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           299mm     ENDC
0000011C                           300mm     
0000011C                 FALSE     301mm     IFNE DEBUG
0000011C                           302mm     ENDC
0000011C                           303mm 
0000011C                           304mm     ENDM
0000011C                           305m     ENDM
0000011C                           306  
0000011C  41F9 00001006            307      LEA VERSION,A0
00000122                           308m     PRINT_STR A0,D3
00000122                           309m LOOP_5
00000122  0C10 0000                310m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                311m     BEQ EXIT_5
0000012A                           312mm     PRINT_CHAR (A0)+,D3
0000012A                           313mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      314mm     IFEQ DEBUG
0000012A  1639 00D30003            315mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                316mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     317mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            318mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           319mm     ENDC
0000013C                           320mm     
0000013C                 FALSE     321mm     IFNE DEBUG
0000013C                           322mm     ENDC
0000013C                           323mm 
0000013C                           324mm     ENDM
0000013C  4EF8 0122                325m     JMP LOOP_5
00000140                           326m EXIT_5
00000140                           327m     ENDM
00000140                           328m     PRINT_CRLF D3
00000140                           329mm     PRINT_CHAR #13,D3             ; CR
00000140                           330mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      331mm     IFEQ DEBUG
00000140  1639 00D30003            332mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                333mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     334mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       335mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           336mm     ENDC
00000154                           337mm     
00000154                 FALSE     338mm     IFNE DEBUG
00000154                           339mm     ENDC
00000154                           340mm 
00000154                           341mm     ENDM
00000154                           342mm     PRINT_CHAR #10,D3             ; LF
00000154                           343mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      344mm     IFEQ DEBUG
00000154  1639 00D30003            345mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                346mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     347mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       348mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           349mm     ENDC
00000168                           350mm     
00000168                 FALSE     351mm     IFNE DEBUG
00000168                           352mm     ENDC
00000168                           353mm 
00000168                           354mm     ENDM
00000168                           355m     ENDM
00000168                           356m     PRINT_CHAR #7,D3
00000168                           357m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      358m     IFEQ DEBUG
00000168  1639 00D30003            359m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                360m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     361m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       362m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           363m     ENDC
0000017C                           364m     
0000017C                 FALSE     365m     IFNE DEBUG
0000017C                           366m     ENDC
0000017C                           367m 
0000017C                           368m     ENDM
0000017C                           369  
0000017C  7E00                     370      MOVE.L #0,D7                    ; address accumulator
0000017E                           371  
0000017E  13FC 0002 00E00001       372      MOVE.B #2,DISPLAY
00000186                           373  MAIN_LOOP
00000186                           374m     PRINT_CHAR #'>',D3               ; prompt
00000186                           375m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      376m     IFEQ DEBUG
00000186  1639 00D30003            377m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                378m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     379m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       380m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           381m     ENDC
0000019A                           382m     
0000019A                 FALSE     383m     IFNE DEBUG
0000019A                           384m     ENDC
0000019A                           385m 
0000019A                           386m     ENDM
0000019A                           387m     PRINT_CHAR #32,D3                ; space
0000019A                           388m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      389m     IFEQ DEBUG
0000019A  1639 00D30003            390m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                391m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     392m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       393m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           394m     ENDC
000001AE                           395m     
000001AE                 FALSE     396m     IFNE DEBUG
000001AE                           397m     ENDC
000001AE                           398m 
000001AE                           399m     ENDM
000001AE                           400      
000001AE                           401  GET_INPUT
000001AE                           402m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           403m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           404m 
000001AE                 TRUE      405m     IFEQ DEBUG
000001AE  1639 00D30003            406m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                407m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     408m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           409m     ENDC
000001BA                           410m     
000001BA                           411mm     READ_CHAR D2
000001BA                 TRUE      412mm     IFEQ DEBUG
000001BA  1439 00D30007            413mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           414mm     ENDC
000001C0                 FALSE     415mm     IFNE DEBUG
000001C0                           416mm     ENDC
000001C0                           417mm      
000001C0  B43C 001B                418mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                419mm     BEQ START
000001C8                           420mm     ENDM
000001C8                           421m 
000001C8                 TRUE      422m     IFEQ DEBUG
000001C8                           423mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           424mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      425mm     IFEQ DEBUG
000001C8  1639 00D30003            426mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                427mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     428mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            429mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           430mm     ENDC
000001DA                           431mm     
000001DA                 FALSE     432mm     IFNE DEBUG
000001DA                           433mm     ENDC
000001DA                           434mm 
000001DA                           435mm     ENDM
000001DA                           436m     ENDC
000001DA                           437m     ENDM
000001DA                           438      
000001DA  B43C 0030                439      CMP.B #'0',D2
000001DE  6700 0E06                440      BEQ HEX_DIGIT
000001E2  B43C 0031                441      CMP.B #'1',D2
000001E6  6700 0DFE                442      BEQ HEX_DIGIT
000001EA  B43C 0032                443      CMP.B #'2',D2
000001EE  6700 0DF6                444      BEQ HEX_DIGIT
000001F2  B43C 0033                445      CMP.B #'3',D2
000001F6  6700 0DEE                446      BEQ HEX_DIGIT
000001FA  B43C 0034                447      CMP.B #'4',D2
000001FE  6700 0DE6                448      BEQ HEX_DIGIT
00000202  B43C 0035                449      CMP.B #'5',D2
00000206  6700 0DDE                450      BEQ HEX_DIGIT
0000020A  B43C 0036                451      CMP.B #'6',D2
0000020E  6700 0DD6                452      BEQ HEX_DIGIT
00000212  B43C 0037                453      CMP.B #'7',D2
00000216  6700 0DCE                454      BEQ HEX_DIGIT
0000021A  B43C 0038                455      CMP.B #'8',D2
0000021E  6700 0DC6                456      BEQ HEX_DIGIT
00000222  B43C 0039                457      CMP.B #'9',D2
00000226  6700 0DBE                458      BEQ HEX_DIGIT
0000022A  B43C 0041                459      CMP.B #'A',D2
0000022E  6700 0DB6                460      BEQ HEX_DIGIT
00000232  B43C 0042                461      CMP.B #'B',D2
00000236  6700 0DAE                462      BEQ HEX_DIGIT
0000023A  B43C 0043                463      CMP.B #'C',D2
0000023E  6700 0DA6                464      BEQ HEX_DIGIT
00000242  B43C 0044                465      CMP.B #'D',D2
00000246  6700 0D9E                466      BEQ HEX_DIGIT
0000024A  B43C 0045                467      CMP.B #'E',D2
0000024E  6700 0D96                468      BEQ HEX_DIGIT
00000252  B43C 0046                469      CMP.B #'F',D2
00000256  6700 0D8E                470      BEQ HEX_DIGIT
0000025A                           471      
0000025A  B43C 0057                472      CMP.B #'W',D2
0000025E  6700 0158                473      BEQ W
00000262                           474  
00000262                           475m     PRINT_CRLF D3
00000262                           476mm     PRINT_CHAR #13,D3             ; CR
00000262                           477mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      478mm     IFEQ DEBUG
00000262  1639 00D30003            479mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                480mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     481mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       482mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           483mm     ENDC
00000276                           484mm     
00000276                 FALSE     485mm     IFNE DEBUG
00000276                           486mm     ENDC
00000276                           487mm 
00000276                           488mm     ENDM
00000276                           489mm     PRINT_CHAR #10,D3             ; LF
00000276                           490mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      491mm     IFEQ DEBUG
00000276  1639 00D30003            492mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                493mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     494mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       495mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           496mm     ENDC
0000028A                           497mm     
0000028A                 FALSE     498mm     IFNE DEBUG
0000028A                           499mm     ENDC
0000028A                           500mm 
0000028A                           501mm     ENDM
0000028A                           502m     ENDM
0000028A                           503   
0000028A  B43C 003F                504      CMP.B #'?',D2
0000028E  6700 0052                505      BEQ H
00000292                           506  
00000292  B43C 0056                507      CMP.B #'V',D2
00000296  6700 0072                508      BEQ V
0000029A                           509      
0000029A  B43C 0052                510      CMP.B #'R',D2
0000029E  6700 0092                511      BEQ R
000002A2                           512  
000002A2  B43C 0053                513      CMP.B #'S',D2
000002A6  6700 01D6                514      BEQ S
000002AA                           515  
000002AA  B43C 0047                516      CMP.B #'G',D2
000002AE  6700 0C26                517      BEQ G   
000002B2                           518  
000002B2  B43C 005A                519      CMP.B #'Z',D2
000002B6  6700 0C26                520      BEQ Z   
000002BA                           521  
000002BA  41F9 0000109C            522      LEA HUH,A0
000002C0                           523m     PRINT_STR A0,D3
000002C0                           524m LOOP_19
000002C0  0C10 0000                525m     CMP.B #0,(A0)                 ; 0 -> DONE
000002C4  6700 0018                526m     BEQ EXIT_19
000002C8                           527mm     PRINT_CHAR (A0)+,D3
000002C8                           528mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      529mm     IFEQ DEBUG
000002C8  1639 00D30003            530mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002CE  0803 0002                531mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002D2  67F4                     532mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002D4  13D8 00D30007            533mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002DA                           534mm     ENDC
000002DA                           535mm     
000002DA                 FALSE     536mm     IFNE DEBUG
000002DA                           537mm     ENDC
000002DA                           538mm 
000002DA                           539mm     ENDM
000002DA  4EF8 02C0                540m     JMP LOOP_19
000002DE                           541m EXIT_19
000002DE                           542m     ENDM
000002DE                           543                         
000002DE  4EF8 0186                544      JMP MAIN_LOOP
000002E2                           545      
000002E2                           546  ; commands
000002E2  41F9 00001023            547  H   LEA HELP,A0
000002E8                           548m     PRINT_STR A0,D3
000002E8                           549m LOOP_21
000002E8  0C10 0000                550m     CMP.B #0,(A0)                 ; 0 -> DONE
000002EC  6700 0018                551m     BEQ EXIT_21
000002F0                           552mm     PRINT_CHAR (A0)+,D3
000002F0                           553mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      554mm     IFEQ DEBUG
000002F0  1639 00D30003            555mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002F6  0803 0002                556mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002FA  67F4                     557mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002FC  13D8 00D30007            558mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000302                           559mm     ENDC
00000302                           560mm     
00000302                 FALSE     561mm     IFNE DEBUG
00000302                           562mm     ENDC
00000302                           563mm 
00000302                           564mm     ENDM
00000302  4EF8 02E8                565m     JMP LOOP_21
00000306                           566m EXIT_21
00000306                           567m     ENDM
00000306  4EF8 0186                568      JMP MAIN_LOOP
0000030A                           569  
0000030A  41F9 00001006            570  V   LEA VERSION,A0
00000310                           571m     PRINT_STR A0,D3       
00000310                           572m LOOP_23
00000310  0C10 0000                573m     CMP.B #0,(A0)                 ; 0 -> DONE
00000314  6700 0018                574m     BEQ EXIT_23
00000318                           575mm     PRINT_CHAR (A0)+,D3
00000318                           576mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000318                 TRUE      577mm     IFEQ DEBUG
00000318  1639 00D30003            578mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000031E  0803 0002                579mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000322  67F4                     580mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
00000324  13D8 00D30007            581mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000032A                           582mm     ENDC
0000032A                           583mm     
0000032A                 FALSE     584mm     IFNE DEBUG
0000032A                           585mm     ENDC
0000032A                           586mm 
0000032A                           587mm     ENDM
0000032A  4EF8 0310                588m     JMP LOOP_23
0000032E                           589m EXIT_23
0000032E                           590m     ENDM
0000032E  4EF8 0186                591      JMP MAIN_LOOP
00000332                           592      
00000332                           593  R   
00000332  2047                     594      MOVE.L D7,A0                    ; address accumulator -> address register
00000334  2A10                     595      MOVE.L (A0),D5                  ; read the memory and print it
00000336                           596m     PRINT_REG D5,D3,D7,D6,A0
00000336                           597mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000336                           598mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000336                 TRUE      599mm     IFEQ DEBUG
00000336  1639 00D30003            600mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000033C  0803 0002                601mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000340  67F4                     602mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00000342  13FC 0030 00D30007       603mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0000034A                           604mm     ENDC
0000034A                           605mm     
0000034A                 FALSE     606mm     IFNE DEBUG
0000034A                           607mm     ENDC
0000034A                           608mm 
0000034A                           609mm     ENDM
0000034A                           610mm     PRINT_CHAR #'x',D3
0000034A                           611mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000034A                 TRUE      612mm     IFEQ DEBUG
0000034A  1639 00D30003            613mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000350  0803 0002                614mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000354  67F4                     615mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000356  13FC 0078 00D30007       616mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0000035E                           617mm     ENDC
0000035E                           618mm     
0000035E                 FALSE     619mm     IFNE DEBUG
0000035E                           620mm     ENDC
0000035E                           621mm 
0000035E                           622mm     ENDM
0000035E  7C07                     623m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000360                           624m LOOP_25
00000360                           625mm     BIN2HEX D5,D7,A0
00000360  41F9 00001139            626mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000366  E99D                     627mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000368  1E05                     628mm   MOVE.B D5,D7
0000036A  0287 0000000F            629mm   ANDI.L #$F,D7
00000370  1E30 7000                630mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000374                           631mm   ENDM
00000374                           632mm     PRINT_CHAR D7,D3
00000374                           633mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000374                 TRUE      634mm     IFEQ DEBUG
00000374  1639 00D30003            635mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000037A  0803 0002                636mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000037E  67F4                     637mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000380  13C7 00D30007            638mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000386                           639mm     ENDC
00000386                           640mm     
00000386                 FALSE     641mm     IFNE DEBUG
00000386                           642mm     ENDC
00000386                           643mm 
00000386                           644mm     ENDM
00000386  57CE FFD8                645m     DBEQ D6,LOOP_25
0000038A                           646m     ENDM
0000038A                           647m     PRINT_CRLF D3
0000038A                           648mm     PRINT_CHAR #13,D3             ; CR
0000038A                           649mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                 TRUE      650mm     IFEQ DEBUG
0000038A  1639 00D30003            651mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000390  0803 0002                652mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000394  67F4                     653mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
00000396  13FC 000D 00D30007       654mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000039E                           655mm     ENDC
0000039E                           656mm     
0000039E                 FALSE     657mm     IFNE DEBUG
0000039E                           658mm     ENDC
0000039E                           659mm 
0000039E                           660mm     ENDM
0000039E                           661mm     PRINT_CHAR #10,D3             ; LF
0000039E                           662mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                 TRUE      663mm     IFEQ DEBUG
0000039E  1639 00D30003            664mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003A4  0803 0002                665mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003A8  67F4                     666mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
000003AA  13FC 000A 00D30007       667mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000003B2                           668mm     ENDC
000003B2                           669mm     
000003B2                 FALSE     670mm     IFNE DEBUG
000003B2                           671mm     ENDC
000003B2                           672mm 
000003B2                           673mm     ENDM
000003B2                           674m     ENDM
000003B2  7E00                     675      MOVE.L #0,D7                    ; clear the now used address accumulator
000003B4  4EF8 0186                676      JMP MAIN_LOOP
000003B8                           677  
000003B8  7A00                     678  W   MOVE.L #0,D5                    ; D5 will be the value to write            
000003BA                           679  
000003BA                           680m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
000003BA                           681m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BA                           682m 
000003BA                 TRUE      683m     IFEQ DEBUG
000003BA  1639 00D30003            684m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003C0  0803 0000                685m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003C4  67F4                     686m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
000003C6                           687m     ENDC
000003C6                           688m     
000003C6                           689mm     READ_CHAR D2
000003C6                 TRUE      690mm     IFEQ DEBUG
000003C6  1439 00D30007            691mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003CC                           692mm     ENDC
000003CC                 FALSE     693mm     IFNE DEBUG
000003CC                           694mm     ENDC
000003CC                           695mm      
000003CC  B43C 001B                696mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003D0  6700 FC36                697mm     BEQ START
000003D4                           698mm     ENDM
000003D4                           699m 
000003D4                 TRUE      700m     IFEQ DEBUG
000003D4                           701mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003D4                           702mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D4                 TRUE      703mm     IFEQ DEBUG
000003D4  1639 00D30003            704mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003DA  0803 0002                705mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003DE  67F4                     706mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
000003E0  13C2 00D30007            707mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003E6                           708mm     ENDC
000003E6                           709mm     
000003E6                 FALSE     710mm     IFNE DEBUG
000003E6                           711mm     ENDC
000003E6                           712mm 
000003E6                           713mm     ENDM
000003E6                           714m     ENDC
000003E6                           715m     ENDM
000003E6                           716m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003E6  41F9 00001149            717m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003EC  0402 0030                718m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F0  C4BC 000000FF            719m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000003F6  1430 2000                720m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000003FA                           721m   ENDM
000003FA  1A02                     722      MOVE.B D2,D5                    ; put at bottom of D5
000003FC                           723  
000003FC  3C3C 0006                724      MOVE #6,D6                      ; 7 bytes left to read
00000400                           725      
00000400                           726  READ_DATA_TO_POKE
00000400  E98D                     727      LSL.L #4,D5                     ; make what we have so far more significant
00000402                           728m     WAIT_CHAR D2,D3                 ; next character -> D2
00000402                           729m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           730m 
00000402                 TRUE      731m     IFEQ DEBUG
00000402  1639 00D30003            732m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000408  0803 0000                733m       BTST #0,D3                    ; CHECK FOR CHARACTER
0000040C  67F4                     734m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
0000040E                           735m     ENDC
0000040E                           736m     
0000040E                           737mm     READ_CHAR D2
0000040E                 TRUE      738mm     IFEQ DEBUG
0000040E  1439 00D30007            739mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000414                           740mm     ENDC
00000414                 FALSE     741mm     IFNE DEBUG
00000414                           742mm     ENDC
00000414                           743mm      
00000414  B43C 001B                744mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                745mm     BEQ START
0000041C                           746mm     ENDM
0000041C                           747m 
0000041C                 TRUE      748m     IFEQ DEBUG
0000041C                           749mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0000041C                           750mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      751mm     IFEQ DEBUG
0000041C  1639 00D30003            752mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000422  0803 0002                753mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000426  67F4                     754mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00000428  13C2 00D30007            755mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000042E                           756mm     ENDC
0000042E                           757mm     
0000042E                 FALSE     758mm     IFNE DEBUG
0000042E                           759mm     ENDC
0000042E                           760mm 
0000042E                           761mm     ENDM
0000042E                           762m     ENDC
0000042E                           763m     ENDM
0000042E                           764m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
0000042E  41F9 00001149            765m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000434  0402 0030                766m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000438  C4BC 000000FF            767m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000043E  1430 2000                768m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000442                           769m   ENDM
00000442  8A02                     770      OR.B D2,D5
00000444  023C 00FB                771      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000448  57CE FFB6                772      DBEQ D6,READ_DATA_TO_POKE
0000044C                           773      
0000044C  2047                     774      MOVE.L D7,A0                    ; address accumulator -> address register
0000044E  7E00                     775      MOVE.L #0,D7                    ; clear the now used address accumulator
00000450                           776      
00000450  2085                     777      MOVE.L D5,(A0)                  ; write the data
00000452                           778  
00000452                           779m     PRINT_CRLF D3
00000452                           780mm     PRINT_CHAR #13,D3             ; CR
00000452                           781mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                 TRUE      782mm     IFEQ DEBUG
00000452  1639 00D30003            783mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000458  0803 0002                784mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000045C  67F4                     785mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
0000045E  13FC 000D 00D30007       786mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000466                           787mm     ENDC
00000466                           788mm     
00000466                 FALSE     789mm     IFNE DEBUG
00000466                           790mm     ENDC
00000466                           791mm 
00000466                           792mm     ENDM
00000466                           793mm     PRINT_CHAR #10,D3             ; LF
00000466                           794mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000466                 TRUE      795mm     IFEQ DEBUG
00000466  1639 00D30003            796mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000046C  0803 0002                797mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000470  67F4                     798mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
00000472  13FC 000A 00D30007       799mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000047A                           800mm     ENDC
0000047A                           801mm     
0000047A                 FALSE     802mm     IFNE DEBUG
0000047A                           803mm     ENDC
0000047A                           804mm 
0000047A                           805mm     ENDM
0000047A                           806m     ENDM
0000047A  4EF8 0186                807      JMP MAIN_LOOP
0000047E                           808  
0000047E                           809  
0000047E  7800                     810  S   MOVE.L #0,D4                    ; count of records read -> D4
00000480  2478 0000                811      MOVE.L 0,A2                     ; start address -> A2
00000484                           812      
00000484                           813  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00000484                           814m     DOWNLOAD D2,D3                  
00000484                           815m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000484                           816m 
00000484  1639 00D30003            817m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000048A  0803 0000                818m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000048E  6700 0010                819m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
00000492                           820m  
00000492                           821mm     READ_CHAR D2
00000492                 TRUE      822mm     IFEQ DEBUG
00000492  1439 00D30007            823mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000498                           824mm     ENDC
00000498                 FALSE     825mm     IFNE DEBUG
00000498                           826mm     ENDC
00000498                           827mm      
00000498  B43C 001B                828mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000049C  6700 FB6A                829mm     BEQ START
000004A0                           830mm     ENDM
000004A0                           831m CONTINUE_44
000004A0  1639 00D30013            832m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004A6  0803 0000                833m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004AA  67D8                     834m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004AC                           835m     
000004AC  1439 00D30017            836m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004B2  13C2 00E00001            837m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004B8                           838m     
000004B8                           839m     ENDM
000004B8  B43C 0053                840      CMP.B #'S',D2                   ; found S?    
000004BC  66C6                     841      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
000004BE                           842      
000004BE  5284                     843      ADD.L #1,D4                     ; read another S record, increment count
000004C0                           844      
000004C0                           845m     DOWNLOAD D7,D3                  ; read the record digit
000004C0                           846m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                           847m 
000004C0  1639 00D30003            848m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004C6  0803 0000                849m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004CA  6700 0010                850m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004CE                           851m  
000004CE                           852mm     READ_CHAR D7
000004CE                 TRUE      853mm     IFEQ DEBUG
000004CE  1E39 00D30007            854mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
000004D4                           855mm     ENDC
000004D4                 FALSE     856mm     IFNE DEBUG
000004D4                           857mm     ENDC
000004D4                           858mm      
000004D4  BE3C 001B                859mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
000004D8  6700 FB2E                860mm     BEQ START
000004DC                           861mm     ENDM
000004DC                           862m CONTINUE_46
000004DC  1639 00D30013            863m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004E2  0803 0000                864m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004E6  67D8                     865m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
000004E8                           866m     
000004E8  1E39 00D30017            867m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
000004EE  13C7 00E00001            868m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
000004F4                           869m     
000004F4                           870m     ENDM
000004F4                           871  
000004F4  7C00                     872      MOVE.L #0,D6                    ; checksum
000004F6                           873  
000004F6  7A00                     874      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
000004F8                           875m     DOWNLOAD D2,D3              
000004F8                           876m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F8                           877m 
000004F8  1639 00D30003            878m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004FE  0803 0000                879m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000502  6700 0010                880m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00000506                           881m  
00000506                           882mm     READ_CHAR D2
00000506                 TRUE      883mm     IFEQ DEBUG
00000506  1439 00D30007            884mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000050C                           885mm     ENDC
0000050C                 FALSE     886mm     IFNE DEBUG
0000050C                           887mm     ENDC
0000050C                           888mm      
0000050C  B43C 001B                889mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000510  6700 FAF6                890mm     BEQ START
00000514                           891mm     ENDM
00000514                           892m CONTINUE_48
00000514  1639 00D30013            893m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000051A  0803 0000                894m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000051E  67D8                     895m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00000520                           896m     
00000520  1439 00D30017            897m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000526  13C2 00E00001            898m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000052C                           899m     
0000052C                           900m     ENDM
0000052C                           901m     HEX2BIN D2,D2,A0
0000052C  41F9 00001149            902m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000532  0402 0030                903m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000536  C4BC 000000FF            904m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000053C  1430 2000                905m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000540                           906m   ENDM
00000540  8A82                     907      OR.L D2,D5
00000542  E98D                     908      LSL.L #4,D5    
00000544                           909m     DOWNLOAD D2,D3
00000544                           910m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                           911m 
00000544  1639 00D30003            912m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000054A  0803 0000                913m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000054E  6700 0010                914m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
00000552                           915m  
00000552                           916mm     READ_CHAR D2
00000552                 TRUE      917mm     IFEQ DEBUG
00000552  1439 00D30007            918mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000558                           919mm     ENDC
00000558                 FALSE     920mm     IFNE DEBUG
00000558                           921mm     ENDC
00000558                           922mm      
00000558  B43C 001B                923mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000055C  6700 FAAA                924mm     BEQ START
00000560                           925mm     ENDM
00000560                           926m CONTINUE_51
00000560  1639 00D30013            927m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000566  0803 0000                928m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000056A  67D8                     929m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
0000056C                           930m     
0000056C  1439 00D30017            931m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000572  13C2 00E00001            932m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000578                           933m     
00000578                           934m     ENDM
00000578                           935m     HEX2BIN D2,D2,A0  
00000578  41F9 00001149            936m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000057E  0402 0030                937m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000582  C4BC 000000FF            938m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000588  1430 2000                939m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000058C                           940m   ENDM
0000058C  8A82                     941      OR.L D2,D5
0000058E                           942                  
0000058E  DC85                     943      ADD.L D5,D6                     ; add byte count into checksum
00000590                           944  
00000590                           945      IF.B D7 <EQ> #'0' THEN.L        ; header
00000598  7E00                     946          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
0000059A                           947m         DOWNLOAD D2,D3              ; top byte
0000059A                           948m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059A                           949m 
0000059A  1639 00D30003            950m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005A0  0803 0000                951m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005A4  6700 0010                952m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
000005A8                           953m  
000005A8                           954mm     READ_CHAR D2
000005A8                 TRUE      955mm     IFEQ DEBUG
000005A8  1439 00D30007            956mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005AE                           957mm     ENDC
000005AE                 FALSE     958mm     IFNE DEBUG
000005AE                           959mm     ENDC
000005AE                           960mm      
000005AE  B43C 001B                961mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005B2  6700 FA54                962mm     BEQ START
000005B6                           963mm     ENDM
000005B6                           964m CONTINUE_54
000005B6  1639 00D30013            965m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005BC  0803 0000                966m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005C0  67D8                     967m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
000005C2                           968m     
000005C2  1439 00D30017            969m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005C8  13C2 00E00001            970m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005CE                           971m     
000005CE                           972m     ENDM
000005CE                           973m         HEX2BIN D2,D2,A0
000005CE  41F9 00001149            974m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005D4  0402 0030                975m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005D8  C4BC 000000FF            976m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005DE  1430 2000                977m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005E2                           978m   ENDM
000005E2  8E82                     979          OR.L D2,D7
000005E4  E98F                     980          LSL.L #4,D7
000005E6                           981m         DOWNLOAD D2,D3         
000005E6                           982m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E6                           983m 
000005E6  1639 00D30003            984m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005EC  0803 0000                985m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005F0  6700 0010                986m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
000005F4                           987m  
000005F4                           988mm     READ_CHAR D2
000005F4                 TRUE      989mm     IFEQ DEBUG
000005F4  1439 00D30007            990mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005FA                           991mm     ENDC
000005FA                 FALSE     992mm     IFNE DEBUG
000005FA                           993mm     ENDC
000005FA                           994mm      
000005FA  B43C 001B                995mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005FE  6700 FA08                996mm     BEQ START
00000602                           997mm     ENDM
00000602                           998m CONTINUE_57
00000602  1639 00D30013            999m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000608  0803 0000               1000m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000060C  67D8                    1001m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
0000060E                          1002m     
0000060E  1439 00D30017           1003m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000614  13C2 00E00001           1004m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000061A                          1005m     
0000061A                          1006m     ENDM
0000061A                          1007m         HEX2BIN D2,D2,A0
0000061A  41F9 00001149           1008m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000620  0402 0030               1009m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000624  C4BC 000000FF           1010m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000062A  1430 2000               1011m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000062E                          1012m   ENDM
0000062E  8E82                    1013          OR.L D2,D7
00000630                          1014          
00000630  DC87                    1015          ADD.L D7,D6                 ; add top byte of address into checksum
00000632                          1016  
00000632  E98F                    1017          LSL.L #4,D7                 ; bottom byte
00000634                          1018m         DOWNLOAD D2,D3
00000634                          1019m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000634                          1020m 
00000634  1639 00D30003           1021m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000063A  0803 0000               1022m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000063E  6700 0010               1023m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
00000642                          1024m  
00000642                          1025mm     READ_CHAR D2
00000642                 TRUE     1026mm     IFEQ DEBUG
00000642  1439 00D30007           1027mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000648                          1028mm     ENDC
00000648                 FALSE    1029mm     IFNE DEBUG
00000648                          1030mm     ENDC
00000648                          1031mm      
00000648  B43C 001B               1032mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000064C  6700 F9BA               1033mm     BEQ START
00000650                          1034mm     ENDM
00000650                          1035m CONTINUE_60
00000650  1639 00D30013           1036m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000656  0803 0000               1037m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000065A  67D8                    1038m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
0000065C                          1039m     
0000065C  1439 00D30017           1040m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000662  13C2 00E00001           1041m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000668                          1042m     
00000668                          1043m     ENDM
00000668                          1044m         HEX2BIN D2,D2,A0
00000668  41F9 00001149           1045m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000066E  0402 0030               1046m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000672  C4BC 000000FF           1047m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000678  1430 2000               1048m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000067C                          1049m   ENDM
0000067C  8E82                    1050          OR.L D2,D7
0000067E  E98F                    1051          LSL.L #4,D7        
00000680                          1052m         DOWNLOAD D2,D3
00000680                          1053m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000680                          1054m 
00000680  1639 00D30003           1055m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000686  0803 0000               1056m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000068A  6700 0010               1057m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
0000068E                          1058m  
0000068E                          1059mm     READ_CHAR D2
0000068E                 TRUE     1060mm     IFEQ DEBUG
0000068E  1439 00D30007           1061mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000694                          1062mm     ENDC
00000694                 FALSE    1063mm     IFNE DEBUG
00000694                          1064mm     ENDC
00000694                          1065mm      
00000694  B43C 001B               1066mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000698  6700 F96E               1067mm     BEQ START
0000069C                          1068mm     ENDM
0000069C                          1069m CONTINUE_63
0000069C  1639 00D30013           1070m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006A2  0803 0000               1071m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006A6  67D8                    1072m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
000006A8                          1073m     
000006A8  1439 00D30017           1074m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006AE  13C2 00E00001           1075m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006B4                          1076m     
000006B4                          1077m     ENDM
000006B4                          1078m         HEX2BIN D2,D2,A0
000006B4  41F9 00001149           1079m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000006BA  0402 0030               1080m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006BE  C4BC 000000FF           1081m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000006C4  1430 2000               1082m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006C8                          1083m   ENDM
000006C8  8E82                    1084          OR.L D2,D7
000006CA                          1085          
000006CA  7400                    1086          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
000006CC  1407                    1087          MOVE.B D7,D2
000006CE  DC82                    1088          ADD.L D2,D6
000006D0                          1089          
000006D0  5785                    1090          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006D2                          1091          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006DC  5385                    1092            SUB.L #1,D5
000006DE                          1093              
000006DE  7E00                    1094            MOVE.L #0,D7              ; D7 holds the byte
000006E0                          1095              
000006E0                          1096m           DOWNLOAD D2,D3            ; MS 4 bits
000006E0                          1097m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E0                          1098m 
000006E0  1639 00D30003           1099m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006E6  0803 0000               1100m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006EA  6700 0010               1101m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
000006EE                          1102m  
000006EE                          1103mm     READ_CHAR D2
000006EE                 TRUE     1104mm     IFEQ DEBUG
000006EE  1439 00D30007           1105mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006F4                          1106mm     ENDC
000006F4                 FALSE    1107mm     IFNE DEBUG
000006F4                          1108mm     ENDC
000006F4                          1109mm      
000006F4  B43C 001B               1110mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006F8  6700 F90E               1111mm     BEQ START
000006FC                          1112mm     ENDM
000006FC                          1113m CONTINUE_66
000006FC  1639 00D30013           1114m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000702  0803 0000               1115m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000706  67D8                    1116m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
00000708                          1117m     
00000708  1439 00D30017           1118m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000070E  13C2 00E00001           1119m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000714                          1120m     
00000714                          1121m     ENDM
00000714                          1122m           HEX2BIN D2,D2,A0
00000714  41F9 00001149           1123m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000071A  0402 0030               1124m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000071E  C4BC 000000FF           1125m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000724  1430 2000               1126m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000728                          1127m   ENDM
00000728  8E82                    1128            OR.L D2,D7
0000072A  E98F                    1129            LSL.L #4,D7
0000072C                          1130               
0000072C                          1131m           DOWNLOAD D2,D3            ; LS 4 bits    
0000072C                          1132m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000072C                          1133m 
0000072C  1639 00D30003           1134m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000732  0803 0000               1135m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000736  6700 0010               1136m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
0000073A                          1137m  
0000073A                          1138mm     READ_CHAR D2
0000073A                 TRUE     1139mm     IFEQ DEBUG
0000073A  1439 00D30007           1140mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000740                          1141mm     ENDC
00000740                 FALSE    1142mm     IFNE DEBUG
00000740                          1143mm     ENDC
00000740                          1144mm      
00000740  B43C 001B               1145mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000744  6700 F8C2               1146mm     BEQ START
00000748                          1147mm     ENDM
00000748                          1148m CONTINUE_69
00000748  1639 00D30013           1149m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000074E  0803 0000               1150m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000752  67D8                    1151m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00000754                          1152m     
00000754  1439 00D30017           1153m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000075A  13C2 00E00001           1154m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000760                          1155m     
00000760                          1156m     ENDM
00000760                          1157m           HEX2BIN D2,D2,A0
00000760  41F9 00001149           1158m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000766  0402 0030               1159m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000076A  C4BC 000000FF           1160m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000770  1430 2000               1161m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000774                          1162m   ENDM
00000774  8E82                    1163            OR.L D2,D7
00000776                          1164              
00000776  DC87                    1165            ADD.L D7,D6               ; add into checksum
00000778                          1166            
00000778                          1167m           PRINT_CHAR D7,D3          ; assume ASCII and print it
00000778                          1168m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000778                 TRUE     1169m     IFEQ DEBUG
00000778  1639 00D30003           1170m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000077E  0803 0002               1171m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000782  67F4                    1172m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
00000784  13C7 00D30007           1173m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000078A                          1174m     ENDC
0000078A                          1175m     
0000078A                 FALSE    1176m     IFNE DEBUG
0000078A                          1177m     ENDC
0000078A                          1178m 
0000078A                          1179m     ENDM
0000078A                          1180          ENDW
0000078E                          1181m         PRINT_CRLF D3
0000078E                          1182mm     PRINT_CHAR #13,D3             ; CR
0000078E                          1183mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078E                 TRUE     1184mm     IFEQ DEBUG
0000078E  1639 00D30003           1185mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000794  0803 0002               1186mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000798  67F4                    1187mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
0000079A  13FC 000D 00D30007      1188mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000007A2                          1189mm     ENDC
000007A2                          1190mm     
000007A2                 FALSE    1191mm     IFNE DEBUG
000007A2                          1192mm     ENDC
000007A2                          1193mm 
000007A2                          1194mm     ENDM
000007A2                          1195mm     PRINT_CHAR #10,D3             ; LF
000007A2                          1196mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A2                 TRUE     1197mm     IFEQ DEBUG
000007A2  1639 00D30003           1198mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007A8  0803 0002               1199mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007AC  67F4                    1200mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
000007AE  13FC 000A 00D30007      1201mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000007B6                          1202mm     ENDC
000007B6                          1203mm     
000007B6                 FALSE    1204mm     IFNE DEBUG
000007B6                          1205mm     ENDC
000007B6                          1206mm 
000007B6                          1207mm     ENDM
000007B6                          1208m     ENDM
000007B6  43F8 0484               1209         LEA WAIT_FOR_SRECORD,A1            
000007BA                          1210      ELSE
000007BE                          1211        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit data record
000007C6  7E00                    1212          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007C8                          1213m         DOWNLOAD D2,D3              ; top byte
000007C8                          1214m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C8                          1215m 
000007C8  1639 00D30003           1216m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007CE  0803 0000               1217m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007D2  6700 0010               1218m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
000007D6                          1219m  
000007D6                          1220mm     READ_CHAR D2
000007D6                 TRUE     1221mm     IFEQ DEBUG
000007D6  1439 00D30007           1222mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007DC                          1223mm     ENDC
000007DC                 FALSE    1224mm     IFNE DEBUG
000007DC                          1225mm     ENDC
000007DC                          1226mm      
000007DC  B43C 001B               1227mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007E0  6700 F826               1228mm     BEQ START
000007E4                          1229mm     ENDM
000007E4                          1230m CONTINUE_76
000007E4  1639 00D30013           1231m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007EA  0803 0000               1232m     BTST #0,D3                  ; CHECK FOR CHARACTER
000007EE  67D8                    1233m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
000007F0                          1234m     
000007F0  1439 00D30017           1235m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000007F6  13C2 00E00001           1236m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000007FC                          1237m     
000007FC                          1238m     ENDM
000007FC                          1239m         PRINT_CHAR D2,D3
000007FC                          1240m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FC                 TRUE     1241m     IFEQ DEBUG
000007FC  1639 00D30003           1242m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000802  0803 0002               1243m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000806  67F4                    1244m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
00000808  13C2 00D30007           1245m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000080E                          1246m     ENDC
0000080E                          1247m     
0000080E                 FALSE    1248m     IFNE DEBUG
0000080E                          1249m     ENDC
0000080E                          1250m 
0000080E                          1251m     ENDM
0000080E                          1252m         HEX2BIN D2,D2,A0
0000080E  41F9 00001149           1253m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000814  0402 0030               1254m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000818  C4BC 000000FF           1255m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000081E  1430 2000               1256m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000822                          1257m   ENDM
00000822  8E82                    1258          OR.L D2,D7
00000824  E98F                    1259          LSL.L #4,D7
00000826                          1260m         DOWNLOAD D2,D3         
00000826                          1261m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                          1262m 
00000826  1639 00D30003           1263m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000082C  0803 0000               1264m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000830  6700 0010               1265m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00000834                          1266m  
00000834                          1267mm     READ_CHAR D2
00000834                 TRUE     1268mm     IFEQ DEBUG
00000834  1439 00D30007           1269mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000083A                          1270mm     ENDC
0000083A                 FALSE    1271mm     IFNE DEBUG
0000083A                          1272mm     ENDC
0000083A                          1273mm      
0000083A  B43C 001B               1274mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000083E  6700 F7C8               1275mm     BEQ START
00000842                          1276mm     ENDM
00000842                          1277m CONTINUE_80
00000842  1639 00D30013           1278m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000848  0803 0000               1279m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000084C  67D8                    1280m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
0000084E                          1281m     
0000084E  1439 00D30017           1282m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000854  13C2 00E00001           1283m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000085A                          1284m     
0000085A                          1285m     ENDM
0000085A                          1286m         PRINT_CHAR D2,D3
0000085A                          1287m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085A                 TRUE     1288m     IFEQ DEBUG
0000085A  1639 00D30003           1289m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000860  0803 0002               1290m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000864  67F4                    1291m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00000866  13C2 00D30007           1292m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000086C                          1293m     ENDC
0000086C                          1294m     
0000086C                 FALSE    1295m     IFNE DEBUG
0000086C                          1296m     ENDC
0000086C                          1297m 
0000086C                          1298m     ENDM
0000086C                          1299m         HEX2BIN D2,D2,A0
0000086C  41F9 00001149           1300m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000872  0402 0030               1301m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000876  C4BC 000000FF           1302m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000087C  1430 2000               1303m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000880                          1304m   ENDM
00000880  8E82                    1305          OR.L D2,D7
00000882                          1306          
00000882  DC87                    1307          ADD.L D7,D6                 ; add top byte of address into checksum
00000884                          1308  
00000884  E98F                    1309          LSL.L #4,D7                 ; bottom byte
00000886                          1310m         DOWNLOAD D2,D3
00000886                          1311m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000886                          1312m 
00000886  1639 00D30003           1313m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000088C  0803 0000               1314m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000890  6700 0010               1315m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
00000894                          1316m  
00000894                          1317mm     READ_CHAR D2
00000894                 TRUE     1318mm     IFEQ DEBUG
00000894  1439 00D30007           1319mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000089A                          1320mm     ENDC
0000089A                 FALSE    1321mm     IFNE DEBUG
0000089A                          1322mm     ENDC
0000089A                          1323mm      
0000089A  B43C 001B               1324mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000089E  6700 F768               1325mm     BEQ START
000008A2                          1326mm     ENDM
000008A2                          1327m CONTINUE_84
000008A2  1639 00D30013           1328m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008A8  0803 0000               1329m     BTST #0,D3                  ; CHECK FOR CHARACTER
000008AC  67D8                    1330m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
000008AE                          1331m     
000008AE  1439 00D30017           1332m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000008B4  13C2 00E00001           1333m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000008BA                          1334m     
000008BA                          1335m     ENDM
000008BA                          1336m         PRINT_CHAR D2,D3
000008BA                          1337m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BA                 TRUE     1338m     IFEQ DEBUG
000008BA  1639 00D30003           1339m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008C0  0803 0002               1340m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008C4  67F4                    1341m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
000008C6  13C2 00D30007           1342m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000008CC                          1343m     ENDC
000008CC                          1344m     
000008CC                 FALSE    1345m     IFNE DEBUG
000008CC                          1346m     ENDC
000008CC                          1347m 
000008CC                          1348m     ENDM
000008CC                          1349m         HEX2BIN D2,D2,A0
000008CC  41F9 00001149           1350m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000008D2  0402 0030               1351m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D6  C4BC 000000FF           1352m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000008DC  1430 2000               1353m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000008E0                          1354m   ENDM
000008E0  8E82                    1355          OR.L D2,D7
000008E2  E98F                    1356          LSL.L #4,D7        
000008E4                          1357m         DOWNLOAD D2,D3
000008E4                          1358m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E4                          1359m 
000008E4  1639 00D30003           1360m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000008EA  0803 0000               1361m     BTST #0,D3                    ; CHECK FOR CHARACTER
000008EE  6700 0010               1362m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
000008F2                          1363m  
000008F2                          1364mm     READ_CHAR D2
000008F2                 TRUE     1365mm     IFEQ DEBUG
000008F2  1439 00D30007           1366mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000008F8                          1367mm     ENDC
000008F8                 FALSE    1368mm     IFNE DEBUG
000008F8                          1369mm     ENDC
000008F8                          1370mm      
000008F8  B43C 001B               1371mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008FC  6700 F70A               1372mm     BEQ START
00000900                          1373mm     ENDM
00000900                          1374m CONTINUE_88
00000900  1639 00D30013           1375m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000906  0803 0000               1376m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000090A  67D8                    1377m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
0000090C                          1378m     
0000090C  1439 00D30017           1379m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000912  13C2 00E00001           1380m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000918                          1381m     
00000918                          1382m     ENDM
00000918                          1383m         PRINT_CHAR D2,D3
00000918                          1384m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000918                 TRUE     1385m     IFEQ DEBUG
00000918  1639 00D30003           1386m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000091E  0803 0002               1387m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000922  67F4                    1388m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00000924  13C2 00D30007           1389m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000092A                          1390m     ENDC
0000092A                          1391m     
0000092A                 FALSE    1392m     IFNE DEBUG
0000092A                          1393m     ENDC
0000092A                          1394m 
0000092A                          1395m     ENDM
0000092A                          1396m         HEX2BIN D2,D2,A0
0000092A  41F9 00001149           1397m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000930  0402 0030               1398m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000934  C4BC 000000FF           1399m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000093A  1430 2000               1400m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000093E                          1401m   ENDM
0000093E  8E82                    1402          OR.L D2,D7
00000940                          1403          
00000940  7400                    1404          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000942  1407                    1405          MOVE.B D7,D2
00000944  DC82                    1406          ADD.L D2,D6
00000946                          1407          
00000946  2247                    1408          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000948                          1409                 
00000948  5785                    1410          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
0000094A                          1411          WHILE.L D5 <GT> #0 DO       ; read the data bytes
00000954  5385                    1412            SUB.L #1,D5
00000956                          1413              
00000956  7E00                    1414            MOVE.L #0,D7              ; D7 holds the byte
00000958                          1415              
00000958                          1416m           DOWNLOAD D2,D3            ; MS 4 bits
00000958                          1417m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000958                          1418m 
00000958  1639 00D30003           1419m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000095E  0803 0000               1420m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000962  6700 0010               1421m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
00000966                          1422m  
00000966                          1423mm     READ_CHAR D2
00000966                 TRUE     1424mm     IFEQ DEBUG
00000966  1439 00D30007           1425mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000096C                          1426mm     ENDC
0000096C                 FALSE    1427mm     IFNE DEBUG
0000096C                          1428mm     ENDC
0000096C                          1429mm      
0000096C  B43C 001B               1430mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000970  6700 F696               1431mm     BEQ START
00000974                          1432mm     ENDM
00000974                          1433m CONTINUE_92
00000974  1639 00D30013           1434m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000097A  0803 0000               1435m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000097E  67D8                    1436m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
00000980                          1437m     
00000980  1439 00D30017           1438m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000986  13C2 00E00001           1439m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000098C                          1440m     
0000098C                          1441m     ENDM
0000098C                          1442m           PRINT_CHAR D2,D3
0000098C                          1443m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1444m     IFEQ DEBUG
0000098C  1639 00D30003           1445m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000992  0803 0002               1446m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000996  67F4                    1447m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
00000998  13C2 00D30007           1448m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000099E                          1449m     ENDC
0000099E                          1450m     
0000099E                 FALSE    1451m     IFNE DEBUG
0000099E                          1452m     ENDC
0000099E                          1453m 
0000099E                          1454m     ENDM
0000099E                          1455m           HEX2BIN D2,D2,A0
0000099E  41F9 00001149           1456m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000009A4  0402 0030               1457m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009A8  C4BC 000000FF           1458m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009AE  1430 2000               1459m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009B2                          1460m   ENDM
000009B2  8E82                    1461            OR.L D2,D7
000009B4  E98F                    1462            LSL.L #4,D7
000009B6                          1463               
000009B6                          1464m           DOWNLOAD D2,D3            ; LS 4 bits    
000009B6                          1465m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B6                          1466m 
000009B6  1639 00D30003           1467m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000009BC  0803 0000               1468m     BTST #0,D3                    ; CHECK FOR CHARACTER
000009C0  6700 0010               1469m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
000009C4                          1470m  
000009C4                          1471mm     READ_CHAR D2
000009C4                 TRUE     1472mm     IFEQ DEBUG
000009C4  1439 00D30007           1473mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000009CA                          1474mm     ENDC
000009CA                 FALSE    1475mm     IFNE DEBUG
000009CA                          1476mm     ENDC
000009CA                          1477mm      
000009CA  B43C 001B               1478mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000009CE  6700 F638               1479mm     BEQ START
000009D2                          1480mm     ENDM
000009D2                          1481m CONTINUE_96
000009D2  1639 00D30013           1482m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000009D8  0803 0000               1483m     BTST #0,D3                  ; CHECK FOR CHARACTER
000009DC  67D8                    1484m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
000009DE                          1485m     
000009DE  1439 00D30017           1486m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000009E4  13C2 00E00001           1487m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009EA                          1488m     
000009EA                          1489m     ENDM
000009EA                          1490m           PRINT_CHAR D2,D3
000009EA                          1491m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EA                 TRUE     1492m     IFEQ DEBUG
000009EA  1639 00D30003           1493m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009F0  0803 0002               1494m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009F4  67F4                    1495m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
000009F6  13C2 00D30007           1496m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000009FC                          1497m     ENDC
000009FC                          1498m     
000009FC                 FALSE    1499m     IFNE DEBUG
000009FC                          1500m     ENDC
000009FC                          1501m 
000009FC                          1502m     ENDM
000009FC                          1503m           HEX2BIN D2,D2,A0
000009FC  41F9 00001149           1504m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A02  0402 0030               1505m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A06  C4BC 000000FF           1506m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A0C  1430 2000               1507m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A10                          1508m   ENDM
00000A10  8E82                    1509            OR.L D2,D7
00000A12                          1510              
00000A12  DC87                    1511            ADD.L D7,D6               ; add into checksum            
00000A14                          1512          ENDW
00000A18                          1513m         PRINT_CRLF D3
00000A18                          1514mm     PRINT_CHAR #13,D3             ; CR
00000A18                          1515mm WAIT_FOR_READY_101                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A18                 TRUE     1516mm     IFEQ DEBUG
00000A18  1639 00D30003           1517mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A1E  0803 0002               1518mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A22  67F4                    1519mm       BEQ WAIT_FOR_READY_101          ; NO SPACE, CHECK AGAIN
00000A24  13FC 000D 00D30007      1520mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A2C                          1521mm     ENDC
00000A2C                          1522mm     
00000A2C                 FALSE    1523mm     IFNE DEBUG
00000A2C                          1524mm     ENDC
00000A2C                          1525mm 
00000A2C                          1526mm     ENDM
00000A2C                          1527mm     PRINT_CHAR #10,D3             ; LF
00000A2C                          1528mm WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2C                 TRUE     1529mm     IFEQ DEBUG
00000A2C  1639 00D30003           1530mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A32  0803 0002               1531mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A36  67F4                    1532mm       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00000A38  13FC 000A 00D30007      1533mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A40                          1534mm     ENDC
00000A40                          1535mm     
00000A40                 FALSE    1536mm     IFNE DEBUG
00000A40                          1537mm     ENDC
00000A40                          1538mm 
00000A40                          1539mm     ENDM
00000A40                          1540m     ENDM
00000A40  43F8 0484               1541          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00000A44                          1542        ELSE
00000A48                          1543          IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00000A50  7E00                    1544            MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000A52                          1545m           DOWNLOAD D2,D3            ; top byte
00000A52                          1546m WAIT_FOR_READY_103                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A52                          1547m 
00000A52  1639 00D30003           1548m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A58  0803 0000               1549m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A5C  6700 0010               1550m     BEQ CONTINUE_103                ; NOTHING, CONTINUE
00000A60                          1551m  
00000A60                          1552mm     READ_CHAR D2
00000A60                 TRUE     1553mm     IFEQ DEBUG
00000A60  1439 00D30007           1554mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A66                          1555mm     ENDC
00000A66                 FALSE    1556mm     IFNE DEBUG
00000A66                          1557mm     ENDC
00000A66                          1558mm      
00000A66  B43C 001B               1559mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A6A  6700 F59C               1560mm     BEQ START
00000A6E                          1561mm     ENDM
00000A6E                          1562m CONTINUE_103
00000A6E  1639 00D30013           1563m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A74  0803 0000               1564m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A78  67D8                    1565m     BEQ WAIT_FOR_READY_103        ; NOTHING, CHECK AGAIN
00000A7A                          1566m     
00000A7A  1439 00D30017           1567m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A80  13C2 00E00001           1568m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000A86                          1569m     
00000A86                          1570m     ENDM
00000A86                          1571m           HEX2BIN D2,D2,A0
00000A86  41F9 00001149           1572m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A8C  0402 0030               1573m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A90  C4BC 000000FF           1574m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A96  1430 2000               1575m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A9A                          1576m   ENDM
00000A9A  8E82                    1577            OR.L D2,D7
00000A9C  E98F                    1578            LSL.L #4,D7
00000A9E                          1579m           DOWNLOAD D2,D3         
00000A9E                          1580m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9E                          1581m 
00000A9E  1639 00D30003           1582m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AA4  0803 0000               1583m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AA8  6700 0010               1584m     BEQ CONTINUE_106                ; NOTHING, CONTINUE
00000AAC                          1585m  
00000AAC                          1586mm     READ_CHAR D2
00000AAC                 TRUE     1587mm     IFEQ DEBUG
00000AAC  1439 00D30007           1588mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AB2                          1589mm     ENDC
00000AB2                 FALSE    1590mm     IFNE DEBUG
00000AB2                          1591mm     ENDC
00000AB2                          1592mm      
00000AB2  B43C 001B               1593mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AB6  6700 F550               1594mm     BEQ START
00000ABA                          1595mm     ENDM
00000ABA                          1596m CONTINUE_106
00000ABA  1639 00D30013           1597m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000AC0  0803 0000               1598m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000AC4  67D8                    1599m     BEQ WAIT_FOR_READY_106        ; NOTHING, CHECK AGAIN
00000AC6                          1600m     
00000AC6  1439 00D30017           1601m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000ACC  13C2 00E00001           1602m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000AD2                          1603m     
00000AD2                          1604m     ENDM
00000AD2                          1605m           HEX2BIN D2,D2,A0
00000AD2  41F9 00001149           1606m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000AD8  0402 0030               1607m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000ADC  C4BC 000000FF           1608m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000AE2  1430 2000               1609m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000AE6                          1610m   ENDM
00000AE6  8E82                    1611            OR.L D2,D7
00000AE8                          1612          
00000AE8  DC87                    1613            ADD.L D7,D6               ; add top byte of address into checksum
00000AEA                          1614  
00000AEA  E98F                    1615            LSL.L #4,D7               ; middle byte
00000AEC                          1616m           DOWNLOAD D2,D3
00000AEC                          1617m WAIT_FOR_READY_109                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEC                          1618m 
00000AEC  1639 00D30003           1619m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AF2  0803 0000               1620m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AF6  6700 0010               1621m     BEQ CONTINUE_109                ; NOTHING, CONTINUE
00000AFA                          1622m  
00000AFA                          1623mm     READ_CHAR D2
00000AFA                 TRUE     1624mm     IFEQ DEBUG
00000AFA  1439 00D30007           1625mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B00                          1626mm     ENDC
00000B00                 FALSE    1627mm     IFNE DEBUG
00000B00                          1628mm     ENDC
00000B00                          1629mm      
00000B00  B43C 001B               1630mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B04  6700 F502               1631mm     BEQ START
00000B08                          1632mm     ENDM
00000B08                          1633m CONTINUE_109
00000B08  1639 00D30013           1634m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B0E  0803 0000               1635m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B12  67D8                    1636m     BEQ WAIT_FOR_READY_109        ; NOTHING, CHECK AGAIN
00000B14                          1637m     
00000B14  1439 00D30017           1638m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B1A  13C2 00E00001           1639m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B20                          1640m     
00000B20                          1641m     ENDM
00000B20                          1642m           HEX2BIN D2,D2,A0
00000B20  41F9 00001149           1643m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B26  0402 0030               1644m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B2A  C4BC 000000FF           1645m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B30  1430 2000               1646m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B34                          1647m   ENDM
00000B34  8E82                    1648            OR.L D2,D7
00000B36  E98F                    1649            LSL.L #4,D7        
00000B38                          1650m           DOWNLOAD D2,D3
00000B38                          1651m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B38                          1652m 
00000B38  1639 00D30003           1653m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B3E  0803 0000               1654m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B42  6700 0010               1655m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00000B46                          1656m  
00000B46                          1657mm     READ_CHAR D2
00000B46                 TRUE     1658mm     IFEQ DEBUG
00000B46  1439 00D30007           1659mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B4C                          1660mm     ENDC
00000B4C                 FALSE    1661mm     IFNE DEBUG
00000B4C                          1662mm     ENDC
00000B4C                          1663mm      
00000B4C  B43C 001B               1664mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B50  6700 F4B6               1665mm     BEQ START
00000B54                          1666mm     ENDM
00000B54                          1667m CONTINUE_112
00000B54  1639 00D30013           1668m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B5A  0803 0000               1669m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B5E  67D8                    1670m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00000B60                          1671m     
00000B60  1439 00D30017           1672m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B66  13C2 00E00001           1673m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B6C                          1674m     
00000B6C                          1675m     ENDM
00000B6C                          1676m           HEX2BIN D2,D2,A0
00000B6C  41F9 00001149           1677m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B72  0402 0030               1678m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B76  C4BC 000000FF           1679m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B7C  1430 2000               1680m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B80                          1681m   ENDM
00000B80  8E82                    1682            OR.L D2,D7
00000B82                          1683          
00000B82  7400                    1684            MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
00000B84  1407                    1685            MOVE.B D7,D2
00000B86  DC82                    1686            ADD.L D2,D6
00000B88                          1687            
00000B88  E98F                    1688            LSL.L #4,D7               ; bottom byte
00000B8A                          1689m           DOWNLOAD D2,D3
00000B8A                          1690m WAIT_FOR_READY_115                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B8A                          1691m 
00000B8A  1639 00D30003           1692m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B90  0803 0000               1693m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B94  6700 0010               1694m     BEQ CONTINUE_115                ; NOTHING, CONTINUE
00000B98                          1695m  
00000B98                          1696mm     READ_CHAR D2
00000B98                 TRUE     1697mm     IFEQ DEBUG
00000B98  1439 00D30007           1698mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B9E                          1699mm     ENDC
00000B9E                 FALSE    1700mm     IFNE DEBUG
00000B9E                          1701mm     ENDC
00000B9E                          1702mm      
00000B9E  B43C 001B               1703mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BA2  6700 F464               1704mm     BEQ START
00000BA6                          1705mm     ENDM
00000BA6                          1706m CONTINUE_115
00000BA6  1639 00D30013           1707m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BAC  0803 0000               1708m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BB0  67D8                    1709m     BEQ WAIT_FOR_READY_115        ; NOTHING, CHECK AGAIN
00000BB2                          1710m     
00000BB2  1439 00D30017           1711m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BB8  13C2 00E00001           1712m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000BBE                          1713m     
00000BBE                          1714m     ENDM
00000BBE                          1715m           HEX2BIN D2,D2,A0
00000BBE  41F9 00001149           1716m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000BC4  0402 0030               1717m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BC8  C4BC 000000FF           1718m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000BCE  1430 2000               1719m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BD2                          1720m   ENDM
00000BD2  8E82                    1721            OR.L D2,D7
00000BD4  E98F                    1722            LSL.L #4,D7        
00000BD6                          1723m           DOWNLOAD D2,D3
00000BD6                          1724m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD6                          1725m 
00000BD6  1639 00D30003           1726m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000BDC  0803 0000               1727m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000BE0  6700 0010               1728m     BEQ CONTINUE_118                ; NOTHING, CONTINUE
00000BE4                          1729m  
00000BE4                          1730mm     READ_CHAR D2
00000BE4                 TRUE     1731mm     IFEQ DEBUG
00000BE4  1439 00D30007           1732mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000BEA                          1733mm     ENDC
00000BEA                 FALSE    1734mm     IFNE DEBUG
00000BEA                          1735mm     ENDC
00000BEA                          1736mm      
00000BEA  B43C 001B               1737mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BEE  6700 F418               1738mm     BEQ START
00000BF2                          1739mm     ENDM
00000BF2                          1740m CONTINUE_118
00000BF2  1639 00D30013           1741m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BF8  0803 0000               1742m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BFC  67D8                    1743m     BEQ WAIT_FOR_READY_118        ; NOTHING, CHECK AGAIN
00000BFE                          1744m     
00000BFE  1439 00D30017           1745m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000C04  13C2 00E00001           1746m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000C0A                          1747m     
00000C0A                          1748m     ENDM
00000C0A                          1749m           HEX2BIN D2,D2,A0
00000C0A  41F9 00001149           1750m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C10  0402 0030               1751m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C14  C4BC 000000FF           1752m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C1A  1430 2000               1753m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C1E                          1754m   ENDM
00000C1E  8E82                    1755            OR.L D2,D7
00000C20                          1756          
00000C20  7400                    1757            MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00000C22  1407                    1758            MOVE.B D7,D2
00000C24  DC82                    1759            ADD.L D2,D6
00000C26                          1760            
00000C26  2447                    1761            MOVE.L D7,A2              ; start address -> A2
00000C28                          1762          
00000C28  43F9 00000DDC           1763            LEA DOWNLOAD_DONE,A1      ; next place to go
00000C2E                          1764          ELSE
00000C32  41F9 000010D5           1765            LEA UNREC,A0              ; warn for unrecognised type
00000C38                          1766m           PRINT_STR A0,D3
00000C38                          1767m LOOP_121
00000C38  0C10 0000               1768m     CMP.B #0,(A0)                 ; 0 -> DONE
00000C3C  6700 0018               1769m     BEQ EXIT_121
00000C40                          1770mm     PRINT_CHAR (A0)+,D3
00000C40                          1771mm WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C40                 TRUE     1772mm     IFEQ DEBUG
00000C40  1639 00D30003           1773mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C46  0803 0002               1774mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C4A  67F4                    1775mm       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00000C4C  13D8 00D30007           1776mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C52                          1777mm     ENDC
00000C52                          1778mm     
00000C52                 FALSE    1779mm     IFNE DEBUG
00000C52                          1780mm     ENDC
00000C52                          1781mm 
00000C52                          1782mm     ENDM
00000C52  4EF8 0C38               1783m     JMP LOOP_121
00000C56                          1784m EXIT_121
00000C56                          1785m     ENDM
00000C56                          1786m           PRINT_CHAR D7,D3
00000C56                          1787m WAIT_FOR_READY_123                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C56                 TRUE     1788m     IFEQ DEBUG
00000C56  1639 00D30003           1789m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C5C  0803 0002               1790m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C60  67F4                    1791m       BEQ WAIT_FOR_READY_123          ; NO SPACE, CHECK AGAIN
00000C62  13C7 00D30007           1792m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C68                          1793m     ENDC
00000C68                          1794m     
00000C68                 FALSE    1795m     IFNE DEBUG
00000C68                          1796m     ENDC
00000C68                          1797m 
00000C68                          1798m     ENDM
00000C68                          1799m           PRINT_CRLF D3
00000C68                          1800mm     PRINT_CHAR #13,D3             ; CR
00000C68                          1801mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C68                 TRUE     1802mm     IFEQ DEBUG
00000C68  1639 00D30003           1803mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C6E  0803 0002               1804mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C72  67F4                    1805mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00000C74  13FC 000D 00D30007      1806mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C7C                          1807mm     ENDC
00000C7C                          1808mm     
00000C7C                 FALSE    1809mm     IFNE DEBUG
00000C7C                          1810mm     ENDC
00000C7C                          1811mm 
00000C7C                          1812mm     ENDM
00000C7C                          1813mm     PRINT_CHAR #10,D3             ; LF
00000C7C                          1814mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C7C                 TRUE     1815mm     IFEQ DEBUG
00000C7C  1639 00D30003           1816mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C82  0803 0002               1817mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C86  67F4                    1818mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00000C88  13FC 000A 00D30007      1819mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C90                          1820mm     ENDC
00000C90                          1821mm     
00000C90                 FALSE    1822mm     IFNE DEBUG
00000C90                          1823mm     ENDC
00000C90                          1824mm 
00000C90                          1825mm     ENDM
00000C90                          1826m     ENDM
00000C90                          1827      
00000C90  4EF8 0484               1828            JMP WAIT_FOR_SRECORD      ; ignore any other type    
00000C94                          1829          ENDI
00000C94                          1830        ENDI
00000C94                          1831      ENDI
00000C94                          1832      
00000C94  4686                    1833      NOT.L D6                        ; ones complement the checksum
00000C96  0286 000000FF           1834      ANDI.L #$FF,D6                  ; and take the LSByte
00000C9C                          1835          
00000C9C  7E00                    1836      MOVE.L #0,D7                    ; read the checksum from the data stream
00000C9E                          1837m     DOWNLOAD D2,D3                  ; top byte
00000C9E                          1838m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9E                          1839m 
00000C9E  1639 00D30003           1840m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CA4  0803 0000               1841m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CA8  6700 0010               1842m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00000CAC                          1843m  
00000CAC                          1844mm     READ_CHAR D2
00000CAC                 TRUE     1845mm     IFEQ DEBUG
00000CAC  1439 00D30007           1846mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CB2                          1847mm     ENDC
00000CB2                 FALSE    1848mm     IFNE DEBUG
00000CB2                          1849mm     ENDC
00000CB2                          1850mm      
00000CB2  B43C 001B               1851mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CB6  6700 F350               1852mm     BEQ START
00000CBA                          1853mm     ENDM
00000CBA                          1854m CONTINUE_127
00000CBA  1639 00D30013           1855m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000CC0  0803 0000               1856m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000CC4  67D8                    1857m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00000CC6                          1858m     
00000CC6  1439 00D30017           1859m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000CCC  13C2 00E00001           1860m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000CD2                          1861m     
00000CD2                          1862m     ENDM
00000CD2                          1863m     HEX2BIN D2,D2,A0
00000CD2  41F9 00001149           1864m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000CD8  0402 0030               1865m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CDC  C4BC 000000FF           1866m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000CE2  1430 2000               1867m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000CE6                          1868m   ENDM
00000CE6  8E82                    1869      OR.L D2,D7
00000CE8  E98F                    1870      LSL.L #4,D7
00000CEA                          1871m     DOWNLOAD D2,D3                  ; bottom byte
00000CEA                          1872m WAIT_FOR_READY_130                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CEA                          1873m 
00000CEA  1639 00D30003           1874m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CF0  0803 0000               1875m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CF4  6700 0010               1876m     BEQ CONTINUE_130                ; NOTHING, CONTINUE
00000CF8                          1877m  
00000CF8                          1878mm     READ_CHAR D2
00000CF8                 TRUE     1879mm     IFEQ DEBUG
00000CF8  1439 00D30007           1880mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CFE                          1881mm     ENDC
00000CFE                 FALSE    1882mm     IFNE DEBUG
00000CFE                          1883mm     ENDC
00000CFE                          1884mm      
00000CFE  B43C 001B               1885mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000D02  6700 F304               1886mm     BEQ START
00000D06                          1887mm     ENDM
00000D06                          1888m CONTINUE_130
00000D06  1639 00D30013           1889m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000D0C  0803 0000               1890m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000D10  67D8                    1891m     BEQ WAIT_FOR_READY_130        ; NOTHING, CHECK AGAIN
00000D12                          1892m     
00000D12  1439 00D30017           1893m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000D18  13C2 00E00001           1894m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000D1E                          1895m     
00000D1E                          1896m     ENDM
00000D1E                          1897m     HEX2BIN D2,D2,A0
00000D1E  41F9 00001149           1898m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D24  0402 0030               1899m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D28  C4BC 000000FF           1900m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D2E  1430 2000               1901m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D32                          1902m   ENDM
00000D32  8E82                    1903      OR.L D2,D7
00000D34                          1904                  
00000D34                          1905      IF.B D7 <NE> D6 THEN.L
00000D3A  41F9 000010FB           1906        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00000D40                          1907m       PRINT_STR A0,D3
00000D40                          1908m LOOP_133
00000D40  0C10 0000               1909m     CMP.B #0,(A0)                 ; 0 -> DONE
00000D44  6700 0018               1910m     BEQ EXIT_133
00000D48                          1911mm     PRINT_CHAR (A0)+,D3
00000D48                          1912mm WAIT_FOR_READY_134                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D48                 TRUE     1913mm     IFEQ DEBUG
00000D48  1639 00D30003           1914mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D4E  0803 0002               1915mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D52  67F4                    1916mm       BEQ WAIT_FOR_READY_134          ; NO SPACE, CHECK AGAIN
00000D54  13D8 00D30007           1917mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D5A                          1918mm     ENDC
00000D5A                          1919mm     
00000D5A                 FALSE    1920mm     IFNE DEBUG
00000D5A                          1921mm     ENDC
00000D5A                          1922mm 
00000D5A                          1923mm     ENDM
00000D5A  4EF8 0D40               1924m     JMP LOOP_133
00000D5E                          1925m EXIT_133
00000D5E                          1926m     ENDM
00000D5E                          1927m       PRINT_REG D4,D3,D6,D7,A0
00000D5E                          1928mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000D5E                          1929mm WAIT_FOR_READY_136                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5E                 TRUE     1930mm     IFEQ DEBUG
00000D5E  1639 00D30003           1931mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D64  0803 0002               1932mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D68  67F4                    1933mm       BEQ WAIT_FOR_READY_136          ; NO SPACE, CHECK AGAIN
00000D6A  13FC 0030 00D30007      1934mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000D72                          1935mm     ENDC
00000D72                          1936mm     
00000D72                 FALSE    1937mm     IFNE DEBUG
00000D72                          1938mm     ENDC
00000D72                          1939mm 
00000D72                          1940mm     ENDM
00000D72                          1941mm     PRINT_CHAR #'x',D3
00000D72                          1942mm WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     1943mm     IFEQ DEBUG
00000D72  1639 00D30003           1944mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D78  0803 0002               1945mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    1946mm       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00000D7E  13FC 0078 00D30007      1947mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000D86                          1948mm     ENDC
00000D86                          1949mm     
00000D86                 FALSE    1950mm     IFNE DEBUG
00000D86                          1951mm     ENDC
00000D86                          1952mm 
00000D86                          1953mm     ENDM
00000D86  7E07                    1954m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D88                          1955m LOOP_135
00000D88                          1956mm     BIN2HEX D4,D6,A0
00000D88  41F9 00001139           1957mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000D8E  E99C                    1958mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D90  1C04                    1959mm   MOVE.B D4,D6
00000D92  0286 0000000F           1960mm   ANDI.L #$F,D6
00000D98  1C30 6000               1961mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
00000D9C                          1962mm   ENDM
00000D9C                          1963mm     PRINT_CHAR D6,D3
00000D9C                          1964mm WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D9C                 TRUE     1965mm     IFEQ DEBUG
00000D9C  1639 00D30003           1966mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DA2  0803 0002               1967mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DA6  67F4                    1968mm       BEQ WAIT_FOR_READY_139          ; NO SPACE, CHECK AGAIN
00000DA8  13C6 00D30007           1969mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DAE                          1970mm     ENDC
00000DAE                          1971mm     
00000DAE                 FALSE    1972mm     IFNE DEBUG
00000DAE                          1973mm     ENDC
00000DAE                          1974mm 
00000DAE                          1975mm     ENDM
00000DAE  57CF FFD8               1976m     DBEQ D7,LOOP_135
00000DB2                          1977m     ENDM
00000DB2                          1978m       PRINT_CRLF D3     
00000DB2                          1979mm     PRINT_CHAR #13,D3             ; CR
00000DB2                          1980mm WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB2                 TRUE     1981mm     IFEQ DEBUG
00000DB2  1639 00D30003           1982mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DB8  0803 0002               1983mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DBC  67F4                    1984mm       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00000DBE  13FC 000D 00D30007      1985mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DC6                          1986mm     ENDC
00000DC6                          1987mm     
00000DC6                 FALSE    1988mm     IFNE DEBUG
00000DC6                          1989mm     ENDC
00000DC6                          1990mm 
00000DC6                          1991mm     ENDM
00000DC6                          1992mm     PRINT_CHAR #10,D3             ; LF
00000DC6                          1993mm WAIT_FOR_READY_142                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC6                 TRUE     1994mm     IFEQ DEBUG
00000DC6  1639 00D30003           1995mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DCC  0803 0002               1996mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DD0  67F4                    1997mm       BEQ WAIT_FOR_READY_142          ; NO SPACE, CHECK AGAIN
00000DD2  13FC 000A 00D30007      1998mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DDA                          1999mm     ENDC
00000DDA                          2000mm     
00000DDA                 FALSE    2001mm     IFNE DEBUG
00000DDA                          2002mm     ENDC
00000DDA                          2003mm 
00000DDA                          2004mm     ENDM
00000DDA                          2005m     ENDM
00000DDA                          2006      ENDI
00000DDA                          2007      
00000DDA  4ED1                    2008      JMP (A1)
00000DDC                          2009  DOWNLOAD_DONE
00000DDC                          2010m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00000DDC                          2011mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000DDC                          2012mm WAIT_FOR_READY_144                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDC                 TRUE     2013mm     IFEQ DEBUG
00000DDC  1639 00D30003           2014mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DE2  0803 0002               2015mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DE6  67F4                    2016mm       BEQ WAIT_FOR_READY_144          ; NO SPACE, CHECK AGAIN
00000DE8  13FC 0030 00D30007      2017mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000DF0                          2018mm     ENDC
00000DF0                          2019mm     
00000DF0                 FALSE    2020mm     IFNE DEBUG
00000DF0                          2021mm     ENDC
00000DF0                          2022mm 
00000DF0                          2023mm     ENDM
00000DF0                          2024mm     PRINT_CHAR #'x',D3
00000DF0                          2025mm WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF0                 TRUE     2026mm     IFEQ DEBUG
00000DF0  1639 00D30003           2027mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DF6  0803 0002               2028mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DFA  67F4                    2029mm       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00000DFC  13FC 0078 00D30007      2030mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000E04                          2031mm     ENDC
00000E04                          2032mm     
00000E04                 FALSE    2033mm     IFNE DEBUG
00000E04                          2034mm     ENDC
00000E04                          2035mm 
00000E04                          2036mm     ENDM
00000E04  7C07                    2037m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E06                          2038m LOOP_143
00000E06                          2039mm     BIN2HEX D4,D7,A0
00000E06  41F9 00001139           2040mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000E0C  E99C                    2041mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E0E  1E04                    2042mm   MOVE.B D4,D7
00000E10  0287 0000000F           2043mm   ANDI.L #$F,D7
00000E16  1E30 7000               2044mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000E1A                          2045mm   ENDM
00000E1A                          2046mm     PRINT_CHAR D7,D3
00000E1A                          2047mm WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1A                 TRUE     2048mm     IFEQ DEBUG
00000E1A  1639 00D30003           2049mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E20  0803 0002               2050mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E24  67F4                    2051mm       BEQ WAIT_FOR_READY_147          ; NO SPACE, CHECK AGAIN
00000E26  13C7 00D30007           2052mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E2C                          2053mm     ENDC
00000E2C                          2054mm     
00000E2C                 FALSE    2055mm     IFNE DEBUG
00000E2C                          2056mm     ENDC
00000E2C                          2057mm 
00000E2C                          2058mm     ENDM
00000E2C  57CE FFD8               2059m     DBEQ D6,LOOP_143
00000E30                          2060m     ENDM
00000E30  41F9 000010B3           2061      LEA READ,A0
00000E36                          2062m     PRINT_STR A0,D3
00000E36                          2063m LOOP_148
00000E36  0C10 0000               2064m     CMP.B #0,(A0)                 ; 0 -> DONE
00000E3A  6700 0018               2065m     BEQ EXIT_148
00000E3E                          2066mm     PRINT_CHAR (A0)+,D3
00000E3E                          2067mm WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3E                 TRUE     2068mm     IFEQ DEBUG
00000E3E  1639 00D30003           2069mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E44  0803 0002               2070mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E48  67F4                    2071mm       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00000E4A  13D8 00D30007           2072mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E50                          2073mm     ENDC
00000E50                          2074mm     
00000E50                 FALSE    2075mm     IFNE DEBUG
00000E50                          2076mm     ENDC
00000E50                          2077mm 
00000E50                          2078mm     ENDM
00000E50  4EF8 0E36               2079m     JMP LOOP_148
00000E54                          2080m EXIT_148
00000E54                          2081m     ENDM
00000E54  2E0A                    2082      MOVE.L A2,D7                    ; set address accumulator to start address
00000E56                          2083m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
00000E56                          2084mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000E56                          2085mm WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E56                 TRUE     2086mm     IFEQ DEBUG
00000E56  1639 00D30003           2087mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E5C  0803 0002               2088mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E60  67F4                    2089mm       BEQ WAIT_FOR_READY_151          ; NO SPACE, CHECK AGAIN
00000E62  13FC 0030 00D30007      2090mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000E6A                          2091mm     ENDC
00000E6A                          2092mm     
00000E6A                 FALSE    2093mm     IFNE DEBUG
00000E6A                          2094mm     ENDC
00000E6A                          2095mm 
00000E6A                          2096mm     ENDM
00000E6A                          2097mm     PRINT_CHAR #'x',D3
00000E6A                          2098mm WAIT_FOR_READY_152                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E6A                 TRUE     2099mm     IFEQ DEBUG
00000E6A  1639 00D30003           2100mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E70  0803 0002               2101mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E74  67F4                    2102mm       BEQ WAIT_FOR_READY_152          ; NO SPACE, CHECK AGAIN
00000E76  13FC 0078 00D30007      2103mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000E7E                          2104mm     ENDC
00000E7E                          2105mm     
00000E7E                 FALSE    2106mm     IFNE DEBUG
00000E7E                          2107mm     ENDC
00000E7E                          2108mm 
00000E7E                          2109mm     ENDM
00000E7E  7C07                    2110m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E80                          2111m LOOP_150
00000E80                          2112mm     BIN2HEX D7,D2,A0
00000E80  41F9 00001139           2113mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000E86  E99F                    2114mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E88  1407                    2115mm   MOVE.B D7,D2
00000E8A  0282 0000000F           2116mm   ANDI.L #$F,D2
00000E90  1430 2000               2117mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00000E94                          2118mm   ENDM
00000E94                          2119mm     PRINT_CHAR D2,D3
00000E94                          2120mm WAIT_FOR_READY_154                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E94                 TRUE     2121mm     IFEQ DEBUG
00000E94  1639 00D30003           2122mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E9A  0803 0002               2123mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E9E  67F4                    2124mm       BEQ WAIT_FOR_READY_154          ; NO SPACE, CHECK AGAIN
00000EA0  13C2 00D30007           2125mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000EA6                          2126mm     ENDC
00000EA6                          2127mm     
00000EA6                 FALSE    2128mm     IFNE DEBUG
00000EA6                          2129mm     ENDC
00000EA6                          2130mm 
00000EA6                          2131mm     ENDM
00000EA6  57CE FFD8               2132m     DBEQ D6,LOOP_150
00000EAA                          2133m     ENDM
00000EAA                          2134m     PRINT_CRLF D3     
00000EAA                          2135mm     PRINT_CHAR #13,D3             ; CR
00000EAA                          2136mm WAIT_FOR_READY_156                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EAA                 TRUE     2137mm     IFEQ DEBUG
00000EAA  1639 00D30003           2138mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EB0  0803 0002               2139mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EB4  67F4                    2140mm       BEQ WAIT_FOR_READY_156          ; NO SPACE, CHECK AGAIN
00000EB6  13FC 000D 00D30007      2141mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000EBE                          2142mm     ENDC
00000EBE                          2143mm     
00000EBE                 FALSE    2144mm     IFNE DEBUG
00000EBE                          2145mm     ENDC
00000EBE                          2146mm 
00000EBE                          2147mm     ENDM
00000EBE                          2148mm     PRINT_CHAR #10,D3             ; LF
00000EBE                          2149mm WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EBE                 TRUE     2150mm     IFEQ DEBUG
00000EBE  1639 00D30003           2151mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EC4  0803 0002               2152mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EC8  67F4                    2153mm       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00000ECA  13FC 000A 00D30007      2154mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000ED2                          2155mm     ENDC
00000ED2                          2156mm     
00000ED2                 FALSE    2157mm     IFNE DEBUG
00000ED2                          2158mm     ENDC
00000ED2                          2159mm 
00000ED2                          2160mm     ENDM
00000ED2                          2161m     ENDM
00000ED2                          2162          
00000ED2  4EF8 0186               2163      JMP MAIN_LOOP
00000ED6                          2164      
00000ED6  2047                    2165  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000ED8  3E3C 0000               2166      MOVE #0,D7                      ; clear the now used address accumulator
00000EDC  4ED0                    2167      JMP (A0)                        ; jump to it!
00000EDE                          2168      
00000EDE  207C 00200000           2169  Z   MOVE.L #RAM,A0                  ; address of RAM
00000EE4  7000                    2170      MOVE.L #0,D0                    ; number of bytes
00000EE6                          2171     
00000EE6                          2172      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
00000EF0                          2173         
00000EF0  2200                    2174        MOVE.L D0,D1                  ; progress update
00000EF2  E089                    2175        LSR.L #8,D1 
00000EF4  E089                    2176        LSR.L #8,D1
00000EF6  0281 0000000F           2177        ANDI.L #$F,D1
00000EFC  13C1 00E00001           2178        MOVE.B D1,DISPLAY
00000F02                          2179  
00000F02  20C0                    2180        MOVE.L D0,(A0)+ 
00000F04  5880                    2181        ADD.L #4,D0
00000F06                          2182      ENDW
00000F08                          2183   
00000F08  207C 00200000           2184      MOVE.L #RAM,A0              ; address of RAM
00000F0E  7000                    2185      MOVE.L #0,D0                ; number of bytes
00000F10                          2186     
00000F10                          2187      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00000F1A                          2188  
00000F1A  2200                    2189        MOVE.L D0,D1              ; progress update
00000F1C  E089                    2190        LSR.L #8,D1
00000F1E  E089                    2191        LSR.L #8,D1
00000F20  0281 0000000F           2192        ANDI.L #$F,D1
00000F26  13C1 00E00001           2193        MOVE.B D1,DISPLAY
00000F2C                          2194  
00000F2C  2218                    2195        MOVE.L (A0)+,D1
00000F2E                          2196        
00000F2E                          2197        IF.L D0 <EQ> D1 THEN
00000F34  6000 00A6               2198          BRA OK
00000F38                          2199        ENDI 
00000F38                          2200        
00000F38  43F9 00001121           2201        LEA RAM_ERROR,A1
00000F3E                          2202m       PRINT_STR A1,D1
00000F3E                          2203m LOOP_158
00000F3E  0C11 0000               2204m     CMP.B #0,(A1)                 ; 0 -> DONE
00000F42  6700 0018               2205m     BEQ EXIT_158
00000F46                          2206mm     PRINT_CHAR (A1)+,D1
00000F46                          2207mm WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F46                 TRUE     2208mm     IFEQ DEBUG
00000F46  1239 00D30003           2209mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
00000F4C  0801 0002               2210mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
00000F50  67F4                    2211mm       BEQ WAIT_FOR_READY_159          ; NO SPACE, CHECK AGAIN
00000F52  13D9 00D30007           2212mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000F58                          2213mm     ENDC
00000F58                          2214mm     
00000F58                 FALSE    2215mm     IFNE DEBUG
00000F58                          2216mm     ENDC
00000F58                          2217mm 
00000F58                          2218mm     ENDM
00000F58  4EF8 0F3E               2219m     JMP LOOP_158
00000F5C                          2220m EXIT_158
00000F5C                          2221m     ENDM
00000F5C  2208                    2222        MOVE.L A0,D1
00000F5E  5981                    2223        SUB.L #4,D1
00000F60                          2224m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
00000F60                          2225mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000F60                          2226mm WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F60                 TRUE     2227mm     IFEQ DEBUG
00000F60  1639 00D30003           2228mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000F66  0803 0002               2229mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000F6A  67F4                    2230mm       BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
00000F6C  13FC 0030 00D30007      2231mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000F74                          2232mm     ENDC
00000F74                          2233mm     
00000F74                 FALSE    2234mm     IFNE DEBUG
00000F74                          2235mm     ENDC
00000F74                          2236mm 
00000F74                          2237mm     ENDM
00000F74                          2238mm     PRINT_CHAR #'x',D3
00000F74                          2239mm WAIT_FOR_READY_162                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F74                 TRUE     2240mm     IFEQ DEBUG
00000F74  1639 00D30003           2241mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000F7A  0803 0002               2242mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000F7E  67F4                    2243mm       BEQ WAIT_FOR_READY_162          ; NO SPACE, CHECK AGAIN
00000F80  13FC 0078 00D30007      2244mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000F88                          2245mm     ENDC
00000F88                          2246mm     
00000F88                 FALSE    2247mm     IFNE DEBUG
00000F88                          2248mm     ENDC
00000F88                          2249mm 
00000F88                          2250mm     ENDM
00000F88  7C07                    2251m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F8A                          2252m LOOP_160
00000F8A                          2253mm     BIN2HEX D1,D2,A1
00000F8A  43F9 00001139           2254mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
00000F90  E999                    2255mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F92  1401                    2256mm   MOVE.B D1,D2
00000F94  0282 0000000F           2257mm   ANDI.L #$F,D2
00000F9A  1431 2000               2258mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00000F9E                          2259mm   ENDM
00000F9E                          2260mm     PRINT_CHAR D2,D3
00000F9E                          2261mm WAIT_FOR_READY_164                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F9E                 TRUE     2262mm     IFEQ DEBUG
00000F9E  1639 00D30003           2263mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000FA4  0803 0002               2264mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000FA8  67F4                    2265mm       BEQ WAIT_FOR_READY_164          ; NO SPACE, CHECK AGAIN
00000FAA  13C2 00D30007           2266mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000FB0                          2267mm     ENDC
00000FB0                          2268mm     
00000FB0                 FALSE    2269mm     IFNE DEBUG
00000FB0                          2270mm     ENDC
00000FB0                          2271mm 
00000FB0                          2272mm     ENDM
00000FB0  57CE FFD8               2273m     DBEQ D6,LOOP_160
00000FB4                          2274m     ENDM
00000FB4                          2275m       PRINT_CRLF D3
00000FB4                          2276mm     PRINT_CHAR #13,D3             ; CR
00000FB4                          2277mm WAIT_FOR_READY_166                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB4                 TRUE     2278mm     IFEQ DEBUG
00000FB4  1639 00D30003           2279mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000FBA  0803 0002               2280mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000FBE  67F4                    2281mm       BEQ WAIT_FOR_READY_166          ; NO SPACE, CHECK AGAIN
00000FC0  13FC 000D 00D30007      2282mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000FC8                          2283mm     ENDC
00000FC8                          2284mm     
00000FC8                 FALSE    2285mm     IFNE DEBUG
00000FC8                          2286mm     ENDC
00000FC8                          2287mm 
00000FC8                          2288mm     ENDM
00000FC8                          2289mm     PRINT_CHAR #10,D3             ; LF
00000FC8                          2290mm WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC8                 TRUE     2291mm     IFEQ DEBUG
00000FC8  1639 00D30003           2292mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000FCE  0803 0002               2293mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000FD2  67F4                    2294mm       BEQ WAIT_FOR_READY_167          ; NO SPACE, CHECK AGAIN
00000FD4  13FC 000A 00D30007      2295mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000FDC                          2296mm     ENDC
00000FDC                          2297mm     
00000FDC                 FALSE    2298mm     IFNE DEBUG
00000FDC                          2299mm     ENDC
00000FDC                          2300mm 
00000FDC                          2301mm     ENDM
00000FDC                          2302m     ENDM
00000FDC                          2303  OK    
00000FDC  5880                    2304        ADD.L #4,D0
00000FDE                          2305      ENDW
00000FE2                          2306      
00000FE2  4EF8 0186               2307      JMP MAIN_LOOP
00000FE6                          2308    
00000FE6                          2309  HEX_DIGIT
00000FE6  E98F                    2310      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000FE8                          2311m     HEX2BIN D2,D2,A0
00000FE8  41F9 00001149           2312m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000FEE  0402 0030               2313m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FF2  C4BC 000000FF           2314m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000FF8  1430 2000               2315m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000FFC                          2316m   ENDM
00000FFC  8E02                    2317      OR.B D2,D7  
00000FFE  4EF8 01AE               2318      JMP GET_INPUT
00001002                          2319  
00001002  FFFF FFFF               2320      SIMHALT                         ; halt simulator
00001006                          2321  
00001006                          2322  ; strings
00001006= 4D 44 46 2D 6D 6F ...   2323  VERSION DC.B 'MDF-mon V1.10 (04/04/2021)',13,10,0
00001023= 3F 20 48 65 6C 70 ...   2324  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,'Z zap memory',10,13,0
0000109C= 48 75 68 3F 0D 0A 00    2325  HUH     DC.B 'Huh?',13,10,0
000010A3= 55 6E 69 6D 70 6C ...   2326  UNIMP   DC.B 'Unimplemented',13,10,0
000010B3= 20 53 20 72 65 63 ...   2327  READ    DC.B ' S records read, start address = ',0
000010D5= 57 41 52 4E 49 4E ...   2328  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
000010FB= 57 41 52 4E 49 4E ...   2329  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00001121= 57 41 52 4E 49 4E ...   2330  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
00001139= 30 31 32 33 34 35 ...   2331  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001149= 00 01 02 03 04 05 ...   2332  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001160                          2333      
00001160                          2334      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1139
CONTINUE_103        A6E
CONTINUE_106        ABA
CONTINUE_109        B08
CONTINUE_112        B54
CONTINUE_115        BA6
CONTINUE_118        BF2
CONTINUE_127        CBA
CONTINUE_130        D06
CONTINUE_44         4A0
CONTINUE_46         4DC
CONTINUE_48         514
CONTINUE_51         560
CONTINUE_54         5B6
CONTINUE_57         602
CONTINUE_60         650
CONTINUE_63         69C
CONTINUE_66         6FC
CONTINUE_69         748
CONTINUE_76         7E4
CONTINUE_80         842
CONTINUE_84         8A2
CONTINUE_88         900
CONTINUE_92         974
CONTINUE_96         9D2
CS_FAILURE          10FB
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       DDC
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_121            C56
EXIT_133            D5E
EXIT_148            E54
EXIT_158            F5C
EXIT_19             2DE
EXIT_21             306
EXIT_23             32E
EXIT_5              140
G                   ED6
GET_INPUT           1AE
H                   2E2
HELP                1023
HEX2BIN             12B
HEX2BIN_LUT         1149
HEX_DIGIT           FE6
HUH                 109C
LOOP_121            C38
LOOP_133            D40
LOOP_135            D88
LOOP_143            E06
LOOP_148            E36
LOOP_150            E80
LOOP_158            F3E
LOOP_160            F8A
LOOP_19             2C0
LOOP_21             2E8
LOOP_23             310
LOOP_25             360
LOOP_5              122
MAIN_LOOP           186
OK                  FDC
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   332
RAM                 200000
RAM_ERROR           1121
READ                10B3
READ_CHAR           79D
READ_DATA_TO_POKE   400
RRRR                0
S                   47E
START               8
UNIMP               10A3
UNREC               10D5
V                   30A
VERSION             1006
W                   3B8
WAIT_CHAR           615
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_101  A18
WAIT_FOR_READY_102  A2C
WAIT_FOR_READY_103  A52
WAIT_FOR_READY_106  A9E
WAIT_FOR_READY_109  AEC
WAIT_FOR_READY_11   186
WAIT_FOR_READY_112  B38
WAIT_FOR_READY_115  B8A
WAIT_FOR_READY_118  BD6
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_122  C40
WAIT_FOR_READY_123  C56
WAIT_FOR_READY_125  C68
WAIT_FOR_READY_126  C7C
WAIT_FOR_READY_127  C9E
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_130  CEA
WAIT_FOR_READY_134  D48
WAIT_FOR_READY_136  D5E
WAIT_FOR_READY_137  D72
WAIT_FOR_READY_139  D9C
WAIT_FOR_READY_141  DB2
WAIT_FOR_READY_142  DC6
WAIT_FOR_READY_144  DDC
WAIT_FOR_READY_145  DF0
WAIT_FOR_READY_147  E1A
WAIT_FOR_READY_149  E3E
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  E56
WAIT_FOR_READY_152  E6A
WAIT_FOR_READY_154  E94
WAIT_FOR_READY_156  EAA
WAIT_FOR_READY_157  EBE
WAIT_FOR_READY_159  F46
WAIT_FOR_READY_161  F60
WAIT_FOR_READY_162  F74
WAIT_FOR_READY_164  F9E
WAIT_FOR_READY_166  FB4
WAIT_FOR_READY_167  FC8
WAIT_FOR_READY_17   262
WAIT_FOR_READY_18   276
WAIT_FOR_READY_20   2C8
WAIT_FOR_READY_22   2F0
WAIT_FOR_READY_24   318
WAIT_FOR_READY_26   336
WAIT_FOR_READY_27   34A
WAIT_FOR_READY_29   374
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_32   39E
WAIT_FOR_READY_33   3BA
WAIT_FOR_READY_35   3D4
WAIT_FOR_READY_37   402
WAIT_FOR_READY_39   41C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   452
WAIT_FOR_READY_43   466
WAIT_FOR_READY_44   484
WAIT_FOR_READY_46   4C0
WAIT_FOR_READY_48   4F8
WAIT_FOR_READY_51   544
WAIT_FOR_READY_54   59A
WAIT_FOR_READY_57   5E6
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_60   634
WAIT_FOR_READY_63   680
WAIT_FOR_READY_66   6E0
WAIT_FOR_READY_69   72C
WAIT_FOR_READY_72   778
WAIT_FOR_READY_74   78E
WAIT_FOR_READY_75   7A2
WAIT_FOR_READY_76   7C8
WAIT_FOR_READY_78   7FC
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   826
WAIT_FOR_READY_82   85A
WAIT_FOR_READY_84   886
WAIT_FOR_READY_86   8BA
WAIT_FOR_READY_88   8E4
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   918
WAIT_FOR_READY_92   958
WAIT_FOR_READY_94   98C
WAIT_FOR_READY_96   9B6
WAIT_FOR_READY_98   9EA
WAIT_FOR_SRECORD    484
Z                   EDE
_00000000           7BE
_00000001           C94
_00000002           A48
_00000003           C94
_00000004           C32
_00000005           C94
_00000006           DDA
_00000007           F38
_10000000           6D2
_10000001           78E
_10000002           94A
_10000003           A18
_10000004           EE6
_10000005           F08
_10000006           F10
_10000007           FE2
