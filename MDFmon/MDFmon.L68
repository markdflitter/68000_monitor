00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 09/04/2021 19:30:39

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; implement DOWNLOAD_BYTE to remove repeated code and shorten the gap between S1 and S2
00000000                             9  ; give DOWNLOAD_BVYTE a loop
00000000                            10  ; stop using two registers in download
00000000                            11  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            12  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            13  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            14  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            15  
00000000                            16  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            17  ; keep track of highest address hit during srec download
00000000                            18  ; fix the reset vector so that it jumps to the start
00000000                            19  ; Replace JMP -> BRA
00000000                            20  ; implement backspace
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  ; fix being able to enter random chars when W'ing
00000000                            23  ; ram check at startup?  Not sure if this is a good idea!
00000000                            24  ; byte W?
00000000                            25  
00000000                            26      ORG  $0
00000000                            27      ;ORG  $200000
00000000                            28  
00000000  =00000000                 29  DEBUG               EQU 0
00000000                            30  
00000000                            31  ; constants
00000000  =00000000                 32  ROM                 EQU $0
00000000  =00200000                 33  RAM                 EQU $200000
00000000                            34     
00000000  =00C00000                 35  DUART_BASE          EQU $C00000
00000000  =00000000                 36  DUART_MRA_          EQU $0
00000000  =00000001                 37  DUART_CSRA_         EQU $1
00000000  =00000001                 38  DUART_SRA_          EQU $1
00000000  =00000002                 39  DUART_CRA_          EQU $2
00000000  =00000003                 40  DUART_TXA_          EQU $3
00000000  =00000003                 41  DUART_RXA_          EQU $3
00000000  =00000004                 42  DUART_ACR_          EQU $4
00000000  =00000005                 43  DUART_IMR_          EQU $5
00000000  =00000008                 44  DUART_MRB_          EQU $8
00000000  =00000009                 45  DUART_CSRB_         EQU $9
00000000  =00000009                 46  DUART_SRB_          EQU $9
00000000  =0000000A                 47  DUART_CRB_          EQU $A
00000000  =0000000B                 48  DUART_TXB_          EQU $B
00000000  =0000000B                 49  DUART_RXB_          EQU $B
00000000  =0000000C                 50  DUART_IVR_          EQU $C
00000000  =0000000D                 51  DUART_OPCR_         EQU $D
00000000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00000000                            54  
00000000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            61  
00000000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            68  
00000000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            75  
00000000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 77  DISPLAY_            EQU $0
00000000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            79  
00000000                            80  ; macros
00000000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            82  ; the input register is changed during the process
00000000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            84  BIN2HEX MACRO
00000000                            85      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            86      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            87      MOVE.B \1,\2
00000000                            88      ANDI.L #$F,\2
00000000                            89      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            90      ENDM
00000000                            91  
00000000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            93  ; the input register is changed during the process
00000000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            95  HEX2BIN MACRO
00000000                            96      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            97      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            98      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                            99      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                           100      ENDM
00000000                           101  
00000000                           102  ; send a single char to the serial port
00000000                           103  ; \1 = char to send, \2 = data register to use for status poll
00000000                           104  ; will stamp on D0 and D1 in debug mode
00000000                           105  PRINT_CHAR MACRO
00000000                           106  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           107      IFEQ DEBUG
00000000                           108          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           109          BTST #2,\2                              ; check for space to send
00000000                           110          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           111          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           112      ENDC
00000000                           113      
00000000                           114      IFNE DEBUG
00000000                           115          MOVE.B \1,D1
00000000                           116          MOVE.L #6,D0   
00000000                           117          TRAP #15                                ; write to terminal in simulator
00000000                           118      ENDC
00000000                           119  
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send CR,LF to the serial port
00000000                           123  ; \1 = data register to use for status poll
00000000                           124  PRINT_CRLF MACRO
00000000                           125      PRINT_CHAR #13,\1                           ; CR
00000000                           126      PRINT_CHAR #10,\1                           ; LF
00000000                           127      ENDM
00000000                           128  
00000000                           129  ; send C-style, zero terminated string to the serial port
00000000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           131  PRINT_STR MACRO
00000000                           132  LOOP\@
00000000                           133      CMP.B #0,(\1)                               ; 0 -> done
00000000                           134      BEQ EXIT\@
00000000                           135      PRINT_CHAR (\1)+,\2
00000000                           136      JMP LOOP\@
00000000                           137  EXIT\@
00000000                           138      ENDM
00000000                           139    
00000000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           142  PRINT_REG MACRO
00000000                           143      PRINT_CHAR #'0',\2                          ;0x header
00000000                           144      PRINT_CHAR #'x',\2
00000000                           145      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           146  LOOP\@
00000000                           147      BIN2HEX \1,\3,\5
00000000                           148      PRINT_CHAR \3,\2
00000000                           149      DBEQ \4,LOOP\@
00000000                           150      ENDM
00000000                           151    
00000000                           152  ; wait for a char from the serial port
00000000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           154  ; will stamp on D0 and D1 in debug mode
00000000                           155  WAIT_CHAR MACRO
00000000                           156  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           157  
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                        ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\2                         ; check for command
00000000                           195      BTST #0,\2                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\2                         ; read status register
00000000                           201      BTST #0,\2                                  ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; read two hex digits from the download serial port and convert to a byte
00000000                           210  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working address register
00000000                           211  DOWNLOAD_BYTE MACRO
00000000                           212      DOWNLOAD \1,\3                              ; read first (most significant) char, convert to 4 bits and shift to top
00000000                           213      PRINT_CHAR \1,\3
00000000                           214      HEX2BIN \1,\1,\4
00000000                           215      OR.B \1,\2
00000000                           216      LSL.L #4,\2
00000000                           217          
00000000                           218      DOWNLOAD \1,\3                              ; now the second (least significant) char, convert to binary
00000000                           219      PRINT_CHAR \1,\3
00000000                           220      HEX2BIN \1,\1,\4
00000000                           221      OR.B \1,\2    
00000000                           222      ENDM
00000000                           223      
00000000                           224  
00000000                           225  ; register catalogue
00000000                           226  ; D0 - used for simulator I/O
00000000                           227  ; D1 - used for simulator I/O
00000000                           228  ; D2 - read character
00000000                           229  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           230  ; D4 - count of S records read
00000000                           231  ; D5 - data to write / data read / byte count for S record load
00000000                           232  ; D6 - working register used in R/W and download
00000000                           233  ; D7 - address accumulator / reset by download
00000000                           234  ; A0 - address of string to print 
00000000                           235  
00000000                           236  ; start vector
00000000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 238  RESET    DC.L START                             ; RESET
00000008                           239      
00000008                           240  ; start of program  
00000008                           241  START
00000008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00000010                           243  
00000010                           244  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     247      NOP
00000022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     249      NOP
0000002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00000034  4E71                     251      NOP
00000036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0000003E  4E71                     253      NOP
00000040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00000048                           255  
00000048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     258      NOP
0000005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00000062  4E71                     260      NOP
00000064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0000006C  4E71                     262      NOP
0000006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00000076  4E71                     264      NOP
00000078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00000080                           266  
00000080                           267  ;initialise UART
00000080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           271  
00000098                           272  ; channel A
00000098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           277  
000000B8                           278  ; channel B
000000B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           283  
000000D8                           284m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      286m     IFEQ DEBUG
000000D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           291m     ENDC
000000EC                           292m     
000000EC                 FALSE     293m     IFNE DEBUG
000000EC                           294m     ENDC
000000EC                           295m 
000000EC                           296m     ENDM
000000EC                           297  
000000EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
000000F4                           299         
000000F4                           300m     PRINT_CRLF D3
000000F4                           301mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           302mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      303mm     IFEQ DEBUG
000000F4  1639 00C00003            304mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                305mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     306mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       307mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           308mm     ENDC
00000108                           309mm     
00000108                 FALSE     310mm     IFNE DEBUG
00000108                           311mm     ENDC
00000108                           312mm 
00000108                           313mm     ENDM
00000108                           314mm     PRINT_CHAR #10,D3                           ; LF
00000108                           315mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      316mm     IFEQ DEBUG
00000108  1639 00C00003            317mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                318mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     319mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       320mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           321mm     ENDC
0000011C                           322mm     
0000011C                 FALSE     323mm     IFNE DEBUG
0000011C                           324mm     ENDC
0000011C                           325mm 
0000011C                           326mm     ENDM
0000011C                           327m     ENDM
0000011C                           328  
0000011C  41F9 0000134A            329      LEA VERSION,A0
00000122                           330m     PRINT_STR A0,D3
00000122                           331m LOOP_5
00000122  0C10 0000                332m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0018                333m     BEQ EXIT_5
0000012A                           334mm     PRINT_CHAR (A0)+,D3
0000012A                           335mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      336mm     IFEQ DEBUG
0000012A  1639 00C00003            337mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                338mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     339mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            340mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           341mm     ENDC
0000013C                           342mm     
0000013C                 FALSE     343mm     IFNE DEBUG
0000013C                           344mm     ENDC
0000013C                           345mm 
0000013C                           346mm     ENDM
0000013C  4EF8 0122                347m     JMP LOOP_5
00000140                           348m EXIT_5
00000140                           349m     ENDM
00000140                           350m     PRINT_CRLF D3
00000140                           351mm     PRINT_CHAR #13,D3                           ; CR
00000140                           352mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      353mm     IFEQ DEBUG
00000140  1639 00C00003            354mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000146  0803 0002                355mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000014A  67F4                     356mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00C00007       357mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000154                           358mm     ENDC
00000154                           359mm     
00000154                 FALSE     360mm     IFNE DEBUG
00000154                           361mm     ENDC
00000154                           362mm 
00000154                           363mm     ENDM
00000154                           364mm     PRINT_CHAR #10,D3                           ; LF
00000154                           365mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      366mm     IFEQ DEBUG
00000154  1639 00C00003            367mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000015A  0803 0002                368mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015E  67F4                     369mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00C00007       370mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000168                           371mm     ENDC
00000168                           372mm     
00000168                 FALSE     373mm     IFNE DEBUG
00000168                           374mm     ENDC
00000168                           375mm 
00000168                           376mm     ENDM
00000168                           377m     ENDM
00000168                           378m     PRINT_CHAR #7,D3
00000168                           379m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      380m     IFEQ DEBUG
00000168  1639 00C00003            381m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016E  0803 0002                382m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000172  67F4                     383m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00C00007       384m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017C                           385m     ENDC
0000017C                           386m     
0000017C                 FALSE     387m     IFNE DEBUG
0000017C                           388m     ENDC
0000017C                           389m 
0000017C                           390m     ENDM
0000017C                           391  
0000017C  7E00                     392      MOVE.L #0,D7                                ; address accumulator
0000017E                           393  
0000017E  13FC 0002 00E00001       394      MOVE.B #2,DISPLAY
00000186                           395  MAIN_LOOP
00000186                           396m     PRINT_CHAR #'>',D3                          ; prompt
00000186                           397m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      398m     IFEQ DEBUG
00000186  1639 00C00003            399m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018C  0803 0002                400m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000190  67F4                     401m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00C00007       402m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000019A                           403m     ENDC
0000019A                           404m     
0000019A                 FALSE     405m     IFNE DEBUG
0000019A                           406m     ENDC
0000019A                           407m 
0000019A                           408m     ENDM
0000019A                           409m     PRINT_CHAR #32,D3                           ; space
0000019A                           410m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      411m     IFEQ DEBUG
0000019A  1639 00C00003            412m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001A0  0803 0002                413m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A4  67F4                     414m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00C00007       415m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AE                           416m     ENDC
000001AE                           417m     
000001AE                 FALSE     418m     IFNE DEBUG
000001AE                           419m     ENDC
000001AE                           420m 
000001AE                           421m     ENDM
000001AE                           422      
000001AE                           423  GET_INPUT
000001AE                           424m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AE                           425m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           426m 
000001AE                 TRUE      427m     IFEQ DEBUG
000001AE  1639 00C00003            428m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B4  0803 0000                429m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B8  67F4                     430m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001BA                           431m     ENDC
000001BA                           432m     
000001BA                           433mm     READ_CHAR D2
000001BA                 TRUE      434mm     IFEQ DEBUG
000001BA  1439 00C00007            435mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001C0                           436mm     ENDC
000001C0                 FALSE     437mm     IFNE DEBUG
000001C0                           438mm     ENDC
000001C0                           439mm      
000001C0  B43C 001B                440mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                441mm     BEQ START
000001C8                           442mm     ENDM
000001C8                           443m 
000001C8                 TRUE      444m     IFEQ DEBUG
000001C8                           445mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C8                           446mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      447mm     IFEQ DEBUG
000001C8  1639 00C00003            448mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CE  0803 0002                449mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D2  67F4                     450mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D4  13C2 00C00007            451mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001DA                           452mm     ENDC
000001DA                           453mm     
000001DA                 FALSE     454mm     IFNE DEBUG
000001DA                           455mm     ENDC
000001DA                           456mm 
000001DA                           457mm     ENDM
000001DA                           458m     ENDC
000001DA                           459m     ENDM
000001DA                           460      
000001DA  B43C 0030                461      CMP.B #'0',D2
000001DE  6700 114A                462      BEQ HEX_DIGIT
000001E2  B43C 0031                463      CMP.B #'1',D2
000001E6  6700 1142                464      BEQ HEX_DIGIT
000001EA  B43C 0032                465      CMP.B #'2',D2
000001EE  6700 113A                466      BEQ HEX_DIGIT
000001F2  B43C 0033                467      CMP.B #'3',D2
000001F6  6700 1132                468      BEQ HEX_DIGIT
000001FA  B43C 0034                469      CMP.B #'4',D2
000001FE  6700 112A                470      BEQ HEX_DIGIT
00000202  B43C 0035                471      CMP.B #'5',D2
00000206  6700 1122                472      BEQ HEX_DIGIT
0000020A  B43C 0036                473      CMP.B #'6',D2
0000020E  6700 111A                474      BEQ HEX_DIGIT
00000212  B43C 0037                475      CMP.B #'7',D2
00000216  6700 1112                476      BEQ HEX_DIGIT
0000021A  B43C 0038                477      CMP.B #'8',D2
0000021E  6700 110A                478      BEQ HEX_DIGIT
00000222  B43C 0039                479      CMP.B #'9',D2
00000226  6700 1102                480      BEQ HEX_DIGIT
0000022A  B43C 0041                481      CMP.B #'A',D2
0000022E  6700 10FA                482      BEQ HEX_DIGIT
00000232  B43C 0042                483      CMP.B #'B',D2
00000236  6700 10F2                484      BEQ HEX_DIGIT
0000023A  B43C 0043                485      CMP.B #'C',D2
0000023E  6700 10EA                486      BEQ HEX_DIGIT
00000242  B43C 0044                487      CMP.B #'D',D2
00000246  6700 10E2                488      BEQ HEX_DIGIT
0000024A  B43C 0045                489      CMP.B #'E',D2
0000024E  6700 10DA                490      BEQ HEX_DIGIT
00000252  B43C 0046                491      CMP.B #'F',D2
00000256  6700 10D2                492      BEQ HEX_DIGIT
0000025A                           493      
0000025A  B43C 0057                494      CMP.B #'W',D2
0000025E  6700 0160                495      BEQ W
00000262                           496      
00000262  B43C 004C                497      CMP.B #'L',D2
00000266  6700 0F52                498      BEQ L 
0000026A                           499  
0000026A                           500m     PRINT_CRLF D3
0000026A                           501mm     PRINT_CHAR #13,D3                           ; CR
0000026A                           502mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      503mm     IFEQ DEBUG
0000026A  1639 00C00003            504mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000270  0803 0002                505mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000274  67F4                     506mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000276  13FC 000D 00C00007       507mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000027E                           508mm     ENDC
0000027E                           509mm     
0000027E                 FALSE     510mm     IFNE DEBUG
0000027E                           511mm     ENDC
0000027E                           512mm 
0000027E                           513mm     ENDM
0000027E                           514mm     PRINT_CHAR #10,D3                           ; LF
0000027E                           515mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027E                 TRUE      516mm     IFEQ DEBUG
0000027E  1639 00C00003            517mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000284  0803 0002                518mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000288  67F4                     519mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0000028A  13FC 000A 00C00007       520mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000292                           521mm     ENDC
00000292                           522mm     
00000292                 FALSE     523mm     IFNE DEBUG
00000292                           524mm     ENDC
00000292                           525mm 
00000292                           526mm     ENDM
00000292                           527m     ENDM
00000292                           528   
00000292  B43C 003F                529      CMP.B #'?',D2
00000296  6700 0052                530      BEQ H
0000029A                           531  
0000029A  B43C 0056                532      CMP.B #'V',D2
0000029E  6700 0072                533      BEQ V
000002A2                           534      
000002A2  B43C 0052                535      CMP.B #'R',D2
000002A6  6700 0092                536      BEQ R
000002AA                           537  
000002AA  B43C 0053                538      CMP.B #'S',D2
000002AE  6700 01D6                539      BEQ S
000002B2                           540  
000002B2  B43C 0047                541      CMP.B #'G',D2
000002B6  6700 0DF2                542      BEQ G   
000002BA                           543  
000002BA  B43C 005A                544      CMP.B #'Z',D2
000002BE  6700 0DF2                545      BEQ Z   
000002C2                           546  
000002C2  41F9 000013FE            547      LEA HUH,A0
000002C8                           548m     PRINT_STR A0,D3
000002C8                           549m LOOP_19
000002C8  0C10 0000                550m     CMP.B #0,(A0)                               ; 0 -> DONE
000002CC  6700 0018                551m     BEQ EXIT_19
000002D0                           552mm     PRINT_CHAR (A0)+,D3
000002D0                           553mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D0                 TRUE      554mm     IFEQ DEBUG
000002D0  1639 00C00003            555mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D6  0803 0002                556mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002DA  67F4                     557mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
000002DC  13D8 00C00007            558mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E2                           559mm     ENDC
000002E2                           560mm     
000002E2                 FALSE     561mm     IFNE DEBUG
000002E2                           562mm     ENDC
000002E2                           563mm 
000002E2                           564mm     ENDM
000002E2  4EF8 02C8                565m     JMP LOOP_19
000002E6                           566m EXIT_19
000002E6                           567m     ENDM
000002E6                           568                         
000002E6  4EF8 0186                569      JMP MAIN_LOOP
000002EA                           570      
000002EA                           571  ; commands
000002EA                           572  H   
000002EA  41F9 00001367            573      LEA HELP,A0
000002F0                           574m     PRINT_STR A0,D3
000002F0                           575m LOOP_21
000002F0  0C10 0000                576m     CMP.B #0,(A0)                               ; 0 -> DONE
000002F4  6700 0018                577m     BEQ EXIT_21
000002F8                           578mm     PRINT_CHAR (A0)+,D3
000002F8                           579mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F8                 TRUE      580mm     IFEQ DEBUG
000002F8  1639 00C00003            581mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FE  0803 0002                582mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000302  67F4                     583mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000304  13D8 00C00007            584mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000030A                           585mm     ENDC
0000030A                           586mm     
0000030A                 FALSE     587mm     IFNE DEBUG
0000030A                           588mm     ENDC
0000030A                           589mm 
0000030A                           590mm     ENDM
0000030A  4EF8 02F0                591m     JMP LOOP_21
0000030E                           592m EXIT_21
0000030E                           593m     ENDM
0000030E  4EF8 0186                594      JMP MAIN_LOOP
00000312                           595  
00000312                           596  V   
00000312  41F9 0000134A            597      LEA VERSION,A0
00000318                           598m     PRINT_STR A0,D3       
00000318                           599m LOOP_23
00000318  0C10 0000                600m     CMP.B #0,(A0)                               ; 0 -> DONE
0000031C  6700 0018                601m     BEQ EXIT_23
00000320                           602mm     PRINT_CHAR (A0)+,D3
00000320                           603mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000320                 TRUE      604mm     IFEQ DEBUG
00000320  1639 00C00003            605mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000326  0803 0002                606mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000032A  67F4                     607mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
0000032C  13D8 00C00007            608mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000332                           609mm     ENDC
00000332                           610mm     
00000332                 FALSE     611mm     IFNE DEBUG
00000332                           612mm     ENDC
00000332                           613mm 
00000332                           614mm     ENDM
00000332  4EF8 0318                615m     JMP LOOP_23
00000336                           616m EXIT_23
00000336                           617m     ENDM
00000336  4EF8 0186                618      JMP MAIN_LOOP
0000033A                           619      
0000033A                           620  R   
0000033A  2047                     621      MOVE.L D7,A0                                ; address accumulator -> address register
0000033C  2A10                     622      MOVE.L (A0),D5                              ; read the memory and print it
0000033E                           623m     PRINT_REG D5,D3,D7,D6,A0
0000033E                           624mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0000033E                           625mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033E                 TRUE      626mm     IFEQ DEBUG
0000033E  1639 00C00003            627mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000344  0803 0002                628mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000348  67F4                     629mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
0000034A  13FC 0030 00C00007       630mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000352                           631mm     ENDC
00000352                           632mm     
00000352                 FALSE     633mm     IFNE DEBUG
00000352                           634mm     ENDC
00000352                           635mm 
00000352                           636mm     ENDM
00000352                           637mm     PRINT_CHAR #'x',D3
00000352                           638mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000352                 TRUE      639mm     IFEQ DEBUG
00000352  1639 00C00003            640mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000358  0803 0002                641mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000035C  67F4                     642mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0000035E  13FC 0078 00C00007       643mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000366                           644mm     ENDC
00000366                           645mm     
00000366                 FALSE     646mm     IFNE DEBUG
00000366                           647mm     ENDC
00000366                           648mm 
00000366                           649mm     ENDM
00000366  7C07                     650m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000368                           651m LOOP_25
00000368                           652mm     BIN2HEX D5,D7,A0
00000368  41F9 00001462            653mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000036E  E99D                     654mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000370  1E05                     655mm     MOVE.B D5,D7
00000372  0287 0000000F            656mm     ANDI.L #$F,D7
00000378  1E30 7000                657mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0000037C                           658mm     ENDM
0000037C                           659mm     PRINT_CHAR D7,D3
0000037C                           660mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037C                 TRUE      661mm     IFEQ DEBUG
0000037C  1639 00C00003            662mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000382  0803 0002                663mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000386  67F4                     664mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000388  13C7 00C00007            665mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000038E                           666mm     ENDC
0000038E                           667mm     
0000038E                 FALSE     668mm     IFNE DEBUG
0000038E                           669mm     ENDC
0000038E                           670mm 
0000038E                           671mm     ENDM
0000038E  57CE FFD8                672m     DBEQ D6,LOOP_25
00000392                           673m     ENDM
00000392                           674m     PRINT_CRLF D3
00000392                           675mm     PRINT_CHAR #13,D3                           ; CR
00000392                           676mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000392                 TRUE      677mm     IFEQ DEBUG
00000392  1639 00C00003            678mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000398  0803 0002                679mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000039C  67F4                     680mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
0000039E  13FC 000D 00C00007       681mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003A6                           682mm     ENDC
000003A6                           683mm     
000003A6                 FALSE     684mm     IFNE DEBUG
000003A6                           685mm     ENDC
000003A6                           686mm 
000003A6                           687mm     ENDM
000003A6                           688mm     PRINT_CHAR #10,D3                           ; LF
000003A6                           689mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A6                 TRUE      690mm     IFEQ DEBUG
000003A6  1639 00C00003            691mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003AC  0803 0002                692mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003B0  67F4                     693mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000003B2  13FC 000A 00C00007       694mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003BA                           695mm     ENDC
000003BA                           696mm     
000003BA                 FALSE     697mm     IFNE DEBUG
000003BA                           698mm     ENDC
000003BA                           699mm 
000003BA                           700mm     ENDM
000003BA                           701m     ENDM
000003BA  7E00                     702      MOVE.L #0,D7                                ; clear the now used address accumulator
000003BC  4EF8 0186                703      JMP MAIN_LOOP
000003C0                           704  
000003C0                           705  W
000003C0  7A00                     706      MOVE.L #0,D5                                ; D5 will be the value to write            
000003C2                           707  
000003C2                           708m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000003C2                           709m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C2                           710m 
000003C2                 TRUE      711m     IFEQ DEBUG
000003C2  1639 00C00003            712m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003C8  0803 0000                713m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003CC  67F4                     714m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
000003CE                           715m     ENDC
000003CE                           716m     
000003CE                           717mm     READ_CHAR D2
000003CE                 TRUE      718mm     IFEQ DEBUG
000003CE  1439 00C00007            719mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003D4                           720mm     ENDC
000003D4                 FALSE     721mm     IFNE DEBUG
000003D4                           722mm     ENDC
000003D4                           723mm      
000003D4  B43C 001B                724mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003D8  6700 FC2E                725mm     BEQ START
000003DC                           726mm     ENDM
000003DC                           727m 
000003DC                 TRUE      728m     IFEQ DEBUG
000003DC                           729mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003DC                           730mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      731mm     IFEQ DEBUG
000003DC  1639 00C00003            732mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003E2  0803 0002                733mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003E6  67F4                     734mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
000003E8  13C2 00C00007            735mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003EE                           736mm     ENDC
000003EE                           737mm     
000003EE                 FALSE     738mm     IFNE DEBUG
000003EE                           739mm     ENDC
000003EE                           740mm 
000003EE                           741mm     ENDM
000003EE                           742m     ENDC
000003EE                           743m     ENDM
000003EE                           744m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003EE  41F9 00001472            745m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003F4  0402 0030                746m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F8  C4BC 000000FF            747m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003FE  1430 2000                748m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000402                           749m     ENDM
00000402  1A02                     750      MOVE.B D2,D5                                ; put at bottom of D5
00000404                           751  
00000404  3C3C 0006                752      MOVE #6,D6                                  ; 7 bytes left to read
00000408                           753      
00000408                           754  READ_DATA_TO_POKE
00000408  E98D                     755      LSL.L #4,D5                                 ; make what we have so far more significant
0000040A                           756m     WAIT_CHAR D2,D3                             ; next character -> D2
0000040A                           757m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040A                           758m 
0000040A                 TRUE      759m     IFEQ DEBUG
0000040A  1639 00C00003            760m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000410  0803 0000                761m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000414  67F4                     762m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00000416                           763m     ENDC
00000416                           764m     
00000416                           765mm     READ_CHAR D2
00000416                 TRUE      766mm     IFEQ DEBUG
00000416  1439 00C00007            767mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000041C                           768mm     ENDC
0000041C                 FALSE     769mm     IFNE DEBUG
0000041C                           770mm     ENDC
0000041C                           771mm      
0000041C  B43C 001B                772mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000420  6700 FBE6                773mm     BEQ START
00000424                           774mm     ENDM
00000424                           775m 
00000424                 TRUE      776m     IFEQ DEBUG
00000424                           777mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000424                           778mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000424                 TRUE      779mm     IFEQ DEBUG
00000424  1639 00C00003            780mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000042A  0803 0002                781mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000042E  67F4                     782mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00000430  13C2 00C00007            783mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000436                           784mm     ENDC
00000436                           785mm     
00000436                 FALSE     786mm     IFNE DEBUG
00000436                           787mm     ENDC
00000436                           788mm 
00000436                           789mm     ENDM
00000436                           790m     ENDC
00000436                           791m     ENDM
00000436                           792m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000436  41F9 00001472            793m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000043C  0402 0030                794m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000440  C4BC 000000FF            795m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000446  1430 2000                796m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000044A                           797m     ENDM
0000044A  8A02                     798      OR.B D2,D5
0000044C  023C 00FB                799      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000450  57CE FFB6                800      DBEQ D6,READ_DATA_TO_POKE
00000454                           801      
00000454  2047                     802      MOVE.L D7,A0                                ; address accumulator -> address register
00000456  7E00                     803      MOVE.L #0,D7                                ; clear the now used address accumulator
00000458                           804      
00000458  2085                     805      MOVE.L D5,(A0)                              ; write the data
0000045A                           806  
0000045A                           807m     PRINT_CRLF D3
0000045A                           808mm     PRINT_CHAR #13,D3                           ; CR
0000045A                           809mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000045A                 TRUE      810mm     IFEQ DEBUG
0000045A  1639 00C00003            811mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000460  0803 0002                812mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000464  67F4                     813mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000466  13FC 000D 00C00007       814mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000046E                           815mm     ENDC
0000046E                           816mm     
0000046E                 FALSE     817mm     IFNE DEBUG
0000046E                           818mm     ENDC
0000046E                           819mm 
0000046E                           820mm     ENDM
0000046E                           821mm     PRINT_CHAR #10,D3                           ; LF
0000046E                           822mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046E                 TRUE      823mm     IFEQ DEBUG
0000046E  1639 00C00003            824mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000474  0803 0002                825mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000478  67F4                     826mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0000047A  13FC 000A 00C00007       827mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000482                           828mm     ENDC
00000482                           829mm     
00000482                 FALSE     830mm     IFNE DEBUG
00000482                           831mm     ENDC
00000482                           832mm 
00000482                           833mm     ENDM
00000482                           834m     ENDM
00000482  4EF8 0186                835      JMP MAIN_LOOP
00000486                           836  
00000486                           837          
00000486                           838  S
00000486  2647                     839      MOVE.L D7,A3                                ; grab the address accumulator
00000488  7800                     840      MOVE.L #0,D4                                ; count of records read -> D4
0000048A  2478 0000                841      MOVE.L 0,A2                                 ; start address -> A2
0000048E                           842      
0000048E                           843  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
0000048E                           844m     DOWNLOAD D2,D3                  
0000048E                           845m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048E                           846m 
0000048E  1639 00C00003            847m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000494  0803 0000                848m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000498  6700 0010                849m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0000049C                           850m  
0000049C                           851mm     READ_CHAR D2
0000049C                 TRUE      852mm     IFEQ DEBUG
0000049C  1439 00C00007            853mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000004A2                           854mm     ENDC
000004A2                 FALSE     855mm     IFNE DEBUG
000004A2                           856mm     ENDC
000004A2                           857mm      
000004A2  B43C 001B                858mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000004A6  6700 FB60                859mm     BEQ START
000004AA                           860mm     ENDM
000004AA                           861m CONTINUE_44
000004AA  1639 00C00013            862m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000004B0  0803 0000                863m     BTST #0,D3                                  ; CHECK FOR CHARACTER
000004B4  67D8                     864m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
000004B6                           865m     
000004B6  1439 00C00017            866m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000004BC  13C2 00E00001            867m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000004C2                           868m     
000004C2                           869m     ENDM
000004C2  B43C 0053                870      CMP.B #'S',D2                               ; found S?    
000004C6  66C6                     871      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
000004C8                           872      
000004C8  5284                     873      ADD.L #1,D4                                 ; read another S record, increment count
000004CA                           874      
000004CA                           875m     DOWNLOAD D7,D3                              ; read the record identifier
000004CA                           876m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CA                           877m 
000004CA  1639 00C00003            878m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000004D0  0803 0000                879m     BTST #0,D3                                  ; CHECK FOR CHARACTER
000004D4  6700 0010                880m     BEQ CONTINUE_46                             ; NOTHING, CONTINUE
000004D8                           881m  
000004D8                           882mm     READ_CHAR D7
000004D8                 TRUE      883mm     IFEQ DEBUG
000004D8  1E39 00C00007            884mm         MOVE.B DUART_RXA,D7                     ; GOT A CHARACTER, READ IT
000004DE                           885mm     ENDC
000004DE                 FALSE     886mm     IFNE DEBUG
000004DE                           887mm     ENDC
000004DE                           888mm      
000004DE  BE3C 001B                889mm     CMP.B #$1B,D7                               ; CHECK FOR ESCAPE AND GO TO START
000004E2  6700 FB24                890mm     BEQ START
000004E6                           891mm     ENDM
000004E6                           892m CONTINUE_46
000004E6  1639 00C00013            893m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000004EC  0803 0000                894m     BTST #0,D3                                  ; CHECK FOR CHARACTER
000004F0  67D8                     895m     BEQ WAIT_FOR_READY_46                       ; NOTHING, CHECK AGAIN
000004F2                           896m     
000004F2  1E39 00C00017            897m     MOVE.B DUART_RXB,D7                         ; GOT A CHARACTER, READ IT
000004F8  13C7 00E00001            898m     MOVE.B D7,DISPLAY                           ; ECHO TO THE DISPLAY
000004FE                           899m     
000004FE                           900m     ENDM
000004FE                           901  
000004FE  7C00                     902      MOVE.L #0,D6                                ; clear the checksum
00000500                           903  
00000500  7A00                     904      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00000502                           905m     DOWNLOAD_BYTE D2,D5,D3,A0                               
00000502                           906mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000502                           907mm WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000502                           908mm 
00000502  1639 00C00003            909mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000508  0803 0000                910mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000050C  6700 0010                911mm     BEQ CONTINUE_49                             ; NOTHING, CONTINUE
00000510                           912mm  
00000510                           913mmm     READ_CHAR D2
00000510                 TRUE      914mmm     IFEQ DEBUG
00000510  1439 00C00007            915mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000516                           916mmm     ENDC
00000516                 FALSE     917mmm     IFNE DEBUG
00000516                           918mmm     ENDC
00000516                           919mmm      
00000516  B43C 001B                920mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000051A  6700 FAEC                921mmm     BEQ START
0000051E                           922mmm     ENDM
0000051E                           923mm CONTINUE_49
0000051E  1639 00C00013            924mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000524  0803 0000                925mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000528  67D8                     926mm     BEQ WAIT_FOR_READY_49                       ; NOTHING, CHECK AGAIN
0000052A                           927mm     
0000052A  1439 00C00017            928mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000530  13C2 00E00001            929mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000536                           930mm     
00000536                           931mm     ENDM
00000536                           932mm     PRINT_CHAR D2,D3
00000536                           933mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000536                 TRUE      934mm     IFEQ DEBUG
00000536  1639 00C00003            935mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000053C  0803 0002                936mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000540  67F4                     937mm         BEQ WAIT_FOR_READY_51                   ; NO SPACE, CHECK AGAIN
00000542  13C2 00C00007            938mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000548                           939mm     ENDC
00000548                           940mm     
00000548                 FALSE     941mm     IFNE DEBUG
00000548                           942mm     ENDC
00000548                           943mm 
00000548                           944mm     ENDM
00000548                           945mm     HEX2BIN D2,D2,A0
00000548  41F9 00001472            946mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000054E  0402 0030                947mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000552  C4BC 000000FF            948mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000558  1430 2000                949mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000055C                           950mm     ENDM
0000055C  8A02                     951m     OR.B D2,D5
0000055E  E98D                     952m     LSL.L #4,D5
00000560                           953m         
00000560                           954mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000560                           955mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000560                           956mm 
00000560  1639 00C00003            957mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000566  0803 0000                958mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000056A  6700 0010                959mm     BEQ CONTINUE_53                             ; NOTHING, CONTINUE
0000056E                           960mm  
0000056E                           961mmm     READ_CHAR D2
0000056E                 TRUE      962mmm     IFEQ DEBUG
0000056E  1439 00C00007            963mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000574                           964mmm     ENDC
00000574                 FALSE     965mmm     IFNE DEBUG
00000574                           966mmm     ENDC
00000574                           967mmm      
00000574  B43C 001B                968mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000578  6700 FA8E                969mmm     BEQ START
0000057C                           970mmm     ENDM
0000057C                           971mm CONTINUE_53
0000057C  1639 00C00013            972mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000582  0803 0000                973mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000586  67D8                     974mm     BEQ WAIT_FOR_READY_53                       ; NOTHING, CHECK AGAIN
00000588                           975mm     
00000588  1439 00C00017            976mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000058E  13C2 00E00001            977mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000594                           978mm     
00000594                           979mm     ENDM
00000594                           980mm     PRINT_CHAR D2,D3
00000594                           981mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                 TRUE      982mm     IFEQ DEBUG
00000594  1639 00C00003            983mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000059A  0803 0002                984mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000059E  67F4                     985mm         BEQ WAIT_FOR_READY_55                   ; NO SPACE, CHECK AGAIN
000005A0  13C2 00C00007            986mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005A6                           987mm     ENDC
000005A6                           988mm     
000005A6                 FALSE     989mm     IFNE DEBUG
000005A6                           990mm     ENDC
000005A6                           991mm 
000005A6                           992mm     ENDM
000005A6                           993mm     HEX2BIN D2,D2,A0
000005A6  41F9 00001472            994mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000005AC  0402 0030                995mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B0  C4BC 000000FF            996mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000005B6  1430 2000                997mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000005BA                           998mm     ENDM
000005BA  8A02                     999m     OR.B D2,D5    
000005BC                          1000m     ENDM
000005BC  DC85                    1001      ADD.L D5,D6                                 ; add to checksum
000005BE                          1002  
000005BE                          1003      IF.B D7 <EQ> #'0' THEN.L                    ; header, just ignore it
000005BE  BE3C 0030               1004s     CMP.B   #'0',D7
000005C2  6600 000A               1005s     BNE.L   _00000000
000005C6  6000 FEC6               1006          BRA WAIT_FOR_SRECORD
000005CA                          1007      ELSE
000005CA  6000 0898               1008s     BRA _00000001
000005CE                          1009s _00000000
000005CE                          1010          IF.B D7 <EQ> #'1' THEN.L                ; 16 bit address data record
000005CE  BE3C 0031               1011s     CMP.B   #'1',D7
000005D2  6600 0288               1012s     BNE.L   _00000002
000005D6  7E00                    1013              MOVE.L #0,D7                        ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000005D8                          1014m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte                           
000005D8                          1015mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
000005D8                          1016mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D8                          1017mm 
000005D8  1639 00C00003           1018mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000005DE  0803 0000               1019mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000005E2  6700 0010               1020mm     BEQ CONTINUE_58                             ; NOTHING, CONTINUE
000005E6                          1021mm  
000005E6                          1022mmm     READ_CHAR D2
000005E6                 TRUE     1023mmm     IFEQ DEBUG
000005E6  1439 00C00007           1024mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000005EC                          1025mmm     ENDC
000005EC                 FALSE    1026mmm     IFNE DEBUG
000005EC                          1027mmm     ENDC
000005EC                          1028mmm      
000005EC  B43C 001B               1029mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000005F0  6700 FA16               1030mmm     BEQ START
000005F4                          1031mmm     ENDM
000005F4                          1032mm CONTINUE_58
000005F4  1639 00C00013           1033mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000005FA  0803 0000               1034mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000005FE  67D8                    1035mm     BEQ WAIT_FOR_READY_58                       ; NOTHING, CHECK AGAIN
00000600                          1036mm     
00000600  1439 00C00017           1037mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000606  13C2 00E00001           1038mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000060C                          1039mm     
0000060C                          1040mm     ENDM
0000060C                          1041mm     PRINT_CHAR D2,D3
0000060C                          1042mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060C                 TRUE     1043mm     IFEQ DEBUG
0000060C  1639 00C00003           1044mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000612  0803 0002               1045mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000616  67F4                    1046mm         BEQ WAIT_FOR_READY_60                   ; NO SPACE, CHECK AGAIN
00000618  13C2 00C00007           1047mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000061E                          1048mm     ENDC
0000061E                          1049mm     
0000061E                 FALSE    1050mm     IFNE DEBUG
0000061E                          1051mm     ENDC
0000061E                          1052mm 
0000061E                          1053mm     ENDM
0000061E                          1054mm     HEX2BIN D2,D2,A0
0000061E  41F9 00001472           1055mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000624  0402 0030               1056mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000628  C4BC 000000FF           1057mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000062E  1430 2000               1058mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000632                          1059mm     ENDM
00000632  8E02                    1060m     OR.B D2,D7
00000634  E98F                    1061m     LSL.L #4,D7
00000636                          1062m         
00000636                          1063mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000636                          1064mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000636                          1065mm 
00000636  1639 00C00003           1066mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0000063C  0803 0000               1067mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000640  6700 0010               1068mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
00000644                          1069mm  
00000644                          1070mmm     READ_CHAR D2
00000644                 TRUE     1071mmm     IFEQ DEBUG
00000644  1439 00C00007           1072mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000064A                          1073mmm     ENDC
0000064A                 FALSE    1074mmm     IFNE DEBUG
0000064A                          1075mmm     ENDC
0000064A                          1076mmm      
0000064A  B43C 001B               1077mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000064E  6700 F9B8               1078mmm     BEQ START
00000652                          1079mmm     ENDM
00000652                          1080mm CONTINUE_62
00000652  1639 00C00013           1081mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000658  0803 0000               1082mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000065C  67D8                    1083mm     BEQ WAIT_FOR_READY_62                       ; NOTHING, CHECK AGAIN
0000065E                          1084mm     
0000065E  1439 00C00017           1085mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000664  13C2 00E00001           1086mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000066A                          1087mm     
0000066A                          1088mm     ENDM
0000066A                          1089mm     PRINT_CHAR D2,D3
0000066A                          1090mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000066A                 TRUE     1091mm     IFEQ DEBUG
0000066A  1639 00C00003           1092mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000670  0803 0002               1093mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000674  67F4                    1094mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
00000676  13C2 00C00007           1095mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000067C                          1096mm     ENDC
0000067C                          1097mm     
0000067C                 FALSE    1098mm     IFNE DEBUG
0000067C                          1099mm     ENDC
0000067C                          1100mm 
0000067C                          1101mm     ENDM
0000067C                          1102mm     HEX2BIN D2,D2,A0
0000067C  41F9 00001472           1103mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000682  0402 0030               1104mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000686  C4BC 000000FF           1105mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000068C  1430 2000               1106mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000690                          1107mm     ENDM
00000690  8E02                    1108m     OR.B D2,D7    
00000692                          1109m     ENDM
00000692  DC87                    1110              ADD.L D7,D6                         ; add into checksum
00000694                          1111  
00000694  E98F                    1112              LSL.L #4,D7                         ; bottom byte
00000696                          1113m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte       
00000696                          1114mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000696                          1115mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000696                          1116mm 
00000696  1639 00C00003           1117mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0000069C  0803 0000               1118mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000006A0  6700 0010               1119mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
000006A4                          1120mm  
000006A4                          1121mmm     READ_CHAR D2
000006A4                 TRUE     1122mmm     IFEQ DEBUG
000006A4  1439 00C00007           1123mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000006AA                          1124mmm     ENDC
000006AA                 FALSE    1125mmm     IFNE DEBUG
000006AA                          1126mmm     ENDC
000006AA                          1127mmm      
000006AA  B43C 001B               1128mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000006AE  6700 F958               1129mmm     BEQ START
000006B2                          1130mmm     ENDM
000006B2                          1131mm CONTINUE_67
000006B2  1639 00C00013           1132mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000006B8  0803 0000               1133mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000006BC  67D8                    1134mm     BEQ WAIT_FOR_READY_67                       ; NOTHING, CHECK AGAIN
000006BE                          1135mm     
000006BE  1439 00C00017           1136mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000006C4  13C2 00E00001           1137mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000006CA                          1138mm     
000006CA                          1139mm     ENDM
000006CA                          1140mm     PRINT_CHAR D2,D3
000006CA                          1141mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006CA                 TRUE     1142mm     IFEQ DEBUG
000006CA  1639 00C00003           1143mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000006D0  0803 0002               1144mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000006D4  67F4                    1145mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
000006D6  13C2 00C00007           1146mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006DC                          1147mm     ENDC
000006DC                          1148mm     
000006DC                 FALSE    1149mm     IFNE DEBUG
000006DC                          1150mm     ENDC
000006DC                          1151mm 
000006DC                          1152mm     ENDM
000006DC                          1153mm     HEX2BIN D2,D2,A0
000006DC  41F9 00001472           1154mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000006E2  0402 0030               1155mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006E6  C4BC 000000FF           1156mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000006EC  1430 2000               1157mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000006F0                          1158mm     ENDM
000006F0  8E02                    1159m     OR.B D2,D7
000006F2  E98F                    1160m     LSL.L #4,D7
000006F4                          1161m         
000006F4                          1162mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
000006F4                          1163mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F4                          1164mm 
000006F4  1639 00C00003           1165mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000006FA  0803 0000               1166mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000006FE  6700 0010               1167mm     BEQ CONTINUE_71                             ; NOTHING, CONTINUE
00000702                          1168mm  
00000702                          1169mmm     READ_CHAR D2
00000702                 TRUE     1170mmm     IFEQ DEBUG
00000702  1439 00C00007           1171mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000708                          1172mmm     ENDC
00000708                 FALSE    1173mmm     IFNE DEBUG
00000708                          1174mmm     ENDC
00000708                          1175mmm      
00000708  B43C 001B               1176mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000070C  6700 F8FA               1177mmm     BEQ START
00000710                          1178mmm     ENDM
00000710                          1179mm CONTINUE_71
00000710  1639 00C00013           1180mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000716  0803 0000               1181mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000071A  67D8                    1182mm     BEQ WAIT_FOR_READY_71                       ; NOTHING, CHECK AGAIN
0000071C                          1183mm     
0000071C  1439 00C00017           1184mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000722  13C2 00E00001           1185mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000728                          1186mm     
00000728                          1187mm     ENDM
00000728                          1188mm     PRINT_CHAR D2,D3
00000728                          1189mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000728                 TRUE     1190mm     IFEQ DEBUG
00000728  1639 00C00003           1191mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000072E  0803 0002               1192mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000732  67F4                    1193mm         BEQ WAIT_FOR_READY_73                   ; NO SPACE, CHECK AGAIN
00000734  13C2 00C00007           1194mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000073A                          1195mm     ENDC
0000073A                          1196mm     
0000073A                 FALSE    1197mm     IFNE DEBUG
0000073A                          1198mm     ENDC
0000073A                          1199mm 
0000073A                          1200mm     ENDM
0000073A                          1201mm     HEX2BIN D2,D2,A0
0000073A  41F9 00001472           1202mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000740  0402 0030               1203mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000744  C4BC 000000FF           1204mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000074A  1430 2000               1205mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000074E                          1206mm     ENDM
0000074E  8E02                    1207m     OR.B D2,D7    
00000750                          1208m     ENDM
00000750  7400                    1209              MOVE.L #0,D2                        ; rextract bottom byte of address and add into checksum
00000752  1407                    1210              MOVE.B D7,D2
00000754  DC82                    1211              ADD.L D2,D6
00000756                          1212          
00000756  2247                    1213              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00000758  D3CB                    1214              ADD.L A3,A1                         ; add in the offset
0000075A                          1215          
0000075A  5785                    1216              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
0000075C                          1217          
0000075C                          1218              WHILE.L D5 <GT> #0 DO               ; read the data bytes
0000075C                          1219s _10000000
0000075C  BABC 00000000           1220s     CMP.L   #0,D5
00000762  6F00 00C8               1221s     BLE _10000001
00000766  7E00                    1222                  MOVE.L #0,D7                    ; D7 holds the byte
00000768                          1223m                 DOWNLOAD_BYTE D2,D7,D3,A0       ; read it                               
00000768                          1224mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000768                          1225mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000768                          1226mm 
00000768  1639 00C00003           1227mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0000076E  0803 0000               1228mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000772  6700 0010               1229mm     BEQ CONTINUE_76                             ; NOTHING, CONTINUE
00000776                          1230mm  
00000776                          1231mmm     READ_CHAR D2
00000776                 TRUE     1232mmm     IFEQ DEBUG
00000776  1439 00C00007           1233mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000077C                          1234mmm     ENDC
0000077C                 FALSE    1235mmm     IFNE DEBUG
0000077C                          1236mmm     ENDC
0000077C                          1237mmm      
0000077C  B43C 001B               1238mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000780  6700 F886               1239mmm     BEQ START
00000784                          1240mmm     ENDM
00000784                          1241mm CONTINUE_76
00000784  1639 00C00013           1242mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0000078A  0803 0000               1243mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000078E  67D8                    1244mm     BEQ WAIT_FOR_READY_76                       ; NOTHING, CHECK AGAIN
00000790                          1245mm     
00000790  1439 00C00017           1246mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000796  13C2 00E00001           1247mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000079C                          1248mm     
0000079C                          1249mm     ENDM
0000079C                          1250mm     PRINT_CHAR D2,D3
0000079C                          1251mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000079C                 TRUE     1252mm     IFEQ DEBUG
0000079C  1639 00C00003           1253mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000007A2  0803 0002               1254mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000007A6  67F4                    1255mm         BEQ WAIT_FOR_READY_78                   ; NO SPACE, CHECK AGAIN
000007A8  13C2 00C00007           1256mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007AE                          1257mm     ENDC
000007AE                          1258mm     
000007AE                 FALSE    1259mm     IFNE DEBUG
000007AE                          1260mm     ENDC
000007AE                          1261mm 
000007AE                          1262mm     ENDM
000007AE                          1263mm     HEX2BIN D2,D2,A0
000007AE  41F9 00001472           1264mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000007B4  0402 0030               1265mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B8  C4BC 000000FF           1266mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000007BE  1430 2000               1267mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000007C2                          1268mm     ENDM
000007C2  8E02                    1269m     OR.B D2,D7
000007C4  E98F                    1270m     LSL.L #4,D7
000007C6                          1271m         
000007C6                          1272mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
000007C6                          1273mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C6                          1274mm 
000007C6  1639 00C00003           1275mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000007CC  0803 0000               1276mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000007D0  6700 0010               1277mm     BEQ CONTINUE_80                             ; NOTHING, CONTINUE
000007D4                          1278mm  
000007D4                          1279mmm     READ_CHAR D2
000007D4                 TRUE     1280mmm     IFEQ DEBUG
000007D4  1439 00C00007           1281mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000007DA                          1282mmm     ENDC
000007DA                 FALSE    1283mmm     IFNE DEBUG
000007DA                          1284mmm     ENDC
000007DA                          1285mmm      
000007DA  B43C 001B               1286mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000007DE  6700 F828               1287mmm     BEQ START
000007E2                          1288mmm     ENDM
000007E2                          1289mm CONTINUE_80
000007E2  1639 00C00013           1290mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000007E8  0803 0000               1291mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000007EC  67D8                    1292mm     BEQ WAIT_FOR_READY_80                       ; NOTHING, CHECK AGAIN
000007EE                          1293mm     
000007EE  1439 00C00017           1294mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000007F4  13C2 00E00001           1295mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000007FA                          1296mm     
000007FA                          1297mm     ENDM
000007FA                          1298mm     PRINT_CHAR D2,D3
000007FA                          1299mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FA                 TRUE     1300mm     IFEQ DEBUG
000007FA  1639 00C00003           1301mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000800  0803 0002               1302mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000804  67F4                    1303mm         BEQ WAIT_FOR_READY_82                   ; NO SPACE, CHECK AGAIN
00000806  13C2 00C00007           1304mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000080C                          1305mm     ENDC
0000080C                          1306mm     
0000080C                 FALSE    1307mm     IFNE DEBUG
0000080C                          1308mm     ENDC
0000080C                          1309mm 
0000080C                          1310mm     ENDM
0000080C                          1311mm     HEX2BIN D2,D2,A0
0000080C  41F9 00001472           1312mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000812  0402 0030               1313mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000816  C4BC 000000FF           1314mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000081C  1430 2000               1315mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000820                          1316mm     ENDM
00000820  8E02                    1317m     OR.B D2,D7    
00000822                          1318m     ENDM
00000822  DC87                    1319                  ADD.L D7,D6                     ; add into checksum
00000824                          1320                          
00000824  12C7                    1321                  MOVE.B D7,(A1)+                 ; store it!
00000826                          1322  
00000826  5385                    1323                  SUB.L #1,D5                     ; 1 less byte to go
00000828                          1324              ENDW
00000828  6000 FF32               1325s     BRA _10000000
0000082C                          1326s _10000001
0000082C                          1327          
0000082C                          1328m             PRINT_CRLF D3
0000082C                          1329mm     PRINT_CHAR #13,D3                           ; CR
0000082C                          1330mm WAIT_FOR_READY_85                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082C                 TRUE     1331mm     IFEQ DEBUG
0000082C  1639 00C00003           1332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000832  0803 0002               1333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000836  67F4                    1334mm         BEQ WAIT_FOR_READY_85                   ; NO SPACE, CHECK AGAIN
00000838  13FC 000D 00C00007      1335mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000840                          1336mm     ENDC
00000840                          1337mm     
00000840                 FALSE    1338mm     IFNE DEBUG
00000840                          1339mm     ENDC
00000840                          1340mm 
00000840                          1341mm     ENDM
00000840                          1342mm     PRINT_CHAR #10,D3                           ; LF
00000840                          1343mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                 TRUE     1344mm     IFEQ DEBUG
00000840  1639 00C00003           1345mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000846  0803 0002               1346mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000084A  67F4                    1347mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
0000084C  13FC 000A 00C00007      1348mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000854                          1349mm     ENDC
00000854                          1350mm     
00000854                 FALSE    1351mm     IFNE DEBUG
00000854                          1352mm     ENDC
00000854                          1353mm 
00000854                          1354mm     ENDM
00000854                          1355m     ENDM
00000854  43F8 048E               1356              LEA WAIT_FOR_SRECORD,A1             ; next place to go
00000858                          1357        ELSE
00000858  6000 060A               1358s     BRA _00000003
0000085C                          1359s _00000002
0000085C                          1360              IF.B D7 <EQ> #'2' THEN.L            ; 24 bit address data record
0000085C  BE3C 0032               1361s     CMP.B   #'2',D7
00000860  6600 034A               1362s     BNE.L   _00000004
00000864  7E00                    1363                  MOVE.L #0,D7                    ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000866                          1364m                 DOWNLOAD_BYTE D2,D7,D3,A0               
00000866                          1365mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000866                          1366mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000866                          1367mm 
00000866  1639 00C00003           1368mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0000086C  0803 0000               1369mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000870  6700 0010               1370mm     BEQ CONTINUE_88                             ; NOTHING, CONTINUE
00000874                          1371mm  
00000874                          1372mmm     READ_CHAR D2
00000874                 TRUE     1373mmm     IFEQ DEBUG
00000874  1439 00C00007           1374mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000087A                          1375mmm     ENDC
0000087A                 FALSE    1376mmm     IFNE DEBUG
0000087A                          1377mmm     ENDC
0000087A                          1378mmm      
0000087A  B43C 001B               1379mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000087E  6700 F788               1380mmm     BEQ START
00000882                          1381mmm     ENDM
00000882                          1382mm CONTINUE_88
00000882  1639 00C00013           1383mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000888  0803 0000               1384mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000088C  67D8                    1385mm     BEQ WAIT_FOR_READY_88                       ; NOTHING, CHECK AGAIN
0000088E                          1386mm     
0000088E  1439 00C00017           1387mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000894  13C2 00E00001           1388mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000089A                          1389mm     
0000089A                          1390mm     ENDM
0000089A                          1391mm     PRINT_CHAR D2,D3
0000089A                          1392mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000089A                 TRUE     1393mm     IFEQ DEBUG
0000089A  1639 00C00003           1394mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000008A0  0803 0002               1395mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000008A4  67F4                    1396mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
000008A6  13C2 00C00007           1397mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008AC                          1398mm     ENDC
000008AC                          1399mm     
000008AC                 FALSE    1400mm     IFNE DEBUG
000008AC                          1401mm     ENDC
000008AC                          1402mm 
000008AC                          1403mm     ENDM
000008AC                          1404mm     HEX2BIN D2,D2,A0
000008AC  41F9 00001472           1405mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000008B2  0402 0030               1406mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B6  C4BC 000000FF           1407mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000008BC  1430 2000               1408mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000008C0                          1409mm     ENDM
000008C0  8E02                    1410m     OR.B D2,D7
000008C2  E98F                    1411m     LSL.L #4,D7
000008C4                          1412m         
000008C4                          1413mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
000008C4                          1414mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008C4                          1415mm 
000008C4  1639 00C00003           1416mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000008CA  0803 0000               1417mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000008CE  6700 0010               1418mm     BEQ CONTINUE_92                             ; NOTHING, CONTINUE
000008D2                          1419mm  
000008D2                          1420mmm     READ_CHAR D2
000008D2                 TRUE     1421mmm     IFEQ DEBUG
000008D2  1439 00C00007           1422mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000008D8                          1423mmm     ENDC
000008D8                 FALSE    1424mmm     IFNE DEBUG
000008D8                          1425mmm     ENDC
000008D8                          1426mmm      
000008D8  B43C 001B               1427mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000008DC  6700 F72A               1428mmm     BEQ START
000008E0                          1429mmm     ENDM
000008E0                          1430mm CONTINUE_92
000008E0  1639 00C00013           1431mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000008E6  0803 0000               1432mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000008EA  67D8                    1433mm     BEQ WAIT_FOR_READY_92                       ; NOTHING, CHECK AGAIN
000008EC                          1434mm     
000008EC  1439 00C00017           1435mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000008F2  13C2 00E00001           1436mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000008F8                          1437mm     
000008F8                          1438mm     ENDM
000008F8                          1439mm     PRINT_CHAR D2,D3
000008F8                          1440mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F8                 TRUE     1441mm     IFEQ DEBUG
000008F8  1639 00C00003           1442mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000008FE  0803 0002               1443mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000902  67F4                    1444mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000904  13C2 00C00007           1445mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000090A                          1446mm     ENDC
0000090A                          1447mm     
0000090A                 FALSE    1448mm     IFNE DEBUG
0000090A                          1449mm     ENDC
0000090A                          1450mm 
0000090A                          1451mm     ENDM
0000090A                          1452mm     HEX2BIN D2,D2,A0
0000090A  41F9 00001472           1453mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000910  0402 0030               1454mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000914  C4BC 000000FF           1455mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000091A  1430 2000               1456mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000091E                          1457mm     ENDM
0000091E  8E02                    1458m     OR.B D2,D7    
00000920                          1459m     ENDM
00000920  DC87                    1460                  ADD.L D7,D6                     ; add into checksum
00000922                          1461  
00000922  E98F                    1462                  LSL.L #4,D7                     ; middle byte
00000924                          1463m                 DOWNLOAD_BYTE D2,D7,D3,A0               
00000924                          1464mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000924                          1465mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000924                          1466mm 
00000924  1639 00C00003           1467mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0000092A  0803 0000               1468mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000092E  6700 0010               1469mm     BEQ CONTINUE_97                             ; NOTHING, CONTINUE
00000932                          1470mm  
00000932                          1471mmm     READ_CHAR D2
00000932                 TRUE     1472mmm     IFEQ DEBUG
00000932  1439 00C00007           1473mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000938                          1474mmm     ENDC
00000938                 FALSE    1475mmm     IFNE DEBUG
00000938                          1476mmm     ENDC
00000938                          1477mmm      
00000938  B43C 001B               1478mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000093C  6700 F6CA               1479mmm     BEQ START
00000940                          1480mmm     ENDM
00000940                          1481mm CONTINUE_97
00000940  1639 00C00013           1482mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000946  0803 0000               1483mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000094A  67D8                    1484mm     BEQ WAIT_FOR_READY_97                       ; NOTHING, CHECK AGAIN
0000094C                          1485mm     
0000094C  1439 00C00017           1486mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000952  13C2 00E00001           1487mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000958                          1488mm     
00000958                          1489mm     ENDM
00000958                          1490mm     PRINT_CHAR D2,D3
00000958                          1491mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000958                 TRUE     1492mm     IFEQ DEBUG
00000958  1639 00C00003           1493mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000095E  0803 0002               1494mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000962  67F4                    1495mm         BEQ WAIT_FOR_READY_99                   ; NO SPACE, CHECK AGAIN
00000964  13C2 00C00007           1496mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000096A                          1497mm     ENDC
0000096A                          1498mm     
0000096A                 FALSE    1499mm     IFNE DEBUG
0000096A                          1500mm     ENDC
0000096A                          1501mm 
0000096A                          1502mm     ENDM
0000096A                          1503mm     HEX2BIN D2,D2,A0
0000096A  41F9 00001472           1504mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000970  0402 0030               1505mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000974  C4BC 000000FF           1506mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000097A  1430 2000               1507mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000097E                          1508mm     ENDM
0000097E  8E02                    1509m     OR.B D2,D7
00000980  E98F                    1510m     LSL.L #4,D7
00000982                          1511m         
00000982                          1512mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000982                          1513mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000982                          1514mm 
00000982  1639 00C00003           1515mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000988  0803 0000               1516mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0000098C  6700 0010               1517mm     BEQ CONTINUE_101                                ; NOTHING, CONTINUE
00000990                          1518mm  
00000990                          1519mmm     READ_CHAR D2
00000990                 TRUE     1520mmm     IFEQ DEBUG
00000990  1439 00C00007           1521mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000996                          1522mmm     ENDC
00000996                 FALSE    1523mmm     IFNE DEBUG
00000996                          1524mmm     ENDC
00000996                          1525mmm      
00000996  B43C 001B               1526mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000099A  6700 F66C               1527mmm     BEQ START
0000099E                          1528mmm     ENDM
0000099E                          1529mm CONTINUE_101
0000099E  1639 00C00013           1530mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
000009A4  0803 0000               1531mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000009A8  67D8                    1532mm     BEQ WAIT_FOR_READY_101                      ; NOTHING, CHECK AGAIN
000009AA                          1533mm     
000009AA  1439 00C00017           1534mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000009B0  13C2 00E00001           1535mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000009B6                          1536mm     
000009B6                          1537mm     ENDM
000009B6                          1538mm     PRINT_CHAR D2,D3
000009B6                          1539mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B6                 TRUE     1540mm     IFEQ DEBUG
000009B6  1639 00C00003           1541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009BC  0803 0002               1542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009C0  67F4                    1543mm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
000009C2  13C2 00C00007           1544mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009C8                          1545mm     ENDC
000009C8                          1546mm     
000009C8                 FALSE    1547mm     IFNE DEBUG
000009C8                          1548mm     ENDC
000009C8                          1549mm 
000009C8                          1550mm     ENDM
000009C8                          1551mm     HEX2BIN D2,D2,A0
000009C8  41F9 00001472           1552mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000009CE  0402 0030               1553mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009D2  C4BC 000000FF           1554mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000009D8  1430 2000               1555mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000009DC                          1556mm     ENDM
000009DC  8E02                    1557m     OR.B D2,D7    
000009DE                          1558m     ENDM
000009DE  7400                    1559                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
000009E0  1407                    1560                  MOVE.B D7,D2
000009E2  DC82                    1561                  ADD.L D2,D6
000009E4                          1562            
000009E4  E98F                    1563                  LSL.L #4,D7                     ; bottom byte
000009E6                          1564m                 DOWNLOAD_BYTE D2,D7,D3,A0                       
000009E6                          1565mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
000009E6                          1566mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                          1567mm 
000009E6  1639 00C00003           1568mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
000009EC  0803 0000               1569mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
000009F0  6700 0010               1570mm     BEQ CONTINUE_106                                ; NOTHING, CONTINUE
000009F4                          1571mm  
000009F4                          1572mmm     READ_CHAR D2
000009F4                 TRUE     1573mmm     IFEQ DEBUG
000009F4  1439 00C00007           1574mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000009FA                          1575mmm     ENDC
000009FA                 FALSE    1576mmm     IFNE DEBUG
000009FA                          1577mmm     ENDC
000009FA                          1578mmm      
000009FA  B43C 001B               1579mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000009FE  6700 F608               1580mmm     BEQ START
00000A02                          1581mmm     ENDM
00000A02                          1582mm CONTINUE_106
00000A02  1639 00C00013           1583mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000A08  0803 0000               1584mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000A0C  67D8                    1585mm     BEQ WAIT_FOR_READY_106                      ; NOTHING, CHECK AGAIN
00000A0E                          1586mm     
00000A0E  1439 00C00017           1587mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000A14  13C2 00E00001           1588mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000A1A                          1589mm     
00000A1A                          1590mm     ENDM
00000A1A                          1591mm     PRINT_CHAR D2,D3
00000A1A                          1592mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1A                 TRUE     1593mm     IFEQ DEBUG
00000A1A  1639 00C00003           1594mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A20  0803 0002               1595mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A24  67F4                    1596mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A26  13C2 00C00007           1597mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A2C                          1598mm     ENDC
00000A2C                          1599mm     
00000A2C                 FALSE    1600mm     IFNE DEBUG
00000A2C                          1601mm     ENDC
00000A2C                          1602mm 
00000A2C                          1603mm     ENDM
00000A2C                          1604mm     HEX2BIN D2,D2,A0
00000A2C  41F9 00001472           1605mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000A32  0402 0030               1606mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A36  C4BC 000000FF           1607mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000A3C  1430 2000               1608mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A40                          1609mm     ENDM
00000A40  8E02                    1610m     OR.B D2,D7
00000A42  E98F                    1611m     LSL.L #4,D7
00000A44                          1612m         
00000A44                          1613mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000A44                          1614mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A44                          1615mm 
00000A44  1639 00C00003           1616mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000A4A  0803 0000               1617mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000A4E  6700 0010               1618mm     BEQ CONTINUE_110                                ; NOTHING, CONTINUE
00000A52                          1619mm  
00000A52                          1620mmm     READ_CHAR D2
00000A52                 TRUE     1621mmm     IFEQ DEBUG
00000A52  1439 00C00007           1622mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000A58                          1623mmm     ENDC
00000A58                 FALSE    1624mmm     IFNE DEBUG
00000A58                          1625mmm     ENDC
00000A58                          1626mmm      
00000A58  B43C 001B               1627mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000A5C  6700 F5AA               1628mmm     BEQ START
00000A60                          1629mmm     ENDM
00000A60                          1630mm CONTINUE_110
00000A60  1639 00C00013           1631mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000A66  0803 0000               1632mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000A6A  67D8                    1633mm     BEQ WAIT_FOR_READY_110                      ; NOTHING, CHECK AGAIN
00000A6C                          1634mm     
00000A6C  1439 00C00017           1635mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000A72  13C2 00E00001           1636mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000A78                          1637mm     
00000A78                          1638mm     ENDM
00000A78                          1639mm     PRINT_CHAR D2,D3
00000A78                          1640mm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A78                 TRUE     1641mm     IFEQ DEBUG
00000A78  1639 00C00003           1642mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A7E  0803 0002               1643mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A82  67F4                    1644mm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000A84  13C2 00C00007           1645mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A8A                          1646mm     ENDC
00000A8A                          1647mm     
00000A8A                 FALSE    1648mm     IFNE DEBUG
00000A8A                          1649mm     ENDC
00000A8A                          1650mm 
00000A8A                          1651mm     ENDM
00000A8A                          1652mm     HEX2BIN D2,D2,A0
00000A8A  41F9 00001472           1653mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000A90  0402 0030               1654mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A94  C4BC 000000FF           1655mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000A9A  1430 2000               1656mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A9E                          1657mm     ENDM
00000A9E  8E02                    1658m     OR.B D2,D7    
00000AA0                          1659m     ENDM
00000AA0  7400                    1660                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00000AA2  1407                    1661                  MOVE.B D7,D2
00000AA4  DC82                    1662                  ADD.L D2,D6
00000AA6                          1663                  
00000AA6  2247                    1664                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00000AA8  D3CB                    1665                  ADD.L A3,A1                     ; add in the offset
00000AAA                          1666          
00000AAA  5985                    1667                  SUB.L #4,D5                     ; subtract four bytes for 24 bit address and 1 byte checksum
00000AAC                          1668                  WHILE.L D5 <GT> #0 DO           ; read the data bytes                   
00000AAC                          1669s _10000002
00000AAC  BABC 00000000           1670s     CMP.L   #0,D5
00000AB2  6F00 00C8               1671s     BLE _10000003
00000AB6  7E00                    1672                      MOVE.L #0,D7                ; D7 holds the byte
00000AB8                          1673m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                        
00000AB8                          1674mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000AB8                          1675mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB8                          1676mm 
00000AB8  1639 00C00003           1677mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000ABE  0803 0000               1678mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000AC2  6700 0010               1679mm     BEQ CONTINUE_115                                ; NOTHING, CONTINUE
00000AC6                          1680mm  
00000AC6                          1681mmm     READ_CHAR D2
00000AC6                 TRUE     1682mmm     IFEQ DEBUG
00000AC6  1439 00C00007           1683mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000ACC                          1684mmm     ENDC
00000ACC                 FALSE    1685mmm     IFNE DEBUG
00000ACC                          1686mmm     ENDC
00000ACC                          1687mmm      
00000ACC  B43C 001B               1688mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000AD0  6700 F536               1689mmm     BEQ START
00000AD4                          1690mmm     ENDM
00000AD4                          1691mm CONTINUE_115
00000AD4  1639 00C00013           1692mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000ADA  0803 0000               1693mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000ADE  67D8                    1694mm     BEQ WAIT_FOR_READY_115                      ; NOTHING, CHECK AGAIN
00000AE0                          1695mm     
00000AE0  1439 00C00017           1696mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000AE6  13C2 00E00001           1697mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000AEC                          1698mm     
00000AEC                          1699mm     ENDM
00000AEC                          1700mm     PRINT_CHAR D2,D3
00000AEC                          1701mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEC                 TRUE     1702mm     IFEQ DEBUG
00000AEC  1639 00C00003           1703mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AF2  0803 0002               1704mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AF6  67F4                    1705mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000AF8  13C2 00C00007           1706mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AFE                          1707mm     ENDC
00000AFE                          1708mm     
00000AFE                 FALSE    1709mm     IFNE DEBUG
00000AFE                          1710mm     ENDC
00000AFE                          1711mm 
00000AFE                          1712mm     ENDM
00000AFE                          1713mm     HEX2BIN D2,D2,A0
00000AFE  41F9 00001472           1714mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000B04  0402 0030               1715mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B08  C4BC 000000FF           1716mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000B0E  1430 2000               1717mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000B12                          1718mm     ENDM
00000B12  8E02                    1719m     OR.B D2,D7
00000B14  E98F                    1720m     LSL.L #4,D7
00000B16                          1721m         
00000B16                          1722mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000B16                          1723mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B16                          1724mm 
00000B16  1639 00C00003           1725mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000B1C  0803 0000               1726mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000B20  6700 0010               1727mm     BEQ CONTINUE_119                                ; NOTHING, CONTINUE
00000B24                          1728mm  
00000B24                          1729mmm     READ_CHAR D2
00000B24                 TRUE     1730mmm     IFEQ DEBUG
00000B24  1439 00C00007           1731mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000B2A                          1732mmm     ENDC
00000B2A                 FALSE    1733mmm     IFNE DEBUG
00000B2A                          1734mmm     ENDC
00000B2A                          1735mmm      
00000B2A  B43C 001B               1736mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000B2E  6700 F4D8               1737mmm     BEQ START
00000B32                          1738mmm     ENDM
00000B32                          1739mm CONTINUE_119
00000B32  1639 00C00013           1740mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000B38  0803 0000               1741mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000B3C  67D8                    1742mm     BEQ WAIT_FOR_READY_119                      ; NOTHING, CHECK AGAIN
00000B3E                          1743mm     
00000B3E  1439 00C00017           1744mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000B44  13C2 00E00001           1745mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000B4A                          1746mm     
00000B4A                          1747mm     ENDM
00000B4A                          1748mm     PRINT_CHAR D2,D3
00000B4A                          1749mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4A                 TRUE     1750mm     IFEQ DEBUG
00000B4A  1639 00C00003           1751mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B50  0803 0002               1752mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B54  67F4                    1753mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B56  13C2 00C00007           1754mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B5C                          1755mm     ENDC
00000B5C                          1756mm     
00000B5C                 FALSE    1757mm     IFNE DEBUG
00000B5C                          1758mm     ENDC
00000B5C                          1759mm 
00000B5C                          1760mm     ENDM
00000B5C                          1761mm     HEX2BIN D2,D2,A0
00000B5C  41F9 00001472           1762mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000B62  0402 0030               1763mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B66  C4BC 000000FF           1764mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000B6C  1430 2000               1765mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000B70                          1766mm     ENDM
00000B70  8E02                    1767m     OR.B D2,D7    
00000B72                          1768m     ENDM
00000B72  DC87                    1769                      ADD.L D7,D6                 ; add into checksum
00000B74                          1770                      
00000B74  12C7                    1771                      MOVE.B D7,(A1)+             ; store it!
00000B76                          1772  
00000B76  5385                    1773                      SUB.L #1,D5                 ; 1 less byte to go
00000B78                          1774                  ENDW
00000B78  6000 FF32               1775s     BRA _10000002
00000B7C                          1776s _10000003
00000B7C                          1777              
00000B7C                          1778m                 PRINT_CRLF D3
00000B7C                          1779mm     PRINT_CHAR #13,D3                           ; CR
00000B7C                          1780mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7C                 TRUE     1781mm     IFEQ DEBUG
00000B7C  1639 00C00003           1782mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B82  0803 0002               1783mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B86  67F4                    1784mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B88  13FC 000D 00C00007      1785mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B90                          1786mm     ENDC
00000B90                          1787mm     
00000B90                 FALSE    1788mm     IFNE DEBUG
00000B90                          1789mm     ENDC
00000B90                          1790mm 
00000B90                          1791mm     ENDM
00000B90                          1792mm     PRINT_CHAR #10,D3                           ; LF
00000B90                          1793mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     1794mm     IFEQ DEBUG
00000B90  1639 00C00003           1795mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B96  0803 0002               1796mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    1797mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000B9C  13FC 000A 00C00007      1798mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BA4                          1799mm     ENDC
00000BA4                          1800mm     
00000BA4                 FALSE    1801mm     IFNE DEBUG
00000BA4                          1802mm     ENDC
00000BA4                          1803mm 
00000BA4                          1804mm     ENDM
00000BA4                          1805m     ENDM
00000BA4  43F8 048E               1806                  LEA WAIT_FOR_SRECORD,A1         ; next place to go
00000BA8                          1807              ELSE
00000BA8  6000 02BA               1808s     BRA _00000005
00000BAC                          1809s _00000004
00000BAC                          1810                  IF.B D7 <EQ> #'8' THEN.L        ; termination record, exit
00000BAC  BE3C 0038               1811s     CMP.B   #'8',D7
00000BB0  6600 0250               1812s     BNE.L   _00000006
00000BB4  7E00                    1813                      MOVE.L #0,D7                ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000BB6                          1814m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00000BB6                          1815mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000BB6                          1816mm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB6                          1817mm 
00000BB6  1639 00C00003           1818mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000BBC  0803 0000               1819mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000BC0  6700 0010               1820mm     BEQ CONTINUE_127                                ; NOTHING, CONTINUE
00000BC4                          1821mm  
00000BC4                          1822mmm     READ_CHAR D2
00000BC4                 TRUE     1823mmm     IFEQ DEBUG
00000BC4  1439 00C00007           1824mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000BCA                          1825mmm     ENDC
00000BCA                 FALSE    1826mmm     IFNE DEBUG
00000BCA                          1827mmm     ENDC
00000BCA                          1828mmm      
00000BCA  B43C 001B               1829mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000BCE  6700 F438               1830mmm     BEQ START
00000BD2                          1831mmm     ENDM
00000BD2                          1832mm CONTINUE_127
00000BD2  1639 00C00013           1833mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000BD8  0803 0000               1834mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000BDC  67D8                    1835mm     BEQ WAIT_FOR_READY_127                      ; NOTHING, CHECK AGAIN
00000BDE                          1836mm     
00000BDE  1439 00C00017           1837mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000BE4  13C2 00E00001           1838mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000BEA                          1839mm     
00000BEA                          1840mm     ENDM
00000BEA                          1841mm     PRINT_CHAR D2,D3
00000BEA                          1842mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEA                 TRUE     1843mm     IFEQ DEBUG
00000BEA  1639 00C00003           1844mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BF0  0803 0002               1845mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BF4  67F4                    1846mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BF6  13C2 00C00007           1847mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BFC                          1848mm     ENDC
00000BFC                          1849mm     
00000BFC                 FALSE    1850mm     IFNE DEBUG
00000BFC                          1851mm     ENDC
00000BFC                          1852mm 
00000BFC                          1853mm     ENDM
00000BFC                          1854mm     HEX2BIN D2,D2,A0
00000BFC  41F9 00001472           1855mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000C02  0402 0030               1856mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C06  C4BC 000000FF           1857mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000C0C  1430 2000               1858mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000C10                          1859mm     ENDM
00000C10  8E02                    1860m     OR.B D2,D7
00000C12  E98F                    1861m     LSL.L #4,D7
00000C14                          1862m         
00000C14                          1863mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000C14                          1864mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C14                          1865mm 
00000C14  1639 00C00003           1866mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000C1A  0803 0000               1867mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000C1E  6700 0010               1868mm     BEQ CONTINUE_131                                ; NOTHING, CONTINUE
00000C22                          1869mm  
00000C22                          1870mmm     READ_CHAR D2
00000C22                 TRUE     1871mmm     IFEQ DEBUG
00000C22  1439 00C00007           1872mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000C28                          1873mmm     ENDC
00000C28                 FALSE    1874mmm     IFNE DEBUG
00000C28                          1875mmm     ENDC
00000C28                          1876mmm      
00000C28  B43C 001B               1877mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000C2C  6700 F3DA               1878mmm     BEQ START
00000C30                          1879mmm     ENDM
00000C30                          1880mm CONTINUE_131
00000C30  1639 00C00013           1881mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000C36  0803 0000               1882mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000C3A  67D8                    1883mm     BEQ WAIT_FOR_READY_131                      ; NOTHING, CHECK AGAIN
00000C3C                          1884mm     
00000C3C  1439 00C00017           1885mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000C42  13C2 00E00001           1886mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000C48                          1887mm     
00000C48                          1888mm     ENDM
00000C48                          1889mm     PRINT_CHAR D2,D3
00000C48                          1890mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C48                 TRUE     1891mm     IFEQ DEBUG
00000C48  1639 00C00003           1892mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C4E  0803 0002               1893mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C52  67F4                    1894mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C54  13C2 00C00007           1895mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C5A                          1896mm     ENDC
00000C5A                          1897mm     
00000C5A                 FALSE    1898mm     IFNE DEBUG
00000C5A                          1899mm     ENDC
00000C5A                          1900mm 
00000C5A                          1901mm     ENDM
00000C5A                          1902mm     HEX2BIN D2,D2,A0
00000C5A  41F9 00001472           1903mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000C60  0402 0030               1904mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C64  C4BC 000000FF           1905mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000C6A  1430 2000               1906mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000C6E                          1907mm     ENDM
00000C6E  8E02                    1908m     OR.B D2,D7    
00000C70                          1909m     ENDM
00000C70  DC87                    1910                      ADD.L D7,D6                 ; add top byte of address into checksum
00000C72                          1911  
00000C72  E98F                    1912                      LSL.L #4,D7                 ; middle byte
00000C74                          1913m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00000C74                          1914mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000C74                          1915mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C74                          1916mm 
00000C74  1639 00C00003           1917mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000C7A  0803 0000               1918mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000C7E  6700 0010               1919mm     BEQ CONTINUE_136                                ; NOTHING, CONTINUE
00000C82                          1920mm  
00000C82                          1921mmm     READ_CHAR D2
00000C82                 TRUE     1922mmm     IFEQ DEBUG
00000C82  1439 00C00007           1923mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000C88                          1924mmm     ENDC
00000C88                 FALSE    1925mmm     IFNE DEBUG
00000C88                          1926mmm     ENDC
00000C88                          1927mmm      
00000C88  B43C 001B               1928mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000C8C  6700 F37A               1929mmm     BEQ START
00000C90                          1930mmm     ENDM
00000C90                          1931mm CONTINUE_136
00000C90  1639 00C00013           1932mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000C96  0803 0000               1933mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000C9A  67D8                    1934mm     BEQ WAIT_FOR_READY_136                      ; NOTHING, CHECK AGAIN
00000C9C                          1935mm     
00000C9C  1439 00C00017           1936mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000CA2  13C2 00E00001           1937mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000CA8                          1938mm     
00000CA8                          1939mm     ENDM
00000CA8                          1940mm     PRINT_CHAR D2,D3
00000CA8                          1941mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA8                 TRUE     1942mm     IFEQ DEBUG
00000CA8  1639 00C00003           1943mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CAE  0803 0002               1944mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB2  67F4                    1945mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000CB4  13C2 00C00007           1946mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CBA                          1947mm     ENDC
00000CBA                          1948mm     
00000CBA                 FALSE    1949mm     IFNE DEBUG
00000CBA                          1950mm     ENDC
00000CBA                          1951mm 
00000CBA                          1952mm     ENDM
00000CBA                          1953mm     HEX2BIN D2,D2,A0
00000CBA  41F9 00001472           1954mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000CC0  0402 0030               1955mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CC4  C4BC 000000FF           1956mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000CCA  1430 2000               1957mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000CCE                          1958mm     ENDM
00000CCE  8E02                    1959m     OR.B D2,D7
00000CD0  E98F                    1960m     LSL.L #4,D7
00000CD2                          1961m         
00000CD2                          1962mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000CD2                          1963mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD2                          1964mm 
00000CD2  1639 00C00003           1965mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000CD8  0803 0000               1966mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000CDC  6700 0010               1967mm     BEQ CONTINUE_140                                ; NOTHING, CONTINUE
00000CE0                          1968mm  
00000CE0                          1969mmm     READ_CHAR D2
00000CE0                 TRUE     1970mmm     IFEQ DEBUG
00000CE0  1439 00C00007           1971mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000CE6                          1972mmm     ENDC
00000CE6                 FALSE    1973mmm     IFNE DEBUG
00000CE6                          1974mmm     ENDC
00000CE6                          1975mmm      
00000CE6  B43C 001B               1976mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000CEA  6700 F31C               1977mmm     BEQ START
00000CEE                          1978mmm     ENDM
00000CEE                          1979mm CONTINUE_140
00000CEE  1639 00C00013           1980mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000CF4  0803 0000               1981mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000CF8  67D8                    1982mm     BEQ WAIT_FOR_READY_140                      ; NOTHING, CHECK AGAIN
00000CFA                          1983mm     
00000CFA  1439 00C00017           1984mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000D00  13C2 00E00001           1985mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000D06                          1986mm     
00000D06                          1987mm     ENDM
00000D06                          1988mm     PRINT_CHAR D2,D3
00000D06                          1989mm WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D06                 TRUE     1990mm     IFEQ DEBUG
00000D06  1639 00C00003           1991mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D0C  0803 0002               1992mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D10  67F4                    1993mm         BEQ WAIT_FOR_READY_142                      ; NO SPACE, CHECK AGAIN
00000D12  13C2 00C00007           1994mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D18                          1995mm     ENDC
00000D18                          1996mm     
00000D18                 FALSE    1997mm     IFNE DEBUG
00000D18                          1998mm     ENDC
00000D18                          1999mm 
00000D18                          2000mm     ENDM
00000D18                          2001mm     HEX2BIN D2,D2,A0
00000D18  41F9 00001472           2002mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D1E  0402 0030               2003mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D22  C4BC 000000FF           2004mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D28  1430 2000               2005mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D2C                          2006mm     ENDM
00000D2C  8E02                    2007m     OR.B D2,D7    
00000D2E                          2008m     ENDM
00000D2E  7400                    2009                      MOVE.L #0,D2                ; rextract middle byte of address and add into checksum
00000D30  1407                    2010                      MOVE.B D7,D2
00000D32  DC82                    2011                      ADD.L D2,D6
00000D34                          2012                    
00000D34  E98F                    2013                      LSL.L #4,D7                 ; bottom byte
00000D36                          2014m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                             
00000D36                          2015mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00000D36                          2016mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D36                          2017mm 
00000D36  1639 00C00003           2018mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000D3C  0803 0000               2019mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000D40  6700 0010               2020mm     BEQ CONTINUE_145                                ; NOTHING, CONTINUE
00000D44                          2021mm  
00000D44                          2022mmm     READ_CHAR D2
00000D44                 TRUE     2023mmm     IFEQ DEBUG
00000D44  1439 00C00007           2024mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D4A                          2025mmm     ENDC
00000D4A                 FALSE    2026mmm     IFNE DEBUG
00000D4A                          2027mmm     ENDC
00000D4A                          2028mmm      
00000D4A  B43C 001B               2029mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D4E  6700 F2B8               2030mmm     BEQ START
00000D52                          2031mmm     ENDM
00000D52                          2032mm CONTINUE_145
00000D52  1639 00C00013           2033mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000D58  0803 0000               2034mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000D5C  67D8                    2035mm     BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D5E                          2036mm     
00000D5E  1439 00C00017           2037mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000D64  13C2 00E00001           2038mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000D6A                          2039mm     
00000D6A                          2040mm     ENDM
00000D6A                          2041mm     PRINT_CHAR D2,D3
00000D6A                          2042mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6A                 TRUE     2043mm     IFEQ DEBUG
00000D6A  1639 00C00003           2044mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D70  0803 0002               2045mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D74  67F4                    2046mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D76  13C2 00C00007           2047mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D7C                          2048mm     ENDC
00000D7C                          2049mm     
00000D7C                 FALSE    2050mm     IFNE DEBUG
00000D7C                          2051mm     ENDC
00000D7C                          2052mm 
00000D7C                          2053mm     ENDM
00000D7C                          2054mm     HEX2BIN D2,D2,A0
00000D7C  41F9 00001472           2055mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D82  0402 0030               2056mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D86  C4BC 000000FF           2057mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D8C  1430 2000               2058mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D90                          2059mm     ENDM
00000D90  8E02                    2060m     OR.B D2,D7
00000D92  E98F                    2061m     LSL.L #4,D7
00000D94                          2062m         
00000D94                          2063mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00000D94                          2064mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D94                          2065mm 
00000D94  1639 00C00003           2066mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000D9A  0803 0000               2067mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000D9E  6700 0010               2068mm     BEQ CONTINUE_149                                ; NOTHING, CONTINUE
00000DA2                          2069mm  
00000DA2                          2070mmm     READ_CHAR D2
00000DA2                 TRUE     2071mmm     IFEQ DEBUG
00000DA2  1439 00C00007           2072mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000DA8                          2073mmm     ENDC
00000DA8                 FALSE    2074mmm     IFNE DEBUG
00000DA8                          2075mmm     ENDC
00000DA8                          2076mmm      
00000DA8  B43C 001B               2077mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000DAC  6700 F25A               2078mmm     BEQ START
00000DB0                          2079mmm     ENDM
00000DB0                          2080mm CONTINUE_149
00000DB0  1639 00C00013           2081mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000DB6  0803 0000               2082mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000DBA  67D8                    2083mm     BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000DBC                          2084mm     
00000DBC  1439 00C00017           2085mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000DC2  13C2 00E00001           2086mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000DC8                          2087mm     
00000DC8                          2088mm     ENDM
00000DC8                          2089mm     PRINT_CHAR D2,D3
00000DC8                          2090mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC8                 TRUE     2091mm     IFEQ DEBUG
00000DC8  1639 00C00003           2092mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DCE  0803 0002               2093mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DD2  67F4                    2094mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DD4  13C2 00C00007           2095mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000DDA                          2096mm     ENDC
00000DDA                          2097mm     
00000DDA                 FALSE    2098mm     IFNE DEBUG
00000DDA                          2099mm     ENDC
00000DDA                          2100mm 
00000DDA                          2101mm     ENDM
00000DDA                          2102mm     HEX2BIN D2,D2,A0
00000DDA  41F9 00001472           2103mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000DE0  0402 0030               2104mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DE4  C4BC 000000FF           2105mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000DEA  1430 2000               2106mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000DEE                          2107mm     ENDM
00000DEE  8E02                    2108m     OR.B D2,D7    
00000DF0                          2109m     ENDM
00000DF0  7400                    2110                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00000DF2  1407                    2111                      MOVE.B D7,D2
00000DF4  DC82                    2112                      ADD.L D2,D6
00000DF6                          2113                    
00000DF6  2447                    2114                      MOVE.L D7,A2                ; start address -> A2
00000DF8                          2115                  
00000DF8  43F9 00000FB0           2116                      LEA DOWNLOAD_DONE,A1        ; next place to go
00000DFE                          2117                  ELSE
00000DFE  6000 0064               2118s     BRA _00000007
00000E02                          2119s _00000006
00000E02  41F9 00001427           2120                      LEA UNREC,A0                ; warn for unrecognised type
00000E08                          2121m                     PRINT_STR A0,D3
00000E08                          2122m LOOP_153
00000E08  0C10 0000               2123m     CMP.B #0,(A0)                               ; 0 -> DONE
00000E0C  6700 0018               2124m     BEQ EXIT_153
00000E10                          2125mm     PRINT_CHAR (A0)+,D3
00000E10                          2126mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E10                 TRUE     2127mm     IFEQ DEBUG
00000E10  1639 00C00003           2128mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E16  0803 0002               2129mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E1A  67F4                    2130mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E1C  13D8 00C00007           2131mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E22                          2132mm     ENDC
00000E22                          2133mm     
00000E22                 FALSE    2134mm     IFNE DEBUG
00000E22                          2135mm     ENDC
00000E22                          2136mm 
00000E22                          2137mm     ENDM
00000E22  4EF8 0E08               2138m     JMP LOOP_153
00000E26                          2139m EXIT_153
00000E26                          2140m     ENDM
00000E26                          2141m                     PRINT_CHAR D7,D3
00000E26                          2142m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E26                 TRUE     2143m     IFEQ DEBUG
00000E26  1639 00C00003           2144m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E2C  0803 0002               2145m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E30  67F4                    2146m         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000E32  13C7 00C00007           2147m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000E38                          2148m     ENDC
00000E38                          2149m     
00000E38                 FALSE    2150m     IFNE DEBUG
00000E38                          2151m     ENDC
00000E38                          2152m 
00000E38                          2153m     ENDM
00000E38                          2154m                     PRINT_CRLF D3
00000E38                          2155mm     PRINT_CHAR #13,D3                           ; CR
00000E38                          2156mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E38                 TRUE     2157mm     IFEQ DEBUG
00000E38  1639 00C00003           2158mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E3E  0803 0002               2159mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E42  67F4                    2160mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E44  13FC 000D 00C00007      2161mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000E4C                          2162mm     ENDC
00000E4C                          2163mm     
00000E4C                 FALSE    2164mm     IFNE DEBUG
00000E4C                          2165mm     ENDC
00000E4C                          2166mm 
00000E4C                          2167mm     ENDM
00000E4C                          2168mm     PRINT_CHAR #10,D3                           ; LF
00000E4C                          2169mm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2170mm     IFEQ DEBUG
00000E4C  1639 00C00003           2171mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E52  0803 0002               2172mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E56  67F4                    2173mm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000E58  13FC 000A 00C00007      2174mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000E60                          2175mm     ENDC
00000E60                          2176mm     
00000E60                 FALSE    2177mm     IFNE DEBUG
00000E60                          2178mm     ENDC
00000E60                          2179mm 
00000E60                          2180mm     ENDM
00000E60                          2181m     ENDM
00000E60                          2182              
00000E60  4EF8 048E               2183                      JMP WAIT_FOR_SRECORD        ; ignore any other type    
00000E64                          2184                  ENDI
00000E64                          2185s _00000007
00000E64                          2186              ENDI
00000E64                          2187s _00000005
00000E64                          2188          ENDI
00000E64                          2189s _00000003
00000E64                          2190      ENDI
00000E64                          2191s _00000001
00000E64                          2192      
00000E64  4686                    2193      NOT.L D6                                    ; ones complement the checksum
00000E66  0286 000000FF           2194      ANDI.L #$FF,D6                              ; and take the LSByte
00000E6C                          2195          
00000E6C  7E00                    2196      MOVE.L #0,D7                                ; read the checksum from the data stream
00000E6E                          2197m     DOWNLOAD D2,D3                              ; top byte
00000E6E                          2198m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E6E                          2199m 
00000E6E  1639 00C00003           2200m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000E74  0803 0000               2201m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E78  6700 0010               2202m     BEQ CONTINUE_159                                ; NOTHING, CONTINUE
00000E7C                          2203m  
00000E7C                          2204mm     READ_CHAR D2
00000E7C                 TRUE     2205mm     IFEQ DEBUG
00000E7C  1439 00C00007           2206mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000E82                          2207mm     ENDC
00000E82                 FALSE    2208mm     IFNE DEBUG
00000E82                          2209mm     ENDC
00000E82                          2210mm      
00000E82  B43C 001B               2211mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000E86  6700 F180               2212mm     BEQ START
00000E8A                          2213mm     ENDM
00000E8A                          2214m CONTINUE_159
00000E8A  1639 00C00013           2215m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000E90  0803 0000               2216m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E94  67D8                    2217m     BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00000E96                          2218m     
00000E96  1439 00C00017           2219m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000E9C  13C2 00E00001           2220m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000EA2                          2221m     
00000EA2                          2222m     ENDM
00000EA2                          2223m     HEX2BIN D2,D2,A0
00000EA2  41F9 00001472           2224m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000EA8  0402 0030               2225m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EAC  C4BC 000000FF           2226m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EB2  1430 2000               2227m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000EB6                          2228m     ENDM
00000EB6  8E82                    2229      OR.L D2,D7
00000EB8  E98F                    2230      LSL.L #4,D7
00000EBA                          2231m     DOWNLOAD D2,D3                              ; bottom byte
00000EBA                          2232m WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EBA                          2233m 
00000EBA  1639 00C00003           2234m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00000EC0  0803 0000               2235m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000EC4  6700 0010               2236m     BEQ CONTINUE_162                                ; NOTHING, CONTINUE
00000EC8                          2237m  
00000EC8                          2238mm     READ_CHAR D2
00000EC8                 TRUE     2239mm     IFEQ DEBUG
00000EC8  1439 00C00007           2240mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000ECE                          2241mm     ENDC
00000ECE                 FALSE    2242mm     IFNE DEBUG
00000ECE                          2243mm     ENDC
00000ECE                          2244mm      
00000ECE  B43C 001B               2245mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000ED2  6700 F134               2246mm     BEQ START
00000ED6                          2247mm     ENDM
00000ED6                          2248m CONTINUE_162
00000ED6  1639 00C00013           2249m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00000EDC  0803 0000               2250m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00000EE0  67D8                    2251m     BEQ WAIT_FOR_READY_162                      ; NOTHING, CHECK AGAIN
00000EE2                          2252m     
00000EE2  1439 00C00017           2253m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000EE8  13C2 00E00001           2254m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000EEE                          2255m     
00000EEE                          2256m     ENDM
00000EEE                          2257m     HEX2BIN D2,D2,A0
00000EEE  41F9 00001472           2258m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000EF4  0402 0030               2259m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EF8  C4BC 000000FF           2260m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EFE  1430 2000               2261m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000F02                          2262m     ENDM
00000F02  8E82                    2263      OR.L D2,D7
00000F04                          2264                  
00000F04                          2265      IF.B D7 <NE> D6 THEN.L
00000F04  BE06                    2266s     CMP.B   D6,D7
00000F06  6700 00A6               2267s     BEQ.L   _00000008
00000F0A  41F9 0000143E           2268          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00000F10                          2269m         PRINT_STR A0,D3
00000F10                          2270m LOOP_165
00000F10  0C10 0000               2271m     CMP.B #0,(A0)                               ; 0 -> DONE
00000F14  6700 0018               2272m     BEQ EXIT_165
00000F18                          2273mm     PRINT_CHAR (A0)+,D3
00000F18                          2274mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F18                 TRUE     2275mm     IFEQ DEBUG
00000F18  1639 00C00003           2276mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F1E  0803 0002               2277mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F22  67F4                    2278mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000F24  13D8 00C00007           2279mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000F2A                          2280mm     ENDC
00000F2A                          2281mm     
00000F2A                 FALSE    2282mm     IFNE DEBUG
00000F2A                          2283mm     ENDC
00000F2A                          2284mm 
00000F2A                          2285mm     ENDM
00000F2A  4EF8 0F10               2286m     JMP LOOP_165
00000F2E                          2287m EXIT_165
00000F2E                          2288m     ENDM
00000F2E                          2289m         PRINT_REG D4,D3,D6,D7,A0
00000F2E                          2290mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000F2E                          2291mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F2E                 TRUE     2292mm     IFEQ DEBUG
00000F2E  1639 00C00003           2293mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F34  0803 0002               2294mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F38  67F4                    2295mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000F3A  13FC 0030 00C00007      2296mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000F42                          2297mm     ENDC
00000F42                          2298mm     
00000F42                 FALSE    2299mm     IFNE DEBUG
00000F42                          2300mm     ENDC
00000F42                          2301mm 
00000F42                          2302mm     ENDM
00000F42                          2303mm     PRINT_CHAR #'x',D3
00000F42                          2304mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F42                 TRUE     2305mm     IFEQ DEBUG
00000F42  1639 00C00003           2306mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F48  0803 0002               2307mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F4C  67F4                    2308mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F4E  13FC 0078 00C00007      2309mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000F56                          2310mm     ENDC
00000F56                          2311mm     
00000F56                 FALSE    2312mm     IFNE DEBUG
00000F56                          2313mm     ENDC
00000F56                          2314mm 
00000F56                          2315mm     ENDM
00000F56  7E07                    2316m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F58                          2317m LOOP_167
00000F58                          2318mm     BIN2HEX D4,D6,A0
00000F58  41F9 00001462           2319mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000F5E  E99C                    2320mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F60  1C04                    2321mm     MOVE.B D4,D6
00000F62  0286 0000000F           2322mm     ANDI.L #$F,D6
00000F68  1C30 6000               2323mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000F6C                          2324mm     ENDM
00000F6C                          2325mm     PRINT_CHAR D6,D3
00000F6C                          2326mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6C                 TRUE     2327mm     IFEQ DEBUG
00000F6C  1639 00C00003           2328mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F72  0803 0002               2329mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F76  67F4                    2330mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F78  13C6 00C00007           2331mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000F7E                          2332mm     ENDC
00000F7E                          2333mm     
00000F7E                 FALSE    2334mm     IFNE DEBUG
00000F7E                          2335mm     ENDC
00000F7E                          2336mm 
00000F7E                          2337mm     ENDM
00000F7E  57CF FFD8               2338m     DBEQ D7,LOOP_167
00000F82                          2339m     ENDM
00000F82                          2340m         PRINT_CRLF D3
00000F82                          2341mm     PRINT_CHAR #13,D3                           ; CR
00000F82                          2342mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F82                 TRUE     2343mm     IFEQ DEBUG
00000F82  1639 00C00003           2344mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F88  0803 0002               2345mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F8C  67F4                    2346mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F8E  13FC 000D 00C00007      2347mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000F96                          2348mm     ENDC
00000F96                          2349mm     
00000F96                 FALSE    2350mm     IFNE DEBUG
00000F96                          2351mm     ENDC
00000F96                          2352mm 
00000F96                          2353mm     ENDM
00000F96                          2354mm     PRINT_CHAR #10,D3                           ; LF
00000F96                          2355mm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F96                 TRUE     2356mm     IFEQ DEBUG
00000F96  1639 00C00003           2357mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F9C  0803 0002               2358mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000FA0  67F4                    2359mm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000FA2  13FC 000A 00C00007      2360mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000FAA                          2361mm     ENDC
00000FAA                          2362mm     
00000FAA                 FALSE    2363mm     IFNE DEBUG
00000FAA                          2364mm     ENDC
00000FAA                          2365mm 
00000FAA                          2366mm     ENDM
00000FAA                          2367m     ENDM
00000FAA  4EF8 0186               2368          JMP MAIN_LOOP
00000FAE                          2369      ENDI
00000FAE                          2370s _00000008
00000FAE                          2371      
00000FAE  4ED1                    2372      JMP (A1)
00000FB0                          2373  DOWNLOAD_DONE
00000FB0                          2374m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00000FB0                          2375mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000FB0                          2376mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB0                 TRUE     2377mm     IFEQ DEBUG
00000FB0  1639 00C00003           2378mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000FB6  0803 0002               2379mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000FBA  67F4                    2380mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000FBC  13FC 0030 00C00007      2381mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000FC4                          2382mm     ENDC
00000FC4                          2383mm     
00000FC4                 FALSE    2384mm     IFNE DEBUG
00000FC4                          2385mm     ENDC
00000FC4                          2386mm 
00000FC4                          2387mm     ENDM
00000FC4                          2388mm     PRINT_CHAR #'x',D3
00000FC4                          2389mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC4                 TRUE     2390mm     IFEQ DEBUG
00000FC4  1639 00C00003           2391mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000FCA  0803 0002               2392mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000FCE  67F4                    2393mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00000FD0  13FC 0078 00C00007      2394mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000FD8                          2395mm     ENDC
00000FD8                          2396mm     
00000FD8                 FALSE    2397mm     IFNE DEBUG
00000FD8                          2398mm     ENDC
00000FD8                          2399mm 
00000FD8                          2400mm     ENDM
00000FD8  7C07                    2401m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FDA                          2402m LOOP_175
00000FDA                          2403mm     BIN2HEX D4,D7,A0
00000FDA  41F9 00001462           2404mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000FE0  E99C                    2405mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FE2  1E04                    2406mm     MOVE.B D4,D7
00000FE4  0287 0000000F           2407mm     ANDI.L #$F,D7
00000FEA  1E30 7000               2408mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000FEE                          2409mm     ENDM
00000FEE                          2410mm     PRINT_CHAR D7,D3
00000FEE                          2411mm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FEE                 TRUE     2412mm     IFEQ DEBUG
00000FEE  1639 00C00003           2413mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000FF4  0803 0002               2414mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000FF8  67F4                    2415mm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000FFA  13C7 00C00007           2416mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00001000                          2417mm     ENDC
00001000                          2418mm     
00001000                 FALSE    2419mm     IFNE DEBUG
00001000                          2420mm     ENDC
00001000                          2421mm 
00001000                          2422mm     ENDM
00001000  57CE FFD8               2423m     DBEQ D6,LOOP_175
00001004                          2424m     ENDM
00001004  41F9 00001405           2425      LEA READ,A0
0000100A                          2426m     PRINT_STR A0,D3
0000100A                          2427m LOOP_180
0000100A  0C10 0000               2428m     CMP.B #0,(A0)                               ; 0 -> DONE
0000100E  6700 0018               2429m     BEQ EXIT_180
00001012                          2430mm     PRINT_CHAR (A0)+,D3
00001012                          2431mm WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001012                 TRUE     2432mm     IFEQ DEBUG
00001012  1639 00C00003           2433mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001018  0803 0002               2434mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000101C  67F4                    2435mm         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
0000101E  13D8 00C00007           2436mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00001024                          2437mm     ENDC
00001024                          2438mm     
00001024                 FALSE    2439mm     IFNE DEBUG
00001024                          2440mm     ENDC
00001024                          2441mm 
00001024                          2442mm     ENDM
00001024  4EF8 100A               2443m     JMP LOOP_180
00001028                          2444m EXIT_180
00001028                          2445m     ENDM
00001028  2E0A                    2446      MOVE.L A2,D7                                ; set address accumulator to start address
0000102A                          2447m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
0000102A                          2448mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0000102A                          2449mm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102A                 TRUE     2450mm     IFEQ DEBUG
0000102A  1639 00C00003           2451mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001030  0803 0002               2452mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001034  67F4                    2453mm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00001036  13FC 0030 00C00007      2454mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000103E                          2455mm     ENDC
0000103E                          2456mm     
0000103E                 FALSE    2457mm     IFNE DEBUG
0000103E                          2458mm     ENDC
0000103E                          2459mm 
0000103E                          2460mm     ENDM
0000103E                          2461mm     PRINT_CHAR #'x',D3
0000103E                          2462mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103E                 TRUE     2463mm     IFEQ DEBUG
0000103E  1639 00C00003           2464mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001044  0803 0002               2465mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001048  67F4                    2466mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
0000104A  13FC 0078 00C00007      2467mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00001052                          2468mm     ENDC
00001052                          2469mm     
00001052                 FALSE    2470mm     IFNE DEBUG
00001052                          2471mm     ENDC
00001052                          2472mm 
00001052                          2473mm     ENDM
00001052  7C07                    2474m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001054                          2475m LOOP_182
00001054                          2476mm     BIN2HEX D7,D2,A0
00001054  41F9 00001462           2477mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000105A  E99F                    2478mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000105C  1407                    2479mm     MOVE.B D7,D2
0000105E  0282 0000000F           2480mm     ANDI.L #$F,D2
00001064  1430 2000               2481mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00001068                          2482mm     ENDM
00001068                          2483mm     PRINT_CHAR D2,D3
00001068                          2484mm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001068                 TRUE     2485mm     IFEQ DEBUG
00001068  1639 00C00003           2486mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000106E  0803 0002               2487mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001072  67F4                    2488mm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00001074  13C2 00C00007           2489mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000107A                          2490mm     ENDC
0000107A                          2491mm     
0000107A                 FALSE    2492mm     IFNE DEBUG
0000107A                          2493mm     ENDC
0000107A                          2494mm 
0000107A                          2495mm     ENDM
0000107A  57CE FFD8               2496m     DBEQ D6,LOOP_182
0000107E                          2497m     ENDM
0000107E                          2498m     PRINT_CRLF D3     
0000107E                          2499mm     PRINT_CHAR #13,D3                           ; CR
0000107E                          2500mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000107E                 TRUE     2501mm     IFEQ DEBUG
0000107E  1639 00C00003           2502mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001084  0803 0002               2503mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001088  67F4                    2504mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
0000108A  13FC 000D 00C00007      2505mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00001092                          2506mm     ENDC
00001092                          2507mm     
00001092                 FALSE    2508mm     IFNE DEBUG
00001092                          2509mm     ENDC
00001092                          2510mm 
00001092                          2511mm     ENDM
00001092                          2512mm     PRINT_CHAR #10,D3                           ; LF
00001092                          2513mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001092                 TRUE     2514mm     IFEQ DEBUG
00001092  1639 00C00003           2515mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001098  0803 0002               2516mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000109C  67F4                    2517mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
0000109E  13FC 000A 00C00007      2518mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000010A6                          2519mm     ENDC
000010A6                          2520mm     
000010A6                 FALSE    2521mm     IFNE DEBUG
000010A6                          2522mm     ENDC
000010A6                          2523mm 
000010A6                          2524mm     ENDM
000010A6                          2525m     ENDM
000010A6                          2526          
000010A6  4EF8 0186               2527      JMP MAIN_LOOP
000010AA                          2528      
000010AA                          2529  G
000010AA  2047                    2530      MOVE.L D7,A0                                ; address accumulator -> address register
000010AC  3E3C 0000               2531      MOVE #0,D7                                  ; clear the now used address accumulator
000010B0  4ED0                    2532      JMP (A0)                                    ; jump to it!
000010B2                          2533      
000010B2                          2534  Z
000010B2  207C 00200000           2535      MOVE.L #RAM,A0                              ; address of RAM
000010B8  7000                    2536      MOVE.L #0,D0                                ; number of bytes
000010BA                          2537     
000010BA                          2538      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
000010BA                          2539s _10000004
000010BA  B0BC 00040000           2540s     CMP.L   #$40000,D0
000010C0  6E00 001A               2541s     BGT _10000005
000010C4                          2542         
000010C4  2200                    2543          MOVE.L D0,D1                            ; progress update
000010C6  E089                    2544          LSR.L #8,D1 
000010C8  E089                    2545          LSR.L #8,D1
000010CA  0281 0000000F           2546          ANDI.L #$F,D1
000010D0  13C1 00E00001           2547          MOVE.B D1,DISPLAY
000010D6                          2548  
000010D6  20C0                    2549          MOVE.L D0,(A0)+ 
000010D8  5880                    2550          ADD.L #4,D0
000010DA                          2551      ENDW
000010DA  60DE                    2552s     BRA _10000004
000010DC                          2553s _10000005
000010DC                          2554   
000010DC  207C 00200000           2555      MOVE.L #RAM,A0                              ; address of RAM
000010E2  7000                    2556      MOVE.L #0,D0                                ; number of bytes
000010E4                          2557     
000010E4                          2558      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
000010E4                          2559s _10000006
000010E4  B0BC 00040000           2560s     CMP.L   #$40000,D0
000010EA  6E00 00CA               2561s     BGT _10000007
000010EE                          2562  
000010EE  2200                    2563          MOVE.L D0,D1                            ; progress update
000010F0  E089                    2564          LSR.L #8,D1
000010F2  E089                    2565          LSR.L #8,D1
000010F4  0281 0000000F           2566          ANDI.L #$F,D1
000010FA  13C1 00E00001           2567          MOVE.B D1,DISPLAY
00001100                          2568  
00001100  2218                    2569          MOVE.L (A0)+,D1
00001102                          2570            
00001102                          2571          IF.L D0 <EQ> D1 THEN
00001102  B081                    2572s     CMP.L   D1,D0
00001104  6600 0006               2573s     BNE _00000009
00001108  6000 00A6               2574              BRA OK
0000110C                          2575          ENDI 
0000110C                          2576s _00000009
0000110C                          2577            
0000110C  43F9 00001450           2578          LEA RAM_ERROR,A1
00001112                          2579m         PRINT_STR A1,D1
00001112                          2580m LOOP_190
00001112  0C11 0000               2581m     CMP.B #0,(A1)                               ; 0 -> DONE
00001116  6700 0018               2582m     BEQ EXIT_190
0000111A                          2583mm     PRINT_CHAR (A1)+,D1
0000111A                          2584mm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000111A                 TRUE     2585mm     IFEQ DEBUG
0000111A  1239 00C00003           2586mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00001120  0801 0002               2587mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00001124  67F4                    2588mm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
00001126  13D9 00C00007           2589mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000112C                          2590mm     ENDC
0000112C                          2591mm     
0000112C                 FALSE    2592mm     IFNE DEBUG
0000112C                          2593mm     ENDC
0000112C                          2594mm 
0000112C                          2595mm     ENDM
0000112C  4EF8 1112               2596m     JMP LOOP_190
00001130                          2597m EXIT_190
00001130                          2598m     ENDM
00001130  2208                    2599          MOVE.L A0,D1
00001132  5981                    2600          SUB.L #4,D1
00001134                          2601m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00001134                          2602mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00001134                          2603mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     2604mm     IFEQ DEBUG
00001134  1639 00C00003           2605mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000113A  0803 0002               2606mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000113E  67F4                    2607mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00001140  13FC 0030 00C00007      2608mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00001148                          2609mm     ENDC
00001148                          2610mm     
00001148                 FALSE    2611mm     IFNE DEBUG
00001148                          2612mm     ENDC
00001148                          2613mm 
00001148                          2614mm     ENDM
00001148                          2615mm     PRINT_CHAR #'x',D3
00001148                          2616mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001148                 TRUE     2617mm     IFEQ DEBUG
00001148  1639 00C00003           2618mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000114E  0803 0002               2619mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001152  67F4                    2620mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00001154  13FC 0078 00C00007      2621mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000115C                          2622mm     ENDC
0000115C                          2623mm     
0000115C                 FALSE    2624mm     IFNE DEBUG
0000115C                          2625mm     ENDC
0000115C                          2626mm 
0000115C                          2627mm     ENDM
0000115C  7C07                    2628m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000115E                          2629m LOOP_192
0000115E                          2630mm     BIN2HEX D1,D2,A1
0000115E  43F9 00001462           2631mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00001164  E999                    2632mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001166  1401                    2633mm     MOVE.B D1,D2
00001168  0282 0000000F           2634mm     ANDI.L #$F,D2
0000116E  1431 2000               2635mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00001172                          2636mm     ENDM
00001172                          2637mm     PRINT_CHAR D2,D3
00001172                          2638mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001172                 TRUE     2639mm     IFEQ DEBUG
00001172  1639 00C00003           2640mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001178  0803 0002               2641mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000117C  67F4                    2642mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
0000117E  13C2 00C00007           2643mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00001184                          2644mm     ENDC
00001184                          2645mm     
00001184                 FALSE    2646mm     IFNE DEBUG
00001184                          2647mm     ENDC
00001184                          2648mm 
00001184                          2649mm     ENDM
00001184  57CE FFD8               2650m     DBEQ D6,LOOP_192
00001188                          2651m     ENDM
00001188                          2652m         PRINT_CRLF D3
00001188                          2653mm     PRINT_CHAR #13,D3                           ; CR
00001188                          2654mm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001188                 TRUE     2655mm     IFEQ DEBUG
00001188  1639 00C00003           2656mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000118E  0803 0002               2657mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001192  67F4                    2658mm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00001194  13FC 000D 00C00007      2659mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000119C                          2660mm     ENDC
0000119C                          2661mm     
0000119C                 FALSE    2662mm     IFNE DEBUG
0000119C                          2663mm     ENDC
0000119C                          2664mm 
0000119C                          2665mm     ENDM
0000119C                          2666mm     PRINT_CHAR #10,D3                           ; LF
0000119C                          2667mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000119C                 TRUE     2668mm     IFEQ DEBUG
0000119C  1639 00C00003           2669mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000011A2  0803 0002               2670mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000011A6  67F4                    2671mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
000011A8  13FC 000A 00C00007      2672mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000011B0                          2673mm     ENDC
000011B0                          2674mm     
000011B0                 FALSE    2675mm     IFNE DEBUG
000011B0                          2676mm     ENDC
000011B0                          2677mm 
000011B0                          2678mm     ENDM
000011B0                          2679m     ENDM
000011B0                          2680  OK    
000011B0  5880                    2681          ADD.L #4,D0
000011B2                          2682      ENDW
000011B2  6000 FF30               2683s     BRA _10000006
000011B6                          2684s _10000007
000011B6                          2685      
000011B6  4EF8 0186               2686      JMP MAIN_LOOP
000011BA                          2687    
000011BA                          2688  L
000011BA  7A00                    2689      MOVE.L #0,D5                                ; D5 will be the length  to write            
000011BC                          2690  
000011BC                          2691m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000011BC                          2692m WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011BC                          2693m 
000011BC                 TRUE     2694m     IFEQ DEBUG
000011BC  1639 00C00003           2695m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000011C2  0803 0000               2696m         BTST #0,D3                              ; CHECK FOR CHARACTER
000011C6  67F4                    2697m         BEQ WAIT_FOR_READY_200                      ; NOTHING, CHECK AGAIN
000011C8                          2698m     ENDC
000011C8                          2699m     
000011C8                          2700mm     READ_CHAR D2
000011C8                 TRUE     2701mm     IFEQ DEBUG
000011C8  1439 00C00007           2702mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000011CE                          2703mm     ENDC
000011CE                 FALSE    2704mm     IFNE DEBUG
000011CE                          2705mm     ENDC
000011CE                          2706mm      
000011CE  B43C 001B               2707mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000011D2  6700 EE34               2708mm     BEQ START
000011D6                          2709mm     ENDM
000011D6                          2710m 
000011D6                 TRUE     2711m     IFEQ DEBUG
000011D6                          2712mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000011D6                          2713mm WAIT_FOR_READY_202                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011D6                 TRUE     2714mm     IFEQ DEBUG
000011D6  1639 00C00003           2715mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000011DC  0803 0002               2716mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000011E0  67F4                    2717mm         BEQ WAIT_FOR_READY_202                      ; NO SPACE, CHECK AGAIN
000011E2  13C2 00C00007           2718mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000011E8                          2719mm     ENDC
000011E8                          2720mm     
000011E8                 FALSE    2721mm     IFNE DEBUG
000011E8                          2722mm     ENDC
000011E8                          2723mm 
000011E8                          2724mm     ENDM
000011E8                          2725m     ENDC
000011E8                          2726m     ENDM
000011E8                          2727m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000011E8  41F9 00001472           2728m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000011EE  0402 0030               2729m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000011F2  C4BC 000000FF           2730m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000011F8  1430 2000               2731m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000011FC                          2732m     ENDM
000011FC  1A02                    2733      MOVE.B D2,D5                                ; put at bottom of D5
000011FE                          2734  
000011FE  3C3C 0002               2735      MOVE #2,D6                                  ; 3 bytes left to read
00001202                          2736      
00001202                          2737  READ_LENGTH
00001202  E98D                    2738      LSL.L #4,D5                                 ; make what we have so far more significant
00001204                          2739m     WAIT_CHAR D2,D3                             ; next character -> D2
00001204                          2740m WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001204                          2741m 
00001204                 TRUE     2742m     IFEQ DEBUG
00001204  1639 00C00003           2743m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000120A  0803 0000               2744m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000120E  67F4                    2745m         BEQ WAIT_FOR_READY_204                      ; NOTHING, CHECK AGAIN
00001210                          2746m     ENDC
00001210                          2747m     
00001210                          2748mm     READ_CHAR D2
00001210                 TRUE     2749mm     IFEQ DEBUG
00001210  1439 00C00007           2750mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00001216                          2751mm     ENDC
00001216                 FALSE    2752mm     IFNE DEBUG
00001216                          2753mm     ENDC
00001216                          2754mm      
00001216  B43C 001B               2755mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000121A  6700 EDEC               2756mm     BEQ START
0000121E                          2757mm     ENDM
0000121E                          2758m 
0000121E                 TRUE     2759m     IFEQ DEBUG
0000121E                          2760mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000121E                          2761mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     2762mm     IFEQ DEBUG
0000121E  1639 00C00003           2763mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001224  0803 0002               2764mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001228  67F4                    2765mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
0000122A  13C2 00C00007           2766mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00001230                          2767mm     ENDC
00001230                          2768mm     
00001230                 FALSE    2769mm     IFNE DEBUG
00001230                          2770mm     ENDC
00001230                          2771mm 
00001230                          2772mm     ENDM
00001230                          2773m     ENDC
00001230                          2774m     ENDM
00001230                          2775m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001230  41F9 00001472           2776m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00001236  0402 0030               2777m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000123A  C4BC 000000FF           2778m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00001240  1430 2000               2779m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00001244                          2780m     ENDM
00001244  8A02                    2781      OR.B D2,D5
00001246  023C 00FB               2782      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
0000124A  57CE FFB6               2783      DBEQ D6,READ_LENGTH
0000124E                          2784          
0000124E                          2785m     PRINT_CRLF D3
0000124E                          2786mm     PRINT_CHAR #13,D3                           ; CR
0000124E                          2787mm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000124E                 TRUE     2788mm     IFEQ DEBUG
0000124E  1639 00C00003           2789mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001254  0803 0002               2790mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00001258  67F4                    2791mm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
0000125A  13FC 000D 00C00007      2792mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00001262                          2793mm     ENDC
00001262                          2794mm     
00001262                 FALSE    2795mm     IFNE DEBUG
00001262                          2796mm     ENDC
00001262                          2797mm 
00001262                          2798mm     ENDM
00001262                          2799mm     PRINT_CHAR #10,D3                           ; LF
00001262                          2800mm WAIT_FOR_READY_210                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001262                 TRUE     2801mm     IFEQ DEBUG
00001262  1639 00C00003           2802mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00001268  0803 0002               2803mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000126C  67F4                    2804mm         BEQ WAIT_FOR_READY_210                      ; NO SPACE, CHECK AGAIN
0000126E  13FC 000A 00C00007      2805mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00001276                          2806mm     ENDC
00001276                          2807mm     
00001276                 FALSE    2808mm     IFNE DEBUG
00001276                          2809mm     ENDC
00001276                          2810mm 
00001276                          2811mm     ENDM
00001276                          2812m     ENDM
00001276                          2813  
00001276  207C 00000000           2814      MOVE.L #ROM,A0                              ; start of ROM
0000127C                          2815      
0000127C  2247                    2816      MOVE.L D7,A1                                ; address accumulator -> address register
0000127E  7E00                    2817      MOVE.L #0,D7                                ; clear the now used address accumulator
00001280                          2818      
00001280  267C 00002AAA           2819      MOVE.L #$2AAA,A3
00001286  36BC AAAA               2820      MOVE.W #$AAAA,(A3)
0000128A  267C 00001554           2821      MOVE.L #$1554,A3
00001290  36BC 5555               2822      MOVE.W #$5555,(A3)
00001294  267C 00002AAA           2823      MOVE.L #$2AAA,A3
0000129A  36BC 8080               2824      MOVE.W #$8080,(A3)
0000129E  267C 00002AAA           2825      MOVE.L #$2AAA,A3
000012A4  36BC AAAA               2826      MOVE.W #$AAAA,(A3)
000012A8  267C 00001554           2827      MOVE.L #$1554,A3
000012AE  36BC 5555               2828      MOVE.W #$5555,(A3)
000012B2  267C 00002AAA           2829      MOVE.L #$2AAA,A3
000012B8  36BC 2020               2830      MOVE.W #$2020,(A3)
000012BC                          2831      
000012BC  45F9 00001489           2832      LEA LOADING,A2                              ; important for timing
000012C2                          2833m     PRINT_STR A2,D3
000012C2                          2834m LOOP_211
000012C2  0C12 0000               2835m     CMP.B #0,(A2)                               ; 0 -> DONE
000012C6  6700 0018               2836m     BEQ EXIT_211
000012CA                          2837mm     PRINT_CHAR (A2)+,D3
000012CA                          2838mm WAIT_FOR_READY_212                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012CA                 TRUE     2839mm     IFEQ DEBUG
000012CA  1639 00C00003           2840mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000012D0  0803 0002               2841mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000012D4  67F4                    2842mm         BEQ WAIT_FOR_READY_212                      ; NO SPACE, CHECK AGAIN
000012D6  13DA 00C00007           2843mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000012DC                          2844mm     ENDC
000012DC                          2845mm     
000012DC                 FALSE    2846mm     IFNE DEBUG
000012DC                          2847mm     ENDC
000012DC                          2848mm 
000012DC                          2849mm     ENDM
000012DC  4EF8 12C2               2850m     JMP LOOP_211
000012E0                          2851m EXIT_211
000012E0                          2852m     ENDM
000012E0                          2853  
000012E0  023C 00FB               2854      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
000012E4                          2855      
000012E4                          2856      WHILE D5 <GT> #0 DO
000012E4                          2857s _10000008
000012E4  BA7C 0000               2858s     CMP.W   #0,D5
000012E8  6F00 001E               2859s     BLE _10000009
000012EC  5585                    2860          SUB.L #2,D5
000012EE                          2861            
000012EE  13D1 00E00001           2862          MOVE.B (A1),DISPLAY
000012F4  3091                    2863          MOVE.W (A1),(A0)                        ; write the data
000012F6                          2864        
000012F6                          2865  WAIT_FOR_COMPLETE
000012F6  3410                    2866          MOVE.W (A0),D2
000012F8                          2867  
000012F8                          2868          IF D2 <NE> (A1) THEN
000012F8  B451                    2869s     CMP.W   (A1),D2
000012FA  6700 0006               2870s     BEQ _0000000A
000012FE  4EF8 12F6               2871              JMP WAIT_FOR_COMPLETE
00001302                          2872          ENDI
00001302                          2873s _0000000A
00001302                          2874        
00001302  5488                    2875          ADD.L #2,A0
00001304  5489                    2876          ADD.L #2,A1
00001306                          2877      ENDW  
00001306  60DC                    2878s     BRA _10000008
00001308                          2879s _10000009
00001308                          2880      
00001308  267C 00002AAA           2881      MOVE.L #$2AAA,A3
0000130E  36BC AAAA               2882      MOVE.W #$AAAA,(A3)
00001312  267C 00001554           2883      MOVE.L #$1554,A3
00001318  36BC 5555               2884      MOVE.W #$5555,(A3)
0000131C  267C 00002AAA           2885      MOVE.L #$2AAA,A3
00001322  36BC A0A0               2886      MOVE.W #$A0A0,(A3)
00001326                          2887              
00001326  4EF8 0186               2888      JMP MAIN_LOOP
0000132A                          2889          
0000132A                          2890  HEX_DIGIT
0000132A  E98F                    2891      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
0000132C                          2892m     HEX2BIN D2,D2,A0
0000132C  41F9 00001472           2893m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00001332  0402 0030               2894m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001336  C4BC 000000FF           2895m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000133C  1430 2000               2896m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00001340                          2897m     ENDM
00001340  8E02                    2898      OR.B D2,D7  
00001342  4EF8 01AE               2899      JMP GET_INPUT
00001346                          2900  
00001346  FFFF FFFF               2901      SIMHALT                                     ; halt simulator
0000134A                          2902  
0000134A                          2903  ; strings
0000134A= 4D 44 46 2D 6D 6F ...   2904  VERSION DC.B 'MDF-mon V1.41 (09/04/2021)',13,10,0
00001367= 3F 20 48 65 6C 70 ...   2905  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
000013FE= 48 75 68 3F 0D 0A 00    2906  HUH     DC.B 'Huh?',13,10,0
00001405= 20 53 20 72 65 63 ...   2907  READ    DC.B ' S records read, start address = ',0
00001427= 57 3A 20 55 6E 6B ...   2908  UNREC   DC.B 'W: Unknown Srec type: ',0
0000143E= 57 3A 20 43 53 20 ...   2909  CS_FAILURE   DC.B 'W: CS failure at ',0
00001450= 57 3A 20 52 41 4D ...   2910  RAM_ERROR DC.B 'W: RAM error at: ',0
00001462= 30 31 32 33 34 35 ...   2911  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001472= 00 01 02 03 04 05 ...   2912  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001489= 4C 6F 61 64 69 6E ...   2913  LOADING  DC.B 'Loading EEPROM...',13,11,0
0000149D                          2914      
0000149D                          2915      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1462
CONTINUE_101        99E
CONTINUE_106        A02
CONTINUE_110        A60
CONTINUE_115        AD4
CONTINUE_119        B32
CONTINUE_127        BD2
CONTINUE_131        C30
CONTINUE_136        C90
CONTINUE_140        CEE
CONTINUE_145        D52
CONTINUE_149        DB0
CONTINUE_159        E8A
CONTINUE_162        ED6
CONTINUE_44         4AA
CONTINUE_46         4E6
CONTINUE_49         51E
CONTINUE_53         57C
CONTINUE_58         5F4
CONTINUE_62         652
CONTINUE_67         6B2
CONTINUE_71         710
CONTINUE_76         784
CONTINUE_80         7E2
CONTINUE_88         882
CONTINUE_92         8E0
CONTINUE_97         940
CS_FAILURE          143E
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       BC9
DOWNLOAD_DONE       FB0
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_153            E26
EXIT_165            F2E
EXIT_180            1028
EXIT_19             2E6
EXIT_190            1130
EXIT_21             30E
EXIT_211            12E0
EXIT_23             336
EXIT_5              140
G                   10AA
GET_INPUT           1AE
H                   2EA
HELP                1367
HEX2BIN             134
HEX2BIN_LUT         1472
HEX_DIGIT           132A
HUH                 13FE
L                   11BA
LOADING             1489
LOOP_153            E08
LOOP_165            F10
LOOP_167            F58
LOOP_175            FDA
LOOP_180            100A
LOOP_182            1054
LOOP_19             2C8
LOOP_190            1112
LOOP_192            115E
LOOP_21             2F0
LOOP_211            12C2
LOOP_23             318
LOOP_25             368
LOOP_5              122
MAIN_LOOP           186
OK                  11B0
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   33A
RAM                 200000
RAM_ERROR           1450
READ                1405
READ_CHAR           805
READ_DATA_TO_POKE   408
READ_LENGTH         1202
RESET               4
ROM                 0
S                   486
STACK               0
START               8
UNREC               1427
V                   312
VERSION             134A
W                   3C0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   12F6
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_101  982
WAIT_FOR_READY_103  9B6
WAIT_FOR_READY_106  9E6
WAIT_FOR_READY_108  A1A
WAIT_FOR_READY_11   186
WAIT_FOR_READY_110  A44
WAIT_FOR_READY_112  A78
WAIT_FOR_READY_115  AB8
WAIT_FOR_READY_117  AEC
WAIT_FOR_READY_119  B16
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_121  B4A
WAIT_FOR_READY_124  B7C
WAIT_FOR_READY_125  B90
WAIT_FOR_READY_127  BB6
WAIT_FOR_READY_129  BEA
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_131  C14
WAIT_FOR_READY_133  C48
WAIT_FOR_READY_136  C74
WAIT_FOR_READY_138  CA8
WAIT_FOR_READY_140  CD2
WAIT_FOR_READY_142  D06
WAIT_FOR_READY_145  D36
WAIT_FOR_READY_147  D6A
WAIT_FOR_READY_149  D94
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  DC8
WAIT_FOR_READY_154  E10
WAIT_FOR_READY_155  E26
WAIT_FOR_READY_157  E38
WAIT_FOR_READY_158  E4C
WAIT_FOR_READY_159  E6E
WAIT_FOR_READY_162  EBA
WAIT_FOR_READY_166  F18
WAIT_FOR_READY_168  F2E
WAIT_FOR_READY_169  F42
WAIT_FOR_READY_17   26A
WAIT_FOR_READY_171  F6C
WAIT_FOR_READY_173  F82
WAIT_FOR_READY_174  F96
WAIT_FOR_READY_176  FB0
WAIT_FOR_READY_177  FC4
WAIT_FOR_READY_179  FEE
WAIT_FOR_READY_18   27E
WAIT_FOR_READY_181  1012
WAIT_FOR_READY_183  102A
WAIT_FOR_READY_184  103E
WAIT_FOR_READY_186  1068
WAIT_FOR_READY_188  107E
WAIT_FOR_READY_189  1092
WAIT_FOR_READY_191  111A
WAIT_FOR_READY_193  1134
WAIT_FOR_READY_194  1148
WAIT_FOR_READY_196  1172
WAIT_FOR_READY_198  1188
WAIT_FOR_READY_199  119C
WAIT_FOR_READY_20   2D0
WAIT_FOR_READY_200  11BC
WAIT_FOR_READY_202  11D6
WAIT_FOR_READY_204  1204
WAIT_FOR_READY_206  121E
WAIT_FOR_READY_209  124E
WAIT_FOR_READY_210  1262
WAIT_FOR_READY_212  12CA
WAIT_FOR_READY_22   2F8
WAIT_FOR_READY_24   320
WAIT_FOR_READY_26   33E
WAIT_FOR_READY_27   352
WAIT_FOR_READY_29   37C
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   392
WAIT_FOR_READY_32   3A6
WAIT_FOR_READY_33   3C2
WAIT_FOR_READY_35   3DC
WAIT_FOR_READY_37   40A
WAIT_FOR_READY_39   424
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   45A
WAIT_FOR_READY_43   46E
WAIT_FOR_READY_44   48E
WAIT_FOR_READY_46   4CA
WAIT_FOR_READY_49   502
WAIT_FOR_READY_51   536
WAIT_FOR_READY_53   560
WAIT_FOR_READY_55   594
WAIT_FOR_READY_58   5D8
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_60   60C
WAIT_FOR_READY_62   636
WAIT_FOR_READY_64   66A
WAIT_FOR_READY_67   696
WAIT_FOR_READY_69   6CA
WAIT_FOR_READY_71   6F4
WAIT_FOR_READY_73   728
WAIT_FOR_READY_76   768
WAIT_FOR_READY_78   79C
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   7C6
WAIT_FOR_READY_82   7FA
WAIT_FOR_READY_85   82C
WAIT_FOR_READY_86   840
WAIT_FOR_READY_88   866
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   89A
WAIT_FOR_READY_92   8C4
WAIT_FOR_READY_94   8F8
WAIT_FOR_READY_97   924
WAIT_FOR_READY_99   958
WAIT_FOR_SRECORD    48E
Z                   10B2
_00000000           5CE
_00000001           E64
_00000002           85C
_00000003           E64
_00000004           BAC
_00000005           E64
_00000006           E02
_00000007           E64
_00000008           FAE
_00000009           110C
_0000000A           1302
_10000000           75C
_10000001           82C
_10000002           AAC
_10000003           B7C
_10000004           10BA
_10000005           10DC
_10000006           10E4
_10000007           11B6
_10000008           12E4
_10000009           1308
