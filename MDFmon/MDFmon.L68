00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 15:39:32

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  
00000000                            12  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            16  ; fix being able to enter random chars when W'ing
00000000                            17  ; ram check at startup?  Not sure if this is a good idea!
00000000                            18  
00000000                            19      ;ORG  $0
00200000                            20      ORG  $200000
00200000                            21  
00200000  =00000000                 22  DEBUG               EQU 0
00200000                            23  
00200000                            24  ; constants
00200000  =00000000                 25  ROM                 EQU $0
00200000  =00200000                 26  RAM                 EQU $200000
00200000                            27     
00200000  =00C00000                 28  DUART_BASE          EQU $C00000
00200000  =00000000                 29  DUART_MRA_          EQU $0
00200000  =00000001                 30  DUART_CSRA_         EQU $1
00200000  =00000001                 31  DUART_SRA_          EQU $1
00200000  =00000002                 32  DUART_CRA_          EQU $2
00200000  =00000003                 33  DUART_TXA_          EQU $3
00200000  =00000003                 34  DUART_RXA_          EQU $3
00200000  =00000004                 35  DUART_ACR_          EQU $4
00200000  =00000005                 36  DUART_IMR_          EQU $5
00200000  =00000008                 37  DUART_MRB_          EQU $8
00200000  =00000009                 38  DUART_CSRB_         EQU $9
00200000  =00000009                 39  DUART_SRB_          EQU $9
00200000  =0000000A                 40  DUART_CRB_          EQU $A
00200000  =0000000B                 41  DUART_TXB_          EQU $B
00200000  =0000000B                 42  DUART_RXB_          EQU $B
00200000  =0000000C                 43  DUART_IVR_          EQU $C
00200000  =0000000D                 44  DUART_OPCR_         EQU $D
00200000  =0000000E                 45  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 46  DUART_RESET_OPR_    EQU $F
00200000                            47  
00200000  =00C00001                 48  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 49  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 50  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 51  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 52  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 53  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            54  
00200000  =00C00011                 55  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 56  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 57  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 58  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 59  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 60  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            61  
00200000  =00C00009                 62  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 63  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 64  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 65  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 66  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 67  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            68  
00200000  =00E00000                 69  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 70  DISPLAY_            EQU $0
00200000  =00E00001                 71  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            72  
00200000                            73  ; macros
00200000                            74  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            75  ; the input register is changed during the process
00200000                            76  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            77  BIN2HEX MACRO
00200000                            78      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            79      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            80      MOVE.B \1,\2
00200000                            81      ANDI.L #$F,\2
00200000                            82      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            83      ENDM
00200000                            84  
00200000                            85  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            86  ; the input register is changed during the process
00200000                            87  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            88  HEX2BIN MACRO
00200000                            89      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00200000                            90      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00200000                            91      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00200000                            92      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00200000                            93      ENDM
00200000                            94  
00200000                            95  ; send a single char to the serial port
00200000                            96  ; \1 = char to send, \2 = data register to use for status poll
00200000                            97  ; will stamp on D0 and D1 in debug mode
00200000                            98  PRINT_CHAR MACRO
00200000                            99  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           100      IFEQ DEBUG
00200000                           101          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           102          BTST #2,\2                              ; check for space to send
00200000                           103          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           104          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           105      ENDC
00200000                           106      
00200000                           107      IFNE DEBUG
00200000                           108          MOVE.B \1,D1
00200000                           109          MOVE.L #6,D0   
00200000                           110          TRAP #15                                ; write to terminal in simulator
00200000                           111      ENDC
00200000                           112  
00200000                           113      ENDM
00200000                           114  
00200000                           115  ; send CR,LF to the serial port
00200000                           116  ; \1 = data register to use for status poll
00200000                           117  PRINT_CRLF MACRO
00200000                           118      PRINT_CHAR #13,\1                           ; CR
00200000                           119      PRINT_CHAR #10,\1                           ; LF
00200000                           120      ENDM
00200000                           121  
00200000                           122  ; send C-style, zero terminated string to the serial port
00200000                           123  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           124  PRINT_STR MACRO
00200000                           125  LOOP\@
00200000                           126      CMP.B #0,(\1)                               ; 0 -> done
00200000                           127      BEQ EXIT\@
00200000                           128      PRINT_CHAR (\1)+,\2
00200000                           129      BRA LOOP\@
00200000                           130  EXIT\@
00200000                           131      ENDM
00200000                           132    
00200000                           133  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           134  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00200000                           135  PRINT_REG MACRO
00200000                           136      PRINT_CHAR #'0',\2                              ;0x header
00200000                           137      PRINT_CHAR #'x',\2
00200000                           138      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00200000                           139  LOOP\@
00200000                           140      BIN2HEX \1,\3,\5
00200000                           141      PRINT_CHAR \3,\2
00200000                           142      DBEQ \4,LOOP\@
00200000                           143      ENDM
00200000                           144      
00200000                           145  ; wait for a char from the serial port
00200000                           146  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           147  ; will stamp on D0 and D1 in debug mode
00200000                           148  WAIT_CHAR MACRO
00200000                           149  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           150      IFEQ DEBUG
00200000                           151          MOVE.B DUART_SRA,\2                         ; read status register
00200000                           152          BTST #0,\2                              ; check for character
00200000                           153          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           154      ENDC
00200000                           155      
00200000                           156      READ_CHAR \1
00200000                           157  
00200000                           158      IFEQ DEBUG
00200000                           159          PRINT_CHAR \1,\2                            ; echo it back
00200000                           160      ENDC
00200000                           161      ENDM
00200000                           162      
00200000                           163  ; read a char from the serial port - assumes that there is one!
00200000                           164  ; \ 1= data register for read char
00200000                           165  ; will stamp on D0 and D1 in debug mode
00200000                           166  READ_CHAR MACRO
00200000                           167      IFEQ DEBUG
00200000                           168          MOVE.B DUART_RXA,\1                         ; got a character, read it
00200000                           169      ENDC
00200000                           170      IFNE DEBUG
00200000                           171          MOVE.L #5,D0    
00200000                           172          TRAP #15                                    ; read from keyboard in simulator
00200000                           173          MOVE.L D1,\1
00200000                           174      ENDC
00200000                           175       
00200000                           176      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           177      BEQ START
00200000                           178      ENDM
00200000                           179      
00200000                           180      
00200000                           181  ; read data from the download serial port
00200000                           182  ; \ 1= data register for read char
00200000                           183  DOWNLOAD MACRO
00200000                           184  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           185  
00200000                           186      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           187      BTST #0,\1                                  ; check for character
00200000                           188      BEQ CONTINUE\@                              ; nothing, continue
00200000                           189   
00200000                           190      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           191  CONTINUE\@
00200000                           192      MOVE.B DUART_SRB,\1                             ; read download status register
00200000                           193      BTST #0,\1                                      ; check for character
00200000                           194      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00200000                           195      
00200000                           196      MOVE.B DUART_RXB,\1                             ; got a character, read it
00200000                           197      MOVE.B \1,DISPLAY                               ; echo to the display
00200000                           198      
00200000                           199      ENDM
00200000                           200      
00200000                           201  ; read two hex digits from the download serial port and convert to a byte
00200000                           202  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           203  DOWNLOAD_BYTE MACRO
00200000                           204      MOVE.B #2,\4
00200000                           205      WHILE.B \4 <GT> 0 DO
00200000                           206          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00200000                           207          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00200000                           208          PRINT_CHAR \2,\3
00200000                           209          HEX2BIN \2,\2,\6
00200000                           210          OR.B \2,\1
00200000                           211          SUB.B #1,\4
00200000                           212      ENDW
00200000                           213      
00200000                           214      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00200000                           215      MOVE.B \1,\2
00200000                           216      ADD.L \1,\5
00200000                           217  
00200000                           218      ENDM
00200000                           219      
00200000                           220  
00200000                           221  ; register catalogue
00200000                           222  ; D0 - used for simulator I/O
00200000                           223  ; D1 - used for simulator I/O
00200000                           224  ; D2 - read character
00200000                           225  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           226  ; D6 - working register used in R/W
00200000                           227  ; D7 - address accumulator, reset by download
00200000                           228  ; A0 - address of string to print 
00200000                           229  
00200000                           230  ; start vector
00200000= 00000000                 231  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 232  RESET    DC.L START                             ; RESET
00200008                           233      
00200008                           234  ; start of program  
00200008                           235  START
00200008  13FC 0000 00E00001       236      MOVE.B #0,DISPLAY
00200010                           237  
00200010                           238  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       239      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00200018  13FC 0050 00C00005       240      MOVE.B #$50,DUART_CRA                           ; reset everyting
00200020  4E71                     241      NOP
00200022  13FC 0040 00C00005       242      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     243      NOP
0020002C  13FC 0030 00C00005       244      MOVE.B #$30,DUART_CRA
00200034  4E71                     245      NOP
00200036  13FC 0020 00C00005       246      MOVE.B #$20,DUART_CRA
0020003E  4E71                     247      NOP
00200040  13FC 0010 00C00005       248      MOVE.B #$10,DUART_CRA   
00200048                           249  
00200048  13FC 000A 00C00015       250      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00200050  13FC 0050 00C00015       251      MOVE.B #$50,DUART_CRB                           ; reset everyting
00200058  4E71                     252      NOP
0020005A  13FC 0040 00C00015       253      MOVE.B #$40,DUART_CRB           
00200062  4E71                     254      NOP
00200064  13FC 0030 00C00015       255      MOVE.B #$30,DUART_CRB
0020006C  4E71                     256      NOP
0020006E  13FC 0020 00C00015       257      MOVE.B #$20,DUART_CRB
00200076  4E71                     258      NOP
00200078  13FC 0010 00C00015       259      MOVE.B #$10,DUART_CRB   
00200080                           260  
00200080                           261  ;initialise UART
00200080  13FC 0000 00C00009       262      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       263      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00200090  13FC 0000 00C0001B       264      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00200098                           265  
00200098                           266  ; channel A
00200098  13FC 0013 00C00001       267      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       268      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
002000A8  13FC 00CC 00C00003       269      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
002000B0  13FC 0005 00C00005       270      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
002000B8                           271  
002000B8                           272  ; channel B
002000B8  13FC 0013 00C00011       273      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       274      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
002000C8  13FC 00CC 00C00013       275      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
002000D0  13FC 0005 00C00015       276      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
002000D8                           277  
002000D8                           278m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
002000D8                           279m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      280m     IFEQ DEBUG
002000D8  1639 00C00003            281m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                282m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     283m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       284m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           285m     ENDC
002000EC                           286m     
002000EC                 FALSE     287m     IFNE DEBUG
002000EC                           288m     ENDC
002000EC                           289m 
002000EC                           290m     ENDM
002000EC                           291  
002000EC  13FC 0001 00E00001       292      MOVE.B #1,DISPLAY
002000F4                           293         
002000F4                           294m     PRINT_CRLF D3
002000F4                           295mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           296mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      297mm     IFEQ DEBUG
002000F4  1639 00C00003            298mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                299mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     300mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       301mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           302mm     ENDC
00200108                           303mm     
00200108                 FALSE     304mm     IFNE DEBUG
00200108                           305mm     ENDC
00200108                           306mm 
00200108                           307mm     ENDM
00200108                           308mm     PRINT_CHAR #10,D3                           ; LF
00200108                           309mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      310mm     IFEQ DEBUG
00200108  1639 00C00003            311mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                312mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     313mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       314mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           315mm     ENDC
0020011C                           316mm     
0020011C                 FALSE     317mm     IFNE DEBUG
0020011C                           318mm     ENDC
0020011C                           319mm 
0020011C                           320mm     ENDM
0020011C                           321m     ENDM
0020011C                           322  
0020011C  41F9 00200E28            323      LEA VERSION,A0
00200122                           324m     PRINT_STR A0,D3
00200122                           325m LOOP_5
00200122  0C10 0000                326m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 0016                327m     BEQ EXIT_5
0020012A                           328mm     PRINT_CHAR (A0)+,D3
0020012A                           329mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      330mm     IFEQ DEBUG
0020012A  1639 00C00003            331mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                332mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     333mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            334mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           335mm     ENDC
0020013C                           336mm     
0020013C                 FALSE     337mm     IFNE DEBUG
0020013C                           338mm     ENDC
0020013C                           339mm 
0020013C                           340mm     ENDM
0020013C  60E4                     341m     BRA LOOP_5
0020013E                           342m EXIT_5
0020013E                           343m     ENDM
0020013E                           344m     PRINT_CRLF D3
0020013E                           345mm     PRINT_CHAR #13,D3                           ; CR
0020013E                           346mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020013E                 TRUE      347mm     IFEQ DEBUG
0020013E  1639 00C00003            348mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200144  0803 0002                349mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200148  67F4                     350mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014A  13FC 000D 00C00007       351mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200152                           352mm     ENDC
00200152                           353mm     
00200152                 FALSE     354mm     IFNE DEBUG
00200152                           355mm     ENDC
00200152                           356mm 
00200152                           357mm     ENDM
00200152                           358mm     PRINT_CHAR #10,D3                           ; LF
00200152                           359mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200152                 TRUE      360mm     IFEQ DEBUG
00200152  1639 00C00003            361mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200158  0803 0002                362mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020015C  67F4                     363mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0020015E  13FC 000A 00C00007       364mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200166                           365mm     ENDC
00200166                           366mm     
00200166                 FALSE     367mm     IFNE DEBUG
00200166                           368mm     ENDC
00200166                           369mm 
00200166                           370mm     ENDM
00200166                           371m     ENDM
00200166                           372  
00200166  7E00                     373      MOVE.L #0,D7                                    ; address accumulator
00200168                           374  
00200168  13FC 0002 00E00001       375      MOVE.B #2,DISPLAY
00200170                           376  MAIN_LOOP
00200170                           377m     PRINT_CHAR #'>',D3                          ; prompt
00200170                           378m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200170                 TRUE      379m     IFEQ DEBUG
00200170  1639 00C00003            380m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200176  0803 0002                381m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020017A  67F4                     382m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0020017C  13FC 003E 00C00007       383m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200184                           384m     ENDC
00200184                           385m     
00200184                 FALSE     386m     IFNE DEBUG
00200184                           387m     ENDC
00200184                           388m 
00200184                           389m     ENDM
00200184                           390m     PRINT_CHAR #32,D3                           ; space
00200184                           391m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200184                 TRUE      392m     IFEQ DEBUG
00200184  1639 00C00003            393m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018A  0803 0002                394m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020018E  67F4                     395m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200190  13FC 0020 00C00007       396m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200198                           397m     ENDC
00200198                           398m     
00200198                 FALSE     399m     IFNE DEBUG
00200198                           400m     ENDC
00200198                           401m 
00200198                           402m     ENDM
00200198                           403      
00200198                           404  GET_INPUT
00200198                           405m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00200198                           406m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200198                 TRUE      407m     IFEQ DEBUG
00200198  1639 00C00003            408m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0020019E  0803 0000                409m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001A2  67F4                     410m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
002001A4                           411m     ENDC
002001A4                           412m     
002001A4                           413mm     READ_CHAR D2
002001A4                 TRUE      414mm     IFEQ DEBUG
002001A4  1439 00C00007            415mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
002001AA                           416mm     ENDC
002001AA                 FALSE     417mm     IFNE DEBUG
002001AA                           418mm     ENDC
002001AA                           419mm      
002001AA  B43C 001B                420mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001AE  6700 FE58                421mm     BEQ START
002001B2                           422mm     ENDM
002001B2                           423m 
002001B2                 TRUE      424m     IFEQ DEBUG
002001B2                           425mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
002001B2                           426mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B2                 TRUE      427mm     IFEQ DEBUG
002001B2  1639 00C00003            428mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B8  0803 0002                429mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001BC  67F4                     430mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
002001BE  13C2 00C00007            431mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001C4                           432mm     ENDC
002001C4                           433mm     
002001C4                 FALSE     434mm     IFNE DEBUG
002001C4                           435mm     ENDC
002001C4                           436mm 
002001C4                           437mm     ENDM
002001C4                           438m     ENDC
002001C4                           439m     ENDM
002001C4                           440      
002001C4                           441      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
002001C4  B43C 0030                442s     CMP.B   #'0',D2
002001C8  6D00 000E                443s     BLT _00000000
002001CC  B43C 0039                444s     CMP.B   #'9',D2
002001D0  6E00 0006                445s     BGT _00000000
002001D4  6000 0C32                446          BRA HEX_DIGIT
002001D8                           447      ENDI
002001D8                           448s _00000000
002001D8                           449      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
002001D8  B43C 0041                450s     CMP.B   #'A',D2
002001DC  6D00 000E                451s     BLT _00000001
002001E0  B43C 0046                452s     CMP.B   #'F',D2
002001E4  6E00 0006                453s     BGT _00000001
002001E8  6000 0C1E                454          BRA HEX_DIGIT
002001EC                           455      ENDI
002001EC                           456s _00000001
002001EC                           457          
002001EC  B43C 0077                458      CMP.B #'w',D2
002001F0  6700 013E                459      BEQ W
002001F4                           460      
002001F4  B43C 006C                461      CMP.B #'l',D2
002001F8  6700 0AA2                462      BEQ L 
002001FC                           463  
002001FC                           464m     PRINT_CRLF D3
002001FC                           465mm     PRINT_CHAR #13,D3                           ; CR
002001FC                           466mm WAIT_FOR_READY_16                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001FC                 TRUE      467mm     IFEQ DEBUG
002001FC  1639 00C00003            468mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200202  0803 0002                469mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200206  67F4                     470mm         BEQ WAIT_FOR_READY_16                   ; NO SPACE, CHECK AGAIN
00200208  13FC 000D 00C00007       471mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200210                           472mm     ENDC
00200210                           473mm     
00200210                 FALSE     474mm     IFNE DEBUG
00200210                           475mm     ENDC
00200210                           476mm 
00200210                           477mm     ENDM
00200210                           478mm     PRINT_CHAR #10,D3                           ; LF
00200210                           479mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200210                 TRUE      480mm     IFEQ DEBUG
00200210  1639 00C00003            481mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200216  0803 0002                482mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020021A  67F4                     483mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0020021C  13FC 000A 00C00007       484mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200224                           485mm     ENDC
00200224                           486mm     
00200224                 FALSE     487mm     IFNE DEBUG
00200224                           488mm     ENDC
00200224                           489mm 
00200224                           490mm     ENDM
00200224                           491m     ENDM
00200224                           492   
00200224  B43C 003F                493      CMP.B #'?',D2
00200228  6700 0050                494      BEQ H
0020022C                           495  
0020022C  B43C 0076                496      CMP.B #'v',D2
00200230  6700 0052                497      BEQ V
00200234                           498      
00200234  B43C 0072                499      CMP.B #'r',D2
00200238  6700 0070                500      BEQ R
0020023C                           501  
0020023C  B43C 0073                502      CMP.B #'s',D2
00200240  6700 01B4                503      BEQ S
00200244                           504  
00200244  B43C 0067                505      CMP.B #'g',D2
00200248  6700 0944                506      BEQ G   
0020024C                           507  
0020024C  B43C 007A                508      CMP.B #'z',D2
00200250  6700 0944                509      BEQ Z   
00200254                           510  
00200254  41F9 00200EEA            511      LEA HUH,A0
0020025A                           512m     PRINT_STR A0,D3
0020025A                           513m LOOP_18
0020025A  0C10 0000                514m     CMP.B #0,(A0)                               ; 0 -> DONE
0020025E  6700 0016                515m     BEQ EXIT_18
00200262                           516mm     PRINT_CHAR (A0)+,D3
00200262                           517mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200262                 TRUE      518mm     IFEQ DEBUG
00200262  1639 00C00003            519mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200268  0803 0002                520mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020026C  67F4                     521mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0020026E  13D8 00C00007            522mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200274                           523mm     ENDC
00200274                           524mm     
00200274                 FALSE     525mm     IFNE DEBUG
00200274                           526mm     ENDC
00200274                           527mm 
00200274                           528mm     ENDM
00200274  60E4                     529m     BRA LOOP_18
00200276                           530m EXIT_18
00200276                           531m     ENDM
00200276                           532                         
00200276  6000 FEF8                533      BRA MAIN_LOOP
0020027A                           534      
0020027A                           535  ; commands
0020027A                           536  H   
0020027A  41F9 00200E45            537      LEA HELP,A0
00200280  6000 0008                538      BRA PRINTSTR
00200284                           539  
00200284                           540  V   
00200284  41F9 00200E28            541      LEA VERSION,A0
0020028A                           542  PRINTSTR
0020028A                           543m     PRINT_STR A0,D3       
0020028A                           544m LOOP_20
0020028A  0C10 0000                545m     CMP.B #0,(A0)                               ; 0 -> DONE
0020028E  6700 0016                546m     BEQ EXIT_20
00200292                           547mm     PRINT_CHAR (A0)+,D3
00200292                           548mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200292                 TRUE      549mm     IFEQ DEBUG
00200292  1639 00C00003            550mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200298  0803 0002                551mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020029C  67F4                     552mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0020029E  13D8 00C00007            553mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002A4                           554mm     ENDC
002002A4                           555mm     
002002A4                 FALSE     556mm     IFNE DEBUG
002002A4                           557mm     ENDC
002002A4                           558mm 
002002A4                           559mm     ENDM
002002A4  60E4                     560m     BRA LOOP_20
002002A6                           561m EXIT_20
002002A6                           562m     ENDM
002002A6  6000 FEC8                563      BRA MAIN_LOOP
002002AA                           564      
002002AA                           565  R   
002002AA  2047                     566      MOVE.L D7,A0                                    ; address accumulator -> address register
002002AC  2A10                     567      MOVE.L (A0),D5                                  ; read the memory and print it
002002AE                           568m     PRINT_REG D5,D3,D7,D6,A0
002002AE                           569mm     PRINT_CHAR #'0',D3                              ;0X HEADER
002002AE                           570mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002AE                 TRUE      571mm     IFEQ DEBUG
002002AE  1639 00C00003            572mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002B4  0803 0002                573mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002B8  67F4                     574mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
002002BA  13FC 0030 00C00007       575mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002C2                           576mm     ENDC
002002C2                           577mm     
002002C2                 FALSE     578mm     IFNE DEBUG
002002C2                           579mm     ENDC
002002C2                           580mm 
002002C2                           581mm     ENDM
002002C2                           582mm     PRINT_CHAR #'x',D3
002002C2                           583mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002C2                 TRUE      584mm     IFEQ DEBUG
002002C2  1639 00C00003            585mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002C8  0803 0002                586mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002CC  67F4                     587mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
002002CE  13FC 0078 00C00007       588mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002D6                           589mm     ENDC
002002D6                           590mm     
002002D6                 FALSE     591mm     IFNE DEBUG
002002D6                           592mm     ENDC
002002D6                           593mm 
002002D6                           594mm     ENDM
002002D6  7C07                     595m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002002D8                           596m LOOP_22
002002D8                           597mm     BIN2HEX D5,D7,A0
002002D8  41F9 00200F4E            598mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002002DE  E99D                     599mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002002E0  1E05                     600mm     MOVE.B D5,D7
002002E2  0287 0000000F            601mm     ANDI.L #$F,D7
002002E8  1E30 7000                602mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
002002EC                           603mm     ENDM
002002EC                           604mm     PRINT_CHAR D7,D3
002002EC                           605mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002EC                 TRUE      606mm     IFEQ DEBUG
002002EC  1639 00C00003            607mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002F2  0803 0002                608mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002F6  67F4                     609mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
002002F8  13C7 00C00007            610mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002002FE                           611mm     ENDC
002002FE                           612mm     
002002FE                 FALSE     613mm     IFNE DEBUG
002002FE                           614mm     ENDC
002002FE                           615mm 
002002FE                           616mm     ENDM
002002FE  57CE FFD8                617m     DBEQ D6,LOOP_22
00200302                           618m     ENDM
00200302                           619m     PRINT_CRLF D3
00200302                           620mm     PRINT_CHAR #13,D3                           ; CR
00200302                           621mm WAIT_FOR_READY_28                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200302                 TRUE      622mm     IFEQ DEBUG
00200302  1639 00C00003            623mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200308  0803 0002                624mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020030C  67F4                     625mm         BEQ WAIT_FOR_READY_28                   ; NO SPACE, CHECK AGAIN
0020030E  13FC 000D 00C00007       626mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200316                           627mm     ENDC
00200316                           628mm     
00200316                 FALSE     629mm     IFNE DEBUG
00200316                           630mm     ENDC
00200316                           631mm 
00200316                           632mm     ENDM
00200316                           633mm     PRINT_CHAR #10,D3                           ; LF
00200316                           634mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200316                 TRUE      635mm     IFEQ DEBUG
00200316  1639 00C00003            636mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020031C  0803 0002                637mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200320  67F4                     638mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200322  13FC 000A 00C00007       639mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020032A                           640mm     ENDC
0020032A                           641mm     
0020032A                 FALSE     642mm     IFNE DEBUG
0020032A                           643mm     ENDC
0020032A                           644mm 
0020032A                           645mm     ENDM
0020032A                           646m     ENDM
0020032A  7E00                     647      MOVE.L #0,D7                                    ; clear the now used address accumulator
0020032C  6000 FE42                648      BRA MAIN_LOOP
00200330                           649  
00200330                           650  W
00200330  7A00                     651      MOVE.L #0,D5                                    ; D5 will be the value to write            
00200332                           652  
00200332                           653m     WAIT_CHAR D2,D3                                 ; read most significant character -> D2
00200332                           654m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200332                 TRUE      655m     IFEQ DEBUG
00200332  1639 00C00003            656m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200338  0803 0000                657m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020033C  67F4                     658m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
0020033E                           659m     ENDC
0020033E                           660m     
0020033E                           661mm     READ_CHAR D2
0020033E                 TRUE      662mm     IFEQ DEBUG
0020033E  1439 00C00007            663mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200344                           664mm     ENDC
00200344                 FALSE     665mm     IFNE DEBUG
00200344                           666mm     ENDC
00200344                           667mm      
00200344  B43C 001B                668mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200348  6700 FCBE                669mm     BEQ START
0020034C                           670mm     ENDM
0020034C                           671m 
0020034C                 TRUE      672m     IFEQ DEBUG
0020034C                           673mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0020034C                           674mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      675mm     IFEQ DEBUG
0020034C  1639 00C00003            676mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                677mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     678mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00200358  13C2 00C00007            679mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020035E                           680mm     ENDC
0020035E                           681mm     
0020035E                 FALSE     682mm     IFNE DEBUG
0020035E                           683mm     ENDC
0020035E                           684mm 
0020035E                           685mm     ENDM
0020035E                           686m     ENDC
0020035E                           687m     ENDM
0020035E                           688m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0020035E  41F9 00200F5E            689m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200364  0402 0030                690m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200368  C4BC 000000FF            691m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0020036E  1430 2000                692m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200372                           693m     ENDM
00200372  1A02                     694      MOVE.B D2,D5                                    ; put at bottom of D5
00200374                           695  
00200374  3C3C 0006                696      MOVE #6,D6                                      ; 7 bytes left to read
00200378                           697      
00200378                           698  READ_DATA_TO_POKE
00200378  E98D                     699      LSL.L #4,D5                                     ; make what we have so far more significant
0020037A                           700m     WAIT_CHAR D2,D3                                 ; next character -> D2
0020037A                           701m WAIT_FOR_READY_34                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020037A                 TRUE      702m     IFEQ DEBUG
0020037A  1639 00C00003            703m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200380  0803 0000                704m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200384  67F4                     705m         BEQ WAIT_FOR_READY_34                   ; NOTHING, CHECK AGAIN
00200386                           706m     ENDC
00200386                           707m     
00200386                           708mm     READ_CHAR D2
00200386                 TRUE      709mm     IFEQ DEBUG
00200386  1439 00C00007            710mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0020038C                           711mm     ENDC
0020038C                 FALSE     712mm     IFNE DEBUG
0020038C                           713mm     ENDC
0020038C                           714mm      
0020038C  B43C 001B                715mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200390  6700 FC76                716mm     BEQ START
00200394                           717mm     ENDM
00200394                           718m 
00200394                 TRUE      719m     IFEQ DEBUG
00200394                           720mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200394                           721mm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200394                 TRUE      722mm     IFEQ DEBUG
00200394  1639 00C00003            723mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020039A  0803 0002                724mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020039E  67F4                     725mm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
002003A0  13C2 00C00007            726mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003A6                           727mm     ENDC
002003A6                           728mm     
002003A6                 FALSE     729mm     IFNE DEBUG
002003A6                           730mm     ENDC
002003A6                           731mm 
002003A6                           732mm     ENDM
002003A6                           733m     ENDC
002003A6                           734m     ENDM
002003A6                           735m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
002003A6  41F9 00200F5E            736m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
002003AC  0402 0030                737m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002003B0  C4BC 000000FF            738m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
002003B6  1430 2000                739m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
002003BA                           740m     ENDM
002003BA  8A02                     741      OR.B D2,D5
002003BC  023C 00FB                742      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
002003C0  57CE FFB6                743      DBEQ D6,READ_DATA_TO_POKE
002003C4                           744      
002003C4  2047                     745      MOVE.L D7,A0                                    ; address accumulator -> address register
002003C6  7E00                     746      MOVE.L #0,D7                                    ; clear the now used address accumulator
002003C8                           747      
002003C8  2085                     748      MOVE.L D5,(A0)                                  ; write the data
002003CA                           749  
002003CA                           750m     PRINT_CRLF D3
002003CA                           751mm     PRINT_CHAR #13,D3                           ; CR
002003CA                           752mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003CA                 TRUE      753mm     IFEQ DEBUG
002003CA  1639 00C00003            754mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D0  0803 0002                755mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003D4  67F4                     756mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
002003D6  13FC 000D 00C00007       757mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003DE                           758mm     ENDC
002003DE                           759mm     
002003DE                 FALSE     760mm     IFNE DEBUG
002003DE                           761mm     ENDC
002003DE                           762mm 
002003DE                           763mm     ENDM
002003DE                           764mm     PRINT_CHAR #10,D3                           ; LF
002003DE                           765mm WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003DE                 TRUE      766mm     IFEQ DEBUG
002003DE  1639 00C00003            767mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003E4  0803 0002                768mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003E8  67F4                     769mm         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
002003EA  13FC 000A 00C00007       770mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003F2                           771mm     ENDC
002003F2                           772mm     
002003F2                 FALSE     773mm     IFNE DEBUG
002003F2                           774mm     ENDC
002003F2                           775mm 
002003F2                           776mm     ENDM
002003F2                           777m     ENDM
002003F2  6000 FD7C                778      BRA MAIN_LOOP
002003F6                           779  
002003F6                           780  ; register map for S
002003F6                           781  ; A0 - start address
002003F6                           782  ; A1 - offset
002003F6                           783  ; A2 - next address to write
002003F6                           784  ; A3 - next location (jmp)
002003F6                           785  ; A4 - Working Address Register
002003F6                           786  ; D0 - record count
002003F6                           787  ; D1 - 'S', record type, data byte
002003F6                           788  ; D2 - checksum
002003F6                           789  ; D3 - data byte count
002003F6                           790  ; D4 - read address, moved into A2
002003F6                           791  ; D5 - temp
002003F6                           792  ; D6 - temp
002003F6                           793  ; D7 - temp
002003F6                           794  S
002003F6  2078 0000                795      MOVE.L 0,A0                                     ; start address -> A0
002003FA  2247                     796      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
002003FC                           797      
002003FC  7000                     798      MOVE.L #0,D0                                    ; count of records read -> D0
002003FE                           799          
002003FE                           800  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
002003FE                           801m     DOWNLOAD D1                 
002003FE                           802m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003FE                           803m 
002003FE  1239 00C00003            804m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00200404  0801 0000                805m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200408  6700 0010                806m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
0020040C                           807m  
0020040C                           808mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0020040C                 TRUE      809mm     IFEQ DEBUG
0020040C  1239 00C00007            810mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00200412                           811mm     ENDC
00200412                 FALSE     812mm     IFNE DEBUG
00200412                           813mm     ENDC
00200412                           814mm      
00200412  B23C 001B                815mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00200416  6700 FBF0                816mm     BEQ START
0020041A                           817mm     ENDM
0020041A                           818m CONTINUE_41
0020041A  1239 00C00013            819m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00200420  0801 0000                820m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00200424  67D8                     821m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
00200426                           822m     
00200426  1239 00C00017            823m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0020042C  13C1 00E00001            824m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00200432                           825m     
00200432                           826m     ENDM
00200432  B23C 0053                827      CMP.B #'S',D1                                   ; found S?    
00200436  66C6                     828      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00200438                           829      
00200438                           830m     PRINT_CHAR #'S',D5                          ; print the S
00200438                           831m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200438                 TRUE      832m     IFEQ DEBUG
00200438  1A39 00C00003            833m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020043E  0805 0002                834m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200442  67F4                     835m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00200444  13FC 0053 00C00007       836m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020044C                           837m     ENDC
0020044C                           838m     
0020044C                 FALSE     839m     IFNE DEBUG
0020044C                           840m     ENDC
0020044C                           841m 
0020044C                           842m     ENDM
0020044C  5280                     843      ADD.L #1,D0                                     ; read another S record, increment count
0020044E                           844      
0020044E                           845m     DOWNLOAD D1                                 ; read the record identifier and echo it back
0020044E                           846m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020044E                           847m 
0020044E  1239 00C00003            848m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00200454  0801 0000                849m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200458  6700 0010                850m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0020045C                           851m  
0020045C                           852mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0020045C                 TRUE      853mm     IFEQ DEBUG
0020045C  1239 00C00007            854mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00200462                           855mm     ENDC
00200462                 FALSE     856mm     IFNE DEBUG
00200462                           857mm     ENDC
00200462                           858mm      
00200462  B23C 001B                859mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00200466  6700 FBA0                860mm     BEQ START
0020046A                           861mm     ENDM
0020046A                           862m CONTINUE_44
0020046A  1239 00C00013            863m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00200470  0801 0000                864m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00200474  67D8                     865m     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00200476                           866m     
00200476  1239 00C00017            867m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0020047C  13C1 00E00001            868m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00200482                           869m     
00200482                           870m     ENDM
00200482                           871m     PRINT_CHAR D1,D5
00200482                           872m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200482                 TRUE      873m     IFEQ DEBUG
00200482  1A39 00C00003            874m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200488  0805 0002                875m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020048C  67F4                     876m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
0020048E  13C1 00C00007            877m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200494                           878m     ENDC
00200494                           879m     
00200494                 FALSE     880m     IFNE DEBUG
00200494                           881m     ENDC
00200494                           882m 
00200494                           883m     ENDM
00200494                           884  
00200494  7400                     885      MOVE.L #0,D2                                    ; clear the checksum
00200496                           886  
00200496  7600                     887      MOVE.L #0,D3                                    ; read the 2 digit byte count -> D3
00200498                           888m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00200498  1E3C 0002                889m     MOVE.B #2,D7
0020049C                           890m     WHILE.B D7 <GT> 0 DO
0020049C                           891ms _10000000
0020049C  BE38 0000                892ms     CMP.B   0,D7
002004A0  6F00 0064                893ms     BLE _10000001
002004A4  E98B                     894m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
002004A6                           895mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002004A6                           896mm WAIT_FOR_READY_48                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A6                           897mm 
002004A6  1A39 00C00003            898mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002004AC  0805 0000                899mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002004B0  6700 0010                900mm     BEQ CONTINUE_48                             ; NOTHING, CONTINUE
002004B4                           901mm  
002004B4                           902mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002004B4                 TRUE      903mmm     IFEQ DEBUG
002004B4  1A39 00C00007            904mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002004BA                           905mmm     ENDC
002004BA                 FALSE     906mmm     IFNE DEBUG
002004BA                           907mmm     ENDC
002004BA                           908mmm      
002004BA  BA3C 001B                909mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002004BE  6700 FB48                910mmm     BEQ START
002004C2                           911mmm     ENDM
002004C2                           912mm CONTINUE_48
002004C2  1A39 00C00013            913mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002004C8  0805 0000                914mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002004CC  67D8                     915mm     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
002004CE                           916mm     
002004CE  1A39 00C00017            917mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002004D4  13C5 00E00001            918mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002004DA                           919mm     
002004DA                           920mm     ENDM
002004DA                           921mm         PRINT_CHAR D5,D6
002004DA                           922mm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      923mm     IFEQ DEBUG
002004DA  1C39 00C00003            924mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002004E0  0806 0002                925mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     926mm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
002004E6  13C5 00C00007            927mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002004EC                           928mm     ENDC
002004EC                           929mm     
002004EC                 FALSE     930mm     IFNE DEBUG
002004EC                           931mm     ENDC
002004EC                           932mm 
002004EC                           933mm     ENDM
002004EC                           934mm         HEX2BIN D5,D5,A4
002004EC  49F9 00200F5E            935mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002004F2  0405 0030                936mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002004F6  CABC 000000FF            937mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002004FC  1A34 5000                938mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200500                           939mm     ENDM
00200500  8605                     940m         OR.B D5,D3
00200502  5307                     941m         SUB.B #1,D7
00200504                           942m     ENDW
00200504  6096                     943ms     BRA _10000000
00200506                           944ms _10000001
00200506                           945m     
00200506  7A00                     946m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200508  1A03                     947m     MOVE.B D3,D5
0020050A  D483                     948m     ADD.L D3,D2
0020050C                           949m 
0020050C                           950m     ENDM
0020050C                           951  
0020050C                           952      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0020050C  B23C 0030                953s     CMP.B   #'0',D1
00200510  6600 0032                954s     BNE.L   _00000002
00200514                           955m         PRINT_CRLF D5
00200514                           956mm     PRINT_CHAR #13,D5                           ; CR
00200514                           957mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                 TRUE      958mm     IFEQ DEBUG
00200514  1A39 00C00003            959mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020051A  0805 0002                960mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020051E  67F4                     961mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00200520  13FC 000D 00C00007       962mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200528                           963mm     ENDC
00200528                           964mm     
00200528                 FALSE     965mm     IFNE DEBUG
00200528                           966mm     ENDC
00200528                           967mm 
00200528                           968mm     ENDM
00200528                           969mm     PRINT_CHAR #10,D5                           ; LF
00200528                           970mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200528                 TRUE      971mm     IFEQ DEBUG
00200528  1A39 00C00003            972mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020052E  0805 0002                973mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200532  67F4                     974mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
00200534  13FC 000A 00C00007       975mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020053C                           976mm     ENDC
0020053C                           977mm     
0020053C                 FALSE     978mm     IFNE DEBUG
0020053C                           979mm     ENDC
0020053C                           980mm 
0020053C                           981mm     ENDM
0020053C                           982m     ENDM
0020053C  6000 FEC0                983          BRA WAIT_FOR_SRECORD
00200540                           984      ELSE
00200540  6000 040A                985s     BRA _00000003
00200544                           986s _00000002
00200544                           987          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00200544  B23C 0031                988s     CMP.B   #'1',D1
00200548  6708                     989s     BEQ.S   _00000004
0020054A  B23C 0032                990s     CMP.B   #'2',D1
0020054E  6600 0202                991s     BNE.L   _00000005
00200552                           992s _00000004
00200552  5783                     993              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00200554                           994      
00200554  7800                     995              MOVE.L #0,D4                            ; read two bytes of address
00200556                           996m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
00200556  1E3C 0002                997m     MOVE.B #2,D7
0020055A                           998m     WHILE.B D7 <GT> 0 DO
0020055A                           999ms _10000002
0020055A  BE38 0000               1000ms     CMP.B   0,D7
0020055E  6F00 0064               1001ms     BLE _10000003
00200562  E98C                    1002m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200564                          1003mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200564                          1004mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200564                          1005mm 
00200564  1A39 00C00003           1006mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020056A  0805 0000               1007mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020056E  6700 0010               1008mm     BEQ CONTINUE_56                             ; NOTHING, CONTINUE
00200572                          1009mm  
00200572                          1010mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200572                 TRUE     1011mmm     IFEQ DEBUG
00200572  1A39 00C00007           1012mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200578                          1013mmm     ENDC
00200578                 FALSE    1014mmm     IFNE DEBUG
00200578                          1015mmm     ENDC
00200578                          1016mmm      
00200578  BA3C 001B               1017mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020057C  6700 FA8A               1018mmm     BEQ START
00200580                          1019mmm     ENDM
00200580                          1020mm CONTINUE_56
00200580  1A39 00C00013           1021mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200586  0805 0000               1022mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020058A  67D8                    1023mm     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
0020058C                          1024mm     
0020058C  1A39 00C00017           1025mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200592  13C5 00E00001           1026mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200598                          1027mm     
00200598                          1028mm     ENDM
00200598                          1029mm         PRINT_CHAR D5,D6
00200598                          1030mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200598                 TRUE     1031mm     IFEQ DEBUG
00200598  1C39 00C00003           1032mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020059E  0806 0002               1033mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002005A2  67F4                    1034mm         BEQ WAIT_FOR_READY_58                   ; NO SPACE, CHECK AGAIN
002005A4  13C5 00C00007           1035mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002005AA                          1036mm     ENDC
002005AA                          1037mm     
002005AA                 FALSE    1038mm     IFNE DEBUG
002005AA                          1039mm     ENDC
002005AA                          1040mm 
002005AA                          1041mm     ENDM
002005AA                          1042mm         HEX2BIN D5,D5,A4
002005AA  49F9 00200F5E           1043mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002005B0  0405 0030               1044mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005B4  CABC 000000FF           1045mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002005BA  1A34 5000               1046mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002005BE                          1047mm     ENDM
002005BE  8805                    1048m         OR.B D5,D4
002005C0  5307                    1049m         SUB.B #1,D7
002005C2                          1050m     ENDW
002005C2  6096                    1051ms     BRA _10000002
002005C4                          1052ms _10000003
002005C4                          1053m     
002005C4  7A00                    1054m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002005C6  1A04                    1055m     MOVE.B D4,D5
002005C8  D484                    1056m     ADD.L D4,D2
002005CA                          1057m 
002005CA                          1058m     ENDM
002005CA                          1059m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
002005CA  1E3C 0002               1060m     MOVE.B #2,D7
002005CE                          1061m     WHILE.B D7 <GT> 0 DO
002005CE                          1062ms _10000004
002005CE  BE38 0000               1063ms     CMP.B   0,D7
002005D2  6F00 0064               1064ms     BLE _10000005
002005D6  E98C                    1065m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002005D8                          1066mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002005D8                          1067mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005D8                          1068mm 
002005D8  1A39 00C00003           1069mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002005DE  0805 0000               1070mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002005E2  6700 0010               1071mm     BEQ CONTINUE_61                             ; NOTHING, CONTINUE
002005E6                          1072mm  
002005E6                          1073mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002005E6                 TRUE     1074mmm     IFEQ DEBUG
002005E6  1A39 00C00007           1075mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002005EC                          1076mmm     ENDC
002005EC                 FALSE    1077mmm     IFNE DEBUG
002005EC                          1078mmm     ENDC
002005EC                          1079mmm      
002005EC  BA3C 001B               1080mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002005F0  6700 FA16               1081mmm     BEQ START
002005F4                          1082mmm     ENDM
002005F4                          1083mm CONTINUE_61
002005F4  1A39 00C00013           1084mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002005FA  0805 0000               1085mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002005FE  67D8                    1086mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00200600                          1087mm     
00200600  1A39 00C00017           1088mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200606  13C5 00E00001           1089mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020060C                          1090mm     
0020060C                          1091mm     ENDM
0020060C                          1092mm         PRINT_CHAR D5,D6
0020060C                          1093mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020060C                 TRUE     1094mm     IFEQ DEBUG
0020060C  1C39 00C00003           1095mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200612  0806 0002               1096mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200616  67F4                    1097mm         BEQ WAIT_FOR_READY_63                   ; NO SPACE, CHECK AGAIN
00200618  13C5 00C00007           1098mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020061E                          1099mm     ENDC
0020061E                          1100mm     
0020061E                 FALSE    1101mm     IFNE DEBUG
0020061E                          1102mm     ENDC
0020061E                          1103mm 
0020061E                          1104mm     ENDM
0020061E                          1105mm         HEX2BIN D5,D5,A4
0020061E  49F9 00200F5E           1106mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200624  0405 0030               1107mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200628  CABC 000000FF           1108mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0020062E  1A34 5000               1109mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200632                          1110mm     ENDM
00200632  8805                    1111m         OR.B D5,D4
00200634  5307                    1112m         SUB.B #1,D7
00200636                          1113m     ENDW
00200636  6096                    1114ms     BRA _10000004
00200638                          1115ms _10000005
00200638                          1116m     
00200638  7A00                    1117m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020063A  1A04                    1118m     MOVE.B D4,D5
0020063C  D484                    1119m     ADD.L D4,D2
0020063E                          1120m 
0020063E                          1121m     ENDM
0020063E                          1122              
0020063E                          1123              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
0020063E  B23C 0032               1124s     CMP.B   #'2',D1
00200642  6600 0078               1125s     BNE.L   _00000006
00200646  5383                    1126                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00200648                          1127m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00200648  1E3C 0002               1128m     MOVE.B #2,D7
0020064C                          1129m     WHILE.B D7 <GT> 0 DO
0020064C                          1130ms _10000006
0020064C  BE38 0000               1131ms     CMP.B   0,D7
00200650  6F00 0064               1132ms     BLE _10000007
00200654  E98C                    1133m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200656                          1134mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200656                          1135mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200656                          1136mm 
00200656  1A39 00C00003           1137mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020065C  0805 0000               1138mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200660  6700 0010               1139mm     BEQ CONTINUE_66                             ; NOTHING, CONTINUE
00200664                          1140mm  
00200664                          1141mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200664                 TRUE     1142mmm     IFEQ DEBUG
00200664  1A39 00C00007           1143mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020066A                          1144mmm     ENDC
0020066A                 FALSE    1145mmm     IFNE DEBUG
0020066A                          1146mmm     ENDC
0020066A                          1147mmm      
0020066A  BA3C 001B               1148mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020066E  6700 F998               1149mmm     BEQ START
00200672                          1150mmm     ENDM
00200672                          1151mm CONTINUE_66
00200672  1A39 00C00013           1152mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200678  0805 0000               1153mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020067C  67D8                    1154mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
0020067E                          1155mm     
0020067E  1A39 00C00017           1156mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200684  13C5 00E00001           1157mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020068A                          1158mm     
0020068A                          1159mm     ENDM
0020068A                          1160mm         PRINT_CHAR D5,D6
0020068A                          1161mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020068A                 TRUE     1162mm     IFEQ DEBUG
0020068A  1C39 00C00003           1163mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200690  0806 0002               1164mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200694  67F4                    1165mm         BEQ WAIT_FOR_READY_68                   ; NO SPACE, CHECK AGAIN
00200696  13C5 00C00007           1166mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020069C                          1167mm     ENDC
0020069C                          1168mm     
0020069C                 FALSE    1169mm     IFNE DEBUG
0020069C                          1170mm     ENDC
0020069C                          1171mm 
0020069C                          1172mm     ENDM
0020069C                          1173mm         HEX2BIN D5,D5,A4
0020069C  49F9 00200F5E           1174mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002006A2  0405 0030               1175mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006A6  CABC 000000FF           1176mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002006AC  1A34 5000               1177mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002006B0                          1178mm     ENDM
002006B0  8805                    1179m         OR.B D5,D4
002006B2  5307                    1180m         SUB.B #1,D7
002006B4                          1181m     ENDW
002006B4  6096                    1182ms     BRA _10000006
002006B6                          1183ms _10000007
002006B6                          1184m     
002006B6  7A00                    1185m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006B8  1A04                    1186m     MOVE.B D4,D5
002006BA  D484                    1187m     ADD.L D4,D2
002006BC                          1188m 
002006BC                          1189m     ENDM
002006BC                          1190              ENDI
002006BC                          1191s _00000006
002006BC                          1192              
002006BC  2444                    1193              MOVE.L D4,A2                                ; put the address in an address register
002006BE  D5C9                    1194              ADD.L A1,A2                             ; add in the offset
002006C0                          1195  
002006C0                          1196              WHILE.L D3 <GT> #0 DO                   ; read the data bytes                
002006C0                          1197s _10000008
002006C0  B6BC 00000000           1198s     CMP.L   #0,D3
002006C6  6F00 0080               1199s     BLE _10000009
002006CA  7200                    1200                  MOVE.L #0,D1                        ; D1 holds the byte
002006CC                          1201m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
002006CC  1E3C 0002               1202m     MOVE.B #2,D7
002006D0                          1203m     WHILE.B D7 <GT> 0 DO
002006D0                          1204ms _1000000A
002006D0  BE38 0000               1205ms     CMP.B   0,D7
002006D4  6F00 0064               1206ms     BLE _1000000B
002006D8  E989                    1207m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
002006DA                          1208mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002006DA                          1209mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006DA                          1210mm 
002006DA  1A39 00C00003           1211mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002006E0  0805 0000               1212mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002006E4  6700 0010               1213mm     BEQ CONTINUE_71                             ; NOTHING, CONTINUE
002006E8                          1214mm  
002006E8                          1215mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002006E8                 TRUE     1216mmm     IFEQ DEBUG
002006E8  1A39 00C00007           1217mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002006EE                          1218mmm     ENDC
002006EE                 FALSE    1219mmm     IFNE DEBUG
002006EE                          1220mmm     ENDC
002006EE                          1221mmm      
002006EE  BA3C 001B               1222mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002006F2  6700 F914               1223mmm     BEQ START
002006F6                          1224mmm     ENDM
002006F6                          1225mm CONTINUE_71
002006F6  1A39 00C00013           1226mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002006FC  0805 0000               1227mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200700  67D8                    1228mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
00200702                          1229mm     
00200702  1A39 00C00017           1230mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200708  13C5 00E00001           1231mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020070E                          1232mm     
0020070E                          1233mm     ENDM
0020070E                          1234mm         PRINT_CHAR D5,D6
0020070E                          1235mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020070E                 TRUE     1236mm     IFEQ DEBUG
0020070E  1C39 00C00003           1237mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200714  0806 0002               1238mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200718  67F4                    1239mm         BEQ WAIT_FOR_READY_73                   ; NO SPACE, CHECK AGAIN
0020071A  13C5 00C00007           1240mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200720                          1241mm     ENDC
00200720                          1242mm     
00200720                 FALSE    1243mm     IFNE DEBUG
00200720                          1244mm     ENDC
00200720                          1245mm 
00200720                          1246mm     ENDM
00200720                          1247mm         HEX2BIN D5,D5,A4
00200720  49F9 00200F5E           1248mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200726  0405 0030               1249mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020072A  CABC 000000FF           1250mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200730  1A34 5000               1251mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200734                          1252mm     ENDM
00200734  8205                    1253m         OR.B D5,D1
00200736  5307                    1254m         SUB.B #1,D7
00200738                          1255m     ENDW
00200738  6096                    1256ms     BRA _1000000A
0020073A                          1257ms _1000000B
0020073A                          1258m     
0020073A  7A00                    1259m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020073C  1A01                    1260m     MOVE.B D1,D5
0020073E  D481                    1261m     ADD.L D1,D2
00200740                          1262m 
00200740                          1263m     ENDM
00200740                          1264                          
00200740  14C1                    1265                  MOVE.B D1,(A2)+                     ; store it!
00200742                          1266  
00200742  5383                    1267                  SUB.L #1,D3                     ; 1 less byte to go
00200744                          1268              ENDW
00200744  6000 FF7A               1269s     BRA _10000008
00200748                          1270s _10000009
00200748                          1271          
00200748  47F9 002003FE           1272              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
0020074E                          1273          ELSE
0020074E  6000 01FC               1274s     BRA _00000007
00200752                          1275s _00000005
00200752                          1276              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00200752  B23C 0038               1277s     CMP.B   #'8',D1
00200756  6600 016C               1278s     BNE.L   _00000008
0020075A  7800                    1279                  MOVE.L #0,D4                    ; read the 24 bit start address
0020075C                          1280m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0020075C  1E3C 0002               1281m     MOVE.B #2,D7
00200760                          1282m     WHILE.B D7 <GT> 0 DO
00200760                          1283ms _1000000C
00200760  BE38 0000               1284ms     CMP.B   0,D7
00200764  6F00 0064               1285ms     BLE _1000000D
00200768  E98C                    1286m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020076A                          1287mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020076A                          1288mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020076A                          1289mm 
0020076A  1A39 00C00003           1290mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200770  0805 0000               1291mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200774  6700 0010               1292mm     BEQ CONTINUE_76                             ; NOTHING, CONTINUE
00200778                          1293mm  
00200778                          1294mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200778                 TRUE     1295mmm     IFEQ DEBUG
00200778  1A39 00C00007           1296mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020077E                          1297mmm     ENDC
0020077E                 FALSE    1298mmm     IFNE DEBUG
0020077E                          1299mmm     ENDC
0020077E                          1300mmm      
0020077E  BA3C 001B               1301mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200782  6700 F884               1302mmm     BEQ START
00200786                          1303mmm     ENDM
00200786                          1304mm CONTINUE_76
00200786  1A39 00C00013           1305mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020078C  0805 0000               1306mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200790  67D8                    1307mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00200792                          1308mm     
00200792  1A39 00C00017           1309mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200798  13C5 00E00001           1310mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020079E                          1311mm     
0020079E                          1312mm     ENDM
0020079E                          1313mm         PRINT_CHAR D5,D6
0020079E                          1314mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020079E                 TRUE     1315mm     IFEQ DEBUG
0020079E  1C39 00C00003           1316mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002007A4  0806 0002               1317mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002007A8  67F4                    1318mm         BEQ WAIT_FOR_READY_78                   ; NO SPACE, CHECK AGAIN
002007AA  13C5 00C00007           1319mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007B0                          1320mm     ENDC
002007B0                          1321mm     
002007B0                 FALSE    1322mm     IFNE DEBUG
002007B0                          1323mm     ENDC
002007B0                          1324mm 
002007B0                          1325mm     ENDM
002007B0                          1326mm         HEX2BIN D5,D5,A4
002007B0  49F9 00200F5E           1327mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002007B6  0405 0030               1328mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007BA  CABC 000000FF           1329mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002007C0  1A34 5000               1330mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002007C4                          1331mm     ENDM
002007C4  8805                    1332m         OR.B D5,D4
002007C6  5307                    1333m         SUB.B #1,D7
002007C8                          1334m     ENDW
002007C8  6096                    1335ms     BRA _1000000C
002007CA                          1336ms _1000000D
002007CA                          1337m     
002007CA  7A00                    1338m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007CC  1A04                    1339m     MOVE.B D4,D5
002007CE  D484                    1340m     ADD.L D4,D2
002007D0                          1341m 
002007D0                          1342m     ENDM
002007D0                          1343m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
002007D0  1E3C 0002               1344m     MOVE.B #2,D7
002007D4                          1345m     WHILE.B D7 <GT> 0 DO
002007D4                          1346ms _1000000E
002007D4  BE38 0000               1347ms     CMP.B   0,D7
002007D8  6F00 0064               1348ms     BLE _1000000F
002007DC  E98C                    1349m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002007DE                          1350mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002007DE                          1351mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007DE                          1352mm 
002007DE  1A39 00C00003           1353mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002007E4  0805 0000               1354mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002007E8  6700 0010               1355mm     BEQ CONTINUE_81                             ; NOTHING, CONTINUE
002007EC                          1356mm  
002007EC                          1357mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002007EC                 TRUE     1358mmm     IFEQ DEBUG
002007EC  1A39 00C00007           1359mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002007F2                          1360mmm     ENDC
002007F2                 FALSE    1361mmm     IFNE DEBUG
002007F2                          1362mmm     ENDC
002007F2                          1363mmm      
002007F2  BA3C 001B               1364mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002007F6  6700 F810               1365mmm     BEQ START
002007FA                          1366mmm     ENDM
002007FA                          1367mm CONTINUE_81
002007FA  1A39 00C00013           1368mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200800  0805 0000               1369mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200804  67D8                    1370mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00200806                          1371mm     
00200806  1A39 00C00017           1372mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0020080C  13C5 00E00001           1373mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200812                          1374mm     
00200812                          1375mm     ENDM
00200812                          1376mm         PRINT_CHAR D5,D6
00200812                          1377mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200812                 TRUE     1378mm     IFEQ DEBUG
00200812  1C39 00C00003           1379mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200818  0806 0002               1380mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020081C  67F4                    1381mm         BEQ WAIT_FOR_READY_83                   ; NO SPACE, CHECK AGAIN
0020081E  13C5 00C00007           1382mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200824                          1383mm     ENDC
00200824                          1384mm     
00200824                 FALSE    1385mm     IFNE DEBUG
00200824                          1386mm     ENDC
00200824                          1387mm 
00200824                          1388mm     ENDM
00200824                          1389mm         HEX2BIN D5,D5,A4
00200824  49F9 00200F5E           1390mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020082A  0405 0030               1391mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020082E  CABC 000000FF           1392mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200834  1A34 5000               1393mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200838                          1394mm     ENDM
00200838  8805                    1395m         OR.B D5,D4
0020083A  5307                    1396m         SUB.B #1,D7
0020083C                          1397m     ENDW
0020083C  6096                    1398ms     BRA _1000000E
0020083E                          1399ms _1000000F
0020083E                          1400m     
0020083E  7A00                    1401m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200840  1A04                    1402m     MOVE.B D4,D5
00200842  D484                    1403m     ADD.L D4,D2
00200844                          1404m 
00200844                          1405m     ENDM
00200844                          1406m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00200844  1E3C 0002               1407m     MOVE.B #2,D7
00200848                          1408m     WHILE.B D7 <GT> 0 DO
00200848                          1409ms _10000010
00200848  BE38 0000               1410ms     CMP.B   0,D7
0020084C  6F00 0064               1411ms     BLE _10000011
00200850  E98C                    1412m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200852                          1413mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200852                          1414mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200852                          1415mm 
00200852  1A39 00C00003           1416mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200858  0805 0000               1417mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020085C  6700 0010               1418mm     BEQ CONTINUE_86                             ; NOTHING, CONTINUE
00200860                          1419mm  
00200860                          1420mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200860                 TRUE     1421mmm     IFEQ DEBUG
00200860  1A39 00C00007           1422mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200866                          1423mmm     ENDC
00200866                 FALSE    1424mmm     IFNE DEBUG
00200866                          1425mmm     ENDC
00200866                          1426mmm      
00200866  BA3C 001B               1427mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020086A  6700 F79C               1428mmm     BEQ START
0020086E                          1429mmm     ENDM
0020086E                          1430mm CONTINUE_86
0020086E  1A39 00C00013           1431mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200874  0805 0000               1432mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200878  67D8                    1433mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
0020087A                          1434mm     
0020087A  1A39 00C00017           1435mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200880  13C5 00E00001           1436mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200886                          1437mm     
00200886                          1438mm     ENDM
00200886                          1439mm         PRINT_CHAR D5,D6
00200886                          1440mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200886                 TRUE     1441mm     IFEQ DEBUG
00200886  1C39 00C00003           1442mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020088C  0806 0002               1443mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200890  67F4                    1444mm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00200892  13C5 00C00007           1445mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200898                          1446mm     ENDC
00200898                          1447mm     
00200898                 FALSE    1448mm     IFNE DEBUG
00200898                          1449mm     ENDC
00200898                          1450mm 
00200898                          1451mm     ENDM
00200898                          1452mm         HEX2BIN D5,D5,A4
00200898  49F9 00200F5E           1453mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020089E  0405 0030               1454mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008A2  CABC 000000FF           1455mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002008A8  1A34 5000               1456mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002008AC                          1457mm     ENDM
002008AC  8805                    1458m         OR.B D5,D4
002008AE  5307                    1459m         SUB.B #1,D7
002008B0                          1460m     ENDW
002008B0  6096                    1461ms     BRA _10000010
002008B2                          1462ms _10000011
002008B2                          1463m     
002008B2  7A00                    1464m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002008B4  1A04                    1465m     MOVE.B D4,D5
002008B6  D484                    1466m     ADD.L D4,D2
002008B8                          1467m 
002008B8                          1468m     ENDM
002008B8                          1469                    
002008B8  2044                    1470                  MOVE.L D4,A0                    ; start address -> A0
002008BA                          1471                  
002008BA  47F9 00200A96           1472                  LEA DOWNLOAD_DONE,A3            ; next place to go
002008C0                          1473              ELSE
002008C0  6000 008A               1474s     BRA _00000009
002008C4                          1475s _00000008
002008C4                          1476m                 PRINT_CRLF D5
002008C4                          1477mm     PRINT_CHAR #13,D5                           ; CR
002008C4                          1478mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008C4                 TRUE     1479mm     IFEQ DEBUG
002008C4  1A39 00C00003           1480mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008CA  0805 0002               1481mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008CE  67F4                    1482mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
002008D0  13FC 000D 00C00007      1483mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008D8                          1484mm     ENDC
002008D8                          1485mm     
002008D8                 FALSE    1486mm     IFNE DEBUG
002008D8                          1487mm     ENDC
002008D8                          1488mm 
002008D8                          1489mm     ENDM
002008D8                          1490mm     PRINT_CHAR #10,D5                           ; LF
002008D8                          1491mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1492mm     IFEQ DEBUG
002008D8  1A39 00C00003           1493mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008DE  0805 0002               1494mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1495mm         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
002008E4  13FC 000A 00C00007      1496mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008EC                          1497mm     ENDC
002008EC                          1498mm     
002008EC                 FALSE    1499mm     IFNE DEBUG
002008EC                          1500mm     ENDC
002008EC                          1501mm 
002008EC                          1502mm     ENDM
002008EC                          1503m     ENDM
002008EC                          1504              
002008EC  49F9 00200F13           1505                  LEA UNREC,A4                    ; warn for unrecognised type
002008F2                          1506m                 PRINT_STR A4,D5
002008F2                          1507m LOOP_93
002008F2  0C14 0000               1508m     CMP.B #0,(A4)                               ; 0 -> DONE
002008F6  6700 0016               1509m     BEQ EXIT_93
002008FA                          1510mm     PRINT_CHAR (A4)+,D5
002008FA                          1511mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008FA                 TRUE     1512mm     IFEQ DEBUG
002008FA  1A39 00C00003           1513mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200900  0805 0002               1514mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200904  67F4                    1515mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00200906  13DC 00C00007           1516mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020090C                          1517mm     ENDC
0020090C                          1518mm     
0020090C                 FALSE    1519mm     IFNE DEBUG
0020090C                          1520mm     ENDC
0020090C                          1521mm 
0020090C                          1522mm     ENDM
0020090C  60E4                    1523m     BRA LOOP_93
0020090E                          1524m EXIT_93
0020090E                          1525m     ENDM
0020090E                          1526m                 PRINT_CHAR D1,D5
0020090E                          1527m WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020090E                 TRUE     1528m     IFEQ DEBUG
0020090E  1A39 00C00003           1529m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200914  0805 0002               1530m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200918  67F4                    1531m         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0020091A  13C1 00C00007           1532m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200920                          1533m     ENDC
00200920                          1534m     
00200920                 FALSE    1535m     IFNE DEBUG
00200920                          1536m     ENDC
00200920                          1537m 
00200920                          1538m     ENDM
00200920                          1539m                 PRINT_CRLF D5
00200920                          1540mm     PRINT_CHAR #13,D5                           ; CR
00200920                          1541mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200920                 TRUE     1542mm     IFEQ DEBUG
00200920  1A39 00C00003           1543mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200926  0805 0002               1544mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020092A  67F4                    1545mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0020092C  13FC 000D 00C00007      1546mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200934                          1547mm     ENDC
00200934                          1548mm     
00200934                 FALSE    1549mm     IFNE DEBUG
00200934                          1550mm     ENDC
00200934                          1551mm 
00200934                          1552mm     ENDM
00200934                          1553mm     PRINT_CHAR #10,D5                           ; LF
00200934                          1554mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200934                 TRUE     1555mm     IFEQ DEBUG
00200934  1A39 00C00003           1556mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020093A  0805 0002               1557mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020093E  67F4                    1558mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00200940  13FC 000A 00C00007      1559mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200948                          1560mm     ENDC
00200948                          1561mm     
00200948                 FALSE    1562mm     IFNE DEBUG
00200948                          1563mm     ENDC
00200948                          1564mm 
00200948                          1565mm     ENDM
00200948                          1566m     ENDM
00200948                          1567              
00200948  6000 FAB4               1568                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0020094C                          1569              ENDI
0020094C                          1570s _00000009
0020094C                          1571          ENDI
0020094C                          1572s _00000007
0020094C                          1573      ENDI
0020094C                          1574s _00000003
0020094C                          1575      
0020094C  7800                    1576      MOVE.L #0,D4                                    ; read the checksum from the data stream add to our checksum: should make it FF
0020094E                          1577m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0020094E  1E3C 0002               1578m     MOVE.B #2,D7
00200952                          1579m     WHILE.B D7 <GT> 0 DO
00200952                          1580ms _10000012
00200952  BE38 0000               1581ms     CMP.B   0,D7
00200956  6F00 0064               1582ms     BLE _10000013
0020095A  E98C                    1583m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020095C                          1584mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020095C                          1585mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020095C                          1586mm 
0020095C  1A39 00C00003           1587mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200962  0805 0000               1588mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200966  6700 0010               1589mm     BEQ CONTINUE_100                                ; NOTHING, CONTINUE
0020096A                          1590mm  
0020096A                          1591mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0020096A                 TRUE     1592mmm     IFEQ DEBUG
0020096A  1A39 00C00007           1593mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200970                          1594mmm     ENDC
00200970                 FALSE    1595mmm     IFNE DEBUG
00200970                          1596mmm     ENDC
00200970                          1597mmm      
00200970  BA3C 001B               1598mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200974  6700 F692               1599mmm     BEQ START
00200978                          1600mmm     ENDM
00200978                          1601mm CONTINUE_100
00200978  1A39 00C00013           1602mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020097E  0805 0000               1603mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200982  67D8                    1604mm     BEQ WAIT_FOR_READY_100                          ; NOTHING, CHECK AGAIN
00200984                          1605mm     
00200984  1A39 00C00017           1606mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0020098A  13C5 00E00001           1607mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200990                          1608mm     
00200990                          1609mm     ENDM
00200990                          1610mm         PRINT_CHAR D5,D6
00200990                          1611mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200990                 TRUE     1612mm     IFEQ DEBUG
00200990  1C39 00C00003           1613mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200996  0806 0002               1614mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020099A  67F4                    1615mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
0020099C  13C5 00C00007           1616mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A2                          1617mm     ENDC
002009A2                          1618mm     
002009A2                 FALSE    1619mm     IFNE DEBUG
002009A2                          1620mm     ENDC
002009A2                          1621mm 
002009A2                          1622mm     ENDM
002009A2                          1623mm         HEX2BIN D5,D5,A4
002009A2  49F9 00200F5E           1624mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002009A8  0405 0030               1625mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009AC  CABC 000000FF           1626mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002009B2  1A34 5000               1627mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002009B6                          1628mm     ENDM
002009B6  8805                    1629m         OR.B D5,D4
002009B8  5307                    1630m         SUB.B #1,D7
002009BA                          1631m     ENDW
002009BA  6096                    1632ms     BRA _10000012
002009BC                          1633ms _10000013
002009BC                          1634m     
002009BC  7A00                    1635m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002009BE  1A04                    1636m     MOVE.B D4,D5
002009C0  D484                    1637m     ADD.L D4,D2
002009C2                          1638m 
002009C2                          1639m     ENDM
002009C2                          1640m     PRINT_CRLF D5
002009C2                          1641mm     PRINT_CHAR #13,D5                           ; CR
002009C2                          1642mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009C2                 TRUE     1643mm     IFEQ DEBUG
002009C2  1A39 00C00003           1644mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009C8  0805 0002               1645mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009CC  67F4                    1646mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
002009CE  13FC 000D 00C00007      1647mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009D6                          1648mm     ENDC
002009D6                          1649mm     
002009D6                 FALSE    1650mm     IFNE DEBUG
002009D6                          1651mm     ENDC
002009D6                          1652mm 
002009D6                          1653mm     ENDM
002009D6                          1654mm     PRINT_CHAR #10,D5                           ; LF
002009D6                          1655mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                 TRUE     1656mm     IFEQ DEBUG
002009D6  1A39 00C00003           1657mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009DC  0805 0002               1658mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009E0  67F4                    1659mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
002009E2  13FC 000A 00C00007      1660mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009EA                          1661mm     ENDC
002009EA                          1662mm     
002009EA                 FALSE    1663mm     IFNE DEBUG
002009EA                          1664mm     ENDC
002009EA                          1665mm 
002009EA                          1666mm     ENDM
002009EA                          1667m     ENDM
002009EA                          1668          
002009EA                          1669      IF.B D2 <NE> #$FF THEN.L
002009EA  B43C 00FF               1670s     CMP.B   #$FF,D2
002009EE  6700 00A4               1671s     BEQ.L   _0000000A
002009F2  49F9 00200F2A           1672          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
002009F8                          1673m         PRINT_STR A4,D5
002009F8                          1674m LOOP_107
002009F8  0C14 0000               1675m     CMP.B #0,(A4)                               ; 0 -> DONE
002009FC  6700 0016               1676m     BEQ EXIT_107
00200A00                          1677mm     PRINT_CHAR (A4)+,D5
00200A00                          1678mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A00                 TRUE     1679mm     IFEQ DEBUG
00200A00  1A39 00C00003           1680mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A06  0805 0002               1681mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A0A  67F4                    1682mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A0C  13DC 00C00007           1683mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200A12                          1684mm     ENDC
00200A12                          1685mm     
00200A12                 FALSE    1686mm     IFNE DEBUG
00200A12                          1687mm     ENDC
00200A12                          1688mm 
00200A12                          1689mm     ENDM
00200A12  60E4                    1690m     BRA LOOP_107
00200A14                          1691m EXIT_107
00200A14                          1692m     ENDM
00200A14                          1693m         PRINT_REG D0,D5,D2,D6,A4
00200A14                          1694mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200A14                          1695mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A14                 TRUE     1696mm     IFEQ DEBUG
00200A14  1A39 00C00003           1697mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A1A  0805 0002               1698mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A1E  67F4                    1699mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200A20  13FC 0030 00C00007      1700mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A28                          1701mm     ENDC
00200A28                          1702mm     
00200A28                 FALSE    1703mm     IFNE DEBUG
00200A28                          1704mm     ENDC
00200A28                          1705mm 
00200A28                          1706mm     ENDM
00200A28                          1707mm     PRINT_CHAR #'x',D5
00200A28                          1708mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A28                 TRUE     1709mm     IFEQ DEBUG
00200A28  1A39 00C00003           1710mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A2E  0805 0002               1711mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A32  67F4                    1712mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200A34  13FC 0078 00C00007      1713mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A3C                          1714mm     ENDC
00200A3C                          1715mm     
00200A3C                 FALSE    1716mm     IFNE DEBUG
00200A3C                          1717mm     ENDC
00200A3C                          1718mm 
00200A3C                          1719mm     ENDM
00200A3C  7C07                    1720m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200A3E                          1721m LOOP_109
00200A3E                          1722mm     BIN2HEX D0,D2,A4
00200A3E  49F9 00200F4E           1723mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200A44  E998                    1724mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200A46  1400                    1725mm     MOVE.B D0,D2
00200A48  0282 0000000F           1726mm     ANDI.L #$F,D2
00200A4E  1434 2000               1727mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200A52                          1728mm     ENDM
00200A52                          1729mm     PRINT_CHAR D2,D5
00200A52                          1730mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A52                 TRUE     1731mm     IFEQ DEBUG
00200A52  1A39 00C00003           1732mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A58  0805 0002               1733mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A5C  67F4                    1734mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00200A5E  13C2 00C00007           1735mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A64                          1736mm     ENDC
00200A64                          1737mm     
00200A64                 FALSE    1738mm     IFNE DEBUG
00200A64                          1739mm     ENDC
00200A64                          1740mm 
00200A64                          1741mm     ENDM
00200A64  57CE FFD8               1742m     DBEQ D6,LOOP_109
00200A68                          1743m     ENDM
00200A68                          1744m         PRINT_CRLF D5
00200A68                          1745mm     PRINT_CHAR #13,D5                           ; CR
00200A68                          1746mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A68                 TRUE     1747mm     IFEQ DEBUG
00200A68  1A39 00C00003           1748mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A6E  0805 0002               1749mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A72  67F4                    1750mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00200A74  13FC 000D 00C00007      1751mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A7C                          1752mm     ENDC
00200A7C                          1753mm     
00200A7C                 FALSE    1754mm     IFNE DEBUG
00200A7C                          1755mm     ENDC
00200A7C                          1756mm 
00200A7C                          1757mm     ENDM
00200A7C                          1758mm     PRINT_CHAR #10,D5                           ; LF
00200A7C                          1759mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A7C                 TRUE     1760mm     IFEQ DEBUG
00200A7C  1A39 00C00003           1761mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A82  0805 0002               1762mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A86  67F4                    1763mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200A88  13FC 000A 00C00007      1764mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A90                          1765mm     ENDC
00200A90                          1766mm     
00200A90                 FALSE    1767mm     IFNE DEBUG
00200A90                          1768mm     ENDC
00200A90                          1769mm 
00200A90                          1770mm     ENDM
00200A90                          1771m     ENDM
00200A90  6000 F6DE               1772          BRA MAIN_LOOP
00200A94                          1773      ENDI
00200A94                          1774s _0000000A
00200A94                          1775      
00200A94  4ED3                    1776      JMP (A3)
00200A96                          1777  DOWNLOAD_DONE
00200A96                          1778m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00200A96                          1779mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200A96                          1780mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A96                 TRUE     1781mm     IFEQ DEBUG
00200A96  1A39 00C00003           1782mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A9C  0805 0002               1783mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AA0  67F4                    1784mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200AA2  13FC 0030 00C00007      1785mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AAA                          1786mm     ENDC
00200AAA                          1787mm     
00200AAA                 FALSE    1788mm     IFNE DEBUG
00200AAA                          1789mm     ENDC
00200AAA                          1790mm 
00200AAA                          1791mm     ENDM
00200AAA                          1792mm     PRINT_CHAR #'x',D5
00200AAA                          1793mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAA                 TRUE     1794mm     IFEQ DEBUG
00200AAA  1A39 00C00003           1795mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AB0  0805 0002               1796mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AB4  67F4                    1797mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200AB6  13FC 0078 00C00007      1798mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200ABE                          1799mm     ENDC
00200ABE                          1800mm     
00200ABE                 FALSE    1801mm     IFNE DEBUG
00200ABE                          1802mm     ENDC
00200ABE                          1803mm 
00200ABE                          1804mm     ENDM
00200ABE  7407                    1805m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AC0                          1806m LOOP_117
00200AC0                          1807mm     BIN2HEX D0,D6,A1
00200AC0  43F9 00200F4E           1808mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200AC6  E998                    1809mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200AC8  1C00                    1810mm     MOVE.B D0,D6
00200ACA  0286 0000000F           1811mm     ANDI.L #$F,D6
00200AD0  1C31 6000               1812mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200AD4                          1813mm     ENDM
00200AD4                          1814mm     PRINT_CHAR D6,D5
00200AD4                          1815mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AD4                 TRUE     1816mm     IFEQ DEBUG
00200AD4  1A39 00C00003           1817mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200ADA  0805 0002               1818mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200ADE  67F4                    1819mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200AE0  13C6 00C00007           1820mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AE6                          1821mm     ENDC
00200AE6                          1822mm     
00200AE6                 FALSE    1823mm     IFNE DEBUG
00200AE6                          1824mm     ENDC
00200AE6                          1825mm 
00200AE6                          1826mm     ENDM
00200AE6  57CA FFD8               1827m     DBEQ D2,LOOP_117
00200AEA                          1828m     ENDM
00200AEA  43F9 00200EF1           1829      LEA READ,A1
00200AF0                          1830m     PRINT_STR A1,D5
00200AF0                          1831m LOOP_122
00200AF0  0C11 0000               1832m     CMP.B #0,(A1)                               ; 0 -> DONE
00200AF4  6700 0016               1833m     BEQ EXIT_122
00200AF8                          1834mm     PRINT_CHAR (A1)+,D5
00200AF8                          1835mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF8                 TRUE     1836mm     IFEQ DEBUG
00200AF8  1A39 00C00003           1837mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AFE  0805 0002               1838mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B02  67F4                    1839mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00200B04  13D9 00C00007           1840mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200B0A                          1841mm     ENDC
00200B0A                          1842mm     
00200B0A                 FALSE    1843mm     IFNE DEBUG
00200B0A                          1844mm     ENDC
00200B0A                          1845mm 
00200B0A                          1846mm     ENDM
00200B0A  60E4                    1847m     BRA LOOP_122
00200B0C                          1848m EXIT_122
00200B0C                          1849m     ENDM
00200B0C  2E08                    1850      MOVE.L A0,D7                                    ; set address accumulator to start address
00200B0E                          1851m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00200B0E                          1852mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200B0E                          1853mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0E                 TRUE     1854mm     IFEQ DEBUG
00200B0E  1A39 00C00003           1855mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B14  0805 0002               1856mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B18  67F4                    1857mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00200B1A  13FC 0030 00C00007      1858mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B22                          1859mm     ENDC
00200B22                          1860mm     
00200B22                 FALSE    1861mm     IFNE DEBUG
00200B22                          1862mm     ENDC
00200B22                          1863mm 
00200B22                          1864mm     ENDM
00200B22                          1865mm     PRINT_CHAR #'x',D5
00200B22                          1866mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B22                 TRUE     1867mm     IFEQ DEBUG
00200B22  1A39 00C00003           1868mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B28  0805 0002               1869mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B2C  67F4                    1870mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200B2E  13FC 0078 00C00007      1871mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B36                          1872mm     ENDC
00200B36                          1873mm     
00200B36                 FALSE    1874mm     IFNE DEBUG
00200B36                          1875mm     ENDC
00200B36                          1876mm 
00200B36                          1877mm     ENDM
00200B36  7407                    1878m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B38                          1879m LOOP_124
00200B38                          1880mm     BIN2HEX D7,D6,A1
00200B38  43F9 00200F4E           1881mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200B3E  E99F                    1882mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B40  1C07                    1883mm     MOVE.B D7,D6
00200B42  0286 0000000F           1884mm     ANDI.L #$F,D6
00200B48  1C31 6000               1885mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200B4C                          1886mm     ENDM
00200B4C                          1887mm     PRINT_CHAR D6,D5
00200B4C                          1888mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B4C                 TRUE     1889mm     IFEQ DEBUG
00200B4C  1A39 00C00003           1890mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B52  0805 0002               1891mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B56  67F4                    1892mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200B58  13C6 00C00007           1893mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B5E                          1894mm     ENDC
00200B5E                          1895mm     
00200B5E                 FALSE    1896mm     IFNE DEBUG
00200B5E                          1897mm     ENDC
00200B5E                          1898mm 
00200B5E                          1899mm     ENDM
00200B5E  57CA FFD8               1900m     DBEQ D2,LOOP_124
00200B62                          1901m     ENDM
00200B62                          1902m     PRINT_CRLF D5     
00200B62                          1903mm     PRINT_CHAR #13,D5                           ; CR
00200B62                          1904mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B62                 TRUE     1905mm     IFEQ DEBUG
00200B62  1A39 00C00003           1906mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B68  0805 0002               1907mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B6C  67F4                    1908mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00200B6E  13FC 000D 00C00007      1909mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B76                          1910mm     ENDC
00200B76                          1911mm     
00200B76                 FALSE    1912mm     IFNE DEBUG
00200B76                          1913mm     ENDC
00200B76                          1914mm 
00200B76                          1915mm     ENDM
00200B76                          1916mm     PRINT_CHAR #10,D5                           ; LF
00200B76                          1917mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B76                 TRUE     1918mm     IFEQ DEBUG
00200B76  1A39 00C00003           1919mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B7C  0805 0002               1920mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B80  67F4                    1921mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200B82  13FC 000A 00C00007      1922mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B8A                          1923mm     ENDC
00200B8A                          1924mm     
00200B8A                 FALSE    1925mm     IFNE DEBUG
00200B8A                          1926mm     ENDC
00200B8A                          1927mm 
00200B8A                          1928mm     ENDM
00200B8A                          1929m     ENDM
00200B8A                          1930          
00200B8A  6000 F5E4               1931      BRA MAIN_LOOP
00200B8E                          1932      
00200B8E                          1933  G
00200B8E  2047                    1934      MOVE.L D7,A0                                    ; address accumulator -> address register
00200B90  3E3C 0000               1935      MOVE #0,D7                                      ; clear the now used address accumulator
00200B94  4ED0                    1936      JMP (A0)                                        ; jump to it!
00200B96                          1937      
00200B96                          1938  Z
00200B96  207C 00200000           1939      MOVE.L #RAM,A0                                  ; address of RAM
00200B9C  7000                    1940      MOVE.L #0,D0                                    ; number of bytes
00200B9E                          1941     
00200B9E                          1942      WHILE.L D0 <LE> #$40000 DO                      ; read the data bytes
00200B9E                          1943s _10000014
00200B9E  B0BC 00040000           1944s     CMP.L   #$40000,D0
00200BA4  6E00 001A               1945s     BGT _10000015
00200BA8  2200                    1946          MOVE.L D0,D1                                ; progress update
00200BAA  E089                    1947          LSR.L #8,D1 
00200BAC  E089                    1948          LSR.L #8,D1
00200BAE  0281 0000000F           1949          ANDI.L #$F,D1
00200BB4  13C1 00E00001           1950          MOVE.B D1,DISPLAY
00200BBA                          1951  
00200BBA  20C0                    1952          MOVE.L D0,(A0)+ 
00200BBC  5880                    1953          ADD.L #4,D0
00200BBE                          1954      ENDW
00200BBE  60DE                    1955s     BRA _10000014
00200BC0                          1956s _10000015
00200BC0                          1957   
00200BC0  207C 00200000           1958      MOVE.L #RAM,A0                                  ; address of RAM
00200BC6  7000                    1959      MOVE.L #0,D0                                    ; number of bytes
00200BC8                          1960     
00200BC8                          1961      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200BC8                          1962s _10000016
00200BC8  B0BC 00040000           1963s     CMP.L   #$40000,D0
00200BCE  6E00 00C8               1964s     BGT _10000017
00200BD2  2200                    1965          MOVE.L D0,D1                            ; progress update
00200BD4  E089                    1966          LSR.L #8,D1
00200BD6  E089                    1967          LSR.L #8,D1
00200BD8  0281 0000000F           1968          ANDI.L #$F,D1
00200BDE  13C1 00E00001           1969          MOVE.B D1,DISPLAY
00200BE4                          1970  
00200BE4  2218                    1971          MOVE.L (A0)+,D1
00200BE6                          1972            
00200BE6                          1973          IF.L D0 <EQ> D1 THEN
00200BE6  B081                    1974s     CMP.L   D1,D0
00200BE8  6600 0006               1975s     BNE _0000000B
00200BEC  6000 00A4               1976              BRA OK
00200BF0                          1977          ENDI 
00200BF0                          1978s _0000000B
00200BF0                          1979            
00200BF0  43F9 00200F3C           1980          LEA RAM_ERROR,A1
00200BF6                          1981m         PRINT_STR A1,D1
00200BF6                          1982m LOOP_132
00200BF6  0C11 0000               1983m     CMP.B #0,(A1)                               ; 0 -> DONE
00200BFA  6700 0016               1984m     BEQ EXIT_132
00200BFE                          1985mm     PRINT_CHAR (A1)+,D1
00200BFE                          1986mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1987mm     IFEQ DEBUG
00200BFE  1239 00C00003           1988mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200C04  0801 0002               1989mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1990mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200C0A  13D9 00C00007           1991mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200C10                          1992mm     ENDC
00200C10                          1993mm     
00200C10                 FALSE    1994mm     IFNE DEBUG
00200C10                          1995mm     ENDC
00200C10                          1996mm 
00200C10                          1997mm     ENDM
00200C10  60E4                    1998m     BRA LOOP_132
00200C12                          1999m EXIT_132
00200C12                          2000m     ENDM
00200C12  2208                    2001          MOVE.L A0,D1
00200C14  5981                    2002          SUB.L #4,D1
00200C16                          2003m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200C16                          2004mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00200C16                          2005mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C16                 TRUE     2006mm     IFEQ DEBUG
00200C16  1639 00C00003           2007mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C1C  0803 0002               2008mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C20  67F4                    2009mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00200C22  13FC 0030 00C00007      2010mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C2A                          2011mm     ENDC
00200C2A                          2012mm     
00200C2A                 FALSE    2013mm     IFNE DEBUG
00200C2A                          2014mm     ENDC
00200C2A                          2015mm 
00200C2A                          2016mm     ENDM
00200C2A                          2017mm     PRINT_CHAR #'x',D3
00200C2A                          2018mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C2A                 TRUE     2019mm     IFEQ DEBUG
00200C2A  1639 00C00003           2020mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C30  0803 0002               2021mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C34  67F4                    2022mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C36  13FC 0078 00C00007      2023mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C3E                          2024mm     ENDC
00200C3E                          2025mm     
00200C3E                 FALSE    2026mm     IFNE DEBUG
00200C3E                          2027mm     ENDC
00200C3E                          2028mm 
00200C3E                          2029mm     ENDM
00200C3E  7C07                    2030m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200C40                          2031m LOOP_134
00200C40                          2032mm     BIN2HEX D1,D2,A1
00200C40  43F9 00200F4E           2033mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200C46  E999                    2034mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200C48  1401                    2035mm     MOVE.B D1,D2
00200C4A  0282 0000000F           2036mm     ANDI.L #$F,D2
00200C50  1431 2000               2037mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200C54                          2038mm     ENDM
00200C54                          2039mm     PRINT_CHAR D2,D3
00200C54                          2040mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C54                 TRUE     2041mm     IFEQ DEBUG
00200C54  1639 00C00003           2042mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C5A  0803 0002               2043mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C5E  67F4                    2044mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200C60  13C2 00C00007           2045mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C66                          2046mm     ENDC
00200C66                          2047mm     
00200C66                 FALSE    2048mm     IFNE DEBUG
00200C66                          2049mm     ENDC
00200C66                          2050mm 
00200C66                          2051mm     ENDM
00200C66  57CE FFD8               2052m     DBEQ D6,LOOP_134
00200C6A                          2053m     ENDM
00200C6A                          2054m         PRINT_CRLF D3
00200C6A                          2055mm     PRINT_CHAR #13,D3                           ; CR
00200C6A                          2056mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6A                 TRUE     2057mm     IFEQ DEBUG
00200C6A  1639 00C00003           2058mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C70  0803 0002               2059mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C74  67F4                    2060mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00200C76  13FC 000D 00C00007      2061mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C7E                          2062mm     ENDC
00200C7E                          2063mm     
00200C7E                 FALSE    2064mm     IFNE DEBUG
00200C7E                          2065mm     ENDC
00200C7E                          2066mm 
00200C7E                          2067mm     ENDM
00200C7E                          2068mm     PRINT_CHAR #10,D3                           ; LF
00200C7E                          2069mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C7E                 TRUE     2070mm     IFEQ DEBUG
00200C7E  1639 00C00003           2071mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C84  0803 0002               2072mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C88  67F4                    2073mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200C8A  13FC 000A 00C00007      2074mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C92                          2075mm     ENDC
00200C92                          2076mm     
00200C92                 FALSE    2077mm     IFNE DEBUG
00200C92                          2078mm     ENDC
00200C92                          2079mm 
00200C92                          2080mm     ENDM
00200C92                          2081m     ENDM
00200C92                          2082  OK    
00200C92  5880                    2083          ADD.L #4,D0
00200C94                          2084      ENDW
00200C94  6000 FF32               2085s     BRA _10000016
00200C98                          2086s _10000017
00200C98                          2087      
00200C98  6000 F4D6               2088      BRA MAIN_LOOP
00200C9C                          2089    
00200C9C                          2090  L
00200C9C  7A00                    2091      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00200C9E                          2092  
00200C9E                          2093m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200C9E                          2094m WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C9E                 TRUE     2095m     IFEQ DEBUG
00200C9E  1639 00C00003           2096m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200CA4  0803 0000               2097m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200CA8  67F4                    2098m         BEQ WAIT_FOR_READY_142                      ; NOTHING, CHECK AGAIN
00200CAA                          2099m     ENDC
00200CAA                          2100m     
00200CAA                          2101mm     READ_CHAR D2
00200CAA                 TRUE     2102mm     IFEQ DEBUG
00200CAA  1439 00C00007           2103mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200CB0                          2104mm     ENDC
00200CB0                 FALSE    2105mm     IFNE DEBUG
00200CB0                          2106mm     ENDC
00200CB0                          2107mm      
00200CB0  B43C 001B               2108mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CB4  6700 F352               2109mm     BEQ START
00200CB8                          2110mm     ENDM
00200CB8                          2111m 
00200CB8                 TRUE     2112m     IFEQ DEBUG
00200CB8                          2113mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200CB8                          2114mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CB8                 TRUE     2115mm     IFEQ DEBUG
00200CB8  1639 00C00003           2116mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CBE  0803 0002               2117mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC2  67F4                    2118mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200CC4  13C2 00C00007           2119mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CCA                          2120mm     ENDC
00200CCA                          2121mm     
00200CCA                 FALSE    2122mm     IFNE DEBUG
00200CCA                          2123mm     ENDC
00200CCA                          2124mm 
00200CCA                          2125mm     ENDM
00200CCA                          2126m     ENDC
00200CCA                          2127m     ENDM
00200CCA                          2128m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200CCA  41F9 00200F5E           2129m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200CD0  0402 0030               2130m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200CD4  C4BC 000000FF           2131m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200CDA  1430 2000               2132m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200CDE                          2133m     ENDM
00200CDE  1A02                    2134      MOVE.B D2,D5                                    ; put at bottom of D5
00200CE0                          2135  
00200CE0  3C3C 0002               2136      MOVE #2,D6                                      ; 3 bytes left to read
00200CE4                          2137      
00200CE4                          2138  READ_LENGTH
00200CE4  E98D                    2139      LSL.L #4,D5                                     ; make what we have so far more significant
00200CE6                          2140m     WAIT_CHAR D2,D3                                 ; next character -> D2
00200CE6                          2141m WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE6                 TRUE     2142m     IFEQ DEBUG
00200CE6  1639 00C00003           2143m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200CEC  0803 0000               2144m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200CF0  67F4                    2145m         BEQ WAIT_FOR_READY_146                      ; NOTHING, CHECK AGAIN
00200CF2                          2146m     ENDC
00200CF2                          2147m     
00200CF2                          2148mm     READ_CHAR D2
00200CF2                 TRUE     2149mm     IFEQ DEBUG
00200CF2  1439 00C00007           2150mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200CF8                          2151mm     ENDC
00200CF8                 FALSE    2152mm     IFNE DEBUG
00200CF8                          2153mm     ENDC
00200CF8                          2154mm      
00200CF8  B43C 001B               2155mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFC  6700 F30A               2156mm     BEQ START
00200D00                          2157mm     ENDM
00200D00                          2158m 
00200D00                 TRUE     2159m     IFEQ DEBUG
00200D00                          2160mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200D00                          2161mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D00                 TRUE     2162mm     IFEQ DEBUG
00200D00  1639 00C00003           2163mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D06  0803 0002               2164mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D0A  67F4                    2165mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00200D0C  13C2 00C00007           2166mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D12                          2167mm     ENDC
00200D12                          2168mm     
00200D12                 FALSE    2169mm     IFNE DEBUG
00200D12                          2170mm     ENDC
00200D12                          2171mm 
00200D12                          2172mm     ENDM
00200D12                          2173m     ENDC
00200D12                          2174m     ENDM
00200D12                          2175m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200D12  41F9 00200F5E           2176m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200D18  0402 0030               2177m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D1C  C4BC 000000FF           2178m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200D22  1430 2000               2179m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200D26                          2180m     ENDM
00200D26  8A02                    2181      OR.B D2,D5  
00200D28  023C 00FB               2182      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200D2C  57CE FFB6               2183      DBEQ D6,READ_LENGTH
00200D30                          2184          
00200D30                          2185m     PRINT_CRLF D3
00200D30                          2186mm     PRINT_CHAR #13,D3                           ; CR
00200D30                          2187mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D30                 TRUE     2188mm     IFEQ DEBUG
00200D30  1639 00C00003           2189mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D36  0803 0002               2190mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D3A  67F4                    2191mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00200D3C  13FC 000D 00C00007      2192mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D44                          2193mm     ENDC
00200D44                          2194mm     
00200D44                 FALSE    2195mm     IFNE DEBUG
00200D44                          2196mm     ENDC
00200D44                          2197mm 
00200D44                          2198mm     ENDM
00200D44                          2199mm     PRINT_CHAR #10,D3                           ; LF
00200D44                          2200mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D44                 TRUE     2201mm     IFEQ DEBUG
00200D44  1639 00C00003           2202mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D4A  0803 0002               2203mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D4E  67F4                    2204mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00200D50  13FC 000A 00C00007      2205mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D58                          2206mm     ENDC
00200D58                          2207mm     
00200D58                 FALSE    2208mm     IFNE DEBUG
00200D58                          2209mm     ENDC
00200D58                          2210mm 
00200D58                          2211mm     ENDM
00200D58                          2212m     ENDM
00200D58                          2213  
00200D58  207C 00000000           2214      MOVE.L #ROM,A0                                  ; start of ROM
00200D5E                          2215      
00200D5E  2247                    2216      MOVE.L D7,A1                                    ; address accumulator -> address register
00200D60  7E00                    2217      MOVE.L #0,D7                                    ; clear the now used address accumulator
00200D62                          2218      
00200D62  267C 00002AAA           2219      MOVE.L #$2AAA,A3
00200D68  36BC AAAA               2220      MOVE.W #$AAAA,(A3)
00200D6C  267C 00001554           2221      MOVE.L #$1554,A3
00200D72  36BC 5555               2222      MOVE.W #$5555,(A3)
00200D76  267C 00002AAA           2223      MOVE.L #$2AAA,A3
00200D7C  36BC 8080               2224      MOVE.W #$8080,(A3)
00200D80  267C 00002AAA           2225      MOVE.L #$2AAA,A3
00200D86  36BC AAAA               2226      MOVE.W #$AAAA,(A3)
00200D8A  267C 00001554           2227      MOVE.L #$1554,A3
00200D90  36BC 5555               2228      MOVE.W #$5555,(A3)
00200D94  267C 00002AAA           2229      MOVE.L #$2AAA,A3
00200D9A  36BC 2020               2230      MOVE.W #$2020,(A3)
00200D9E                          2231      
00200D9E  45F9 00200F75           2232      LEA LOADING,A2                              ; important for timing
00200DA4                          2233m     PRINT_STR A2,D3
00200DA4                          2234m LOOP_153
00200DA4  0C12 0000               2235m     CMP.B #0,(A2)                               ; 0 -> DONE
00200DA8  6700 0016               2236m     BEQ EXIT_153
00200DAC                          2237mm     PRINT_CHAR (A2)+,D3
00200DAC                          2238mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DAC                 TRUE     2239mm     IFEQ DEBUG
00200DAC  1639 00C00003           2240mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DB2  0803 0002               2241mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DB6  67F4                    2242mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200DB8  13DA 00C00007           2243mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200DBE                          2244mm     ENDC
00200DBE                          2245mm     
00200DBE                 FALSE    2246mm     IFNE DEBUG
00200DBE                          2247mm     ENDC
00200DBE                          2248mm 
00200DBE                          2249mm     ENDM
00200DBE  60E4                    2250m     BRA LOOP_153
00200DC0                          2251m EXIT_153
00200DC0                          2252m     ENDM
00200DC0                          2253  
00200DC0  023C 00FB               2254      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200DC4                          2255      
00200DC4                          2256      WHILE D5 <GT> #0 DO
00200DC4                          2257s _10000018
00200DC4  BA7C 0000               2258s     CMP.W   #0,D5
00200DC8  6F00 001C               2259s     BLE _10000019
00200DCC  5585                    2260          SUB.L #2,D5
00200DCE                          2261            
00200DCE  13D1 00E00001           2262          MOVE.B (A1),DISPLAY
00200DD4  3091                    2263          MOVE.W (A1),(A0)                            ; write the data
00200DD6                          2264        
00200DD6                          2265  WAIT_FOR_COMPLETE
00200DD6  3410                    2266          MOVE.W (A0),D2
00200DD8                          2267  
00200DD8                          2268          IF D2 <NE> (A1) THEN
00200DD8  B451                    2269s     CMP.W   (A1),D2
00200DDA  6700 0004               2270s     BEQ _0000000C
00200DDE  60F6                    2271              BRA WAIT_FOR_COMPLETE
00200DE0                          2272          ENDI
00200DE0                          2273s _0000000C
00200DE0                          2274        
00200DE0  5488                    2275          ADD.L #2,A0
00200DE2  5489                    2276          ADD.L #2,A1
00200DE4                          2277      ENDW  
00200DE4  60DE                    2278s     BRA _10000018
00200DE6                          2279s _10000019
00200DE6                          2280      
00200DE6  267C 00002AAA           2281      MOVE.L #$2AAA,A3
00200DEC  36BC AAAA               2282      MOVE.W #$AAAA,(A3)
00200DF0  267C 00001554           2283      MOVE.L #$1554,A3
00200DF6  36BC 5555               2284      MOVE.W #$5555,(A3)
00200DFA  267C 00002AAA           2285      MOVE.L #$2AAA,A3
00200E00  36BC A0A0               2286      MOVE.W #$A0A0,(A3)
00200E04                          2287              
00200E04  6000 F36A               2288      BRA MAIN_LOOP
00200E08                          2289          
00200E08                          2290  HEX_DIGIT
00200E08  E98F                    2291      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200E0A                          2292m     HEX2BIN D2,D2,A0
00200E0A  41F9 00200F5E           2293m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200E10  0402 0030               2294m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E14  C4BC 000000FF           2295m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200E1A  1430 2000               2296m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200E1E                          2297m     ENDM
00200E1E  8E02                    2298      OR.B D2,D7  
00200E20  6000 F376               2299      BRA GET_INPUT
00200E24                          2300  
00200E24  FFFF FFFF               2301      SIMHALT                                         ; halt simulator
00200E28                          2302  
00200E28                          2303  ; strings
00200E28= 4D 44 46 2D 6D 6F ...   2304  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',13,10,0
00200E45= 3F 20 48 65 6C 70 ...   2305  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00200EEA= 48 75 68 3F 0D 0A 00    2306  HUH     DC.B 'Huh?',13,10,0
00200EF1= 20 53 20 72 65 63 ...   2307  READ    DC.B ' S records read, start address = ',0
00200F13= 57 3A 20 55 6E 6B ...   2308  UNREC   DC.B 'W: Unknown Srec type: ',0
00200F2A= 57 3A 20 43 53 20 ...   2309  CS_FAILURE   DC.B 'W: CS failure at ',0
00200F3C= 57 3A 20 52 41 4D ...   2310  RAM_ERROR DC.B 'W: RAM error at: ',0
00200F4E= 30 31 32 33 34 35 ...   2311  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00200F5E= 00 01 02 03 04 05 ...   2312  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00200F75= 4C 6F 61 64 69 6E ...   2313  LOADING  DC.B 'Loading EEPROM...',13,11,0
00200F89                          2314      
00200F89                          2315      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200F4E
CONTINUE_100        200978
CONTINUE_41         20041A
CONTINUE_44         20046A
CONTINUE_48         2004C2
CONTINUE_56         200580
CONTINUE_61         2005F4
CONTINUE_66         200672
CONTINUE_71         2006F6
CONTINUE_76         200786
CONTINUE_81         2007FA
CONTINUE_86         20086E
CS_FAILURE          200F2A
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            992
DOWNLOAD_BYTE       C77
DOWNLOAD_DONE       200A96
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_107            200A14
EXIT_122            200B0C
EXIT_132            200C12
EXIT_153            200DC0
EXIT_18             200276
EXIT_20             2002A6
EXIT_5              20013E
EXIT_93             20090E
G                   200B8E
GET_INPUT           200198
H                   20027A
HELP                200E45
HEX2BIN             134
HEX2BIN_LUT         200F5E
HEX_DIGIT           200E08
HUH                 200EEA
L                   200C9C
LOADING             200F75
LOOP_107            2009F8
LOOP_109            200A3E
LOOP_117            200AC0
LOOP_122            200AF0
LOOP_124            200B38
LOOP_132            200BF6
LOOP_134            200C40
LOOP_153            200DA4
LOOP_18             20025A
LOOP_20             20028A
LOOP_22             2002D8
LOOP_5              200122
LOOP_93             2008F2
MAIN_LOOP           200170
OK                  200C92
PRINTSTR            20028A
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           585
PRINT_STR           4FF
R                   2002AA
RAM                 200000
RAM_ERROR           200F3C
READ                200EF1
READ_CHAR           82C
READ_DATA_TO_POKE   200378
READ_LENGTH         200CE4
RESET               200004
ROM                 0
S                   2003F6
STACK               200000
START               200008
UNREC               200F13
V                   200284
VERSION             200E28
W                   200330
WAIT_CHAR           67D
WAIT_FOR_COMPLETE   200DD6
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   200170
WAIT_FOR_READY_100  20095C
WAIT_FOR_READY_102  200990
WAIT_FOR_READY_105  2009C2
WAIT_FOR_READY_106  2009D6
WAIT_FOR_READY_108  200A00
WAIT_FOR_READY_11   200184
WAIT_FOR_READY_110  200A14
WAIT_FOR_READY_111  200A28
WAIT_FOR_READY_113  200A52
WAIT_FOR_READY_115  200A68
WAIT_FOR_READY_116  200A7C
WAIT_FOR_READY_118  200A96
WAIT_FOR_READY_119  200AAA
WAIT_FOR_READY_12   200198
WAIT_FOR_READY_121  200AD4
WAIT_FOR_READY_123  200AF8
WAIT_FOR_READY_125  200B0E
WAIT_FOR_READY_126  200B22
WAIT_FOR_READY_128  200B4C
WAIT_FOR_READY_130  200B62
WAIT_FOR_READY_131  200B76
WAIT_FOR_READY_133  200BFE
WAIT_FOR_READY_135  200C16
WAIT_FOR_READY_136  200C2A
WAIT_FOR_READY_138  200C54
WAIT_FOR_READY_14   2001B2
WAIT_FOR_READY_140  200C6A
WAIT_FOR_READY_141  200C7E
WAIT_FOR_READY_142  200C9E
WAIT_FOR_READY_144  200CB8
WAIT_FOR_READY_146  200CE6
WAIT_FOR_READY_148  200D00
WAIT_FOR_READY_151  200D30
WAIT_FOR_READY_152  200D44
WAIT_FOR_READY_154  200DAC
WAIT_FOR_READY_16   2001FC
WAIT_FOR_READY_17   200210
WAIT_FOR_READY_19   200262
WAIT_FOR_READY_21   200292
WAIT_FOR_READY_23   2002AE
WAIT_FOR_READY_24   2002C2
WAIT_FOR_READY_26   2002EC
WAIT_FOR_READY_28   200302
WAIT_FOR_READY_29   200316
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_30   200332
WAIT_FOR_READY_32   20034C
WAIT_FOR_READY_34   20037A
WAIT_FOR_READY_36   200394
WAIT_FOR_READY_39   2003CA
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_40   2003DE
WAIT_FOR_READY_41   2003FE
WAIT_FOR_READY_43   200438
WAIT_FOR_READY_44   20044E
WAIT_FOR_READY_46   200482
WAIT_FOR_READY_48   2004A6
WAIT_FOR_READY_50   2004DA
WAIT_FOR_READY_53   200514
WAIT_FOR_READY_54   200528
WAIT_FOR_READY_56   200564
WAIT_FOR_READY_58   200598
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   2005D8
WAIT_FOR_READY_63   20060C
WAIT_FOR_READY_66   200656
WAIT_FOR_READY_68   20068A
WAIT_FOR_READY_71   2006DA
WAIT_FOR_READY_73   20070E
WAIT_FOR_READY_76   20076A
WAIT_FOR_READY_78   20079E
WAIT_FOR_READY_8    20013E
WAIT_FOR_READY_81   2007DE
WAIT_FOR_READY_83   200812
WAIT_FOR_READY_86   200852
WAIT_FOR_READY_88   200886
WAIT_FOR_READY_9    200152
WAIT_FOR_READY_91   2008C4
WAIT_FOR_READY_92   2008D8
WAIT_FOR_READY_94   2008FA
WAIT_FOR_READY_95   20090E
WAIT_FOR_READY_97   200920
WAIT_FOR_READY_98   200934
WAIT_FOR_SRECORD    2003FE
Z                   200B96
_00000000           2001D8
_00000001           2001EC
_00000002           200544
_00000003           20094C
_00000004           200552
_00000005           200752
_00000006           2006BC
_00000007           20094C
_00000008           2008C4
_00000009           20094C
_0000000A           200A94
_0000000B           200BF0
_0000000C           200DE0
_10000000           20049C
_10000001           200506
_10000002           20055A
_10000003           2005C4
_10000004           2005CE
_10000005           200638
_10000006           20064C
_10000007           2006B6
_10000008           2006C0
_10000009           200748
_1000000A           2006D0
_1000000B           20073A
_1000000C           200760
_1000000D           2007CA
_1000000E           2007D4
_1000000F           20083E
_10000010           200848
_10000011           2008B2
_10000012           200952
_10000013           2009BC
_10000014           200B9E
_10000015           200BC0
_10000016           200BC8
_10000017           200C98
_10000018           200DC4
_10000019           200DE6
