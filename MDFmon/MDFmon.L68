00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 15:03:16

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; add command to write to eeprom to back patch start address
00000000                             9  ; shared code between load and patch
00000000                            10  ; tidy up comments again, sigh
00000000                            11  ; also garbage on serial port when starting
00000000                            12  ; use DBLoop?
00000000                            13  
00000000                            14  
00000000                            15  ; ideas, but no room to do them
00000000                            16  ;------------------------------
00000000                            17  ; keep track of highest address hit during srec download
00000000                            18  ; implement backspace
00000000                            19  ; fix being able to enter random chars when W'ing
00000000                            20  ; ram check at startup?  Not sure if this is a good idea!
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  
00000000                            23      ORG  $0
00000000                            24  
00000000  =00000000                 25  DEBUG               EQU 0
00000000                            26  
00000000                            27  ; constants
00000000  =00000000                 28  NULL                EQU 0
00000000  =00000009                 29  TAB                 EQU 9
00000000  =0000000D                 30  CR                  EQU 13
00000000  =0000000A                 31  LF                  EQU 10
00000000                            32  
00000000  =00000000                 33  ROM                 EQU $0
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35     
00000000  =00C00000                 36  DUART_BASE          EQU $C00000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  
00000000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           110          BTST #2,\2                              ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           113      ENDC
00000000                           114      
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll, /2 = working address register
00000000                           125  PRINT_CRLF MACRO
00000000                           126      LEA CRLF(PC),\2
00000000                           127      PRINT_STR \2,\1
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      BRA LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           143  PRINT_REG MACRO
00000000                           144      LEA ox(PC),\5
00000000                           145      PRINT_STR \5,\2
00000000                           146      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152      
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                            ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                    ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           195      BTST #0,\1                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           201      BTST #0,\1                                      ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; read two hex digits from the download serial port and convert to a byte
00000000                           210  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           211  DOWNLOAD_BYTE MACRO
00000000                           212      MOVE.B #2,\4
00000000                           213      WHILE.B \4 <GT> 0 DO
00000000                           214          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           215          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           216          PRINT_CHAR \2,\3
00000000                           217          HEX2BIN \2,\2,\6
00000000                           218          OR.B \2,\1
00000000                           219          SUB.B #1,\4
00000000                           220      ENDW
00000000                           221      
00000000                           222      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           223      MOVE.B \1,\2
00000000                           224      ADD.L \1,\5
00000000                           225  
00000000                           226      ENDM
00000000                           227      
00000000                           228  ; write word to EEPROM
00000000                           229  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           230  PROGRAM MACRO
00000000                           231    MOVE.W \1,\2                          ; write the data
00000000                           232        
00000000                           233  WAIT_FOR_COMPLETE\@
00000000                           234          MOVE.W \2,\3
00000000                           235  
00000000                           236          IF.W \3 <NE> \1 THEN
00000000                           237              BRA WAIT_FOR_COMPLETE\@
00000000                           238          ENDI
00000000                           239          ENDM
00000000                           240          
00000000                           241  ; register catalogue
00000000                           242  ; D0 - used for simulator I/O
00000000                           243  ; D1 - used for simulator I/O
00000000                           244  ; D2 - read character
00000000                           245  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           246  ; D6 - working register used in R/W
00000000                           247  ; D7 - address accumulator, reset by download
00000000                           248  ; A0 - address of string to print 
00000000                           249  
00000000                           250  ; start vector
00000000= 00000000                 251  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 252  RESET    DC.L START                             ; RESET
00000008                           253      
00000008                           254  ; start of program  
00000008                           255  START
00000008  13FC 0000 00E00001       256      MOVE.B #0,DISPLAY
00000010                           257  
00000010                           258  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       259      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       260      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           261      
00000020                           262      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                263s     MOVE.W  #$50,D1
00000024  6000 000E                264s     BRA _20000001
00000028                           265s _20000000
00000028  13C1 00C00005            266          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     267          NOP
00000030                           268      ENDF
00000030  0441 0010                269s     SUB.W   #$10,D1
00000034                           270s _20000001
00000034  B27C 0010                271s     CMP.W   #$10,D1
00000038  6CEE                     272s     BGE _20000000
0000003A                           273  
0000003A                           274      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                275s     MOVE.W  #$50,D1
0000003E  6000 000E                276s     BRA _20000003
00000042                           277s _20000002
00000042  13C1 00C00015            278          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     279          NOP
0000004A                           280      ENDF
0000004A  0441 0010                281s     SUB.W   #$10,D1
0000004E                           282s _20000003
0000004E  B27C 0010                283s     CMP.W   #$10,D1
00000052  6CEE                     284s     BGE _20000002
00000054                           285    
00000054                           286  ;initialise UART
00000054  13FC 0000 00C00009       287      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       288      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       289      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           290  
0000006C                           291  ; channel A
0000006C  13FC 0013 00C00001       292      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       293      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       294      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       295      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           296  
0000008C                           297  ; channel B
0000008C  13FC 0013 00C00011       298      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       299      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       300      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       301      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           302  
000000AC                           303      ;PRINT_CHAR '.',D3                              ; give the serial port chance to settle after reset
000000AC                           304  
000000AC  13FC 0001 00E00001       305      MOVE.B #1,DISPLAY
000000B4                           306         
000000B4                           307m     PRINT_CRLF D3,A0
000000B4  41FA 1071                308m     LEA CRLF(PC),A0
000000B8                           309mm     PRINT_STR A0,D3
000000B8                           310mm LOOP_2
000000B8  0C10 0000                311mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000BC  6700 0016                312mm     BEQ EXIT_2
000000C0                           313mmm     PRINT_CHAR (A0)+,D3
000000C0                           314mmm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      315mmm     IFEQ DEBUG
000000C0  1639 00C00003            316mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000C6  0803 0002                317mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000CA  67F4                     318mmm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
000000CC  13D8 00C00007            319mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000D2                           320mmm     ENDC
000000D2                           321mmm     
000000D2                 FALSE     322mmm     IFNE DEBUG
000000D2                           323mmm     ENDC
000000D2                           324mmm 
000000D2                           325mmm     ENDM
000000D2  60E4                     326mm     BRA LOOP_2
000000D4                           327mm EXIT_2
000000D4                           328mm     ENDM
000000D4                           329m     ENDM
000000D4                           330  
000000D4  41FA 0EB2                331      LEA VERSION(PC),A0
000000D8                           332m     PRINT_STR A0,D3
000000D8                           333m LOOP_4
000000D8  0C10 0000                334m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000DC  6700 0016                335m     BEQ EXIT_4
000000E0                           336mm     PRINT_CHAR (A0)+,D3
000000E0                           337mm WAIT_FOR_READY_5                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E0                 TRUE      338mm     IFEQ DEBUG
000000E0  1639 00C00003            339mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000E6  0803 0002                340mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000EA  67F4                     341mm         BEQ WAIT_FOR_READY_5                    ; NO SPACE, CHECK AGAIN
000000EC  13D8 00C00007            342mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000F2                           343mm     ENDC
000000F2                           344mm     
000000F2                 FALSE     345mm     IFNE DEBUG
000000F2                           346mm     ENDC
000000F2                           347mm 
000000F2                           348mm     ENDM
000000F2  60E4                     349m     BRA LOOP_4
000000F4                           350m EXIT_4
000000F4                           351m     ENDM
000000F4                           352      
000000F4  41FA 0EAF                353      LEA HELPPROMPT(PC),A0
000000F8                           354m     PRINT_STR A0,D3
000000F8                           355m LOOP_6
000000F8  0C10 0000                356m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FC  6700 0016                357m     BEQ EXIT_6
00000100                           358mm     PRINT_CHAR (A0)+,D3
00000100                           359mm WAIT_FOR_READY_7                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000100                 TRUE      360mm     IFEQ DEBUG
00000100  1639 00C00003            361mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000106  0803 0002                362mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010A  67F4                     363mm         BEQ WAIT_FOR_READY_7                    ; NO SPACE, CHECK AGAIN
0000010C  13D8 00C00007            364mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000112                           365mm     ENDC
00000112                           366mm     
00000112                 FALSE     367mm     IFNE DEBUG
00000112                           368mm     ENDC
00000112                           369mm 
00000112                           370mm     ENDM
00000112  60E4                     371m     BRA LOOP_6
00000114                           372m EXIT_6
00000114                           373m     ENDM
00000114                           374      
00000114                           375m     PRINT_CRLF D3,A0
00000114  41FA 1011                376m     LEA CRLF(PC),A0
00000118                           377mm     PRINT_STR A0,D3
00000118                           378mm LOOP_9
00000118  0C10 0000                379mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000011C  6700 0016                380mm     BEQ EXIT_9
00000120                           381mmm     PRINT_CHAR (A0)+,D3
00000120                           382mmm WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000120                 TRUE      383mmm     IFEQ DEBUG
00000120  1639 00C00003            384mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000126  0803 0002                385mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012A  67F4                     386mmm         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0000012C  13D8 00C00007            387mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000132                           388mmm     ENDC
00000132                           389mmm     
00000132                 FALSE     390mmm     IFNE DEBUG
00000132                           391mmm     ENDC
00000132                           392mmm 
00000132                           393mmm     ENDM
00000132  60E4                     394mm     BRA LOOP_9
00000134                           395mm EXIT_9
00000134                           396mm     ENDM
00000134                           397m     ENDM
00000134                           398  
00000134  7E00                     399      MOVE.L #0,D7                                    ; address accumulator
00000136                           400  
00000136  13FC 0002 00E00001       401      MOVE.B #2,DISPLAY
0000013E                           402  MAIN_LOOP
0000013E  41FA 0FEA                403      LEA PROMPT(PC),A0
00000142                           404m     PRINT_STR A0,D3
00000142                           405m LOOP_11
00000142  0C10 0000                406m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000146  6700 0016                407m     BEQ EXIT_11
0000014A                           408mm     PRINT_CHAR (A0)+,D3
0000014A                           409mm WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000014A                 TRUE      410mm     IFEQ DEBUG
0000014A  1639 00C00003            411mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000150  0803 0002                412mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000154  67F4                     413mm         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
00000156  13D8 00C00007            414mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000015C                           415mm     ENDC
0000015C                           416mm     
0000015C                 FALSE     417mm     IFNE DEBUG
0000015C                           418mm     ENDC
0000015C                           419mm 
0000015C                           420mm     ENDM
0000015C  60E4                     421m     BRA LOOP_11
0000015E                           422m EXIT_11
0000015E                           423m     ENDM
0000015E                           424      
0000015E                           425  GET_INPUT
0000015E                           426m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015E                           427m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015E                 TRUE      428m     IFEQ DEBUG
0000015E  1639 00C00003            429m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000164  0803 0000                430m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000168  67F4                     431m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
0000016A                           432m     ENDC
0000016A                           433m     
0000016A                           434mm     READ_CHAR D2
0000016A                 TRUE      435mm     IFEQ DEBUG
0000016A  1439 00C00007            436mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000170                           437mm     ENDC
00000170                 FALSE     438mm     IFNE DEBUG
00000170                           439mm     ENDC
00000170                           440mm      
00000170  B43C 001B                441mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000174  6700 FE92                442mm     BEQ START
00000178                           443mm     ENDM
00000178                           444m 
00000178                 TRUE      445m     IFEQ DEBUG
00000178                           446mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000178                           447mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      448mm     IFEQ DEBUG
00000178  1639 00C00003            449mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                450mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     451mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
00000184  13C2 00C00007            452mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000018A                           453mm     ENDC
0000018A                           454mm     
0000018A                 FALSE     455mm     IFNE DEBUG
0000018A                           456mm     ENDC
0000018A                           457mm 
0000018A                           458mm     ENDM
0000018A                           459m     ENDC
0000018A                           460m     ENDM
0000018A                           461      
0000018A                           462      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000018A  B43C 0030                463s     CMP.B   #'0',D2
0000018E  6D00 000E                464s     BLT _00000000
00000192  B43C 0039                465s     CMP.B   #'9',D2
00000196  6E00 0006                466s     BGT _00000000
0000019A  6000 0DCE                467          BRA HEX_DIGIT
0000019E                           468      ENDI
0000019E                           469s _00000000
0000019E                           470      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019E  B43C 0041                471s     CMP.B   #'A',D2
000001A2  6D00 000E                472s     BLT _00000001
000001A6  B43C 0046                473s     CMP.B   #'F',D2
000001AA  6E00 0006                474s     BGT _00000001
000001AE  6000 0DBA                475          BRA HEX_DIGIT
000001B2                           476      ENDI
000001B2                           477s _00000001
000001B2                           478          
000001B2  B43C 0077                479      CMP.B #'w',D2
000001B6  6700 0126                480      BEQ W
000001BA                           481      
000001BA  B43C 006C                482      CMP.B #'l',D2
000001BE  6700 09A8                483      BEQ L 
000001C2                           484  
000001C2  B43C 0070                485      CMP.B #'p',D2
000001C6  6700 0BD0                486      BEQ P
000001CA                           487  
000001CA                           488m     PRINT_CRLF D3,A0
000001CA  41FA 0F5B                489m     LEA CRLF(PC),A0
000001CE                           490mm     PRINT_STR A0,D3
000001CE                           491mm LOOP_17
000001CE  0C10 0000                492mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001D2  6700 0016                493mm     BEQ EXIT_17
000001D6                           494mmm     PRINT_CHAR (A0)+,D3
000001D6                           495mmm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001D6                 TRUE      496mmm     IFEQ DEBUG
000001D6  1639 00C00003            497mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001DC  0803 0002                498mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001E0  67F4                     499mmm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
000001E2  13D8 00C00007            500mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001E8                           501mmm     ENDC
000001E8                           502mmm     
000001E8                 FALSE     503mmm     IFNE DEBUG
000001E8                           504mmm     ENDC
000001E8                           505mmm 
000001E8                           506mmm     ENDM
000001E8  60E4                     507mm     BRA LOOP_17
000001EA                           508mm EXIT_17
000001EA                           509mm     ENDM
000001EA                           510m     ENDM
000001EA                           511   
000001EA  B43C 003F                512      CMP.B #'?',D2
000001EE  6700 004E                513      BEQ H
000001F2                           514   
000001F2  B43C 0076                515      CMP.B #'v',D2
000001F6  6700 004E                516      BEQ V
000001FA                           517      
000001FA  B43C 0072                518      CMP.B #'r',D2
000001FE  6700 006A                519      BEQ R
00000202                           520  
00000202  B43C 0073                521      CMP.B #'s',D2
00000206  6700 014A                522      BEQ S
0000020A                           523  
0000020A  B43C 0067                524      CMP.B #'g',D2
0000020E  6700 086E                525      BEQ G   
00000212                           526  
00000212  B43C 007A                527      CMP.B #'z',D2
00000216  6700 086E                528      BEQ Z   
0000021A                           529  
0000021A  41FA 0E6C                530      LEA HUH(PC),A0
0000021E                           531m     PRINT_STR A0,D3
0000021E                           532m LOOP_19
0000021E  0C10 0000                533m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000222  6700 0016                534m     BEQ EXIT_19
00000226                           535mm     PRINT_CHAR (A0)+,D3
00000226                           536mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000226                 TRUE      537mm     IFEQ DEBUG
00000226  1639 00C00003            538mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000022C  0803 0002                539mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000230  67F4                     540mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
00000232  13D8 00C00007            541mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000238                           542mm     ENDC
00000238                           543mm     
00000238                 FALSE     544mm     IFNE DEBUG
00000238                           545mm     ENDC
00000238                           546mm 
00000238                           547mm     ENDM
00000238  60E4                     548m     BRA LOOP_19
0000023A                           549m EXIT_19
0000023A                           550m     ENDM
0000023A                           551                         
0000023A  6000 FF02                552      BRA MAIN_LOOP
0000023E                           553      
0000023E                           554  ; commands
0000023E                           555  H   
0000023E  41FA 0D78                556      LEA HELP(PC),A0
00000242  6000 0006                557      BRA PRINTSTR
00000246                           558  
00000246                           559  V   
00000246  41FA 0D40                560      LEA VERSION(PC),A0
0000024A                           561  PRINTSTR
0000024A                           562m     PRINT_STR A0,D3       
0000024A                           563m LOOP_21
0000024A  0C10 0000                564m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024E  6700 0016                565m     BEQ EXIT_21
00000252                           566mm     PRINT_CHAR (A0)+,D3
00000252                           567mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000252                 TRUE      568mm     IFEQ DEBUG
00000252  1639 00C00003            569mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000258  0803 0002                570mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000025C  67F4                     571mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0000025E  13D8 00C00007            572mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000264                           573mm     ENDC
00000264                           574mm     
00000264                 FALSE     575mm     IFNE DEBUG
00000264                           576mm     ENDC
00000264                           577mm 
00000264                           578mm     ENDM
00000264  60E4                     579m     BRA LOOP_21
00000266                           580m EXIT_21
00000266                           581m     ENDM
00000266  6000 FED6                582      BRA MAIN_LOOP
0000026A                           583      
0000026A                           584  R   
0000026A  2047                     585      MOVE.L D7,A0                                    ; address accumulator -> address register
0000026C  7E00                     586      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000026E  2410                     587      MOVE.L (A0),D2                                  ; read the memory and print it
00000270                           588m     PRINT_REG D2,D3,D4,D5,A0
00000270  41FA 0EBB                589m     LEA OX(PC),A0
00000274                           590mm     PRINT_STR A0,D3
00000274                           591mm LOOP_24
00000274  0C10 0000                592mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000278  6700 0016                593mm     BEQ EXIT_24
0000027C                           594mmm     PRINT_CHAR (A0)+,D3
0000027C                           595mmm WAIT_FOR_READY_25                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      596mmm     IFEQ DEBUG
0000027C  1639 00C00003            597mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000282  0803 0002                598mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000286  67F4                     599mmm         BEQ WAIT_FOR_READY_25                   ; NO SPACE, CHECK AGAIN
00000288  13D8 00C00007            600mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028E                           601mmm     ENDC
0000028E                           602mmm     
0000028E                 FALSE     603mmm     IFNE DEBUG
0000028E                           604mmm     ENDC
0000028E                           605mmm 
0000028E                           606mmm     ENDM
0000028E  60E4                     607mm     BRA LOOP_24
00000290                           608mm EXIT_24
00000290                           609mm     ENDM
00000290  7A07                     610m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000292                           611m LOOP_23
00000292                           612mm     BIN2HEX D2,D4,A0
00000292  41FA 0E58                613mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
00000296  E99A                     614mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000298  1802                     615mm     MOVE.B D2,D4
0000029A  0284 0000000F            616mm     ANDI.L #$F,D4
000002A0  1830 4000                617mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
000002A4                           618mm     ENDM
000002A4                           619mm     PRINT_CHAR D4,D3
000002A4                           620mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002A4                 TRUE      621mm     IFEQ DEBUG
000002A4  1639 00C00003            622mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002AA  0803 0002                623mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002AE  67F4                     624mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002B0  13C4 00C00007            625mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002B6                           626mm     ENDC
000002B6                           627mm     
000002B6                 FALSE     628mm     IFNE DEBUG
000002B6                           629mm     ENDC
000002B6                           630mm 
000002B6                           631mm     ENDM
000002B6  57CD FFDA                632m     DBEQ D5,LOOP_23
000002BA                           633m     ENDM
000002BA                           634m     PRINT_CRLF D3,A0
000002BA  41FA 0E6B                635m     LEA CRLF(PC),A0
000002BE                           636mm     PRINT_STR A0,D3
000002BE                           637mm LOOP_29
000002BE  0C10 0000                638mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002C2  6700 0016                639mm     BEQ EXIT_29
000002C6                           640mmm     PRINT_CHAR (A0)+,D3
000002C6                           641mmm WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C6                 TRUE      642mmm     IFEQ DEBUG
000002C6  1639 00C00003            643mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002CC  0803 0002                644mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D0  67F4                     645mmm         BEQ WAIT_FOR_READY_30                   ; NO SPACE, CHECK AGAIN
000002D2  13D8 00C00007            646mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D8                           647mmm     ENDC
000002D8                           648mmm     
000002D8                 FALSE     649mmm     IFNE DEBUG
000002D8                           650mmm     ENDC
000002D8                           651mmm 
000002D8                           652mmm     ENDM
000002D8  60E4                     653mm     BRA LOOP_29
000002DA                           654mm EXIT_29
000002DA                           655mm     ENDM
000002DA                           656m     ENDM
000002DA  6000 FE62                657      BRA MAIN_LOOP
000002DE                           658  
000002DE                           659  W
000002DE  3C3C 0007                660      MOVE #7,D6                                      ; 7 bytes left to read
000002E2                           661      
000002E2                           662  READ_DATA_TO_POKE
000002E2  E98D                     663      LSL.L #4,D5                                     ; make what we have so far more significant
000002E4                           664m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002E4                           665m WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E4                 TRUE      666m     IFEQ DEBUG
000002E4  1639 00C00003            667m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EA  0803 0000                668m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002EE  67F4                     669m         BEQ WAIT_FOR_READY_31                   ; NOTHING, CHECK AGAIN
000002F0                           670m     ENDC
000002F0                           671m     
000002F0                           672mm     READ_CHAR D2
000002F0                 TRUE      673mm     IFEQ DEBUG
000002F0  1439 00C00007            674mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002F6                           675mm     ENDC
000002F6                 FALSE     676mm     IFNE DEBUG
000002F6                           677mm     ENDC
000002F6                           678mm      
000002F6  B43C 001B                679mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002FA  6700 FD0C                680mm     BEQ START
000002FE                           681mm     ENDM
000002FE                           682m 
000002FE                 TRUE      683m     IFEQ DEBUG
000002FE                           684mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000002FE                           685mm WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      686mm     IFEQ DEBUG
000002FE  1639 00C00003            687mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000304  0803 0002                688mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000308  67F4                     689mm         BEQ WAIT_FOR_READY_33                   ; NO SPACE, CHECK AGAIN
0000030A  13C2 00C00007            690mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000310                           691mm     ENDC
00000310                           692mm     
00000310                 FALSE     693mm     IFNE DEBUG
00000310                           694mm     ENDC
00000310                           695mm 
00000310                           696mm     ENDM
00000310                           697m     ENDC
00000310                           698m     ENDM
00000310                           699m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000310  41FA 0DEA                700m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000314  0402 0030                701m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000318  C4BC 000000FF            702m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000031E  1430 2000                703m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000322                           704m     ENDM
00000322  8A02                     705      OR.B D2,D5
00000324  57CE FFBC                706      DBEQ D6,READ_DATA_TO_POKE
00000328                           707      
00000328  2047                     708      MOVE.L D7,A0                                    ; address accumulator -> address register
0000032A  7E00                     709      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000032C                           710      
0000032C  2085                     711      MOVE.L D5,(A0)                                  ; write the data
0000032E                           712  
0000032E                           713m     PRINT_CRLF D3,A0
0000032E  41FA 0DF7                714m     LEA CRLF(PC),A0
00000332                           715mm     PRINT_STR A0,D3
00000332                           716mm LOOP_36
00000332  0C10 0000                717mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000336  6700 0016                718mm     BEQ EXIT_36
0000033A                           719mmm     PRINT_CHAR (A0)+,D3
0000033A                           720mmm WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033A                 TRUE      721mmm     IFEQ DEBUG
0000033A  1639 00C00003            722mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000340  0803 0002                723mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000344  67F4                     724mmm         BEQ WAIT_FOR_READY_37                   ; NO SPACE, CHECK AGAIN
00000346  13D8 00C00007            725mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000034C                           726mmm     ENDC
0000034C                           727mmm     
0000034C                 FALSE     728mmm     IFNE DEBUG
0000034C                           729mmm     ENDC
0000034C                           730mmm 
0000034C                           731mmm     ENDM
0000034C  60E4                     732mm     BRA LOOP_36
0000034E                           733mm EXIT_36
0000034E                           734mm     ENDM
0000034E                           735m     ENDM
0000034E  6000 FDEE                736      BRA MAIN_LOOP
00000352                           737  
00000352                           738  ; register map for S
00000352                           739  ; A0 - start address
00000352                           740  ; A1 - offset
00000352                           741  ; A2 - next address to write
00000352                           742  ; A3 - next location (jmp)
00000352                           743  ; A4 - Working Address Register
00000352                           744  ; D0 - record count
00000352                           745  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000352                           746  ; D2 - checksum
00000352                           747  ; D3 - data byte count
00000352                           748  ; D4 - read address, moved into A2
00000352                           749  ; D5 - temp
00000352                           750  ; D6 - temp
00000352                           751  ; D7 - temp
00000352                           752  S
00000352  2078 0000                753      MOVE.L 0,A0                                     ; start address -> A0
00000356  2247                     754      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000358                           755      
00000358  7000                     756      MOVE.L #0,D0                                    ; count of records read -> D0
0000035A                           757          
0000035A                           758  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000035A                           759m     DOWNLOAD D1                 
0000035A                           760m WAIT_FOR_READY_38                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                           761m 
0000035A  1239 00C00003            762m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000360  0801 0000                763m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000364  6700 0010                764m     BEQ CONTINUE_38                             ; NOTHING, CONTINUE
00000368                           765m  
00000368                           766mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000368                 TRUE      767mm     IFEQ DEBUG
00000368  1239 00C00007            768mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000036E                           769mm     ENDC
0000036E                 FALSE     770mm     IFNE DEBUG
0000036E                           771mm     ENDC
0000036E                           772mm      
0000036E  B23C 001B                773mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000372  6700 FC94                774mm     BEQ START
00000376                           775mm     ENDM
00000376                           776m CONTINUE_38
00000376  1239 00C00013            777m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000037C  0801 0000                778m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000380  67D8                     779m     BEQ WAIT_FOR_READY_38                           ; NOTHING, CHECK AGAIN
00000382                           780m     
00000382  1239 00C00017            781m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000388  13C1 00E00001            782m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000038E                           783m     
0000038E                           784m     ENDM
0000038E  B23C 0053                785      CMP.B #'S',D1                                   ; found S?    
00000392  66C6                     786      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000394                           787      
00000394                           788m     PRINT_CHAR #'S',D5                            ; print the S
00000394                           789m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000394                 TRUE      790m     IFEQ DEBUG
00000394  1A39 00C00003            791m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000039A  0805 0002                792m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000039E  67F4                     793m         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
000003A0  13FC 0053 00C00007       794m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003A8                           795m     ENDC
000003A8                           796m     
000003A8                 FALSE     797m     IFNE DEBUG
000003A8                           798m     ENDC
000003A8                           799m 
000003A8                           800m     ENDM
000003A8  5280                     801      ADD.L #1,D0                                     ; read another S record, increment count
000003AA                           802      
000003AA                           803m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003AA                           804m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AA                           805m 
000003AA  1239 00C00003            806m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003B0  0801 0000                807m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003B4  6700 0010                808m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
000003B8                           809m  
000003B8                           810mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003B8                 TRUE      811mm     IFEQ DEBUG
000003B8  1239 00C00007            812mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003BE                           813mm     ENDC
000003BE                 FALSE     814mm     IFNE DEBUG
000003BE                           815mm     ENDC
000003BE                           816mm      
000003BE  B23C 001B                817mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003C2  6700 FC44                818mm     BEQ START
000003C6                           819mm     ENDM
000003C6                           820m CONTINUE_41
000003C6  1239 00C00013            821m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003CC  0801 0000                822m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003D0  67D8                     823m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003D2                           824m     
000003D2  1239 00C00017            825m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003D8  13C1 00E00001            826m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003DE                           827m     
000003DE                           828m     ENDM
000003DE                           829m     PRINT_CHAR D1,D5
000003DE                           830m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DE                 TRUE      831m     IFEQ DEBUG
000003DE  1A39 00C00003            832m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003E4  0805 0002                833m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003E8  67F4                     834m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
000003EA  13C1 00C00007            835m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003F0                           836m     ENDC
000003F0                           837m     
000003F0                 FALSE     838m     IFNE DEBUG
000003F0                           839m     ENDC
000003F0                           840m 
000003F0                           841m     ENDM
000003F0                           842  
000003F0  7400                     843      MOVE.L #0,D2                                    ; clear the checksum
000003F2                           844  
000003F2                           845m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003F2  1E3C 0002                846m     MOVE.B #2,D7
000003F6                           847m     WHILE.B D7 <GT> 0 DO
000003F6                           848ms _10000000
000003F6  BE38 0000                849ms     CMP.B   0,D7
000003FA  6F00 0062                850ms     BLE _10000001
000003FE  E98B                     851m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000400                           852mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000400                           853mm WAIT_FOR_READY_45                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000400                           854mm 
00000400  1A39 00C00003            855mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000406  0805 0000                856mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000040A  6700 0010                857mm     BEQ CONTINUE_45                             ; NOTHING, CONTINUE
0000040E                           858mm  
0000040E                           859mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000040E                 TRUE      860mmm     IFEQ DEBUG
0000040E  1A39 00C00007            861mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000414                           862mmm     ENDC
00000414                 FALSE     863mmm     IFNE DEBUG
00000414                           864mmm     ENDC
00000414                           865mmm      
00000414  BA3C 001B                866mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                867mmm     BEQ START
0000041C                           868mmm     ENDM
0000041C                           869mm CONTINUE_45
0000041C  1A39 00C00013            870mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000422  0805 0000                871mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000426  67D8                     872mm     BEQ WAIT_FOR_READY_45                           ; NOTHING, CHECK AGAIN
00000428                           873mm     
00000428  1A39 00C00017            874mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000042E  13C5 00E00001            875mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000434                           876mm     
00000434                           877mm     ENDM
00000434                           878mm         PRINT_CHAR D5,D6
00000434                           879mm WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000434                 TRUE      880mm     IFEQ DEBUG
00000434  1C39 00C00003            881mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000043A  0806 0002                882mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000043E  67F4                     883mm         BEQ WAIT_FOR_READY_47                   ; NO SPACE, CHECK AGAIN
00000440  13C5 00C00007            884mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000446                           885mm     ENDC
00000446                           886mm     
00000446                 FALSE     887mm     IFNE DEBUG
00000446                           888mm     ENDC
00000446                           889mm 
00000446                           890mm     ENDM
00000446                           891mm         HEX2BIN D5,D5,A4
00000446  49FA 0CB4                892mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000044A  0405 0030                893mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000044E  CABC 000000FF            894mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000454  1A34 5000                895mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000458                           896mm     ENDM
00000458  8605                     897m         OR.B D5,D3
0000045A  5307                     898m         SUB.B #1,D7
0000045C                           899m     ENDW
0000045C  6098                     900ms     BRA _10000000
0000045E                           901ms _10000001
0000045E                           902m     
0000045E  7A00                     903m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000460  1A03                     904m     MOVE.B D3,D5
00000462  D483                     905m     ADD.L D3,D2
00000464                           906m 
00000464                           907m     ENDM
00000464                           908  
00000464                           909      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000464  B23C 0030                910s     CMP.B   #'0',D1
00000468  6600 002A                911s     BNE.L   _00000002
0000046C                           912m         PRINT_CRLF D5,A4
0000046C  49FA 0CB9                913m     LEA CRLF(PC),A4
00000470                           914mm     PRINT_STR A4,D5
00000470                           915mm LOOP_50
00000470  0C14 0000                916mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000474  6700 0016                917mm     BEQ EXIT_50
00000478                           918mmm     PRINT_CHAR (A4)+,D5
00000478                           919mmm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000478                 TRUE      920mmm     IFEQ DEBUG
00000478  1A39 00C00003            921mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000047E  0805 0002                922mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000482  67F4                     923mmm         BEQ WAIT_FOR_READY_51                   ; NO SPACE, CHECK AGAIN
00000484  13DC 00C00007            924mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000048A                           925mmm     ENDC
0000048A                           926mmm     
0000048A                 FALSE     927mmm     IFNE DEBUG
0000048A                           928mmm     ENDC
0000048A                           929mmm 
0000048A                           930mmm     ENDM
0000048A  60E4                     931mm     BRA LOOP_50
0000048C                           932mm EXIT_50
0000048C                           933mm     ENDM
0000048C                           934m     ENDM
0000048C  6000 FECC                935          BRA WAIT_FOR_SRECORD
00000490                           936      ELSE
00000490  6000 03DE                937s     BRA _00000003
00000494                           938s _00000002
00000494                           939          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00000494  B23C 0031                940s     CMP.B   #'1',D1
00000498  6708                     941s     BEQ.S   _00000004
0000049A  B23C 0032                942s     CMP.B   #'2',D1
0000049E  6600 01F0                943s     BNE.L   _00000005
000004A2                           944s _00000004
000004A2  5783                     945              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004A4                           946      
000004A4  7800                     947              MOVE.L #0,D4                            ; read two bytes of address
000004A6                           948m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004A6  1E3C 0002                949m     MOVE.B #2,D7
000004AA                           950m     WHILE.B D7 <GT> 0 DO
000004AA                           951ms _10000002
000004AA  BE38 0000                952ms     CMP.B   0,D7
000004AE  6F00 0062                953ms     BLE _10000003
000004B2  E98C                     954m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004B4                           955mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004B4                           956mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B4                           957mm 
000004B4  1A39 00C00003            958mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004BA  0805 0000                959mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004BE  6700 0010                960mm     BEQ CONTINUE_53                             ; NOTHING, CONTINUE
000004C2                           961mm  
000004C2                           962mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004C2                 TRUE      963mmm     IFEQ DEBUG
000004C2  1A39 00C00007            964mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C8                           965mmm     ENDC
000004C8                 FALSE     966mmm     IFNE DEBUG
000004C8                           967mmm     ENDC
000004C8                           968mmm      
000004C8  BA3C 001B                969mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004CC  6700 FB3A                970mmm     BEQ START
000004D0                           971mmm     ENDM
000004D0                           972mm CONTINUE_53
000004D0  1A39 00C00013            973mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004D6  0805 0000                974mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004DA  67D8                     975mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004DC                           976mm     
000004DC  1A39 00C00017            977mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004E2  13C5 00E00001            978mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E8                           979mm     
000004E8                           980mm     ENDM
000004E8                           981mm         PRINT_CHAR D5,D6
000004E8                           982mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE      983mm     IFEQ DEBUG
000004E8  1C39 00C00003            984mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004EE  0806 0002                985mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004F2  67F4                     986mm         BEQ WAIT_FOR_READY_55                   ; NO SPACE, CHECK AGAIN
000004F4  13C5 00C00007            987mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004FA                           988mm     ENDC
000004FA                           989mm     
000004FA                 FALSE     990mm     IFNE DEBUG
000004FA                           991mm     ENDC
000004FA                           992mm 
000004FA                           993mm     ENDM
000004FA                           994mm         HEX2BIN D5,D5,A4
000004FA  49FA 0C00                995mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004FE  0405 0030                996mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000502  CABC 000000FF            997mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000508  1A34 5000                998mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000050C                           999mm     ENDM
0000050C  8805                    1000m         OR.B D5,D4
0000050E  5307                    1001m         SUB.B #1,D7
00000510                          1002m     ENDW
00000510  6098                    1003ms     BRA _10000002
00000512                          1004ms _10000003
00000512                          1005m     
00000512  7A00                    1006m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000514  1A04                    1007m     MOVE.B D4,D5
00000516  D484                    1008m     ADD.L D4,D2
00000518                          1009m 
00000518                          1010m     ENDM
00000518                          1011m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000518  1E3C 0002               1012m     MOVE.B #2,D7
0000051C                          1013m     WHILE.B D7 <GT> 0 DO
0000051C                          1014ms _10000004
0000051C  BE38 0000               1015ms     CMP.B   0,D7
00000520  6F00 0062               1016ms     BLE _10000005
00000524  E98C                    1017m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000526                          1018mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000526                          1019mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                          1020mm 
00000526  1A39 00C00003           1021mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000052C  0805 0000               1022mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000530  6700 0010               1023mm     BEQ CONTINUE_58                             ; NOTHING, CONTINUE
00000534                          1024mm  
00000534                          1025mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000534                 TRUE     1026mmm     IFEQ DEBUG
00000534  1A39 00C00007           1027mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000053A                          1028mmm     ENDC
0000053A                 FALSE    1029mmm     IFNE DEBUG
0000053A                          1030mmm     ENDC
0000053A                          1031mmm      
0000053A  BA3C 001B               1032mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000053E  6700 FAC8               1033mmm     BEQ START
00000542                          1034mmm     ENDM
00000542                          1035mm CONTINUE_58
00000542  1A39 00C00013           1036mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000548  0805 0000               1037mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000054C  67D8                    1038mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
0000054E                          1039mm     
0000054E  1A39 00C00017           1040mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000554  13C5 00E00001           1041mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000055A                          1042mm     
0000055A                          1043mm     ENDM
0000055A                          1044mm         PRINT_CHAR D5,D6
0000055A                          1045mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000055A                 TRUE     1046mm     IFEQ DEBUG
0000055A  1C39 00C00003           1047mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000560  0806 0002               1048mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000564  67F4                    1049mm         BEQ WAIT_FOR_READY_60                   ; NO SPACE, CHECK AGAIN
00000566  13C5 00C00007           1050mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000056C                          1051mm     ENDC
0000056C                          1052mm     
0000056C                 FALSE    1053mm     IFNE DEBUG
0000056C                          1054mm     ENDC
0000056C                          1055mm 
0000056C                          1056mm     ENDM
0000056C                          1057mm         HEX2BIN D5,D5,A4
0000056C  49FA 0B8E               1058mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000570  0405 0030               1059mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000574  CABC 000000FF           1060mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000057A  1A34 5000               1061mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000057E                          1062mm     ENDM
0000057E  8805                    1063m         OR.B D5,D4
00000580  5307                    1064m         SUB.B #1,D7
00000582                          1065m     ENDW
00000582  6098                    1066ms     BRA _10000004
00000584                          1067ms _10000005
00000584                          1068m     
00000584  7A00                    1069m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000586  1A04                    1070m     MOVE.B D4,D5
00000588  D484                    1071m     ADD.L D4,D2
0000058A                          1072m 
0000058A                          1073m     ENDM
0000058A                          1074              
0000058A                          1075              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
0000058A  B23C 0032               1076s     CMP.B   #'2',D1
0000058E  6600 0076               1077s     BNE.L   _00000006
00000592  5383                    1078                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000594                          1079m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00000594  1E3C 0002               1080m     MOVE.B #2,D7
00000598                          1081m     WHILE.B D7 <GT> 0 DO
00000598                          1082ms _10000006
00000598  BE38 0000               1083ms     CMP.B   0,D7
0000059C  6F00 0062               1084ms     BLE _10000007
000005A0  E98C                    1085m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005A2                          1086mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005A2                          1087mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A2                          1088mm 
000005A2  1A39 00C00003           1089mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005A8  0805 0000               1090mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005AC  6700 0010               1091mm     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
000005B0                          1092mm  
000005B0                          1093mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005B0                 TRUE     1094mmm     IFEQ DEBUG
000005B0  1A39 00C00007           1095mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005B6                          1096mmm     ENDC
000005B6                 FALSE    1097mmm     IFNE DEBUG
000005B6                          1098mmm     ENDC
000005B6                          1099mmm      
000005B6  BA3C 001B               1100mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005BA  6700 FA4C               1101mmm     BEQ START
000005BE                          1102mmm     ENDM
000005BE                          1103mm CONTINUE_63
000005BE  1A39 00C00013           1104mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005C4  0805 0000               1105mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005C8  67D8                    1106mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005CA                          1107mm     
000005CA  1A39 00C00017           1108mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005D0  13C5 00E00001           1109mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005D6                          1110mm     
000005D6                          1111mm     ENDM
000005D6                          1112mm         PRINT_CHAR D5,D6
000005D6                          1113mm WAIT_FOR_READY_65                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D6                 TRUE     1114mm     IFEQ DEBUG
000005D6  1C39 00C00003           1115mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005DC  0806 0002               1116mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005E0  67F4                    1117mm         BEQ WAIT_FOR_READY_65                   ; NO SPACE, CHECK AGAIN
000005E2  13C5 00C00007           1118mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005E8                          1119mm     ENDC
000005E8                          1120mm     
000005E8                 FALSE    1121mm     IFNE DEBUG
000005E8                          1122mm     ENDC
000005E8                          1123mm 
000005E8                          1124mm     ENDM
000005E8                          1125mm         HEX2BIN D5,D5,A4
000005E8  49FA 0B12               1126mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005EC  0405 0030               1127mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005F0  CABC 000000FF           1128mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005F6  1A34 5000               1129mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005FA                          1130mm     ENDM
000005FA  8805                    1131m         OR.B D5,D4
000005FC  5307                    1132m         SUB.B #1,D7
000005FE                          1133m     ENDW
000005FE  6098                    1134ms     BRA _10000006
00000600                          1135ms _10000007
00000600                          1136m     
00000600  7A00                    1137m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000602  1A04                    1138m     MOVE.B D4,D5
00000604  D484                    1139m     ADD.L D4,D2
00000606                          1140m 
00000606                          1141m     ENDM
00000606                          1142              ENDI
00000606                          1143s _00000006
00000606                          1144              
00000606  2444                    1145                  MOVE.L D4,A2                            ; put the address in an address register
00000608  D5C9                    1146              ADD.L A1,A2                             ; add in the offset
0000060A                          1147  
0000060A                          1148              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000060A                          1149s _10000008
0000060A  B63C 0000               1150s     CMP.B   #0,D3
0000060E  6F00 007A               1151s     BLE _10000009
00000612                          1152m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000612  1E3C 0002               1153m     MOVE.B #2,D7
00000616                          1154m     WHILE.B D7 <GT> 0 DO
00000616                          1155ms _1000000A
00000616  BE38 0000               1156ms     CMP.B   0,D7
0000061A  6F00 0062               1157ms     BLE _1000000B
0000061E  E989                    1158m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000620                          1159mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000620                          1160mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                          1161mm 
00000620  1A39 00C00003           1162mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000626  0805 0000               1163mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000062A  6700 0010               1164mm     BEQ CONTINUE_68                             ; NOTHING, CONTINUE
0000062E                          1165mm  
0000062E                          1166mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000062E                 TRUE     1167mmm     IFEQ DEBUG
0000062E  1A39 00C00007           1168mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000634                          1169mmm     ENDC
00000634                 FALSE    1170mmm     IFNE DEBUG
00000634                          1171mmm     ENDC
00000634                          1172mmm      
00000634  BA3C 001B               1173mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000638  6700 F9CE               1174mmm     BEQ START
0000063C                          1175mmm     ENDM
0000063C                          1176mm CONTINUE_68
0000063C  1A39 00C00013           1177mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000642  0805 0000               1178mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000646  67D8                    1179mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
00000648                          1180mm     
00000648  1A39 00C00017           1181mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000064E  13C5 00E00001           1182mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000654                          1183mm     
00000654                          1184mm     ENDM
00000654                          1185mm         PRINT_CHAR D5,D6
00000654                          1186mm WAIT_FOR_READY_70                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000654                 TRUE     1187mm     IFEQ DEBUG
00000654  1C39 00C00003           1188mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000065A  0806 0002               1189mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000065E  67F4                    1190mm         BEQ WAIT_FOR_READY_70                   ; NO SPACE, CHECK AGAIN
00000660  13C5 00C00007           1191mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000666                          1192mm     ENDC
00000666                          1193mm     
00000666                 FALSE    1194mm     IFNE DEBUG
00000666                          1195mm     ENDC
00000666                          1196mm 
00000666                          1197mm     ENDM
00000666                          1198mm         HEX2BIN D5,D5,A4
00000666  49FA 0A94               1199mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000066A  0405 0030               1200mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000066E  CABC 000000FF           1201mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000674  1A34 5000               1202mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000678                          1203mm     ENDM
00000678  8205                    1204m         OR.B D5,D1
0000067A  5307                    1205m         SUB.B #1,D7
0000067C                          1206m     ENDW
0000067C  6098                    1207ms     BRA _1000000A
0000067E                          1208ms _1000000B
0000067E                          1209m     
0000067E  7A00                    1210m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000680  1A01                    1211m     MOVE.B D1,D5
00000682  D481                    1212m     ADD.L D1,D2
00000684                          1213m 
00000684                          1214m     ENDM
00000684                          1215                          
00000684  14C1                    1216                  MOVE.B D1,(A2)+                     ; store it!
00000686                          1217  
00000686  5303                    1218                  SUB.B #1,D3                      ; 1 less byte to go
00000688                          1219              ENDW
00000688  6080                    1220s     BRA _10000008
0000068A                          1221s _10000009
0000068A                          1222          
0000068A  7200                    1223              MOVE.L #0,D1                         ; not done yet
0000068C                          1224          ELSE
0000068C  6000 01E2               1225s     BRA _00000007
00000690                          1226s _00000005
00000690                          1227              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000690  B23C 0038               1228s     CMP.B   #'8',D1
00000694  6600 0164               1229s     BNE.L   _00000008
00000698  7800                    1230                  MOVE.L #0,D4                    ; read the 24 bit start address
0000069A                          1231m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0000069A  1E3C 0002               1232m     MOVE.B #2,D7
0000069E                          1233m     WHILE.B D7 <GT> 0 DO
0000069E                          1234ms _1000000C
0000069E  BE38 0000               1235ms     CMP.B   0,D7
000006A2  6F00 0062               1236ms     BLE _1000000D
000006A6  E98C                    1237m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006A8                          1238mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006A8                          1239mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A8                          1240mm 
000006A8  1A39 00C00003           1241mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006AE  0805 0000               1242mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006B2  6700 0010               1243mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
000006B6                          1244mm  
000006B6                          1245mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006B6                 TRUE     1246mmm     IFEQ DEBUG
000006B6  1A39 00C00007           1247mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006BC                          1248mmm     ENDC
000006BC                 FALSE    1249mmm     IFNE DEBUG
000006BC                          1250mmm     ENDC
000006BC                          1251mmm      
000006BC  BA3C 001B               1252mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006C0  6700 F946               1253mmm     BEQ START
000006C4                          1254mmm     ENDM
000006C4                          1255mm CONTINUE_73
000006C4  1A39 00C00013           1256mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006CA  0805 0000               1257mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006CE  67D8                    1258mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
000006D0                          1259mm     
000006D0  1A39 00C00017           1260mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006D6  13C5 00E00001           1261mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006DC                          1262mm     
000006DC                          1263mm     ENDM
000006DC                          1264mm         PRINT_CHAR D5,D6
000006DC                          1265mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DC                 TRUE     1266mm     IFEQ DEBUG
000006DC  1C39 00C00003           1267mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006E2  0806 0002               1268mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006E6  67F4                    1269mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
000006E8  13C5 00C00007           1270mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006EE                          1271mm     ENDC
000006EE                          1272mm     
000006EE                 FALSE    1273mm     IFNE DEBUG
000006EE                          1274mm     ENDC
000006EE                          1275mm 
000006EE                          1276mm     ENDM
000006EE                          1277mm         HEX2BIN D5,D5,A4
000006EE  49FA 0A0C               1278mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006F2  0405 0030               1279mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006F6  CABC 000000FF           1280mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006FC  1A34 5000               1281mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000700                          1282mm     ENDM
00000700  8805                    1283m         OR.B D5,D4
00000702  5307                    1284m         SUB.B #1,D7
00000704                          1285m     ENDW
00000704  6098                    1286ms     BRA _1000000C
00000706                          1287ms _1000000D
00000706                          1288m     
00000706  7A00                    1289m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000708  1A04                    1290m     MOVE.B D4,D5
0000070A  D484                    1291m     ADD.L D4,D2
0000070C                          1292m 
0000070C                          1293m     ENDM
0000070C                          1294m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
0000070C  1E3C 0002               1295m     MOVE.B #2,D7
00000710                          1296m     WHILE.B D7 <GT> 0 DO
00000710                          1297ms _1000000E
00000710  BE38 0000               1298ms     CMP.B   0,D7
00000714  6F00 0062               1299ms     BLE _1000000F
00000718  E98C                    1300m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000071A                          1301mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071A                          1302mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071A                          1303mm 
0000071A  1A39 00C00003           1304mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000720  0805 0000               1305mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000724  6700 0010               1306mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
00000728                          1307mm  
00000728                          1308mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000728                 TRUE     1309mmm     IFEQ DEBUG
00000728  1A39 00C00007           1310mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000072E                          1311mmm     ENDC
0000072E                 FALSE    1312mmm     IFNE DEBUG
0000072E                          1313mmm     ENDC
0000072E                          1314mmm      
0000072E  BA3C 001B               1315mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000732  6700 F8D4               1316mmm     BEQ START
00000736                          1317mmm     ENDM
00000736                          1318mm CONTINUE_78
00000736  1A39 00C00013           1319mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000073C  0805 0000               1320mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000740  67D8                    1321mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000742                          1322mm     
00000742  1A39 00C00017           1323mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000748  13C5 00E00001           1324mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000074E                          1325mm     
0000074E                          1326mm     ENDM
0000074E                          1327mm         PRINT_CHAR D5,D6
0000074E                          1328mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074E                 TRUE     1329mm     IFEQ DEBUG
0000074E  1C39 00C00003           1330mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000754  0806 0002               1331mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000758  67F4                    1332mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
0000075A  13C5 00C00007           1333mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000760                          1334mm     ENDC
00000760                          1335mm     
00000760                 FALSE    1336mm     IFNE DEBUG
00000760                          1337mm     ENDC
00000760                          1338mm 
00000760                          1339mm     ENDM
00000760                          1340mm         HEX2BIN D5,D5,A4
00000760  49FA 099A               1341mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000764  0405 0030               1342mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000768  CABC 000000FF           1343mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000076E  1A34 5000               1344mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000772                          1345mm     ENDM
00000772  8805                    1346m         OR.B D5,D4
00000774  5307                    1347m         SUB.B #1,D7
00000776                          1348m     ENDW
00000776  6098                    1349ms     BRA _1000000E
00000778                          1350ms _1000000F
00000778                          1351m     
00000778  7A00                    1352m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000077A  1A04                    1353m     MOVE.B D4,D5
0000077C  D484                    1354m     ADD.L D4,D2
0000077E                          1355m 
0000077E                          1356m     ENDM
0000077E                          1357m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
0000077E  1E3C 0002               1358m     MOVE.B #2,D7
00000782                          1359m     WHILE.B D7 <GT> 0 DO
00000782                          1360ms _10000010
00000782  BE38 0000               1361ms     CMP.B   0,D7
00000786  6F00 0062               1362ms     BLE _10000011
0000078A  E98C                    1363m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000078C                          1364mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000078C                          1365mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                          1366mm 
0000078C  1A39 00C00003           1367mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000792  0805 0000               1368mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000796  6700 0010               1369mm     BEQ CONTINUE_83                             ; NOTHING, CONTINUE
0000079A                          1370mm  
0000079A                          1371mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000079A                 TRUE     1372mmm     IFEQ DEBUG
0000079A  1A39 00C00007           1373mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007A0                          1374mmm     ENDC
000007A0                 FALSE    1375mmm     IFNE DEBUG
000007A0                          1376mmm     ENDC
000007A0                          1377mmm      
000007A0  BA3C 001B               1378mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007A4  6700 F862               1379mmm     BEQ START
000007A8                          1380mmm     ENDM
000007A8                          1381mm CONTINUE_83
000007A8  1A39 00C00013           1382mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007AE  0805 0000               1383mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007B2  67D8                    1384mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
000007B4                          1385mm     
000007B4  1A39 00C00017           1386mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007BA  13C5 00E00001           1387mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007C0                          1388mm     
000007C0                          1389mm     ENDM
000007C0                          1390mm         PRINT_CHAR D5,D6
000007C0                          1391mm WAIT_FOR_READY_85                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                 TRUE     1392mm     IFEQ DEBUG
000007C0  1C39 00C00003           1393mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007C6  0806 0002               1394mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007CA  67F4                    1395mm         BEQ WAIT_FOR_READY_85                   ; NO SPACE, CHECK AGAIN
000007CC  13C5 00C00007           1396mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007D2                          1397mm     ENDC
000007D2                          1398mm     
000007D2                 FALSE    1399mm     IFNE DEBUG
000007D2                          1400mm     ENDC
000007D2                          1401mm 
000007D2                          1402mm     ENDM
000007D2                          1403mm         HEX2BIN D5,D5,A4
000007D2  49FA 0928               1404mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007D6  0405 0030               1405mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007DA  CABC 000000FF           1406mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007E0  1A34 5000               1407mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007E4                          1408mm     ENDM
000007E4  8805                    1409m         OR.B D5,D4
000007E6  5307                    1410m         SUB.B #1,D7
000007E8                          1411m     ENDW
000007E8  6098                    1412ms     BRA _10000010
000007EA                          1413ms _10000011
000007EA                          1414m     
000007EA  7A00                    1415m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007EC  1A04                    1416m     MOVE.B D4,D5
000007EE  D484                    1417m     ADD.L D4,D2
000007F0                          1418m 
000007F0                          1419m     ENDM
000007F0                          1420                            
000007F0  2044                    1421                  MOVE.L D4,A0                    ; start address -> A0
000007F2  D1C9                    1422                  ADD.L A1,A0                         ; add in the offset
000007F4                          1423  
000007F4  72FF                    1424                  MOVE.L #$FFFFFFFF,D1             ; done
000007F6                          1425              ELSE
000007F6  6000 0078               1426s     BRA _00000009
000007FA                          1427s _00000008
000007FA                          1428m                 PRINT_CRLF D5,A4
000007FA  49FA 092B               1429m     LEA CRLF(PC),A4
000007FE                          1430mm     PRINT_STR A4,D5
000007FE                          1431mm LOOP_88
000007FE  0C14 0000               1432mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000802  6700 0016               1433mm     BEQ EXIT_88
00000806                          1434mmm     PRINT_CHAR (A4)+,D5
00000806                          1435mmm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000806                 TRUE     1436mmm     IFEQ DEBUG
00000806  1A39 00C00003           1437mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000080C  0805 0002               1438mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000810  67F4                    1439mmm         BEQ WAIT_FOR_READY_89                   ; NO SPACE, CHECK AGAIN
00000812  13DC 00C00007           1440mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000818                          1441mmm     ENDC
00000818                          1442mmm     
00000818                 FALSE    1443mmm     IFNE DEBUG
00000818                          1444mmm     ENDC
00000818                          1445mmm 
00000818                          1446mmm     ENDM
00000818  60E4                    1447mm     BRA LOOP_88
0000081A                          1448mm EXIT_88
0000081A                          1449mm     ENDM
0000081A                          1450m     ENDM
0000081A                          1451              
0000081A  49FA 0895               1452                  LEA UNREC(PC),A4                ; warn for unrecognised type
0000081E                          1453m                 PRINT_STR A4,D5
0000081E                          1454m LOOP_90
0000081E  0C14 0000               1455m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000822  6700 0016               1456m     BEQ EXIT_90
00000826                          1457mm     PRINT_CHAR (A4)+,D5
00000826                          1458mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1459mm     IFEQ DEBUG
00000826  1A39 00C00003           1460mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1461mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1462mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000832  13DC 00C00007           1463mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000838                          1464mm     ENDC
00000838                          1465mm     
00000838                 FALSE    1466mm     IFNE DEBUG
00000838                          1467mm     ENDC
00000838                          1468mm 
00000838                          1469mm     ENDM
00000838  60E4                    1470m     BRA LOOP_90
0000083A                          1471m EXIT_90
0000083A                          1472m     ENDM
0000083A                          1473m                 PRINT_CHAR D1,D5
0000083A                          1474m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083A                 TRUE     1475m     IFEQ DEBUG
0000083A  1A39 00C00003           1476m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000840  0805 0002               1477m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000844  67F4                    1478m         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
00000846  13C1 00C00007           1479m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000084C                          1480m     ENDC
0000084C                          1481m     
0000084C                 FALSE    1482m     IFNE DEBUG
0000084C                          1483m     ENDC
0000084C                          1484m 
0000084C                          1485m     ENDM
0000084C                          1486m                 PRINT_CRLF D5,A4
0000084C  49FA 08D9               1487m     LEA CRLF(PC),A4
00000850                          1488mm     PRINT_STR A4,D5
00000850                          1489mm LOOP_94
00000850  0C14 0000               1490mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000854  6700 0016               1491mm     BEQ EXIT_94
00000858                          1492mmm     PRINT_CHAR (A4)+,D5
00000858                          1493mmm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000858                 TRUE     1494mmm     IFEQ DEBUG
00000858  1A39 00C00003           1495mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000085E  0805 0002               1496mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000862  67F4                    1497mmm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00000864  13DC 00C00007           1498mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000086A                          1499mmm     ENDC
0000086A                          1500mmm     
0000086A                 FALSE    1501mmm     IFNE DEBUG
0000086A                          1502mmm     ENDC
0000086A                          1503mmm 
0000086A                          1504mmm     ENDM
0000086A  60E4                    1505mm     BRA LOOP_94
0000086C                          1506mm EXIT_94
0000086C                          1507mm     ENDM
0000086C                          1508m     ENDM
0000086C                          1509              
0000086C  6000 FAEC               1510                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000870                          1511              ENDI
00000870                          1512s _00000009
00000870                          1513          ENDI
00000870                          1514s _00000007
00000870                          1515      ENDI
00000870                          1516s _00000003
00000870                          1517      
00000870                          1518m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000870  1E3C 0002               1519m     MOVE.B #2,D7
00000874                          1520m     WHILE.B D7 <GT> 0 DO
00000874                          1521ms _10000012
00000874  BE38 0000               1522ms     CMP.B   0,D7
00000878  6F00 0062               1523ms     BLE _10000013
0000087C  E98C                    1524m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000087E                          1525mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000087E                          1526mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087E                          1527mm 
0000087E  1A39 00C00003           1528mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000884  0805 0000               1529mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000888  6700 0010               1530mm     BEQ CONTINUE_97                             ; NOTHING, CONTINUE
0000088C                          1531mm  
0000088C                          1532mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000088C                 TRUE     1533mmm     IFEQ DEBUG
0000088C  1A39 00C00007           1534mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000892                          1535mmm     ENDC
00000892                 FALSE    1536mmm     IFNE DEBUG
00000892                          1537mmm     ENDC
00000892                          1538mmm      
00000892  BA3C 001B               1539mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000896  6700 F770               1540mmm     BEQ START
0000089A                          1541mmm     ENDM
0000089A                          1542mm CONTINUE_97
0000089A  1A39 00C00013           1543mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008A0  0805 0000               1544mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008A4  67D8                    1545mm     BEQ WAIT_FOR_READY_97                           ; NOTHING, CHECK AGAIN
000008A6                          1546mm     
000008A6  1A39 00C00017           1547mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008AC  13C5 00E00001           1548mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008B2                          1549mm     
000008B2                          1550mm     ENDM
000008B2                          1551mm         PRINT_CHAR D5,D6
000008B2                          1552mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B2                 TRUE     1553mm     IFEQ DEBUG
000008B2  1C39 00C00003           1554mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008B8  0806 0002               1555mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008BC  67F4                    1556mm         BEQ WAIT_FOR_READY_99                   ; NO SPACE, CHECK AGAIN
000008BE  13C5 00C00007           1557mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008C4                          1558mm     ENDC
000008C4                          1559mm     
000008C4                 FALSE    1560mm     IFNE DEBUG
000008C4                          1561mm     ENDC
000008C4                          1562mm 
000008C4                          1563mm     ENDM
000008C4                          1564mm         HEX2BIN D5,D5,A4
000008C4  49FA 0836               1565mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008C8  0405 0030               1566mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008CC  CABC 000000FF           1567mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008D2  1A34 5000               1568mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008D6                          1569mm     ENDM
000008D6  8805                    1570m         OR.B D5,D4
000008D8  5307                    1571m         SUB.B #1,D7
000008DA                          1572m     ENDW
000008DA  6098                    1573ms     BRA _10000012
000008DC                          1574ms _10000013
000008DC                          1575m     
000008DC  7A00                    1576m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008DE  1A04                    1577m     MOVE.B D4,D5
000008E0  D484                    1578m     ADD.L D4,D2
000008E2                          1579m 
000008E2                          1580m     ENDM
000008E2                          1581m     PRINT_CRLF D5,A4
000008E2  49FA 0843               1582m     LEA CRLF(PC),A4
000008E6                          1583mm     PRINT_STR A4,D5
000008E6                          1584mm LOOP_102
000008E6  0C14 0000               1585mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008EA  6700 0016               1586mm     BEQ EXIT_102
000008EE                          1587mmm     PRINT_CHAR (A4)+,D5
000008EE                          1588mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1589mmm     IFEQ DEBUG
000008EE  1A39 00C00003           1590mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008F4  0805 0002               1591mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1592mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
000008FA  13DC 00C00007           1593mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000900                          1594mmm     ENDC
00000900                          1595mmm     
00000900                 FALSE    1596mmm     IFNE DEBUG
00000900                          1597mmm     ENDC
00000900                          1598mmm 
00000900                          1599mmm     ENDM
00000900  60E4                    1600mm     BRA LOOP_102
00000902                          1601mm EXIT_102
00000902                          1602mm     ENDM
00000902                          1603m     ENDM
00000902                          1604          
00000902                          1605      IF.B D2 <NE> #$FF THEN.L
00000902  B43C 00FF               1606s     CMP.B   #$FF,D2
00000906  6700 0090               1607s     BEQ.L   _0000000A
0000090A  49FA 07BC               1608          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
0000090E                          1609m         PRINT_STR A4,D5
0000090E                          1610m LOOP_104
0000090E  0C14 0000               1611m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000912  6700 0016               1612m     BEQ EXIT_104
00000916                          1613mm     PRINT_CHAR (A4)+,D5
00000916                          1614mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                 TRUE     1615mm     IFEQ DEBUG
00000916  1A39 00C00003           1616mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000091C  0805 0002               1617mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000920  67F4                    1618mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000922  13DC 00C00007           1619mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000928                          1620mm     ENDC
00000928                          1621mm     
00000928                 FALSE    1622mm     IFNE DEBUG
00000928                          1623mm     ENDC
00000928                          1624mm 
00000928                          1625mm     ENDM
00000928  60E4                    1626m     BRA LOOP_104
0000092A                          1627m EXIT_104
0000092A                          1628m     ENDM
0000092A                          1629m         PRINT_REG D0,D5,D2,D6,A4
0000092A  49FA 0801               1630m     LEA OX(PC),A4
0000092E                          1631mm     PRINT_STR A4,D5
0000092E                          1632mm LOOP_107
0000092E  0C14 0000               1633mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000932  6700 0016               1634mm     BEQ EXIT_107
00000936                          1635mmm     PRINT_CHAR (A4)+,D5
00000936                          1636mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000936                 TRUE     1637mmm     IFEQ DEBUG
00000936  1A39 00C00003           1638mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000093C  0805 0002               1639mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000940  67F4                    1640mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000942  13DC 00C00007           1641mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000948                          1642mmm     ENDC
00000948                          1643mmm     
00000948                 FALSE    1644mmm     IFNE DEBUG
00000948                          1645mmm     ENDC
00000948                          1646mmm 
00000948                          1647mmm     ENDM
00000948  60E4                    1648mm     BRA LOOP_107
0000094A                          1649mm EXIT_107
0000094A                          1650mm     ENDM
0000094A  7C07                    1651m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000094C                          1652m LOOP_106
0000094C                          1653mm     BIN2HEX D0,D2,A4
0000094C  49FA 079E               1654mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
00000950  E998                    1655mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000952  1400                    1656mm     MOVE.B D0,D2
00000954  0282 0000000F           1657mm     ANDI.L #$F,D2
0000095A  1434 2000               1658mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000095E                          1659mm     ENDM
0000095E                          1660mm     PRINT_CHAR D2,D5
0000095E                          1661mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1662mm     IFEQ DEBUG
0000095E  1A39 00C00003           1663mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000964  0805 0002               1664mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000968  67F4                    1665mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
0000096A  13C2 00C00007           1666mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000970                          1667mm     ENDC
00000970                          1668mm     
00000970                 FALSE    1669mm     IFNE DEBUG
00000970                          1670mm     ENDC
00000970                          1671mm 
00000970                          1672mm     ENDM
00000970  57CE FFDA               1673m     DBEQ D6,LOOP_106
00000974                          1674m     ENDM
00000974                          1675m         PRINT_CRLF D5,A4
00000974  49FA 07B1               1676m     LEA CRLF(PC),A4
00000978                          1677mm     PRINT_STR A4,D5
00000978                          1678mm LOOP_112
00000978  0C14 0000               1679mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000097C  6700 0016               1680mm     BEQ EXIT_112
00000980                          1681mmm     PRINT_CHAR (A4)+,D5
00000980                          1682mmm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000980                 TRUE     1683mmm     IFEQ DEBUG
00000980  1A39 00C00003           1684mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000986  0805 0002               1685mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000098A  67F4                    1686mmm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
0000098C  13DC 00C00007           1687mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000992                          1688mmm     ENDC
00000992                          1689mmm     
00000992                 FALSE    1690mmm     IFNE DEBUG
00000992                          1691mmm     ENDC
00000992                          1692mmm 
00000992                          1693mmm     ENDM
00000992  60E4                    1694mm     BRA LOOP_112
00000994                          1695mm EXIT_112
00000994                          1696mm     ENDM
00000994                          1697m     ENDM
00000994  6000 F7A8               1698          BRA MAIN_LOOP
00000998                          1699      ENDI
00000998                          1700s _0000000A
00000998                          1701      
00000998                          1702      IF D1 <EQ> #0 THEN
00000998  B27C 0000               1703s     CMP.W   #0,D1
0000099C  6600 0006               1704s     BNE _0000000B
000009A0  6000 F9B8               1705        BRA WAIT_FOR_SRECORD            
000009A4                          1706      ENDI
000009A4                          1707s _0000000B
000009A4                          1708  DOWNLOAD_DONE
000009A4                          1709m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009A4  43FA 0787               1710m     LEA OX(PC),A1
000009A8                          1711mm     PRINT_STR A1,D5
000009A8                          1712mm LOOP_115
000009A8  0C11 0000               1713mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009AC  6700 0016               1714mm     BEQ EXIT_115
000009B0                          1715mmm     PRINT_CHAR (A1)+,D5
000009B0                          1716mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1717mmm     IFEQ DEBUG
000009B0  1A39 00C00003           1718mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B6  0805 0002               1719mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1720mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009BC  13D9 00C00007           1721mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009C2                          1722mmm     ENDC
000009C2                          1723mmm     
000009C2                 FALSE    1724mmm     IFNE DEBUG
000009C2                          1725mmm     ENDC
000009C2                          1726mmm 
000009C2                          1727mmm     ENDM
000009C2  60E4                    1728mm     BRA LOOP_115
000009C4                          1729mm EXIT_115
000009C4                          1730mm     ENDM
000009C4  7407                    1731m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009C6                          1732m LOOP_114
000009C6                          1733mm     BIN2HEX D0,D6,A1
000009C6  43FA 0724               1734mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009CA  E998                    1735mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009CC  1C00                    1736mm     MOVE.B D0,D6
000009CE  0286 0000000F           1737mm     ANDI.L #$F,D6
000009D4  1C31 6000               1738mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009D8                          1739mm     ENDM
000009D8                          1740mm     PRINT_CHAR D6,D5
000009D8                          1741mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1742mm     IFEQ DEBUG
000009D8  1A39 00C00003           1743mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1744mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1745mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
000009E4  13C6 00C00007           1746mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009EA                          1747mm     ENDC
000009EA                          1748mm     
000009EA                 FALSE    1749mm     IFNE DEBUG
000009EA                          1750mm     ENDC
000009EA                          1751mm 
000009EA                          1752mm     ENDM
000009EA  57CA FFDA               1753m     DBEQ D2,LOOP_114
000009EE                          1754m     ENDM
000009EE  43FA 069F               1755      LEA READ(PC),A1
000009F2                          1756m     PRINT_STR A1,D5
000009F2                          1757m LOOP_119
000009F2  0C11 0000               1758m     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009F6  6700 0016               1759m     BEQ EXIT_119
000009FA                          1760mm     PRINT_CHAR (A1)+,D5
000009FA                          1761mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FA                 TRUE     1762mm     IFEQ DEBUG
000009FA  1A39 00C00003           1763mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A00  0805 0002               1764mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A04  67F4                    1765mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000A06  13D9 00C00007           1766mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A0C                          1767mm     ENDC
00000A0C                          1768mm     
00000A0C                 FALSE    1769mm     IFNE DEBUG
00000A0C                          1770mm     ENDC
00000A0C                          1771mm 
00000A0C                          1772mm     ENDM
00000A0C  60E4                    1773m     BRA LOOP_119
00000A0E                          1774m EXIT_119
00000A0E                          1775m     ENDM
00000A0E  2E08                    1776      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A10                          1777m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A10  43FA 071B               1778m     LEA OX(PC),A1
00000A14                          1779mm     PRINT_STR A1,D5
00000A14                          1780mm LOOP_122
00000A14  0C11 0000               1781mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A18  6700 0016               1782mm     BEQ EXIT_122
00000A1C                          1783mmm     PRINT_CHAR (A1)+,D5
00000A1C                          1784mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1C                 TRUE     1785mmm     IFEQ DEBUG
00000A1C  1A39 00C00003           1786mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A22  0805 0002               1787mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A26  67F4                    1788mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A28  13D9 00C00007           1789mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A2E                          1790mmm     ENDC
00000A2E                          1791mmm     
00000A2E                 FALSE    1792mmm     IFNE DEBUG
00000A2E                          1793mmm     ENDC
00000A2E                          1794mmm 
00000A2E                          1795mmm     ENDM
00000A2E  60E4                    1796mm     BRA LOOP_122
00000A30                          1797mm EXIT_122
00000A30                          1798mm     ENDM
00000A30  7407                    1799m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A32                          1800m LOOP_121
00000A32                          1801mm     BIN2HEX D7,D6,A1
00000A32  43FA 06B8               1802mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A36  E99F                    1803mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A38  1C07                    1804mm     MOVE.B D7,D6
00000A3A  0286 0000000F           1805mm     ANDI.L #$F,D6
00000A40  1C31 6000               1806mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A44                          1807mm     ENDM
00000A44                          1808mm     PRINT_CHAR D6,D5
00000A44                          1809mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A44                 TRUE     1810mm     IFEQ DEBUG
00000A44  1A39 00C00003           1811mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A4A  0805 0002               1812mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A4E  67F4                    1813mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000A50  13C6 00C00007           1814mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A56                          1815mm     ENDC
00000A56                          1816mm     
00000A56                 FALSE    1817mm     IFNE DEBUG
00000A56                          1818mm     ENDC
00000A56                          1819mm 
00000A56                          1820mm     ENDM
00000A56  57CA FFDA               1821m     DBEQ D2,LOOP_121
00000A5A                          1822m     ENDM
00000A5A                          1823m     PRINT_CRLF D5,A4     
00000A5A  49FA 06CB               1824m     LEA CRLF(PC),A4
00000A5E                          1825mm     PRINT_STR A4,D5
00000A5E                          1826mm LOOP_127
00000A5E  0C14 0000               1827mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A62  6700 0016               1828mm     BEQ EXIT_127
00000A66                          1829mmm     PRINT_CHAR (A4)+,D5
00000A66                          1830mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                 TRUE     1831mmm     IFEQ DEBUG
00000A66  1A39 00C00003           1832mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A6C  0805 0002               1833mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A70  67F4                    1834mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A72  13DC 00C00007           1835mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A78                          1836mmm     ENDC
00000A78                          1837mmm     
00000A78                 FALSE    1838mmm     IFNE DEBUG
00000A78                          1839mmm     ENDC
00000A78                          1840mmm 
00000A78                          1841mmm     ENDM
00000A78  60E4                    1842mm     BRA LOOP_127
00000A7A                          1843mm EXIT_127
00000A7A                          1844mm     ENDM
00000A7A                          1845m     ENDM
00000A7A                          1846          
00000A7A  6000 F6C2               1847      BRA MAIN_LOOP
00000A7E                          1848      
00000A7E                          1849  G
00000A7E  2047                    1850      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A80  3E3C 0000               1851      MOVE #0,D7                                      ; clear the now used address accumulator
00000A84  4ED0                    1852      JMP (A0)                                        ; jump to it!
00000A86                          1853      
00000A86                          1854  Z
00000A86  207C 00200000           1855      MOVE.L #RAM,A0                                  ; address of RAM
00000A8C                          1856      
00000A8C                          1857      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A8C  7000                    1858s     MOVE.L  #0,D0
00000A8E  6000 0012               1859s     BRA _20000005
00000A92                          1860s _20000004
00000A92  2200                    1861          MOVE.L D0,D1                              ; progress update
00000A94  E089                    1862          LSR.L #8,D1 
00000A96  E089                    1863          LSR.L #8,D1
00000A98  13C1 00E00001           1864          MOVE.B D1,DISPLAY
00000A9E                          1865  
00000A9E  20C0                    1866          MOVE.L D0,(A0)+
00000AA0                          1867      ENDF
00000AA0  5880                    1868s     ADD.L   #4,D0
00000AA2                          1869s _20000005
00000AA2  B0BC 00040000           1870s     CMP.L   #$40000,D0
00000AA8  6FE8                    1871s     BLE _20000004
00000AAA                          1872   
00000AAA  207C 00200000           1873      MOVE.L #RAM,A0                                    ; address of RAM
00000AB0                          1874     
00000AB0                          1875      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AB0  7000                    1876s     MOVE.L  #0,D0
00000AB2  6000 00A6               1877s     BRA _20000007
00000AB6                          1878s _20000006
00000AB6  2200                    1879          MOVE.L D0,D1                              ; progress update
00000AB8  E089                    1880          LSR.L #8,D1
00000ABA  E089                    1881          LSR.L #8,D1
00000ABC  13C1 00E00001           1882          MOVE.B D1,DISPLAY
00000AC2                          1883  
00000AC2  2218                    1884          MOVE.L (A0)+,D1
00000AC4                          1885            
00000AC4                          1886          IF.L D0 <NE> D1 THEN      
00000AC4  B081                    1887s     CMP.L   D1,D0
00000AC6  6700 0090               1888s     BEQ _0000000C
00000ACA  43FA 060E               1889              LEA RAM_ERROR(PC),A1
00000ACE                          1890m             PRINT_STR A1,D1
00000ACE                          1891m LOOP_129
00000ACE  0C11 0000               1892m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AD2  6700 0016               1893m     BEQ EXIT_129
00000AD6                          1894mm     PRINT_CHAR (A1)+,D1
00000AD6                          1895mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD6                 TRUE     1896mm     IFEQ DEBUG
00000AD6  1239 00C00003           1897mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000ADC  0801 0002               1898mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000AE0  67F4                    1899mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000AE2  13D9 00C00007           1900mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AE8                          1901mm     ENDC
00000AE8                          1902mm     
00000AE8                 FALSE    1903mm     IFNE DEBUG
00000AE8                          1904mm     ENDC
00000AE8                          1905mm 
00000AE8                          1906mm     ENDM
00000AE8  60E4                    1907m     BRA LOOP_129
00000AEA                          1908m EXIT_129
00000AEA                          1909m     ENDM
00000AEA  2208                    1910              MOVE.L A0,D1
00000AEC  5981                    1911              SUB.L #4,D1
00000AEE                          1912m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AEE  43FA 063D               1913m     LEA OX(PC),A1
00000AF2                          1914mm     PRINT_STR A1,D3
00000AF2                          1915mm LOOP_132
00000AF2  0C11 0000               1916mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AF6  6700 0016               1917mm     BEQ EXIT_132
00000AFA                          1918mmm     PRINT_CHAR (A1)+,D3
00000AFA                          1919mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFA                 TRUE     1920mmm     IFEQ DEBUG
00000AFA  1639 00C00003           1921mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B00  0803 0002               1922mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B04  67F4                    1923mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B06  13D9 00C00007           1924mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B0C                          1925mmm     ENDC
00000B0C                          1926mmm     
00000B0C                 FALSE    1927mmm     IFNE DEBUG
00000B0C                          1928mmm     ENDC
00000B0C                          1929mmm 
00000B0C                          1930mmm     ENDM
00000B0C  60E4                    1931mm     BRA LOOP_132
00000B0E                          1932mm EXIT_132
00000B0E                          1933mm     ENDM
00000B0E  7C07                    1934m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B10                          1935m LOOP_131
00000B10                          1936mm     BIN2HEX D1,D2,A1
00000B10  43FA 05DA               1937mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B14  E999                    1938mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B16  1401                    1939mm     MOVE.B D1,D2
00000B18  0282 0000000F           1940mm     ANDI.L #$F,D2
00000B1E  1431 2000               1941mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B22                          1942mm     ENDM
00000B22                          1943mm     PRINT_CHAR D2,D3
00000B22                          1944mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B22                 TRUE     1945mm     IFEQ DEBUG
00000B22  1639 00C00003           1946mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B28  0803 0002               1947mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B2C  67F4                    1948mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00000B2E  13C2 00C00007           1949mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B34                          1950mm     ENDC
00000B34                          1951mm     
00000B34                 FALSE    1952mm     IFNE DEBUG
00000B34                          1953mm     ENDC
00000B34                          1954mm 
00000B34                          1955mm     ENDM
00000B34  57CE FFDA               1956m     DBEQ D6,LOOP_131
00000B38                          1957m     ENDM
00000B38                          1958m             PRINT_CRLF D3,A1
00000B38  43FA 05ED               1959m     LEA CRLF(PC),A1
00000B3C                          1960mm     PRINT_STR A1,D3
00000B3C                          1961mm LOOP_137
00000B3C  0C11 0000               1962mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B40  6700 0016               1963mm     BEQ EXIT_137
00000B44                          1964mmm     PRINT_CHAR (A1)+,D3
00000B44                          1965mmm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B44                 TRUE     1966mmm     IFEQ DEBUG
00000B44  1639 00C00003           1967mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B4A  0803 0002               1968mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B4E  67F4                    1969mmm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B50  13D9 00C00007           1970mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B56                          1971mmm     ENDC
00000B56                          1972mmm     
00000B56                 FALSE    1973mmm     IFNE DEBUG
00000B56                          1974mmm     ENDC
00000B56                          1975mmm 
00000B56                          1976mmm     ENDM
00000B56  60E4                    1977mm     BRA LOOP_137
00000B58                          1978mm EXIT_137
00000B58                          1979mm     ENDM
00000B58                          1980m     ENDM
00000B58                          1981          ENDI 
00000B58                          1982s _0000000C
00000B58                          1983      ENDF
00000B58  5880                    1984s     ADD.L   #4,D0
00000B5A                          1985s _20000007
00000B5A  B0BC 00040000           1986s     CMP.L   #$40000,D0
00000B60  6F00 FF54               1987s     BLE _20000006
00000B64                          1988      
00000B64  6000 F5D8               1989      BRA MAIN_LOOP
00000B68                          1990    
00000B68                          1991  L
00000B68  7000                    1992      MOVE.L #0,D0                                    ; D0 will be the length  to write            
00000B6A  7200                    1993      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B6C                          1994  
00000B6C                          1995      FOR D2 = #0 TO #7 DO                          ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B6C  343C 0000               1996s     MOVE.W  #0,D2
00000B70  6000 0046               1997s     BRA _20000009
00000B74                          1998s _20000008
00000B74  E989                    1999          LSL.L #4,D1                                 ; make what we have so far more significant
00000B76                          2000m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B76                          2001m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B76                 TRUE     2002m     IFEQ DEBUG
00000B76  1839 00C00003           2003m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B7C  0804 0000               2004m         BTST #0,D4                              ; CHECK FOR CHARACTER
00000B80  67F4                    2005m         BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00000B82                          2006m     ENDC
00000B82                          2007m     
00000B82                          2008mm     READ_CHAR D3
00000B82                 TRUE     2009mm     IFEQ DEBUG
00000B82  1639 00C00007           2010mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B88                          2011mm     ENDC
00000B88                 FALSE    2012mm     IFNE DEBUG
00000B88                          2013mm     ENDC
00000B88                          2014mm      
00000B88  B63C 001B               2015mm     CMP.B #$1B,D3                               ; CHECK FOR ESCAPE AND GO TO START
00000B8C  6700 F47A               2016mm     BEQ START
00000B90                          2017mm     ENDM
00000B90                          2018m 
00000B90                 TRUE     2019m     IFEQ DEBUG
00000B90                          2020mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B90                          2021mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     2022mm     IFEQ DEBUG
00000B90  1839 00C00003           2023mm         MOVE.B DUART_SRA,D4                     ; READ STATUS REGISTER
00000B96  0804 0002               2024mm         BTST #2,D4                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    2025mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B9C  13C3 00C00007           2026mm         MOVE.B D3,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BA2                          2027mm     ENDC
00000BA2                          2028mm     
00000BA2                 FALSE    2029mm     IFNE DEBUG
00000BA2                          2030mm     ENDC
00000BA2                          2031mm 
00000BA2                          2032mm     ENDM
00000BA2                          2033m     ENDC
00000BA2                          2034m     ENDM
00000BA2                          2035m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BA2  41FA 0558               2036m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BA6  0403 0030               2037m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BAA  C6BC 000000FF           2038m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BB0  1630 3000               2039m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BB4                          2040m     ENDM
00000BB4  8203                    2041          OR.B D3,D1
00000BB6                          2042      ENDF
00000BB6  5242                    2043s     ADD.W   #1,D2
00000BB8                          2044s _20000009
00000BB8  B47C 0007               2045s     CMP.W   #7,D2
00000BBC  6FB6                    2046s     BLE _20000008
00000BBE                          2047      
00000BBE  3001                    2048      MOVE.W D1,D0                                  ; extract the LSword for the length
00000BC0  E089                    2049      LSR.L #8,D1                                   ; extract the MSword for the address
00000BC2  E089                    2050      LSR.L #8,D1                                   
00000BC4                          2051                        
00000BC4                          2052m     PRINT_CRLF D2,A1
00000BC4  43FA 0561               2053m     LEA CRLF(PC),A1
00000BC8                          2054mm     PRINT_STR A1,D2
00000BC8                          2055mm LOOP_144
00000BC8  0C11 0000               2056mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BCC  6700 0016               2057mm     BEQ EXIT_144
00000BD0                          2058mmm     PRINT_CHAR (A1)+,D2
00000BD0                          2059mmm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     2060mmm     IFEQ DEBUG
00000BD0  1439 00C00003           2061mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000BD6  0802 0002               2062mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    2063mmm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000BDC  13D9 00C00007           2064mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BE2                          2065mmm     ENDC
00000BE2                          2066mmm     
00000BE2                 FALSE    2067mmm     IFNE DEBUG
00000BE2                          2068mmm     ENDC
00000BE2                          2069mmm 
00000BE2                          2070mmm     ENDM
00000BE2  60E4                    2071mm     BRA LOOP_144
00000BE4                          2072mm EXIT_144
00000BE4                          2073mm     ENDM
00000BE4                          2074m     ENDM
00000BE4                          2075  
00000BE4  2041                    2076      MOVE.L D1,A0                                ; target address
00000BE6                          2077      
00000BE6  2247                    2078      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BE8  7E00                    2079      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BEA                          2080  
00000BEA  5089                    2081      ADD.L #8,A1                                   ; skip the initial stack pointer and reset vector for now
00000BEC  5180                    2082      SUB.L #8,D0
00000BEE                          2083      
00000BEE  31FC AAAA 2AAA          2084      MOVE.W #$AAAA,$2AAA                         ; remove write protect
00000BF4  4E71                    2085      NOP
00000BF6  31FC 5555 1554          2086      MOVE.W #$5555,$1554
00000BFC  4E71                    2087      NOP
00000BFE  31FC 8080 2AAA          2088      MOVE.W #$8080,$2AAA
00000C04  4E71                    2089      NOP
00000C06  31FC AAAA 2AAA          2090      MOVE.W #$AAAA,$2AAA
00000C0C  4E71                    2091      NOP
00000C0E  31FC 5555 1554          2092      MOVE.W #$5555,$1554
00000C14  4E71                    2093      NOP
00000C16  31FC 2020 2AAA          2094      MOVE.W #$2020,$2AAA
00000C1C                          2095      
00000C1C  45FA 04F5               2096      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00000C20                          2097m     PRINT_STR A2,D2
00000C20                          2098m LOOP_146
00000C20  0C12 0000               2099m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C24  6700 0016               2100m     BEQ EXIT_146
00000C28                          2101mm     PRINT_CHAR (A2)+,D2
00000C28                          2102mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C28                 TRUE     2103mm     IFEQ DEBUG
00000C28  1439 00C00003           2104mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000C2E  0802 0002               2105mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000C32  67F4                    2106mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000C34  13DA 00C00007           2107mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C3A                          2108mm     ENDC
00000C3A                          2109mm     
00000C3A                 FALSE    2110mm     IFNE DEBUG
00000C3A                          2111mm     ENDC
00000C3A                          2112mm 
00000C3A                          2113mm     ENDM
00000C3A  60E4                    2114m     BRA LOOP_146
00000C3C                          2115m EXIT_146
00000C3C                          2116m     ENDM
00000C3C                          2117      
00000C3C  2409                    2118      MOVE.L A1,D2                
00000C3E                          2119m     PRINT_REG D2,D3,D4,D5,A2
00000C3E  45FA 04ED               2120m     LEA OX(PC),A2
00000C42                          2121mm     PRINT_STR A2,D3
00000C42                          2122mm LOOP_149
00000C42  0C12 0000               2123mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C46  6700 0016               2124mm     BEQ EXIT_149
00000C4A                          2125mmm     PRINT_CHAR (A2)+,D3
00000C4A                          2126mmm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2127mmm     IFEQ DEBUG
00000C4A  1639 00C00003           2128mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C50  0803 0002               2129mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2130mmm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00000C56  13DA 00C00007           2131mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C5C                          2132mmm     ENDC
00000C5C                          2133mmm     
00000C5C                 FALSE    2134mmm     IFNE DEBUG
00000C5C                          2135mmm     ENDC
00000C5C                          2136mmm 
00000C5C                          2137mmm     ENDM
00000C5C  60E4                    2138mm     BRA LOOP_149
00000C5E                          2139mm EXIT_149
00000C5E                          2140mm     ENDM
00000C5E  7A07                    2141m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C60                          2142m LOOP_148
00000C60                          2143mm     BIN2HEX D2,D4,A2
00000C60  45FA 048A               2144mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000C64  E99A                    2145mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C66  1802                    2146mm     MOVE.B D2,D4
00000C68  0284 0000000F           2147mm     ANDI.L #$F,D4
00000C6E  1832 4000               2148mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000C72                          2149mm     ENDM
00000C72                          2150mm     PRINT_CHAR D4,D3
00000C72                          2151mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C72                 TRUE     2152mm     IFEQ DEBUG
00000C72  1639 00C00003           2153mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C78  0803 0002               2154mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C7C  67F4                    2155mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000C7E  13C4 00C00007           2156mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C84                          2157mm     ENDC
00000C84                          2158mm     
00000C84                 FALSE    2159mm     IFNE DEBUG
00000C84                          2160mm     ENDC
00000C84                          2161mm 
00000C84                          2162mm     ENDM
00000C84  57CD FFDA               2163m     DBEQ D5,LOOP_148
00000C88                          2164m     ENDM
00000C88                          2165  
00000C88  45FA 04A6               2166      LEA TO(PC),A2
00000C8C                          2167m     PRINT_STR A2,D3
00000C8C                          2168m LOOP_153
00000C8C  0C12 0000               2169m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C90  6700 0016               2170m     BEQ EXIT_153
00000C94                          2171mm     PRINT_CHAR (A2)+,D3
00000C94                          2172mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2173mm     IFEQ DEBUG
00000C94  1639 00C00003           2174mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C9A  0803 0002               2175mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2176mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000CA0  13DA 00C00007           2177mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CA6                          2178mm     ENDC
00000CA6                          2179mm     
00000CA6                 FALSE    2180mm     IFNE DEBUG
00000CA6                          2181mm     ENDC
00000CA6                          2182mm 
00000CA6                          2183mm     ENDM
00000CA6  60E4                    2184m     BRA LOOP_153
00000CA8                          2185m EXIT_153
00000CA8                          2186m     ENDM
00000CA8                          2187      
00000CA8  2408                    2188      MOVE.L A0,D2                
00000CAA                          2189m     PRINT_REG D2,D3,D4,D5,A2
00000CAA  45FA 0481               2190m     LEA OX(PC),A2
00000CAE                          2191mm     PRINT_STR A2,D3
00000CAE                          2192mm LOOP_156
00000CAE  0C12 0000               2193mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CB2  6700 0016               2194mm     BEQ EXIT_156
00000CB6                          2195mmm     PRINT_CHAR (A2)+,D3
00000CB6                          2196mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2197mmm     IFEQ DEBUG
00000CB6  1639 00C00003           2198mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CBC  0803 0002               2199mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2200mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000CC2  13DA 00C00007           2201mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CC8                          2202mmm     ENDC
00000CC8                          2203mmm     
00000CC8                 FALSE    2204mmm     IFNE DEBUG
00000CC8                          2205mmm     ENDC
00000CC8                          2206mmm 
00000CC8                          2207mmm     ENDM
00000CC8  60E4                    2208mm     BRA LOOP_156
00000CCA                          2209mm EXIT_156
00000CCA                          2210mm     ENDM
00000CCA  7A07                    2211m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCC                          2212m LOOP_155
00000CCC                          2213mm     BIN2HEX D2,D4,A2
00000CCC  45FA 041E               2214mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000CD0  E99A                    2215mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD2  1802                    2216mm     MOVE.B D2,D4
00000CD4  0284 0000000F           2217mm     ANDI.L #$F,D4
00000CDA  1832 4000               2218mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000CDE                          2219mm     ENDM
00000CDE                          2220mm     PRINT_CHAR D4,D3
00000CDE                          2221mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDE                 TRUE     2222mm     IFEQ DEBUG
00000CDE  1639 00C00003           2223mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE4  0803 0002               2224mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE8  67F4                    2225mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000CEA  13C4 00C00007           2226mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CF0                          2227mm     ENDC
00000CF0                          2228mm     
00000CF0                 FALSE    2229mm     IFNE DEBUG
00000CF0                          2230mm     ENDC
00000CF0                          2231mm 
00000CF0                          2232mm     ENDM
00000CF0  57CD FFDA               2233m     DBEQ D5,LOOP_155
00000CF4                          2234m     ENDM
00000CF4                          2235  
00000CF4                          2236m     PRINT_CRLF D3,A2
00000CF4  45FA 0431               2237m     LEA CRLF(PC),A2
00000CF8                          2238mm     PRINT_STR A2,D3
00000CF8                          2239mm LOOP_161
00000CF8  0C12 0000               2240mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CFC  6700 0016               2241mm     BEQ EXIT_161
00000D00                          2242mmm     PRINT_CHAR (A2)+,D3
00000D00                          2243mmm WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2244mmm     IFEQ DEBUG
00000D00  1639 00C00003           2245mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D06  0803 0002               2246mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2247mmm         BEQ WAIT_FOR_READY_162                      ; NO SPACE, CHECK AGAIN
00000D0C  13DA 00C00007           2248mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000D12                          2249mmm     ENDC
00000D12                          2250mmm     
00000D12                 FALSE    2251mmm     IFNE DEBUG
00000D12                          2252mmm     ENDC
00000D12                          2253mmm 
00000D12                          2254mmm     ENDM
00000D12  60E4                    2255mm     BRA LOOP_161
00000D14                          2256mm EXIT_161
00000D14                          2257mm     ENDM
00000D14                          2258m     ENDM
00000D14                          2259  
00000D14                          2260      WHILE D0 <GT> #0 DO
00000D14                          2261s _10000014
00000D14  B07C 0000               2262s     CMP.W   #0,D0
00000D18  6F00 001C               2263s     BLE _10000015
00000D1C  5580                    2264          SUB.L #2,D0
00000D1E                          2265        
00000D1E  13D1 00E00001           2266          MOVE.B (A1),DISPLAY
00000D24                          2267m         PROGRAM (A1),(A0),D2
00000D24  3091                    2268m   MOVE.W (A1),(A0)                          ; WRITE THE DATA
00000D26                          2269m       
00000D26                          2270m WAIT_FOR_COMPLETE_163
00000D26  3410                    2271m         MOVE.W (A0),D2
00000D28                          2272m 
00000D28                          2273m         IF.W D2 <NE> (A1) THEN
00000D28  B451                    2274ms     CMP.W   (A1),D2
00000D2A  6700 0004               2275ms     BEQ _0000000D
00000D2E  60F6                    2276m             BRA WAIT_FOR_COMPLETE_163
00000D30                          2277m         ENDI
00000D30                          2278ms _0000000D
00000D30                          2279m         ENDM
00000D30                          2280                
00000D30  5488                    2281          ADD.L #2,A0
00000D32  5489                    2282          ADD.L #2,A1
00000D34                          2283      ENDW
00000D34  60DE                    2284s     BRA _10000014
00000D36                          2285s _10000015
00000D36                          2286      
00000D36                          2287m     PROGRAM #0, $0, D2                         ; we're done, can now update the SP and start vector
00000D36  31FC 0000 0000          2288m   MOVE.W #0,$0                          ; WRITE THE DATA
00000D3C                          2289m       
00000D3C                          2290m WAIT_FOR_COMPLETE_164
00000D3C  3438 0000               2291m         MOVE.W $0,D2
00000D40                          2292m 
00000D40                          2293m         IF.W D2 <NE> #0 THEN
00000D40  B47C 0000               2294ms     CMP.W   #0,D2
00000D44  6700 0004               2295ms     BEQ _0000000E
00000D48  60F2                    2296m             BRA WAIT_FOR_COMPLETE_164
00000D4A                          2297m         ENDI
00000D4A                          2298ms _0000000E
00000D4A                          2299m         ENDM
00000D4A                          2300m     PROGRAM #0, $2, D2                         ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D4A  31FC 0000 0002          2301m   MOVE.W #0,$2                          ; WRITE THE DATA
00000D50                          2302m       
00000D50                          2303m WAIT_FOR_COMPLETE_165
00000D50  3438 0002               2304m         MOVE.W $2,D2
00000D54                          2305m 
00000D54                          2306m         IF.W D2 <NE> #0 THEN
00000D54  B47C 0000               2307ms     CMP.W   #0,D2
00000D58  6700 0004               2308ms     BEQ _0000000F
00000D5C  60F2                    2309m             BRA WAIT_FOR_COMPLETE_165
00000D5E                          2310m         ENDI
00000D5E                          2311ms _0000000F
00000D5E                          2312m         ENDM
00000D5E                          2313  
00000D5E                          2314m     PROGRAM D1, $6, D2
00000D5E  31C1 0006               2315m   MOVE.W D1,$6                          ; WRITE THE DATA
00000D62                          2316m       
00000D62                          2317m WAIT_FOR_COMPLETE_166
00000D62  3438 0006               2318m         MOVE.W $6,D2
00000D66                          2319m 
00000D66                          2320m         IF.W D2 <NE> D1 THEN
00000D66  B441                    2321ms     CMP.W   D1,D2
00000D68  6700 0004               2322ms     BEQ _00000010
00000D6C  60F4                    2323m             BRA WAIT_FOR_COMPLETE_166
00000D6E                          2324m         ENDI
00000D6E                          2325ms _00000010
00000D6E                          2326m         ENDM
00000D6E  E089                    2327      LSR.L #8,D1
00000D70  E089                    2328      LSR.L #8,D1
00000D72                          2329m     PROGRAM D1, $4, D2                         
00000D72  31C1 0004               2330m   MOVE.W D1,$4                          ; WRITE THE DATA
00000D76                          2331m       
00000D76                          2332m WAIT_FOR_COMPLETE_167
00000D76  3438 0004               2333m         MOVE.W $4,D2
00000D7A                          2334m 
00000D7A                          2335m         IF.W D2 <NE> D1 THEN
00000D7A  B441                    2336ms     CMP.W   D1,D2
00000D7C  6700 0004               2337ms     BEQ _00000011
00000D80  60F4                    2338m             BRA WAIT_FOR_COMPLETE_167
00000D82                          2339m         ENDI
00000D82                          2340ms _00000011
00000D82                          2341m         ENDM
00000D82                          2342  
00000D82  31FC AAAA 2AAA          2343      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000D88  31FC 5555 1554          2344      MOVE.W #$5555,$1554
00000D8E  31FC A0A0 2AAA          2345      MOVE.W #$A0A0,$2AAA
00000D94                          2346              
00000D94  6000 F3A8               2347      BRA MAIN_LOOP
00000D98                          2348      
00000D98                          2349  P
00000D98  7000                    2350      MOVE.L #0,D0                                    ; D0 will be the data to write            
00000D9A                          2351  
00000D9A                          2352      FOR D1 = #0 TO #3 DO                           ; read 2 bytes
00000D9A  323C 0000               2353s     MOVE.W  #0,D1
00000D9E  6000 0046               2354s     BRA _2000000B
00000DA2                          2355s _2000000A
00000DA2  E988                    2356          LSL.L #4,D0                                 ; make what we have so far more significant
00000DA4                          2357m         WAIT_CHAR D2,D3                             ; next character -> D2
00000DA4                          2358m WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA4                 TRUE     2359m     IFEQ DEBUG
00000DA4  1639 00C00003           2360m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DAA  0803 0000               2361m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000DAE  67F4                    2362m         BEQ WAIT_FOR_READY_168                      ; NOTHING, CHECK AGAIN
00000DB0                          2363m     ENDC
00000DB0                          2364m     
00000DB0                          2365mm     READ_CHAR D2
00000DB0                 TRUE     2366mm     IFEQ DEBUG
00000DB0  1439 00C00007           2367mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000DB6                          2368mm     ENDC
00000DB6                 FALSE    2369mm     IFNE DEBUG
00000DB6                          2370mm     ENDC
00000DB6                          2371mm      
00000DB6  B43C 001B               2372mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000DBA  6700 F24C               2373mm     BEQ START
00000DBE                          2374mm     ENDM
00000DBE                          2375m 
00000DBE                 TRUE     2376m     IFEQ DEBUG
00000DBE                          2377mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000DBE                          2378mm WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBE                 TRUE     2379mm     IFEQ DEBUG
00000DBE  1639 00C00003           2380mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DC4  0803 0002               2381mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DC8  67F4                    2382mm         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
00000DCA  13C2 00C00007           2383mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000DD0                          2384mm     ENDC
00000DD0                          2385mm     
00000DD0                 FALSE    2386mm     IFNE DEBUG
00000DD0                          2387mm     ENDC
00000DD0                          2388mm 
00000DD0                          2389mm     ENDM
00000DD0                          2390m     ENDC
00000DD0                          2391m     ENDM
00000DD0                          2392m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000DD0  41FA 032A               2393m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000DD4  0402 0030               2394m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DD8  C4BC 000000FF           2395m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000DDE  1430 2000               2396m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000DE2                          2397m     ENDM
00000DE2  8002                    2398          OR.B D2,D0
00000DE4                          2399      ENDF
00000DE4  5241                    2400s     ADD.W   #1,D1
00000DE6                          2401s _2000000B
00000DE6  B27C 0003               2402s     CMP.W   #3,D1
00000DEA  6FB6                    2403s     BLE _2000000A
00000DEC                          2404         
00000DEC                          2405m     PRINT_CRLF D2,A1
00000DEC  43FA 0339               2406m     LEA CRLF(PC),A1
00000DF0                          2407mm     PRINT_STR A1,D2
00000DF0                          2408mm LOOP_173
00000DF0  0C11 0000               2409mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000DF4  6700 0016               2410mm     BEQ EXIT_173
00000DF8                          2411mmm     PRINT_CHAR (A1)+,D2
00000DF8                          2412mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF8                 TRUE     2413mmm     IFEQ DEBUG
00000DF8  1439 00C00003           2414mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000DFE  0802 0002               2415mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000E02  67F4                    2416mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000E04  13D9 00C00007           2417mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E0A                          2418mmm     ENDC
00000E0A                          2419mmm     
00000E0A                 FALSE    2420mmm     IFNE DEBUG
00000E0A                          2421mmm     ENDC
00000E0A                          2422mmm 
00000E0A                          2423mmm     ENDM
00000E0A  60E4                    2424mm     BRA LOOP_173
00000E0C                          2425mm EXIT_173
00000E0C                          2426mm     ENDM
00000E0C                          2427m     ENDM
00000E0C                          2428      
00000E0C  2047                    2429      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000E0E  7E00                    2430      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E10                          2431      
00000E10  31FC AAAA 2AAA          2432      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000E16  4E71                    2433      NOP
00000E18  31FC 5555 1554          2434      MOVE.W #$5555,$1554
00000E1E  4E71                    2435      NOP
00000E20  31FC 8080 2AAA          2436      MOVE.W #$8080,$2AAA
00000E26  4E71                    2437      NOP
00000E28  31FC AAAA 2AAA          2438      MOVE.W #$AAAA,$2AAA
00000E2E  4E71                    2439      NOP
00000E30  31FC 5555 1554          2440      MOVE.W #$5555,$1554
00000E36  4E71                    2441      NOP
00000E38  31FC 2020 2AAA          2442      MOVE.W #$2020,$2AAA
00000E3E                          2443            
00000E3E  45FA 02D3               2444      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00000E42                          2445m     PRINT_STR A2,D2
00000E42                          2446m LOOP_175
00000E42  0C12 0000               2447m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000E46  6700 0016               2448m     BEQ EXIT_175
00000E4A                          2449mm     PRINT_CHAR (A2)+,D2
00000E4A                          2450mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4A                 TRUE     2451mm     IFEQ DEBUG
00000E4A  1439 00C00003           2452mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000E50  0802 0002               2453mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000E54  67F4                    2454mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000E56  13DA 00C00007           2455mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E5C                          2456mm     ENDC
00000E5C                          2457mm     
00000E5C                 FALSE    2458mm     IFNE DEBUG
00000E5C                          2459mm     ENDC
00000E5C                          2460mm 
00000E5C                          2461mm     ENDM
00000E5C  60E4                    2462m     BRA LOOP_175
00000E5E                          2463m EXIT_175
00000E5E                          2464m     ENDM
00000E5E                          2465      
00000E5E                          2466m     PRINT_CHAR '#',D3
00000E5E                          2467m WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5E                 TRUE     2468m     IFEQ DEBUG
00000E5E  1639 00C00003           2469m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E64  0803 0002               2470m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E68  67F4                    2471m         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00000E6A  13F8 0023 00C00007      2472m         MOVE.B '#',DUART_TXA                    ; SEND THE NEXT CHARACTER
00000E72                          2473m     ENDC
00000E72                          2474m     
00000E72                 FALSE    2475m     IFNE DEBUG
00000E72                          2476m     ENDC
00000E72                          2477m 
00000E72                          2478m     ENDM
00000E72                          2479m     PRINT_REG D0,D3,D4,D5,A2
00000E72  45FA 02B9               2480m     LEA OX(PC),A2
00000E76                          2481mm     PRINT_STR A2,D3
00000E76                          2482mm LOOP_179
00000E76  0C12 0000               2483mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000E7A  6700 0016               2484mm     BEQ EXIT_179
00000E7E                          2485mmm     PRINT_CHAR (A2)+,D3
00000E7E                          2486mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7E                 TRUE     2487mmm     IFEQ DEBUG
00000E7E  1639 00C00003           2488mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E84  0803 0002               2489mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E88  67F4                    2490mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E8A  13DA 00C00007           2491mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E90                          2492mmm     ENDC
00000E90                          2493mmm     
00000E90                 FALSE    2494mmm     IFNE DEBUG
00000E90                          2495mmm     ENDC
00000E90                          2496mmm 
00000E90                          2497mmm     ENDM
00000E90  60E4                    2498mm     BRA LOOP_179
00000E92                          2499mm EXIT_179
00000E92                          2500mm     ENDM
00000E92  7A07                    2501m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E94                          2502m LOOP_178
00000E94                          2503mm     BIN2HEX D0,D4,A2
00000E94  45FA 0256               2504mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000E98  E998                    2505mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E9A  1800                    2506mm     MOVE.B D0,D4
00000E9C  0284 0000000F           2507mm     ANDI.L #$F,D4
00000EA2  1832 4000               2508mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000EA6                          2509mm     ENDM
00000EA6                          2510mm     PRINT_CHAR D4,D3
00000EA6                          2511mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA6                 TRUE     2512mm     IFEQ DEBUG
00000EA6  1639 00C00003           2513mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000EAC  0803 0002               2514mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000EB0  67F4                    2515mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000EB2  13C4 00C00007           2516mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000EB8                          2517mm     ENDC
00000EB8                          2518mm     
00000EB8                 FALSE    2519mm     IFNE DEBUG
00000EB8                          2520mm     ENDC
00000EB8                          2521mm 
00000EB8                          2522mm     ENDM
00000EB8  57CD FFDA               2523m     DBEQ D5,LOOP_178
00000EBC                          2524m     ENDM
00000EBC                          2525  
00000EBC  45FA 0272               2526      LEA TO(PC),A2
00000EC0                          2527m     PRINT_STR A2,D3
00000EC0                          2528m LOOP_183
00000EC0  0C12 0000               2529m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000EC4  6700 0016               2530m     BEQ EXIT_183
00000EC8                          2531mm     PRINT_CHAR (A2)+,D3
00000EC8                          2532mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2533mm     IFEQ DEBUG
00000EC8  1639 00C00003           2534mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000ECE  0803 0002               2535mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2536mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00000ED4  13DA 00C00007           2537mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000EDA                          2538mm     ENDC
00000EDA                          2539mm     
00000EDA                 FALSE    2540mm     IFNE DEBUG
00000EDA                          2541mm     ENDC
00000EDA                          2542mm 
00000EDA                          2543mm     ENDM
00000EDA  60E4                    2544m     BRA LOOP_183
00000EDC                          2545m EXIT_183
00000EDC                          2546m     ENDM
00000EDC                          2547      
00000EDC  2408                    2548      MOVE.L A0,D2                
00000EDE                          2549m     PRINT_REG D2,D3,D4,D5,A2
00000EDE  45FA 024D               2550m     LEA OX(PC),A2
00000EE2                          2551mm     PRINT_STR A2,D3
00000EE2                          2552mm LOOP_186
00000EE2  0C12 0000               2553mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000EE6  6700 0016               2554mm     BEQ EXIT_186
00000EEA                          2555mmm     PRINT_CHAR (A2)+,D3
00000EEA                          2556mmm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEA                 TRUE     2557mmm     IFEQ DEBUG
00000EEA  1639 00C00003           2558mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000EF0  0803 0002               2559mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000EF4  67F4                    2560mmm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000EF6  13DA 00C00007           2561mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000EFC                          2562mmm     ENDC
00000EFC                          2563mmm     
00000EFC                 FALSE    2564mmm     IFNE DEBUG
00000EFC                          2565mmm     ENDC
00000EFC                          2566mmm 
00000EFC                          2567mmm     ENDM
00000EFC  60E4                    2568mm     BRA LOOP_186
00000EFE                          2569mm EXIT_186
00000EFE                          2570mm     ENDM
00000EFE  7A07                    2571m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F00                          2572m LOOP_185
00000F00                          2573mm     BIN2HEX D2,D4,A2
00000F00  45FA 01EA               2574mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000F04  E99A                    2575mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F06  1802                    2576mm     MOVE.B D2,D4
00000F08  0284 0000000F           2577mm     ANDI.L #$F,D4
00000F0E  1832 4000               2578mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000F12                          2579mm     ENDM
00000F12                          2580mm     PRINT_CHAR D4,D3
00000F12                          2581mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F12                 TRUE     2582mm     IFEQ DEBUG
00000F12  1639 00C00003           2583mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F18  0803 0002               2584mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F1C  67F4                    2585mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
00000F1E  13C4 00C00007           2586mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000F24                          2587mm     ENDC
00000F24                          2588mm     
00000F24                 FALSE    2589mm     IFNE DEBUG
00000F24                          2590mm     ENDC
00000F24                          2591mm 
00000F24                          2592mm     ENDM
00000F24  57CD FFDA               2593m     DBEQ D5,LOOP_185
00000F28                          2594m     ENDM
00000F28                          2595  
00000F28                          2596m     PRINT_CRLF D3,A2
00000F28  45FA 01FD               2597m     LEA CRLF(PC),A2
00000F2C                          2598mm     PRINT_STR A2,D3
00000F2C                          2599mm LOOP_191
00000F2C  0C12 0000               2600mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000F30  6700 0016               2601mm     BEQ EXIT_191
00000F34                          2602mmm     PRINT_CHAR (A2)+,D3
00000F34                          2603mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F34                 TRUE     2604mmm     IFEQ DEBUG
00000F34  1639 00C00003           2605mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F3A  0803 0002               2606mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F3E  67F4                    2607mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000F40  13DA 00C00007           2608mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000F46                          2609mmm     ENDC
00000F46                          2610mmm     
00000F46                 FALSE    2611mmm     IFNE DEBUG
00000F46                          2612mmm     ENDC
00000F46                          2613mmm 
00000F46                          2614mmm     ENDM
00000F46  60E4                    2615mm     BRA LOOP_191
00000F48                          2616mm EXIT_191
00000F48                          2617mm     ENDM
00000F48                          2618m     ENDM
00000F48                          2619       
00000F48                          2620m     PROGRAM D0,(A0),D2
00000F48  3080                    2621m   MOVE.W D0,(A0)                            ; WRITE THE DATA
00000F4A                          2622m       
00000F4A                          2623m WAIT_FOR_COMPLETE_193
00000F4A  3410                    2624m         MOVE.W (A0),D2
00000F4C                          2625m 
00000F4C                          2626m         IF.W D2 <NE> D0 THEN
00000F4C  B440                    2627ms     CMP.W   D0,D2
00000F4E  6700 0004               2628ms     BEQ _00000012
00000F52  60F6                    2629m             BRA WAIT_FOR_COMPLETE_193
00000F54                          2630m         ENDI
00000F54                          2631ms _00000012
00000F54                          2632m         ENDM
00000F54                          2633      
00000F54  31FC AAAA 2AAA          2634      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000F5A  31FC 5555 1554          2635      MOVE.W #$5555,$1554
00000F60  31FC A0A0 2AAA          2636      MOVE.W #$A0A0,$2AAA
00000F66                          2637              
00000F66  6000 F1D6               2638      BRA MAIN_LOOP
00000F6A                          2639  
00000F6A                          2640  HEX_DIGIT
00000F6A  E98F                    2641      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000F6C                          2642m     HEX2BIN D2,D2,A0
00000F6C  41FA 018E               2643m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F70  0402 0030               2644m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F74  C4BC 000000FF           2645m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000F7A  1430 2000               2646m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000F7E                          2647m     ENDM
00000F7E  8E02                    2648      OR.B D2,D7  
00000F80  6000 F1DC               2649      BRA GET_INPUT
00000F84                          2650  
00000F84  FFFF FFFF               2651      SIMHALT                                     ; halt simulator
00000F88                          2652  
00000F88                          2653  ; strings
00000F88= 4D 44 46 2D 6D 6F ...   2654  VERSION DC.B 'MDF-mon V1.65 (11/04/2021)',CR,LF,NULL
00000FA5= 50 72 65 73 73 20 ...   2655  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000FB8= 3F 09 09 09 68 65 ...   2656  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000FC2= 5B 76 5D 09 09 09 ...   2657          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000FD1= 78 78 78 78 78 78 ...   2658          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000FE9= 78 78 78 78 78 78 ...   2659          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001009= 5B 73 5D 09 09 09 ...   2660          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00001023= 78 78 78 78 78 78 ...   2661          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001034= 5B 7A 5D 09 09 09 ...   2662          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001046= 78 78 78 78 78 78 ...   2663          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00001068= 78 78 78 78 78 78 ...   2664          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF,NULL
00001088= 48 75 68 3F 0D 0A 00    2665  HUH     DC.B 'Huh?',CR,LF,NULL
0000108F= 20 53 20 72 65 63 ...   2666  READ    DC.B ' S records read, start address = ',NULL
000010B1= 57 3A 20 55 6E 6B ...   2667  UNREC   DC.B 'W: Unknown Srec type: ',NULL
000010C8= 57 3A 20 43 53 20 ...   2668  CS_FAILURE   DC.B 'W: CS failure at ',NULL
000010DA= 57 3A 20 52 41 4D ...   2669  RAM_ERROR DC.B 'W: RAM error at: ',NULL
000010EC= 30 31 32 33 34 35 ...   2670  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000010FC= 00 01 02 03 04 05 ...   2671  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001113= 4C 6F 61 64 69 6E ...   2672  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001127= 0D 0A 00                2673  CRLF    DC.B CR,LF,NULL
0000112A= 3E 20 00                2674  PROMPT  DC.B '> ',NULL
0000112D= 30 78 00                2675  ox      DC.B '0x',NULL
00001130= 20 2D 3E 20 00          2676  to      DC.B ' -> ',NULL
00001135                          2677      
00001135                          2678      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         10EC
CONTINUE_38         376
CONTINUE_41         3C6
CONTINUE_45         41C
CONTINUE_53         4D0
CONTINUE_58         542
CONTINUE_63         5BE
CONTINUE_68         63C
CONTINUE_73         6C4
CONTINUE_78         736
CONTINUE_83         7A8
CONTINUE_97         89A
CR                  D
CRLF                1127
CS_FAILURE          10C8
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       C2D
DOWNLOAD_DONE       9A4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            902
EXIT_104            92A
EXIT_107            94A
EXIT_11             15E
EXIT_112            994
EXIT_115            9C4
EXIT_119            A0E
EXIT_122            A30
EXIT_127            A7A
EXIT_129            AEA
EXIT_132            B0E
EXIT_137            B58
EXIT_144            BE4
EXIT_146            C3C
EXIT_149            C5E
EXIT_153            CA8
EXIT_156            CCA
EXIT_161            D14
EXIT_17             1EA
EXIT_173            E0C
EXIT_175            E5E
EXIT_179            E92
EXIT_183            EDC
EXIT_186            EFE
EXIT_19             23A
EXIT_191            F48
EXIT_2              D4
EXIT_21             266
EXIT_24             290
EXIT_29             2DA
EXIT_36             34E
EXIT_4              F4
EXIT_50             48C
EXIT_6              114
EXIT_88             81A
EXIT_9              134
EXIT_90             83A
EXIT_94             86C
G                   A7E
GET_INPUT           15E
H                   23E
HELP                FB8
HELPPROMPT          FA5
HEX2BIN             137
HEX2BIN_LUT         10FC
HEX_DIGIT           F6A
HUH                 1088
L                   B68
LF                  A
LOADING             1113
LOOP_102            8E6
LOOP_104            90E
LOOP_106            94C
LOOP_107            92E
LOOP_11             142
LOOP_112            978
LOOP_114            9C6
LOOP_115            9A8
LOOP_119            9F2
LOOP_121            A32
LOOP_122            A14
LOOP_127            A5E
LOOP_129            ACE
LOOP_131            B10
LOOP_132            AF2
LOOP_137            B3C
LOOP_144            BC8
LOOP_146            C20
LOOP_148            C60
LOOP_149            C42
LOOP_153            C8C
LOOP_155            CCC
LOOP_156            CAE
LOOP_161            CF8
LOOP_17             1CE
LOOP_173            DF0
LOOP_175            E42
LOOP_178            E94
LOOP_179            E76
LOOP_183            EC0
LOOP_185            F00
LOOP_186            EE2
LOOP_19             21E
LOOP_191            F2C
LOOP_2              B8
LOOP_21             24A
LOOP_23             292
LOOP_24             274
LOOP_29             2BE
LOOP_36             332
LOOP_4              D8
LOOP_50             470
LOOP_6              F8
LOOP_88             7FE
LOOP_9              118
LOOP_90             81E
LOOP_94             850
MAIN_LOOP           13E
NULL                0
OX                  112D
P                   D98
PRINTSTR            24A
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROGRAM             E50
PROMPT              112A
R                   26A
RAM                 200000
RAM_ERROR           10DA
READ                108F
READ_CHAR           7E2
READ_DATA_TO_POKE   2E2
RESET               4
ROM                 0
S                   352
STACK               0
START               8
TAB                 9
TO                  1130
UNREC               10B1
V                   246
VERSION             F88
W                   2DE
WAIT_CHAR           633
WAIT_FOR_COMPLETE_163  D26
WAIT_FOR_COMPLETE_164  D3C
WAIT_FOR_COMPLETE_165  D50
WAIT_FOR_COMPLETE_166  D62
WAIT_FOR_COMPLETE_167  D76
WAIT_FOR_COMPLETE_193  F4A
WAIT_FOR_READY_10   120
WAIT_FOR_READY_103  8EE
WAIT_FOR_READY_105  916
WAIT_FOR_READY_108  936
WAIT_FOR_READY_110  95E
WAIT_FOR_READY_113  980
WAIT_FOR_READY_116  9B0
WAIT_FOR_READY_118  9D8
WAIT_FOR_READY_12   14A
WAIT_FOR_READY_120  9FA
WAIT_FOR_READY_123  A1C
WAIT_FOR_READY_125  A44
WAIT_FOR_READY_128  A66
WAIT_FOR_READY_13   15E
WAIT_FOR_READY_130  AD6
WAIT_FOR_READY_133  AFA
WAIT_FOR_READY_135  B22
WAIT_FOR_READY_138  B44
WAIT_FOR_READY_139  B76
WAIT_FOR_READY_141  B90
WAIT_FOR_READY_145  BD0
WAIT_FOR_READY_147  C28
WAIT_FOR_READY_15   178
WAIT_FOR_READY_150  C4A
WAIT_FOR_READY_152  C72
WAIT_FOR_READY_154  C94
WAIT_FOR_READY_157  CB6
WAIT_FOR_READY_159  CDE
WAIT_FOR_READY_162  D00
WAIT_FOR_READY_168  DA4
WAIT_FOR_READY_170  DBE
WAIT_FOR_READY_174  DF8
WAIT_FOR_READY_176  E4A
WAIT_FOR_READY_177  E5E
WAIT_FOR_READY_18   1D6
WAIT_FOR_READY_180  E7E
WAIT_FOR_READY_182  EA6
WAIT_FOR_READY_184  EC8
WAIT_FOR_READY_187  EEA
WAIT_FOR_READY_189  F12
WAIT_FOR_READY_192  F34
WAIT_FOR_READY_20   226
WAIT_FOR_READY_22   252
WAIT_FOR_READY_25   27C
WAIT_FOR_READY_27   2A4
WAIT_FOR_READY_3    C0
WAIT_FOR_READY_30   2C6
WAIT_FOR_READY_31   2E4
WAIT_FOR_READY_33   2FE
WAIT_FOR_READY_37   33A
WAIT_FOR_READY_38   35A
WAIT_FOR_READY_40   394
WAIT_FOR_READY_41   3AA
WAIT_FOR_READY_43   3DE
WAIT_FOR_READY_45   400
WAIT_FOR_READY_47   434
WAIT_FOR_READY_5    E0
WAIT_FOR_READY_51   478
WAIT_FOR_READY_53   4B4
WAIT_FOR_READY_55   4E8
WAIT_FOR_READY_58   526
WAIT_FOR_READY_60   55A
WAIT_FOR_READY_63   5A2
WAIT_FOR_READY_65   5D6
WAIT_FOR_READY_68   620
WAIT_FOR_READY_7    100
WAIT_FOR_READY_70   654
WAIT_FOR_READY_73   6A8
WAIT_FOR_READY_75   6DC
WAIT_FOR_READY_78   71A
WAIT_FOR_READY_80   74E
WAIT_FOR_READY_83   78C
WAIT_FOR_READY_85   7C0
WAIT_FOR_READY_89   806
WAIT_FOR_READY_91   826
WAIT_FOR_READY_92   83A
WAIT_FOR_READY_95   858
WAIT_FOR_READY_97   87E
WAIT_FOR_READY_99   8B2
WAIT_FOR_SRECORD    35A
Z                   A86
_00000000           19E
_00000001           1B2
_00000002           494
_00000003           870
_00000004           4A2
_00000005           690
_00000006           606
_00000007           870
_00000008           7FA
_00000009           870
_0000000A           998
_0000000B           9A4
_0000000C           B58
_0000000D           D30
_0000000E           D4A
_0000000F           D5E
_00000010           D6E
_00000011           D82
_00000012           F54
_10000000           3F6
_10000001           45E
_10000002           4AA
_10000003           512
_10000004           51C
_10000005           584
_10000006           598
_10000007           600
_10000008           60A
_10000009           68A
_1000000A           616
_1000000B           67E
_1000000C           69E
_1000000D           706
_1000000E           710
_1000000F           778
_10000010           782
_10000011           7EA
_10000012           874
_10000013           8DC
_10000014           D14
_10000015           D36
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A92
_20000005           AA2
_20000006           AB6
_20000007           B5A
_20000008           B74
_20000009           BB8
_2000000A           DA2
_2000000B           DE6
