00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 01/04/2021 18:29:51

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000  =00000000                  9  DEBUG               EQU 0
00000000                            10  
00000000                            11  ; constants
00000000  =00E00000                 12  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 13  DISPLAY_            EQU $0
00000000  =00E00001                 14  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            15  
00000000  =00D30000                 16  DUART_BASE          EQU $D30000
00000000  =00000000                 17  DUART_MRA_          EQU $0
00000000  =00000001                 18  DUART_CSRA_         EQU $1
00000000  =00000001                 19  DUART_SRA_          EQU $1
00000000  =00000002                 20  DUART_CRA_          EQU $2
00000000  =00000003                 21  DUART_TXA_          EQU $3
00000000  =00000003                 22  DUART_RXA_          EQU $3
00000000  =00000004                 23  DUART_ACR_          EQU $4
00000000  =00000005                 24  DUART_IMR_          EQU $5
00000000  =00000008                 25  DUART_MRB_          EQU $8
00000000  =00000009                 26  DUART_CSRB_         EQU $9
00000000  =00000009                 27  DUART_SRB_          EQU $9
00000000  =0000000A                 28  DUART_CRB_          EQU $A
00000000  =0000000B                 29  DUART_TXB_          EQU $B
00000000  =0000000B                 30  DUART_RXB_          EQU $B
00000000  =0000000C                 31  DUART_IVR_          EQU $C
00000000  =0000000D                 32  DUART_OPCR_         EQU $D
00000000  =0000000E                 33  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 34  DUART_RESET_OPR_    EQU $F
00000000                            35  RRRR
00000000  =00D30001                 36  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 37  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 38  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 39  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 40  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 41  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            42  
00000000  =00D30011                 43  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 44  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 45  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 46  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 47  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 48  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            49  
00000000  =00D30009                 50  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 51  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 52  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 53  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 54  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 55  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            56  
00000000                            57  ; macros
00000000                            58  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            59  ; the input register is changed during the process
00000000                            60  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            61  BIN2HEX MACRO
00000000                            62    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            63    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            64    MOVE.B \1,\2
00000000                            65    ANDI.L #$F,\2
00000000                            66    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            67    ENDM
00000000                            68  
00000000                            69  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            70  ; the input register is changed during the process
00000000                            71  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            72  HEX2BIN MACRO
00000000                            73    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            74    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            75    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            76    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            77    ENDM
00000000                            78  
00000000                            79  ; send a single char to the serial port
00000000                            80  ; \1 = char to send, \2 = data register to use for status poll
00000000                            81  ; will stamp on D0 and D1 in debug mode
00000000                            82  PRINT_CHAR MACRO
00000000                            83  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            84      IFEQ DEBUG
00000000                            85        MOVE.B DUART_SRA,\2           ; read status register
00000000                            86        BTST #2,\2                    ; check for space to send
00000000                            87        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            88        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            89      ENDC
00000000                            90      
00000000                            91      IFNE DEBUG
00000000                            92        MOVE.B \1,D1
00000000                            93        MOVE.L #6,D0   
00000000                            94        TRAP #15                      ; write to terminal in simulator
00000000                            95      ENDC
00000000                            96  
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send CR,LF to the serial port
00000000                           100  ; \1 = data register to use for status poll
00000000                           101  PRINT_CRLF MACRO                  
00000000                           102      PRINT_CHAR #13,\1             ; CR
00000000                           103      PRINT_CHAR #10,\1             ; LF
00000000                           104      ENDM
00000000                           105  
00000000                           106  ; send C-style, zero terminated string to the serial port
00000000                           107  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           108  PRINT_STR MACRO
00000000                           109  LOOP\@
00000000                           110      CMP.B #0,(\1)                 ; 0 -> done
00000000                           111      BEQ EXIT\@
00000000                           112      PRINT_CHAR (\1)+,\2
00000000                           113      JMP LOOP\@
00000000                           114  EXIT\@
00000000                           115      ENDM
00000000                           116    
00000000                           117  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           118  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           119  PRINT_REG MACRO
00000000                           120      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           121  LOOP\@
00000000                           122      BIN2HEX \1,\3,\5
00000000                           123      PRINT_CHAR \3,\2
00000000                           124      DBEQ \4,LOOP\@
00000000                           125      ENDM
00000000                           126    
00000000                           127  ; wait for a char from the serial port
00000000                           128  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           129  ; will stamp on D0 and D1 in debug mode
00000000                           130  WAIT_CHAR MACRO
00000000                           131  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           132  
00000000                           133      IFEQ DEBUG
00000000                           134        MOVE.B DUART_SRA,\2         ; read status register
00000000                           135        BTST #0,\2                    ; check for character
00000000                           136        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           137      ENDC
00000000                           138      
00000000                           139      READ_CHAR \1
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        PRINT_CHAR \1,\2            ; echo it back
00000000                           143      ENDC
00000000                           144      ENDM
00000000                           145      
00000000                           146  ; read a char from the serial port - assumes that there is one!
00000000                           147  ; \ 1= data register for read char
00000000                           148  ; will stamp on D0 and D1 in debug mode
00000000                           149  READ_CHAR MACRO
00000000                           150      IFEQ DEBUG
00000000                           151        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           152      ENDC
00000000                           153      IFNE DEBUG
00000000                           154        MOVE.L #5,D0    
00000000                           155        TRAP #15                    ; read from keyboard in simulator
00000000                           156        MOVE.L D1,\1
00000000                           157      ENDC
00000000                           158       
00000000                           159      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           160      BEQ START
00000000                           161      ENDM
00000000                           162      
00000000                           163      
00000000                           164  ; read data from the download serial port
00000000                           165  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           166  DOWNLOAD MACRO
00000000                           167  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           168  
00000000                           169      MOVE.B DUART_SRA,\2           ; check for command
00000000                           170      BTST #0,\2                    ; check for character
00000000                           171      BEQ CONTINUE\@                ; nothing, continue
00000000                           172   
00000000                           173      READ_CHAR \1
00000000                           174  CONTINUE\@
00000000                           175      MOVE.B DUART_SRB,\2         ; read status register
00000000                           176      BTST #0,\2                  ; check for character
00000000                           177      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           178      
00000000                           179      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           180      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           181      
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; register catalogue
00000000                           186  ; D0 - used for simulator I/O
00000000                           187  ; D1 - used for simulator I/O
00000000                           188  ; D2 - read character
00000000                           189  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           190  ; D4 - count of S records read
00000000                           191  ; D5 - data to write / data read / byte count for S record load
00000000                           192  ; D6 - working register used in R/W and download
00000000                           193  ; D7 - address accumulator / reset by download
00000000                           194  ; A0 - address of string to print 
00000000                           195  
00000000                           196  ; start vector
00000000                           197      ORG  $0
00000000= 00000000                 198      DC.L $00000000              ; PC
00000004= 00000000                 199      DC.L $00000000              ; SP
00000008                           200      
00000008                           201  ; start of program  
00000008                           202  START
00000008  13FC 0000 00E00001       203      MOVE.B #0,DISPLAY
00000010                           204  
00000010                           205  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       206      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       207      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     208      NOP
00000022  13FC 0040 00D30005       209      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     210      NOP
0000002C  13FC 0030 00D30005       211      MOVE.B #$30,DUART_CRA
00000034  4E71                     212      NOP
00000036  13FC 0020 00D30005       213      MOVE.B #$20,DUART_CRA
0000003E  4E71                     214      NOP
00000040  13FC 0010 00D30005       215      MOVE.B #$10,DUART_CRA   
00000048                           216  
00000048  13FC 000A 00D30015       217      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       218      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     219      NOP
0000005A  13FC 0040 00D30015       220      MOVE.B #$40,DUART_CRB           
00000062  4E71                     221      NOP
00000064  13FC 0030 00D30015       222      MOVE.B #$30,DUART_CRB
0000006C  4E71                     223      NOP
0000006E  13FC 0020 00D30015       224      MOVE.B #$20,DUART_CRB
00000076  4E71                     225      NOP
00000078  13FC 0010 00D30015       226      MOVE.B #$10,DUART_CRB   
00000080                           227  
00000080                           228  ;initialise UART
00000080  13FC 0000 00D30009       229      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       230      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       231      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           232  
00000098                           233  ; channel A
00000098  13FC 0013 00D30001       234      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       235      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       236      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       237      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           238  
000000B8                           239  ; channel B
000000B8  13FC 0013 00D30011       240      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       241      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       242      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       243      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           244  
000000D8                           245m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           246m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      247m     IFEQ DEBUG
000000D8  1639 00D30003            248m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                249m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     250m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       251m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           252m     ENDC
000000EC                           253m     
000000EC                 FALSE     254m     IFNE DEBUG
000000EC                           255m     ENDC
000000EC                           256m 
000000EC                           257m     ENDM
000000EC                           258  
000000EC  13FC 0001 00E00001       259      MOVE.B #1,DISPLAY
000000F4                           260         
000000F4                           261m     PRINT_CRLF D3
000000F4                           262mm     PRINT_CHAR #13,D3             ; CR
000000F4                           263mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      264mm     IFEQ DEBUG
000000F4  1639 00D30003            265mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                266mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     267mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       268mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           269mm     ENDC
00000108                           270mm     
00000108                 FALSE     271mm     IFNE DEBUG
00000108                           272mm     ENDC
00000108                           273mm 
00000108                           274mm     ENDM
00000108                           275mm     PRINT_CHAR #10,D3             ; LF
00000108                           276mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      277mm     IFEQ DEBUG
00000108  1639 00D30003            278mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                279mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     280mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       281mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           282mm     ENDC
0000011C                           283mm     
0000011C                 FALSE     284mm     IFNE DEBUG
0000011C                           285mm     ENDC
0000011C                           286mm 
0000011C                           287mm     ENDM
0000011C                           288m     ENDM
0000011C                           289  
0000011C  41F9 00000E56            290      LEA VERSION,A0
00000122                           291m     PRINT_STR A0,D3
00000122                           292m LOOP_5
00000122  0C10 0000                293m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                294m     BEQ EXIT_5
0000012A                           295mm     PRINT_CHAR (A0)+,D3
0000012A                           296mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      297mm     IFEQ DEBUG
0000012A  1639 00D30003            298mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                299mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     300mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            301mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           302mm     ENDC
0000013C                           303mm     
0000013C                 FALSE     304mm     IFNE DEBUG
0000013C                           305mm     ENDC
0000013C                           306mm 
0000013C                           307mm     ENDM
0000013C  4EF8 0122                308m     JMP LOOP_5
00000140                           309m EXIT_5
00000140                           310m     ENDM
00000140                           311m     PRINT_CRLF D3
00000140                           312mm     PRINT_CHAR #13,D3             ; CR
00000140                           313mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      314mm     IFEQ DEBUG
00000140  1639 00D30003            315mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                316mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     317mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       318mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           319mm     ENDC
00000154                           320mm     
00000154                 FALSE     321mm     IFNE DEBUG
00000154                           322mm     ENDC
00000154                           323mm 
00000154                           324mm     ENDM
00000154                           325mm     PRINT_CHAR #10,D3             ; LF
00000154                           326mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      327mm     IFEQ DEBUG
00000154  1639 00D30003            328mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                329mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     330mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       331mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           332mm     ENDC
00000168                           333mm     
00000168                 FALSE     334mm     IFNE DEBUG
00000168                           335mm     ENDC
00000168                           336mm 
00000168                           337mm     ENDM
00000168                           338m     ENDM
00000168                           339m     PRINT_CHAR #7,D3
00000168                           340m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      341m     IFEQ DEBUG
00000168  1639 00D30003            342m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                343m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     344m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       345m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           346m     ENDC
0000017C                           347m     
0000017C                 FALSE     348m     IFNE DEBUG
0000017C                           349m     ENDC
0000017C                           350m 
0000017C                           351m     ENDM
0000017C                           352  
0000017C  7E00                     353      MOVE.L #0,D7                    ; address accumulator
0000017E                           354  
0000017E  13FC 0002 00E00001       355      MOVE.B #2,DISPLAY
00000186                           356  MAIN_LOOP
00000186                           357m     PRINT_CHAR #'>',D3               ; prompt
00000186                           358m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      359m     IFEQ DEBUG
00000186  1639 00D30003            360m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                361m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     362m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       363m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           364m     ENDC
0000019A                           365m     
0000019A                 FALSE     366m     IFNE DEBUG
0000019A                           367m     ENDC
0000019A                           368m 
0000019A                           369m     ENDM
0000019A                           370m     PRINT_CHAR #32,D3                ; space
0000019A                           371m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      372m     IFEQ DEBUG
0000019A  1639 00D30003            373m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                374m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     375m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       376m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           377m     ENDC
000001AE                           378m     
000001AE                 FALSE     379m     IFNE DEBUG
000001AE                           380m     ENDC
000001AE                           381m 
000001AE                           382m     ENDM
000001AE                           383      
000001AE                           384  GET_INPUT
000001AE                           385m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           386m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           387m 
000001AE                 TRUE      388m     IFEQ DEBUG
000001AE  1639 00D30003            389m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                390m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     391m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           392m     ENDC
000001BA                           393m     
000001BA                           394mm     READ_CHAR D2
000001BA                 TRUE      395mm     IFEQ DEBUG
000001BA  1439 00D30007            396mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           397mm     ENDC
000001C0                 FALSE     398mm     IFNE DEBUG
000001C0                           399mm     ENDC
000001C0                           400mm      
000001C0  B43C 001B                401mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                402mm     BEQ START
000001C8                           403mm     ENDM
000001C8                           404m 
000001C8                 TRUE      405m     IFEQ DEBUG
000001C8                           406mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           407mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      408mm     IFEQ DEBUG
000001C8  1639 00D30003            409mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                410mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     411mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            412mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           413mm     ENDC
000001DA                           414mm     
000001DA                 FALSE     415mm     IFNE DEBUG
000001DA                           416mm     ENDC
000001DA                           417mm 
000001DA                           418mm     ENDM
000001DA                           419m     ENDC
000001DA                           420m     ENDM
000001DA                           421      
000001DA  B43C 0030                422      CMP.B #'0',D2
000001DE  6700 0C56                423      BEQ HEX_DIGIT
000001E2  B43C 0031                424      CMP.B #'1',D2
000001E6  6700 0C4E                425      BEQ HEX_DIGIT
000001EA  B43C 0032                426      CMP.B #'2',D2
000001EE  6700 0C46                427      BEQ HEX_DIGIT
000001F2  B43C 0033                428      CMP.B #'3',D2
000001F6  6700 0C3E                429      BEQ HEX_DIGIT
000001FA  B43C 0034                430      CMP.B #'4',D2
000001FE  6700 0C36                431      BEQ HEX_DIGIT
00000202  B43C 0035                432      CMP.B #'5',D2
00000206  6700 0C2E                433      BEQ HEX_DIGIT
0000020A  B43C 0036                434      CMP.B #'6',D2
0000020E  6700 0C26                435      BEQ HEX_DIGIT
00000212  B43C 0037                436      CMP.B #'7',D2
00000216  6700 0C1E                437      BEQ HEX_DIGIT
0000021A  B43C 0038                438      CMP.B #'8',D2
0000021E  6700 0C16                439      BEQ HEX_DIGIT
00000222  B43C 0039                440      CMP.B #'9',D2
00000226  6700 0C0E                441      BEQ HEX_DIGIT
0000022A  B43C 0041                442      CMP.B #'A',D2
0000022E  6700 0C06                443      BEQ HEX_DIGIT
00000232  B43C 0042                444      CMP.B #'B',D2
00000236  6700 0BFE                445      BEQ HEX_DIGIT
0000023A  B43C 0043                446      CMP.B #'C',D2
0000023E  6700 0BF6                447      BEQ HEX_DIGIT
00000242  B43C 0044                448      CMP.B #'D',D2
00000246  6700 0BEE                449      BEQ HEX_DIGIT
0000024A  B43C 0045                450      CMP.B #'E',D2
0000024E  6700 0BE6                451      BEQ HEX_DIGIT
00000252  B43C 0046                452      CMP.B #'F',D2
00000256  6700 0BDE                453      BEQ HEX_DIGIT
0000025A                           454      
0000025A  B43C 0057                455      CMP.B #'W',D2
0000025E  6700 0128                456      BEQ W
00000262                           457  
00000262                           458m     PRINT_CRLF D3
00000262                           459mm     PRINT_CHAR #13,D3             ; CR
00000262                           460mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      461mm     IFEQ DEBUG
00000262  1639 00D30003            462mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                463mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     464mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       465mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           466mm     ENDC
00000276                           467mm     
00000276                 FALSE     468mm     IFNE DEBUG
00000276                           469mm     ENDC
00000276                           470mm 
00000276                           471mm     ENDM
00000276                           472mm     PRINT_CHAR #10,D3             ; LF
00000276                           473mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      474mm     IFEQ DEBUG
00000276  1639 00D30003            475mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                476mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     477mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       478mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           479mm     ENDC
0000028A                           480mm     
0000028A                 FALSE     481mm     IFNE DEBUG
0000028A                           482mm     ENDC
0000028A                           483mm 
0000028A                           484mm     ENDM
0000028A                           485m     ENDM
0000028A                           486   
0000028A  B43C 003F                487      CMP.B #'?',D2
0000028E  6700 004A                488      BEQ H
00000292                           489  
00000292  B43C 0056                490      CMP.B #'V',D2
00000296  6700 006A                491      BEQ V
0000029A                           492      
0000029A  B43C 0052                493      CMP.B #'R',D2
0000029E  6700 008A                494      BEQ R
000002A2                           495  
000002A2  B43C 0053                496      CMP.B #'S',D2
000002A6  6700 01A6                497      BEQ S
000002AA                           498  
000002AA  B43C 0047                499      CMP.B #'G',D2
000002AE  6700 0B7E                500      BEQ G   
000002B2                           501  
000002B2  41F9 00000EDD            502      LEA HUH,A0
000002B8                           503m     PRINT_STR A0,D3
000002B8                           504m LOOP_19
000002B8  0C10 0000                505m     CMP.B #0,(A0)                 ; 0 -> DONE
000002BC  6700 0018                506m     BEQ EXIT_19
000002C0                           507mm     PRINT_CHAR (A0)+,D3
000002C0                           508mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      509mm     IFEQ DEBUG
000002C0  1639 00D30003            510mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002C6  0803 0002                511mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002CA  67F4                     512mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002CC  13D8 00D30007            513mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002D2                           514mm     ENDC
000002D2                           515mm     
000002D2                 FALSE     516mm     IFNE DEBUG
000002D2                           517mm     ENDC
000002D2                           518mm 
000002D2                           519mm     ENDM
000002D2  4EF8 02B8                520m     JMP LOOP_19
000002D6                           521m EXIT_19
000002D6                           522m     ENDM
000002D6                           523                         
000002D6  4EF8 0186                524      JMP MAIN_LOOP
000002DA                           525      
000002DA                           526  ; commands
000002DA  41F9 00000E72            527  H   LEA HELP,A0
000002E0                           528m     PRINT_STR A0,D3
000002E0                           529m LOOP_21
000002E0  0C10 0000                530m     CMP.B #0,(A0)                 ; 0 -> DONE
000002E4  6700 0018                531m     BEQ EXIT_21
000002E8                           532mm     PRINT_CHAR (A0)+,D3
000002E8                           533mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      534mm     IFEQ DEBUG
000002E8  1639 00D30003            535mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002EE  0803 0002                536mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002F2  67F4                     537mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002F4  13D8 00D30007            538mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002FA                           539mm     ENDC
000002FA                           540mm     
000002FA                 FALSE     541mm     IFNE DEBUG
000002FA                           542mm     ENDC
000002FA                           543mm 
000002FA                           544mm     ENDM
000002FA  4EF8 02E0                545m     JMP LOOP_21
000002FE                           546m EXIT_21
000002FE                           547m     ENDM
000002FE  4EF8 0186                548      JMP MAIN_LOOP
00000302                           549  
00000302  41F9 00000E56            550  V   LEA VERSION,A0
00000308                           551m     PRINT_STR A0,D3       
00000308                           552m LOOP_23
00000308  0C10 0000                553m     CMP.B #0,(A0)                 ; 0 -> DONE
0000030C  6700 0018                554m     BEQ EXIT_23
00000310                           555mm     PRINT_CHAR (A0)+,D3
00000310                           556mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000310                 TRUE      557mm     IFEQ DEBUG
00000310  1639 00D30003            558mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000316  0803 0002                559mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000031A  67F4                     560mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0000031C  13D8 00D30007            561mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000322                           562mm     ENDC
00000322                           563mm     
00000322                 FALSE     564mm     IFNE DEBUG
00000322                           565mm     ENDC
00000322                           566mm 
00000322                           567mm     ENDM
00000322  4EF8 0308                568m     JMP LOOP_23
00000326                           569m EXIT_23
00000326                           570m     ENDM
00000326  4EF8 0186                571      JMP MAIN_LOOP
0000032A                           572      
0000032A                           573  R   
0000032A  2047                     574      MOVE.L D7,A0                    ; address accumulator -> address register
0000032C  2A10                     575      MOVE.L (A0),D5                  ; read the memory and print it
0000032E                           576m     PRINT_REG D5,D3,D7,D6,A0
0000032E  7C07                     577m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000330                           578m LOOP_25
00000330                           579mm     BIN2HEX D5,D7,A0
00000330  41F9 00000F64            580mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000336  E99D                     581mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000338  1E05                     582mm   MOVE.B D5,D7
0000033A  0287 0000000F            583mm   ANDI.L #$F,D7
00000340  1E30 7000                584mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000344                           585mm   ENDM
00000344                           586mm     PRINT_CHAR D7,D3
00000344                           587mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      588mm     IFEQ DEBUG
00000344  1639 00D30003            589mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000034A  0803 0002                590mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000034E  67F4                     591mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000350  13C7 00D30007            592mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000356                           593mm     ENDC
00000356                           594mm     
00000356                 FALSE     595mm     IFNE DEBUG
00000356                           596mm     ENDC
00000356                           597mm 
00000356                           598mm     ENDM
00000356  57CE FFD8                599m     DBEQ D6,LOOP_25
0000035A                           600m     ENDM
0000035A                           601m     PRINT_CRLF D3
0000035A                           602mm     PRINT_CHAR #13,D3             ; CR
0000035A                           603mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                 TRUE      604mm     IFEQ DEBUG
0000035A  1639 00D30003            605mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000360  0803 0002                606mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000364  67F4                     607mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000366  13FC 000D 00D30007       608mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000036E                           609mm     ENDC
0000036E                           610mm     
0000036E                 FALSE     611mm     IFNE DEBUG
0000036E                           612mm     ENDC
0000036E                           613mm 
0000036E                           614mm     ENDM
0000036E                           615mm     PRINT_CHAR #10,D3             ; LF
0000036E                           616mm WAIT_FOR_READY_30                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      617mm     IFEQ DEBUG
0000036E  1639 00D30003            618mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000374  0803 0002                619mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000378  67F4                     620mm       BEQ WAIT_FOR_READY_30          ; NO SPACE, CHECK AGAIN
0000037A  13FC 000A 00D30007       621mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000382                           622mm     ENDC
00000382                           623mm     
00000382                 FALSE     624mm     IFNE DEBUG
00000382                           625mm     ENDC
00000382                           626mm 
00000382                           627mm     ENDM
00000382                           628m     ENDM
00000382  7E00                     629      MOVE.L #0,D7                    ; clear the now used address accumulator
00000384  4EF8 0186                630      JMP MAIN_LOOP
00000388                           631  
00000388  7A00                     632  W   MOVE.L #0,D5                    ; D5 will be the value to write            
0000038A                           633  
0000038A                           634m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
0000038A                           635m WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                           636m 
0000038A                 TRUE      637m     IFEQ DEBUG
0000038A  1639 00D30003            638m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000390  0803 0000                639m       BTST #0,D3                    ; CHECK FOR CHARACTER
00000394  67F4                     640m       BEQ WAIT_FOR_READY_31          ; NOTHING, CHECK AGAIN
00000396                           641m     ENDC
00000396                           642m     
00000396                           643mm     READ_CHAR D2
00000396                 TRUE      644mm     IFEQ DEBUG
00000396  1439 00D30007            645mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000039C                           646mm     ENDC
0000039C                 FALSE     647mm     IFNE DEBUG
0000039C                           648mm     ENDC
0000039C                           649mm      
0000039C  B43C 001B                650mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003A0  6700 FC66                651mm     BEQ START
000003A4                           652mm     ENDM
000003A4                           653m 
000003A4                 TRUE      654m     IFEQ DEBUG
000003A4                           655mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003A4                           656mm WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A4                 TRUE      657mm     IFEQ DEBUG
000003A4  1639 00D30003            658mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003AA  0803 0002                659mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003AE  67F4                     660mm       BEQ WAIT_FOR_READY_33          ; NO SPACE, CHECK AGAIN
000003B0  13C2 00D30007            661mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003B6                           662mm     ENDC
000003B6                           663mm     
000003B6                 FALSE     664mm     IFNE DEBUG
000003B6                           665mm     ENDC
000003B6                           666mm 
000003B6                           667mm     ENDM
000003B6                           668m     ENDC
000003B6                           669m     ENDM
000003B6                           670m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003B6  41F9 00000F74            671m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003BC  0402 0030                672m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C4BC 000000FF            673m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000003C6  1430 2000                674m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000003CA                           675m   ENDM
000003CA  1A02                     676      MOVE.B D2,D5                    ; put at bottom of D5
000003CC                           677  
000003CC  3C3C 0006                678      MOVE #6,D6                      ; 7 bytes left to read
000003D0                           679      
000003D0                           680  READ_DATA_TO_POKE
000003D0  E98D                     681      LSL.L #4,D5                     ; make what we have so far more significant
000003D2                           682m     WAIT_CHAR D2,D3                 ; next character -> D2
000003D2                           683m WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D2                           684m 
000003D2                 TRUE      685m     IFEQ DEBUG
000003D2  1639 00D30003            686m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003D8  0803 0000                687m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003DC  67F4                     688m       BEQ WAIT_FOR_READY_35          ; NOTHING, CHECK AGAIN
000003DE                           689m     ENDC
000003DE                           690m     
000003DE                           691mm     READ_CHAR D2
000003DE                 TRUE      692mm     IFEQ DEBUG
000003DE  1439 00D30007            693mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003E4                           694mm     ENDC
000003E4                 FALSE     695mm     IFNE DEBUG
000003E4                           696mm     ENDC
000003E4                           697mm      
000003E4  B43C 001B                698mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003E8  6700 FC1E                699mm     BEQ START
000003EC                           700mm     ENDM
000003EC                           701m 
000003EC                 TRUE      702m     IFEQ DEBUG
000003EC                           703mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003EC                           704mm WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EC                 TRUE      705mm     IFEQ DEBUG
000003EC  1639 00D30003            706mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003F2  0803 0002                707mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003F6  67F4                     708mm       BEQ WAIT_FOR_READY_37          ; NO SPACE, CHECK AGAIN
000003F8  13C2 00D30007            709mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003FE                           710mm     ENDC
000003FE                           711mm     
000003FE                 FALSE     712mm     IFNE DEBUG
000003FE                           713mm     ENDC
000003FE                           714mm 
000003FE                           715mm     ENDM
000003FE                           716m     ENDC
000003FE                           717m     ENDM
000003FE                           718m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003FE  41F9 00000F74            719m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000404  0402 0030                720m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000408  C4BC 000000FF            721m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000040E  1430 2000                722m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000412                           723m   ENDM
00000412  8A02                     724      OR.B D2,D5
00000414  023C 00FB                725      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000418  57CE FFB6                726      DBEQ D6,READ_DATA_TO_POKE
0000041C                           727      
0000041C  2047                     728      MOVE.L D7,A0                    ; address accumulator -> address register
0000041E  7E00                     729      MOVE.L #0,D7                    ; clear the now used address accumulator
00000420                           730      
00000420  2082                     731      MOVE.L D2,(A0)                  ; write the data
00000422                           732  
00000422                           733m     PRINT_CRLF D3
00000422                           734mm     PRINT_CHAR #13,D3             ; CR
00000422                           735mm WAIT_FOR_READY_40                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000422                 TRUE      736mm     IFEQ DEBUG
00000422  1639 00D30003            737mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000428  0803 0002                738mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000042C  67F4                     739mm       BEQ WAIT_FOR_READY_40          ; NO SPACE, CHECK AGAIN
0000042E  13FC 000D 00D30007       740mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000436                           741mm     ENDC
00000436                           742mm     
00000436                 FALSE     743mm     IFNE DEBUG
00000436                           744mm     ENDC
00000436                           745mm 
00000436                           746mm     ENDM
00000436                           747mm     PRINT_CHAR #10,D3             ; LF
00000436                           748mm WAIT_FOR_READY_41                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000436                 TRUE      749mm     IFEQ DEBUG
00000436  1639 00D30003            750mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000043C  0803 0002                751mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000440  67F4                     752mm       BEQ WAIT_FOR_READY_41          ; NO SPACE, CHECK AGAIN
00000442  13FC 000A 00D30007       753mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000044A                           754mm     ENDC
0000044A                           755mm     
0000044A                 FALSE     756mm     IFNE DEBUG
0000044A                           757mm     ENDC
0000044A                           758mm 
0000044A                           759mm     ENDM
0000044A                           760m     ENDM
0000044A  4EF8 0186                761      JMP MAIN_LOOP
0000044E                           762  
0000044E                           763  
0000044E  7800                     764  S   MOVE.L #0,D4                    ; count of records read -> D4
00000450  2478 0000                765      MOVE.L 0,A2                     ; start address -> A2
00000454                           766      
00000454                           767  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00000454                           768m     DOWNLOAD D2,D3                  
00000454                           769m WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000454                           770m 
00000454  1639 00D30003            771m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000045A  0803 0000                772m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000045E  6700 0010                773m     BEQ CONTINUE_42                ; NOTHING, CONTINUE
00000462                           774m  
00000462                           775mm     READ_CHAR D2
00000462                 TRUE      776mm     IFEQ DEBUG
00000462  1439 00D30007            777mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000468                           778mm     ENDC
00000468                 FALSE     779mm     IFNE DEBUG
00000468                           780mm     ENDC
00000468                           781mm      
00000468  B43C 001B                782mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000046C  6700 FB9A                783mm     BEQ START
00000470                           784mm     ENDM
00000470                           785m CONTINUE_42
00000470  1639 00D30013            786m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000476  0803 0000                787m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000047A  67D8                     788m     BEQ WAIT_FOR_READY_42        ; NOTHING, CHECK AGAIN
0000047C                           789m     
0000047C  1439 00D30017            790m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000482  13C2 00E00001            791m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000488                           792m     
00000488                           793m     ENDM
00000488  B43C 0053                794      CMP.B #'S',D2                   ; found S?    
0000048C  66C6                     795      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
0000048E                           796      
0000048E  5284                     797      ADD.L #1,D4                     ; read another S record, increment count
00000490                           798      
00000490                           799m     DOWNLOAD D7,D3                  ; read the record digit
00000490                           800m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000490                           801m 
00000490  1639 00D30003            802m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000496  0803 0000                803m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000049A  6700 0010                804m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
0000049E                           805m  
0000049E                           806mm     READ_CHAR D7
0000049E                 TRUE      807mm     IFEQ DEBUG
0000049E  1E39 00D30007            808mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
000004A4                           809mm     ENDC
000004A4                 FALSE     810mm     IFNE DEBUG
000004A4                           811mm     ENDC
000004A4                           812mm      
000004A4  BE3C 001B                813mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
000004A8  6700 FB5E                814mm     BEQ START
000004AC                           815mm     ENDM
000004AC                           816m CONTINUE_44
000004AC  1639 00D30013            817m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004B2  0803 0000                818m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004B6  67D8                     819m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004B8                           820m     
000004B8  1E39 00D30017            821m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
000004BE  13C7 00E00001            822m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
000004C4                           823m     
000004C4                           824m     ENDM
000004C4                           825  
000004C4  7C00                     826      MOVE.L #0,D6                    ; checksum
000004C6                           827  
000004C6  7A00                     828      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
000004C8                           829m     DOWNLOAD D2,D3              
000004C8                           830m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C8                           831m 
000004C8  1639 00D30003            832m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004CE  0803 0000                833m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004D2  6700 0010                834m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004D6                           835m  
000004D6                           836mm     READ_CHAR D2
000004D6                 TRUE      837mm     IFEQ DEBUG
000004D6  1439 00D30007            838mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000004DC                           839mm     ENDC
000004DC                 FALSE     840mm     IFNE DEBUG
000004DC                           841mm     ENDC
000004DC                           842mm      
000004DC  B43C 001B                843mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000004E0  6700 FB26                844mm     BEQ START
000004E4                           845mm     ENDM
000004E4                           846m CONTINUE_46
000004E4  1639 00D30013            847m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004EA  0803 0000                848m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004EE  67D8                     849m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
000004F0                           850m     
000004F0  1439 00D30017            851m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004F6  13C2 00E00001            852m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004FC                           853m     
000004FC                           854m     ENDM
000004FC                           855m     HEX2BIN D2,D2,A0
000004FC  41F9 00000F74            856m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000502  0402 0030                857m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000506  C4BC 000000FF            858m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000050C  1430 2000                859m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000510                           860m   ENDM
00000510  8A82                     861      OR.L D2,D5
00000512  E98D                     862      LSL.L #4,D5    
00000514                           863m     DOWNLOAD D2,D3
00000514                           864m WAIT_FOR_READY_49                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000514                           865m 
00000514  1639 00D30003            866m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000051A  0803 0000                867m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000051E  6700 0010                868m     BEQ CONTINUE_49                ; NOTHING, CONTINUE
00000522                           869m  
00000522                           870mm     READ_CHAR D2
00000522                 TRUE      871mm     IFEQ DEBUG
00000522  1439 00D30007            872mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000528                           873mm     ENDC
00000528                 FALSE     874mm     IFNE DEBUG
00000528                           875mm     ENDC
00000528                           876mm      
00000528  B43C 001B                877mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000052C  6700 FADA                878mm     BEQ START
00000530                           879mm     ENDM
00000530                           880m CONTINUE_49
00000530  1639 00D30013            881m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000536  0803 0000                882m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000053A  67D8                     883m     BEQ WAIT_FOR_READY_49        ; NOTHING, CHECK AGAIN
0000053C                           884m     
0000053C  1439 00D30017            885m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000542  13C2 00E00001            886m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000548                           887m     
00000548                           888m     ENDM
00000548                           889m     HEX2BIN D2,D2,A0  
00000548  41F9 00000F74            890m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000054E  0402 0030                891m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000552  C4BC 000000FF            892m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000558  1430 2000                893m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000055C                           894m   ENDM
0000055C  8A82                     895      OR.L D2,D5
0000055E                           896                  
0000055E  DC85                     897      ADD.L D5,D6                     ; add byte count into checksum
00000560                           898  
00000560                           899      IF.B D7 <EQ> #'0' THEN.L        ; header
00000568  7E00                     900          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
0000056A                           901m         DOWNLOAD D2,D3              ; top byte
0000056A                           902m WAIT_FOR_READY_52                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056A                           903m 
0000056A  1639 00D30003            904m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000570  0803 0000                905m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000574  6700 0010                906m     BEQ CONTINUE_52                ; NOTHING, CONTINUE
00000578                           907m  
00000578                           908mm     READ_CHAR D2
00000578                 TRUE      909mm     IFEQ DEBUG
00000578  1439 00D30007            910mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000057E                           911mm     ENDC
0000057E                 FALSE     912mm     IFNE DEBUG
0000057E                           913mm     ENDC
0000057E                           914mm      
0000057E  B43C 001B                915mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000582  6700 FA84                916mm     BEQ START
00000586                           917mm     ENDM
00000586                           918m CONTINUE_52
00000586  1639 00D30013            919m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000058C  0803 0000                920m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000590  67D8                     921m     BEQ WAIT_FOR_READY_52        ; NOTHING, CHECK AGAIN
00000592                           922m     
00000592  1439 00D30017            923m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000598  13C2 00E00001            924m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000059E                           925m     
0000059E                           926m     ENDM
0000059E                           927m         HEX2BIN D2,D2,A0
0000059E  41F9 00000F74            928m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005A4  0402 0030                929m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005A8  C4BC 000000FF            930m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005AE  1430 2000                931m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005B2                           932m   ENDM
000005B2  8E82                     933          OR.L D2,D7
000005B4  E98F                     934          LSL.L #4,D7
000005B6                           935m         DOWNLOAD D2,D3         
000005B6                           936m WAIT_FOR_READY_55                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B6                           937m 
000005B6  1639 00D30003            938m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005BC  0803 0000                939m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005C0  6700 0010                940m     BEQ CONTINUE_55                ; NOTHING, CONTINUE
000005C4                           941m  
000005C4                           942mm     READ_CHAR D2
000005C4                 TRUE      943mm     IFEQ DEBUG
000005C4  1439 00D30007            944mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005CA                           945mm     ENDC
000005CA                 FALSE     946mm     IFNE DEBUG
000005CA                           947mm     ENDC
000005CA                           948mm      
000005CA  B43C 001B                949mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005CE  6700 FA38                950mm     BEQ START
000005D2                           951mm     ENDM
000005D2                           952m CONTINUE_55
000005D2  1639 00D30013            953m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005D8  0803 0000                954m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005DC  67D8                     955m     BEQ WAIT_FOR_READY_55        ; NOTHING, CHECK AGAIN
000005DE                           956m     
000005DE  1439 00D30017            957m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005E4  13C2 00E00001            958m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005EA                           959m     
000005EA                           960m     ENDM
000005EA                           961m         HEX2BIN D2,D2,A0
000005EA  41F9 00000F74            962m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005F0  0402 0030                963m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005F4  C4BC 000000FF            964m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005FA  1430 2000                965m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005FE                           966m   ENDM
000005FE  8E82                     967          OR.L D2,D7
00000600                           968          
00000600  DC87                     969          ADD.L D7,D6                 ; add top byte of address into checksum
00000602                           970  
00000602  E98F                     971          LSL.L #4,D7                 ; bottom byte
00000604                           972m         DOWNLOAD D2,D3
00000604                           973m WAIT_FOR_READY_58                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000604                           974m 
00000604  1639 00D30003            975m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000060A  0803 0000                976m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000060E  6700 0010                977m     BEQ CONTINUE_58                ; NOTHING, CONTINUE
00000612                           978m  
00000612                           979mm     READ_CHAR D2
00000612                 TRUE      980mm     IFEQ DEBUG
00000612  1439 00D30007            981mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000618                           982mm     ENDC
00000618                 FALSE     983mm     IFNE DEBUG
00000618                           984mm     ENDC
00000618                           985mm      
00000618  B43C 001B                986mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000061C  6700 F9EA                987mm     BEQ START
00000620                           988mm     ENDM
00000620                           989m CONTINUE_58
00000620  1639 00D30013            990m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000626  0803 0000                991m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000062A  67D8                     992m     BEQ WAIT_FOR_READY_58        ; NOTHING, CHECK AGAIN
0000062C                           993m     
0000062C  1439 00D30017            994m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000632  13C2 00E00001            995m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000638                           996m     
00000638                           997m     ENDM
00000638                           998m         HEX2BIN D2,D2,A0
00000638  41F9 00000F74            999m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000063E  0402 0030               1000m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000642  C4BC 000000FF           1001m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000648  1430 2000               1002m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000064C                          1003m   ENDM
0000064C  8E82                    1004          OR.L D2,D7
0000064E  E98F                    1005          LSL.L #4,D7        
00000650                          1006m         DOWNLOAD D2,D3
00000650                          1007m WAIT_FOR_READY_61                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000650                          1008m 
00000650  1639 00D30003           1009m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000656  0803 0000               1010m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000065A  6700 0010               1011m     BEQ CONTINUE_61                ; NOTHING, CONTINUE
0000065E                          1012m  
0000065E                          1013mm     READ_CHAR D2
0000065E                 TRUE     1014mm     IFEQ DEBUG
0000065E  1439 00D30007           1015mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000664                          1016mm     ENDC
00000664                 FALSE    1017mm     IFNE DEBUG
00000664                          1018mm     ENDC
00000664                          1019mm      
00000664  B43C 001B               1020mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000668  6700 F99E               1021mm     BEQ START
0000066C                          1022mm     ENDM
0000066C                          1023m CONTINUE_61
0000066C  1639 00D30013           1024m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000672  0803 0000               1025m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000676  67D8                    1026m     BEQ WAIT_FOR_READY_61        ; NOTHING, CHECK AGAIN
00000678                          1027m     
00000678  1439 00D30017           1028m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000067E  13C2 00E00001           1029m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000684                          1030m     
00000684                          1031m     ENDM
00000684                          1032m         HEX2BIN D2,D2,A0
00000684  41F9 00000F74           1033m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000068A  0402 0030               1034m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000068E  C4BC 000000FF           1035m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000694  1430 2000               1036m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000698                          1037m   ENDM
00000698  8E82                    1038          OR.L D2,D7
0000069A                          1039          
0000069A  7400                    1040          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
0000069C  1407                    1041          MOVE.B D7,D2
0000069E  DC82                    1042          ADD.L D2,D6
000006A0                          1043          
000006A0  5785                    1044          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006A2                          1045          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006AC  5385                    1046            SUB.L #1,D5
000006AE                          1047              
000006AE  7E00                    1048            MOVE.L #0,D7              ; D7 holds the byte
000006B0                          1049              
000006B0                          1050m           DOWNLOAD D2,D3            ; MS 4 bits
000006B0                          1051m WAIT_FOR_READY_64                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006B0                          1052m 
000006B0  1639 00D30003           1053m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006B6  0803 0000               1054m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006BA  6700 0010               1055m     BEQ CONTINUE_64                ; NOTHING, CONTINUE
000006BE                          1056m  
000006BE                          1057mm     READ_CHAR D2
000006BE                 TRUE     1058mm     IFEQ DEBUG
000006BE  1439 00D30007           1059mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006C4                          1060mm     ENDC
000006C4                 FALSE    1061mm     IFNE DEBUG
000006C4                          1062mm     ENDC
000006C4                          1063mm      
000006C4  B43C 001B               1064mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006C8  6700 F93E               1065mm     BEQ START
000006CC                          1066mm     ENDM
000006CC                          1067m CONTINUE_64
000006CC  1639 00D30013           1068m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006D2  0803 0000               1069m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006D6  67D8                    1070m     BEQ WAIT_FOR_READY_64        ; NOTHING, CHECK AGAIN
000006D8                          1071m     
000006D8  1439 00D30017           1072m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006DE  13C2 00E00001           1073m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006E4                          1074m     
000006E4                          1075m     ENDM
000006E4                          1076m           HEX2BIN D2,D2,A0
000006E4  41F9 00000F74           1077m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000006EA  0402 0030               1078m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006EE  C4BC 000000FF           1079m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000006F4  1430 2000               1080m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006F8                          1081m   ENDM
000006F8  8E82                    1082            OR.L D2,D7
000006FA  E98F                    1083            LSL.L #4,D7
000006FC                          1084               
000006FC                          1085m           DOWNLOAD D2,D3            ; LS 4 bits    
000006FC                          1086m WAIT_FOR_READY_67                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                          1087m 
000006FC  1639 00D30003           1088m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000702  0803 0000               1089m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000706  6700 0010               1090m     BEQ CONTINUE_67                ; NOTHING, CONTINUE
0000070A                          1091m  
0000070A                          1092mm     READ_CHAR D2
0000070A                 TRUE     1093mm     IFEQ DEBUG
0000070A  1439 00D30007           1094mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000710                          1095mm     ENDC
00000710                 FALSE    1096mm     IFNE DEBUG
00000710                          1097mm     ENDC
00000710                          1098mm      
00000710  B43C 001B               1099mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000714  6700 F8F2               1100mm     BEQ START
00000718                          1101mm     ENDM
00000718                          1102m CONTINUE_67
00000718  1639 00D30013           1103m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000071E  0803 0000               1104m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000722  67D8                    1105m     BEQ WAIT_FOR_READY_67        ; NOTHING, CHECK AGAIN
00000724                          1106m     
00000724  1439 00D30017           1107m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000072A  13C2 00E00001           1108m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000730                          1109m     
00000730                          1110m     ENDM
00000730                          1111m           HEX2BIN D2,D2,A0
00000730  41F9 00000F74           1112m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000736  0402 0030               1113m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000073A  C4BC 000000FF           1114m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000740  1430 2000               1115m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000744                          1116m   ENDM
00000744  8E82                    1117            OR.L D2,D7
00000746                          1118              
00000746  DC87                    1119            ADD.L D7,D6               ; add into checksum
00000748                          1120            
00000748                          1121m           PRINT_CHAR D7,D3          ; assume ASCII and print it
00000748                          1122m WAIT_FOR_READY_70                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000748                 TRUE     1123m     IFEQ DEBUG
00000748  1639 00D30003           1124m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000074E  0803 0002               1125m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000752  67F4                    1126m       BEQ WAIT_FOR_READY_70          ; NO SPACE, CHECK AGAIN
00000754  13C7 00D30007           1127m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000075A                          1128m     ENDC
0000075A                          1129m     
0000075A                 FALSE    1130m     IFNE DEBUG
0000075A                          1131m     ENDC
0000075A                          1132m 
0000075A                          1133m     ENDM
0000075A                          1134          ENDW
0000075E                          1135m         PRINT_CRLF D3
0000075E                          1136mm     PRINT_CHAR #13,D3             ; CR
0000075E                          1137mm WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000075E                 TRUE     1138mm     IFEQ DEBUG
0000075E  1639 00D30003           1139mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000764  0803 0002               1140mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000768  67F4                    1141mm       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
0000076A  13FC 000D 00D30007      1142mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000772                          1143mm     ENDC
00000772                          1144mm     
00000772                 FALSE    1145mm     IFNE DEBUG
00000772                          1146mm     ENDC
00000772                          1147mm 
00000772                          1148mm     ENDM
00000772                          1149mm     PRINT_CHAR #10,D3             ; LF
00000772                          1150mm WAIT_FOR_READY_73                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000772                 TRUE     1151mm     IFEQ DEBUG
00000772  1639 00D30003           1152mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000778  0803 0002               1153mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000077C  67F4                    1154mm       BEQ WAIT_FOR_READY_73          ; NO SPACE, CHECK AGAIN
0000077E  13FC 000A 00D30007      1155mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000786                          1156mm     ENDC
00000786                          1157mm     
00000786                 FALSE    1158mm     IFNE DEBUG
00000786                          1159mm     ENDC
00000786                          1160mm 
00000786                          1161mm     ENDM
00000786                          1162m     ENDM
00000786  43F8 0454               1163         LEA WAIT_FOR_SRECORD,A1            
0000078A                          1164      ELSE
0000078E                          1165        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit data record
00000796  7E00                    1166          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000798                          1167m         DOWNLOAD D2,D3              ; top byte
00000798                          1168m WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                          1169m 
00000798  1639 00D30003           1170m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000079E  0803 0000               1171m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007A2  6700 0010               1172m     BEQ CONTINUE_74                ; NOTHING, CONTINUE
000007A6                          1173m  
000007A6                          1174mm     READ_CHAR D2
000007A6                 TRUE     1175mm     IFEQ DEBUG
000007A6  1439 00D30007           1176mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007AC                          1177mm     ENDC
000007AC                 FALSE    1178mm     IFNE DEBUG
000007AC                          1179mm     ENDC
000007AC                          1180mm      
000007AC  B43C 001B               1181mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007B0  6700 F856               1182mm     BEQ START
000007B4                          1183mm     ENDM
000007B4                          1184m CONTINUE_74
000007B4  1639 00D30013           1185m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007BA  0803 0000               1186m     BTST #0,D3                  ; CHECK FOR CHARACTER
000007BE  67D8                    1187m     BEQ WAIT_FOR_READY_74        ; NOTHING, CHECK AGAIN
000007C0                          1188m     
000007C0  1439 00D30017           1189m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000007C6  13C2 00E00001           1190m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000007CC                          1191m     
000007CC                          1192m     ENDM
000007CC                          1193m         PRINT_CHAR D2,D3
000007CC                          1194m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CC                 TRUE     1195m     IFEQ DEBUG
000007CC  1639 00D30003           1196m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007D2  0803 0002               1197m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007D6  67F4                    1198m       BEQ WAIT_FOR_READY_76          ; NO SPACE, CHECK AGAIN
000007D8  13C2 00D30007           1199m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000007DE                          1200m     ENDC
000007DE                          1201m     
000007DE                 FALSE    1202m     IFNE DEBUG
000007DE                          1203m     ENDC
000007DE                          1204m 
000007DE                          1205m     ENDM
000007DE                          1206m         HEX2BIN D2,D2,A0
000007DE  41F9 00000F74           1207m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000007E4  0402 0030               1208m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007E8  C4BC 000000FF           1209m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000007EE  1430 2000               1210m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000007F2                          1211m   ENDM
000007F2  8E82                    1212          OR.L D2,D7
000007F4  E98F                    1213          LSL.L #4,D7
000007F6                          1214m         DOWNLOAD D2,D3         
000007F6                          1215m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F6                          1216m 
000007F6  1639 00D30003           1217m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007FC  0803 0000               1218m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000800  6700 0010               1219m     BEQ CONTINUE_78                ; NOTHING, CONTINUE
00000804                          1220m  
00000804                          1221mm     READ_CHAR D2
00000804                 TRUE     1222mm     IFEQ DEBUG
00000804  1439 00D30007           1223mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000080A                          1224mm     ENDC
0000080A                 FALSE    1225mm     IFNE DEBUG
0000080A                          1226mm     ENDC
0000080A                          1227mm      
0000080A  B43C 001B               1228mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000080E  6700 F7F8               1229mm     BEQ START
00000812                          1230mm     ENDM
00000812                          1231m CONTINUE_78
00000812  1639 00D30013           1232m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000818  0803 0000               1233m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000081C  67D8                    1234m     BEQ WAIT_FOR_READY_78        ; NOTHING, CHECK AGAIN
0000081E                          1235m     
0000081E  1439 00D30017           1236m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000824  13C2 00E00001           1237m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000082A                          1238m     
0000082A                          1239m     ENDM
0000082A                          1240m         PRINT_CHAR D2,D3
0000082A                          1241m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082A                 TRUE     1242m     IFEQ DEBUG
0000082A  1639 00D30003           1243m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000830  0803 0002               1244m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000834  67F4                    1245m       BEQ WAIT_FOR_READY_80          ; NO SPACE, CHECK AGAIN
00000836  13C2 00D30007           1246m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000083C                          1247m     ENDC
0000083C                          1248m     
0000083C                 FALSE    1249m     IFNE DEBUG
0000083C                          1250m     ENDC
0000083C                          1251m 
0000083C                          1252m     ENDM
0000083C                          1253m         HEX2BIN D2,D2,A0
0000083C  41F9 00000F74           1254m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000842  0402 0030               1255m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000846  C4BC 000000FF           1256m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000084C  1430 2000               1257m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000850                          1258m   ENDM
00000850  8E82                    1259          OR.L D2,D7
00000852                          1260          
00000852  DC87                    1261          ADD.L D7,D6                 ; add top byte of address into checksum
00000854                          1262  
00000854  E98F                    1263          LSL.L #4,D7                 ; bottom byte
00000856                          1264m         DOWNLOAD D2,D3
00000856                          1265m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000856                          1266m 
00000856  1639 00D30003           1267m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000085C  0803 0000               1268m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000860  6700 0010               1269m     BEQ CONTINUE_82                ; NOTHING, CONTINUE
00000864                          1270m  
00000864                          1271mm     READ_CHAR D2
00000864                 TRUE     1272mm     IFEQ DEBUG
00000864  1439 00D30007           1273mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000086A                          1274mm     ENDC
0000086A                 FALSE    1275mm     IFNE DEBUG
0000086A                          1276mm     ENDC
0000086A                          1277mm      
0000086A  B43C 001B               1278mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000086E  6700 F798               1279mm     BEQ START
00000872                          1280mm     ENDM
00000872                          1281m CONTINUE_82
00000872  1639 00D30013           1282m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000878  0803 0000               1283m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000087C  67D8                    1284m     BEQ WAIT_FOR_READY_82        ; NOTHING, CHECK AGAIN
0000087E                          1285m     
0000087E  1439 00D30017           1286m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000884  13C2 00E00001           1287m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000088A                          1288m     
0000088A                          1289m     ENDM
0000088A                          1290m         PRINT_CHAR D2,D3
0000088A                          1291m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088A                 TRUE     1292m     IFEQ DEBUG
0000088A  1639 00D30003           1293m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000890  0803 0002               1294m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000894  67F4                    1295m       BEQ WAIT_FOR_READY_84          ; NO SPACE, CHECK AGAIN
00000896  13C2 00D30007           1296m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000089C                          1297m     ENDC
0000089C                          1298m     
0000089C                 FALSE    1299m     IFNE DEBUG
0000089C                          1300m     ENDC
0000089C                          1301m 
0000089C                          1302m     ENDM
0000089C                          1303m         HEX2BIN D2,D2,A0
0000089C  41F9 00000F74           1304m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000008A2  0402 0030               1305m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008A6  C4BC 000000FF           1306m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000008AC  1430 2000               1307m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000008B0                          1308m   ENDM
000008B0  8E82                    1309          OR.L D2,D7
000008B2  E98F                    1310          LSL.L #4,D7        
000008B4                          1311m         DOWNLOAD D2,D3
000008B4                          1312m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B4                          1313m 
000008B4  1639 00D30003           1314m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000008BA  0803 0000               1315m     BTST #0,D3                    ; CHECK FOR CHARACTER
000008BE  6700 0010               1316m     BEQ CONTINUE_86                ; NOTHING, CONTINUE
000008C2                          1317m  
000008C2                          1318mm     READ_CHAR D2
000008C2                 TRUE     1319mm     IFEQ DEBUG
000008C2  1439 00D30007           1320mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000008C8                          1321mm     ENDC
000008C8                 FALSE    1322mm     IFNE DEBUG
000008C8                          1323mm     ENDC
000008C8                          1324mm      
000008C8  B43C 001B               1325mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008CC  6700 F73A               1326mm     BEQ START
000008D0                          1327mm     ENDM
000008D0                          1328m CONTINUE_86
000008D0  1639 00D30013           1329m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008D6  0803 0000               1330m     BTST #0,D3                  ; CHECK FOR CHARACTER
000008DA  67D8                    1331m     BEQ WAIT_FOR_READY_86        ; NOTHING, CHECK AGAIN
000008DC                          1332m     
000008DC  1439 00D30017           1333m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000008E2  13C2 00E00001           1334m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000008E8                          1335m     
000008E8                          1336m     ENDM
000008E8                          1337m         PRINT_CHAR D2,D3
000008E8                          1338m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E8                 TRUE     1339m     IFEQ DEBUG
000008E8  1639 00D30003           1340m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008EE  0803 0002               1341m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008F2  67F4                    1342m       BEQ WAIT_FOR_READY_88          ; NO SPACE, CHECK AGAIN
000008F4  13C2 00D30007           1343m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000008FA                          1344m     ENDC
000008FA                          1345m     
000008FA                 FALSE    1346m     IFNE DEBUG
000008FA                          1347m     ENDC
000008FA                          1348m 
000008FA                          1349m     ENDM
000008FA                          1350m         HEX2BIN D2,D2,A0
000008FA  41F9 00000F74           1351m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000900  0402 0030               1352m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000904  C4BC 000000FF           1353m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000090A  1430 2000               1354m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000090E                          1355m   ENDM
0000090E  8E82                    1356          OR.L D2,D7
00000910                          1357          
00000910  7400                    1358          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000912  1407                    1359          MOVE.B D7,D2
00000914  DC82                    1360          ADD.L D2,D6
00000916                          1361          
00000916  2247                    1362          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000918                          1363                 
00000918  5785                    1364          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
0000091A                          1365          WHILE.L D5 <GT> #0 DO       ; read the data bytes
00000924  5385                    1366            SUB.L #1,D5
00000926                          1367              
00000926  7E00                    1368            MOVE.L #0,D7              ; D7 holds the byte
00000928                          1369              
00000928                          1370m           DOWNLOAD D2,D3            ; MS 4 bits
00000928                          1371m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000928                          1372m 
00000928  1639 00D30003           1373m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000092E  0803 0000               1374m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000932  6700 0010               1375m     BEQ CONTINUE_90                ; NOTHING, CONTINUE
00000936                          1376m  
00000936                          1377mm     READ_CHAR D2
00000936                 TRUE     1378mm     IFEQ DEBUG
00000936  1439 00D30007           1379mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000093C                          1380mm     ENDC
0000093C                 FALSE    1381mm     IFNE DEBUG
0000093C                          1382mm     ENDC
0000093C                          1383mm      
0000093C  B43C 001B               1384mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000940  6700 F6C6               1385mm     BEQ START
00000944                          1386mm     ENDM
00000944                          1387m CONTINUE_90
00000944  1639 00D30013           1388m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000094A  0803 0000               1389m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000094E  67D8                    1390m     BEQ WAIT_FOR_READY_90        ; NOTHING, CHECK AGAIN
00000950                          1391m     
00000950  1439 00D30017           1392m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000956  13C2 00E00001           1393m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000095C                          1394m     
0000095C                          1395m     ENDM
0000095C                          1396m           PRINT_CHAR D2,D3
0000095C                          1397m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                 TRUE     1398m     IFEQ DEBUG
0000095C  1639 00D30003           1399m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000962  0803 0002               1400m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000966  67F4                    1401m       BEQ WAIT_FOR_READY_92          ; NO SPACE, CHECK AGAIN
00000968  13C2 00D30007           1402m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000096E                          1403m     ENDC
0000096E                          1404m     
0000096E                 FALSE    1405m     IFNE DEBUG
0000096E                          1406m     ENDC
0000096E                          1407m 
0000096E                          1408m     ENDM
0000096E                          1409m           HEX2BIN D2,D2,A0
0000096E  41F9 00000F74           1410m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000974  0402 0030               1411m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000978  C4BC 000000FF           1412m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000097E  1430 2000               1413m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000982                          1414m   ENDM
00000982  8E82                    1415            OR.L D2,D7
00000984  E98F                    1416            LSL.L #4,D7
00000986                          1417               
00000986                          1418m           DOWNLOAD D2,D3            ; LS 4 bits    
00000986                          1419m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000986                          1420m 
00000986  1639 00D30003           1421m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000098C  0803 0000               1422m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000990  6700 0010               1423m     BEQ CONTINUE_94                ; NOTHING, CONTINUE
00000994                          1424m  
00000994                          1425mm     READ_CHAR D2
00000994                 TRUE     1426mm     IFEQ DEBUG
00000994  1439 00D30007           1427mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000099A                          1428mm     ENDC
0000099A                 FALSE    1429mm     IFNE DEBUG
0000099A                          1430mm     ENDC
0000099A                          1431mm      
0000099A  B43C 001B               1432mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000099E  6700 F668               1433mm     BEQ START
000009A2                          1434mm     ENDM
000009A2                          1435m CONTINUE_94
000009A2  1639 00D30013           1436m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000009A8  0803 0000               1437m     BTST #0,D3                  ; CHECK FOR CHARACTER
000009AC  67D8                    1438m     BEQ WAIT_FOR_READY_94        ; NOTHING, CHECK AGAIN
000009AE                          1439m     
000009AE  1439 00D30017           1440m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000009B4  13C2 00E00001           1441m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009BA                          1442m     
000009BA                          1443m     ENDM
000009BA                          1444m           PRINT_CHAR D2,D3
000009BA                          1445m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BA                 TRUE     1446m     IFEQ DEBUG
000009BA  1639 00D30003           1447m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009C0  0803 0002               1448m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009C4  67F4                    1449m       BEQ WAIT_FOR_READY_96          ; NO SPACE, CHECK AGAIN
000009C6  13C2 00D30007           1450m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000009CC                          1451m     ENDC
000009CC                          1452m     
000009CC                 FALSE    1453m     IFNE DEBUG
000009CC                          1454m     ENDC
000009CC                          1455m 
000009CC                          1456m     ENDM
000009CC                          1457m           HEX2BIN D2,D2,A0
000009CC  41F9 00000F74           1458m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000009D2  0402 0030               1459m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009D6  C4BC 000000FF           1460m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009DC  1430 2000               1461m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009E0                          1462m   ENDM
000009E0  8E82                    1463            OR.L D2,D7
000009E2                          1464              
000009E2  DC87                    1465            ADD.L D7,D6               ; add into checksum            
000009E4                          1466          ENDW
000009E8                          1467m         PRINT_CRLF D3
000009E8                          1468mm     PRINT_CHAR #13,D3             ; CR
000009E8                          1469mm WAIT_FOR_READY_99                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E8                 TRUE     1470mm     IFEQ DEBUG
000009E8  1639 00D30003           1471mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009EE  0803 0002               1472mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009F2  67F4                    1473mm       BEQ WAIT_FOR_READY_99          ; NO SPACE, CHECK AGAIN
000009F4  13FC 000D 00D30007      1474mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000009FC                          1475mm     ENDC
000009FC                          1476mm     
000009FC                 FALSE    1477mm     IFNE DEBUG
000009FC                          1478mm     ENDC
000009FC                          1479mm 
000009FC                          1480mm     ENDM
000009FC                          1481mm     PRINT_CHAR #10,D3             ; LF
000009FC                          1482mm WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FC                 TRUE     1483mm     IFEQ DEBUG
000009FC  1639 00D30003           1484mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A02  0803 0002               1485mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A06  67F4                    1486mm       BEQ WAIT_FOR_READY_100          ; NO SPACE, CHECK AGAIN
00000A08  13FC 000A 00D30007      1487mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A10                          1488mm     ENDC
00000A10                          1489mm     
00000A10                 FALSE    1490mm     IFNE DEBUG
00000A10                          1491mm     ENDC
00000A10                          1492mm 
00000A10                          1493mm     ENDM
00000A10                          1494m     ENDM
00000A10  43F8 0454               1495          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00000A14                          1496        ELSE
00000A18                          1497          IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00000A20  7E00                    1498            MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000A22                          1499m           DOWNLOAD D2,D3            ; top byte
00000A22                          1500m WAIT_FOR_READY_101                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A22                          1501m 
00000A22  1639 00D30003           1502m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A28  0803 0000               1503m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A2C  6700 0010               1504m     BEQ CONTINUE_101                ; NOTHING, CONTINUE
00000A30                          1505m  
00000A30                          1506mm     READ_CHAR D2
00000A30                 TRUE     1507mm     IFEQ DEBUG
00000A30  1439 00D30007           1508mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A36                          1509mm     ENDC
00000A36                 FALSE    1510mm     IFNE DEBUG
00000A36                          1511mm     ENDC
00000A36                          1512mm      
00000A36  B43C 001B               1513mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A3A  6700 F5CC               1514mm     BEQ START
00000A3E                          1515mm     ENDM
00000A3E                          1516m CONTINUE_101
00000A3E  1639 00D30013           1517m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A44  0803 0000               1518m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A48  67D8                    1519m     BEQ WAIT_FOR_READY_101        ; NOTHING, CHECK AGAIN
00000A4A                          1520m     
00000A4A  1439 00D30017           1521m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A50  13C2 00E00001           1522m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000A56                          1523m     
00000A56                          1524m     ENDM
00000A56                          1525m           HEX2BIN D2,D2,A0
00000A56  41F9 00000F74           1526m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A5C  0402 0030               1527m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A60  C4BC 000000FF           1528m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A66  1430 2000               1529m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A6A                          1530m   ENDM
00000A6A  8E82                    1531            OR.L D2,D7
00000A6C  E98F                    1532            LSL.L #4,D7
00000A6E                          1533m           DOWNLOAD D2,D3         
00000A6E                          1534m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6E                          1535m 
00000A6E  1639 00D30003           1536m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A74  0803 0000               1537m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A78  6700 0010               1538m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00000A7C                          1539m  
00000A7C                          1540mm     READ_CHAR D2
00000A7C                 TRUE     1541mm     IFEQ DEBUG
00000A7C  1439 00D30007           1542mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A82                          1543mm     ENDC
00000A82                 FALSE    1544mm     IFNE DEBUG
00000A82                          1545mm     ENDC
00000A82                          1546mm      
00000A82  B43C 001B               1547mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A86  6700 F580               1548mm     BEQ START
00000A8A                          1549mm     ENDM
00000A8A                          1550m CONTINUE_104
00000A8A  1639 00D30013           1551m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A90  0803 0000               1552m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A94  67D8                    1553m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00000A96                          1554m     
00000A96  1439 00D30017           1555m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A9C  13C2 00E00001           1556m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000AA2                          1557m     
00000AA2                          1558m     ENDM
00000AA2                          1559m           HEX2BIN D2,D2,A0
00000AA2  41F9 00000F74           1560m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000AA8  0402 0030               1561m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AAC  C4BC 000000FF           1562m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000AB2  1430 2000               1563m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000AB6                          1564m   ENDM
00000AB6  8E82                    1565            OR.L D2,D7
00000AB8                          1566          
00000AB8  DC87                    1567            ADD.L D7,D6               ; add top byte of address into checksum
00000ABA                          1568  
00000ABA  E98F                    1569            LSL.L #4,D7               ; middle byte
00000ABC                          1570m           DOWNLOAD D2,D3
00000ABC                          1571m WAIT_FOR_READY_107                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ABC                          1572m 
00000ABC  1639 00D30003           1573m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AC2  0803 0000               1574m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AC6  6700 0010               1575m     BEQ CONTINUE_107                ; NOTHING, CONTINUE
00000ACA                          1576m  
00000ACA                          1577mm     READ_CHAR D2
00000ACA                 TRUE     1578mm     IFEQ DEBUG
00000ACA  1439 00D30007           1579mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AD0                          1580mm     ENDC
00000AD0                 FALSE    1581mm     IFNE DEBUG
00000AD0                          1582mm     ENDC
00000AD0                          1583mm      
00000AD0  B43C 001B               1584mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AD4  6700 F532               1585mm     BEQ START
00000AD8                          1586mm     ENDM
00000AD8                          1587m CONTINUE_107
00000AD8  1639 00D30013           1588m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000ADE  0803 0000               1589m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000AE2  67D8                    1590m     BEQ WAIT_FOR_READY_107        ; NOTHING, CHECK AGAIN
00000AE4                          1591m     
00000AE4  1439 00D30017           1592m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000AEA  13C2 00E00001           1593m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000AF0                          1594m     
00000AF0                          1595m     ENDM
00000AF0                          1596m           HEX2BIN D2,D2,A0
00000AF0  41F9 00000F74           1597m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000AF6  0402 0030               1598m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AFA  C4BC 000000FF           1599m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B00  1430 2000               1600m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B04                          1601m   ENDM
00000B04  8E82                    1602            OR.L D2,D7
00000B06  E98F                    1603            LSL.L #4,D7        
00000B08                          1604m           DOWNLOAD D2,D3
00000B08                          1605m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B08                          1606m 
00000B08  1639 00D30003           1607m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B0E  0803 0000               1608m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B12  6700 0010               1609m     BEQ CONTINUE_110                ; NOTHING, CONTINUE
00000B16                          1610m  
00000B16                          1611mm     READ_CHAR D2
00000B16                 TRUE     1612mm     IFEQ DEBUG
00000B16  1439 00D30007           1613mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B1C                          1614mm     ENDC
00000B1C                 FALSE    1615mm     IFNE DEBUG
00000B1C                          1616mm     ENDC
00000B1C                          1617mm      
00000B1C  B43C 001B               1618mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B20  6700 F4E6               1619mm     BEQ START
00000B24                          1620mm     ENDM
00000B24                          1621m CONTINUE_110
00000B24  1639 00D30013           1622m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B2A  0803 0000               1623m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B2E  67D8                    1624m     BEQ WAIT_FOR_READY_110        ; NOTHING, CHECK AGAIN
00000B30                          1625m     
00000B30  1439 00D30017           1626m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B36  13C2 00E00001           1627m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B3C                          1628m     
00000B3C                          1629m     ENDM
00000B3C                          1630m           HEX2BIN D2,D2,A0
00000B3C  41F9 00000F74           1631m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B42  0402 0030               1632m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B46  C4BC 000000FF           1633m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B4C  1430 2000               1634m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B50                          1635m   ENDM
00000B50  8E82                    1636            OR.L D2,D7
00000B52                          1637          
00000B52  7400                    1638            MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
00000B54  1407                    1639            MOVE.B D7,D2
00000B56  DC82                    1640            ADD.L D2,D6
00000B58                          1641            
00000B58  E98F                    1642            LSL.L #4,D7               ; bottom byte
00000B5A                          1643m           DOWNLOAD D2,D3
00000B5A                          1644m WAIT_FOR_READY_113                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                          1645m 
00000B5A  1639 00D30003           1646m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B60  0803 0000               1647m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B64  6700 0010               1648m     BEQ CONTINUE_113                ; NOTHING, CONTINUE
00000B68                          1649m  
00000B68                          1650mm     READ_CHAR D2
00000B68                 TRUE     1651mm     IFEQ DEBUG
00000B68  1439 00D30007           1652mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B6E                          1653mm     ENDC
00000B6E                 FALSE    1654mm     IFNE DEBUG
00000B6E                          1655mm     ENDC
00000B6E                          1656mm      
00000B6E  B43C 001B               1657mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B72  6700 F494               1658mm     BEQ START
00000B76                          1659mm     ENDM
00000B76                          1660m CONTINUE_113
00000B76  1639 00D30013           1661m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B7C  0803 0000               1662m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B80  67D8                    1663m     BEQ WAIT_FOR_READY_113        ; NOTHING, CHECK AGAIN
00000B82                          1664m     
00000B82  1439 00D30017           1665m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B88  13C2 00E00001           1666m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B8E                          1667m     
00000B8E                          1668m     ENDM
00000B8E                          1669m           HEX2BIN D2,D2,A0
00000B8E  41F9 00000F74           1670m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B94  0402 0030               1671m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B98  C4BC 000000FF           1672m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B9E  1430 2000               1673m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BA2                          1674m   ENDM
00000BA2  8E82                    1675            OR.L D2,D7
00000BA4  E98F                    1676            LSL.L #4,D7        
00000BA6                          1677m           DOWNLOAD D2,D3
00000BA6                          1678m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA6                          1679m 
00000BA6  1639 00D30003           1680m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000BAC  0803 0000               1681m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000BB0  6700 0010               1682m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00000BB4                          1683m  
00000BB4                          1684mm     READ_CHAR D2
00000BB4                 TRUE     1685mm     IFEQ DEBUG
00000BB4  1439 00D30007           1686mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000BBA                          1687mm     ENDC
00000BBA                 FALSE    1688mm     IFNE DEBUG
00000BBA                          1689mm     ENDC
00000BBA                          1690mm      
00000BBA  B43C 001B               1691mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BBE  6700 F448               1692mm     BEQ START
00000BC2                          1693mm     ENDM
00000BC2                          1694m CONTINUE_116
00000BC2  1639 00D30013           1695m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BC8  0803 0000               1696m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BCC  67D8                    1697m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00000BCE                          1698m     
00000BCE  1439 00D30017           1699m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BD4  13C2 00E00001           1700m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000BDA                          1701m     
00000BDA                          1702m     ENDM
00000BDA                          1703m           HEX2BIN D2,D2,A0
00000BDA  41F9 00000F74           1704m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000BE0  0402 0030               1705m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BE4  C4BC 000000FF           1706m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000BEA  1430 2000               1707m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BEE                          1708m   ENDM
00000BEE  8E82                    1709            OR.L D2,D7
00000BF0                          1710          
00000BF0  7400                    1711            MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00000BF2  1407                    1712            MOVE.B D7,D2
00000BF4  DC82                    1713            ADD.L D2,D6
00000BF6                          1714            
00000BF6  2447                    1715            MOVE.L D7,A2              ; start address -> A2
00000BF8                          1716          
00000BF8  43F9 00000D84           1717            LEA DOWNLOAD_DONE,A1      ; next place to go
00000BFE                          1718          ELSE
00000C02  41F9 00000F18           1719            LEA UNREC,A0              ; warn for unrecognised type
00000C08                          1720m           PRINT_STR A0,D3
00000C08                          1721m LOOP_119
00000C08  0C10 0000               1722m     CMP.B #0,(A0)                 ; 0 -> DONE
00000C0C  6700 0018               1723m     BEQ EXIT_119
00000C10                          1724mm     PRINT_CHAR (A0)+,D3
00000C10                          1725mm WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C10                 TRUE     1726mm     IFEQ DEBUG
00000C10  1639 00D30003           1727mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C16  0803 0002               1728mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C1A  67F4                    1729mm       BEQ WAIT_FOR_READY_120          ; NO SPACE, CHECK AGAIN
00000C1C  13D8 00D30007           1730mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C22                          1731mm     ENDC
00000C22                          1732mm     
00000C22                 FALSE    1733mm     IFNE DEBUG
00000C22                          1734mm     ENDC
00000C22                          1735mm 
00000C22                          1736mm     ENDM
00000C22  4EF8 0C08               1737m     JMP LOOP_119
00000C26                          1738m EXIT_119
00000C26                          1739m     ENDM
00000C26                          1740m           PRINT_CHAR D7,D3
00000C26                          1741m WAIT_FOR_READY_121                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C26                 TRUE     1742m     IFEQ DEBUG
00000C26  1639 00D30003           1743m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C2C  0803 0002               1744m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C30  67F4                    1745m       BEQ WAIT_FOR_READY_121          ; NO SPACE, CHECK AGAIN
00000C32  13C7 00D30007           1746m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C38                          1747m     ENDC
00000C38                          1748m     
00000C38                 FALSE    1749m     IFNE DEBUG
00000C38                          1750m     ENDC
00000C38                          1751m 
00000C38                          1752m     ENDM
00000C38                          1753m           PRINT_CRLF D3
00000C38                          1754mm     PRINT_CHAR #13,D3             ; CR
00000C38                          1755mm WAIT_FOR_READY_123                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C38                 TRUE     1756mm     IFEQ DEBUG
00000C38  1639 00D30003           1757mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C3E  0803 0002               1758mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C42  67F4                    1759mm       BEQ WAIT_FOR_READY_123          ; NO SPACE, CHECK AGAIN
00000C44  13FC 000D 00D30007      1760mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C4C                          1761mm     ENDC
00000C4C                          1762mm     
00000C4C                 FALSE    1763mm     IFNE DEBUG
00000C4C                          1764mm     ENDC
00000C4C                          1765mm 
00000C4C                          1766mm     ENDM
00000C4C                          1767mm     PRINT_CHAR #10,D3             ; LF
00000C4C                          1768mm WAIT_FOR_READY_124                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4C                 TRUE     1769mm     IFEQ DEBUG
00000C4C  1639 00D30003           1770mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C52  0803 0002               1771mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C56  67F4                    1772mm       BEQ WAIT_FOR_READY_124          ; NO SPACE, CHECK AGAIN
00000C58  13FC 000A 00D30007      1773mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C60                          1774mm     ENDC
00000C60                          1775mm     
00000C60                 FALSE    1776mm     IFNE DEBUG
00000C60                          1777mm     ENDC
00000C60                          1778mm 
00000C60                          1779mm     ENDM
00000C60                          1780m     ENDM
00000C60                          1781      
00000C60  4EF8 0454               1782            JMP WAIT_FOR_SRECORD      ; ignore any other type    
00000C64                          1783          ENDI
00000C64                          1784        ENDI
00000C64                          1785      ENDI
00000C64                          1786      
00000C64  4686                    1787      NOT.L D6                        ; ones complement the checksum
00000C66  0286 000000FF           1788      ANDI.L #$FF,D6                  ; and take the LSByte
00000C6C                          1789          
00000C6C  7E00                    1790      MOVE.L #0,D7                    ; read the checksum from the data stream
00000C6E                          1791m     DOWNLOAD D2,D3                  ; top byte
00000C6E                          1792m WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6E                          1793m 
00000C6E  1639 00D30003           1794m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000C74  0803 0000               1795m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000C78  6700 0010               1796m     BEQ CONTINUE_125                ; NOTHING, CONTINUE
00000C7C                          1797m  
00000C7C                          1798mm     READ_CHAR D2
00000C7C                 TRUE     1799mm     IFEQ DEBUG
00000C7C  1439 00D30007           1800mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000C82                          1801mm     ENDC
00000C82                 FALSE    1802mm     IFNE DEBUG
00000C82                          1803mm     ENDC
00000C82                          1804mm      
00000C82  B43C 001B               1805mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000C86  6700 F380               1806mm     BEQ START
00000C8A                          1807mm     ENDM
00000C8A                          1808m CONTINUE_125
00000C8A  1639 00D30013           1809m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000C90  0803 0000               1810m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000C94  67D8                    1811m     BEQ WAIT_FOR_READY_125        ; NOTHING, CHECK AGAIN
00000C96                          1812m     
00000C96  1439 00D30017           1813m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000C9C  13C2 00E00001           1814m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000CA2                          1815m     
00000CA2                          1816m     ENDM
00000CA2                          1817m     HEX2BIN D2,D2,A0
00000CA2  41F9 00000F74           1818m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000CA8  0402 0030               1819m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CAC  C4BC 000000FF           1820m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000CB2  1430 2000               1821m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000CB6                          1822m   ENDM
00000CB6  8E82                    1823      OR.L D2,D7
00000CB8  E98F                    1824      LSL.L #4,D7
00000CBA                          1825m     DOWNLOAD D2,D3                  ; bottom byte
00000CBA                          1826m WAIT_FOR_READY_128                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CBA                          1827m 
00000CBA  1639 00D30003           1828m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CC0  0803 0000               1829m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CC4  6700 0010               1830m     BEQ CONTINUE_128                ; NOTHING, CONTINUE
00000CC8                          1831m  
00000CC8                          1832mm     READ_CHAR D2
00000CC8                 TRUE     1833mm     IFEQ DEBUG
00000CC8  1439 00D30007           1834mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CCE                          1835mm     ENDC
00000CCE                 FALSE    1836mm     IFNE DEBUG
00000CCE                          1837mm     ENDC
00000CCE                          1838mm      
00000CCE  B43C 001B               1839mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CD2  6700 F334               1840mm     BEQ START
00000CD6                          1841mm     ENDM
00000CD6                          1842m CONTINUE_128
00000CD6  1639 00D30013           1843m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000CDC  0803 0000               1844m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000CE0  67D8                    1845m     BEQ WAIT_FOR_READY_128        ; NOTHING, CHECK AGAIN
00000CE2                          1846m     
00000CE2  1439 00D30017           1847m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000CE8  13C2 00E00001           1848m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000CEE                          1849m     
00000CEE                          1850m     ENDM
00000CEE                          1851m     HEX2BIN D2,D2,A0
00000CEE  41F9 00000F74           1852m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000CF4  0402 0030               1853m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CF8  C4BC 000000FF           1854m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000CFE  1430 2000               1855m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D02                          1856m   ENDM
00000D02  8E82                    1857      OR.L D2,D7
00000D04                          1858                  
00000D04                          1859      IF.B D7 <NE> D6 THEN.L
00000D0A  41F9 00000F3E           1860        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00000D10                          1861m       PRINT_STR A0,D3
00000D10                          1862m LOOP_131
00000D10  0C10 0000               1863m     CMP.B #0,(A0)                 ; 0 -> DONE
00000D14  6700 0018               1864m     BEQ EXIT_131
00000D18                          1865mm     PRINT_CHAR (A0)+,D3
00000D18                          1866mm WAIT_FOR_READY_132                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D18                 TRUE     1867mm     IFEQ DEBUG
00000D18  1639 00D30003           1868mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D1E  0803 0002               1869mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D22  67F4                    1870mm       BEQ WAIT_FOR_READY_132          ; NO SPACE, CHECK AGAIN
00000D24  13D8 00D30007           1871mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D2A                          1872mm     ENDC
00000D2A                          1873mm     
00000D2A                 FALSE    1874mm     IFNE DEBUG
00000D2A                          1875mm     ENDC
00000D2A                          1876mm 
00000D2A                          1877mm     ENDM
00000D2A  4EF8 0D10               1878m     JMP LOOP_131
00000D2E                          1879m EXIT_131
00000D2E                          1880m     ENDM
00000D2E                          1881m       PRINT_REG D4,D3,D6,D7,A0
00000D2E  7E07                    1882m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D30                          1883m LOOP_133
00000D30                          1884mm     BIN2HEX D4,D6,A0
00000D30  41F9 00000F64           1885mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000D36  E99C                    1886mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D38  1C04                    1887mm   MOVE.B D4,D6
00000D3A  0286 0000000F           1888mm   ANDI.L #$F,D6
00000D40  1C30 6000               1889mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
00000D44                          1890mm   ENDM
00000D44                          1891mm     PRINT_CHAR D6,D3
00000D44                          1892mm WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D44                 TRUE     1893mm     IFEQ DEBUG
00000D44  1639 00D30003           1894mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D4A  0803 0002               1895mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D4E  67F4                    1896mm       BEQ WAIT_FOR_READY_135          ; NO SPACE, CHECK AGAIN
00000D50  13C6 00D30007           1897mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D56                          1898mm     ENDC
00000D56                          1899mm     
00000D56                 FALSE    1900mm     IFNE DEBUG
00000D56                          1901mm     ENDC
00000D56                          1902mm 
00000D56                          1903mm     ENDM
00000D56  57CF FFD8               1904m     DBEQ D7,LOOP_133
00000D5A                          1905m     ENDM
00000D5A                          1906m       PRINT_CRLF D3     
00000D5A                          1907mm     PRINT_CHAR #13,D3             ; CR
00000D5A                          1908mm WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5A                 TRUE     1909mm     IFEQ DEBUG
00000D5A  1639 00D30003           1910mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D60  0803 0002               1911mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D64  67F4                    1912mm       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00000D66  13FC 000D 00D30007      1913mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D6E                          1914mm     ENDC
00000D6E                          1915mm     
00000D6E                 FALSE    1916mm     IFNE DEBUG
00000D6E                          1917mm     ENDC
00000D6E                          1918mm 
00000D6E                          1919mm     ENDM
00000D6E                          1920mm     PRINT_CHAR #10,D3             ; LF
00000D6E                          1921mm WAIT_FOR_READY_138                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6E                 TRUE     1922mm     IFEQ DEBUG
00000D6E  1639 00D30003           1923mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D74  0803 0002               1924mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D78  67F4                    1925mm       BEQ WAIT_FOR_READY_138          ; NO SPACE, CHECK AGAIN
00000D7A  13FC 000A 00D30007      1926mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D82                          1927mm     ENDC
00000D82                          1928mm     
00000D82                 FALSE    1929mm     IFNE DEBUG
00000D82                          1930mm     ENDC
00000D82                          1931mm 
00000D82                          1932mm     ENDM
00000D82                          1933m     ENDM
00000D82                          1934      ENDI
00000D82                          1935      
00000D82  4ED1                    1936      JMP (A1)
00000D84                          1937  DOWNLOAD_DONE
00000D84                          1938m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00000D84  7C07                    1939m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D86                          1940m LOOP_139
00000D86                          1941mm     BIN2HEX D4,D7,A0
00000D86  41F9 00000F64           1942mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000D8C  E99C                    1943mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D8E  1E04                    1944mm   MOVE.B D4,D7
00000D90  0287 0000000F           1945mm   ANDI.L #$F,D7
00000D96  1E30 7000               1946mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000D9A                          1947mm   ENDM
00000D9A                          1948mm     PRINT_CHAR D7,D3
00000D9A                          1949mm WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D9A                 TRUE     1950mm     IFEQ DEBUG
00000D9A  1639 00D30003           1951mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DA0  0803 0002               1952mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DA4  67F4                    1953mm       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00000DA6  13C7 00D30007           1954mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DAC                          1955mm     ENDC
00000DAC                          1956mm     
00000DAC                 FALSE    1957mm     IFNE DEBUG
00000DAC                          1958mm     ENDC
00000DAC                          1959mm 
00000DAC                          1960mm     ENDM
00000DAC  57CE FFD8               1961m     DBEQ D6,LOOP_139
00000DB0                          1962m     ENDM
00000DB0  41F9 00000EF4           1963      LEA READ,A0
00000DB6                          1964m     PRINT_STR A0,D3
00000DB6                          1965m LOOP_142
00000DB6  0C10 0000               1966m     CMP.B #0,(A0)                 ; 0 -> DONE
00000DBA  6700 0018               1967m     BEQ EXIT_142
00000DBE                          1968mm     PRINT_CHAR (A0)+,D3
00000DBE                          1969mm WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBE                 TRUE     1970mm     IFEQ DEBUG
00000DBE  1639 00D30003           1971mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DC4  0803 0002               1972mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DC8  67F4                    1973mm       BEQ WAIT_FOR_READY_143          ; NO SPACE, CHECK AGAIN
00000DCA  13D8 00D30007           1974mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DD0                          1975mm     ENDC
00000DD0                          1976mm     
00000DD0                 FALSE    1977mm     IFNE DEBUG
00000DD0                          1978mm     ENDC
00000DD0                          1979mm 
00000DD0                          1980mm     ENDM
00000DD0  4EF8 0DB6               1981m     JMP LOOP_142
00000DD4                          1982m EXIT_142
00000DD4                          1983m     ENDM
00000DD4  2E0A                    1984      MOVE.L A2,D7                    ; set address accumulator to start address
00000DD6                          1985m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
00000DD6  7C07                    1986m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DD8                          1987m LOOP_144
00000DD8                          1988mm     BIN2HEX D7,D2,A0
00000DD8  41F9 00000F64           1989mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000DDE  E99F                    1990mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DE0  1407                    1991mm   MOVE.B D7,D2
00000DE2  0282 0000000F           1992mm   ANDI.L #$F,D2
00000DE8  1430 2000               1993mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00000DEC                          1994mm   ENDM
00000DEC                          1995mm     PRINT_CHAR D2,D3
00000DEC                          1996mm WAIT_FOR_READY_146                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     1997mm     IFEQ DEBUG
00000DEC  1639 00D30003           1998mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DF2  0803 0002               1999mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DF6  67F4                    2000mm       BEQ WAIT_FOR_READY_146          ; NO SPACE, CHECK AGAIN
00000DF8  13C2 00D30007           2001mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DFE                          2002mm     ENDC
00000DFE                          2003mm     
00000DFE                 FALSE    2004mm     IFNE DEBUG
00000DFE                          2005mm     ENDC
00000DFE                          2006mm 
00000DFE                          2007mm     ENDM
00000DFE  57CE FFD8               2008m     DBEQ D6,LOOP_144
00000E02                          2009m     ENDM
00000E02                          2010m     PRINT_CRLF D3     
00000E02                          2011mm     PRINT_CHAR #13,D3             ; CR
00000E02                          2012mm WAIT_FOR_READY_148                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E02                 TRUE     2013mm     IFEQ DEBUG
00000E02  1639 00D30003           2014mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E08  0803 0002               2015mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E0C  67F4                    2016mm       BEQ WAIT_FOR_READY_148          ; NO SPACE, CHECK AGAIN
00000E0E  13FC 000D 00D30007      2017mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E16                          2018mm     ENDC
00000E16                          2019mm     
00000E16                 FALSE    2020mm     IFNE DEBUG
00000E16                          2021mm     ENDC
00000E16                          2022mm 
00000E16                          2023mm     ENDM
00000E16                          2024mm     PRINT_CHAR #10,D3             ; LF
00000E16                          2025mm WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E16                 TRUE     2026mm     IFEQ DEBUG
00000E16  1639 00D30003           2027mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E1C  0803 0002               2028mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E20  67F4                    2029mm       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00000E22  13FC 000A 00D30007      2030mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E2A                          2031mm     ENDC
00000E2A                          2032mm     
00000E2A                 FALSE    2033mm     IFNE DEBUG
00000E2A                          2034mm     ENDC
00000E2A                          2035mm 
00000E2A                          2036mm     ENDM
00000E2A                          2037m     ENDM
00000E2A                          2038          
00000E2A  4EF8 0186               2039      JMP MAIN_LOOP
00000E2E                          2040      
00000E2E  2047                    2041  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000E30  3E3C 0000               2042      MOVE #0,D7                      ; clear the now used address accumulator
00000E34  4ED0                    2043      JMP (A0)                        ; jump to it!
00000E36                          2044          
00000E36                          2045  HEX_DIGIT
00000E36  E98F                    2046      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000E38                          2047m     HEX2BIN D2,D2,A0
00000E38  41F9 00000F74           2048m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000E3E  0402 0030               2049m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E42  C4BC 000000FF           2050m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000E48  1430 2000               2051m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000E4C                          2052m   ENDM
00000E4C  8E02                    2053      OR.B D2,D7  
00000E4E  4EF8 01AE               2054      JMP GET_INPUT
00000E52                          2055  
00000E52  FFFF FFFF               2056      SIMHALT                         ; halt simulator
00000E56                          2057  
00000E56                          2058  ; strings
00000E56= 4D 44 46 2D 6D 6F ...   2059  VERSION DC.B 'MDF-mon V1.8 (01/04/2021)',13,10,0
00000E72= 3F 20 48 65 6C 70 ...   2060  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
00000EDD= 48 75 68 3F 0D 0A 00    2061  HUH     DC.B 'Huh?',13,10,0
00000EE4= 55 6E 69 6D 70 6C ...   2062  UNIMP   DC.B 'Unimplemented',13,10,0
00000EF4= 20 53 20 72 65 63 ...   2063  READ    DC.B ' S records read, start address = 0x',0
00000F18= 57 41 52 4E 49 4E ...   2064  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00000F3E= 57 41 52 4E 49 4E ...   2065  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00000F64= 30 31 32 33 34 35 ...   2066  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000F74= 00 01 02 03 04 05 ...   2067  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000F8B= 4F 76 65 72 72 75 ...   2068  OVERRUN DC.B 'Overrun!',0
00000F94                          2069      
00000F94                          2070      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         F64
CONTINUE_101        A3E
CONTINUE_104        A8A
CONTINUE_107        AD8
CONTINUE_110        B24
CONTINUE_113        B76
CONTINUE_116        BC2
CONTINUE_125        C8A
CONTINUE_128        CD6
CONTINUE_42         470
CONTINUE_44         4AC
CONTINUE_46         4E4
CONTINUE_49         530
CONTINUE_52         586
CONTINUE_55         5D2
CONTINUE_58         620
CONTINUE_61         66C
CONTINUE_64         6CC
CONTINUE_67         718
CONTINUE_74         7B4
CONTINUE_78         812
CONTINUE_82         872
CONTINUE_86         8D0
CONTINUE_90         944
CONTINUE_94         9A2
CS_FAILURE          F3E
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8A2
DOWNLOAD_DONE       D84
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_119            C26
EXIT_131            D2E
EXIT_142            DD4
EXIT_19             2D6
EXIT_21             2FE
EXIT_23             326
EXIT_5              140
G                   E2E
GET_INPUT           1AE
H                   2DA
HELP                E72
HEX2BIN             12B
HEX2BIN_LUT         F74
HEX_DIGIT           E36
HUH                 EDD
LOOP_119            C08
LOOP_131            D10
LOOP_133            D30
LOOP_139            D86
LOOP_142            DB6
LOOP_144            DD8
LOOP_19             2B8
LOOP_21             2E0
LOOP_23             308
LOOP_25             330
LOOP_5              122
MAIN_LOOP           186
OVERRUN             F8B
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   32A
READ                EF4
READ_CHAR           759
READ_DATA_TO_POKE   3D0
RRRR                0
S                   44E
START               8
UNIMP               EE4
UNREC               F18
V                   302
VERSION             E56
W                   388
WAIT_CHAR           5D1
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_100  9FC
WAIT_FOR_READY_101  A22
WAIT_FOR_READY_104  A6E
WAIT_FOR_READY_107  ABC
WAIT_FOR_READY_11   186
WAIT_FOR_READY_110  B08
WAIT_FOR_READY_113  B5A
WAIT_FOR_READY_116  BA6
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_120  C10
WAIT_FOR_READY_121  C26
WAIT_FOR_READY_123  C38
WAIT_FOR_READY_124  C4C
WAIT_FOR_READY_125  C6E
WAIT_FOR_READY_128  CBA
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_132  D18
WAIT_FOR_READY_135  D44
WAIT_FOR_READY_137  D5A
WAIT_FOR_READY_138  D6E
WAIT_FOR_READY_141  D9A
WAIT_FOR_READY_143  DBE
WAIT_FOR_READY_146  DEC
WAIT_FOR_READY_148  E02
WAIT_FOR_READY_149  E16
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_17   262
WAIT_FOR_READY_18   276
WAIT_FOR_READY_20   2C0
WAIT_FOR_READY_22   2E8
WAIT_FOR_READY_24   310
WAIT_FOR_READY_27   344
WAIT_FOR_READY_29   35A
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_30   36E
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_33   3A4
WAIT_FOR_READY_35   3D2
WAIT_FOR_READY_37   3EC
WAIT_FOR_READY_4    108
WAIT_FOR_READY_40   422
WAIT_FOR_READY_41   436
WAIT_FOR_READY_42   454
WAIT_FOR_READY_44   490
WAIT_FOR_READY_46   4C8
WAIT_FOR_READY_49   514
WAIT_FOR_READY_52   56A
WAIT_FOR_READY_55   5B6
WAIT_FOR_READY_58   604
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   650
WAIT_FOR_READY_64   6B0
WAIT_FOR_READY_67   6FC
WAIT_FOR_READY_70   748
WAIT_FOR_READY_72   75E
WAIT_FOR_READY_73   772
WAIT_FOR_READY_74   798
WAIT_FOR_READY_76   7CC
WAIT_FOR_READY_78   7F6
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   82A
WAIT_FOR_READY_82   856
WAIT_FOR_READY_84   88A
WAIT_FOR_READY_86   8B4
WAIT_FOR_READY_88   8E8
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   928
WAIT_FOR_READY_92   95C
WAIT_FOR_READY_94   986
WAIT_FOR_READY_96   9BA
WAIT_FOR_READY_99   9E8
WAIT_FOR_SRECORD    454
_00000000           78E
_00000001           C64
_00000002           A18
_00000003           C64
_00000004           C02
_00000005           C64
_00000006           D82
_10000000           6A2
_10000001           75E
_10000002           91A
_10000003           9E8
