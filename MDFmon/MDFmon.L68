00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 14:00:13

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; move to lower case commands
00000000                             9  ; Replace JMP -> BRA, THEN.L
00000000                            10  ; revisit register usage in S record download
00000000                            11  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            12  ; revisit use of bytes and longs
00000000                            13  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            14  ; Review for any other savings
00000000                            15  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            16  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            17  
00000000                            18  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            19  ; keep track of highest address hit during srec download
00000000                            20  ; fix the reset vector so that it jumps to the start
00000000                            21  ; implement backspace
00000000                            22  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            23  ; fix being able to enter random chars when W'ing
00000000                            24  ; ram check at startup?  Not sure if this is a good idea!
00000000                            25  ; byte W?
00000000                            26  
00000000                            27      ORG  $0
00000000                            28      ;ORG  $200000
00000000                            29  
00000000  =00000000                 30  DEBUG               EQU 0
00000000                            31  
00000000                            32  ; constants
00000000  =00000000                 33  ROM                 EQU $0
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35     
00000000  =00C00000                 36  DUART_BASE          EQU $C00000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  
00000000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           110          BTST #2,\2                              ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           113      ENDC
00000000                           114      
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll
00000000                           125  PRINT_CRLF MACRO
00000000                           126      PRINT_CHAR #13,\1                           ; CR
00000000                           127      PRINT_CHAR #10,\1                           ; LF
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #0,(\1)                               ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      BRA LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           143  PRINT_REG MACRO
00000000                           144      PRINT_CHAR #'0',\2                          ;0x header
00000000                           145      PRINT_CHAR #'x',\2
00000000                           146      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152    
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           158  
00000000                           159      IFEQ DEBUG
00000000                           160          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           161          BTST #0,\2                              ; check for character
00000000                           162          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           163      ENDC
00000000                           164      
00000000                           165      READ_CHAR \1
00000000                           166  
00000000                           167      IFEQ DEBUG
00000000                           168          PRINT_CHAR \1,\2                        ; echo it back
00000000                           169      ENDC
00000000                           170      ENDM
00000000                           171      
00000000                           172  ; read a char from the serial port - assumes that there is one!
00000000                           173  ; \ 1= data register for read char
00000000                           174  ; will stamp on D0 and D1 in debug mode
00000000                           175  READ_CHAR MACRO
00000000                           176      IFEQ DEBUG
00000000                           177          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           178      ENDC
00000000                           179      IFNE DEBUG
00000000                           180          MOVE.L #5,D0    
00000000                           181          TRAP #15                                ; read from keyboard in simulator
00000000                           182          MOVE.L D1,\1
00000000                           183      ENDC
00000000                           184       
00000000                           185      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           186      BEQ START
00000000                           187      ENDM
00000000                           188      
00000000                           189      
00000000                           190  ; read data from the download serial port
00000000                           191  ; \ 1= data register for read char
00000000                           192  DOWNLOAD MACRO
00000000                           193  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           194  
00000000                           195      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           196      BTST #0,\1                                  ; check for character
00000000                           197      BEQ CONTINUE\@                              ; nothing, continue
00000000                           198   
00000000                           199      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           200  CONTINUE\@
00000000                           201      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           202      BTST #0,\1                                  ; check for character
00000000                           203      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           204      
00000000                           205      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           206      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           207      
00000000                           208      ENDM
00000000                           209      
00000000                           210  ; read two hex digits from the download serial port and convert to a byte
00000000                           211  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           212  DOWNLOAD_BYTE MACRO
00000000                           213      MOVE.B #2,\4
00000000                           214      WHILE.B \4 <GT> 0 DO
00000000                           215          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           216          DOWNLOAD \1
00000000                           217          PRINT_CHAR \1,\3
00000000                           218          HEX2BIN \1,\1,\6
00000000                           219          OR.B \1,\2
00000000                           220          SUB.B #1,\4
00000000                           221      ENDW
00000000                           222      
00000000                           223      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00000000                           224      MOVE.B \2,\1
00000000                           225      ADD.L \2,\5
00000000                           226  
00000000                           227      ENDM
00000000                           228      
00000000                           229  
00000000                           230  ; register catalogue
00000000                           231  ; D0 - used for simulator I/O
00000000                           232  ; D1 - used for simulator I/O
00000000                           233  ; D2 - read character
00000000                           234  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           235  ; D4 - count of S records read
00000000                           236  ; D5 - data to write / data read / byte count for S record load
00000000                           237  ; D6 - working register used in R/W and download
00000000                           238  ; D7 - address accumulator / reset by download
00000000                           239  ; A0 - address of string to print 
00000000                           240  
00000000                           241  ; start vector
00000000= 00000000                 242  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 243  RESET    DC.L START                             ; RESET
00000008                           244      
00000008                           245  ; start of program  
00000008                           246  START
00000008  13FC 0000 00E00001       247      MOVE.B #0,DISPLAY
00000010                           248  
00000010                           249  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       250      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       251      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     252      NOP
00000022  13FC 0040 00C00005       253      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     254      NOP
0000002C  13FC 0030 00C00005       255      MOVE.B #$30,DUART_CRA
00000034  4E71                     256      NOP
00000036  13FC 0020 00C00005       257      MOVE.B #$20,DUART_CRA
0000003E  4E71                     258      NOP
00000040  13FC 0010 00C00005       259      MOVE.B #$10,DUART_CRA   
00000048                           260  
00000048  13FC 000A 00C00015       261      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       262      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     263      NOP
0000005A  13FC 0040 00C00015       264      MOVE.B #$40,DUART_CRB           
00000062  4E71                     265      NOP
00000064  13FC 0030 00C00015       266      MOVE.B #$30,DUART_CRB
0000006C  4E71                     267      NOP
0000006E  13FC 0020 00C00015       268      MOVE.B #$20,DUART_CRB
00000076  4E71                     269      NOP
00000078  13FC 0010 00C00015       270      MOVE.B #$10,DUART_CRB   
00000080                           271  
00000080                           272  ;initialise UART
00000080  13FC 0000 00C00009       273      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       274      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       275      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           276  
00000098                           277  ; channel A
00000098  13FC 0013 00C00001       278      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       279      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       280      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       281      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           282  
000000B8                           283  ; channel B
000000B8  13FC 0013 00C00011       284      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       285      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       286      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       287      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           288  
000000D8                           289m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           290m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      291m     IFEQ DEBUG
000000D8  1639 00C00003            292m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                293m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     294m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       295m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           296m     ENDC
000000EC                           297m     
000000EC                 FALSE     298m     IFNE DEBUG
000000EC                           299m     ENDC
000000EC                           300m 
000000EC                           301m     ENDM
000000EC                           302  
000000EC  13FC 0001 00E00001       303      MOVE.B #1,DISPLAY
000000F4                           304         
000000F4                           305m     PRINT_CRLF D3
000000F4                           306mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           307mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      308mm     IFEQ DEBUG
000000F4  1639 00C00003            309mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                310mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     311mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       312mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           313mm     ENDC
00000108                           314mm     
00000108                 FALSE     315mm     IFNE DEBUG
00000108                           316mm     ENDC
00000108                           317mm 
00000108                           318mm     ENDM
00000108                           319mm     PRINT_CHAR #10,D3                           ; LF
00000108                           320mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      321mm     IFEQ DEBUG
00000108  1639 00C00003            322mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                323mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     324mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       325mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           326mm     ENDC
0000011C                           327mm     
0000011C                 FALSE     328mm     IFNE DEBUG
0000011C                           329mm     ENDC
0000011C                           330mm 
0000011C                           331mm     ENDM
0000011C                           332m     ENDM
0000011C                           333  
0000011C  41F9 00000EB0            334      LEA VERSION,A0
00000122                           335m     PRINT_STR A0,D3
00000122                           336m LOOP_5
00000122  0C10 0000                337m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0016                338m     BEQ EXIT_5
0000012A                           339mm     PRINT_CHAR (A0)+,D3
0000012A                           340mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      341mm     IFEQ DEBUG
0000012A  1639 00C00003            342mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                343mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     344mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            345mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           346mm     ENDC
0000013C                           347mm     
0000013C                 FALSE     348mm     IFNE DEBUG
0000013C                           349mm     ENDC
0000013C                           350mm 
0000013C                           351mm     ENDM
0000013C  60E4                     352m     BRA LOOP_5
0000013E                           353m EXIT_5
0000013E                           354m     ENDM
0000013E                           355m     PRINT_CRLF D3
0000013E                           356mm     PRINT_CHAR #13,D3                           ; CR
0000013E                           357mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      358mm     IFEQ DEBUG
0000013E  1639 00C00003            359mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                360mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     361mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014A  13FC 000D 00C00007       362mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000152                           363mm     ENDC
00000152                           364mm     
00000152                 FALSE     365mm     IFNE DEBUG
00000152                           366mm     ENDC
00000152                           367mm 
00000152                           368mm     ENDM
00000152                           369mm     PRINT_CHAR #10,D3                           ; LF
00000152                           370mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      371mm     IFEQ DEBUG
00000152  1639 00C00003            372mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000158  0803 0002                373mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015C  67F4                     374mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0000015E  13FC 000A 00C00007       375mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000166                           376mm     ENDC
00000166                           377mm     
00000166                 FALSE     378mm     IFNE DEBUG
00000166                           379mm     ENDC
00000166                           380mm 
00000166                           381mm     ENDM
00000166                           382m     ENDM
00000166                           383m     PRINT_CHAR #7,D3
00000166                           384m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000166                 TRUE      385m     IFEQ DEBUG
00000166  1639 00C00003            386m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016C  0803 0002                387m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000170  67F4                     388m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000172  13FC 0007 00C00007       389m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017A                           390m     ENDC
0000017A                           391m     
0000017A                 FALSE     392m     IFNE DEBUG
0000017A                           393m     ENDC
0000017A                           394m 
0000017A                           395m     ENDM
0000017A                           396  
0000017A  7E00                     397      MOVE.L #0,D7                                ; address accumulator
0000017C                           398  
0000017C  13FC 0002 00E00001       399      MOVE.B #2,DISPLAY
00000184                           400  MAIN_LOOP
00000184                           401m     PRINT_CHAR #'>',D3                          ; prompt
00000184                           402m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000184                 TRUE      403m     IFEQ DEBUG
00000184  1639 00C00003            404m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018A  0803 0002                405m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000018E  67F4                     406m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000190  13FC 003E 00C00007       407m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000198                           408m     ENDC
00000198                           409m     
00000198                 FALSE     410m     IFNE DEBUG
00000198                           411m     ENDC
00000198                           412m 
00000198                           413m     ENDM
00000198                           414m     PRINT_CHAR #32,D3                           ; space
00000198                           415m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000198                 TRUE      416m     IFEQ DEBUG
00000198  1639 00C00003            417m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000019E  0803 0002                418m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A2  67F4                     419m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A4  13FC 0020 00C00007       420m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AC                           421m     ENDC
000001AC                           422m     
000001AC                 FALSE     423m     IFNE DEBUG
000001AC                           424m     ENDC
000001AC                           425m 
000001AC                           426m     ENDM
000001AC                           427      
000001AC                           428  GET_INPUT
000001AC                           429m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AC                           430m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AC                           431m 
000001AC                 TRUE      432m     IFEQ DEBUG
000001AC  1639 00C00003            433m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B2  0803 0000                434m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B6  67F4                     435m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001B8                           436m     ENDC
000001B8                           437m     
000001B8                           438mm     READ_CHAR D2
000001B8                 TRUE      439mm     IFEQ DEBUG
000001B8  1439 00C00007            440mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001BE                           441mm     ENDC
000001BE                 FALSE     442mm     IFNE DEBUG
000001BE                           443mm     ENDC
000001BE                           444mm      
000001BE  B43C 001B                445mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C2  6700 FE44                446mm     BEQ START
000001C6                           447mm     ENDM
000001C6                           448m 
000001C6                 TRUE      449m     IFEQ DEBUG
000001C6                           450mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C6                           451mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C6                 TRUE      452mm     IFEQ DEBUG
000001C6  1639 00C00003            453mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CC  0803 0002                454mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D0  67F4                     455mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D2  13C2 00C00007            456mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001D8                           457mm     ENDC
000001D8                           458mm     
000001D8                 FALSE     459mm     IFNE DEBUG
000001D8                           460mm     ENDC
000001D8                           461mm 
000001D8                           462mm     ENDM
000001D8                           463m     ENDC
000001D8                           464m     ENDM
000001D8                           465      
000001D8  B43C 0030                466      CMP.B #'0',D2
000001DC  6700 0CB2                467      BEQ HEX_DIGIT
000001E0  B43C 0031                468      CMP.B #'1',D2
000001E4  6700 0CAA                469      BEQ HEX_DIGIT
000001E8  B43C 0032                470      CMP.B #'2',D2
000001EC  6700 0CA2                471      BEQ HEX_DIGIT
000001F0  B43C 0033                472      CMP.B #'3',D2
000001F4  6700 0C9A                473      BEQ HEX_DIGIT
000001F8  B43C 0034                474      CMP.B #'4',D2
000001FC  6700 0C92                475      BEQ HEX_DIGIT
00000200  B43C 0035                476      CMP.B #'5',D2
00000204  6700 0C8A                477      BEQ HEX_DIGIT
00000208  B43C 0036                478      CMP.B #'6',D2
0000020C  6700 0C82                479      BEQ HEX_DIGIT
00000210  B43C 0037                480      CMP.B #'7',D2
00000214  6700 0C7A                481      BEQ HEX_DIGIT
00000218  B43C 0038                482      CMP.B #'8',D2
0000021C  6700 0C72                483      BEQ HEX_DIGIT
00000220  B43C 0039                484      CMP.B #'9',D2
00000224  6700 0C6A                485      BEQ HEX_DIGIT
00000228  B43C 0061                486      CMP.B #'a',D2
0000022C  6700 0C62                487      BEQ HEX_DIGIT
00000230  B43C 0062                488      CMP.B #'b',D2
00000234  6700 0C5A                489      BEQ HEX_DIGIT
00000238  B43C 0063                490      CMP.B #'c',D2
0000023C  6700 0C52                491      BEQ HEX_DIGIT
00000240  B43C 0064                492      CMP.B #'d',D2
00000244  6700 0C4A                493      BEQ HEX_DIGIT
00000248  B43C 0065                494      CMP.B #'e',D2
0000024C  6700 0C42                495      BEQ HEX_DIGIT
00000250  B43C 0066                496      CMP.B #'f',D2
00000254  6700 0C3A                497      BEQ HEX_DIGIT
00000258                           498      
00000258  B43C 0077                499      CMP.B #'w',D2
0000025C  6700 015A                500      BEQ W
00000260                           501      
00000260  B43C 006C                502      CMP.B #'l',D2
00000264  6700 0ABC                503      BEQ L 
00000268                           504  
00000268                           505m     PRINT_CRLF D3
00000268                           506mm     PRINT_CHAR #13,D3                           ; CR
00000268                           507mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000268                 TRUE      508mm     IFEQ DEBUG
00000268  1639 00C00003            509mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000026E  0803 0002                510mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000272  67F4                     511mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000274  13FC 000D 00C00007       512mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000027C                           513mm     ENDC
0000027C                           514mm     
0000027C                 FALSE     515mm     IFNE DEBUG
0000027C                           516mm     ENDC
0000027C                           517mm 
0000027C                           518mm     ENDM
0000027C                           519mm     PRINT_CHAR #10,D3                           ; LF
0000027C                           520mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      521mm     IFEQ DEBUG
0000027C  1639 00C00003            522mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000282  0803 0002                523mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000286  67F4                     524mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00000288  13FC 000A 00C00007       525mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000290                           526mm     ENDC
00000290                           527mm     
00000290                 FALSE     528mm     IFNE DEBUG
00000290                           529mm     ENDC
00000290                           530mm 
00000290                           531mm     ENDM
00000290                           532m     ENDM
00000290                           533   
00000290  B43C 003F                534      CMP.B #'?',D2
00000294  6700 0050                535      BEQ H
00000298                           536  
00000298  B43C 0076                537      CMP.B #'v',D2
0000029C  6700 006E                538      BEQ V
000002A0                           539      
000002A0  B43C 0072                540      CMP.B #'r',D2
000002A4  6700 008C                541      BEQ R
000002A8                           542  
000002A8  B43C 0073                543      CMP.B #'s',D2
000002AC  6700 01D0                544      BEQ S
000002B0                           545  
000002B0  B43C 0067                546      CMP.B #'g',D2
000002B4  6700 095E                547      BEQ G   
000002B8                           548  
000002B8  B43C 007A                549      CMP.B #'z',D2
000002BC  6700 095E                550      BEQ Z   
000002C0                           551  
000002C0  41F9 00000F72            552      LEA HUH,A0
000002C6                           553m     PRINT_STR A0,D3
000002C6                           554m LOOP_19
000002C6  0C10 0000                555m     CMP.B #0,(A0)                               ; 0 -> DONE
000002CA  6700 0016                556m     BEQ EXIT_19
000002CE                           557mm     PRINT_CHAR (A0)+,D3
000002CE                           558mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002CE                 TRUE      559mm     IFEQ DEBUG
000002CE  1639 00C00003            560mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D4  0803 0002                561mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D8  67F4                     562mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
000002DA  13D8 00C00007            563mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E0                           564mm     ENDC
000002E0                           565mm     
000002E0                 FALSE     566mm     IFNE DEBUG
000002E0                           567mm     ENDC
000002E0                           568mm 
000002E0                           569mm     ENDM
000002E0  60E4                     570m     BRA LOOP_19
000002E2                           571m EXIT_19
000002E2                           572m     ENDM
000002E2                           573                         
000002E2  4EF8 0184                574      JMP MAIN_LOOP
000002E6                           575      
000002E6                           576  ; commands
000002E6                           577  H   
000002E6  41F9 00000ECD            578      LEA HELP,A0
000002EC                           579m     PRINT_STR A0,D3
000002EC                           580m LOOP_21
000002EC  0C10 0000                581m     CMP.B #0,(A0)                               ; 0 -> DONE
000002F0  6700 0016                582m     BEQ EXIT_21
000002F4                           583mm     PRINT_CHAR (A0)+,D3
000002F4                           584mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F4                 TRUE      585mm     IFEQ DEBUG
000002F4  1639 00C00003            586mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FA  0803 0002                587mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002FE  67F4                     588mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000300  13D8 00C00007            589mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000306                           590mm     ENDC
00000306                           591mm     
00000306                 FALSE     592mm     IFNE DEBUG
00000306                           593mm     ENDC
00000306                           594mm 
00000306                           595mm     ENDM
00000306  60E4                     596m     BRA LOOP_21
00000308                           597m EXIT_21
00000308                           598m     ENDM
00000308  4EF8 0184                599      JMP MAIN_LOOP
0000030C                           600  
0000030C                           601  V   
0000030C  41F9 00000EB0            602      LEA VERSION,A0
00000312                           603m     PRINT_STR A0,D3       
00000312                           604m LOOP_23
00000312  0C10 0000                605m     CMP.B #0,(A0)                               ; 0 -> DONE
00000316  6700 0016                606m     BEQ EXIT_23
0000031A                           607mm     PRINT_CHAR (A0)+,D3
0000031A                           608mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031A                 TRUE      609mm     IFEQ DEBUG
0000031A  1639 00C00003            610mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000320  0803 0002                611mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000324  67F4                     612mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000326  13D8 00C00007            613mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000032C                           614mm     ENDC
0000032C                           615mm     
0000032C                 FALSE     616mm     IFNE DEBUG
0000032C                           617mm     ENDC
0000032C                           618mm 
0000032C                           619mm     ENDM
0000032C  60E4                     620m     BRA LOOP_23
0000032E                           621m EXIT_23
0000032E                           622m     ENDM
0000032E  4EF8 0184                623      JMP MAIN_LOOP
00000332                           624      
00000332                           625  R   
00000332  2047                     626      MOVE.L D7,A0                                ; address accumulator -> address register
00000334  2A10                     627      MOVE.L (A0),D5                              ; read the memory and print it
00000336                           628m     PRINT_REG D5,D3,D7,D6,A0
00000336                           629mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000336                           630mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000336                 TRUE      631mm     IFEQ DEBUG
00000336  1639 00C00003            632mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000033C  0803 0002                633mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000340  67F4                     634mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00000342  13FC 0030 00C00007       635mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000034A                           636mm     ENDC
0000034A                           637mm     
0000034A                 FALSE     638mm     IFNE DEBUG
0000034A                           639mm     ENDC
0000034A                           640mm 
0000034A                           641mm     ENDM
0000034A                           642mm     PRINT_CHAR #'x',D3
0000034A                           643mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000034A                 TRUE      644mm     IFEQ DEBUG
0000034A  1639 00C00003            645mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000350  0803 0002                646mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000354  67F4                     647mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
00000356  13FC 0078 00C00007       648mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000035E                           649mm     ENDC
0000035E                           650mm     
0000035E                 FALSE     651mm     IFNE DEBUG
0000035E                           652mm     ENDC
0000035E                           653mm 
0000035E                           654mm     ENDM
0000035E  7C07                     655m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000360                           656m LOOP_25
00000360                           657mm     BIN2HEX D5,D7,A0
00000360  41F9 00000FD6            658mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000366  E99D                     659mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000368  1E05                     660mm     MOVE.B D5,D7
0000036A  0287 0000000F            661mm     ANDI.L #$F,D7
00000370  1E30 7000                662mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000374                           663mm     ENDM
00000374                           664mm     PRINT_CHAR D7,D3
00000374                           665mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000374                 TRUE      666mm     IFEQ DEBUG
00000374  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000037A  0803 0002                668mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000037E  67F4                     669mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000380  13C7 00C00007            670mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000386                           671mm     ENDC
00000386                           672mm     
00000386                 FALSE     673mm     IFNE DEBUG
00000386                           674mm     ENDC
00000386                           675mm 
00000386                           676mm     ENDM
00000386  57CE FFD8                677m     DBEQ D6,LOOP_25
0000038A                           678m     ENDM
0000038A                           679m     PRINT_CRLF D3
0000038A                           680mm     PRINT_CHAR #13,D3                           ; CR
0000038A                           681mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                 TRUE      682mm     IFEQ DEBUG
0000038A  1639 00C00003            683mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000390  0803 0002                684mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000394  67F4                     685mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
00000396  13FC 000D 00C00007       686mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000039E                           687mm     ENDC
0000039E                           688mm     
0000039E                 FALSE     689mm     IFNE DEBUG
0000039E                           690mm     ENDC
0000039E                           691mm 
0000039E                           692mm     ENDM
0000039E                           693mm     PRINT_CHAR #10,D3                           ; LF
0000039E                           694mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                 TRUE      695mm     IFEQ DEBUG
0000039E  1639 00C00003            696mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003A4  0803 0002                697mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003A8  67F4                     698mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000003AA  13FC 000A 00C00007       699mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003B2                           700mm     ENDC
000003B2                           701mm     
000003B2                 FALSE     702mm     IFNE DEBUG
000003B2                           703mm     ENDC
000003B2                           704mm 
000003B2                           705mm     ENDM
000003B2                           706m     ENDM
000003B2  7E00                     707      MOVE.L #0,D7                                ; clear the now used address accumulator
000003B4  4EF8 0184                708      JMP MAIN_LOOP
000003B8                           709  
000003B8                           710  W
000003B8  7A00                     711      MOVE.L #0,D5                                ; D5 will be the value to write            
000003BA                           712  
000003BA                           713m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000003BA                           714m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BA                           715m 
000003BA                 TRUE      716m     IFEQ DEBUG
000003BA  1639 00C00003            717m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003C0  0803 0000                718m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003C4  67F4                     719m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
000003C6                           720m     ENDC
000003C6                           721m     
000003C6                           722mm     READ_CHAR D2
000003C6                 TRUE      723mm     IFEQ DEBUG
000003C6  1439 00C00007            724mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003CC                           725mm     ENDC
000003CC                 FALSE     726mm     IFNE DEBUG
000003CC                           727mm     ENDC
000003CC                           728mm      
000003CC  B43C 001B                729mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003D0  6700 FC36                730mm     BEQ START
000003D4                           731mm     ENDM
000003D4                           732m 
000003D4                 TRUE      733m     IFEQ DEBUG
000003D4                           734mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003D4                           735mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D4                 TRUE      736mm     IFEQ DEBUG
000003D4  1639 00C00003            737mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003DA  0803 0002                738mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003DE  67F4                     739mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
000003E0  13C2 00C00007            740mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003E6                           741mm     ENDC
000003E6                           742mm     
000003E6                 FALSE     743mm     IFNE DEBUG
000003E6                           744mm     ENDC
000003E6                           745mm 
000003E6                           746mm     ENDM
000003E6                           747m     ENDC
000003E6                           748m     ENDM
000003E6                           749m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003E6  41F9 00000FE6            750m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003EC  0402 0030                751m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F0  C4BC 000000FF            752m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003F6  1430 2000                753m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003FA                           754m     ENDM
000003FA  1A02                     755      MOVE.B D2,D5                                ; put at bottom of D5
000003FC                           756  
000003FC  3C3C 0006                757      MOVE #6,D6                                  ; 7 bytes left to read
00000400                           758      
00000400                           759  READ_DATA_TO_POKE
00000400  E98D                     760      LSL.L #4,D5                                 ; make what we have so far more significant
00000402                           761m     WAIT_CHAR D2,D3                             ; next character -> D2
00000402                           762m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           763m 
00000402                 TRUE      764m     IFEQ DEBUG
00000402  1639 00C00003            765m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000408  0803 0000                766m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000040C  67F4                     767m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
0000040E                           768m     ENDC
0000040E                           769m     
0000040E                           770mm     READ_CHAR D2
0000040E                 TRUE      771mm     IFEQ DEBUG
0000040E  1439 00C00007            772mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000414                           773mm     ENDC
00000414                 FALSE     774mm     IFNE DEBUG
00000414                           775mm     ENDC
00000414                           776mm      
00000414  B43C 001B                777mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                778mm     BEQ START
0000041C                           779mm     ENDM
0000041C                           780m 
0000041C                 TRUE      781m     IFEQ DEBUG
0000041C                           782mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000041C                           783mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      784mm     IFEQ DEBUG
0000041C  1639 00C00003            785mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000422  0803 0002                786mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000426  67F4                     787mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00000428  13C2 00C00007            788mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000042E                           789mm     ENDC
0000042E                           790mm     
0000042E                 FALSE     791mm     IFNE DEBUG
0000042E                           792mm     ENDC
0000042E                           793mm 
0000042E                           794mm     ENDM
0000042E                           795m     ENDC
0000042E                           796m     ENDM
0000042E                           797m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0000042E  41F9 00000FE6            798m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000434  0402 0030                799m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000438  C4BC 000000FF            800m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000043E  1430 2000                801m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000442                           802m     ENDM
00000442  8A02                     803      OR.B D2,D5
00000444  023C 00FB                804      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000448  57CE FFB6                805      DBEQ D6,READ_DATA_TO_POKE
0000044C                           806      
0000044C  2047                     807      MOVE.L D7,A0                                ; address accumulator -> address register
0000044E  7E00                     808      MOVE.L #0,D7                                ; clear the now used address accumulator
00000450                           809      
00000450  2085                     810      MOVE.L D5,(A0)                              ; write the data
00000452                           811  
00000452                           812m     PRINT_CRLF D3
00000452                           813mm     PRINT_CHAR #13,D3                           ; CR
00000452                           814mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                 TRUE      815mm     IFEQ DEBUG
00000452  1639 00C00003            816mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000458  0803 0002                817mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000045C  67F4                     818mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0000045E  13FC 000D 00C00007       819mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000466                           820mm     ENDC
00000466                           821mm     
00000466                 FALSE     822mm     IFNE DEBUG
00000466                           823mm     ENDC
00000466                           824mm 
00000466                           825mm     ENDM
00000466                           826mm     PRINT_CHAR #10,D3                           ; LF
00000466                           827mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000466                 TRUE      828mm     IFEQ DEBUG
00000466  1639 00C00003            829mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000046C  0803 0002                830mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000470  67F4                     831mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00000472  13FC 000A 00C00007       832mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000047A                           833mm     ENDC
0000047A                           834mm     
0000047A                 FALSE     835mm     IFNE DEBUG
0000047A                           836mm     ENDC
0000047A                           837mm 
0000047A                           838mm     ENDM
0000047A                           839m     ENDM
0000047A  4EF8 0184                840      JMP MAIN_LOOP
0000047E                           841  
0000047E                           842          
0000047E                           843  S
0000047E  2647                     844      MOVE.L D7,A3                                ; grab the address accumulator
00000480  7800                     845      MOVE.L #0,D4                                ; count of records read -> D4
00000482  2478 0000                846      MOVE.L 0,A2                                 ; start address -> A2
00000486                           847      
00000486                           848  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
00000486                           849m     DOWNLOAD D2                 
00000486                           850m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                           851m 
00000486  1439 00C00003            852m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000048C  0802 0000                853m     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000490  6700 0010                854m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000494                           855m  
00000494                           856mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000494                 TRUE      857mm     IFEQ DEBUG
00000494  1439 00C00007            858mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000049A                           859mm     ENDC
0000049A                 FALSE     860mm     IFNE DEBUG
0000049A                           861mm     ENDC
0000049A                           862mm      
0000049A  B43C 001B                863mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000049E  6700 FB68                864mm     BEQ START
000004A2                           865mm     ENDM
000004A2                           866m CONTINUE_44
000004A2  1439 00C00013            867m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
000004A8  0802 0000                868m     BTST #0,D2                                  ; CHECK FOR CHARACTER
000004AC  67D8                     869m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
000004AE                           870m     
000004AE  1439 00C00017            871m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000004B4  13C2 00E00001            872m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000004BA                           873m     
000004BA                           874m     ENDM
000004BA  B43C 0053                875      CMP.B #'S',D2                               ; found S?    
000004BE  66C6                     876      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
000004C0                           877      
000004C0                           878m     PRINT_CHAR #'S',D3                          ; print it
000004C0                           879m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                 TRUE      880m     IFEQ DEBUG
000004C0  1639 00C00003            881m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000004C6  0803 0002                882m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000004CA  67F4                     883m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
000004CC  13FC 0053 00C00007       884m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000004D4                           885m     ENDC
000004D4                           886m     
000004D4                 FALSE     887m     IFNE DEBUG
000004D4                           888m     ENDC
000004D4                           889m 
000004D4                           890m     ENDM
000004D4  5284                     891      ADD.L #1,D4                                 ; read another S record, increment count
000004D6                           892      
000004D6                           893m     DOWNLOAD D0                                 ; read the record identifier
000004D6                           894m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                           895m 
000004D6  1039 00C00003            896m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
000004DC  0800 0000                897m     BTST #0,D0                                  ; CHECK FOR CHARACTER
000004E0  6700 0010                898m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
000004E4                           899m  
000004E4                           900mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
000004E4                 TRUE      901mm     IFEQ DEBUG
000004E4  1039 00C00007            902mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
000004EA                           903mm     ENDC
000004EA                 FALSE     904mm     IFNE DEBUG
000004EA                           905mm     ENDC
000004EA                           906mm      
000004EA  B03C 001B                907mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
000004EE  6700 FB18                908mm     BEQ START
000004F2                           909mm     ENDM
000004F2                           910m CONTINUE_47
000004F2  1039 00C00013            911m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
000004F8  0800 0000                912m     BTST #0,D0                                  ; CHECK FOR CHARACTER
000004FC  67D8                     913m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
000004FE                           914m     
000004FE  1039 00C00017            915m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
00000504  13C0 00E00001            916m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
0000050A                           917m     
0000050A                           918m     ENDM
0000050A                           919m     PRINT_CHAR D0,D3                            ; print it
0000050A                           920m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      921m     IFEQ DEBUG
0000050A  1639 00C00003            922m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000510  0803 0002                923m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000514  67F4                     924m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00000516  13C0 00C00007            925m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000051C                           926m     ENDC
0000051C                           927m     
0000051C                 FALSE     928m     IFNE DEBUG
0000051C                           929m     ENDC
0000051C                           930m 
0000051C                           931m     ENDM
0000051C                           932  
0000051C  7C00                     933      MOVE.L #0,D6                                ; clear the checksum
0000051E                           934  
0000051E  7A00                     935      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00000520                           936m     DOWNLOAD_BYTE D2,D5,D3,D1,D6,A0                                        
00000520  123C 0002                937m     MOVE.B #2,D1
00000524                           938m     WHILE.B D1 <GT> 0 DO
00000524                           939ms _10000000
00000524  B238 0000                940ms     CMP.B   0,D1
00000528  6F00 0064                941ms     BLE _10000001
0000052C  E98D                     942m         LSL.L #4,D5                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000052E                           943mm         DOWNLOAD D2
0000052E                           944mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052E                           945mm 
0000052E  1439 00C00003            946mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000534  0802 0000                947mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000538  6700 0010                948mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0000053C                           949mm  
0000053C                           950mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000053C                 TRUE      951mmm     IFEQ DEBUG
0000053C  1439 00C00007            952mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000542                           953mmm     ENDC
00000542                 FALSE     954mmm     IFNE DEBUG
00000542                           955mmm     ENDC
00000542                           956mmm      
00000542  B43C 001B                957mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000546  6700 FAC0                958mmm     BEQ START
0000054A                           959mmm     ENDM
0000054A                           960mm CONTINUE_51
0000054A  1439 00C00013            961mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000550  0802 0000                962mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000554  67D8                     963mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00000556                           964mm     
00000556  1439 00C00017            965mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000055C  13C2 00E00001            966mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000562                           967mm     
00000562                           968mm     ENDM
00000562                           969mm         PRINT_CHAR D2,D3
00000562                           970mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000562                 TRUE      971mm     IFEQ DEBUG
00000562  1639 00C00003            972mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000568  0803 0002                973mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000056C  67F4                     974mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0000056E  13C2 00C00007            975mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000574                           976mm     ENDC
00000574                           977mm     
00000574                 FALSE     978mm     IFNE DEBUG
00000574                           979mm     ENDC
00000574                           980mm 
00000574                           981mm     ENDM
00000574                           982mm         HEX2BIN D2,D2,A0
00000574  41F9 00000FE6            983mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000057A  0402 0030                984mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  C4BC 000000FF            985mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000584  1430 2000                986mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000588                           987mm     ENDM
00000588  8A02                     988m         OR.B D2,D5
0000058A  5301                     989m         SUB.B #1,D1
0000058C                           990m     ENDW
0000058C  6096                     991ms     BRA _10000000
0000058E                           992ms _10000001
0000058E                           993m     
0000058E  7400                     994m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000590  1405                     995m     MOVE.B D5,D2
00000592  DC85                     996m     ADD.L D5,D6
00000594                           997m 
00000594                           998m     ENDM
00000594                           999  
00000594                          1000      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
00000594  B03C 0030               1001s     CMP.B   #'0',D0
00000598  6600 0032               1002s     BNE.L   _00000000
0000059C                          1003m         PRINT_CRLF D3
0000059C                          1004mm     PRINT_CHAR #13,D3                           ; CR
0000059C                          1005mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059C                 TRUE     1006mm     IFEQ DEBUG
0000059C  1639 00C00003           1007mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005A2  0803 0002               1008mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005A6  67F4                    1009mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
000005A8  13FC 000D 00C00007      1010mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005B0                          1011mm     ENDC
000005B0                          1012mm     
000005B0                 FALSE    1013mm     IFNE DEBUG
000005B0                          1014mm     ENDC
000005B0                          1015mm 
000005B0                          1016mm     ENDM
000005B0                          1017mm     PRINT_CHAR #10,D3                           ; LF
000005B0                          1018mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                 TRUE     1019mm     IFEQ DEBUG
000005B0  1639 00C00003           1020mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005B6  0803 0002               1021mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005BA  67F4                    1022mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
000005BC  13FC 000A 00C00007      1023mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005C4                          1024mm     ENDC
000005C4                          1025mm     
000005C4                 FALSE    1026mm     IFNE DEBUG
000005C4                          1027mm     ENDC
000005C4                          1028mm 
000005C4                          1029mm     ENDM
000005C4                          1030m     ENDM
000005C4  6000 FEC0               1031          BRA WAIT_FOR_SRECORD
000005C8                          1032      ELSE
000005C8  6000 0408               1033s     BRA _00000001
000005CC                          1034s _00000000
000005CC                          1035          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000005CC  B03C 0031               1036s     CMP.B   #'1',D0
000005D0  6708                    1037s     BEQ.S   _00000002
000005D2  B03C 0032               1038s     CMP.B   #'2',D0
000005D6  6600 0200               1039s     BNE.L   _00000003
000005DA                          1040s _00000002
000005DA  5785                    1041              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
000005DC                          1042      
000005DC  7E00                    1043              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
000005DE                          1044m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; first byte                           
000005DE  123C 0002               1045m     MOVE.B #2,D1
000005E2                          1046m     WHILE.B D1 <GT> 0 DO
000005E2                          1047ms _10000002
000005E2  B238 0000               1048ms     CMP.B   0,D1
000005E6  6F00 0064               1049ms     BLE _10000003
000005EA  E98F                    1050m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000005EC                          1051mm         DOWNLOAD D2
000005EC                          1052mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005EC                          1053mm 
000005EC  1439 00C00003           1054mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000005F2  0802 0000               1055mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000005F6  6700 0010               1056mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
000005FA                          1057mm  
000005FA                          1058mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000005FA                 TRUE     1059mmm     IFEQ DEBUG
000005FA  1439 00C00007           1060mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000600                          1061mmm     ENDC
00000600                 FALSE    1062mmm     IFNE DEBUG
00000600                          1063mmm     ENDC
00000600                          1064mmm      
00000600  B43C 001B               1065mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000604  6700 FA02               1066mmm     BEQ START
00000608                          1067mmm     ENDM
00000608                          1068mm CONTINUE_59
00000608  1439 00C00013           1069mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000060E  0802 0000               1070mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000612  67D8                    1071mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00000614                          1072mm     
00000614  1439 00C00017           1073mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000061A  13C2 00E00001           1074mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000620                          1075mm     
00000620                          1076mm     ENDM
00000620                          1077mm         PRINT_CHAR D2,D3
00000620                          1078mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                 TRUE     1079mm     IFEQ DEBUG
00000620  1639 00C00003           1080mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000626  0803 0002               1081mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000062A  67F4                    1082mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
0000062C  13C2 00C00007           1083mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000632                          1084mm     ENDC
00000632                          1085mm     
00000632                 FALSE    1086mm     IFNE DEBUG
00000632                          1087mm     ENDC
00000632                          1088mm 
00000632                          1089mm     ENDM
00000632                          1090mm         HEX2BIN D2,D2,A0
00000632  41F9 00000FE6           1091mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000638  0402 0030               1092mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000063C  C4BC 000000FF           1093mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000642  1430 2000               1094mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000646                          1095mm     ENDM
00000646  8E02                    1096m         OR.B D2,D7
00000648  5301                    1097m         SUB.B #1,D1
0000064A                          1098m     ENDW
0000064A  6096                    1099ms     BRA _10000002
0000064C                          1100ms _10000003
0000064C                          1101m     
0000064C  7400                    1102m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000064E  1407                    1103m     MOVE.B D7,D2
00000650  DC87                    1104m     ADD.L D7,D6
00000652                          1105m 
00000652                          1106m     ENDM
00000652                          1107m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; second one
00000652  123C 0002               1108m     MOVE.B #2,D1
00000656                          1109m     WHILE.B D1 <GT> 0 DO
00000656                          1110ms _10000004
00000656  B238 0000               1111ms     CMP.B   0,D1
0000065A  6F00 0064               1112ms     BLE _10000005
0000065E  E98F                    1113m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000660                          1114mm         DOWNLOAD D2
00000660                          1115mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000660                          1116mm 
00000660  1439 00C00003           1117mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000666  0802 0000               1118mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000066A  6700 0010               1119mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0000066E                          1120mm  
0000066E                          1121mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000066E                 TRUE     1122mmm     IFEQ DEBUG
0000066E  1439 00C00007           1123mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000674                          1124mmm     ENDC
00000674                 FALSE    1125mmm     IFNE DEBUG
00000674                          1126mmm     ENDC
00000674                          1127mmm      
00000674  B43C 001B               1128mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000678  6700 F98E               1129mmm     BEQ START
0000067C                          1130mmm     ENDM
0000067C                          1131mm CONTINUE_64
0000067C  1439 00C00013           1132mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000682  0802 0000               1133mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000686  67D8                    1134mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000688                          1135mm     
00000688  1439 00C00017           1136mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000068E  13C2 00E00001           1137mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000694                          1138mm     
00000694                          1139mm     ENDM
00000694                          1140mm         PRINT_CHAR D2,D3
00000694                          1141mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000694                 TRUE     1142mm     IFEQ DEBUG
00000694  1639 00C00003           1143mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000069A  0803 0002               1144mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000069E  67F4                    1145mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
000006A0  13C2 00C00007           1146mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006A6                          1147mm     ENDC
000006A6                          1148mm     
000006A6                 FALSE    1149mm     IFNE DEBUG
000006A6                          1150mm     ENDC
000006A6                          1151mm 
000006A6                          1152mm     ENDM
000006A6                          1153mm         HEX2BIN D2,D2,A0
000006A6  41F9 00000FE6           1154mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000006AC  0402 0030               1155mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B0  C4BC 000000FF           1156mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000006B6  1430 2000               1157mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000006BA                          1158mm     ENDM
000006BA  8E02                    1159m         OR.B D2,D7
000006BC  5301                    1160m         SUB.B #1,D1
000006BE                          1161m     ENDW
000006BE  6096                    1162ms     BRA _10000004
000006C0                          1163ms _10000005
000006C0                          1164m     
000006C0  7400                    1165m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006C2  1407                    1166m     MOVE.B D7,D2
000006C4  DC87                    1167m     ADD.L D7,D6
000006C6                          1168m 
000006C6                          1169m     ENDM
000006C6                          1170              
000006C6                          1171              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
000006C6  B03C 0032               1172s     CMP.B   #'2',D0
000006CA  6600 0078               1173s     BNE.L   _00000004
000006CE  5385                    1174                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address    
000006D0                          1175m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; 3rd byte       
000006D0  123C 0002               1176m     MOVE.B #2,D1
000006D4                          1177m     WHILE.B D1 <GT> 0 DO
000006D4                          1178ms _10000006
000006D4  B238 0000               1179ms     CMP.B   0,D1
000006D8  6F00 0064               1180ms     BLE _10000007
000006DC  E98F                    1181m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000006DE                          1182mm         DOWNLOAD D2
000006DE                          1183mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DE                          1184mm 
000006DE  1439 00C00003           1185mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000006E4  0802 0000               1186mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000006E8  6700 0010               1187mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
000006EC                          1188mm  
000006EC                          1189mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000006EC                 TRUE     1190mmm     IFEQ DEBUG
000006EC  1439 00C00007           1191mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000006F2                          1192mmm     ENDC
000006F2                 FALSE    1193mmm     IFNE DEBUG
000006F2                          1194mmm     ENDC
000006F2                          1195mmm      
000006F2  B43C 001B               1196mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000006F6  6700 F910               1197mmm     BEQ START
000006FA                          1198mmm     ENDM
000006FA                          1199mm CONTINUE_69
000006FA  1439 00C00013           1200mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000700  0802 0000               1201mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000704  67D8                    1202mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00000706                          1203mm     
00000706  1439 00C00017           1204mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000070C  13C2 00E00001           1205mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000712                          1206mm     
00000712                          1207mm     ENDM
00000712                          1208mm         PRINT_CHAR D2,D3
00000712                          1209mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1210mm     IFEQ DEBUG
00000712  1639 00C00003           1211mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000718  0803 0002               1212mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1213mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0000071E  13C2 00C00007           1214mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000724                          1215mm     ENDC
00000724                          1216mm     
00000724                 FALSE    1217mm     IFNE DEBUG
00000724                          1218mm     ENDC
00000724                          1219mm 
00000724                          1220mm     ENDM
00000724                          1221mm         HEX2BIN D2,D2,A0
00000724  41F9 00000FE6           1222mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000072A  0402 0030               1223mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000072E  C4BC 000000FF           1224mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000734  1430 2000               1225mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000738                          1226mm     ENDM
00000738  8E02                    1227m         OR.B D2,D7
0000073A  5301                    1228m         SUB.B #1,D1
0000073C                          1229m     ENDW
0000073C  6096                    1230ms     BRA _10000006
0000073E                          1231ms _10000007
0000073E                          1232m     
0000073E  7400                    1233m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000740  1407                    1234m     MOVE.B D7,D2
00000742  DC87                    1235m     ADD.L D7,D6
00000744                          1236m 
00000744                          1237m     ENDM
00000744                          1238              ENDI
00000744                          1239s _00000004
00000744                          1240              
00000744  2247                    1241              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00000746  D3CB                    1242              ADD.L A3,A1                         ; add in the offset
00000748                          1243  
00000748                          1244              WHILE.L D5 <GT> #0 DO               ; read the data bytes                
00000748                          1245s _10000008
00000748  BABC 00000000           1246s     CMP.L   #0,D5
0000074E  6F00 0080               1247s     BLE _10000009
00000752  7E00                    1248                  MOVE.L #0,D7                    ; D7 holds the byte
00000754                          1249m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; read it                               
00000754  123C 0002               1250m     MOVE.B #2,D1
00000758                          1251m     WHILE.B D1 <GT> 0 DO
00000758                          1252ms _1000000A
00000758  B238 0000               1253ms     CMP.B   0,D1
0000075C  6F00 0064               1254ms     BLE _1000000B
00000760  E98F                    1255m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000762                          1256mm         DOWNLOAD D2
00000762                          1257mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000762                          1258mm 
00000762  1439 00C00003           1259mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000768  0802 0000               1260mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000076C  6700 0010               1261mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000770                          1262mm  
00000770                          1263mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000770                 TRUE     1264mmm     IFEQ DEBUG
00000770  1439 00C00007           1265mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000776                          1266mmm     ENDC
00000776                 FALSE    1267mmm     IFNE DEBUG
00000776                          1268mmm     ENDC
00000776                          1269mmm      
00000776  B43C 001B               1270mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000077A  6700 F88C               1271mmm     BEQ START
0000077E                          1272mmm     ENDM
0000077E                          1273mm CONTINUE_74
0000077E  1439 00C00013           1274mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000784  0802 0000               1275mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000788  67D8                    1276mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0000078A                          1277mm     
0000078A  1439 00C00017           1278mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000790  13C2 00E00001           1279mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000796                          1280mm     
00000796                          1281mm     ENDM
00000796                          1282mm         PRINT_CHAR D2,D3
00000796                          1283mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000796                 TRUE     1284mm     IFEQ DEBUG
00000796  1639 00C00003           1285mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000079C  0803 0002               1286mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000007A0  67F4                    1287mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
000007A2  13C2 00C00007           1288mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007A8                          1289mm     ENDC
000007A8                          1290mm     
000007A8                 FALSE    1291mm     IFNE DEBUG
000007A8                          1292mm     ENDC
000007A8                          1293mm 
000007A8                          1294mm     ENDM
000007A8                          1295mm         HEX2BIN D2,D2,A0
000007A8  41F9 00000FE6           1296mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000007AE  0402 0030               1297mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B2  C4BC 000000FF           1298mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000007B8  1430 2000               1299mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000007BC                          1300mm     ENDM
000007BC  8E02                    1301m         OR.B D2,D7
000007BE  5301                    1302m         SUB.B #1,D1
000007C0                          1303m     ENDW
000007C0  6096                    1304ms     BRA _1000000A
000007C2                          1305ms _1000000B
000007C2                          1306m     
000007C2  7400                    1307m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C4  1407                    1308m     MOVE.B D7,D2
000007C6  DC87                    1309m     ADD.L D7,D6
000007C8                          1310m 
000007C8                          1311m     ENDM
000007C8                          1312                          
000007C8  12C7                    1313                  MOVE.B D7,(A1)+                 ; store it!
000007CA                          1314  
000007CA  5385                    1315                  SUB.L #1,D5                     ; 1 less byte to go
000007CC                          1316              ENDW
000007CC  6000 FF7A               1317s     BRA _10000008
000007D0                          1318s _10000009
000007D0                          1319          
000007D0  43F8 0486               1320              LEA WAIT_FOR_SRECORD,A1             ; next place to go
000007D4                          1321          ELSE
000007D4  6000 01FC               1322s     BRA _00000005
000007D8                          1323s _00000003
000007D8                          1324              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
000007D8  B03C 0038               1325s     CMP.B   #'8',D0
000007DC  6600 016C               1326s     BNE.L   _00000006
000007E0  7E00                    1327                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007E2                          1328m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; top byte  
000007E2  123C 0002               1329m     MOVE.B #2,D1
000007E6                          1330m     WHILE.B D1 <GT> 0 DO
000007E6                          1331ms _1000000C
000007E6  B238 0000               1332ms     CMP.B   0,D1
000007EA  6F00 0064               1333ms     BLE _1000000D
000007EE  E98F                    1334m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000007F0                          1335mm         DOWNLOAD D2
000007F0                          1336mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F0                          1337mm 
000007F0  1439 00C00003           1338mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000007F6  0802 0000               1339mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000007FA  6700 0010               1340mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
000007FE                          1341mm  
000007FE                          1342mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000007FE                 TRUE     1343mmm     IFEQ DEBUG
000007FE  1439 00C00007           1344mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000804                          1345mmm     ENDC
00000804                 FALSE    1346mmm     IFNE DEBUG
00000804                          1347mmm     ENDC
00000804                          1348mmm      
00000804  B43C 001B               1349mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000808  6700 F7FE               1350mmm     BEQ START
0000080C                          1351mmm     ENDM
0000080C                          1352mm CONTINUE_79
0000080C  1439 00C00013           1353mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000812  0802 0000               1354mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000816  67D8                    1355mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
00000818                          1356mm     
00000818  1439 00C00017           1357mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000081E  13C2 00E00001           1358mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000824                          1359mm     
00000824                          1360mm     ENDM
00000824                          1361mm         PRINT_CHAR D2,D3
00000824                          1362mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000824                 TRUE     1363mm     IFEQ DEBUG
00000824  1639 00C00003           1364mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000082A  0803 0002               1365mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000082E  67F4                    1366mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00000830  13C2 00C00007           1367mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000836                          1368mm     ENDC
00000836                          1369mm     
00000836                 FALSE    1370mm     IFNE DEBUG
00000836                          1371mm     ENDC
00000836                          1372mm 
00000836                          1373mm     ENDM
00000836                          1374mm         HEX2BIN D2,D2,A0
00000836  41F9 00000FE6           1375mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000083C  0402 0030               1376mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000840  C4BC 000000FF           1377mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000846  1430 2000               1378mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000084A                          1379mm     ENDM
0000084A  8E02                    1380m         OR.B D2,D7
0000084C  5301                    1381m         SUB.B #1,D1
0000084E                          1382m     ENDW
0000084E  6096                    1383ms     BRA _1000000C
00000850                          1384ms _1000000D
00000850                          1385m     
00000850  7400                    1386m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000852  1407                    1387m     MOVE.B D7,D2
00000854  DC87                    1388m     ADD.L D7,D6
00000856                          1389m 
00000856                          1390m     ENDM
00000856                          1391m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; middle byte     
00000856  123C 0002               1392m     MOVE.B #2,D1
0000085A                          1393m     WHILE.B D1 <GT> 0 DO
0000085A                          1394ms _1000000E
0000085A  B238 0000               1395ms     CMP.B   0,D1
0000085E  6F00 0064               1396ms     BLE _1000000F
00000862  E98F                    1397m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000864                          1398mm         DOWNLOAD D2
00000864                          1399mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000864                          1400mm 
00000864  1439 00C00003           1401mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000086A  0802 0000               1402mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000086E  6700 0010               1403mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00000872                          1404mm  
00000872                          1405mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000872                 TRUE     1406mmm     IFEQ DEBUG
00000872  1439 00C00007           1407mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000878                          1408mmm     ENDC
00000878                 FALSE    1409mmm     IFNE DEBUG
00000878                          1410mmm     ENDC
00000878                          1411mmm      
00000878  B43C 001B               1412mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000087C  6700 F78A               1413mmm     BEQ START
00000880                          1414mmm     ENDM
00000880                          1415mm CONTINUE_84
00000880  1439 00C00013           1416mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000886  0802 0000               1417mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000088A  67D8                    1418mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0000088C                          1419mm     
0000088C  1439 00C00017           1420mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000892  13C2 00E00001           1421mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000898                          1422mm     
00000898                          1423mm     ENDM
00000898                          1424mm         PRINT_CHAR D2,D3
00000898                          1425mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000898                 TRUE     1426mm     IFEQ DEBUG
00000898  1639 00C00003           1427mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000089E  0803 0002               1428mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000008A2  67F4                    1429mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
000008A4  13C2 00C00007           1430mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008AA                          1431mm     ENDC
000008AA                          1432mm     
000008AA                 FALSE    1433mm     IFNE DEBUG
000008AA                          1434mm     ENDC
000008AA                          1435mm 
000008AA                          1436mm     ENDM
000008AA                          1437mm         HEX2BIN D2,D2,A0
000008AA  41F9 00000FE6           1438mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000008B0  0402 0030               1439mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B4  C4BC 000000FF           1440mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000008BA  1430 2000               1441mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000008BE                          1442mm     ENDM
000008BE  8E02                    1443m         OR.B D2,D7
000008C0  5301                    1444m         SUB.B #1,D1
000008C2                          1445m     ENDW
000008C2  6096                    1446ms     BRA _1000000E
000008C4                          1447ms _1000000F
000008C4                          1448m     
000008C4  7400                    1449m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C6  1407                    1450m     MOVE.B D7,D2
000008C8  DC87                    1451m     ADD.L D7,D6
000008CA                          1452m 
000008CA                          1453m     ENDM
000008CA                          1454m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; bottom byte
000008CA  123C 0002               1455m     MOVE.B #2,D1
000008CE                          1456m     WHILE.B D1 <GT> 0 DO
000008CE                          1457ms _10000010
000008CE  B238 0000               1458ms     CMP.B   0,D1
000008D2  6F00 0064               1459ms     BLE _10000011
000008D6  E98F                    1460m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000008D8                          1461mm         DOWNLOAD D2
000008D8                          1462mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D8                          1463mm 
000008D8  1439 00C00003           1464mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000008DE  0802 0000               1465mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000008E2  6700 0010               1466mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
000008E6                          1467mm  
000008E6                          1468mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000008E6                 TRUE     1469mmm     IFEQ DEBUG
000008E6  1439 00C00007           1470mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000008EC                          1471mmm     ENDC
000008EC                 FALSE    1472mmm     IFNE DEBUG
000008EC                          1473mmm     ENDC
000008EC                          1474mmm      
000008EC  B43C 001B               1475mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000008F0  6700 F716               1476mmm     BEQ START
000008F4                          1477mmm     ENDM
000008F4                          1478mm CONTINUE_89
000008F4  1439 00C00013           1479mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
000008FA  0802 0000               1480mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000008FE  67D8                    1481mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00000900                          1482mm     
00000900  1439 00C00017           1483mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000906  13C2 00E00001           1484mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000090C                          1485mm     
0000090C                          1486mm     ENDM
0000090C                          1487mm         PRINT_CHAR D2,D3
0000090C                          1488mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                 TRUE     1489mm     IFEQ DEBUG
0000090C  1639 00C00003           1490mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000912  0803 0002               1491mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000916  67F4                    1492mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000918  13C2 00C00007           1493mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000091E                          1494mm     ENDC
0000091E                          1495mm     
0000091E                 FALSE    1496mm     IFNE DEBUG
0000091E                          1497mm     ENDC
0000091E                          1498mm 
0000091E                          1499mm     ENDM
0000091E                          1500mm         HEX2BIN D2,D2,A0
0000091E  41F9 00000FE6           1501mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000924  0402 0030               1502mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000928  C4BC 000000FF           1503mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000092E  1430 2000               1504mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000932                          1505mm     ENDM
00000932  8E02                    1506m         OR.B D2,D7
00000934  5301                    1507m         SUB.B #1,D1
00000936                          1508m     ENDW
00000936  6096                    1509ms     BRA _10000010
00000938                          1510ms _10000011
00000938                          1511m     
00000938  7400                    1512m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000093A  1407                    1513m     MOVE.B D7,D2
0000093C  DC87                    1514m     ADD.L D7,D6
0000093E                          1515m 
0000093E                          1516m     ENDM
0000093E                          1517                    
0000093E  2447                    1518                  MOVE.L D7,A2                    ; start address -> A2
00000940                          1519                  
00000940  43F9 00000B1C           1520                  LEA DOWNLOAD_DONE,A1            ; next place to go
00000946                          1521              ELSE
00000946  6000 008A               1522s     BRA _00000007
0000094A                          1523s _00000006
0000094A                          1524m                 PRINT_CRLF D3
0000094A                          1525mm     PRINT_CHAR #13,D3                           ; CR
0000094A                          1526mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094A                 TRUE     1527mm     IFEQ DEBUG
0000094A  1639 00C00003           1528mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000950  0803 0002               1529mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000954  67F4                    1530mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000956  13FC 000D 00C00007      1531mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000095E                          1532mm     ENDC
0000095E                          1533mm     
0000095E                 FALSE    1534mm     IFNE DEBUG
0000095E                          1535mm     ENDC
0000095E                          1536mm 
0000095E                          1537mm     ENDM
0000095E                          1538mm     PRINT_CHAR #10,D3                           ; LF
0000095E                          1539mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1540mm     IFEQ DEBUG
0000095E  1639 00C00003           1541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000964  0803 0002               1542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000968  67F4                    1543mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0000096A  13FC 000A 00C00007      1544mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000972                          1545mm     ENDC
00000972                          1546mm     
00000972                 FALSE    1547mm     IFNE DEBUG
00000972                          1548mm     ENDC
00000972                          1549mm 
00000972                          1550mm     ENDM
00000972                          1551m     ENDM
00000972                          1552              
00000972  41F9 00000F9B           1553                  LEA UNREC,A0                    ; warn for unrecognised type
00000978                          1554m                 PRINT_STR A0,D3
00000978                          1555m LOOP_96
00000978  0C10 0000               1556m     CMP.B #0,(A0)                               ; 0 -> DONE
0000097C  6700 0016               1557m     BEQ EXIT_96
00000980                          1558mm     PRINT_CHAR (A0)+,D3
00000980                          1559mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000980                 TRUE     1560mm     IFEQ DEBUG
00000980  1639 00C00003           1561mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000986  0803 0002               1562mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000098A  67F4                    1563mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0000098C  13D8 00C00007           1564mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000992                          1565mm     ENDC
00000992                          1566mm     
00000992                 FALSE    1567mm     IFNE DEBUG
00000992                          1568mm     ENDC
00000992                          1569mm 
00000992                          1570mm     ENDM
00000992  60E4                    1571m     BRA LOOP_96
00000994                          1572m EXIT_96
00000994                          1573m     ENDM
00000994                          1574m                 PRINT_CHAR D7,D3
00000994                          1575m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000994                 TRUE     1576m     IFEQ DEBUG
00000994  1639 00C00003           1577m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000099A  0803 0002               1578m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000099E  67F4                    1579m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000009A0  13C7 00C00007           1580m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009A6                          1581m     ENDC
000009A6                          1582m     
000009A6                 FALSE    1583m     IFNE DEBUG
000009A6                          1584m     ENDC
000009A6                          1585m 
000009A6                          1586m     ENDM
000009A6                          1587m                 PRINT_CRLF D3
000009A6                          1588mm     PRINT_CHAR #13,D3                           ; CR
000009A6                          1589mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A6                 TRUE     1590mm     IFEQ DEBUG
000009A6  1639 00C00003           1591mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009AC  0803 0002               1592mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009B0  67F4                    1593mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000009B2  13FC 000D 00C00007      1594mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009BA                          1595mm     ENDC
000009BA                          1596mm     
000009BA                 FALSE    1597mm     IFNE DEBUG
000009BA                          1598mm     ENDC
000009BA                          1599mm 
000009BA                          1600mm     ENDM
000009BA                          1601mm     PRINT_CHAR #10,D3                           ; LF
000009BA                          1602mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BA                 TRUE     1603mm     IFEQ DEBUG
000009BA  1639 00C00003           1604mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009C0  0803 0002               1605mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009C4  67F4                    1606mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
000009C6  13FC 000A 00C00007      1607mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009CE                          1608mm     ENDC
000009CE                          1609mm     
000009CE                 FALSE    1610mm     IFNE DEBUG
000009CE                          1611mm     ENDC
000009CE                          1612mm 
000009CE                          1613mm     ENDM
000009CE                          1614m     ENDM
000009CE                          1615              
000009CE  4EF8 0486               1616                  JMP WAIT_FOR_SRECORD            ; ignore any other type    
000009D2                          1617              ENDI
000009D2                          1618s _00000007
000009D2                          1619          ENDI
000009D2                          1620s _00000005
000009D2                          1621      ENDI
000009D2                          1622s _00000001
000009D2                          1623      
000009D2  7E00                    1624      MOVE.L #0,D7                                ; read the checksum from the data stream, and add into the inverted checksum: should make it FF
000009D4                          1625m     DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0                         
000009D4  123C 0002               1626m     MOVE.B #2,D1
000009D8                          1627m     WHILE.B D1 <GT> 0 DO
000009D8                          1628ms _10000012
000009D8  B238 0000               1629ms     CMP.B   0,D1
000009DC  6F00 0064               1630ms     BLE _10000013
000009E0  E98F                    1631m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000009E2                          1632mm         DOWNLOAD D2
000009E2                          1633mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E2                          1634mm 
000009E2  1439 00C00003           1635mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000009E8  0802 0000               1636mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000009EC  6700 0010               1637mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
000009F0                          1638mm  
000009F0                          1639mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000009F0                 TRUE     1640mmm     IFEQ DEBUG
000009F0  1439 00C00007           1641mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000009F6                          1642mmm     ENDC
000009F6                 FALSE    1643mmm     IFNE DEBUG
000009F6                          1644mmm     ENDC
000009F6                          1645mmm      
000009F6  B43C 001B               1646mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000009FA  6700 F60C               1647mmm     BEQ START
000009FE                          1648mmm     ENDM
000009FE                          1649mm CONTINUE_103
000009FE  1439 00C00013           1650mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000A04  0802 0000               1651mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000A08  67D8                    1652mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00000A0A                          1653mm     
00000A0A  1439 00C00017           1654mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000A10  13C2 00E00001           1655mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000A16                          1656mm     
00000A16                          1657mm     ENDM
00000A16                          1658mm         PRINT_CHAR D2,D3
00000A16                          1659mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1660mm     IFEQ DEBUG
00000A16  1639 00C00003           1661mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A1C  0803 0002               1662mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1663mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A22  13C2 00C00007           1664mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A28                          1665mm     ENDC
00000A28                          1666mm     
00000A28                 FALSE    1667mm     IFNE DEBUG
00000A28                          1668mm     ENDC
00000A28                          1669mm 
00000A28                          1670mm     ENDM
00000A28                          1671mm         HEX2BIN D2,D2,A0
00000A28  41F9 00000FE6           1672mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000A2E  0402 0030               1673mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A32  C4BC 000000FF           1674mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000A38  1430 2000               1675mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A3C                          1676mm     ENDM
00000A3C  8E02                    1677m         OR.B D2,D7
00000A3E  5301                    1678m         SUB.B #1,D1
00000A40                          1679m     ENDW
00000A40  6096                    1680ms     BRA _10000012
00000A42                          1681ms _10000013
00000A42                          1682m     
00000A42  7400                    1683m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A44  1407                    1684m     MOVE.B D7,D2
00000A46  DC87                    1685m     ADD.L D7,D6
00000A48                          1686m 
00000A48                          1687m     ENDM
00000A48                          1688m     PRINT_CRLF D3
00000A48                          1689mm     PRINT_CHAR #13,D3                           ; CR
00000A48                          1690mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A48                 TRUE     1691mm     IFEQ DEBUG
00000A48  1639 00C00003           1692mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A4E  0803 0002               1693mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A52  67F4                    1694mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A54  13FC 000D 00C00007      1695mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A5C                          1696mm     ENDC
00000A5C                          1697mm     
00000A5C                 FALSE    1698mm     IFNE DEBUG
00000A5C                          1699mm     ENDC
00000A5C                          1700mm 
00000A5C                          1701mm     ENDM
00000A5C                          1702mm     PRINT_CHAR #10,D3                           ; LF
00000A5C                          1703mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5C                 TRUE     1704mm     IFEQ DEBUG
00000A5C  1639 00C00003           1705mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A62  0803 0002               1706mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A66  67F4                    1707mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A68  13FC 000A 00C00007      1708mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A70                          1709mm     ENDC
00000A70                          1710mm     
00000A70                 FALSE    1711mm     IFNE DEBUG
00000A70                          1712mm     ENDC
00000A70                          1713mm 
00000A70                          1714mm     ENDM
00000A70                          1715m     ENDM
00000A70                          1716          
00000A70                          1717      IF.B D6 <NE> #$FF THEN.L
00000A70  BC3C 00FF               1718s     CMP.B   #$FF,D6
00000A74  6700 00A4               1719s     BEQ.L   _00000008
00000A78  41F9 00000FB2           1720          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00000A7E                          1721m         PRINT_STR A0,D3
00000A7E                          1722m LOOP_110
00000A7E  0C10 0000               1723m     CMP.B #0,(A0)                               ; 0 -> DONE
00000A82  6700 0016               1724m     BEQ EXIT_110
00000A86                          1725mm     PRINT_CHAR (A0)+,D3
00000A86                          1726mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A86                 TRUE     1727mm     IFEQ DEBUG
00000A86  1639 00C00003           1728mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A8C  0803 0002               1729mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A90  67F4                    1730mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A92  13D8 00C00007           1731mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A98                          1732mm     ENDC
00000A98                          1733mm     
00000A98                 FALSE    1734mm     IFNE DEBUG
00000A98                          1735mm     ENDC
00000A98                          1736mm 
00000A98                          1737mm     ENDM
00000A98  60E4                    1738m     BRA LOOP_110
00000A9A                          1739m EXIT_110
00000A9A                          1740m     ENDM
00000A9A                          1741m         PRINT_REG D4,D3,D6,D7,A0
00000A9A                          1742mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000A9A                          1743mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1744mm     IFEQ DEBUG
00000A9A  1639 00C00003           1745mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AA0  0803 0002               1746mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1747mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000AA6  13FC 0030 00C00007      1748mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AAE                          1749mm     ENDC
00000AAE                          1750mm     
00000AAE                 FALSE    1751mm     IFNE DEBUG
00000AAE                          1752mm     ENDC
00000AAE                          1753mm 
00000AAE                          1754mm     ENDM
00000AAE                          1755mm     PRINT_CHAR #'x',D3
00000AAE                          1756mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAE                 TRUE     1757mm     IFEQ DEBUG
00000AAE  1639 00C00003           1758mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AB4  0803 0002               1759mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AB8  67F4                    1760mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000ABA  13FC 0078 00C00007      1761mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AC2                          1762mm     ENDC
00000AC2                          1763mm     
00000AC2                 FALSE    1764mm     IFNE DEBUG
00000AC2                          1765mm     ENDC
00000AC2                          1766mm 
00000AC2                          1767mm     ENDM
00000AC2  7E07                    1768m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AC4                          1769m LOOP_112
00000AC4                          1770mm     BIN2HEX D4,D6,A0
00000AC4  41F9 00000FD6           1771mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000ACA  E99C                    1772mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000ACC  1C04                    1773mm     MOVE.B D4,D6
00000ACE  0286 0000000F           1774mm     ANDI.L #$F,D6
00000AD4  1C30 6000               1775mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000AD8                          1776mm     ENDM
00000AD8                          1777mm     PRINT_CHAR D6,D3
00000AD8                          1778mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1779mm     IFEQ DEBUG
00000AD8  1639 00C00003           1780mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000ADE  0803 0002               1781mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1782mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000AE4  13C6 00C00007           1783mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AEA                          1784mm     ENDC
00000AEA                          1785mm     
00000AEA                 FALSE    1786mm     IFNE DEBUG
00000AEA                          1787mm     ENDC
00000AEA                          1788mm 
00000AEA                          1789mm     ENDM
00000AEA  57CF FFD8               1790m     DBEQ D7,LOOP_112
00000AEE                          1791m     ENDM
00000AEE                          1792m         PRINT_CRLF D3
00000AEE                          1793mm     PRINT_CHAR #13,D3                           ; CR
00000AEE                          1794mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEE                 TRUE     1795mm     IFEQ DEBUG
00000AEE  1639 00C00003           1796mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AF4  0803 0002               1797mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AF8  67F4                    1798mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AFA  13FC 000D 00C00007      1799mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B02                          1800mm     ENDC
00000B02                          1801mm     
00000B02                 FALSE    1802mm     IFNE DEBUG
00000B02                          1803mm     ENDC
00000B02                          1804mm 
00000B02                          1805mm     ENDM
00000B02                          1806mm     PRINT_CHAR #10,D3                           ; LF
00000B02                          1807mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B02                 TRUE     1808mm     IFEQ DEBUG
00000B02  1639 00C00003           1809mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B08  0803 0002               1810mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B0C  67F4                    1811mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B0E  13FC 000A 00C00007      1812mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B16                          1813mm     ENDC
00000B16                          1814mm     
00000B16                 FALSE    1815mm     IFNE DEBUG
00000B16                          1816mm     ENDC
00000B16                          1817mm 
00000B16                          1818mm     ENDM
00000B16                          1819m     ENDM
00000B16  4EF8 0184               1820          JMP MAIN_LOOP
00000B1A                          1821      ENDI
00000B1A                          1822s _00000008
00000B1A                          1823      
00000B1A  4ED1                    1824      JMP (A1)
00000B1C                          1825  DOWNLOAD_DONE
00000B1C                          1826m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00000B1C                          1827mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000B1C                          1828mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1C                 TRUE     1829mm     IFEQ DEBUG
00000B1C  1639 00C00003           1830mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B22  0803 0002               1831mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B26  67F4                    1832mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B28  13FC 0030 00C00007      1833mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B30                          1834mm     ENDC
00000B30                          1835mm     
00000B30                 FALSE    1836mm     IFNE DEBUG
00000B30                          1837mm     ENDC
00000B30                          1838mm 
00000B30                          1839mm     ENDM
00000B30                          1840mm     PRINT_CHAR #'x',D3
00000B30                          1841mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1842mm     IFEQ DEBUG
00000B30  1639 00C00003           1843mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1844mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1845mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000B3C  13FC 0078 00C00007      1846mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B44                          1847mm     ENDC
00000B44                          1848mm     
00000B44                 FALSE    1849mm     IFNE DEBUG
00000B44                          1850mm     ENDC
00000B44                          1851mm 
00000B44                          1852mm     ENDM
00000B44  7C07                    1853m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1854m LOOP_120
00000B46                          1855mm     BIN2HEX D4,D7,A0
00000B46  41F9 00000FD6           1856mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000B4C  E99C                    1857mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1E04                    1858mm     MOVE.B D4,D7
00000B50  0287 0000000F           1859mm     ANDI.L #$F,D7
00000B56  1E30 7000               1860mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1861mm     ENDM
00000B5A                          1862mm     PRINT_CHAR D7,D3
00000B5A                          1863mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1864mm     IFEQ DEBUG
00000B5A  1639 00C00003           1865mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B60  0803 0002               1866mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1867mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B66  13C7 00C00007           1868mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1869mm     ENDC
00000B6C                          1870mm     
00000B6C                 FALSE    1871mm     IFNE DEBUG
00000B6C                          1872mm     ENDC
00000B6C                          1873mm 
00000B6C                          1874mm     ENDM
00000B6C  57CE FFD8               1875m     DBEQ D6,LOOP_120
00000B70                          1876m     ENDM
00000B70  41F9 00000F79           1877      LEA READ,A0
00000B76                          1878m     PRINT_STR A0,D3
00000B76                          1879m LOOP_125
00000B76  0C10 0000               1880m     CMP.B #0,(A0)                               ; 0 -> DONE
00000B7A  6700 0016               1881m     BEQ EXIT_125
00000B7E                          1882mm     PRINT_CHAR (A0)+,D3
00000B7E                          1883mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1884mm     IFEQ DEBUG
00000B7E  1639 00C00003           1885mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B84  0803 0002               1886mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1887mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B8A  13D8 00C00007           1888mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1889mm     ENDC
00000B90                          1890mm     
00000B90                 FALSE    1891mm     IFNE DEBUG
00000B90                          1892mm     ENDC
00000B90                          1893mm 
00000B90                          1894mm     ENDM
00000B90  60E4                    1895m     BRA LOOP_125
00000B92                          1896m EXIT_125
00000B92                          1897m     ENDM
00000B92  2E0A                    1898      MOVE.L A2,D7                                ; set address accumulator to start address
00000B94                          1899m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00000B94                          1900mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000B94                          1901mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B94                 TRUE     1902mm     IFEQ DEBUG
00000B94  1639 00C00003           1903mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B9A  0803 0002               1904mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B9E  67F4                    1905mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BA0  13FC 0030 00C00007      1906mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BA8                          1907mm     ENDC
00000BA8                          1908mm     
00000BA8                 FALSE    1909mm     IFNE DEBUG
00000BA8                          1910mm     ENDC
00000BA8                          1911mm 
00000BA8                          1912mm     ENDM
00000BA8                          1913mm     PRINT_CHAR #'x',D3
00000BA8                          1914mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA8                 TRUE     1915mm     IFEQ DEBUG
00000BA8  1639 00C00003           1916mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BAE  0803 0002               1917mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BB2  67F4                    1918mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BB4  13FC 0078 00C00007      1919mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BBC                          1920mm     ENDC
00000BBC                          1921mm     
00000BBC                 FALSE    1922mm     IFNE DEBUG
00000BBC                          1923mm     ENDC
00000BBC                          1924mm 
00000BBC                          1925mm     ENDM
00000BBC  7C07                    1926m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBE                          1927m LOOP_127
00000BBE                          1928mm     BIN2HEX D7,D2,A0
00000BBE  41F9 00000FD6           1929mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000BC4  E99F                    1930mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC6  1407                    1931mm     MOVE.B D7,D2
00000BC8  0282 0000000F           1932mm     ANDI.L #$F,D2
00000BCE  1430 2000               1933mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BD2                          1934mm     ENDM
00000BD2                          1935mm     PRINT_CHAR D2,D3
00000BD2                          1936mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                 TRUE     1937mm     IFEQ DEBUG
00000BD2  1639 00C00003           1938mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BD8  0803 0002               1939mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BDC  67F4                    1940mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000BDE  13C2 00C00007           1941mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BE4                          1942mm     ENDC
00000BE4                          1943mm     
00000BE4                 FALSE    1944mm     IFNE DEBUG
00000BE4                          1945mm     ENDC
00000BE4                          1946mm 
00000BE4                          1947mm     ENDM
00000BE4  57CE FFD8               1948m     DBEQ D6,LOOP_127
00000BE8                          1949m     ENDM
00000BE8                          1950m     PRINT_CRLF D3     
00000BE8                          1951mm     PRINT_CHAR #13,D3                           ; CR
00000BE8                          1952mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE8                 TRUE     1953mm     IFEQ DEBUG
00000BE8  1639 00C00003           1954mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BEE  0803 0002               1955mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BF2  67F4                    1956mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000BF4  13FC 000D 00C00007      1957mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BFC                          1958mm     ENDC
00000BFC                          1959mm     
00000BFC                 FALSE    1960mm     IFNE DEBUG
00000BFC                          1961mm     ENDC
00000BFC                          1962mm 
00000BFC                          1963mm     ENDM
00000BFC                          1964mm     PRINT_CHAR #10,D3                           ; LF
00000BFC                          1965mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BFC                 TRUE     1966mm     IFEQ DEBUG
00000BFC  1639 00C00003           1967mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C02  0803 0002               1968mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C06  67F4                    1969mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C08  13FC 000A 00C00007      1970mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000C10                          1971mm     ENDC
00000C10                          1972mm     
00000C10                 FALSE    1973mm     IFNE DEBUG
00000C10                          1974mm     ENDC
00000C10                          1975mm 
00000C10                          1976mm     ENDM
00000C10                          1977m     ENDM
00000C10                          1978          
00000C10  4EF8 0184               1979      JMP MAIN_LOOP
00000C14                          1980      
00000C14                          1981  G
00000C14  2047                    1982      MOVE.L D7,A0                                ; address accumulator -> address register
00000C16  3E3C 0000               1983      MOVE #0,D7                                  ; clear the now used address accumulator
00000C1A  4ED0                    1984      JMP (A0)                                    ; jump to it!
00000C1C                          1985      
00000C1C                          1986  Z
00000C1C  207C 00200000           1987      MOVE.L #RAM,A0                              ; address of RAM
00000C22  7000                    1988      MOVE.L #0,D0                                ; number of bytes
00000C24                          1989     
00000C24                          1990      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C24                          1991s _10000014
00000C24  B0BC 00040000           1992s     CMP.L   #$40000,D0
00000C2A  6E00 001A               1993s     BGT _10000015
00000C2E  2200                    1994          MOVE.L D0,D1                            ; progress update
00000C30  E089                    1995          LSR.L #8,D1 
00000C32  E089                    1996          LSR.L #8,D1
00000C34  0281 0000000F           1997          ANDI.L #$F,D1
00000C3A  13C1 00E00001           1998          MOVE.B D1,DISPLAY
00000C40                          1999  
00000C40  20C0                    2000          MOVE.L D0,(A0)+ 
00000C42  5880                    2001          ADD.L #4,D0
00000C44                          2002      ENDW
00000C44  60DE                    2003s     BRA _10000014
00000C46                          2004s _10000015
00000C46                          2005   
00000C46  207C 00200000           2006      MOVE.L #RAM,A0                              ; address of RAM
00000C4C  7000                    2007      MOVE.L #0,D0                                ; number of bytes
00000C4E                          2008     
00000C4E                          2009      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C4E                          2010s _10000016
00000C4E  B0BC 00040000           2011s     CMP.L   #$40000,D0
00000C54  6E00 00C8               2012s     BGT _10000017
00000C58  2200                    2013          MOVE.L D0,D1                            ; progress update
00000C5A  E089                    2014          LSR.L #8,D1
00000C5C  E089                    2015          LSR.L #8,D1
00000C5E  0281 0000000F           2016          ANDI.L #$F,D1
00000C64  13C1 00E00001           2017          MOVE.B D1,DISPLAY
00000C6A                          2018  
00000C6A  2218                    2019          MOVE.L (A0)+,D1
00000C6C                          2020            
00000C6C                          2021          IF.L D0 <EQ> D1 THEN
00000C6C  B081                    2022s     CMP.L   D1,D0
00000C6E  6600 0006               2023s     BNE _00000009
00000C72  6000 00A4               2024              BRA OK
00000C76                          2025          ENDI 
00000C76                          2026s _00000009
00000C76                          2027            
00000C76  43F9 00000FC4           2028          LEA RAM_ERROR,A1
00000C7C                          2029m         PRINT_STR A1,D1
00000C7C                          2030m LOOP_135
00000C7C  0C11 0000               2031m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C80  6700 0016               2032m     BEQ EXIT_135
00000C84                          2033mm     PRINT_CHAR (A1)+,D1
00000C84                          2034mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C84                 TRUE     2035mm     IFEQ DEBUG
00000C84  1239 00C00003           2036mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C8A  0801 0002               2037mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C8E  67F4                    2038mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C90  13D9 00C00007           2039mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C96                          2040mm     ENDC
00000C96                          2041mm     
00000C96                 FALSE    2042mm     IFNE DEBUG
00000C96                          2043mm     ENDC
00000C96                          2044mm 
00000C96                          2045mm     ENDM
00000C96  60E4                    2046m     BRA LOOP_135
00000C98                          2047m EXIT_135
00000C98                          2048m     ENDM
00000C98  2208                    2049          MOVE.L A0,D1
00000C9A  5981                    2050          SUB.L #4,D1
00000C9C                          2051m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C9C                          2052mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000C9C                          2053mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9C                 TRUE     2054mm     IFEQ DEBUG
00000C9C  1639 00C00003           2055mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CA2  0803 0002               2056mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA6  67F4                    2057mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000CA8  13FC 0030 00C00007      2058mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CB0                          2059mm     ENDC
00000CB0                          2060mm     
00000CB0                 FALSE    2061mm     IFNE DEBUG
00000CB0                          2062mm     ENDC
00000CB0                          2063mm 
00000CB0                          2064mm     ENDM
00000CB0                          2065mm     PRINT_CHAR #'x',D3
00000CB0                          2066mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB0                 TRUE     2067mm     IFEQ DEBUG
00000CB0  1639 00C00003           2068mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB6  0803 0002               2069mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CBA  67F4                    2070mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CBC  13FC 0078 00C00007      2071mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CC4                          2072mm     ENDC
00000CC4                          2073mm     
00000CC4                 FALSE    2074mm     IFNE DEBUG
00000CC4                          2075mm     ENDC
00000CC4                          2076mm 
00000CC4                          2077mm     ENDM
00000CC4  7C07                    2078m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CC6                          2079m LOOP_137
00000CC6                          2080mm     BIN2HEX D1,D2,A1
00000CC6  43F9 00000FD6           2081mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000CCC  E999                    2082mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CCE  1401                    2083mm     MOVE.B D1,D2
00000CD0  0282 0000000F           2084mm     ANDI.L #$F,D2
00000CD6  1431 2000               2085mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000CDA                          2086mm     ENDM
00000CDA                          2087mm     PRINT_CHAR D2,D3
00000CDA                          2088mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDA                 TRUE     2089mm     IFEQ DEBUG
00000CDA  1639 00C00003           2090mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE0  0803 0002               2091mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE4  67F4                    2092mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CE6  13C2 00C00007           2093mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CEC                          2094mm     ENDC
00000CEC                          2095mm     
00000CEC                 FALSE    2096mm     IFNE DEBUG
00000CEC                          2097mm     ENDC
00000CEC                          2098mm 
00000CEC                          2099mm     ENDM
00000CEC  57CE FFD8               2100m     DBEQ D6,LOOP_137
00000CF0                          2101m     ENDM
00000CF0                          2102m         PRINT_CRLF D3
00000CF0                          2103mm     PRINT_CHAR #13,D3                           ; CR
00000CF0                          2104mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF0                 TRUE     2105mm     IFEQ DEBUG
00000CF0  1639 00C00003           2106mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CF6  0803 0002               2107mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CFA  67F4                    2108mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CFC  13FC 000D 00C00007      2109mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D04                          2110mm     ENDC
00000D04                          2111mm     
00000D04                 FALSE    2112mm     IFNE DEBUG
00000D04                          2113mm     ENDC
00000D04                          2114mm 
00000D04                          2115mm     ENDM
00000D04                          2116mm     PRINT_CHAR #10,D3                           ; LF
00000D04                          2117mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D04                 TRUE     2118mm     IFEQ DEBUG
00000D04  1639 00C00003           2119mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D0A  0803 0002               2120mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0E  67F4                    2121mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D10  13FC 000A 00C00007      2122mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D18                          2123mm     ENDC
00000D18                          2124mm     
00000D18                 FALSE    2125mm     IFNE DEBUG
00000D18                          2126mm     ENDC
00000D18                          2127mm 
00000D18                          2128mm     ENDM
00000D18                          2129m     ENDM
00000D18                          2130  OK    
00000D18  5880                    2131          ADD.L #4,D0
00000D1A                          2132      ENDW
00000D1A  6000 FF32               2133s     BRA _10000016
00000D1E                          2134s _10000017
00000D1E                          2135      
00000D1E  4EF8 0184               2136      JMP MAIN_LOOP
00000D22                          2137    
00000D22                          2138  L
00000D22  7A00                    2139      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000D24                          2140  
00000D24                          2141m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000D24                          2142m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D24                          2143m 
00000D24                 TRUE     2144m     IFEQ DEBUG
00000D24  1639 00C00003           2145m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D2A  0803 0000               2146m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D2E  67F4                    2147m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D30                          2148m     ENDC
00000D30                          2149m     
00000D30                          2150mm     READ_CHAR D2
00000D30                 TRUE     2151mm     IFEQ DEBUG
00000D30  1439 00C00007           2152mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D36                          2153mm     ENDC
00000D36                 FALSE    2154mm     IFNE DEBUG
00000D36                          2155mm     ENDC
00000D36                          2156mm      
00000D36  B43C 001B               2157mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D3A  6700 F2CC               2158mm     BEQ START
00000D3E                          2159mm     ENDM
00000D3E                          2160m 
00000D3E                 TRUE     2161m     IFEQ DEBUG
00000D3E                          2162mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D3E                          2163mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                 TRUE     2164mm     IFEQ DEBUG
00000D3E  1639 00C00003           2165mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D44  0803 0002               2166mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D48  67F4                    2167mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D4A  13C2 00C00007           2168mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D50                          2169mm     ENDC
00000D50                          2170mm     
00000D50                 FALSE    2171mm     IFNE DEBUG
00000D50                          2172mm     ENDC
00000D50                          2173mm 
00000D50                          2174mm     ENDM
00000D50                          2175m     ENDC
00000D50                          2176m     ENDM
00000D50                          2177m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D50  41F9 00000FE6           2178m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D56  0402 0030               2179m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D5A  C4BC 000000FF           2180m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D60  1430 2000               2181m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D64                          2182m     ENDM
00000D64  1A02                    2183      MOVE.B D2,D5                                ; put at bottom of D5
00000D66                          2184  
00000D66  3C3C 0002               2185      MOVE #2,D6                                  ; 3 bytes left to read
00000D6A                          2186      
00000D6A                          2187  READ_LENGTH
00000D6A  E98D                    2188      LSL.L #4,D5                                 ; make what we have so far more significant
00000D6C                          2189m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D6C                          2190m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6C                          2191m 
00000D6C                 TRUE     2192m     IFEQ DEBUG
00000D6C  1639 00C00003           2193m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D72  0803 0000               2194m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D76  67F4                    2195m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D78                          2196m     ENDC
00000D78                          2197m     
00000D78                          2198mm     READ_CHAR D2
00000D78                 TRUE     2199mm     IFEQ DEBUG
00000D78  1439 00C00007           2200mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D7E                          2201mm     ENDC
00000D7E                 FALSE    2202mm     IFNE DEBUG
00000D7E                          2203mm     ENDC
00000D7E                          2204mm      
00000D7E  B43C 001B               2205mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D82  6700 F284               2206mm     BEQ START
00000D86                          2207mm     ENDM
00000D86                          2208m 
00000D86                 TRUE     2209m     IFEQ DEBUG
00000D86                          2210mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D86                          2211mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D86                 TRUE     2212mm     IFEQ DEBUG
00000D86  1639 00C00003           2213mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D8C  0803 0002               2214mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D90  67F4                    2215mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000D92  13C2 00C00007           2216mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D98                          2217mm     ENDC
00000D98                          2218mm     
00000D98                 FALSE    2219mm     IFNE DEBUG
00000D98                          2220mm     ENDC
00000D98                          2221mm 
00000D98                          2222mm     ENDM
00000D98                          2223m     ENDC
00000D98                          2224m     ENDM
00000D98                          2225m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D98  41F9 00000FE6           2226m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D9E  0402 0030               2227m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DA2  C4BC 000000FF           2228m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000DA8  1430 2000               2229m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000DAC                          2230m     ENDM
00000DAC  8A02                    2231      OR.B D2,D5
00000DAE  023C 00FB               2232      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DB2  57CE FFB6               2233      DBEQ D6,READ_LENGTH
00000DB6                          2234          
00000DB6                          2235m     PRINT_CRLF D3
00000DB6                          2236mm     PRINT_CHAR #13,D3                           ; CR
00000DB6                          2237mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB6                 TRUE     2238mm     IFEQ DEBUG
00000DB6  1639 00C00003           2239mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DBC  0803 0002               2240mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DC0  67F4                    2241mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC2  13FC 000D 00C00007      2242mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DCA                          2243mm     ENDC
00000DCA                          2244mm     
00000DCA                 FALSE    2245mm     IFNE DEBUG
00000DCA                          2246mm     ENDC
00000DCA                          2247mm 
00000DCA                          2248mm     ENDM
00000DCA                          2249mm     PRINT_CHAR #10,D3                           ; LF
00000DCA                          2250mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DCA                 TRUE     2251mm     IFEQ DEBUG
00000DCA  1639 00C00003           2252mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DD0  0803 0002               2253mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DD4  67F4                    2254mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000DD6  13FC 000A 00C00007      2255mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DDE                          2256mm     ENDC
00000DDE                          2257mm     
00000DDE                 FALSE    2258mm     IFNE DEBUG
00000DDE                          2259mm     ENDC
00000DDE                          2260mm 
00000DDE                          2261mm     ENDM
00000DDE                          2262m     ENDM
00000DDE                          2263  
00000DDE  207C 00000000           2264      MOVE.L #ROM,A0                              ; start of ROM
00000DE4                          2265      
00000DE4  2247                    2266      MOVE.L D7,A1                                ; address accumulator -> address register
00000DE6  7E00                    2267      MOVE.L #0,D7                                ; clear the now used address accumulator
00000DE8                          2268      
00000DE8  267C 00002AAA           2269      MOVE.L #$2AAA,A3
00000DEE  36BC AAAA               2270      MOVE.W #$AAAA,(A3)
00000DF2  267C 00001554           2271      MOVE.L #$1554,A3
00000DF8  36BC 5555               2272      MOVE.W #$5555,(A3)
00000DFC  267C 00002AAA           2273      MOVE.L #$2AAA,A3
00000E02  36BC 8080               2274      MOVE.W #$8080,(A3)
00000E06  267C 00002AAA           2275      MOVE.L #$2AAA,A3
00000E0C  36BC AAAA               2276      MOVE.W #$AAAA,(A3)
00000E10  267C 00001554           2277      MOVE.L #$1554,A3
00000E16  36BC 5555               2278      MOVE.W #$5555,(A3)
00000E1A  267C 00002AAA           2279      MOVE.L #$2AAA,A3
00000E20  36BC 2020               2280      MOVE.W #$2020,(A3)
00000E24                          2281      
00000E24  45F9 00000FFD           2282      LEA LOADING,A2                              ; important for timing
00000E2A                          2283m     PRINT_STR A2,D3
00000E2A                          2284m LOOP_156
00000E2A  0C12 0000               2285m     CMP.B #0,(A2)                               ; 0 -> DONE
00000E2E  6700 0016               2286m     BEQ EXIT_156
00000E32                          2287mm     PRINT_CHAR (A2)+,D3
00000E32                          2288mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E32                 TRUE     2289mm     IFEQ DEBUG
00000E32  1639 00C00003           2290mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E38  0803 0002               2291mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E3C  67F4                    2292mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E3E  13DA 00C00007           2293mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E44                          2294mm     ENDC
00000E44                          2295mm     
00000E44                 FALSE    2296mm     IFNE DEBUG
00000E44                          2297mm     ENDC
00000E44                          2298mm 
00000E44                          2299mm     ENDM
00000E44  60E4                    2300m     BRA LOOP_156
00000E46                          2301m EXIT_156
00000E46                          2302m     ENDM
00000E46                          2303  
00000E46  023C 00FB               2304      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000E4A                          2305      
00000E4A                          2306      WHILE D5 <GT> #0 DO
00000E4A                          2307s _10000018
00000E4A  BA7C 0000               2308s     CMP.W   #0,D5
00000E4E  6F00 001E               2309s     BLE _10000019
00000E52  5585                    2310          SUB.L #2,D5
00000E54                          2311            
00000E54  13D1 00E00001           2312          MOVE.B (A1),DISPLAY
00000E5A  3091                    2313          MOVE.W (A1),(A0)                        ; write the data
00000E5C                          2314        
00000E5C                          2315  WAIT_FOR_COMPLETE
00000E5C  3410                    2316          MOVE.W (A0),D2
00000E5E                          2317  
00000E5E                          2318          IF D2 <NE> (A1) THEN
00000E5E  B451                    2319s     CMP.W   (A1),D2
00000E60  6700 0006               2320s     BEQ _0000000A
00000E64  4EF8 0E5C               2321              JMP WAIT_FOR_COMPLETE
00000E68                          2322          ENDI
00000E68                          2323s _0000000A
00000E68                          2324        
00000E68  5488                    2325          ADD.L #2,A0
00000E6A  5489                    2326          ADD.L #2,A1
00000E6C                          2327      ENDW  
00000E6C  60DC                    2328s     BRA _10000018
00000E6E                          2329s _10000019
00000E6E                          2330      
00000E6E  267C 00002AAA           2331      MOVE.L #$2AAA,A3
00000E74  36BC AAAA               2332      MOVE.W #$AAAA,(A3)
00000E78  267C 00001554           2333      MOVE.L #$1554,A3
00000E7E  36BC 5555               2334      MOVE.W #$5555,(A3)
00000E82  267C 00002AAA           2335      MOVE.L #$2AAA,A3
00000E88  36BC A0A0               2336      MOVE.W #$A0A0,(A3)
00000E8C                          2337              
00000E8C  4EF8 0184               2338      JMP MAIN_LOOP
00000E90                          2339          
00000E90                          2340  HEX_DIGIT
00000E90  E98F                    2341      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000E92                          2342m     HEX2BIN D2,D2,A0
00000E92  41F9 00000FE6           2343m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000E98  0402 0030               2344m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E9C  C4BC 000000FF           2345m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EA2  1430 2000               2346m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000EA6                          2347m     ENDM
00000EA6  8E02                    2348      OR.B D2,D7  
00000EA8  4EF8 01AC               2349      JMP GET_INPUT
00000EAC                          2350  
00000EAC  FFFF FFFF               2351      SIMHALT                                     ; halt simulator
00000EB0                          2352  
00000EB0                          2353  ; strings
00000EB0= 4D 44 46 2D 6D 6F ...   2354  VERSION DC.B 'MDF-mon V1.48 (10/04/2021)',13,10,0
00000ECD= 3F 20 48 65 6C 70 ...   2355  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00000F72= 48 75 68 3F 0D 0A 00    2356  HUH     DC.B 'Huh?',13,10,0
00000F79= 20 53 20 72 65 63 ...   2357  READ    DC.B ' S records read, start address = ',0
00000F9B= 57 3A 20 55 6E 6B ...   2358  UNREC   DC.B 'W: Unknown Srec type: ',0
00000FB2= 57 3A 20 43 53 20 ...   2359  CS_FAILURE   DC.B 'W: CS failure at ',0
00000FC4= 57 3A 20 52 41 4D ...   2360  RAM_ERROR DC.B 'W: RAM error at: ',0
00000FD6= 30 31 32 33 34 35 ...   2361  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000FE6= 00 01 02 03 04 05 ...   2362  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000FFD= 4C 6F 61 64 69 6E ...   2363  LOADING  DC.B 'Loading EEPROM...',13,11,0
00001011                          2364      
00001011                          2365      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         FD6
CONTINUE_103        9FE
CONTINUE_44         4A2
CONTINUE_47         4F2
CONTINUE_51         54A
CONTINUE_59         608
CONTINUE_64         67C
CONTINUE_69         6FA
CONTINUE_74         77E
CONTINUE_79         80C
CONTINUE_84         880
CONTINUE_89         8F4
CS_FAILURE          FB2
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       B1C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            A9A
EXIT_125            B92
EXIT_135            C98
EXIT_156            E46
EXIT_19             2E2
EXIT_21             308
EXIT_23             32E
EXIT_5              13E
EXIT_96             994
G                   C14
GET_INPUT           1AC
H                   2E6
HELP                ECD
HEX2BIN             134
HEX2BIN_LUT         FE6
HEX_DIGIT           E90
HUH                 F72
L                   D22
LOADING             FFD
LOOP_110            A7E
LOOP_112            AC4
LOOP_120            B46
LOOP_125            B76
LOOP_127            BBE
LOOP_135            C7C
LOOP_137            CC6
LOOP_156            E2A
LOOP_19             2C6
LOOP_21             2EC
LOOP_23             312
LOOP_25             360
LOOP_5              122
LOOP_96             978
MAIN_LOOP           184
OK                  D18
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   332
RAM                 200000
RAM_ERROR           FC4
READ                F79
READ_CHAR           805
READ_DATA_TO_POKE   400
READ_LENGTH         D6A
RESET               4
ROM                 0
S                   47E
STACK               0
START               8
UNREC               F9B
V                   30C
VERSION             EB0
W                   3B8
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E5C
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   166
WAIT_FOR_READY_100  9A6
WAIT_FOR_READY_101  9BA
WAIT_FOR_READY_103  9E2
WAIT_FOR_READY_105  A16
WAIT_FOR_READY_108  A48
WAIT_FOR_READY_109  A5C
WAIT_FOR_READY_11   184
WAIT_FOR_READY_111  A86
WAIT_FOR_READY_113  A9A
WAIT_FOR_READY_114  AAE
WAIT_FOR_READY_116  AD8
WAIT_FOR_READY_118  AEE
WAIT_FOR_READY_119  B02
WAIT_FOR_READY_12   198
WAIT_FOR_READY_121  B1C
WAIT_FOR_READY_122  B30
WAIT_FOR_READY_124  B5A
WAIT_FOR_READY_126  B7E
WAIT_FOR_READY_128  B94
WAIT_FOR_READY_129  BA8
WAIT_FOR_READY_13   1AC
WAIT_FOR_READY_131  BD2
WAIT_FOR_READY_133  BE8
WAIT_FOR_READY_134  BFC
WAIT_FOR_READY_136  C84
WAIT_FOR_READY_138  C9C
WAIT_FOR_READY_139  CB0
WAIT_FOR_READY_141  CDA
WAIT_FOR_READY_143  CF0
WAIT_FOR_READY_144  D04
WAIT_FOR_READY_145  D24
WAIT_FOR_READY_147  D3E
WAIT_FOR_READY_149  D6C
WAIT_FOR_READY_15   1C6
WAIT_FOR_READY_151  D86
WAIT_FOR_READY_154  DB6
WAIT_FOR_READY_155  DCA
WAIT_FOR_READY_157  E32
WAIT_FOR_READY_17   268
WAIT_FOR_READY_18   27C
WAIT_FOR_READY_20   2CE
WAIT_FOR_READY_22   2F4
WAIT_FOR_READY_24   31A
WAIT_FOR_READY_26   336
WAIT_FOR_READY_27   34A
WAIT_FOR_READY_29   374
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_32   39E
WAIT_FOR_READY_33   3BA
WAIT_FOR_READY_35   3D4
WAIT_FOR_READY_37   402
WAIT_FOR_READY_39   41C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   452
WAIT_FOR_READY_43   466
WAIT_FOR_READY_44   486
WAIT_FOR_READY_46   4C0
WAIT_FOR_READY_47   4D6
WAIT_FOR_READY_49   50A
WAIT_FOR_READY_51   52E
WAIT_FOR_READY_53   562
WAIT_FOR_READY_56   59C
WAIT_FOR_READY_57   5B0
WAIT_FOR_READY_59   5EC
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   620
WAIT_FOR_READY_64   660
WAIT_FOR_READY_66   694
WAIT_FOR_READY_69   6DE
WAIT_FOR_READY_71   712
WAIT_FOR_READY_74   762
WAIT_FOR_READY_76   796
WAIT_FOR_READY_79   7F0
WAIT_FOR_READY_8    13E
WAIT_FOR_READY_81   824
WAIT_FOR_READY_84   864
WAIT_FOR_READY_86   898
WAIT_FOR_READY_89   8D8
WAIT_FOR_READY_9    152
WAIT_FOR_READY_91   90C
WAIT_FOR_READY_94   94A
WAIT_FOR_READY_95   95E
WAIT_FOR_READY_97   980
WAIT_FOR_READY_98   994
WAIT_FOR_SRECORD    486
Z                   C1C
_00000000           5CC
_00000001           9D2
_00000002           5DA
_00000003           7D8
_00000004           744
_00000005           9D2
_00000006           94A
_00000007           9D2
_00000008           B1A
_00000009           C76
_0000000A           E68
_10000000           524
_10000001           58E
_10000002           5E2
_10000003           64C
_10000004           656
_10000005           6C0
_10000006           6D4
_10000007           73E
_10000008           748
_10000009           7D0
_1000000A           758
_1000000B           7C2
_1000000C           7E6
_1000000D           850
_1000000E           85A
_1000000F           8C4
_10000010           8CE
_10000011           938
_10000012           9D8
_10000013           A42
_10000014           C24
_10000015           C46
_10000016           C4E
_10000017           D1E
_10000018           E4A
_10000019           E6E
