00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 01/04/2021 17:52:10

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000  =00000000                  9  DEBUG               EQU 0
00000000                            10  
00000000                            11  ; constants
00000000  =00E00000                 12  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 13  DISPLAY_            EQU $0
00000000  =00E00001                 14  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            15  
00000000  =00D30000                 16  DUART_BASE          EQU $D30000
00000000  =00000000                 17  DUART_MRA_          EQU $0
00000000  =00000001                 18  DUART_CSRA_         EQU $1
00000000  =00000001                 19  DUART_SRA_          EQU $1
00000000  =00000002                 20  DUART_CRA_          EQU $2
00000000  =00000003                 21  DUART_TXA_          EQU $3
00000000  =00000003                 22  DUART_RXA_          EQU $3
00000000  =00000004                 23  DUART_ACR_          EQU $4
00000000  =00000005                 24  DUART_IMR_          EQU $5
00000000  =00000008                 25  DUART_MRB_          EQU $8
00000000  =00000009                 26  DUART_CSRB_         EQU $9
00000000  =00000009                 27  DUART_SRB_          EQU $9
00000000  =0000000A                 28  DUART_CRB_          EQU $A
00000000  =0000000B                 29  DUART_TXB_          EQU $B
00000000  =0000000B                 30  DUART_RXB_          EQU $B
00000000  =0000000C                 31  DUART_IVR_          EQU $C
00000000  =0000000D                 32  DUART_OPCR_         EQU $D
00000000  =0000000E                 33  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 34  DUART_RESET_OPR_    EQU $F
00000000                            35  RRRR
00000000  =00D30001                 36  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 37  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 38  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 39  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 40  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 41  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            42  
00000000  =00D30011                 43  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 44  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 45  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 46  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 47  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 48  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            49  
00000000  =00D30009                 50  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 51  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 52  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 53  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 54  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 55  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            56  
00000000                            57  ; macros
00000000                            58  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            59  ; the input register is changed during the process
00000000                            60  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            61  BIN2HEX MACRO
00000000                            62    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            63    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            64    MOVE.B \1,\2
00000000                            65    ANDI.L #$F,\2
00000000                            66    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            67    ENDM
00000000                            68  
00000000                            69  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            70  ; the input register is changed during the process
00000000                            71  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            72  HEX2BIN MACRO
00000000                            73    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            74    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            75    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            76    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            77    ENDM
00000000                            78  
00000000                            79  ; send a single char to the serial port
00000000                            80  ; \1 = char to send, \2 = data register to use for status poll
00000000                            81  ; will stamp on D0 and D1 in debug mode
00000000                            82  PRINT_CHAR MACRO
00000000                            83  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            84      IFEQ DEBUG
00000000                            85        MOVE.B DUART_SRA,\2           ; read status register
00000000                            86        BTST #2,\2                    ; check for space to send
00000000                            87        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            88        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            89      ENDC
00000000                            90      
00000000                            91      IFNE DEBUG
00000000                            92        MOVE.B \1,D1
00000000                            93        MOVE.L #6,D0   
00000000                            94        TRAP #15                      ; write to terminal in simulator
00000000                            95      ENDC
00000000                            96  
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send CR,LF to the serial port
00000000                           100  ; \1 = data register to use for status poll
00000000                           101  PRINT_CRLF MACRO                  
00000000                           102      PRINT_CHAR #13,\1             ; CR
00000000                           103      PRINT_CHAR #10,\1             ; LF
00000000                           104      ENDM
00000000                           105  
00000000                           106  ; send C-style, zero terminated string to the serial port
00000000                           107  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           108  PRINT_STR MACRO
00000000                           109  LOOP\@
00000000                           110      CMP.B #0,(\1)                 ; 0 -> done
00000000                           111      BEQ EXIT\@
00000000                           112      PRINT_CHAR (\1)+,\2
00000000                           113      JMP LOOP\@
00000000                           114  EXIT\@
00000000                           115      ENDM
00000000                           116    
00000000                           117  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           118  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           119  PRINT_REG MACRO
00000000                           120      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           121  LOOP\@
00000000                           122      BIN2HEX \1,\3,\5
00000000                           123      PRINT_CHAR \3,\2
00000000                           124      DBEQ \4,LOOP\@
00000000                           125      ENDM
00000000                           126    
00000000                           127  ; wait for a char from the serial port
00000000                           128  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           129  ; will stamp on D0 and D1 in debug mode
00000000                           130  WAIT_CHAR MACRO
00000000                           131  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           132  
00000000                           133      IFEQ DEBUG
00000000                           134        MOVE.B DUART_SRA,\2         ; read status register
00000000                           135        BTST #0,\2                    ; check for character
00000000                           136        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           137      ENDC
00000000                           138      
00000000                           139      READ_CHAR \1
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        PRINT_CHAR \1,\2            ; echo it back
00000000                           143      ENDC
00000000                           144      ENDM
00000000                           145      
00000000                           146  ; read a char from the serial port - assumes that there is one!
00000000                           147  ; \ 1= data register for read char
00000000                           148  ; will stamp on D0 and D1 in debug mode
00000000                           149  READ_CHAR MACRO
00000000                           150      IFEQ DEBUG
00000000                           151        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           152      ENDC
00000000                           153      IFNE DEBUG
00000000                           154        MOVE.L #5,D0    
00000000                           155        TRAP #15                    ; read from keyboard in simulator
00000000                           156        MOVE.L D1,\1
00000000                           157      ENDC
00000000                           158       
00000000                           159      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           160      BEQ START
00000000                           161      ENDM
00000000                           162      
00000000                           163      
00000000                           164  ; read data from the download serial port
00000000                           165  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           166  DOWNLOAD MACRO
00000000                           167  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           168  
00000000                           169      MOVE.B DUART_SRA,\2           ; check for command
00000000                           170      BTST #0,\2                    ; check for character
00000000                           171      BEQ CONTINUE\@                ; nothing, continue
00000000                           172   
00000000                           173      READ_CHAR \1
00000000                           174  CONTINUE\@
00000000                           175      MOVE.B DUART_SRB,\2         ; read status register
00000000                           176      BTST #0,\2                  ; check for character
00000000                           177      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           178      
00000000                           179      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           180      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           181      
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; register catalogue
00000000                           186  ; D0 - used for simulator I/O
00000000                           187  ; D1 - used for simulator I/O
00000000                           188  ; D2 - read character
00000000                           189  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           190  ; D4 - count of S records read
00000000                           191  ; D5 - data to write / data read / byte count for S record load
00000000                           192  ; D6 - working register used in R/W and download
00000000                           193  ; D7 - address accumulator / reset by download
00000000                           194  ; A0 - address of string to print 
00000000                           195  
00000000                           196  ; start vector
00000000                           197      ORG  $0
00000000= 00000000                 198      DC.L $00000000              ; PC
00000004= 00000000                 199      DC.L $00000000              ; SP
00000008                           200      
00000008                           201  ; start of program  
00000008                           202  START
00000008  13FC 0000 00E00001       203      MOVE.B #0,DISPLAY
00000010                           204  
00000010                           205  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       206      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       207      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     208      NOP
00000022  13FC 0040 00D30005       209      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     210      NOP
0000002C  13FC 0030 00D30005       211      MOVE.B #$30,DUART_CRA
00000034  4E71                     212      NOP
00000036  13FC 0020 00D30005       213      MOVE.B #$20,DUART_CRA
0000003E  4E71                     214      NOP
00000040  13FC 0010 00D30005       215      MOVE.B #$10,DUART_CRA   
00000048                           216  
00000048  13FC 000A 00D30015       217      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       218      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     219      NOP
0000005A  13FC 0040 00D30015       220      MOVE.B #$40,DUART_CRB           
00000062  4E71                     221      NOP
00000064  13FC 0030 00D30015       222      MOVE.B #$30,DUART_CRB
0000006C  4E71                     223      NOP
0000006E  13FC 0020 00D30015       224      MOVE.B #$20,DUART_CRB
00000076  4E71                     225      NOP
00000078  13FC 0010 00D30015       226      MOVE.B #$10,DUART_CRB   
00000080                           227  
00000080                           228  ;initialise UART
00000080  13FC 0000 00D30009       229      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       230      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       231      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           232  
00000098                           233  ; channel A
00000098  13FC 0013 00D30001       234      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       235      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       236      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       237      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           238  
000000B8                           239  ; channel B
000000B8  13FC 0013 00D30011       240      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       241      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       242      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       243      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           244  
000000D8                           245m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           246m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      247m     IFEQ DEBUG
000000D8  1639 00D30003            248m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                249m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     250m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       251m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           252m     ENDC
000000EC                           253m     
000000EC                 FALSE     254m     IFNE DEBUG
000000EC                           255m     ENDC
000000EC                           256m 
000000EC                           257m     ENDM
000000EC                           258  
000000EC  13FC 0001 00E00001       259      MOVE.B #1,DISPLAY
000000F4                           260         
000000F4                           261m     PRINT_CRLF D3
000000F4                           262mm     PRINT_CHAR #13,D3             ; CR
000000F4                           263mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      264mm     IFEQ DEBUG
000000F4  1639 00D30003            265mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                266mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     267mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       268mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           269mm     ENDC
00000108                           270mm     
00000108                 FALSE     271mm     IFNE DEBUG
00000108                           272mm     ENDC
00000108                           273mm 
00000108                           274mm     ENDM
00000108                           275mm     PRINT_CHAR #10,D3             ; LF
00000108                           276mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      277mm     IFEQ DEBUG
00000108  1639 00D30003            278mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                279mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     280mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       281mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           282mm     ENDC
0000011C                           283mm     
0000011C                 FALSE     284mm     IFNE DEBUG
0000011C                           285mm     ENDC
0000011C                           286mm 
0000011C                           287mm     ENDM
0000011C                           288m     ENDM
0000011C                           289  
0000011C  41F9 000009B0            290      LEA VERSION,A0
00000122                           291m     PRINT_STR A0,D3
00000122                           292m LOOP_5
00000122  0C10 0000                293m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                294m     BEQ EXIT_5
0000012A                           295mm     PRINT_CHAR (A0)+,D3
0000012A                           296mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      297mm     IFEQ DEBUG
0000012A  1639 00D30003            298mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                299mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     300mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            301mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           302mm     ENDC
0000013C                           303mm     
0000013C                 FALSE     304mm     IFNE DEBUG
0000013C                           305mm     ENDC
0000013C                           306mm 
0000013C                           307mm     ENDM
0000013C  4EF8 0122                308m     JMP LOOP_5
00000140                           309m EXIT_5
00000140                           310m     ENDM
00000140                           311m     PRINT_CRLF D3
00000140                           312mm     PRINT_CHAR #13,D3             ; CR
00000140                           313mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      314mm     IFEQ DEBUG
00000140  1639 00D30003            315mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                316mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     317mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       318mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           319mm     ENDC
00000154                           320mm     
00000154                 FALSE     321mm     IFNE DEBUG
00000154                           322mm     ENDC
00000154                           323mm 
00000154                           324mm     ENDM
00000154                           325mm     PRINT_CHAR #10,D3             ; LF
00000154                           326mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      327mm     IFEQ DEBUG
00000154  1639 00D30003            328mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                329mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     330mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       331mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           332mm     ENDC
00000168                           333mm     
00000168                 FALSE     334mm     IFNE DEBUG
00000168                           335mm     ENDC
00000168                           336mm 
00000168                           337mm     ENDM
00000168                           338m     ENDM
00000168                           339m     PRINT_CHAR #7,D3
00000168                           340m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      341m     IFEQ DEBUG
00000168  1639 00D30003            342m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                343m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     344m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       345m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           346m     ENDC
0000017C                           347m     
0000017C                 FALSE     348m     IFNE DEBUG
0000017C                           349m     ENDC
0000017C                           350m 
0000017C                           351m     ENDM
0000017C                           352  
0000017C  7E00                     353      MOVE.L #0,D7                    ; address accumulator
0000017E                           354  
0000017E  13FC 0002 00E00001       355      MOVE.B #2,DISPLAY
00000186                           356  MAIN_LOOP
00000186                           357m     PRINT_CHAR #'>',D3               ; prompt
00000186                           358m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      359m     IFEQ DEBUG
00000186  1639 00D30003            360m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                361m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     362m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       363m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           364m     ENDC
0000019A                           365m     
0000019A                 FALSE     366m     IFNE DEBUG
0000019A                           367m     ENDC
0000019A                           368m 
0000019A                           369m     ENDM
0000019A                           370m     PRINT_CHAR #32,D3                ; space
0000019A                           371m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      372m     IFEQ DEBUG
0000019A  1639 00D30003            373m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                374m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     375m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       376m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           377m     ENDC
000001AE                           378m     
000001AE                 FALSE     379m     IFNE DEBUG
000001AE                           380m     ENDC
000001AE                           381m 
000001AE                           382m     ENDM
000001AE                           383      
000001AE                           384  GET_INPUT
000001AE                           385m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           386m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           387m 
000001AE                 TRUE      388m     IFEQ DEBUG
000001AE  1639 00D30003            389m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                390m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     391m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           392m     ENDC
000001BA                           393m     
000001BA                           394mm     READ_CHAR D2
000001BA                 TRUE      395mm     IFEQ DEBUG
000001BA  1439 00D30007            396mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           397mm     ENDC
000001C0                 FALSE     398mm     IFNE DEBUG
000001C0                           399mm     ENDC
000001C0                           400mm      
000001C0  B43C 001B                401mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                402mm     BEQ START
000001C8                           403mm     ENDM
000001C8                           404m 
000001C8                 TRUE      405m     IFEQ DEBUG
000001C8                           406mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           407mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      408mm     IFEQ DEBUG
000001C8  1639 00D30003            409mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                410mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     411mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            412mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           413mm     ENDC
000001DA                           414mm     
000001DA                 FALSE     415mm     IFNE DEBUG
000001DA                           416mm     ENDC
000001DA                           417mm 
000001DA                           418mm     ENDM
000001DA                           419m     ENDC
000001DA                           420m     ENDM
000001DA                           421      
000001DA  B43C 0030                422      CMP.B #'0',D2
000001DE  6700 07B0                423      BEQ HEX_DIGIT
000001E2  B43C 0031                424      CMP.B #'1',D2
000001E6  6700 07A8                425      BEQ HEX_DIGIT
000001EA  B43C 0032                426      CMP.B #'2',D2
000001EE  6700 07A0                427      BEQ HEX_DIGIT
000001F2  B43C 0033                428      CMP.B #'3',D2
000001F6  6700 0798                429      BEQ HEX_DIGIT
000001FA  B43C 0034                430      CMP.B #'4',D2
000001FE  6700 0790                431      BEQ HEX_DIGIT
00000202  B43C 0035                432      CMP.B #'5',D2
00000206  6700 0788                433      BEQ HEX_DIGIT
0000020A  B43C 0036                434      CMP.B #'6',D2
0000020E  6700 0780                435      BEQ HEX_DIGIT
00000212  B43C 0037                436      CMP.B #'7',D2
00000216  6700 0778                437      BEQ HEX_DIGIT
0000021A  B43C 0038                438      CMP.B #'8',D2
0000021E  6700 0770                439      BEQ HEX_DIGIT
00000222  B43C 0039                440      CMP.B #'9',D2
00000226  6700 0768                441      BEQ HEX_DIGIT
0000022A  B43C 0041                442      CMP.B #'A',D2
0000022E  6700 0760                443      BEQ HEX_DIGIT
00000232  B43C 0042                444      CMP.B #'B',D2
00000236  6700 0758                445      BEQ HEX_DIGIT
0000023A  B43C 0043                446      CMP.B #'C',D2
0000023E  6700 0750                447      BEQ HEX_DIGIT
00000242  B43C 0044                448      CMP.B #'D',D2
00000246  6700 0748                449      BEQ HEX_DIGIT
0000024A  B43C 0045                450      CMP.B #'E',D2
0000024E  6700 0740                451      BEQ HEX_DIGIT
00000252  B43C 0046                452      CMP.B #'F',D2
00000256  6700 0738                453      BEQ HEX_DIGIT
0000025A                           454      
0000025A  B43C 0057                455      CMP.B #'W',D2
0000025E  6700 0128                456      BEQ W
00000262                           457  
00000262                           458m     PRINT_CRLF D3
00000262                           459mm     PRINT_CHAR #13,D3             ; CR
00000262                           460mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      461mm     IFEQ DEBUG
00000262  1639 00D30003            462mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                463mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     464mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       465mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           466mm     ENDC
00000276                           467mm     
00000276                 FALSE     468mm     IFNE DEBUG
00000276                           469mm     ENDC
00000276                           470mm 
00000276                           471mm     ENDM
00000276                           472mm     PRINT_CHAR #10,D3             ; LF
00000276                           473mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      474mm     IFEQ DEBUG
00000276  1639 00D30003            475mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                476mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     477mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       478mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           479mm     ENDC
0000028A                           480mm     
0000028A                 FALSE     481mm     IFNE DEBUG
0000028A                           482mm     ENDC
0000028A                           483mm 
0000028A                           484mm     ENDM
0000028A                           485m     ENDM
0000028A                           486   
0000028A  B43C 003F                487      CMP.B #'?',D2
0000028E  6700 004A                488      BEQ H
00000292                           489  
00000292  B43C 0056                490      CMP.B #'V',D2
00000296  6700 006A                491      BEQ V
0000029A                           492      
0000029A  B43C 0052                493      CMP.B #'R',D2
0000029E  6700 008A                494      BEQ R
000002A2                           495  
000002A2  B43C 0053                496      CMP.B #'S',D2
000002A6  6700 01A6                497      BEQ S
000002AA                           498  
000002AA  B43C 0047                499      CMP.B #'G',D2
000002AE  6700 06D8                500      BEQ G   
000002B2                           501  
000002B2  41F9 00000A37            502      LEA HUH,A0
000002B8                           503m     PRINT_STR A0,D3
000002B8                           504m LOOP_19
000002B8  0C10 0000                505m     CMP.B #0,(A0)                 ; 0 -> DONE
000002BC  6700 0018                506m     BEQ EXIT_19
000002C0                           507mm     PRINT_CHAR (A0)+,D3
000002C0                           508mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      509mm     IFEQ DEBUG
000002C0  1639 00D30003            510mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002C6  0803 0002                511mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002CA  67F4                     512mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002CC  13D8 00D30007            513mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002D2                           514mm     ENDC
000002D2                           515mm     
000002D2                 FALSE     516mm     IFNE DEBUG
000002D2                           517mm     ENDC
000002D2                           518mm 
000002D2                           519mm     ENDM
000002D2  4EF8 02B8                520m     JMP LOOP_19
000002D6                           521m EXIT_19
000002D6                           522m     ENDM
000002D6                           523                         
000002D6  4EF8 0186                524      JMP MAIN_LOOP
000002DA                           525      
000002DA                           526  ; commands
000002DA  41F9 000009CC            527  H   LEA HELP,A0
000002E0                           528m     PRINT_STR A0,D3
000002E0                           529m LOOP_21
000002E0  0C10 0000                530m     CMP.B #0,(A0)                 ; 0 -> DONE
000002E4  6700 0018                531m     BEQ EXIT_21
000002E8                           532mm     PRINT_CHAR (A0)+,D3
000002E8                           533mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      534mm     IFEQ DEBUG
000002E8  1639 00D30003            535mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002EE  0803 0002                536mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002F2  67F4                     537mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002F4  13D8 00D30007            538mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002FA                           539mm     ENDC
000002FA                           540mm     
000002FA                 FALSE     541mm     IFNE DEBUG
000002FA                           542mm     ENDC
000002FA                           543mm 
000002FA                           544mm     ENDM
000002FA  4EF8 02E0                545m     JMP LOOP_21
000002FE                           546m EXIT_21
000002FE                           547m     ENDM
000002FE  4EF8 0186                548      JMP MAIN_LOOP
00000302                           549  
00000302  41F9 000009B0            550  V   LEA VERSION,A0
00000308                           551m     PRINT_STR A0,D3       
00000308                           552m LOOP_23
00000308  0C10 0000                553m     CMP.B #0,(A0)                 ; 0 -> DONE
0000030C  6700 0018                554m     BEQ EXIT_23
00000310                           555mm     PRINT_CHAR (A0)+,D3
00000310                           556mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000310                 TRUE      557mm     IFEQ DEBUG
00000310  1639 00D30003            558mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000316  0803 0002                559mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000031A  67F4                     560mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0000031C  13D8 00D30007            561mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000322                           562mm     ENDC
00000322                           563mm     
00000322                 FALSE     564mm     IFNE DEBUG
00000322                           565mm     ENDC
00000322                           566mm 
00000322                           567mm     ENDM
00000322  4EF8 0308                568m     JMP LOOP_23
00000326                           569m EXIT_23
00000326                           570m     ENDM
00000326  4EF8 0186                571      JMP MAIN_LOOP
0000032A                           572      
0000032A                           573  R   
0000032A  2047                     574      MOVE.L D7,A0                    ; address accumulator -> address register
0000032C  2A10                     575      MOVE.L (A0),D5                  ; read the memory and print it
0000032E                           576m     PRINT_REG D5,D3,D7,D6,A0
0000032E  7C07                     577m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000330                           578m LOOP_25
00000330                           579mm     BIN2HEX D5,D7,A0
00000330  41F9 00000AAC            580mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000336  E99D                     581mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000338  1E05                     582mm   MOVE.B D5,D7
0000033A  0287 0000000F            583mm   ANDI.L #$F,D7
00000340  1E30 7000                584mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000344                           585mm   ENDM
00000344                           586mm     PRINT_CHAR D7,D3
00000344                           587mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      588mm     IFEQ DEBUG
00000344  1639 00D30003            589mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000034A  0803 0002                590mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000034E  67F4                     591mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000350  13C7 00D30007            592mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000356                           593mm     ENDC
00000356                           594mm     
00000356                 FALSE     595mm     IFNE DEBUG
00000356                           596mm     ENDC
00000356                           597mm 
00000356                           598mm     ENDM
00000356  57CE FFD8                599m     DBEQ D6,LOOP_25
0000035A                           600m     ENDM
0000035A                           601m     PRINT_CRLF D3
0000035A                           602mm     PRINT_CHAR #13,D3             ; CR
0000035A                           603mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                 TRUE      604mm     IFEQ DEBUG
0000035A  1639 00D30003            605mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000360  0803 0002                606mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000364  67F4                     607mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000366  13FC 000D 00D30007       608mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000036E                           609mm     ENDC
0000036E                           610mm     
0000036E                 FALSE     611mm     IFNE DEBUG
0000036E                           612mm     ENDC
0000036E                           613mm 
0000036E                           614mm     ENDM
0000036E                           615mm     PRINT_CHAR #10,D3             ; LF
0000036E                           616mm WAIT_FOR_READY_30                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      617mm     IFEQ DEBUG
0000036E  1639 00D30003            618mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000374  0803 0002                619mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000378  67F4                     620mm       BEQ WAIT_FOR_READY_30          ; NO SPACE, CHECK AGAIN
0000037A  13FC 000A 00D30007       621mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000382                           622mm     ENDC
00000382                           623mm     
00000382                 FALSE     624mm     IFNE DEBUG
00000382                           625mm     ENDC
00000382                           626mm 
00000382                           627mm     ENDM
00000382                           628m     ENDM
00000382  7E00                     629      MOVE.L #0,D7                    ; clear the now used address accumulator
00000384  4EF8 0186                630      JMP MAIN_LOOP
00000388                           631  
00000388  7A00                     632  W   MOVE.L #0,D5                    ; D5 will be the value to write            
0000038A                           633  
0000038A                           634m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
0000038A                           635m WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                           636m 
0000038A                 TRUE      637m     IFEQ DEBUG
0000038A  1639 00D30003            638m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000390  0803 0000                639m       BTST #0,D3                    ; CHECK FOR CHARACTER
00000394  67F4                     640m       BEQ WAIT_FOR_READY_31          ; NOTHING, CHECK AGAIN
00000396                           641m     ENDC
00000396                           642m     
00000396                           643mm     READ_CHAR D2
00000396                 TRUE      644mm     IFEQ DEBUG
00000396  1439 00D30007            645mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000039C                           646mm     ENDC
0000039C                 FALSE     647mm     IFNE DEBUG
0000039C                           648mm     ENDC
0000039C                           649mm      
0000039C  B43C 001B                650mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003A0  6700 FC66                651mm     BEQ START
000003A4                           652mm     ENDM
000003A4                           653m 
000003A4                 TRUE      654m     IFEQ DEBUG
000003A4                           655mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003A4                           656mm WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A4                 TRUE      657mm     IFEQ DEBUG
000003A4  1639 00D30003            658mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003AA  0803 0002                659mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003AE  67F4                     660mm       BEQ WAIT_FOR_READY_33          ; NO SPACE, CHECK AGAIN
000003B0  13C2 00D30007            661mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003B6                           662mm     ENDC
000003B6                           663mm     
000003B6                 FALSE     664mm     IFNE DEBUG
000003B6                           665mm     ENDC
000003B6                           666mm 
000003B6                           667mm     ENDM
000003B6                           668m     ENDC
000003B6                           669m     ENDM
000003B6                           670m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003B6  41F9 00000ABC            671m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003BC  0402 0030                672m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C4BC 000000FF            673m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000003C6  1430 2000                674m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000003CA                           675m   ENDM
000003CA  1A02                     676      MOVE.B D2,D5                    ; put at bottom of D5
000003CC                           677  
000003CC  3C3C 0006                678      MOVE #6,D6                      ; 7 bytes left to read
000003D0                           679      
000003D0                           680  READ_DATA_TO_POKE
000003D0  E98D                     681      LSL.L #4,D5                     ; make what we have so far more significant
000003D2                           682m     WAIT_CHAR D2,D3                 ; next character -> D2
000003D2                           683m WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D2                           684m 
000003D2                 TRUE      685m     IFEQ DEBUG
000003D2  1639 00D30003            686m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003D8  0803 0000                687m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003DC  67F4                     688m       BEQ WAIT_FOR_READY_35          ; NOTHING, CHECK AGAIN
000003DE                           689m     ENDC
000003DE                           690m     
000003DE                           691mm     READ_CHAR D2
000003DE                 TRUE      692mm     IFEQ DEBUG
000003DE  1439 00D30007            693mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003E4                           694mm     ENDC
000003E4                 FALSE     695mm     IFNE DEBUG
000003E4                           696mm     ENDC
000003E4                           697mm      
000003E4  B43C 001B                698mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003E8  6700 FC1E                699mm     BEQ START
000003EC                           700mm     ENDM
000003EC                           701m 
000003EC                 TRUE      702m     IFEQ DEBUG
000003EC                           703mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003EC                           704mm WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EC                 TRUE      705mm     IFEQ DEBUG
000003EC  1639 00D30003            706mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003F2  0803 0002                707mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003F6  67F4                     708mm       BEQ WAIT_FOR_READY_37          ; NO SPACE, CHECK AGAIN
000003F8  13C2 00D30007            709mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003FE                           710mm     ENDC
000003FE                           711mm     
000003FE                 FALSE     712mm     IFNE DEBUG
000003FE                           713mm     ENDC
000003FE                           714mm 
000003FE                           715mm     ENDM
000003FE                           716m     ENDC
000003FE                           717m     ENDM
000003FE                           718m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003FE  41F9 00000ABC            719m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000404  0402 0030                720m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000408  C4BC 000000FF            721m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000040E  1430 2000                722m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000412                           723m   ENDM
00000412  8A02                     724      OR.B D2,D5
00000414  023C 00FB                725      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000418  57CE FFB6                726      DBEQ D6,READ_DATA_TO_POKE
0000041C                           727      
0000041C  2047                     728      MOVE.L D7,A0                    ; address accumulator -> address register
0000041E  7E00                     729      MOVE.L #0,D7                    ; clear the now used address accumulator
00000420                           730      
00000420  2082                     731      MOVE.L D2,(A0)                  ; write the data
00000422                           732  
00000422                           733m     PRINT_CRLF D3
00000422                           734mm     PRINT_CHAR #13,D3             ; CR
00000422                           735mm WAIT_FOR_READY_40                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000422                 TRUE      736mm     IFEQ DEBUG
00000422  1639 00D30003            737mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000428  0803 0002                738mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000042C  67F4                     739mm       BEQ WAIT_FOR_READY_40          ; NO SPACE, CHECK AGAIN
0000042E  13FC 000D 00D30007       740mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000436                           741mm     ENDC
00000436                           742mm     
00000436                 FALSE     743mm     IFNE DEBUG
00000436                           744mm     ENDC
00000436                           745mm 
00000436                           746mm     ENDM
00000436                           747mm     PRINT_CHAR #10,D3             ; LF
00000436                           748mm WAIT_FOR_READY_41                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000436                 TRUE      749mm     IFEQ DEBUG
00000436  1639 00D30003            750mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000043C  0803 0002                751mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000440  67F4                     752mm       BEQ WAIT_FOR_READY_41          ; NO SPACE, CHECK AGAIN
00000442  13FC 000A 00D30007       753mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000044A                           754mm     ENDC
0000044A                           755mm     
0000044A                 FALSE     756mm     IFNE DEBUG
0000044A                           757mm     ENDC
0000044A                           758mm 
0000044A                           759mm     ENDM
0000044A                           760m     ENDM
0000044A  4EF8 0186                761      JMP MAIN_LOOP
0000044E                           762  
0000044E                           763  
0000044E  7800                     764  S   MOVE.L #0,D4                    ; count of records read -> D4
00000450                           765  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00000450                           766m     DOWNLOAD D2,D3                  
00000450                           767m WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000450                           768m 
00000450  1639 00D30003            769m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000456  0803 0000                770m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000045A  6700 0010                771m     BEQ CONTINUE_42                ; NOTHING, CONTINUE
0000045E                           772m  
0000045E                           773mm     READ_CHAR D2
0000045E                 TRUE      774mm     IFEQ DEBUG
0000045E  1439 00D30007            775mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000464                           776mm     ENDC
00000464                 FALSE     777mm     IFNE DEBUG
00000464                           778mm     ENDC
00000464                           779mm      
00000464  B43C 001B                780mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000468  6700 FB9E                781mm     BEQ START
0000046C                           782mm     ENDM
0000046C                           783m CONTINUE_42
0000046C  1639 00D30013            784m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000472  0803 0000                785m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000476  67D8                     786m     BEQ WAIT_FOR_READY_42        ; NOTHING, CHECK AGAIN
00000478                           787m     
00000478  1439 00D30017            788m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000047E  13C2 00E00001            789m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000484                           790m     
00000484                           791m     ENDM
00000484  B43C 0053                792      CMP.B #'S',D2                   ; found S?    
00000488  66C6                     793      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
0000048A                           794      
0000048A  5284                     795      ADD.L #1,D4                     ; read another S record, increment count
0000048C                           796      
0000048C                           797m     DOWNLOAD D2,D3                  ; read the record digit
0000048C                           798m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048C                           799m 
0000048C  1639 00D30003            800m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000492  0803 0000                801m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000496  6700 0010                802m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
0000049A                           803m  
0000049A                           804mm     READ_CHAR D2
0000049A                 TRUE      805mm     IFEQ DEBUG
0000049A  1439 00D30007            806mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000004A0                           807mm     ENDC
000004A0                 FALSE     808mm     IFNE DEBUG
000004A0                           809mm     ENDC
000004A0                           810mm      
000004A0  B43C 001B                811mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000004A4  6700 FB62                812mm     BEQ START
000004A8                           813mm     ENDM
000004A8                           814m CONTINUE_44
000004A8  1639 00D30013            815m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004AE  0803 0000                816m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004B2  67D8                     817m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004B4                           818m     
000004B4  1439 00D30017            819m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004BA  13C2 00E00001            820m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004C0                           821m     
000004C0                           822m     ENDM
000004C0                           823  
000004C0                           824      IF.B D2 <EQ> #'0' THEN.L        ; header, just ignore it
000004C8  4EF8 0450                825          JMP WAIT_FOR_SRECORD            
000004CC                           826      ENDI
000004CC                           827   
000004CC                           828      IF.B D2 <EQ> #'1' THEN.L        ; 16 bit data record
000004D4  7C00                     829          MOVE.L #0,D6                ; checksum
000004D6                           830      
000004D6  7A00                     831          MOVE.L #0,D5                ; read the 2 digit byte count -> D5
000004D8                           832m         DOWNLOAD D2,D3              
000004D8                           833m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D8                           834m 
000004D8  1639 00D30003            835m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004DE  0803 0000                836m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004E2  6700 0010                837m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004E6                           838m  
000004E6                           839mm     READ_CHAR D2
000004E6                 TRUE      840mm     IFEQ DEBUG
000004E6  1439 00D30007            841mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000004EC                           842mm     ENDC
000004EC                 FALSE     843mm     IFNE DEBUG
000004EC                           844mm     ENDC
000004EC                           845mm      
000004EC  B43C 001B                846mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000004F0  6700 FB16                847mm     BEQ START
000004F4                           848mm     ENDM
000004F4                           849m CONTINUE_46
000004F4  1639 00D30013            850m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004FA  0803 0000                851m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004FE  67D8                     852m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
00000500                           853m     
00000500  1439 00D30017            854m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000506  13C2 00E00001            855m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000050C                           856m     
0000050C                           857m     ENDM
0000050C                           858m         HEX2BIN D2,D2,A0
0000050C  41F9 00000ABC            859m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000512  0402 0030                860m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000516  C4BC 000000FF            861m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000051C  1430 2000                862m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000520                           863m   ENDM
00000520  8A82                     864          OR.L D2,D5
00000522  E98D                     865          LSL.L #4,D5    
00000524                           866m         DOWNLOAD D2,D3
00000524                           867m WAIT_FOR_READY_49                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000524                           868m 
00000524  1639 00D30003            869m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000052A  0803 0000                870m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000052E  6700 0010                871m     BEQ CONTINUE_49                ; NOTHING, CONTINUE
00000532                           872m  
00000532                           873mm     READ_CHAR D2
00000532                 TRUE      874mm     IFEQ DEBUG
00000532  1439 00D30007            875mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000538                           876mm     ENDC
00000538                 FALSE     877mm     IFNE DEBUG
00000538                           878mm     ENDC
00000538                           879mm      
00000538  B43C 001B                880mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000053C  6700 FACA                881mm     BEQ START
00000540                           882mm     ENDM
00000540                           883m CONTINUE_49
00000540  1639 00D30013            884m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000546  0803 0000                885m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000054A  67D8                     886m     BEQ WAIT_FOR_READY_49        ; NOTHING, CHECK AGAIN
0000054C                           887m     
0000054C  1439 00D30017            888m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000552  13C2 00E00001            889m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000558                           890m     
00000558                           891m     ENDM
00000558                           892m         HEX2BIN D2,D2,A0  
00000558  41F9 00000ABC            893m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000055E  0402 0030                894m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000562  C4BC 000000FF            895m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000568  1430 2000                896m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000056C                           897m   ENDM
0000056C  8A82                     898          OR.L D2,D5
0000056E                           899                  
0000056E  DC85                     900          ADD.L D5,D6                 ; add byte count into checksum
00000570                           901  
00000570  7E00                     902          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000572                           903m         DOWNLOAD D2,D3              ; top byte
00000572                           904m WAIT_FOR_READY_52                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000572                           905m 
00000572  1639 00D30003            906m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000578  0803 0000                907m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000057C  6700 0010                908m     BEQ CONTINUE_52                ; NOTHING, CONTINUE
00000580                           909m  
00000580                           910mm     READ_CHAR D2
00000580                 TRUE      911mm     IFEQ DEBUG
00000580  1439 00D30007            912mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000586                           913mm     ENDC
00000586                 FALSE     914mm     IFNE DEBUG
00000586                           915mm     ENDC
00000586                           916mm      
00000586  B43C 001B                917mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000058A  6700 FA7C                918mm     BEQ START
0000058E                           919mm     ENDM
0000058E                           920m CONTINUE_52
0000058E  1639 00D30013            921m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000594  0803 0000                922m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000598  67D8                     923m     BEQ WAIT_FOR_READY_52        ; NOTHING, CHECK AGAIN
0000059A                           924m     
0000059A  1439 00D30017            925m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005A0  13C2 00E00001            926m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005A6                           927m     
000005A6                           928m     ENDM
000005A6                           929m         HEX2BIN D2,D2,A0
000005A6  41F9 00000ABC            930m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005AC  0402 0030                931m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B0  C4BC 000000FF            932m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005B6  1430 2000                933m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005BA                           934m   ENDM
000005BA  8E82                     935          OR.L D2,D7
000005BC  E98F                     936          LSL.L #4,D7
000005BE                           937m         DOWNLOAD D2,D3         
000005BE                           938m WAIT_FOR_READY_55                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005BE                           939m 
000005BE  1639 00D30003            940m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005C4  0803 0000                941m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005C8  6700 0010                942m     BEQ CONTINUE_55                ; NOTHING, CONTINUE
000005CC                           943m  
000005CC                           944mm     READ_CHAR D2
000005CC                 TRUE      945mm     IFEQ DEBUG
000005CC  1439 00D30007            946mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005D2                           947mm     ENDC
000005D2                 FALSE     948mm     IFNE DEBUG
000005D2                           949mm     ENDC
000005D2                           950mm      
000005D2  B43C 001B                951mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005D6  6700 FA30                952mm     BEQ START
000005DA                           953mm     ENDM
000005DA                           954m CONTINUE_55
000005DA  1639 00D30013            955m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005E0  0803 0000                956m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005E4  67D8                     957m     BEQ WAIT_FOR_READY_55        ; NOTHING, CHECK AGAIN
000005E6                           958m     
000005E6  1439 00D30017            959m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005EC  13C2 00E00001            960m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005F2                           961m     
000005F2                           962m     ENDM
000005F2                           963m         HEX2BIN D2,D2,A0
000005F2  41F9 00000ABC            964m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005F8  0402 0030                965m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005FC  C4BC 000000FF            966m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000602  1430 2000                967m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000606                           968m   ENDM
00000606  8E82                     969          OR.L D2,D7
00000608                           970          
00000608  DC87                     971          ADD.L D7,D6                 ; add top byte of address into checksum
0000060A                           972  
0000060A  E98F                     973          LSL.L #4,D7                 ; bottom byte
0000060C                           974m         DOWNLOAD D2,D3
0000060C                           975m WAIT_FOR_READY_58                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060C                           976m 
0000060C  1639 00D30003            977m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000612  0803 0000                978m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000616  6700 0010                979m     BEQ CONTINUE_58                ; NOTHING, CONTINUE
0000061A                           980m  
0000061A                           981mm     READ_CHAR D2
0000061A                 TRUE      982mm     IFEQ DEBUG
0000061A  1439 00D30007            983mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000620                           984mm     ENDC
00000620                 FALSE     985mm     IFNE DEBUG
00000620                           986mm     ENDC
00000620                           987mm      
00000620  B43C 001B                988mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000624  6700 F9E2                989mm     BEQ START
00000628                           990mm     ENDM
00000628                           991m CONTINUE_58
00000628  1639 00D30013            992m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000062E  0803 0000                993m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000632  67D8                     994m     BEQ WAIT_FOR_READY_58        ; NOTHING, CHECK AGAIN
00000634                           995m     
00000634  1439 00D30017            996m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000063A  13C2 00E00001            997m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000640                           998m     
00000640                           999m     ENDM
00000640                          1000m         HEX2BIN D2,D2,A0
00000640  41F9 00000ABC           1001m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000646  0402 0030               1002m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000064A  C4BC 000000FF           1003m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000650  1430 2000               1004m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000654                          1005m   ENDM
00000654  8E82                    1006          OR.L D2,D7
00000656  E98F                    1007          LSL.L #4,D7        
00000658                          1008m         DOWNLOAD D2,D3
00000658                          1009m WAIT_FOR_READY_61                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000658                          1010m 
00000658  1639 00D30003           1011m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000065E  0803 0000               1012m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000662  6700 0010               1013m     BEQ CONTINUE_61                ; NOTHING, CONTINUE
00000666                          1014m  
00000666                          1015mm     READ_CHAR D2
00000666                 TRUE     1016mm     IFEQ DEBUG
00000666  1439 00D30007           1017mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000066C                          1018mm     ENDC
0000066C                 FALSE    1019mm     IFNE DEBUG
0000066C                          1020mm     ENDC
0000066C                          1021mm      
0000066C  B43C 001B               1022mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000670  6700 F996               1023mm     BEQ START
00000674                          1024mm     ENDM
00000674                          1025m CONTINUE_61
00000674  1639 00D30013           1026m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000067A  0803 0000               1027m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000067E  67D8                    1028m     BEQ WAIT_FOR_READY_61        ; NOTHING, CHECK AGAIN
00000680                          1029m     
00000680  1439 00D30017           1030m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000686  13C2 00E00001           1031m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000068C                          1032m     
0000068C                          1033m     ENDM
0000068C                          1034m         HEX2BIN D2,D2,A0
0000068C  41F9 00000ABC           1035m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000692  0402 0030               1036m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000696  C4BC 000000FF           1037m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000069C  1430 2000               1038m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006A0                          1039m   ENDM
000006A0  8E82                    1040          OR.L D2,D7
000006A2                          1041          
000006A2  7400                    1042          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
000006A4  1407                    1043          MOVE.B D7,D2
000006A6  DC82                    1044          ADD.L D2,D6
000006A8                          1045          
000006A8  2247                    1046          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
000006AA                          1047                 
000006AA  5785                    1048          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006AC                          1049          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006B6  5385                    1050              SUB.L #1,D5
000006B8                          1051              
000006B8  7E00                    1052              MOVE.L #0,D7            ; D7 holds the byte
000006BA                          1053              
000006BA                          1054m             DOWNLOAD D2,D3          ; MS 4 bits
000006BA                          1055m WAIT_FOR_READY_64                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BA                          1056m 
000006BA  1639 00D30003           1057m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006C0  0803 0000               1058m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006C4  6700 0010               1059m     BEQ CONTINUE_64                ; NOTHING, CONTINUE
000006C8                          1060m  
000006C8                          1061mm     READ_CHAR D2
000006C8                 TRUE     1062mm     IFEQ DEBUG
000006C8  1439 00D30007           1063mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006CE                          1064mm     ENDC
000006CE                 FALSE    1065mm     IFNE DEBUG
000006CE                          1066mm     ENDC
000006CE                          1067mm      
000006CE  B43C 001B               1068mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006D2  6700 F934               1069mm     BEQ START
000006D6                          1070mm     ENDM
000006D6                          1071m CONTINUE_64
000006D6  1639 00D30013           1072m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006DC  0803 0000               1073m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006E0  67D8                    1074m     BEQ WAIT_FOR_READY_64        ; NOTHING, CHECK AGAIN
000006E2                          1075m     
000006E2  1439 00D30017           1076m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006E8  13C2 00E00001           1077m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006EE                          1078m     
000006EE                          1079m     ENDM
000006EE                          1080m             PRINT_CHAR D2,D3
000006EE                          1081m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006EE                 TRUE     1082m     IFEQ DEBUG
000006EE  1639 00D30003           1083m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000006F4  0803 0002               1084m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000006F8  67F4                    1085m       BEQ WAIT_FOR_READY_66          ; NO SPACE, CHECK AGAIN
000006FA  13C2 00D30007           1086m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000700                          1087m     ENDC
00000700                          1088m     
00000700                 FALSE    1089m     IFNE DEBUG
00000700                          1090m     ENDC
00000700                          1091m 
00000700                          1092m     ENDM
00000700                          1093m             HEX2BIN D2,D2,A0
00000700  41F9 00000ABC           1094m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000706  0402 0030               1095m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070A  C4BC 000000FF           1096m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000710  1430 2000               1097m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000714                          1098m   ENDM
00000714  8E82                    1099              OR.L D2,D7
00000716  E98F                    1100              LSL.L #4,D7
00000718                          1101               
00000718                          1102m             DOWNLOAD D2,D3          ; LS 4 bits    
00000718                          1103m WAIT_FOR_READY_68                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000718                          1104m 
00000718  1639 00D30003           1105m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000071E  0803 0000               1106m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000722  6700 0010               1107m     BEQ CONTINUE_68                ; NOTHING, CONTINUE
00000726                          1108m  
00000726                          1109mm     READ_CHAR D2
00000726                 TRUE     1110mm     IFEQ DEBUG
00000726  1439 00D30007           1111mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000072C                          1112mm     ENDC
0000072C                 FALSE    1113mm     IFNE DEBUG
0000072C                          1114mm     ENDC
0000072C                          1115mm      
0000072C  B43C 001B               1116mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000730  6700 F8D6               1117mm     BEQ START
00000734                          1118mm     ENDM
00000734                          1119m CONTINUE_68
00000734  1639 00D30013           1120m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000073A  0803 0000               1121m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000073E  67D8                    1122m     BEQ WAIT_FOR_READY_68        ; NOTHING, CHECK AGAIN
00000740                          1123m     
00000740  1439 00D30017           1124m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000746  13C2 00E00001           1125m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000074C                          1126m     
0000074C                          1127m     ENDM
0000074C                          1128m             PRINT_CHAR D2,D3
0000074C                          1129m WAIT_FOR_READY_70                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074C                 TRUE     1130m     IFEQ DEBUG
0000074C  1639 00D30003           1131m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000752  0803 0002               1132m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000756  67F4                    1133m       BEQ WAIT_FOR_READY_70          ; NO SPACE, CHECK AGAIN
00000758  13C2 00D30007           1134m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000075E                          1135m     ENDC
0000075E                          1136m     
0000075E                 FALSE    1137m     IFNE DEBUG
0000075E                          1138m     ENDC
0000075E                          1139m 
0000075E                          1140m     ENDM
0000075E                          1141m             HEX2BIN D2,D2,A0
0000075E  41F9 00000ABC           1142m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000764  0402 0030               1143m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000768  C4BC 000000FF           1144m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000076E  1430 2000               1145m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000772                          1146m   ENDM
00000772  8E82                    1147              OR.L D2,D7
00000774                          1148              
00000774  DC87                    1149              ADD.L D7,D6             ; add into checksum            
00000776                          1150          ENDW
0000077A                          1151m         PRINT_CRLF D3
0000077A                          1152mm     PRINT_CHAR #13,D3             ; CR
0000077A                          1153mm WAIT_FOR_READY_73                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000077A                 TRUE     1154mm     IFEQ DEBUG
0000077A  1639 00D30003           1155mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000780  0803 0002               1156mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000784  67F4                    1157mm       BEQ WAIT_FOR_READY_73          ; NO SPACE, CHECK AGAIN
00000786  13FC 000D 00D30007      1158mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000078E                          1159mm     ENDC
0000078E                          1160mm     
0000078E                 FALSE    1161mm     IFNE DEBUG
0000078E                          1162mm     ENDC
0000078E                          1163mm 
0000078E                          1164mm     ENDM
0000078E                          1165mm     PRINT_CHAR #10,D3             ; LF
0000078E                          1166mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078E                 TRUE     1167mm     IFEQ DEBUG
0000078E  1639 00D30003           1168mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000794  0803 0002               1169mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000798  67F4                    1170mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
0000079A  13FC 000A 00D30007      1171mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000007A2                          1172mm     ENDC
000007A2                          1173mm     
000007A2                 FALSE    1174mm     IFNE DEBUG
000007A2                          1175mm     ENDC
000007A2                          1176mm 
000007A2                          1177mm     ENDM
000007A2                          1178m     ENDM
000007A2                          1179          
000007A2  4686                    1180          NOT.L D6                    ; ones complement the checksum
000007A4  0286 000000FF           1181          ANDI.L #$FF,D6              ; and take the LSByte
000007AA                          1182          
000007AA  7E00                    1183          MOVE.L #0,D7                ; read the checksum from the data stream
000007AC                          1184m         DOWNLOAD D2,D3              ; top byte
000007AC                          1185m WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007AC                          1186m 
000007AC  1639 00D30003           1187m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007B2  0803 0000               1188m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007B6  6700 0010               1189m     BEQ CONTINUE_75                ; NOTHING, CONTINUE
000007BA                          1190m  
000007BA                          1191mm     READ_CHAR D2
000007BA                 TRUE     1192mm     IFEQ DEBUG
000007BA  1439 00D30007           1193mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007C0                          1194mm     ENDC
000007C0                 FALSE    1195mm     IFNE DEBUG
000007C0                          1196mm     ENDC
000007C0                          1197mm      
000007C0  B43C 001B               1198mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007C4  6700 F842               1199mm     BEQ START
000007C8                          1200mm     ENDM
000007C8                          1201m CONTINUE_75
000007C8  1639 00D30013           1202m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007CE  0803 0000               1203m     BTST #0,D3                  ; CHECK FOR CHARACTER
000007D2  67D8                    1204m     BEQ WAIT_FOR_READY_75        ; NOTHING, CHECK AGAIN
000007D4                          1205m     
000007D4  1439 00D30017           1206m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000007DA  13C2 00E00001           1207m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000007E0                          1208m     
000007E0                          1209m     ENDM
000007E0                          1210m         HEX2BIN D2,D2,A0
000007E0  41F9 00000ABC           1211m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000007E6  0402 0030               1212m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007EA  C4BC 000000FF           1213m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000007F0  1430 2000               1214m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000007F4                          1215m   ENDM
000007F4  8E82                    1216          OR.L D2,D7
000007F6  E98F                    1217          LSL.L #4,D7
000007F8                          1218m         DOWNLOAD D2,D3             ; bottom byte
000007F8                          1219m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F8                          1220m 
000007F8  1639 00D30003           1221m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007FE  0803 0000               1222m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000802  6700 0010               1223m     BEQ CONTINUE_78                ; NOTHING, CONTINUE
00000806                          1224m  
00000806                          1225mm     READ_CHAR D2
00000806                 TRUE     1226mm     IFEQ DEBUG
00000806  1439 00D30007           1227mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000080C                          1228mm     ENDC
0000080C                 FALSE    1229mm     IFNE DEBUG
0000080C                          1230mm     ENDC
0000080C                          1231mm      
0000080C  B43C 001B               1232mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000810  6700 F7F6               1233mm     BEQ START
00000814                          1234mm     ENDM
00000814                          1235m CONTINUE_78
00000814  1639 00D30013           1236m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000081A  0803 0000               1237m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000081E  67D8                    1238m     BEQ WAIT_FOR_READY_78        ; NOTHING, CHECK AGAIN
00000820                          1239m     
00000820  1439 00D30017           1240m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000826  13C2 00E00001           1241m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000082C                          1242m     
0000082C                          1243m     ENDM
0000082C                          1244m         HEX2BIN D2,D2,A0
0000082C  41F9 00000ABC           1245m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000832  0402 0030               1246m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000836  C4BC 000000FF           1247m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000083C  1430 2000               1248m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000840                          1249m   ENDM
00000840  8E82                    1250          OR.L D2,D7
00000842                          1251                  
00000842                          1252          IF.B D7 <NE> D6 THEN.L
00000848  41F9 00000A86           1253              LEA CS_FAILURE,A0       ; warn for mismatched checksum
0000084E                          1254m             PRINT_STR A0,D3
0000084E                          1255m LOOP_81
0000084E  0C10 0000               1256m     CMP.B #0,(A0)                 ; 0 -> DONE
00000852  6700 0018               1257m     BEQ EXIT_81
00000856                          1258mm     PRINT_CHAR (A0)+,D3
00000856                          1259mm WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000856                 TRUE     1260mm     IFEQ DEBUG
00000856  1639 00D30003           1261mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000085C  0803 0002               1262mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000860  67F4                    1263mm       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00000862  13D8 00D30007           1264mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000868                          1265mm     ENDC
00000868                          1266mm     
00000868                 FALSE    1267mm     IFNE DEBUG
00000868                          1268mm     ENDC
00000868                          1269mm 
00000868                          1270mm     ENDM
00000868  4EF8 084E               1271m     JMP LOOP_81
0000086C                          1272m EXIT_81
0000086C                          1273m     ENDM
0000086C                          1274m             PRINT_REG D4,D3,D6,D7,A0
0000086C  7E07                    1275m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000086E                          1276m LOOP_83
0000086E                          1277mm     BIN2HEX D4,D6,A0
0000086E  41F9 00000AAC           1278mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000874  E99C                    1279mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000876  1C04                    1280mm   MOVE.B D4,D6
00000878  0286 0000000F           1281mm   ANDI.L #$F,D6
0000087E  1C30 6000               1282mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
00000882                          1283mm   ENDM
00000882                          1284mm     PRINT_CHAR D6,D3
00000882                          1285mm WAIT_FOR_READY_85                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000882                 TRUE     1286mm     IFEQ DEBUG
00000882  1639 00D30003           1287mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000888  0803 0002               1288mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000088C  67F4                    1289mm       BEQ WAIT_FOR_READY_85          ; NO SPACE, CHECK AGAIN
0000088E  13C6 00D30007           1290mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00000894                          1291mm     ENDC
00000894                          1292mm     
00000894                 FALSE    1293mm     IFNE DEBUG
00000894                          1294mm     ENDC
00000894                          1295mm 
00000894                          1296mm     ENDM
00000894  57CF FFD8               1297m     DBEQ D7,LOOP_83
00000898                          1298m     ENDM
00000898                          1299m             PRINT_CRLF D3
00000898                          1300mm     PRINT_CHAR #13,D3             ; CR
00000898                          1301mm WAIT_FOR_READY_87                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000898                 TRUE     1302mm     IFEQ DEBUG
00000898  1639 00D30003           1303mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000089E  0803 0002               1304mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008A2  67F4                    1305mm       BEQ WAIT_FOR_READY_87          ; NO SPACE, CHECK AGAIN
000008A4  13FC 000D 00D30007      1306mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000008AC                          1307mm     ENDC
000008AC                          1308mm     
000008AC                 FALSE    1309mm     IFNE DEBUG
000008AC                          1310mm     ENDC
000008AC                          1311mm 
000008AC                          1312mm     ENDM
000008AC                          1313mm     PRINT_CHAR #10,D3             ; LF
000008AC                          1314mm WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AC                 TRUE     1315mm     IFEQ DEBUG
000008AC  1639 00D30003           1316mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008B2  0803 0002               1317mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008B6  67F4                    1318mm       BEQ WAIT_FOR_READY_88          ; NO SPACE, CHECK AGAIN
000008B8  13FC 000A 00D30007      1319mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000008C0                          1320mm     ENDC
000008C0                          1321mm     
000008C0                 FALSE    1322mm     IFNE DEBUG
000008C0                          1323mm     ENDC
000008C0                          1324mm 
000008C0                          1325mm     ENDM
000008C0                          1326m     ENDM
000008C0                          1327          ENDI
000008C0                          1328       
000008C0  4EF8 0450               1329          JMP WAIT_FOR_SRECORD            
000008C4                          1330      ENDI
000008C4                          1331      
000008C4                          1332      IF.B D2 <EQ> #'8' THEN.S        ; termination record, exit
000008CA  4EF9 00000932           1333          JMP DOWNLOAD_DONE
000008D0                          1334      ENDI
000008D0                          1335      
000008D0  41F9 00000A60           1336      LEA UNREC,A0                    ; warn for unrecognised type
000008D6                          1337m     PRINT_STR A0,D3
000008D6                          1338m LOOP_89
000008D6  0C10 0000               1339m     CMP.B #0,(A0)                 ; 0 -> DONE
000008DA  6700 0018               1340m     BEQ EXIT_89
000008DE                          1341mm     PRINT_CHAR (A0)+,D3
000008DE                          1342mm WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DE                 TRUE     1343mm     IFEQ DEBUG
000008DE  1639 00D30003           1344mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008E4  0803 0002               1345mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008E8  67F4                    1346mm       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
000008EA  13D8 00D30007           1347mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000008F0                          1348mm     ENDC
000008F0                          1349mm     
000008F0                 FALSE    1350mm     IFNE DEBUG
000008F0                          1351mm     ENDC
000008F0                          1352mm 
000008F0                          1353mm     ENDM
000008F0  4EF8 08D6               1354m     JMP LOOP_89
000008F4                          1355m EXIT_89
000008F4                          1356m     ENDM
000008F4                          1357m     PRINT_CHAR D2,D3
000008F4                          1358m WAIT_FOR_READY_91                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F4                 TRUE     1359m     IFEQ DEBUG
000008F4  1639 00D30003           1360m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008FA  0803 0002               1361m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008FE  67F4                    1362m       BEQ WAIT_FOR_READY_91          ; NO SPACE, CHECK AGAIN
00000900  13C2 00D30007           1363m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000906                          1364m     ENDC
00000906                          1365m     
00000906                 FALSE    1366m     IFNE DEBUG
00000906                          1367m     ENDC
00000906                          1368m 
00000906                          1369m     ENDM
00000906                          1370m     PRINT_CRLF D3
00000906                          1371mm     PRINT_CHAR #13,D3             ; CR
00000906                          1372mm WAIT_FOR_READY_93                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000906                 TRUE     1373mm     IFEQ DEBUG
00000906  1639 00D30003           1374mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000090C  0803 0002               1375mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000910  67F4                    1376mm       BEQ WAIT_FOR_READY_93          ; NO SPACE, CHECK AGAIN
00000912  13FC 000D 00D30007      1377mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000091A                          1378mm     ENDC
0000091A                          1379mm     
0000091A                 FALSE    1380mm     IFNE DEBUG
0000091A                          1381mm     ENDC
0000091A                          1382mm 
0000091A                          1383mm     ENDM
0000091A                          1384mm     PRINT_CHAR #10,D3             ; LF
0000091A                          1385mm WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000091A                 TRUE     1386mm     IFEQ DEBUG
0000091A  1639 00D30003           1387mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000920  0803 0002               1388mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000924  67F4                    1389mm       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
00000926  13FC 000A 00D30007      1390mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000092E                          1391mm     ENDC
0000092E                          1392mm     
0000092E                 FALSE    1393mm     IFNE DEBUG
0000092E                          1394mm     ENDC
0000092E                          1395mm 
0000092E                          1396mm     ENDM
0000092E                          1397m     ENDM
0000092E                          1398      
0000092E  6600 FB20               1399      BNE WAIT_FOR_SRECORD            ; ignore any other type
00000932                          1400      
00000932                          1401  DOWNLOAD_DONE
00000932                          1402m     PRINT_REG D4,D3,D7,D6,A0        ; print out n Srecords read
00000932  7C07                    1403m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000934                          1404m LOOP_95
00000934                          1405mm     BIN2HEX D4,D7,A0
00000934  41F9 00000AAC           1406mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
0000093A  E99C                    1407mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000093C  1E04                    1408mm   MOVE.B D4,D7
0000093E  0287 0000000F           1409mm   ANDI.L #$F,D7
00000944  1E30 7000               1410mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000948                          1411mm   ENDM
00000948                          1412mm     PRINT_CHAR D7,D3
00000948                          1413mm WAIT_FOR_READY_97                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000948                 TRUE     1414mm     IFEQ DEBUG
00000948  1639 00D30003           1415mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000094E  0803 0002               1416mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000952  67F4                    1417mm       BEQ WAIT_FOR_READY_97          ; NO SPACE, CHECK AGAIN
00000954  13C7 00D30007           1418mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000095A                          1419mm     ENDC
0000095A                          1420mm     
0000095A                 FALSE    1421mm     IFNE DEBUG
0000095A                          1422mm     ENDC
0000095A                          1423mm 
0000095A                          1424mm     ENDM
0000095A  57CE FFD8               1425m     DBEQ D6,LOOP_95
0000095E                          1426m     ENDM
0000095E  41F9 00000A4E           1427      LEA READ,A0
00000964                          1428m     PRINT_STR A0,D3
00000964                          1429m LOOP_98
00000964  0C10 0000               1430m     CMP.B #0,(A0)                 ; 0 -> DONE
00000968  6700 0018               1431m     BEQ EXIT_98
0000096C                          1432mm     PRINT_CHAR (A0)+,D3
0000096C                          1433mm WAIT_FOR_READY_99                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000096C                 TRUE     1434mm     IFEQ DEBUG
0000096C  1639 00D30003           1435mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000972  0803 0002               1436mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000976  67F4                    1437mm       BEQ WAIT_FOR_READY_99          ; NO SPACE, CHECK AGAIN
00000978  13D8 00D30007           1438mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000097E                          1439mm     ENDC
0000097E                          1440mm     
0000097E                 FALSE    1441mm     IFNE DEBUG
0000097E                          1442mm     ENDC
0000097E                          1443mm 
0000097E                          1444mm     ENDM
0000097E  4EF8 0964               1445m     JMP LOOP_98
00000982                          1446m EXIT_98
00000982                          1447m     ENDM
00000982                          1448      
00000982  7E00                    1449      MOVE.L #0,D7                   ; reset address accumulator that we trashed above
00000984                          1450      
00000984  4EF8 0186               1451      JMP MAIN_LOOP
00000988                          1452      
00000988  2047                    1453  G   MOVE.L D7,A0                    ; address accumulator -> address register
0000098A  3E3C 0000               1454      MOVE #0,D7                      ; clear the now used address accumulator
0000098E  4ED0                    1455      JMP (A0)                        ; jump to it!
00000990                          1456          
00000990                          1457  HEX_DIGIT
00000990  E98F                    1458      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000992                          1459m     HEX2BIN D2,D2,A0
00000992  41F9 00000ABC           1460m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000998  0402 0030               1461m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000099C  C4BC 000000FF           1462m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009A2  1430 2000               1463m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009A6                          1464m   ENDM
000009A6  8E02                    1465      OR.B D2,D7  
000009A8  4EF8 01AE               1466      JMP GET_INPUT
000009AC                          1467  
000009AC  FFFF FFFF               1468      SIMHALT                         ; halt simulator
000009B0                          1469  
000009B0                          1470  ; strings
000009B0= 4D 44 46 2D 6D 6F ...   1471  VERSION DC.B 'MDF-mon V1.8 (01/04/2021)',13,10,0
000009CC= 3F 20 48 65 6C 70 ...   1472  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
00000A37= 48 75 68 3F 0D 0A 00    1473  HUH     DC.B 'Huh?',13,10,0
00000A3E= 55 6E 69 6D 70 6C ...   1474  UNIMP   DC.B 'Unimplemented',13,10,0
00000A4E= 20 53 20 72 65 63 ...   1475  READ    DC.B ' S records read',13,10,0
00000A60= 57 41 52 4E 49 4E ...   1476  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00000A86= 57 41 52 4E 49 4E ...   1477  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00000AAC= 30 31 32 33 34 35 ...   1478  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000ABC= 00 01 02 03 04 05 ...   1479  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000AD3= 4F 76 65 72 72 75 ...   1480  OVERRUN DC.B 'Overrun!',0
00000ADC                          1481      
00000ADC                          1482      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         AAC
CONTINUE_42         46C
CONTINUE_44         4A8
CONTINUE_46         4F4
CONTINUE_49         540
CONTINUE_52         58E
CONTINUE_55         5DA
CONTINUE_58         628
CONTINUE_61         674
CONTINUE_64         6D6
CONTINUE_68         734
CONTINUE_75         7C8
CONTINUE_78         814
CS_FAILURE          A86
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8A2
DOWNLOAD_DONE       932
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_19             2D6
EXIT_21             2FE
EXIT_23             326
EXIT_5              140
EXIT_81             86C
EXIT_89             8F4
EXIT_98             982
G                   988
GET_INPUT           1AE
H                   2DA
HELP                9CC
HEX2BIN             12B
HEX2BIN_LUT         ABC
HEX_DIGIT           990
HUH                 A37
LOOP_19             2B8
LOOP_21             2E0
LOOP_23             308
LOOP_25             330
LOOP_5              122
LOOP_81             84E
LOOP_83             86E
LOOP_89             8D6
LOOP_95             934
LOOP_98             964
MAIN_LOOP           186
OVERRUN             AD3
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   32A
READ                A4E
READ_CHAR           759
READ_DATA_TO_POKE   3D0
RRRR                0
S                   44E
START               8
UNIMP               A3E
UNREC               A60
V                   302
VERSION             9B0
W                   388
WAIT_CHAR           5D1
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_11   186
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_17   262
WAIT_FOR_READY_18   276
WAIT_FOR_READY_20   2C0
WAIT_FOR_READY_22   2E8
WAIT_FOR_READY_24   310
WAIT_FOR_READY_27   344
WAIT_FOR_READY_29   35A
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_30   36E
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_33   3A4
WAIT_FOR_READY_35   3D2
WAIT_FOR_READY_37   3EC
WAIT_FOR_READY_4    108
WAIT_FOR_READY_40   422
WAIT_FOR_READY_41   436
WAIT_FOR_READY_42   450
WAIT_FOR_READY_44   48C
WAIT_FOR_READY_46   4D8
WAIT_FOR_READY_49   524
WAIT_FOR_READY_52   572
WAIT_FOR_READY_55   5BE
WAIT_FOR_READY_58   60C
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   658
WAIT_FOR_READY_64   6BA
WAIT_FOR_READY_66   6EE
WAIT_FOR_READY_68   718
WAIT_FOR_READY_70   74C
WAIT_FOR_READY_73   77A
WAIT_FOR_READY_74   78E
WAIT_FOR_READY_75   7AC
WAIT_FOR_READY_78   7F8
WAIT_FOR_READY_8    140
WAIT_FOR_READY_82   856
WAIT_FOR_READY_85   882
WAIT_FOR_READY_87   898
WAIT_FOR_READY_88   8AC
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   8DE
WAIT_FOR_READY_91   8F4
WAIT_FOR_READY_93   906
WAIT_FOR_READY_94   91A
WAIT_FOR_READY_97   948
WAIT_FOR_READY_99   96C
WAIT_FOR_SRECORD    450
_00000000           4CC
_00000001           8C4
_00000002           8C0
_00000003           8D0
_10000000           6AC
_10000001           77A
