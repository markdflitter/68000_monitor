00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 31/03/2021 16:10:50

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000  =00000000                  9  DEBUG               EQU 0
00000000                            10  
00000000                            11  ; constants
00000000  =00E00000                 12  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 13  DISPLAY_            EQU $0
00000000  =00E00001                 14  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            15  
00000000  =00D30000                 16  DUART_BASE          EQU $D30000
00000000  =00000000                 17  DUART_MRA_          EQU $0
00000000  =00000001                 18  DUART_CSRA_         EQU $1
00000000  =00000001                 19  DUART_SRA_          EQU $1
00000000  =00000002                 20  DUART_CRA_          EQU $2
00000000  =00000003                 21  DUART_TXA_          EQU $3
00000000  =00000003                 22  DUART_RXA_          EQU $3
00000000  =00000004                 23  DUART_ACR_          EQU $4
00000000  =00000005                 24  DUART_IMR_          EQU $5
00000000  =00000008                 25  DUART_MRB_          EQU $8
00000000  =00000009                 26  DUART_CSRB_         EQU $9
00000000  =00000009                 27  DUART_SRB_          EQU $9
00000000  =0000000A                 28  DUART_CRB_          EQU $A
00000000  =0000000B                 29  DUART_TXB_          EQU $B
00000000  =0000000B                 30  DUART_RXB_          EQU $B
00000000  =0000000C                 31  DUART_IVR_          EQU $C
00000000  =0000000D                 32  DUART_OPCR_         EQU $D
00000000  =0000000E                 33  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 34  DUART_RESET_OPR_    EQU $F
00000000                            35  RRRR
00000000  =00D30001                 36  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 37  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 38  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 39  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 40  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 41  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            42  
00000000  =00D30011                 43  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 44  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 45  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 46  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 47  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 48  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            49  
00000000  =00D30009                 50  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 51  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 52  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 53  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 54  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 55  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            56  
00000000                            57  ; macros
00000000                            58  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            59  ; the input register is changed during the process
00000000                            60  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            61  BIN2HEX MACRO
00000000                            62    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            63    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            64    MOVE.B \1,\2
00000000                            65    ANDI.L #$F,\2
00000000                            66    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            67    ENDM
00000000                            68  
00000000                            69  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            70  ; the input register is changed during the process
00000000                            71  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            72  HEX2BIN MACRO
00000000                            73    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            74    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            75    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            76    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            77    ENDM
00000000                            78  
00000000                            79  ; send a single char to the serial port
00000000                            80  ; \1 = char to send, \2 = data register to use for status poll
00000000                            81  ; will stamp on D0 and D1 in debug mode
00000000                            82  PRINT_CHAR MACRO
00000000                            83  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            84      IFEQ DEBUG
00000000                            85        MOVE.B DUART_SRA,\2           ; read status register
00000000                            86        BTST #2,\2                    ; check for space to send
00000000                            87        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            88        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            89      ENDC
00000000                            90      
00000000                            91      IFNE DEBUG
00000000                            92        MOVE.B \1,D1
00000000                            93        MOVE.L #6,D0   
00000000                            94        TRAP #15                      ; write to terminal in simulator
00000000                            95      ENDC
00000000                            96  
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send CR,LF to the serial port
00000000                           100  ; \1 = data register to use for status poll
00000000                           101  PRINT_CRLF MACRO                  
00000000                           102      PRINT_CHAR #13,\1             ; CR
00000000                           103      PRINT_CHAR #10,\1             ; LF
00000000                           104      ENDM
00000000                           105  
00000000                           106  ; send C-style, zero terminated string to the serial port
00000000                           107  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           108  PRINT_STR MACRO
00000000                           109  LOOP\@
00000000                           110      CMP.B #0,(\1)                 ; 0 -> done
00000000                           111      BEQ EXIT\@
00000000                           112      PRINT_CHAR (\1)+,\2
00000000                           113      JMP LOOP\@
00000000                           114  EXIT\@
00000000                           115      ENDM
00000000                           116    
00000000                           117  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           118  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           119  PRINT_REG MACRO
00000000                           120      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           121  LOOP\@
00000000                           122      BIN2HEX \1,\3,\5
00000000                           123      PRINT_CHAR \3,\2
00000000                           124      DBEQ \4,LOOP\@
00000000                           125      ENDM
00000000                           126    
00000000                           127  ; wait for a char from the serial port
00000000                           128  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           129  ; will stamp on D0 and D1 in debug mode
00000000                           130  WAIT_CHAR MACRO
00000000                           131  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           132  
00000000                           133      IFEQ DEBUG
00000000                           134        MOVE.B DUART_SRA,\2         ; read status register
00000000                           135        BTST #0,\2                    ; check for character
00000000                           136        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           137      ENDC
00000000                           138      
00000000                           139      READ_CHAR \1
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        PRINT_CHAR \1,\2            ; echo it back
00000000                           143      ENDC
00000000                           144      ENDM
00000000                           145      
00000000                           146  ; read a char from the serial port - assumes that there is one!
00000000                           147  ; \ 1= data register for read char
00000000                           148  ; will stamp on D0 and D1 in debug mode
00000000                           149  READ_CHAR MACRO
00000000                           150      IFEQ DEBUG
00000000                           151        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           152      ENDC
00000000                           153      IFNE DEBUG
00000000                           154        MOVE.L #5,D0    
00000000                           155        TRAP #15                    ; read from keyboard in simulator
00000000                           156        MOVE.L D1,\1
00000000                           157      ENDC
00000000                           158       
00000000                           159      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           160      BEQ START
00000000                           161      ENDM
00000000                           162      
00000000                           163      
00000000                           164  ; read data from the download serial port
00000000                           165  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           166  DOWNLOAD MACRO
00000000                           167  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           168  
00000000                           169      MOVE.B DUART_SRA,\2           ; check for command
00000000                           170      BTST #0,\2                    ; check for character
00000000                           171      BEQ CONTINUE\@               ; nothing, continue
00000000                           172   
00000000                           173      READ_CHAR \1
00000000                           174  CONTINUE\@
00000000                           175      MOVE.B DUART_SRB,\2         ; read status register
00000000                           176      BTST #0,\2                  ; check for character
00000000                           177      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           178      
00000000                           179      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           180      ENDM
00000000                           181  
00000000                           182  
00000000                           183  ; register catalogue
00000000                           184  ; D0 - used for simulator I/O
00000000                           185  ; D1 - used for simulator I/O
00000000                           186  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           187  ; D4 - read character
00000000                           188  ; D5 - data to write / data read / count of Srecords read (reset after)
00000000                           189  ; D6 - working register used in R/W and download
00000000                           190  ; D7 - address accumulator / reset by download
00000000                           191  ; A0 - address of string to print 
00000000                           192  
00000000                           193  ; start vector
00000000                           194      ORG  $0
00000000= 00000000                 195      DC.L $00000000              ; PC
00000004= 00000000                 196      DC.L $00000000              ; SP
00000008                           197      
00000008                           198  ; start of program  
00000008                           199  START
00000008  13FC 0000 00E00001       200      MOVE.B #0,DISPLAY
00000010                           201  
00000010                           202  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       203      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       204      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     205      NOP
00000022  13FC 0040 00D30005       206      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     207      NOP
0000002C  13FC 0030 00D30005       208      MOVE.B #$30,DUART_CRA
00000034  4E71                     209      NOP
00000036  13FC 0020 00D30005       210      MOVE.B #$20,DUART_CRA
0000003E  4E71                     211      NOP
00000040  13FC 0010 00D30005       212      MOVE.B #$10,DUART_CRA   
00000048                           213  
00000048  13FC 000A 00D30015       214      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       215      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     216      NOP
0000005A  13FC 0040 00D30015       217      MOVE.B #$40,DUART_CRB           
00000062  4E71                     218      NOP
00000064  13FC 0030 00D30015       219      MOVE.B #$30,DUART_CRB
0000006C  4E71                     220      NOP
0000006E  13FC 0020 00D30015       221      MOVE.B #$20,DUART_CRB
00000076  4E71                     222      NOP
00000078  13FC 0010 00D30015       223      MOVE.B #$10,DUART_CRB   
00000080                           224  
00000080                           225  ;initialise UART
00000080  13FC 0000 00D30009       226      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       227      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       228      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           229  
00000098                           230  ; channel A
00000098  13FC 0003 00D30001       231      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       232      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
000000A8  13FC 00BB 00D30003       233      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       234      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           235  
000000B8                           236  ; channel B
000000B8  13FC 0013 00D30011       237      MOVE.B #$13,DUART_MRB           ; rts on, no parity, 8 data bits
000000C0  13FC 0047 00D30011       238      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
000000C8  13FC 00BB 00D30013       239      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       240      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           241  
000000D8                           242m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           243m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      244m     IFEQ DEBUG
000000D8  1639 00D30003            245m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                246m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     247m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       248m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           249m     ENDC
000000EC                           250m     
000000EC                 FALSE     251m     IFNE DEBUG
000000EC                           252m     ENDC
000000EC                           253m 
000000EC                           254m     ENDM
000000EC                           255  
000000EC  13FC 0001 00E00001       256      MOVE.B #1,DISPLAY
000000F4                           257         
000000F4                           258m     PRINT_CRLF D3
000000F4                           259mm     PRINT_CHAR #13,D3             ; CR
000000F4                           260mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      261mm     IFEQ DEBUG
000000F4  1639 00D30003            262mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                263mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     264mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       265mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           266mm     ENDC
00000108                           267mm     
00000108                 FALSE     268mm     IFNE DEBUG
00000108                           269mm     ENDC
00000108                           270mm 
00000108                           271mm     ENDM
00000108                           272mm     PRINT_CHAR #10,D3             ; LF
00000108                           273mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      274mm     IFEQ DEBUG
00000108  1639 00D30003            275mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                276mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     277mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       278mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           279mm     ENDC
0000011C                           280mm     
0000011C                 FALSE     281mm     IFNE DEBUG
0000011C                           282mm     ENDC
0000011C                           283mm 
0000011C                           284mm     ENDM
0000011C                           285m     ENDM
0000011C                           286  
0000011C  41F9 00000544            287      LEA VERSION,A0
00000122                           288m     PRINT_STR A0,D3
00000122                           289m LOOP_5
00000122  0C10 0000                290m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                291m     BEQ EXIT_5
0000012A                           292mm     PRINT_CHAR (A0)+,D3
0000012A                           293mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      294mm     IFEQ DEBUG
0000012A  1639 00D30003            295mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                296mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     297mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            298mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           299mm     ENDC
0000013C                           300mm     
0000013C                 FALSE     301mm     IFNE DEBUG
0000013C                           302mm     ENDC
0000013C                           303mm 
0000013C                           304mm     ENDM
0000013C  4EF8 0122                305m     JMP LOOP_5
00000140                           306m EXIT_5
00000140                           307m     ENDM
00000140                           308m     PRINT_CRLF D3
00000140                           309mm     PRINT_CHAR #13,D3             ; CR
00000140                           310mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      311mm     IFEQ DEBUG
00000140  1639 00D30003            312mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                313mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     314mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       315mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           316mm     ENDC
00000154                           317mm     
00000154                 FALSE     318mm     IFNE DEBUG
00000154                           319mm     ENDC
00000154                           320mm 
00000154                           321mm     ENDM
00000154                           322mm     PRINT_CHAR #10,D3             ; LF
00000154                           323mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      324mm     IFEQ DEBUG
00000154  1639 00D30003            325mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                326mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     327mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       328mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           329mm     ENDC
00000168                           330mm     
00000168                 FALSE     331mm     IFNE DEBUG
00000168                           332mm     ENDC
00000168                           333mm 
00000168                           334mm     ENDM
00000168                           335m     ENDM
00000168                           336m     PRINT_CHAR #7,D3
00000168                           337m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      338m     IFEQ DEBUG
00000168  1639 00D30003            339m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                340m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     341m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       342m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           343m     ENDC
0000017C                           344m     
0000017C                 FALSE     345m     IFNE DEBUG
0000017C                           346m     ENDC
0000017C                           347m 
0000017C                           348m     ENDM
0000017C                           349  
0000017C  7E00                     350      MOVE.L #0,D7                    ; address accumulator
0000017E                           351  
0000017E  13FC 0002 00E00001       352      MOVE.B #2,DISPLAY
00000186                           353  MAIN_LOOP
00000186                           354m     PRINT_CHAR #'>',D3               ; prompt
00000186                           355m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      356m     IFEQ DEBUG
00000186  1639 00D30003            357m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                358m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     359m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       360m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           361m     ENDC
0000019A                           362m     
0000019A                 FALSE     363m     IFNE DEBUG
0000019A                           364m     ENDC
0000019A                           365m 
0000019A                           366m     ENDM
0000019A                           367m     PRINT_CHAR #32,D3                ; space
0000019A                           368m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      369m     IFEQ DEBUG
0000019A  1639 00D30003            370m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                371m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     372m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       373m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           374m     ENDC
000001AE                           375m     
000001AE                 FALSE     376m     IFNE DEBUG
000001AE                           377m     ENDC
000001AE                           378m 
000001AE                           379m     ENDM
000001AE                           380      
000001AE                           381  GET_INPUT
000001AE                           382m     WAIT_CHAR D4,D3                  ; fetch character from serial port -> D4
000001AE                           383m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           384m 
000001AE                 TRUE      385m     IFEQ DEBUG
000001AE  1639 00D30003            386m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                387m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     388m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           389m     ENDC
000001BA                           390m     
000001BA                           391mm     READ_CHAR D4
000001BA                 TRUE      392mm     IFEQ DEBUG
000001BA  1839 00D30007            393mm       MOVE.B DUART_RXA,D4         ; GOT A CHARACTER, READ IT
000001C0                           394mm     ENDC
000001C0                 FALSE     395mm     IFNE DEBUG
000001C0                           396mm     ENDC
000001C0                           397mm      
000001C0  B83C 001B                398mm     CMP.B #$1B,D4                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                399mm     BEQ START
000001C8                           400mm     ENDM
000001C8                           401m 
000001C8                 TRUE      402m     IFEQ DEBUG
000001C8                           403mm       PRINT_CHAR D4,D3            ; ECHO IT BACK
000001C8                           404mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      405mm     IFEQ DEBUG
000001C8  1639 00D30003            406mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                407mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     408mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C4 00D30007            409mm       MOVE.B D4,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           410mm     ENDC
000001DA                           411mm     
000001DA                 FALSE     412mm     IFNE DEBUG
000001DA                           413mm     ENDC
000001DA                           414mm 
000001DA                           415mm     ENDM
000001DA                           416m     ENDC
000001DA                           417m     ENDM
000001DA                           418      
000001DA  B83C 0030                419      CMP.B #'0',D4
000001DE  6700 0344                420      BEQ HEX_DIGIT
000001E2  B83C 0031                421      CMP.B #'1',D4
000001E6  6700 033C                422      BEQ HEX_DIGIT
000001EA  B83C 0032                423      CMP.B #'2',D4
000001EE  6700 0334                424      BEQ HEX_DIGIT
000001F2  B83C 0033                425      CMP.B #'3',D4
000001F6  6700 032C                426      BEQ HEX_DIGIT
000001FA  B83C 0034                427      CMP.B #'4',D4
000001FE  6700 0324                428      BEQ HEX_DIGIT
00000202  B83C 0035                429      CMP.B #'5',D4
00000206  6700 031C                430      BEQ HEX_DIGIT
0000020A  B83C 0036                431      CMP.B #'6',D4
0000020E  6700 0314                432      BEQ HEX_DIGIT
00000212  B83C 0037                433      CMP.B #'7',D4
00000216  6700 030C                434      BEQ HEX_DIGIT
0000021A  B83C 0038                435      CMP.B #'8',D4
0000021E  6700 0304                436      BEQ HEX_DIGIT
00000222  B83C 0039                437      CMP.B #'9',D4
00000226  6700 02FC                438      BEQ HEX_DIGIT
0000022A  B83C 0041                439      CMP.B #'A',D4
0000022E  6700 02F4                440      BEQ HEX_DIGIT
00000232  B83C 0042                441      CMP.B #'B',D4
00000236  6700 02EC                442      BEQ HEX_DIGIT
0000023A  B83C 0043                443      CMP.B #'C',D4
0000023E  6700 02E4                444      BEQ HEX_DIGIT
00000242  B83C 0044                445      CMP.B #'D',D4
00000246  6700 02DC                446      BEQ HEX_DIGIT
0000024A  B83C 0045                447      CMP.B #'E',D4
0000024E  6700 02D4                448      BEQ HEX_DIGIT
00000252  B83C 0046                449      CMP.B #'F',D4
00000256  6700 02CC                450      BEQ HEX_DIGIT
0000025A                           451      
0000025A  B83C 0057                452      CMP.B #'W',D4
0000025E  6700 0128                453      BEQ W
00000262                           454  
00000262                           455m     PRINT_CRLF D3
00000262                           456mm     PRINT_CHAR #13,D3             ; CR
00000262                           457mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      458mm     IFEQ DEBUG
00000262  1639 00D30003            459mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                460mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     461mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       462mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           463mm     ENDC
00000276                           464mm     
00000276                 FALSE     465mm     IFNE DEBUG
00000276                           466mm     ENDC
00000276                           467mm 
00000276                           468mm     ENDM
00000276                           469mm     PRINT_CHAR #10,D3             ; LF
00000276                           470mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      471mm     IFEQ DEBUG
00000276  1639 00D30003            472mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                473mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     474mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       475mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           476mm     ENDC
0000028A                           477mm     
0000028A                 FALSE     478mm     IFNE DEBUG
0000028A                           479mm     ENDC
0000028A                           480mm 
0000028A                           481mm     ENDM
0000028A                           482m     ENDM
0000028A                           483   
0000028A  B83C 003F                484      CMP.B #'?',D4
0000028E  6700 004A                485      BEQ H
00000292                           486  
00000292  B83C 0056                487      CMP.B #'V',D4
00000296  6700 006A                488      BEQ V
0000029A                           489      
0000029A  B83C 0052                490      CMP.B #'R',D4
0000029E  6700 008A                491      BEQ R
000002A2                           492  
000002A2  B83C 0053                493      CMP.B #'S',D4
000002A6  6700 01A6                494      BEQ S
000002AA                           495  
000002AA  B83C 0047                496      CMP.B #'G',D4
000002AE  6700 026C                497      BEQ G   
000002B2                           498  
000002B2  41F9 000005CB            499      LEA HUH,A0
000002B8                           500m     PRINT_STR A0,D3
000002B8                           501m LOOP_19
000002B8  0C10 0000                502m     CMP.B #0,(A0)                 ; 0 -> DONE
000002BC  6700 0018                503m     BEQ EXIT_19
000002C0                           504mm     PRINT_CHAR (A0)+,D3
000002C0                           505mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      506mm     IFEQ DEBUG
000002C0  1639 00D30003            507mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002C6  0803 0002                508mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002CA  67F4                     509mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002CC  13D8 00D30007            510mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002D2                           511mm     ENDC
000002D2                           512mm     
000002D2                 FALSE     513mm     IFNE DEBUG
000002D2                           514mm     ENDC
000002D2                           515mm 
000002D2                           516mm     ENDM
000002D2  4EF8 02B8                517m     JMP LOOP_19
000002D6                           518m EXIT_19
000002D6                           519m     ENDM
000002D6                           520                         
000002D6  4EF8 0186                521      JMP MAIN_LOOP
000002DA                           522      
000002DA                           523  ; commands
000002DA  41F9 00000560            524  H   LEA HELP,A0
000002E0                           525m     PRINT_STR A0,D3
000002E0                           526m LOOP_21
000002E0  0C10 0000                527m     CMP.B #0,(A0)                 ; 0 -> DONE
000002E4  6700 0018                528m     BEQ EXIT_21
000002E8                           529mm     PRINT_CHAR (A0)+,D3
000002E8                           530mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      531mm     IFEQ DEBUG
000002E8  1639 00D30003            532mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002EE  0803 0002                533mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002F2  67F4                     534mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002F4  13D8 00D30007            535mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002FA                           536mm     ENDC
000002FA                           537mm     
000002FA                 FALSE     538mm     IFNE DEBUG
000002FA                           539mm     ENDC
000002FA                           540mm 
000002FA                           541mm     ENDM
000002FA  4EF8 02E0                542m     JMP LOOP_21
000002FE                           543m EXIT_21
000002FE                           544m     ENDM
000002FE  4EF8 0186                545      JMP MAIN_LOOP
00000302                           546  
00000302  41F9 00000544            547  V   LEA VERSION,A0
00000308                           548m     PRINT_STR A0,D3       
00000308                           549m LOOP_23
00000308  0C10 0000                550m     CMP.B #0,(A0)                 ; 0 -> DONE
0000030C  6700 0018                551m     BEQ EXIT_23
00000310                           552mm     PRINT_CHAR (A0)+,D3
00000310                           553mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000310                 TRUE      554mm     IFEQ DEBUG
00000310  1639 00D30003            555mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000316  0803 0002                556mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000031A  67F4                     557mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0000031C  13D8 00D30007            558mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000322                           559mm     ENDC
00000322                           560mm     
00000322                 FALSE     561mm     IFNE DEBUG
00000322                           562mm     ENDC
00000322                           563mm 
00000322                           564mm     ENDM
00000322  4EF8 0308                565m     JMP LOOP_23
00000326                           566m EXIT_23
00000326                           567m     ENDM
00000326  4EF8 0186                568      JMP MAIN_LOOP
0000032A                           569      
0000032A                           570  R   
0000032A  2047                     571      MOVE.L D7,A0                    ; address accumulator -> address register
0000032C  2A10                     572      MOVE.L (A0),D5                  ; read the memory and print it
0000032E                           573m     PRINT_REG D5,D3,D7,D6,A0
0000032E  7C07                     574m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000330                           575m LOOP_25
00000330                           576mm     BIN2HEX D5,D7,A0
00000330  41F9 000005F4            577mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000336  E99D                     578mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000338  1E05                     579mm   MOVE.B D5,D7
0000033A  0287 0000000F            580mm   ANDI.L #$F,D7
00000340  1E30 7000                581mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000344                           582mm   ENDM
00000344                           583mm     PRINT_CHAR D7,D3
00000344                           584mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      585mm     IFEQ DEBUG
00000344  1639 00D30003            586mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000034A  0803 0002                587mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000034E  67F4                     588mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000350  13C7 00D30007            589mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000356                           590mm     ENDC
00000356                           591mm     
00000356                 FALSE     592mm     IFNE DEBUG
00000356                           593mm     ENDC
00000356                           594mm 
00000356                           595mm     ENDM
00000356  57CE FFD8                596m     DBEQ D6,LOOP_25
0000035A                           597m     ENDM
0000035A                           598m     PRINT_CRLF D3
0000035A                           599mm     PRINT_CHAR #13,D3             ; CR
0000035A                           600mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                 TRUE      601mm     IFEQ DEBUG
0000035A  1639 00D30003            602mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000360  0803 0002                603mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000364  67F4                     604mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000366  13FC 000D 00D30007       605mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000036E                           606mm     ENDC
0000036E                           607mm     
0000036E                 FALSE     608mm     IFNE DEBUG
0000036E                           609mm     ENDC
0000036E                           610mm 
0000036E                           611mm     ENDM
0000036E                           612mm     PRINT_CHAR #10,D3             ; LF
0000036E                           613mm WAIT_FOR_READY_30                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      614mm     IFEQ DEBUG
0000036E  1639 00D30003            615mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000374  0803 0002                616mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000378  67F4                     617mm       BEQ WAIT_FOR_READY_30          ; NO SPACE, CHECK AGAIN
0000037A  13FC 000A 00D30007       618mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000382                           619mm     ENDC
00000382                           620mm     
00000382                 FALSE     621mm     IFNE DEBUG
00000382                           622mm     ENDC
00000382                           623mm 
00000382                           624mm     ENDM
00000382                           625m     ENDM
00000382  7E00                     626      MOVE.L #0,D7                    ; clear the now used address accumulator
00000384  4EF8 0186                627      JMP MAIN_LOOP
00000388                           628  
00000388  7A00                     629  W   MOVE.L #0,D5                    ; D5 will be the value to write            
0000038A                           630  
0000038A                           631m     WAIT_CHAR D4,D3                 ; read most significant character -> D4
0000038A                           632m WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                           633m 
0000038A                 TRUE      634m     IFEQ DEBUG
0000038A  1639 00D30003            635m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000390  0803 0000                636m       BTST #0,D3                    ; CHECK FOR CHARACTER
00000394  67F4                     637m       BEQ WAIT_FOR_READY_31          ; NOTHING, CHECK AGAIN
00000396                           638m     ENDC
00000396                           639m     
00000396                           640mm     READ_CHAR D4
00000396                 TRUE      641mm     IFEQ DEBUG
00000396  1839 00D30007            642mm       MOVE.B DUART_RXA,D4         ; GOT A CHARACTER, READ IT
0000039C                           643mm     ENDC
0000039C                 FALSE     644mm     IFNE DEBUG
0000039C                           645mm     ENDC
0000039C                           646mm      
0000039C  B83C 001B                647mm     CMP.B #$1B,D4                 ; CHECK FOR ESCAPE AND GO TO START
000003A0  6700 FC66                648mm     BEQ START
000003A4                           649mm     ENDM
000003A4                           650m 
000003A4                 TRUE      651m     IFEQ DEBUG
000003A4                           652mm       PRINT_CHAR D4,D3            ; ECHO IT BACK
000003A4                           653mm WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A4                 TRUE      654mm     IFEQ DEBUG
000003A4  1639 00D30003            655mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003AA  0803 0002                656mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003AE  67F4                     657mm       BEQ WAIT_FOR_READY_33          ; NO SPACE, CHECK AGAIN
000003B0  13C4 00D30007            658mm       MOVE.B D4,DUART_TXA           ; SEND THE NEXT CHARACTER
000003B6                           659mm     ENDC
000003B6                           660mm     
000003B6                 FALSE     661mm     IFNE DEBUG
000003B6                           662mm     ENDC
000003B6                           663mm 
000003B6                           664mm     ENDM
000003B6                           665m     ENDC
000003B6                           666m     ENDM
000003B6                           667m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
000003B6  41F9 00000604            668m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003BC  0404 0030                669m   SUB.B #'0',D4                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C8BC 000000FF            670m   AND.L #$FF,D4                       ; IGNORE THE TOP 3 BYTES
000003C6  1830 4000                671m   MOVE.B 0(A0,D4),D4                  ; USE THAT AS AN INDEX INTO THE LUT      
000003CA                           672m   ENDM
000003CA  1A04                     673      MOVE.B D4,D5                    ; put at bottom of D5
000003CC                           674  
000003CC  3C3C 0006                675      MOVE #6,D6                      ; 7 bytes left to read
000003D0                           676      
000003D0                           677  READ_DATA_TO_POKE
000003D0  E98D                     678      LSL.L #4,D5                     ; make what we have so far more significant
000003D2                           679m     WAIT_CHAR D4,D3                 ; next character -> D4
000003D2                           680m WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D2                           681m 
000003D2                 TRUE      682m     IFEQ DEBUG
000003D2  1639 00D30003            683m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003D8  0803 0000                684m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003DC  67F4                     685m       BEQ WAIT_FOR_READY_35          ; NOTHING, CHECK AGAIN
000003DE                           686m     ENDC
000003DE                           687m     
000003DE                           688mm     READ_CHAR D4
000003DE                 TRUE      689mm     IFEQ DEBUG
000003DE  1839 00D30007            690mm       MOVE.B DUART_RXA,D4         ; GOT A CHARACTER, READ IT
000003E4                           691mm     ENDC
000003E4                 FALSE     692mm     IFNE DEBUG
000003E4                           693mm     ENDC
000003E4                           694mm      
000003E4  B83C 001B                695mm     CMP.B #$1B,D4                 ; CHECK FOR ESCAPE AND GO TO START
000003E8  6700 FC1E                696mm     BEQ START
000003EC                           697mm     ENDM
000003EC                           698m 
000003EC                 TRUE      699m     IFEQ DEBUG
000003EC                           700mm       PRINT_CHAR D4,D3            ; ECHO IT BACK
000003EC                           701mm WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EC                 TRUE      702mm     IFEQ DEBUG
000003EC  1639 00D30003            703mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003F2  0803 0002                704mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003F6  67F4                     705mm       BEQ WAIT_FOR_READY_37          ; NO SPACE, CHECK AGAIN
000003F8  13C4 00D30007            706mm       MOVE.B D4,DUART_TXA           ; SEND THE NEXT CHARACTER
000003FE                           707mm     ENDC
000003FE                           708mm     
000003FE                 FALSE     709mm     IFNE DEBUG
000003FE                           710mm     ENDC
000003FE                           711mm 
000003FE                           712mm     ENDM
000003FE                           713m     ENDC
000003FE                           714m     ENDM
000003FE                           715m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
000003FE  41F9 00000604            716m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000404  0404 0030                717m   SUB.B #'0',D4                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000408  C8BC 000000FF            718m   AND.L #$FF,D4                       ; IGNORE THE TOP 3 BYTES
0000040E  1830 4000                719m   MOVE.B 0(A0,D4),D4                  ; USE THAT AS AN INDEX INTO THE LUT      
00000412                           720m   ENDM
00000412  8A04                     721      OR.B D4,D5
00000414  023C 00FB                722      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000418  57CE FFB6                723      DBEQ D6,READ_DATA_TO_POKE
0000041C                           724      
0000041C  2047                     725      MOVE.L D7,A0                    ; address accumulator -> address register
0000041E  7E00                     726      MOVE.L #0,D7                    ; clear the now used address accumulator
00000420                           727      
00000420  2084                     728      MOVE.L D4,(A0)                  ; write the data
00000422                           729  
00000422                           730m     PRINT_CRLF D3
00000422                           731mm     PRINT_CHAR #13,D3             ; CR
00000422                           732mm WAIT_FOR_READY_40                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000422                 TRUE      733mm     IFEQ DEBUG
00000422  1639 00D30003            734mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000428  0803 0002                735mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000042C  67F4                     736mm       BEQ WAIT_FOR_READY_40          ; NO SPACE, CHECK AGAIN
0000042E  13FC 000D 00D30007       737mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000436                           738mm     ENDC
00000436                           739mm     
00000436                 FALSE     740mm     IFNE DEBUG
00000436                           741mm     ENDC
00000436                           742mm 
00000436                           743mm     ENDM
00000436                           744mm     PRINT_CHAR #10,D3             ; LF
00000436                           745mm WAIT_FOR_READY_41                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000436                 TRUE      746mm     IFEQ DEBUG
00000436  1639 00D30003            747mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000043C  0803 0002                748mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000440  67F4                     749mm       BEQ WAIT_FOR_READY_41          ; NO SPACE, CHECK AGAIN
00000442  13FC 000A 00D30007       750mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000044A                           751mm     ENDC
0000044A                           752mm     
0000044A                 FALSE     753mm     IFNE DEBUG
0000044A                           754mm     ENDC
0000044A                           755mm 
0000044A                           756mm     ENDM
0000044A                           757m     ENDM
0000044A  4EF8 0186                758      JMP MAIN_LOOP
0000044E                           759  
0000044E  7A00                     760  S   MOVE.L #0,D5                    ; count of records read
00000450                           761  WAIT_FOR_SRECORD
00000450                           762m     DOWNLOAD D4,D3
00000450                           763m WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000450                           764m 
00000450  1639 00D30003            765m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000456  0803 0000                766m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000045A  6700 0010                767m     BEQ CONTINUE_42               ; NOTHING, CONTINUE
0000045E                           768m  
0000045E                           769mm     READ_CHAR D4
0000045E                 TRUE      770mm     IFEQ DEBUG
0000045E  1839 00D30007            771mm       MOVE.B DUART_RXA,D4         ; GOT A CHARACTER, READ IT
00000464                           772mm     ENDC
00000464                 FALSE     773mm     IFNE DEBUG
00000464                           774mm     ENDC
00000464                           775mm      
00000464  B83C 001B                776mm     CMP.B #$1B,D4                 ; CHECK FOR ESCAPE AND GO TO START
00000468  6700 FB9E                777mm     BEQ START
0000046C                           778mm     ENDM
0000046C                           779m CONTINUE_42
0000046C  1639 00D30013            780m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000472  0803 0000                781m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000476  67D8                     782m     BEQ WAIT_FOR_READY_42        ; NOTHING, CHECK AGAIN
00000478                           783m     
00000478  1839 00D30017            784m     MOVE.B DUART_RXB,D4         ; GOT A CHARACTER, READ IT
0000047E                           785m     ENDM
0000047E  13C4 00E00001            786      MOVE.B D4,DISPLAY               ; set the display to the byte
00000484  B83C 0053                787      CMP.B #'S',D4
00000488  66C6                     788      BNE WAIT_FOR_SRECORD
0000048A                           789      
0000048A  5285                     790      ADD.L #1,D5                     ; read another Srecord
0000048C                           791      
0000048C                           792m     DOWNLOAD D4,D3
0000048C                           793m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048C                           794m 
0000048C  1639 00D30003            795m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000492  0803 0000                796m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000496  6700 0010                797m     BEQ CONTINUE_44               ; NOTHING, CONTINUE
0000049A                           798m  
0000049A                           799mm     READ_CHAR D4
0000049A                 TRUE      800mm     IFEQ DEBUG
0000049A  1839 00D30007            801mm       MOVE.B DUART_RXA,D4         ; GOT A CHARACTER, READ IT
000004A0                           802mm     ENDC
000004A0                 FALSE     803mm     IFNE DEBUG
000004A0                           804mm     ENDC
000004A0                           805mm      
000004A0  B83C 001B                806mm     CMP.B #$1B,D4                 ; CHECK FOR ESCAPE AND GO TO START
000004A4  6700 FB62                807mm     BEQ START
000004A8                           808mm     ENDM
000004A8                           809m CONTINUE_44
000004A8  1639 00D30013            810m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004AE  0803 0000                811m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004B2  67D8                     812m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004B4                           813m     
000004B4  1839 00D30017            814m     MOVE.B DUART_RXB,D4         ; GOT A CHARACTER, READ IT
000004BA                           815m     ENDM
000004BA  13C4 00E00001            816      MOVE.B D4,DISPLAY               ; set the display to the byte
000004C0  B83C 0038                817      CMP.B #'8',D4                   ; termination record, exit
000004C4  668A                     818      BNE WAIT_FOR_SRECORD
000004C6                           819      
000004C6                           820m     PRINT_REG D5,D3,D7,D6,A0        ; print out n Srecords read
000004C6  7C07                     821m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004C8                           822m LOOP_46
000004C8                           823mm     BIN2HEX D5,D7,A0
000004C8  41F9 000005F4            824mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
000004CE  E99D                     825mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004D0  1E05                     826mm   MOVE.B D5,D7
000004D2  0287 0000000F            827mm   ANDI.L #$F,D7
000004D8  1E30 7000                828mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
000004DC                           829mm   ENDM
000004DC                           830mm     PRINT_CHAR D7,D3
000004DC                           831mm WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DC                 TRUE      832mm     IFEQ DEBUG
000004DC  1639 00D30003            833mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000004E2  0803 0002                834mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000004E6  67F4                     835mm       BEQ WAIT_FOR_READY_48          ; NO SPACE, CHECK AGAIN
000004E8  13C7 00D30007            836mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
000004EE                           837mm     ENDC
000004EE                           838mm     
000004EE                 FALSE     839mm     IFNE DEBUG
000004EE                           840mm     ENDC
000004EE                           841mm 
000004EE                           842mm     ENDM
000004EE  57CE FFD8                843m     DBEQ D6,LOOP_46
000004F2                           844m     ENDM
000004F2  41F9 000005E2            845      LEA READ,A0
000004F8                           846m     PRINT_STR A0,D3
000004F8                           847m LOOP_49
000004F8  0C10 0000                848m     CMP.B #0,(A0)                 ; 0 -> DONE
000004FC  6700 0018                849m     BEQ EXIT_49
00000500                           850mm     PRINT_CHAR (A0)+,D3
00000500                           851mm WAIT_FOR_READY_50                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000500                 TRUE      852mm     IFEQ DEBUG
00000500  1639 00D30003            853mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000506  0803 0002                854mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000050A  67F4                     855mm       BEQ WAIT_FOR_READY_50          ; NO SPACE, CHECK AGAIN
0000050C  13D8 00D30007            856mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000512                           857mm     ENDC
00000512                           858mm     
00000512                 FALSE     859mm     IFNE DEBUG
00000512                           860mm     ENDC
00000512                           861mm 
00000512                           862mm     ENDM
00000512  4EF8 04F8                863m     JMP LOOP_49
00000516                           864m EXIT_49
00000516                           865m     ENDM
00000516                           866      
00000516  7E00                     867      MOVE.L #0,D7                   ; reset address accumulator that we trashed above
00000518                           868      
00000518  4EF8 0186                869      JMP MAIN_LOOP
0000051C                           870      
0000051C  2047                     871  G   MOVE.L D7,A0                    ; address accumulator -> address register
0000051E  3E3C 0000                872      MOVE #0,D7                      ; clear the now used address accumulator
00000522  4ED0                     873      JMP (A0)                        ; jump to it!
00000524                           874          
00000524                           875  HEX_DIGIT
00000524  E98F                     876      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000526                           877m     HEX2BIN D4,D4,A0
00000526  41F9 00000604            878m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000052C  0404 0030                879m   SUB.B #'0',D4                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000530  C8BC 000000FF            880m   AND.L #$FF,D4                       ; IGNORE THE TOP 3 BYTES
00000536  1830 4000                881m   MOVE.B 0(A0,D4),D4                  ; USE THAT AS AN INDEX INTO THE LUT      
0000053A                           882m   ENDM
0000053A  8E04                     883      OR.B D4,D7  
0000053C  4EF8 01AE                884      JMP GET_INPUT
00000540                           885  
00000540  FFFF FFFF                886      SIMHALT                         ; halt simulator
00000544                           887  
00000544                           888  ; strings
00000544= 4D 44 46 2D 6D 6F ...    889  VERSION DC.B 'MDF-mon V1.7 (31/03/2021)',13,10,0
00000560= 3F 20 48 65 6C 70 ...    890  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
000005CB= 48 75 68 3F 0D 0A 00     891  HUH     DC.B 'Huh?',13,10,0
000005D2= 55 6E 69 6D 70 6C ...    892  UNIMP   DC.B 'Unimplemented',13,10,0
000005E2= 20 53 20 72 65 63 ...    893  READ   DC.B ' S records read',13,10,0
000005F4= 30 31 32 33 34 35 ...    894  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000604= 00 01 02 03 04 05 ...    895  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000061B                           896      
0000061B                           897      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         5F4
CONTINUE_42         46C
CONTINUE_44         4A8
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8A2
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_19             2D6
EXIT_21             2FE
EXIT_23             326
EXIT_49             516
EXIT_5              140
G                   51C
GET_INPUT           1AE
H                   2DA
HELP                560
HEX2BIN             12B
HEX2BIN_LUT         604
HEX_DIGIT           524
HUH                 5CB
LOOP_19             2B8
LOOP_21             2E0
LOOP_23             308
LOOP_25             330
LOOP_46             4C8
LOOP_49             4F8
LOOP_5              122
MAIN_LOOP           186
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   32A
READ                5E2
READ_CHAR           759
READ_DATA_TO_POKE   3D0
RRRR                0
S                   44E
START               8
UNIMP               5D2
V                   302
VERSION             544
W                   388
WAIT_CHAR           5D1
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_11   186
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_17   262
WAIT_FOR_READY_18   276
WAIT_FOR_READY_20   2C0
WAIT_FOR_READY_22   2E8
WAIT_FOR_READY_24   310
WAIT_FOR_READY_27   344
WAIT_FOR_READY_29   35A
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_30   36E
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_33   3A4
WAIT_FOR_READY_35   3D2
WAIT_FOR_READY_37   3EC
WAIT_FOR_READY_4    108
WAIT_FOR_READY_40   422
WAIT_FOR_READY_41   436
WAIT_FOR_READY_42   450
WAIT_FOR_READY_44   48C
WAIT_FOR_READY_48   4DC
WAIT_FOR_READY_50   500
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_8    140
WAIT_FOR_READY_9    154
WAIT_FOR_SRECORD    450
