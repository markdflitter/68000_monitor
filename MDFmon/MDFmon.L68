00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 31/03/2021 11:19:26

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000  =00000000                  9  DEBUG               EQU 0
00000000                            10  
00000000                            11  ; constants
00000000  =00E00000                 12  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 13  DISPLAY_            EQU $0
00000000  =00E00001                 14  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            15  
00000000  =00D30000                 16  DUART_BASE          EQU $D30000
00000000  =00000000                 17  DUART_MRA_          EQU $0
00000000  =00000001                 18  DUART_CSRA_         EQU $1
00000000  =00000001                 19  DUART_SRA_          EQU $1
00000000  =00000002                 20  DUART_CRA_          EQU $2
00000000  =00000003                 21  DUART_TXA_          EQU $3
00000000  =00000003                 22  DUART_RXA_          EQU $3
00000000  =00000004                 23  DUART_ACR_          EQU $4
00000000  =00000005                 24  DUART_IMR_          EQU $5
00000000  =00000008                 25  DUART_MRB_          EQU $8
00000000  =00000009                 26  DUART_CSRB_         EQU $9
00000000  =00000009                 27  DUART_SRB_          EQU $9
00000000  =0000000A                 28  DUART_CRB_          EQU $A
00000000  =0000000B                 29  DUART_TXB_          EQU $B
00000000  =0000000B                 30  DUART_RXB_          EQU $B
00000000  =0000000C                 31  DUART_IVR_          EQU $C
00000000  =0000000D                 32  DUART_OPCR_         EQU $D
00000000  =0000000E                 33  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 34  DUART_RESET_OPR_    EQU $F
00000000                            35  RRRR
00000000  =00D30001                 36  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 37  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 38  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 39  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 40  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 41  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            42  
00000000  =00D30011                 43  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 44  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 45  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 46  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 47  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 48  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            49  
00000000  =00D30009                 50  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 51  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 52  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 53  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 54  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 55  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            56  
00000000                            57  ; macros
00000000                            58  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            59  ; the input register is changed during the process
00000000                            60  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            61  BIN2HEX MACRO
00000000                            62    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            63    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            64    MOVE.B \1,\2
00000000                            65    ANDI.L #$F,\2
00000000                            66    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            67    ENDM
00000000                            68  
00000000                            69  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            70  ; the input register is changed during the process
00000000                            71  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            72  HEX2BIN MACRO
00000000                            73    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            74    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            75    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            76    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            77    ENDM
00000000                            78  
00000000                            79  ; send a single char to the serial port
00000000                            80  ; \1 = char to send, \2 = data register to use for status poll
00000000                            81  ; will stamp on D3 and D2 in debug mode
00000000                            82  PRINT_CHAR MACRO
00000000                            83  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            84      IFEQ DEBUG
00000000                            85        MOVE.B DUART_SRA,\2           ; read status register
00000000                            86        BTST #2,\2                    ; check for space to send
00000000                            87        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            88        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            89      ENDC
00000000                            90      
00000000                            91      IFNE DEBUG
00000000                            92        MOVE.B \1,D1
00000000                            93        MOVE.L #6,D0   
00000000                            94        TRAP #15                      ; write to terminal in simulator
00000000                            95      ENDC
00000000                            96  
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send CR,LF to the serial port
00000000                           100  ; \1 = data register to use for status poll
00000000                           101  PRINT_CRLF MACRO                  
00000000                           102      PRINT_CHAR #13,\1             ; CR
00000000                           103      PRINT_CHAR #10,\1             ; LF
00000000                           104      ENDM
00000000                           105  
00000000                           106  ; send C-style, zero terminated string to the serial port
00000000                           107  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           108  PRINT_STR MACRO
00000000                           109  LOOP\@
00000000                           110      CMP.B #0,(\1)                 ; 0 -> done
00000000                           111      BEQ EXIT\@
00000000                           112      PRINT_CHAR (\1)+,\2
00000000                           113      JMP LOOP\@
00000000                           114  EXIT\@
00000000                           115      ENDM
00000000                           116    
00000000                           117  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           118  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           119  PRINT_REG MACRO
00000000                           120      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           121  LOOP\@
00000000                           122      BIN2HEX \1,\3,\5
00000000                           123      PRINT_CHAR \3,\2
00000000                           124      DBEQ \4,LOOP\@
00000000                           125      ENDM
00000000                           126    
00000000                           127  ; read a char from the serial port
00000000                           128  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           129  ; will stamp on D3 and D2 in debug mode
00000000                           130  READ_CHAR MACRO
00000000                           131  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           132  
00000000                           133      IFEQ DEBUG
00000000                           134        MOVE.B DUART_SRA,\2         ; read status register
00000000                           135        BTST #0,\2                    ; check for character
00000000                           136        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           137      ENDC
00000000                           138  
00000000                           139      IFEQ DEBUG
00000000                           140        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           141      ENDC
00000000                           142      IFNE DEBUG
00000000                           143        MOVE.L #5,D0    
00000000                           144        TRAP #15                    ; read from keyboard in simulator
00000000                           145        MOVE.L D1,\1
00000000                           146      ENDC
00000000                           147       
00000000                           148      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           149      BEQ START
00000000                           150  
00000000                           151      IFEQ DEBUG
00000000                           152        PRINT_CHAR \1,\2            ; echo it back
00000000                           153      ENDC
00000000                           154      ENDM
00000000                           155  
00000000                           156  ; register catalogue
00000000                           157  ; D0 - used for simulator I/O
00000000                           158  ; D1 - used for simulator I/O
00000000                           159  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           160  ; D4 - read character
00000000                           161  ; D5 - data to write / data read
00000000                           162  ; D6 - working register used in R/W
00000000                           163  ; D7 - address accumulator
00000000                           164  ; A0 - address of string to print / address for R or W
00000000                           165  
00000000                           166  ; start vector
00000000                           167      ORG  $0
00000000= 00000000                 168      DC.L $00000000              ; PC
00000004= 00000000                 169      DC.L $00000000              ; SP
00000008                           170      
00000008                           171  ; start of program  
00000008                           172  START
00000008  13FC 0000 00E00001       173      MOVE.B #0,DISPLAY
00000010                           174  
00000010                           175  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       176      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       177      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     178      NOP
00000022  13FC 0040 00D30005       179      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     180      NOP
0000002C  13FC 0030 00D30005       181      MOVE.B #$30,DUART_CRA
00000034  4E71                     182      NOP
00000036  13FC 0020 00D30005       183      MOVE.B #$20,DUART_CRA
0000003E  4E71                     184      NOP
00000040  13FC 0010 00D30005       185      MOVE.B #$10,DUART_CRA   
00000048                           186  
00000048  13FC 000A 00D30015       187      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       188      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     189      NOP
0000005A  13FC 0040 00D30015       190      MOVE.B #$40,DUART_CRB           
00000062  4E71                     191      NOP
00000064  13FC 0030 00D30015       192      MOVE.B #$30,DUART_CRB
0000006C  4E71                     193      NOP
0000006E  13FC 0020 00D30015       194      MOVE.B #$20,DUART_CRB
00000076  4E71                     195      NOP
00000078  13FC 0010 00D30015       196      MOVE.B #$10,DUART_CRB   
00000080                           197  
00000080                           198  ;initialise UART
00000080  13FC 0000 00D30009       199      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       200      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       201      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           202  
00000098                           203  ; channel A
00000098  13FC 0003 00D30001       204      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       205      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
000000A8  13FC 00BB 00D30003       206      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       207      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           208  
000000B8                           209  ; channel B
000000B8  13FC 0003 00D30011       210      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0047 00D30011       211      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
000000C8  13FC 00BB 00D30013       212      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       213      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           214  
000000D8                           215m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000EC                           216  
000000EC  13FC 0001 00E00001       217      MOVE.B #1,DISPLAY
000000F4                           218         
000000F4                           219m     PRINT_CRLF D3
0000011C                           220  
0000011C  41F9 000004A6            221      LEA VERSION,A0
00000122                           222m     PRINT_STR A0,D3
00000140                           223m     PRINT_CRLF D3
00000168                           224m     PRINT_CHAR #7,D3
0000017C                           225  
0000017C  7E00                     226      MOVE.L #0,D7                    ; address accumulator
0000017E                           227  
0000017E  13FC 0002 00E00001       228      MOVE.B #2,DISPLAY
00000186                           229  MAIN_LOOP
00000186                           230m     PRINT_CHAR #'>',D3               ; prompt
0000019A                           231m     PRINT_CHAR #32,D3                ; space
000001AE                           232      
000001AE                           233  GET_INPUT
000001AE                           234m     READ_CHAR D4,D3                  ; fetch character from serial port -> D4
000001DA                           235      
000001DA  B83C 0030                236      CMP.B #'0',D4
000001DE  6700 02A6                237      BEQ HEX_DIGIT
000001E2  B83C 0031                238      CMP.B #'1',D4
000001E6  6700 029E                239      BEQ HEX_DIGIT
000001EA  B83C 0032                240      CMP.B #'2',D4
000001EE  6700 0296                241      BEQ HEX_DIGIT
000001F2  B83C 0033                242      CMP.B #'3',D4
000001F6  6700 028E                243      BEQ HEX_DIGIT
000001FA  B83C 0034                244      CMP.B #'4',D4
000001FE  6700 0286                245      BEQ HEX_DIGIT
00000202  B83C 0035                246      CMP.B #'5',D4
00000206  6700 027E                247      BEQ HEX_DIGIT
0000020A  B83C 0036                248      CMP.B #'6',D4
0000020E  6700 0276                249      BEQ HEX_DIGIT
00000212  B83C 0037                250      CMP.B #'7',D4
00000216  6700 026E                251      BEQ HEX_DIGIT
0000021A  B83C 0038                252      CMP.B #'8',D4
0000021E  6700 0266                253      BEQ HEX_DIGIT
00000222  B83C 0039                254      CMP.B #'9',D4
00000226  6700 025E                255      BEQ HEX_DIGIT
0000022A  B83C 0041                256      CMP.B #'A',D4
0000022E  6700 0256                257      BEQ HEX_DIGIT
00000232  B83C 0042                258      CMP.B #'B',D4
00000236  6700 024E                259      BEQ HEX_DIGIT
0000023A  B83C 0043                260      CMP.B #'C',D4
0000023E  6700 0246                261      BEQ HEX_DIGIT
00000242  B83C 0044                262      CMP.B #'D',D4
00000246  6700 023E                263      BEQ HEX_DIGIT
0000024A  B83C 0045                264      CMP.B #'E',D4
0000024E  6700 0236                265      BEQ HEX_DIGIT
00000252  B83C 0046                266      CMP.B #'F',D4
00000256  6700 022E                267      BEQ HEX_DIGIT
0000025A                           268      
0000025A  B83C 0057                269      CMP.B #'W',D4
0000025E  6700 0128                270      BEQ W
00000262                           271  
00000262                           272m     PRINT_CRLF D3
0000028A                           273   
0000028A  B83C 003F                274      CMP.B #'?',D4
0000028E  6700 004A                275      BEQ H
00000292                           276  
00000292  B83C 0056                277      CMP.B #'V',D4
00000296  6700 006A                278      BEQ V
0000029A                           279      
0000029A  B83C 0052                280      CMP.B #'R',D4
0000029E  6700 008A                281      BEQ R
000002A2                           282  
000002A2  B83C 0053                283      CMP.B #'S',D4
000002A6  6700 01A6                284      BEQ S
000002AA                           285  
000002AA  B83C 0047                286      CMP.B #'G',D4
000002AE  6700 01CE                287      BEQ G   
000002B2                           288  
000002B2  41F9 0000052D            289      LEA HUH,A0
000002B8                           290m     PRINT_STR A0,D3
000002D6                           291                         
000002D6  4EF8 0186                292      JMP MAIN_LOOP
000002DA                           293      
000002DA                           294  ; commands
000002DA  41F9 000004C2            295  H   LEA HELP,A0
000002E0                           296m     PRINT_STR A0,D3
000002FE  4EF8 0186                297      JMP MAIN_LOOP
00000302                           298  
00000302  41F9 000004A6            299  V   LEA VERSION,A0
00000308                           300m     PRINT_STR A0,D3       
00000326  4EF8 0186                301      JMP MAIN_LOOP
0000032A                           302      
0000032A                           303  R   
0000032A  2047                     304      MOVE.L D7,A0                    ; address accumulator -> address register
0000032C  2A10                     305      MOVE.L (A0),D5                  ; read the memory and print it
0000032E                           306m     PRINT_REG D5,D3,D7,D6,A0
0000035A                           307m     PRINT_CRLF D3
00000382  7E00                     308      MOVE.L #0,D7                    ; clear the now used address accumulator
00000384  4EF8 0186                309      JMP MAIN_LOOP
00000388                           310  
00000388  7A00                     311  W   MOVE.L #0,D5                    ; D5 will be the value to write            
0000038A                           312  
0000038A                           313m     READ_CHAR D4,D3                 ; read most significant character -> D4
000003B6                           314m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
000003CA  1A04                     315      MOVE.B D4,D5                    ; put at bottom of D5
000003CC                           316  
000003CC  3C3C 0006                317      MOVE #6,D6                      ; 7 bytes left to read
000003D0                           318      
000003D0                           319  READ_DATA
000003D0  E98D                     320      LSL.L #4,D5                     ; make what we have so far more significant
000003D2                           321m     READ_CHAR D4,D3                 ; next character -> D4
000003FE                           322m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000412  8A04                     323      OR.B D4,D5
00000414  023C 00FB                324      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000418  57CE FFB6                325      DBEQ D6,READ_DATA
0000041C                           326      
0000041C  2047                     327      MOVE.L D7,A0                    ; address accumulator -> address register
0000041E  7E00                     328      MOVE.L #0,D7                    ; clear the now used address accumulator
00000420                           329      
00000420  2084                     330      MOVE.L D4,(A0)                  ; write the data
00000422                           331  
00000422                           332m     PRINT_CRLF D3
0000044A  4EF8 0186                333      JMP MAIN_LOOP
0000044E                           334  
0000044E                           335m S   READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000047A  4EF8 044E                336      JMP S
0000047E                           337  
0000047E  2047                     338  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000480  3E3C 0000                339      MOVE #0,D7                      ; clear the now used address accumulator
00000484  4ED0                     340      JMP (A0)                        ; jump to it!
00000486                           341          
00000486                           342  HEX_DIGIT
00000486  E98F                     343      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000488                           344m     HEX2BIN D4,D4,A0
0000049C  8E04                     345      OR.B D4,D7  
0000049E  4EF8 01AE                346      JMP GET_INPUT
000004A2                           347  
000004A2  FFFF FFFF                348      SIMHALT                         ; halt simulator
000004A6                           349  
000004A6                           350  ; strings
000004A6= 4D 44 46 2D 6D 6F ...    351  VERSION DC.B 'MDF-mon V1.6 (31/03/2021)',13,10,0
000004C2= 3F 20 48 65 6C 70 ...    352  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
0000052D= 48 75 68 3F 0D 0A 00     353  HUH     DC.B 'Huh?',13,10,0
00000534= 55 6E 69 6D 70 6C ...    354  UNIMP   DC.B 'Unimplemented',13,10,0
00000544= 30 31 32 33 34 35 ...    355  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000554= 00 01 02 03 04 05 ...    356  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000056B                           357      
0000056B                           358      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         544
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_18             2D6
EXIT_20             2FE
EXIT_22             326
EXIT_5              140
G                   47E
GET_INPUT           1AE
H                   2DA
HELP                4C2
HEX2BIN             12B
HEX2BIN_LUT         554
HEX_DIGIT           486
HUH                 52D
LOOP_18             2B8
LOOP_20             2E0
LOOP_22             308
LOOP_24             330
LOOP_5              122
MAIN_LOOP           186
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   32A
READ_CHAR           5D1
READ_DATA           3D0
RRRR                0
S                   44E
START               8
UNIMP               534
V                   302
VERSION             4A6
W                   388
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_11   186
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_14   1C8
WAIT_FOR_READY_16   262
WAIT_FOR_READY_17   276
WAIT_FOR_READY_19   2C0
WAIT_FOR_READY_21   2E8
WAIT_FOR_READY_23   310
WAIT_FOR_READY_26   344
WAIT_FOR_READY_28   35A
WAIT_FOR_READY_29   36E
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_30   38A
WAIT_FOR_READY_31   3A4
WAIT_FOR_READY_33   3D2
WAIT_FOR_READY_34   3EC
WAIT_FOR_READY_37   422
WAIT_FOR_READY_38   436
WAIT_FOR_READY_39   44E
WAIT_FOR_READY_4    108
WAIT_FOR_READY_40   468
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_8    140
WAIT_FOR_READY_9    154
