00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 18:31:33

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ORG  $0
00000000                            21      ;ORG  $200000
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF,\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      LEA ox,\5
00000000                           143      PRINT_STR \5,\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  
00000000                           227  ; register catalogue
00000000                           228  ; D0 - used for simulator I/O
00000000                           229  ; D1 - used for simulator I/O
00000000                           230  ; D2 - read character
00000000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           232  ; D6 - working register used in R/W
00000000                           233  ; D7 - address accumulator, reset by download
00000000                           234  ; A0 - address of string to print 
00000000                           235  
00000000                           236  ; start vector
00000000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 238  RESET    DC.L START                             ; RESET
00000008                           239      
00000008                           240  ; start of program  
00000008                           241  START
00000008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00000010                           243  
00000010                           244  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       246      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           247      
00000020                           248      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                249s     MOVE.W  #$50,D1
00000024  6000 000E                250s     BRA _20000001
00000028                           251s _20000000
00000028  13C1 00C00005            252          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     253          NOP
00000030                           254      ENDF
00000030  0441 0010                255s     SUB.W   #$10,D1
00000034                           256s _20000001
00000034  B27C 0010                257s     CMP.W   #$10,D1
00000038  6CEE                     258s     BGE _20000000
0000003A                           259  
0000003A                           260      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                261s     MOVE.W  #$50,D1
0000003E  6000 000E                262s     BRA _20000003
00000042                           263s _20000002
00000042  13C1 00C00015            264          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     265          NOP
0000004A                           266      ENDF
0000004A  0441 0010                267s     SUB.W   #$10,D1
0000004E                           268s _20000003
0000004E  B27C 0010                269s     CMP.W   #$10,D1
00000052  6CEE                     270s     BGE _20000002
00000054                           271    
00000054                           272  ;initialise UART
00000054  13FC 0000 00C00009       273      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       274      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       275      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           276  
0000006C                           277  ; channel A
0000006C  13FC 0013 00C00001       278      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       279      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       280      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       281      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           282  
0000008C                           283  ; channel B
0000008C  13FC 0013 00C00011       284      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       285      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       286      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       287      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           288  
000000AC                           289m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000AC                           290m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      291m     IFEQ DEBUG
000000AC  1639 00C00003            292m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000B2  0803 0002                293m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000B6  67F4                     294m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000B8  13F8 002E 00C00007       295m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000C0                           296m     ENDC
000000C0                           297m     
000000C0                 FALSE     298m     IFNE DEBUG
000000C0                           299m     ENDC
000000C0                           300m 
000000C0                           301m     ENDM
000000C0                           302  
000000C0  13FC 0001 00E00001       303      MOVE.B #1,DISPLAY
000000C8                           304         
000000C8                           305m     PRINT_CRLF D3,A0
000000C8  41F9 00000E2E            306m     LEA CRLF,A0
000000CE                           307mm     PRINT_STR A0,D3
000000CE                           308mm LOOP_3
000000CE  0C10 0000                309mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000D2  6700 0016                310mm     BEQ EXIT_3
000000D6                           311mmm     PRINT_CHAR (A0)+,D3
000000D6                           312mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D6                 TRUE      313mmm     IFEQ DEBUG
000000D6  1639 00C00003            314mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DC  0803 0002                315mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E0  67F4                     316mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
000000E2  13D8 00C00007            317mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000E8                           318mmm     ENDC
000000E8                           319mmm     
000000E8                 FALSE     320mmm     IFNE DEBUG
000000E8                           321mmm     ENDC
000000E8                           322mmm 
000000E8                           323mmm     ENDM
000000E8  60E4                     324mm     BRA LOOP_3
000000EA                           325mm EXIT_3
000000EA                           326mm     ENDM
000000EA                           327m     ENDM
000000EA                           328  
000000EA  41F9 00000CC2            329      LEA VERSION,A0
000000F0                           330m     PRINT_STR A0,D3
000000F0                           331m LOOP_5
000000F0  0C10 0000                332m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000F4  6700 0016                333m     BEQ EXIT_5
000000F8                           334mm     PRINT_CHAR (A0)+,D3
000000F8                           335mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F8                 TRUE      336mm     IFEQ DEBUG
000000F8  1639 00C00003            337mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FE  0803 0002                338mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000102  67F4                     339mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000104  13D8 00C00007            340mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000010A                           341mm     ENDC
0000010A                           342mm     
0000010A                 FALSE     343mm     IFNE DEBUG
0000010A                           344mm     ENDC
0000010A                           345mm 
0000010A                           346mm     ENDM
0000010A  60E4                     347m     BRA LOOP_5
0000010C                           348m EXIT_5
0000010C                           349m     ENDM
0000010C                           350m     PRINT_CRLF D3,A0
0000010C  41F9 00000E2E            351m     LEA CRLF,A0
00000112                           352mm     PRINT_STR A0,D3
00000112                           353mm LOOP_8
00000112  0C10 0000                354mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000116  6700 0016                355mm     BEQ EXIT_8
0000011A                           356mmm     PRINT_CHAR (A0)+,D3
0000011A                           357mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011A                 TRUE      358mmm     IFEQ DEBUG
0000011A  1639 00C00003            359mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000120  0803 0002                360mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000124  67F4                     361mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000126  13D8 00C00007            362mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000012C                           363mmm     ENDC
0000012C                           364mmm     
0000012C                 FALSE     365mmm     IFNE DEBUG
0000012C                           366mmm     ENDC
0000012C                           367mmm 
0000012C                           368mmm     ENDM
0000012C  60E4                     369mm     BRA LOOP_8
0000012E                           370mm EXIT_8
0000012E                           371mm     ENDM
0000012E                           372m     ENDM
0000012E                           373  
0000012E  7E00                     374      MOVE.L #0,D7                                    ; address accumulator
00000130                           375  
00000130  13FC 0002 00E00001       376      MOVE.B #2,DISPLAY
00000138                           377  MAIN_LOOP
00000138  41F9 00000E31            378      LEA PROMPT,A0
0000013E                           379m     PRINT_STR A0,D3
0000013E                           380m LOOP_10
0000013E  0C10 0000                381m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                382m     BEQ EXIT_10
00000146                           383mm     PRINT_CHAR (A0)+,D3
00000146                           384mm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      385mm     IFEQ DEBUG
00000146  1639 00C00003            386mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                387mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     388mm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            389mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           390mm     ENDC
00000158                           391mm     
00000158                 FALSE     392mm     IFNE DEBUG
00000158                           393mm     ENDC
00000158                           394mm 
00000158                           395mm     ENDM
00000158  60E4                     396m     BRA LOOP_10
0000015A                           397m EXIT_10
0000015A                           398m     ENDM
0000015A                           399      
0000015A                           400  GET_INPUT
0000015A                           401m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015A                           402m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015A                 TRUE      403m     IFEQ DEBUG
0000015A  1639 00C00003            404m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000160  0803 0000                405m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000164  67F4                     406m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000166                           407m     ENDC
00000166                           408m     
00000166                           409mm     READ_CHAR D2
00000166                 TRUE      410mm     IFEQ DEBUG
00000166  1439 00C00007            411mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000016C                           412mm     ENDC
0000016C                 FALSE     413mm     IFNE DEBUG
0000016C                           414mm     ENDC
0000016C                           415mm      
0000016C  B43C 001B                416mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000170  6700 FE96                417mm     BEQ START
00000174                           418mm     ENDM
00000174                           419m 
00000174                 TRUE      420m     IFEQ DEBUG
00000174                           421mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000174                           422mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000174                 TRUE      423mm     IFEQ DEBUG
00000174  1639 00C00003            424mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017A  0803 0002                425mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000017E  67F4                     426mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
00000180  13C2 00C00007            427mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000186                           428mm     ENDC
00000186                           429mm     
00000186                 FALSE     430mm     IFNE DEBUG
00000186                           431mm     ENDC
00000186                           432mm 
00000186                           433mm     ENDM
00000186                           434m     ENDC
00000186                           435m     ENDM
00000186                           436      
00000186                           437      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000186  B43C 0030                438s     CMP.B   #'0',D2
0000018A  6D00 000E                439s     BLT _00000000
0000018E  B43C 0039                440s     CMP.B   #'9',D2
00000192  6E00 0006                441s     BGT _00000000
00000196  6000 0B0A                442          BRA HEX_DIGIT
0000019A                           443      ENDI
0000019A                           444s _00000000
0000019A                           445      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019A  B43C 0041                446s     CMP.B   #'A',D2
0000019E  6D00 000E                447s     BLT _00000001
000001A2  B43C 0046                448s     CMP.B   #'F',D2
000001A6  6E00 0006                449s     BGT _00000001
000001AA  6000 0AF6                450          BRA HEX_DIGIT
000001AE                           451      ENDI
000001AE                           452s _00000001
000001AE                           453          
000001AE  B43C 0077                454      CMP.B #'w',D2
000001B2  6700 012C                455      BEQ W
000001B6                           456      
000001B6  B43C 006C                457      CMP.B #'l',D2
000001BA  6700 09E6                458      BEQ L 
000001BE                           459  
000001BE                           460m     PRINT_CRLF D3,A0
000001BE  41F9 00000E2E            461m     LEA CRLF,A0
000001C4                           462mm     PRINT_STR A0,D3
000001C4                           463mm LOOP_16
000001C4  0C10 0000                464mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001C8  6700 0016                465mm     BEQ EXIT_16
000001CC                           466mmm     PRINT_CHAR (A0)+,D3
000001CC                           467mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CC                 TRUE      468mmm     IFEQ DEBUG
000001CC  1639 00C00003            469mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001D2  0803 0002                470mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D6  67F4                     471mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
000001D8  13D8 00C00007            472mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001DE                           473mmm     ENDC
000001DE                           474mmm     
000001DE                 FALSE     475mmm     IFNE DEBUG
000001DE                           476mmm     ENDC
000001DE                           477mmm 
000001DE                           478mmm     ENDM
000001DE  60E4                     479mm     BRA LOOP_16
000001E0                           480mm EXIT_16
000001E0                           481mm     ENDM
000001E0                           482m     ENDM
000001E0                           483   
000001E0  B43C 003F                484      CMP.B #'?',D2
000001E4  6700 0050                485      BEQ H
000001E8                           486   
000001E8  B43C 0076                487      CMP.B #'v',D2
000001EC  6700 0052                488      BEQ V
000001F0                           489      
000001F0  B43C 0072                490      CMP.B #'r',D2
000001F4  6700 0070                491      BEQ R
000001F8                           492  
000001F8  B43C 0073                493      CMP.B #'s',D2
000001FC  6700 015A                494      BEQ S
00000200                           495  
00000200  B43C 0067                496      CMP.B #'g',D2
00000204  6700 08AA                497      BEQ G   
00000208                           498  
00000208  B43C 007A                499      CMP.B #'z',D2
0000020C  6700 08AA                500      BEQ Z   
00000210                           501  
00000210  41F9 00000D8F            502      LEA HUH,A0
00000216                           503m     PRINT_STR A0,D3
00000216                           504m LOOP_18
00000216  0C10 0000                505m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000021A  6700 0016                506m     BEQ EXIT_18
0000021E                           507mm     PRINT_CHAR (A0)+,D3
0000021E                           508mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021E                 TRUE      509mm     IFEQ DEBUG
0000021E  1639 00C00003            510mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000224  0803 0002                511mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000228  67F4                     512mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000022A  13D8 00C00007            513mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000230                           514mm     ENDC
00000230                           515mm     
00000230                 FALSE     516mm     IFNE DEBUG
00000230                           517mm     ENDC
00000230                           518mm 
00000230                           519mm     ENDM
00000230  60E4                     520m     BRA LOOP_18
00000232                           521m EXIT_18
00000232                           522m     ENDM
00000232                           523                         
00000232  6000 FF04                524      BRA MAIN_LOOP
00000236                           525      
00000236                           526  ; commands
00000236                           527  H   
00000236  41F9 00000CDF            528      LEA HELP,A0
0000023C  6000 0008                529      BRA PRINTSTR
00000240                           530  
00000240                           531  V   
00000240  41F9 00000CC2            532      LEA VERSION,A0
00000246                           533  PRINTSTR
00000246                           534m     PRINT_STR A0,D3       
00000246                           535m LOOP_20
00000246  0C10 0000                536m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024A  6700 0016                537m     BEQ EXIT_20
0000024E                           538mm     PRINT_CHAR (A0)+,D3
0000024E                           539mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024E                 TRUE      540mm     IFEQ DEBUG
0000024E  1639 00C00003            541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000254  0803 0002                542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000258  67F4                     543mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000025A  13D8 00C00007            544mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000260                           545mm     ENDC
00000260                           546mm     
00000260                 FALSE     547mm     IFNE DEBUG
00000260                           548mm     ENDC
00000260                           549mm 
00000260                           550mm     ENDM
00000260  60E4                     551m     BRA LOOP_20
00000262                           552m EXIT_20
00000262                           553m     ENDM
00000262  6000 FED4                554      BRA MAIN_LOOP
00000266                           555      
00000266                           556  R   
00000266  2047                     557      MOVE.L D7,A0                                    ; address accumulator -> address register
00000268  7E00                     558      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000026A  2410                     559      MOVE.L (A0),D2                                  ; read the memory and print it
0000026C                           560m     PRINT_REG D2,D3,D4,D5,A0
0000026C  41F9 00000E34            561m     LEA OX,A0
00000272                           562mm     PRINT_STR A0,D3
00000272                           563mm LOOP_23
00000272  0C10 0000                564mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000276  6700 0016                565mm     BEQ EXIT_23
0000027A                           566mmm     PRINT_CHAR (A0)+,D3
0000027A                           567mmm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027A                 TRUE      568mmm     IFEQ DEBUG
0000027A  1639 00C00003            569mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000280  0803 0002                570mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000284  67F4                     571mmm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000286  13D8 00C00007            572mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028C                           573mmm     ENDC
0000028C                           574mmm     
0000028C                 FALSE     575mmm     IFNE DEBUG
0000028C                           576mmm     ENDC
0000028C                           577mmm 
0000028C                           578mmm     ENDM
0000028C  60E4                     579mm     BRA LOOP_23
0000028E                           580mm EXIT_23
0000028E                           581mm     ENDM
0000028E  7A07                     582m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000290                           583m LOOP_22
00000290                           584mm     BIN2HEX D2,D4,A0
00000290  41F9 00000DF3            585mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000296  E99A                     586mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000298  1802                     587mm     MOVE.B D2,D4
0000029A  0284 0000000F            588mm     ANDI.L #$F,D4
000002A0  1830 4000                589mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
000002A4                           590mm     ENDM
000002A4                           591mm     PRINT_CHAR D4,D3
000002A4                           592mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002A4                 TRUE      593mm     IFEQ DEBUG
000002A4  1639 00C00003            594mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002AA  0803 0002                595mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002AE  67F4                     596mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002B0  13C4 00C00007            597mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002B6                           598mm     ENDC
000002B6                           599mm     
000002B6                 FALSE     600mm     IFNE DEBUG
000002B6                           601mm     ENDC
000002B6                           602mm 
000002B6                           603mm     ENDM
000002B6  57CD FFD8                604m     DBEQ D5,LOOP_22
000002BA                           605m     ENDM
000002BA                           606m     PRINT_CRLF D3,A0
000002BA  41F9 00000E2E            607m     LEA CRLF,A0
000002C0                           608mm     PRINT_STR A0,D3
000002C0                           609mm LOOP_28
000002C0  0C10 0000                610mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002C4  6700 0016                611mm     BEQ EXIT_28
000002C8                           612mmm     PRINT_CHAR (A0)+,D3
000002C8                           613mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      614mmm     IFEQ DEBUG
000002C8  1639 00C00003            615mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002CE  0803 0002                616mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D2  67F4                     617mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            618mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002DA                           619mmm     ENDC
000002DA                           620mmm     
000002DA                 FALSE     621mmm     IFNE DEBUG
000002DA                           622mmm     ENDC
000002DA                           623mmm 
000002DA                           624mmm     ENDM
000002DA  60E4                     625mm     BRA LOOP_28
000002DC                           626mm EXIT_28
000002DC                           627mm     ENDM
000002DC                           628m     ENDM
000002DC  6000 FE5A                629      BRA MAIN_LOOP
000002E0                           630  
000002E0                           631  W
000002E0  3C3C 0007                632      MOVE #7,D6                                      ; 7 bytes left to read
000002E4                           633      
000002E4                           634  READ_DATA_TO_POKE
000002E4  E98D                     635      LSL.L #4,D5                                     ; make what we have so far more significant
000002E6                           636m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002E6                           637m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E6                 TRUE      638m     IFEQ DEBUG
000002E6  1639 00C00003            639m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EC  0803 0000                640m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002F0  67F4                     641m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
000002F2                           642m     ENDC
000002F2                           643m     
000002F2                           644mm     READ_CHAR D2
000002F2                 TRUE      645mm     IFEQ DEBUG
000002F2  1439 00C00007            646mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002F8                           647mm     ENDC
000002F8                 FALSE     648mm     IFNE DEBUG
000002F8                           649mm     ENDC
000002F8                           650mm      
000002F8  B43C 001B                651mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002FC  6700 FD0A                652mm     BEQ START
00000300                           653mm     ENDM
00000300                           654m 
00000300                 TRUE      655m     IFEQ DEBUG
00000300                           656mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000300                           657mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000300                 TRUE      658mm     IFEQ DEBUG
00000300  1639 00C00003            659mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000306  0803 0002                660mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000030A  67F4                     661mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
0000030C  13C2 00C00007            662mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000312                           663mm     ENDC
00000312                           664mm     
00000312                 FALSE     665mm     IFNE DEBUG
00000312                           666mm     ENDC
00000312                           667mm 
00000312                           668mm     ENDM
00000312                           669m     ENDC
00000312                           670m     ENDM
00000312                           671m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000312  41F9 00000E03            672m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000318  0402 0030                673m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000031C  C4BC 000000FF            674m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000322  1430 2000                675m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000326                           676m     ENDM
00000326  8A02                     677      OR.B D2,D5
00000328  57CE FFBA                678      DBEQ D6,READ_DATA_TO_POKE
0000032C                           679      
0000032C  2047                     680      MOVE.L D7,A0                                    ; address accumulator -> address register
0000032E  7E00                     681      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000330                           682      
00000330  2085                     683      MOVE.L D5,(A0)                                  ; write the data
00000332                           684  
00000332                           685m     PRINT_CRLF D3,A0
00000332  41F9 00000E2E            686m     LEA CRLF,A0
00000338                           687mm     PRINT_STR A0,D3
00000338                           688mm LOOP_35
00000338  0C10 0000                689mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000033C  6700 0016                690mm     BEQ EXIT_35
00000340                           691mmm     PRINT_CHAR (A0)+,D3
00000340                           692mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000340                 TRUE      693mmm     IFEQ DEBUG
00000340  1639 00C00003            694mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000346  0803 0002                695mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000034A  67F4                     696mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0000034C  13D8 00C00007            697mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000352                           698mmm     ENDC
00000352                           699mmm     
00000352                 FALSE     700mmm     IFNE DEBUG
00000352                           701mmm     ENDC
00000352                           702mmm 
00000352                           703mmm     ENDM
00000352  60E4                     704mm     BRA LOOP_35
00000354                           705mm EXIT_35
00000354                           706mm     ENDM
00000354                           707m     ENDM
00000354  6000 FDE2                708      BRA MAIN_LOOP
00000358                           709  
00000358                           710  ; register map for S
00000358                           711  ; A0 - start address
00000358                           712  ; A1 - offset
00000358                           713  ; A2 - next address to write
00000358                           714  ; A3 - next location (jmp)
00000358                           715  ; A4 - Working Address Register
00000358                           716  ; D0 - record count
00000358                           717  ; D1 - 'S', record type, data byte
00000358                           718  ; D2 - checksum
00000358                           719  ; D3 - data byte count
00000358                           720  ; D4 - read address, moved into A2
00000358                           721  ; D5 - temp
00000358                           722  ; D6 - temp
00000358                           723  ; D7 - temp
00000358                           724  S
00000358  2078 0000                725      MOVE.L 0,A0                                     ; start address -> A0
0000035C  2247                     726      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000035E                           727      
0000035E  7000                     728      MOVE.L #0,D0                                    ; count of records read -> D0
00000360                           729          
00000360                           730  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000360                           731m     DOWNLOAD D1                 
00000360                           732m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000360                           733m 
00000360  1239 00C00003            734m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000366  0801 0000                735m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000036A  6700 0010                736m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
0000036E                           737m  
0000036E                           738mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000036E                 TRUE      739mm     IFEQ DEBUG
0000036E  1239 00C00007            740mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000374                           741mm     ENDC
00000374                 FALSE     742mm     IFNE DEBUG
00000374                           743mm     ENDC
00000374                           744mm      
00000374  B23C 001B                745mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000378  6700 FC8E                746mm     BEQ START
0000037C                           747mm     ENDM
0000037C                           748m CONTINUE_37
0000037C  1239 00C00013            749m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000382  0801 0000                750m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000386  67D8                     751m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
00000388                           752m     
00000388  1239 00C00017            753m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000038E  13C1 00E00001            754m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000394                           755m     
00000394                           756m     ENDM
00000394  B23C 0053                757      CMP.B #'S',D1                                   ; found S?    
00000398  66C6                     758      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000039A                           759      
0000039A                           760m     PRINT_CHAR #'S',D5                            ; print the S
0000039A                           761m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039A                 TRUE      762m     IFEQ DEBUG
0000039A  1A39 00C00003            763m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003A0  0805 0002                764m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003A4  67F4                     765m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003A6  13FC 0053 00C00007       766m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003AE                           767m     ENDC
000003AE                           768m     
000003AE                 FALSE     769m     IFNE DEBUG
000003AE                           770m     ENDC
000003AE                           771m 
000003AE                           772m     ENDM
000003AE  5280                     773      ADD.L #1,D0                                     ; read another S record, increment count
000003B0                           774      
000003B0                           775m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003B0                           776m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B0                           777m 
000003B0  1239 00C00003            778m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003B6  0801 0000                779m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003BA  6700 0010                780m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003BE                           781m  
000003BE                           782mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003BE                 TRUE      783mm     IFEQ DEBUG
000003BE  1239 00C00007            784mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003C4                           785mm     ENDC
000003C4                 FALSE     786mm     IFNE DEBUG
000003C4                           787mm     ENDC
000003C4                           788mm      
000003C4  B23C 001B                789mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003C8  6700 FC3E                790mm     BEQ START
000003CC                           791mm     ENDM
000003CC                           792m CONTINUE_40
000003CC  1239 00C00013            793m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003D2  0801 0000                794m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003D6  67D8                     795m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
000003D8                           796m     
000003D8  1239 00C00017            797m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003DE  13C1 00E00001            798m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003E4                           799m     
000003E4                           800m     ENDM
000003E4                           801m     PRINT_CHAR D1,D5
000003E4                           802m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E4                 TRUE      803m     IFEQ DEBUG
000003E4  1A39 00C00003            804m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003EA  0805 0002                805m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003EE  67F4                     806m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
000003F0  13C1 00C00007            807m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003F6                           808m     ENDC
000003F6                           809m     
000003F6                 FALSE     810m     IFNE DEBUG
000003F6                           811m     ENDC
000003F6                           812m 
000003F6                           813m     ENDM
000003F6                           814  
000003F6  7400                     815      MOVE.L #0,D2                                    ; clear the checksum
000003F8                           816  
000003F8                           817m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003F8  1E3C 0002                818m     MOVE.B #2,D7
000003FC                           819m     WHILE.B D7 <GT> 0 DO
000003FC                           820ms _10000000
000003FC  BE38 0000                821ms     CMP.B   0,D7
00000400  6F00 0064                822ms     BLE _10000001
00000404  E98B                     823m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000406                           824mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000406                           825mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000406                           826mm 
00000406  1A39 00C00003            827mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000040C  0805 0000                828mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000410  6700 0010                829mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000414                           830mm  
00000414                           831mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000414                 TRUE      832mmm     IFEQ DEBUG
00000414  1A39 00C00007            833mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000041A                           834mmm     ENDC
0000041A                 FALSE     835mmm     IFNE DEBUG
0000041A                           836mmm     ENDC
0000041A                           837mmm      
0000041A  BA3C 001B                838mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000041E  6700 FBE8                839mmm     BEQ START
00000422                           840mmm     ENDM
00000422                           841mm CONTINUE_44
00000422  1A39 00C00013            842mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000428  0805 0000                843mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000042C  67D8                     844mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0000042E                           845mm     
0000042E  1A39 00C00017            846mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000434  13C5 00E00001            847mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000043A                           848mm     
0000043A                           849mm     ENDM
0000043A                           850mm         PRINT_CHAR D5,D6
0000043A                           851mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043A                 TRUE      852mm     IFEQ DEBUG
0000043A  1C39 00C00003            853mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000440  0806 0002                854mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000444  67F4                     855mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000446  13C5 00C00007            856mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000044C                           857mm     ENDC
0000044C                           858mm     
0000044C                 FALSE     859mm     IFNE DEBUG
0000044C                           860mm     ENDC
0000044C                           861mm 
0000044C                           862mm     ENDM
0000044C                           863mm         HEX2BIN D5,D5,A4
0000044C  49F9 00000E03            864mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000452  0405 0030                865mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000456  CABC 000000FF            866mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000045C  1A34 5000                867mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000460                           868mm     ENDM
00000460  8605                     869m         OR.B D5,D3
00000462  5307                     870m         SUB.B #1,D7
00000464                           871m     ENDW
00000464  6096                     872ms     BRA _10000000
00000466                           873ms _10000001
00000466                           874m     
00000466  7A00                     875m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000468  1A03                     876m     MOVE.B D3,D5
0000046A  D483                     877m     ADD.L D3,D2
0000046C                           878m 
0000046C                           879m     ENDM
0000046C                           880  
0000046C                           881      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000046C  B23C 0030                882s     CMP.B   #'0',D1
00000470  6600 002C                883s     BNE.L   _00000002
00000474                           884m         PRINT_CRLF D5,A4
00000474  49F9 00000E2E            885m     LEA CRLF,A4
0000047A                           886mm     PRINT_STR A4,D5
0000047A                           887mm LOOP_49
0000047A  0C14 0000                888mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000047E  6700 0016                889mm     BEQ EXIT_49
00000482                           890mmm     PRINT_CHAR (A4)+,D5
00000482                           891mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000482                 TRUE      892mmm     IFEQ DEBUG
00000482  1A39 00C00003            893mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000488  0805 0002                894mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000048C  67F4                     895mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
0000048E  13DC 00C00007            896mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000494                           897mmm     ENDC
00000494                           898mmm     
00000494                 FALSE     899mmm     IFNE DEBUG
00000494                           900mmm     ENDC
00000494                           901mmm 
00000494                           902mmm     ENDM
00000494  60E4                     903mm     BRA LOOP_49
00000496                           904mm EXIT_49
00000496                           905mm     ENDM
00000496                           906m     ENDM
00000496  6000 FEC8                907          BRA WAIT_FOR_SRECORD
0000049A                           908      ELSE
0000049A  6000 03F8                909s     BRA _00000003
0000049E                           910s _00000002
0000049E                           911          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
0000049E  B23C 0031                912s     CMP.B   #'1',D1
000004A2  6708                     913s     BEQ.S   _00000004
000004A4  B23C 0032                914s     CMP.B   #'2',D1
000004A8  6600 01FC                915s     BNE.L   _00000005
000004AC                           916s _00000004
000004AC  5783                     917              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004AE                           918      
000004AE  7800                     919              MOVE.L #0,D4                            ; read two bytes of address
000004B0                           920m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004B0  1E3C 0002                921m     MOVE.B #2,D7
000004B4                           922m     WHILE.B D7 <GT> 0 DO
000004B4                           923ms _10000002
000004B4  BE38 0000                924ms     CMP.B   0,D7
000004B8  6F00 0064                925ms     BLE _10000003
000004BC  E98C                     926m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004BE                           927mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004BE                           928mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                           929mm 
000004BE  1A39 00C00003            930mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004C4  0805 0000                931mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004C8  6700 0010                932mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
000004CC                           933mm  
000004CC                           934mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004CC                 TRUE      935mmm     IFEQ DEBUG
000004CC  1A39 00C00007            936mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004D2                           937mmm     ENDC
000004D2                 FALSE     938mmm     IFNE DEBUG
000004D2                           939mmm     ENDC
000004D2                           940mmm      
000004D2  BA3C 001B                941mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004D6  6700 FB30                942mmm     BEQ START
000004DA                           943mmm     ENDM
000004DA                           944mm CONTINUE_52
000004DA  1A39 00C00013            945mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004E0  0805 0000                946mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004E4  67D8                     947mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
000004E6                           948mm     
000004E6  1A39 00C00017            949mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004EC  13C5 00E00001            950mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004F2                           951mm     
000004F2                           952mm     ENDM
000004F2                           953mm         PRINT_CHAR D5,D6
000004F2                           954mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      955mm     IFEQ DEBUG
000004F2  1C39 00C00003            956mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004F8  0806 0002                957mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004FC  67F4                     958mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
000004FE  13C5 00C00007            959mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000504                           960mm     ENDC
00000504                           961mm     
00000504                 FALSE     962mm     IFNE DEBUG
00000504                           963mm     ENDC
00000504                           964mm 
00000504                           965mm     ENDM
00000504                           966mm         HEX2BIN D5,D5,A4
00000504  49F9 00000E03            967mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000050A  0405 0030                968mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000050E  CABC 000000FF            969mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000514  1A34 5000                970mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000518                           971mm     ENDM
00000518  8805                     972m         OR.B D5,D4
0000051A  5307                     973m         SUB.B #1,D7
0000051C                           974m     ENDW
0000051C  6096                     975ms     BRA _10000002
0000051E                           976ms _10000003
0000051E                           977m     
0000051E  7A00                     978m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000520  1A04                     979m     MOVE.B D4,D5
00000522  D484                     980m     ADD.L D4,D2
00000524                           981m 
00000524                           982m     ENDM
00000524                           983m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000524  1E3C 0002                984m     MOVE.B #2,D7
00000528                           985m     WHILE.B D7 <GT> 0 DO
00000528                           986ms _10000004
00000528  BE38 0000                987ms     CMP.B   0,D7
0000052C  6F00 0064                988ms     BLE _10000005
00000530  E98C                     989m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000532                           990mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000532                           991mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000532                           992mm 
00000532  1A39 00C00003            993mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000538  0805 0000                994mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000053C  6700 0010                995mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000540                           996mm  
00000540                           997mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000540                 TRUE      998mmm     IFEQ DEBUG
00000540  1A39 00C00007            999mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000546                          1000mmm     ENDC
00000546                 FALSE    1001mmm     IFNE DEBUG
00000546                          1002mmm     ENDC
00000546                          1003mmm      
00000546  BA3C 001B               1004mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000054A  6700 FABC               1005mmm     BEQ START
0000054E                          1006mmm     ENDM
0000054E                          1007mm CONTINUE_57
0000054E  1A39 00C00013           1008mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000554  0805 0000               1009mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000558  67D8                    1010mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000055A                          1011mm     
0000055A  1A39 00C00017           1012mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000560  13C5 00E00001           1013mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000566                          1014mm     
00000566                          1015mm     ENDM
00000566                          1016mm         PRINT_CHAR D5,D6
00000566                          1017mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000566                 TRUE     1018mm     IFEQ DEBUG
00000566  1C39 00C00003           1019mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000056C  0806 0002               1020mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000570  67F4                    1021mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
00000572  13C5 00C00007           1022mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000578                          1023mm     ENDC
00000578                          1024mm     
00000578                 FALSE    1025mm     IFNE DEBUG
00000578                          1026mm     ENDC
00000578                          1027mm 
00000578                          1028mm     ENDM
00000578                          1029mm         HEX2BIN D5,D5,A4
00000578  49F9 00000E03           1030mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000057E  0405 0030               1031mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000582  CABC 000000FF           1032mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000588  1A34 5000               1033mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000058C                          1034mm     ENDM
0000058C  8805                    1035m         OR.B D5,D4
0000058E  5307                    1036m         SUB.B #1,D7
00000590                          1037m     ENDW
00000590  6096                    1038ms     BRA _10000004
00000592                          1039ms _10000005
00000592                          1040m     
00000592  7A00                    1041m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000594  1A04                    1042m     MOVE.B D4,D5
00000596  D484                    1043m     ADD.L D4,D2
00000598                          1044m 
00000598                          1045m     ENDM
00000598                          1046              
00000598                          1047              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000598  B23C 0032               1048s     CMP.B   #'2',D1
0000059C  6600 0078               1049s     BNE.L   _00000006
000005A0  5383                    1050                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005A2                          1051m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005A2  1E3C 0002               1052m     MOVE.B #2,D7
000005A6                          1053m     WHILE.B D7 <GT> 0 DO
000005A6                          1054ms _10000006
000005A6  BE38 0000               1055ms     CMP.B   0,D7
000005AA  6F00 0064               1056ms     BLE _10000007
000005AE  E98C                    1057m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005B0                          1058mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005B0                          1059mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                          1060mm 
000005B0  1A39 00C00003           1061mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005B6  0805 0000               1062mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005BA  6700 0010               1063mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005BE                          1064mm  
000005BE                          1065mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005BE                 TRUE     1066mmm     IFEQ DEBUG
000005BE  1A39 00C00007           1067mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005C4                          1068mmm     ENDC
000005C4                 FALSE    1069mmm     IFNE DEBUG
000005C4                          1070mmm     ENDC
000005C4                          1071mmm      
000005C4  BA3C 001B               1072mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005C8  6700 FA3E               1073mmm     BEQ START
000005CC                          1074mmm     ENDM
000005CC                          1075mm CONTINUE_62
000005CC  1A39 00C00013           1076mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005D2  0805 0000               1077mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D6  67D8                    1078mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
000005D8                          1079mm     
000005D8  1A39 00C00017           1080mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005DE  13C5 00E00001           1081mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005E4                          1082mm     
000005E4                          1083mm     ENDM
000005E4                          1084mm         PRINT_CHAR D5,D6
000005E4                          1085mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E4                 TRUE     1086mm     IFEQ DEBUG
000005E4  1C39 00C00003           1087mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005EA  0806 0002               1088mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005EE  67F4                    1089mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
000005F0  13C5 00C00007           1090mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005F6                          1091mm     ENDC
000005F6                          1092mm     
000005F6                 FALSE    1093mm     IFNE DEBUG
000005F6                          1094mm     ENDC
000005F6                          1095mm 
000005F6                          1096mm     ENDM
000005F6                          1097mm         HEX2BIN D5,D5,A4
000005F6  49F9 00000E03           1098mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005FC  0405 0030               1099mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000600  CABC 000000FF           1100mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000606  1A34 5000               1101mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000060A                          1102mm     ENDM
0000060A  8805                    1103m         OR.B D5,D4
0000060C  5307                    1104m         SUB.B #1,D7
0000060E                          1105m     ENDW
0000060E  6096                    1106ms     BRA _10000006
00000610                          1107ms _10000007
00000610                          1108m     
00000610  7A00                    1109m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000612  1A04                    1110m     MOVE.B D4,D5
00000614  D484                    1111m     ADD.L D4,D2
00000616                          1112m 
00000616                          1113m     ENDM
00000616                          1114              ENDI
00000616                          1115s _00000006
00000616                          1116              
00000616  2444                    1117                  MOVE.L D4,A2                            ; put the address in an address register
00000618  D5C9                    1118              ADD.L A1,A2                             ; add in the offset
0000061A                          1119  
0000061A                          1120              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000061A                          1121s _10000008
0000061A  B63C 0000               1122s     CMP.B   #0,D3
0000061E  6F00 007E               1123s     BLE _10000009
00000622                          1124m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000622  1E3C 0002               1125m     MOVE.B #2,D7
00000626                          1126m     WHILE.B D7 <GT> 0 DO
00000626                          1127ms _1000000A
00000626  BE38 0000               1128ms     CMP.B   0,D7
0000062A  6F00 0064               1129ms     BLE _1000000B
0000062E  E989                    1130m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000630                          1131mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000630                          1132mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000630                          1133mm 
00000630  1A39 00C00003           1134mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000636  0805 0000               1135mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000063A  6700 0010               1136mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
0000063E                          1137mm  
0000063E                          1138mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000063E                 TRUE     1139mmm     IFEQ DEBUG
0000063E  1A39 00C00007           1140mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000644                          1141mmm     ENDC
00000644                 FALSE    1142mmm     IFNE DEBUG
00000644                          1143mmm     ENDC
00000644                          1144mmm      
00000644  BA3C 001B               1145mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000648  6700 F9BE               1146mmm     BEQ START
0000064C                          1147mmm     ENDM
0000064C                          1148mm CONTINUE_67
0000064C  1A39 00C00013           1149mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000652  0805 0000               1150mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000656  67D8                    1151mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000658                          1152mm     
00000658  1A39 00C00017           1153mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000065E  13C5 00E00001           1154mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000664                          1155mm     
00000664                          1156mm     ENDM
00000664                          1157mm         PRINT_CHAR D5,D6
00000664                          1158mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000664                 TRUE     1159mm     IFEQ DEBUG
00000664  1C39 00C00003           1160mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000066A  0806 0002               1161mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000066E  67F4                    1162mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
00000670  13C5 00C00007           1163mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000676                          1164mm     ENDC
00000676                          1165mm     
00000676                 FALSE    1166mm     IFNE DEBUG
00000676                          1167mm     ENDC
00000676                          1168mm 
00000676                          1169mm     ENDM
00000676                          1170mm         HEX2BIN D5,D5,A4
00000676  49F9 00000E03           1171mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000067C  0405 0030               1172mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000680  CABC 000000FF           1173mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000686  1A34 5000               1174mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000068A                          1175mm     ENDM
0000068A  8205                    1176m         OR.B D5,D1
0000068C  5307                    1177m         SUB.B #1,D7
0000068E                          1178m     ENDW
0000068E  6096                    1179ms     BRA _1000000A
00000690                          1180ms _1000000B
00000690                          1181m     
00000690  7A00                    1182m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000692  1A01                    1183m     MOVE.B D1,D5
00000694  D481                    1184m     ADD.L D1,D2
00000696                          1185m 
00000696                          1186m     ENDM
00000696                          1187                          
00000696  14C1                    1188                  MOVE.B D1,(A2)+                     ; store it!
00000698                          1189  
00000698  5303                    1190                  SUB.B #1,D3                     ; 1 less byte to go
0000069A                          1191              ENDW
0000069A  6000 FF7E               1192s     BRA _10000008
0000069E                          1193s _10000009
0000069E                          1194          
0000069E  47F8 0360               1195              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006A2                          1196          ELSE
000006A2  6000 01F0               1197s     BRA _00000007
000006A6                          1198s _00000005
000006A6                          1199              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006A6  B23C 0038               1200s     CMP.B   #'8',D1
000006AA  6600 016C               1201s     BNE.L   _00000008
000006AE  7800                    1202                  MOVE.L #0,D4                    ; read the 24 bit start address
000006B0                          1203m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006B0  1E3C 0002               1204m     MOVE.B #2,D7
000006B4                          1205m     WHILE.B D7 <GT> 0 DO
000006B4                          1206ms _1000000C
000006B4  BE38 0000               1207ms     CMP.B   0,D7
000006B8  6F00 0064               1208ms     BLE _1000000D
000006BC  E98C                    1209m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006BE                          1210mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006BE                          1211mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BE                          1212mm 
000006BE  1A39 00C00003           1213mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006C4  0805 0000               1214mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006C8  6700 0010               1215mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
000006CC                          1216mm  
000006CC                          1217mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006CC                 TRUE     1218mmm     IFEQ DEBUG
000006CC  1A39 00C00007           1219mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006D2                          1220mmm     ENDC
000006D2                 FALSE    1221mmm     IFNE DEBUG
000006D2                          1222mmm     ENDC
000006D2                          1223mmm      
000006D2  BA3C 001B               1224mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006D6  6700 F930               1225mmm     BEQ START
000006DA                          1226mmm     ENDM
000006DA                          1227mm CONTINUE_72
000006DA  1A39 00C00013           1228mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006E0  0805 0000               1229mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006E4  67D8                    1230mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
000006E6                          1231mm     
000006E6  1A39 00C00017           1232mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006EC  13C5 00E00001           1233mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006F2                          1234mm     
000006F2                          1235mm     ENDM
000006F2                          1236mm         PRINT_CHAR D5,D6
000006F2                          1237mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F2                 TRUE     1238mm     IFEQ DEBUG
000006F2  1C39 00C00003           1239mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006F8  0806 0002               1240mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006FC  67F4                    1241mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
000006FE  13C5 00C00007           1242mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000704                          1243mm     ENDC
00000704                          1244mm     
00000704                 FALSE    1245mm     IFNE DEBUG
00000704                          1246mm     ENDC
00000704                          1247mm 
00000704                          1248mm     ENDM
00000704                          1249mm         HEX2BIN D5,D5,A4
00000704  49F9 00000E03           1250mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000070A  0405 0030               1251mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070E  CABC 000000FF           1252mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000714  1A34 5000               1253mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000718                          1254mm     ENDM
00000718  8805                    1255m         OR.B D5,D4
0000071A  5307                    1256m         SUB.B #1,D7
0000071C                          1257m     ENDW
0000071C  6096                    1258ms     BRA _1000000C
0000071E                          1259ms _1000000D
0000071E                          1260m     
0000071E  7A00                    1261m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000720  1A04                    1262m     MOVE.B D4,D5
00000722  D484                    1263m     ADD.L D4,D2
00000724                          1264m 
00000724                          1265m     ENDM
00000724                          1266m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000724  1E3C 0002               1267m     MOVE.B #2,D7
00000728                          1268m     WHILE.B D7 <GT> 0 DO
00000728                          1269ms _1000000E
00000728  BE38 0000               1270ms     CMP.B   0,D7
0000072C  6F00 0064               1271ms     BLE _1000000F
00000730  E98C                    1272m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000732                          1273mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000732                          1274mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000732                          1275mm 
00000732  1A39 00C00003           1276mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000738  0805 0000               1277mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000073C  6700 0010               1278mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000740                          1279mm  
00000740                          1280mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000740                 TRUE     1281mmm     IFEQ DEBUG
00000740  1A39 00C00007           1282mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000746                          1283mmm     ENDC
00000746                 FALSE    1284mmm     IFNE DEBUG
00000746                          1285mmm     ENDC
00000746                          1286mmm      
00000746  BA3C 001B               1287mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000074A  6700 F8BC               1288mmm     BEQ START
0000074E                          1289mmm     ENDM
0000074E                          1290mm CONTINUE_77
0000074E  1A39 00C00013           1291mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000754  0805 0000               1292mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  67D8                    1293mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000075A                          1294mm     
0000075A  1A39 00C00017           1295mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000760  13C5 00E00001           1296mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000766                          1297mm     
00000766                          1298mm     ENDM
00000766                          1299mm         PRINT_CHAR D5,D6
00000766                          1300mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000766                 TRUE     1301mm     IFEQ DEBUG
00000766  1C39 00C00003           1302mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000076C  0806 0002               1303mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000770  67F4                    1304mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
00000772  13C5 00C00007           1305mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000778                          1306mm     ENDC
00000778                          1307mm     
00000778                 FALSE    1308mm     IFNE DEBUG
00000778                          1309mm     ENDC
00000778                          1310mm 
00000778                          1311mm     ENDM
00000778                          1312mm         HEX2BIN D5,D5,A4
00000778  49F9 00000E03           1313mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000077E  0405 0030               1314mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000782  CABC 000000FF           1315mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000788  1A34 5000               1316mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000078C                          1317mm     ENDM
0000078C  8805                    1318m         OR.B D5,D4
0000078E  5307                    1319m         SUB.B #1,D7
00000790                          1320m     ENDW
00000790  6096                    1321ms     BRA _1000000E
00000792                          1322ms _1000000F
00000792                          1323m     
00000792  7A00                    1324m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000794  1A04                    1325m     MOVE.B D4,D5
00000796  D484                    1326m     ADD.L D4,D2
00000798                          1327m 
00000798                          1328m     ENDM
00000798                          1329m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000798  1E3C 0002               1330m     MOVE.B #2,D7
0000079C                          1331m     WHILE.B D7 <GT> 0 DO
0000079C                          1332ms _10000010
0000079C  BE38 0000               1333ms     CMP.B   0,D7
000007A0  6F00 0064               1334ms     BLE _10000011
000007A4  E98C                    1335m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007A6                          1336mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007A6                          1337mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A6                          1338mm 
000007A6  1A39 00C00003           1339mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007AC  0805 0000               1340mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007B0  6700 0010               1341mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007B4                          1342mm  
000007B4                          1343mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007B4                 TRUE     1344mmm     IFEQ DEBUG
000007B4  1A39 00C00007           1345mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007BA                          1346mmm     ENDC
000007BA                 FALSE    1347mmm     IFNE DEBUG
000007BA                          1348mmm     ENDC
000007BA                          1349mmm      
000007BA  BA3C 001B               1350mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007BE  6700 F848               1351mmm     BEQ START
000007C2                          1352mmm     ENDM
000007C2                          1353mm CONTINUE_82
000007C2  1A39 00C00013           1354mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007C8  0805 0000               1355mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CC  67D8                    1356mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
000007CE                          1357mm     
000007CE  1A39 00C00017           1358mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007D4  13C5 00E00001           1359mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007DA                          1360mm     
000007DA                          1361mm     ENDM
000007DA                          1362mm         PRINT_CHAR D5,D6
000007DA                          1363mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DA                 TRUE     1364mm     IFEQ DEBUG
000007DA  1C39 00C00003           1365mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007E0  0806 0002               1366mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007E4  67F4                    1367mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
000007E6  13C5 00C00007           1368mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007EC                          1369mm     ENDC
000007EC                          1370mm     
000007EC                 FALSE    1371mm     IFNE DEBUG
000007EC                          1372mm     ENDC
000007EC                          1373mm 
000007EC                          1374mm     ENDM
000007EC                          1375mm         HEX2BIN D5,D5,A4
000007EC  49F9 00000E03           1376mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007F2  0405 0030               1377mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007F6  CABC 000000FF           1378mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007FC  1A34 5000               1379mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000800                          1380mm     ENDM
00000800  8805                    1381m         OR.B D5,D4
00000802  5307                    1382m         SUB.B #1,D7
00000804                          1383m     ENDW
00000804  6096                    1384ms     BRA _10000010
00000806                          1385ms _10000011
00000806                          1386m     
00000806  7A00                    1387m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000808  1A04                    1388m     MOVE.B D4,D5
0000080A  D484                    1389m     ADD.L D4,D2
0000080C                          1390m 
0000080C                          1391m     ENDM
0000080C                          1392                    
0000080C  2044                    1393                  MOVE.L D4,A0                    ; start address -> A0
0000080E                          1394                  
0000080E  47F9 000009CA           1395                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000814                          1396              ELSE
00000814  6000 007E               1397s     BRA _00000009
00000818                          1398s _00000008
00000818                          1399m                 PRINT_CRLF D5,A4
00000818  49F9 00000E2E           1400m     LEA CRLF,A4
0000081E                          1401mm     PRINT_STR A4,D5
0000081E                          1402mm LOOP_87
0000081E  0C14 0000               1403mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000822  6700 0016               1404mm     BEQ EXIT_87
00000826                          1405mmm     PRINT_CHAR (A4)+,D5
00000826                          1406mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1407mmm     IFEQ DEBUG
00000826  1A39 00C00003           1408mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1409mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1410mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00000832  13DC 00C00007           1411mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000838                          1412mmm     ENDC
00000838                          1413mmm     
00000838                 FALSE    1414mmm     IFNE DEBUG
00000838                          1415mmm     ENDC
00000838                          1416mmm 
00000838                          1417mmm     ENDM
00000838  60E4                    1418mm     BRA LOOP_87
0000083A                          1419mm EXIT_87
0000083A                          1420mm     ENDM
0000083A                          1421m     ENDM
0000083A                          1422              
0000083A  49F9 00000DB8           1423                  LEA UNREC,A4                    ; warn for unrecognised type
00000840                          1424m                 PRINT_STR A4,D5
00000840                          1425m LOOP_89
00000840  0C14 0000               1426m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000844  6700 0016               1427m     BEQ EXIT_89
00000848                          1428mm     PRINT_CHAR (A4)+,D5
00000848                          1429mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000848                 TRUE     1430mm     IFEQ DEBUG
00000848  1A39 00C00003           1431mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000084E  0805 0002               1432mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000852  67F4                    1433mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00000854  13DC 00C00007           1434mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000085A                          1435mm     ENDC
0000085A                          1436mm     
0000085A                 FALSE    1437mm     IFNE DEBUG
0000085A                          1438mm     ENDC
0000085A                          1439mm 
0000085A                          1440mm     ENDM
0000085A  60E4                    1441m     BRA LOOP_89
0000085C                          1442m EXIT_89
0000085C                          1443m     ENDM
0000085C                          1444m                 PRINT_CHAR D1,D5
0000085C                          1445m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085C                 TRUE     1446m     IFEQ DEBUG
0000085C  1A39 00C00003           1447m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000862  0805 0002               1448m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000866  67F4                    1449m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000868  13C1 00C00007           1450m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000086E                          1451m     ENDC
0000086E                          1452m     
0000086E                 FALSE    1453m     IFNE DEBUG
0000086E                          1454m     ENDC
0000086E                          1455m 
0000086E                          1456m     ENDM
0000086E                          1457m                 PRINT_CRLF D5,A4
0000086E  49F9 00000E2E           1458m     LEA CRLF,A4
00000874                          1459mm     PRINT_STR A4,D5
00000874                          1460mm LOOP_93
00000874  0C14 0000               1461mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000878  6700 0016               1462mm     BEQ EXIT_93
0000087C                          1463mmm     PRINT_CHAR (A4)+,D5
0000087C                          1464mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087C                 TRUE     1465mmm     IFEQ DEBUG
0000087C  1A39 00C00003           1466mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000882  0805 0002               1467mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000886  67F4                    1468mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000888  13DC 00C00007           1469mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000088E                          1470mmm     ENDC
0000088E                          1471mmm     
0000088E                 FALSE    1472mmm     IFNE DEBUG
0000088E                          1473mmm     ENDC
0000088E                          1474mmm 
0000088E                          1475mmm     ENDM
0000088E  60E4                    1476mm     BRA LOOP_93
00000890                          1477mm EXIT_93
00000890                          1478mm     ENDM
00000890                          1479m     ENDM
00000890                          1480              
00000890  6000 FACE               1481                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000894                          1482              ENDI
00000894                          1483s _00000009
00000894                          1484          ENDI
00000894                          1485s _00000007
00000894                          1486      ENDI
00000894                          1487s _00000003
00000894                          1488      
00000894                          1489m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000894  1E3C 0002               1490m     MOVE.B #2,D7
00000898                          1491m     WHILE.B D7 <GT> 0 DO
00000898                          1492ms _10000012
00000898  BE38 0000               1493ms     CMP.B   0,D7
0000089C  6F00 0064               1494ms     BLE _10000013
000008A0  E98C                    1495m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008A2                          1496mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008A2                          1497mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A2                          1498mm 
000008A2  1A39 00C00003           1499mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008A8  0805 0000               1500mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008AC  6700 0010               1501mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008B0                          1502mm  
000008B0                          1503mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008B0                 TRUE     1504mmm     IFEQ DEBUG
000008B0  1A39 00C00007           1505mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008B6                          1506mmm     ENDC
000008B6                 FALSE    1507mmm     IFNE DEBUG
000008B6                          1508mmm     ENDC
000008B6                          1509mmm      
000008B6  BA3C 001B               1510mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008BA  6700 F74C               1511mmm     BEQ START
000008BE                          1512mmm     ENDM
000008BE                          1513mm CONTINUE_96
000008BE  1A39 00C00013           1514mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008C4  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C8  67D8                    1516mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
000008CA                          1517mm     
000008CA  1A39 00C00017           1518mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008D0  13C5 00E00001           1519mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008D6                          1520mm     
000008D6                          1521mm     ENDM
000008D6                          1522mm         PRINT_CHAR D5,D6
000008D6                          1523mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                 TRUE     1524mm     IFEQ DEBUG
000008D6  1C39 00C00003           1525mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008DC  0806 0002               1526mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008E0  67F4                    1527mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000008E2  13C5 00C00007           1528mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008E8                          1529mm     ENDC
000008E8                          1530mm     
000008E8                 FALSE    1531mm     IFNE DEBUG
000008E8                          1532mm     ENDC
000008E8                          1533mm 
000008E8                          1534mm     ENDM
000008E8                          1535mm         HEX2BIN D5,D5,A4
000008E8  49F9 00000E03           1536mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000008EE  0405 0030               1537mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008F2  CABC 000000FF           1538mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008F8  1A34 5000               1539mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008FC                          1540mm     ENDM
000008FC  8805                    1541m         OR.B D5,D4
000008FE  5307                    1542m         SUB.B #1,D7
00000900                          1543m     ENDW
00000900  6096                    1544ms     BRA _10000012
00000902                          1545ms _10000013
00000902                          1546m     
00000902  7A00                    1547m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000904  1A04                    1548m     MOVE.B D4,D5
00000906  D484                    1549m     ADD.L D4,D2
00000908                          1550m 
00000908                          1551m     ENDM
00000908                          1552m     PRINT_CRLF D5,A4
00000908  49F9 00000E2E           1553m     LEA CRLF,A4
0000090E                          1554mm     PRINT_STR A4,D5
0000090E                          1555mm LOOP_101
0000090E  0C14 0000               1556mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000912  6700 0016               1557mm     BEQ EXIT_101
00000916                          1558mmm     PRINT_CHAR (A4)+,D5
00000916                          1559mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                 TRUE     1560mmm     IFEQ DEBUG
00000916  1A39 00C00003           1561mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000091C  0805 0002               1562mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000920  67F4                    1563mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000922  13DC 00C00007           1564mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000928                          1565mmm     ENDC
00000928                          1566mmm     
00000928                 FALSE    1567mmm     IFNE DEBUG
00000928                          1568mmm     ENDC
00000928                          1569mmm 
00000928                          1570mmm     ENDM
00000928  60E4                    1571mm     BRA LOOP_101
0000092A                          1572mm EXIT_101
0000092A                          1573mm     ENDM
0000092A                          1574m     ENDM
0000092A                          1575          
0000092A                          1576      IF.B D2 <NE> #$FF THEN.L
0000092A  B43C 00FF               1577s     CMP.B   #$FF,D2
0000092E  6700 0098               1578s     BEQ.L   _0000000A
00000932  49F9 00000DCF           1579          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000938                          1580m         PRINT_STR A4,D5
00000938                          1581m LOOP_103
00000938  0C14 0000               1582m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000093C  6700 0016               1583m     BEQ EXIT_103
00000940                          1584mm     PRINT_CHAR (A4)+,D5
00000940                          1585mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000940                 TRUE     1586mm     IFEQ DEBUG
00000940  1A39 00C00003           1587mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000946  0805 0002               1588mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000094A  67F4                    1589mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000094C  13DC 00C00007           1590mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000952                          1591mm     ENDC
00000952                          1592mm     
00000952                 FALSE    1593mm     IFNE DEBUG
00000952                          1594mm     ENDC
00000952                          1595mm 
00000952                          1596mm     ENDM
00000952  60E4                    1597m     BRA LOOP_103
00000954                          1598m EXIT_103
00000954                          1599m     ENDM
00000954                          1600m         PRINT_REG D0,D5,D2,D6,A4
00000954  49F9 00000E34           1601m     LEA OX,A4
0000095A                          1602mm     PRINT_STR A4,D5
0000095A                          1603mm LOOP_106
0000095A  0C14 0000               1604mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000095E  6700 0016               1605mm     BEQ EXIT_106
00000962                          1606mmm     PRINT_CHAR (A4)+,D5
00000962                          1607mmm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1608mmm     IFEQ DEBUG
00000962  1A39 00C00003           1609mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000968  0805 0002               1610mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1611mmm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096E  13DC 00C00007           1612mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000974                          1613mmm     ENDC
00000974                          1614mmm     
00000974                 FALSE    1615mmm     IFNE DEBUG
00000974                          1616mmm     ENDC
00000974                          1617mmm 
00000974                          1618mmm     ENDM
00000974  60E4                    1619mm     BRA LOOP_106
00000976                          1620mm EXIT_106
00000976                          1621mm     ENDM
00000976  7C07                    1622m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000978                          1623m LOOP_105
00000978                          1624mm     BIN2HEX D0,D2,A4
00000978  49F9 00000DF3           1625mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000097E  E998                    1626mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000980  1400                    1627mm     MOVE.B D0,D2
00000982  0282 0000000F           1628mm     ANDI.L #$F,D2
00000988  1434 2000               1629mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000098C                          1630mm     ENDM
0000098C                          1631mm     PRINT_CHAR D2,D5
0000098C                          1632mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1633mm     IFEQ DEBUG
0000098C  1A39 00C00003           1634mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000992  0805 0002               1635mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000996  67F4                    1636mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000998  13C2 00C00007           1637mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000099E                          1638mm     ENDC
0000099E                          1639mm     
0000099E                 FALSE    1640mm     IFNE DEBUG
0000099E                          1641mm     ENDC
0000099E                          1642mm 
0000099E                          1643mm     ENDM
0000099E  57CE FFD8               1644m     DBEQ D6,LOOP_105
000009A2                          1645m     ENDM
000009A2                          1646m         PRINT_CRLF D5,A4
000009A2  49F9 00000E2E           1647m     LEA CRLF,A4
000009A8                          1648mm     PRINT_STR A4,D5
000009A8                          1649mm LOOP_111
000009A8  0C14 0000               1650mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009AC  6700 0016               1651mm     BEQ EXIT_111
000009B0                          1652mmm     PRINT_CHAR (A4)+,D5
000009B0                          1653mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1654mmm     IFEQ DEBUG
000009B0  1A39 00C00003           1655mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B6  0805 0002               1656mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1657mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
000009BC  13DC 00C00007           1658mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009C2                          1659mmm     ENDC
000009C2                          1660mmm     
000009C2                 FALSE    1661mmm     IFNE DEBUG
000009C2                          1662mmm     ENDC
000009C2                          1663mmm 
000009C2                          1664mmm     ENDM
000009C2  60E4                    1665mm     BRA LOOP_111
000009C4                          1666mm EXIT_111
000009C4                          1667mm     ENDM
000009C4                          1668m     ENDM
000009C4  6000 F772               1669          BRA MAIN_LOOP
000009C8                          1670      ENDI
000009C8                          1671s _0000000A
000009C8                          1672      
000009C8  4ED3                    1673      JMP (A3)
000009CA                          1674  DOWNLOAD_DONE
000009CA                          1675m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009CA  43F9 00000E34           1676m     LEA OX,A1
000009D0                          1677mm     PRINT_STR A1,D5
000009D0                          1678mm LOOP_114
000009D0  0C11 0000               1679mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009D4  6700 0016               1680mm     BEQ EXIT_114
000009D8                          1681mmm     PRINT_CHAR (A1)+,D5
000009D8                          1682mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1683mmm     IFEQ DEBUG
000009D8  1A39 00C00003           1684mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1685mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1686mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009E4  13D9 00C00007           1687mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009EA                          1688mmm     ENDC
000009EA                          1689mmm     
000009EA                 FALSE    1690mmm     IFNE DEBUG
000009EA                          1691mmm     ENDC
000009EA                          1692mmm 
000009EA                          1693mmm     ENDM
000009EA  60E4                    1694mm     BRA LOOP_114
000009EC                          1695mm EXIT_114
000009EC                          1696mm     ENDM
000009EC  7407                    1697m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009EE                          1698m LOOP_113
000009EE                          1699mm     BIN2HEX D0,D6,A1
000009EE  43F9 00000DF3           1700mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
000009F4  E998                    1701mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009F6  1C00                    1702mm     MOVE.B D0,D6
000009F8  0286 0000000F           1703mm     ANDI.L #$F,D6
000009FE  1C31 6000               1704mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A02                          1705mm     ENDM
00000A02                          1706mm     PRINT_CHAR D6,D5
00000A02                          1707mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A02                 TRUE     1708mm     IFEQ DEBUG
00000A02  1A39 00C00003           1709mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A08  0805 0002               1710mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0C  67F4                    1711mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A0E  13C6 00C00007           1712mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A14                          1713mm     ENDC
00000A14                          1714mm     
00000A14                 FALSE    1715mm     IFNE DEBUG
00000A14                          1716mm     ENDC
00000A14                          1717mm 
00000A14                          1718mm     ENDM
00000A14  57CA FFD8               1719m     DBEQ D2,LOOP_113
00000A18                          1720m     ENDM
00000A18  43F9 00000D96           1721      LEA READ,A1
00000A1E                          1722m     PRINT_STR A1,D5
00000A1E                          1723m LOOP_118
00000A1E  0C11 0000               1724m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A22  6700 0016               1725m     BEQ EXIT_118
00000A26                          1726mm     PRINT_CHAR (A1)+,D5
00000A26                          1727mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1728mm     IFEQ DEBUG
00000A26  1A39 00C00003           1729mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A2C  0805 0002               1730mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1731mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A32  13D9 00C00007           1732mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A38                          1733mm     ENDC
00000A38                          1734mm     
00000A38                 FALSE    1735mm     IFNE DEBUG
00000A38                          1736mm     ENDC
00000A38                          1737mm 
00000A38                          1738mm     ENDM
00000A38  60E4                    1739m     BRA LOOP_118
00000A3A                          1740m EXIT_118
00000A3A                          1741m     ENDM
00000A3A  2E08                    1742      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A3C                          1743m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A3C  43F9 00000E34           1744m     LEA OX,A1
00000A42                          1745mm     PRINT_STR A1,D5
00000A42                          1746mm LOOP_121
00000A42  0C11 0000               1747mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A46  6700 0016               1748mm     BEQ EXIT_121
00000A4A                          1749mmm     PRINT_CHAR (A1)+,D5
00000A4A                          1750mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4A                 TRUE     1751mmm     IFEQ DEBUG
00000A4A  1A39 00C00003           1752mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A50  0805 0002               1753mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A54  67F4                    1754mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000A56  13D9 00C00007           1755mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A5C                          1756mmm     ENDC
00000A5C                          1757mmm     
00000A5C                 FALSE    1758mmm     IFNE DEBUG
00000A5C                          1759mmm     ENDC
00000A5C                          1760mmm 
00000A5C                          1761mmm     ENDM
00000A5C  60E4                    1762mm     BRA LOOP_121
00000A5E                          1763mm EXIT_121
00000A5E                          1764mm     ENDM
00000A5E  7407                    1765m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A60                          1766m LOOP_120
00000A60                          1767mm     BIN2HEX D7,D6,A1
00000A60  43F9 00000DF3           1768mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A66  E99F                    1769mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A68  1C07                    1770mm     MOVE.B D7,D6
00000A6A  0286 0000000F           1771mm     ANDI.L #$F,D6
00000A70  1C31 6000               1772mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A74                          1773mm     ENDM
00000A74                          1774mm     PRINT_CHAR D6,D5
00000A74                          1775mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A74                 TRUE     1776mm     IFEQ DEBUG
00000A74  1A39 00C00003           1777mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A7A  0805 0002               1778mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A7E  67F4                    1779mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A80  13C6 00C00007           1780mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A86                          1781mm     ENDC
00000A86                          1782mm     
00000A86                 FALSE    1783mm     IFNE DEBUG
00000A86                          1784mm     ENDC
00000A86                          1785mm 
00000A86                          1786mm     ENDM
00000A86  57CA FFD8               1787m     DBEQ D2,LOOP_120
00000A8A                          1788m     ENDM
00000A8A                          1789m     PRINT_CRLF D5,A4     
00000A8A  49F9 00000E2E           1790m     LEA CRLF,A4
00000A90                          1791mm     PRINT_STR A4,D5
00000A90                          1792mm LOOP_126
00000A90  0C14 0000               1793mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A94  6700 0016               1794mm     BEQ EXIT_126
00000A98                          1795mmm     PRINT_CHAR (A4)+,D5
00000A98                          1796mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A98                 TRUE     1797mmm     IFEQ DEBUG
00000A98  1A39 00C00003           1798mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9E  0805 0002               1799mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA2  67F4                    1800mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AA4  13DC 00C00007           1801mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AAA                          1802mmm     ENDC
00000AAA                          1803mmm     
00000AAA                 FALSE    1804mmm     IFNE DEBUG
00000AAA                          1805mmm     ENDC
00000AAA                          1806mmm 
00000AAA                          1807mmm     ENDM
00000AAA  60E4                    1808mm     BRA LOOP_126
00000AAC                          1809mm EXIT_126
00000AAC                          1810mm     ENDM
00000AAC                          1811m     ENDM
00000AAC                          1812          
00000AAC  6000 F68A               1813      BRA MAIN_LOOP
00000AB0                          1814      
00000AB0                          1815  G
00000AB0  2047                    1816      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AB2  3E3C 0000               1817      MOVE #0,D7                                      ; clear the now used address accumulator
00000AB6  4ED0                    1818      JMP (A0)                                        ; jump to it!
00000AB8                          1819      
00000AB8                          1820  Z
00000AB8  207C 00200000           1821      MOVE.L #RAM,A0                                  ; address of RAM
00000ABE                          1822      
00000ABE                          1823      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000ABE  7000                    1824s     MOVE.L  #0,D0
00000AC0  6000 0012               1825s     BRA _20000005
00000AC4                          1826s _20000004
00000AC4  2200                    1827              MOVE.L D0,D1                              ; progress update
00000AC6  E089                    1828          LSR.L #8,D1 
00000AC8  E089                    1829          LSR.L #8,D1
00000ACA  13C1 00E00001           1830          MOVE.B D1,DISPLAY
00000AD0                          1831  
00000AD0  20C0                    1832          MOVE.L D0,(A0)+
00000AD2                          1833      ENDF
00000AD2  5880                    1834s     ADD.L   #4,D0
00000AD4                          1835s _20000005
00000AD4  B0BC 00040000           1836s     CMP.L   #$40000,D0
00000ADA  6FE8                    1837s     BLE _20000004
00000ADC                          1838   
00000ADC  207C 00200000           1839      MOVE.L #RAM,A0                                    ; address of RAM
00000AE2                          1840     
00000AE2                          1841      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AE2  7000                    1842s     MOVE.L  #0,D0
00000AE4  6000 00AE               1843s     BRA _20000007
00000AE8                          1844s _20000006
00000AE8  2200                    1845          MOVE.L D0,D1                              ; progress update
00000AEA  E089                    1846          LSR.L #8,D1
00000AEC  E089                    1847          LSR.L #8,D1
00000AEE  13C1 00E00001           1848          MOVE.B D1,DISPLAY
00000AF4                          1849  
00000AF4  2218                    1850          MOVE.L (A0)+,D1
00000AF6                          1851            
00000AF6                          1852          IF.L D0 <NE> D1 THEN      
00000AF6  B081                    1853s     CMP.L   D1,D0
00000AF8  6700 0098               1854s     BEQ _0000000B
00000AFC  43F9 00000DE1           1855              LEA RAM_ERROR,A1
00000B02                          1856m             PRINT_STR A1,D1
00000B02                          1857m LOOP_128
00000B02  0C11 0000               1858m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B06  6700 0016               1859m     BEQ EXIT_128
00000B0A                          1860mm     PRINT_CHAR (A1)+,D1
00000B0A                          1861mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0A                 TRUE     1862mm     IFEQ DEBUG
00000B0A  1239 00C00003           1863mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B10  0801 0002               1864mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B14  67F4                    1865mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B16  13D9 00C00007           1866mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B1C                          1867mm     ENDC
00000B1C                          1868mm     
00000B1C                 FALSE    1869mm     IFNE DEBUG
00000B1C                          1870mm     ENDC
00000B1C                          1871mm 
00000B1C                          1872mm     ENDM
00000B1C  60E4                    1873m     BRA LOOP_128
00000B1E                          1874m EXIT_128
00000B1E                          1875m     ENDM
00000B1E  2208                    1876              MOVE.L A0,D1
00000B20  5981                    1877              SUB.L #4,D1
00000B22                          1878m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B22  43F9 00000E34           1879m     LEA OX,A1
00000B28                          1880mm     PRINT_STR A1,D3
00000B28                          1881mm LOOP_131
00000B28  0C11 0000               1882mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B2C  6700 0016               1883mm     BEQ EXIT_131
00000B30                          1884mmm     PRINT_CHAR (A1)+,D3
00000B30                          1885mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1886mmm     IFEQ DEBUG
00000B30  1639 00C00003           1887mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1888mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1889mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000B3C  13D9 00C00007           1890mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B42                          1891mmm     ENDC
00000B42                          1892mmm     
00000B42                 FALSE    1893mmm     IFNE DEBUG
00000B42                          1894mmm     ENDC
00000B42                          1895mmm 
00000B42                          1896mmm     ENDM
00000B42  60E4                    1897mm     BRA LOOP_131
00000B44                          1898mm EXIT_131
00000B44                          1899mm     ENDM
00000B44  7C07                    1900m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1901m LOOP_130
00000B46                          1902mm     BIN2HEX D1,D2,A1
00000B46  43F9 00000DF3           1903mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B4C  E999                    1904mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1401                    1905mm     MOVE.B D1,D2
00000B50  0282 0000000F           1906mm     ANDI.L #$F,D2
00000B56  1431 2000               1907mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1908mm     ENDM
00000B5A                          1909mm     PRINT_CHAR D2,D3
00000B5A                          1910mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1911mm     IFEQ DEBUG
00000B5A  1639 00C00003           1912mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B60  0803 0002               1913mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1914mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B66  13C2 00C00007           1915mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1916mm     ENDC
00000B6C                          1917mm     
00000B6C                 FALSE    1918mm     IFNE DEBUG
00000B6C                          1919mm     ENDC
00000B6C                          1920mm 
00000B6C                          1921mm     ENDM
00000B6C  57CE FFD8               1922m     DBEQ D6,LOOP_130
00000B70                          1923m     ENDM
00000B70                          1924m             PRINT_CRLF D3,A1
00000B70  43F9 00000E2E           1925m     LEA CRLF,A1
00000B76                          1926mm     PRINT_STR A1,D3
00000B76                          1927mm LOOP_136
00000B76  0C11 0000               1928mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B7A  6700 0016               1929mm     BEQ EXIT_136
00000B7E                          1930mmm     PRINT_CHAR (A1)+,D3
00000B7E                          1931mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1932mmm     IFEQ DEBUG
00000B7E  1639 00C00003           1933mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B84  0803 0002               1934mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1935mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000B8A  13D9 00C00007           1936mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1937mmm     ENDC
00000B90                          1938mmm     
00000B90                 FALSE    1939mmm     IFNE DEBUG
00000B90                          1940mmm     ENDC
00000B90                          1941mmm 
00000B90                          1942mmm     ENDM
00000B90  60E4                    1943mm     BRA LOOP_136
00000B92                          1944mm EXIT_136
00000B92                          1945mm     ENDM
00000B92                          1946m     ENDM
00000B92                          1947          ENDI 
00000B92                          1948s _0000000B
00000B92                          1949      ENDF
00000B92  5880                    1950s     ADD.L   #4,D0
00000B94                          1951s _20000007
00000B94  B0BC 00040000           1952s     CMP.L   #$40000,D0
00000B9A  6F00 FF4C               1953s     BLE _20000006
00000B9E                          1954      
00000B9E  6000 F598               1955      BRA MAIN_LOOP
00000BA2                          1956    
00000BA2                          1957  L
00000BA2  7A00                    1958      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000BA4                          1959  
00000BA4                          1960      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000BA4  3C3C 0000               1961s     MOVE.W  #0,D6
00000BA8  6000 0048               1962s     BRA _20000009
00000BAC                          1963s _20000008
00000BAC  E98D                    1964          LSL.L #4,D5                                 ; make what we have so far more significant
00000BAE                          1965m         WAIT_CHAR D2,D3                             ; next character -> D2
00000BAE                          1966m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAE                 TRUE     1967m     IFEQ DEBUG
00000BAE  1639 00C00003           1968m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BB4  0803 0000               1969m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000BB8  67F4                    1970m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000BBA                          1971m     ENDC
00000BBA                          1972m     
00000BBA                          1973mm     READ_CHAR D2
00000BBA                 TRUE     1974mm     IFEQ DEBUG
00000BBA  1439 00C00007           1975mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000BC0                          1976mm     ENDC
00000BC0                 FALSE    1977mm     IFNE DEBUG
00000BC0                          1978mm     ENDC
00000BC0                          1979mm      
00000BC0  B43C 001B               1980mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000BC4  6700 F442               1981mm     BEQ START
00000BC8                          1982mm     ENDM
00000BC8                          1983m 
00000BC8                 TRUE     1984m     IFEQ DEBUG
00000BC8                          1985mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000BC8                          1986mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1987mm     IFEQ DEBUG
00000BC8  1639 00C00003           1988mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BCE  0803 0002               1989mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1990mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000BD4  13C2 00C00007           1991mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BDA                          1992mm     ENDC
00000BDA                          1993mm     
00000BDA                 FALSE    1994mm     IFNE DEBUG
00000BDA                          1995mm     ENDC
00000BDA                          1996mm 
00000BDA                          1997mm     ENDM
00000BDA                          1998m     ENDC
00000BDA                          1999m     ENDM
00000BDA                          2000m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000BDA  41F9 00000E03           2001m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000BE0  0402 0030               2002m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BE4  C4BC 000000FF           2003m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000BEA  1430 2000               2004m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BEE                          2005m     ENDM
00000BEE  8A02                    2006          OR.B D2,D5
00000BF0                          2007      ENDF
00000BF0  5246                    2008s     ADD.W   #1,D6
00000BF2                          2009s _20000009
00000BF2  BC7C 0003               2010s     CMP.W   #3,D6
00000BF6  6FB4                    2011s     BLE _20000008
00000BF8                          2012            
00000BF8                          2013m     PRINT_CRLF D3,A0
00000BF8  41F9 00000E2E           2014m     LEA CRLF,A0
00000BFE                          2015mm     PRINT_STR A0,D3
00000BFE                          2016mm LOOP_143
00000BFE  0C10 0000               2017mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C02  6700 0016               2018mm     BEQ EXIT_143
00000C06                          2019mmm     PRINT_CHAR (A0)+,D3
00000C06                          2020mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     2021mmm     IFEQ DEBUG
00000C06  1639 00C00003           2022mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C0C  0803 0002               2023mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C10  67F4                    2024mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C12  13D8 00C00007           2025mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C18                          2026mmm     ENDC
00000C18                          2027mmm     
00000C18                 FALSE    2028mmm     IFNE DEBUG
00000C18                          2029mmm     ENDC
00000C18                          2030mmm 
00000C18                          2031mmm     ENDM
00000C18  60E4                    2032mm     BRA LOOP_143
00000C1A                          2033mm EXIT_143
00000C1A                          2034mm     ENDM
00000C1A                          2035m     ENDM
00000C1A                          2036  
00000C1A  207C 00000000           2037      MOVE.L #ROM,A0                                  ; start of ROM
00000C20                          2038      
00000C20  2247                    2039      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C22  7E00                    2040      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C24                          2041      
00000C24  31FC AAAA 2AAA          2042      MOVE.W #$AAAA,$2AAA
00000C2A  31FC 5555 1554          2043      MOVE.W #$5555,$1554
00000C30  31FC 8080 2AAA          2044      MOVE.W #$8080,$2AAA
00000C36  31FC AAAA 2AAA          2045      MOVE.W #$AAAA,$2AAA
00000C3C  31FC 5555 1554          2046      MOVE.W #$5555,$1554
00000C42  31FC 2020 2AAA          2047      MOVE.W #$2020,$2AAA
00000C48                          2048      
00000C48  45F9 00000E1A           2049      LEA LOADING,A2                              ; important for timing
00000C4E                          2050m     PRINT_STR A2,D3
00000C4E                          2051m LOOP_145
00000C4E  0C12 0000               2052m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C52  6700 0016               2053m     BEQ EXIT_145
00000C56                          2054mm     PRINT_CHAR (A2)+,D3
00000C56                          2055mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C56                 TRUE     2056mm     IFEQ DEBUG
00000C56  1639 00C00003           2057mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5C  0803 0002               2058mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C60  67F4                    2059mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C62  13DA 00C00007           2060mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C68                          2061mm     ENDC
00000C68                          2062mm     
00000C68                 FALSE    2063mm     IFNE DEBUG
00000C68                          2064mm     ENDC
00000C68                          2065mm 
00000C68                          2066mm     ENDM
00000C68  60E4                    2067m     BRA LOOP_145
00000C6A                          2068m EXIT_145
00000C6A                          2069m     ENDM
00000C6A                          2070      
00000C6A                          2071      WHILE D5 <GT> #0 DO
00000C6A                          2072s _10000014
00000C6A  BA7C 0000               2073s     CMP.W   #0,D5
00000C6E  6F00 001C               2074s     BLE _10000015
00000C72  5585                    2075          SUB.L #2,D5
00000C74                          2076            
00000C74  13D1 00E00001           2077          MOVE.B (A1),DISPLAY
00000C7A  3091                    2078          MOVE.W (A1),(A0)                            ; write the data
00000C7C                          2079        
00000C7C                          2080  WAIT_FOR_COMPLETE
00000C7C  3410                    2081          MOVE.W (A0),D2
00000C7E                          2082  
00000C7E                          2083          IF D2 <NE> (A1) THEN
00000C7E  B451                    2084s     CMP.W   (A1),D2
00000C80  6700 0004               2085s     BEQ _0000000C
00000C84  60F6                    2086              BRA WAIT_FOR_COMPLETE
00000C86                          2087          ENDI
00000C86                          2088s _0000000C
00000C86                          2089        
00000C86  5488                    2090          ADD.L #2,A0
00000C88  5489                    2091          ADD.L #2,A1
00000C8A                          2092       ENDW    
00000C8A  60DE                    2093s     BRA _10000014
00000C8C                          2094s _10000015
00000C8C                          2095      
00000C8C  31FC AAAA 2AAA          2096      MOVE.W #$AAAA,$2AAA
00000C92  31FC 5555 1554          2097      MOVE.W #$5555,$1554
00000C98  31FC A0A0 2AAA          2098      MOVE.W #$A0A0,$2AAA
00000C9E                          2099              
00000C9E  6000 F498               2100      BRA MAIN_LOOP
00000CA2                          2101          
00000CA2                          2102  HEX_DIGIT
00000CA2  E98F                    2103      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000CA4                          2104m     HEX2BIN D2,D2,A0
00000CA4  41F9 00000E03           2105m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000CAA  0402 0030               2106m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CAE  C4BC 000000FF           2107m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000CB4  1430 2000               2108m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000CB8                          2109m     ENDM
00000CB8  8E02                    2110      OR.B D2,D7  
00000CBA  6000 F49E               2111      BRA GET_INPUT
00000CBE                          2112  
00000CBE  FFFF FFFF               2113      SIMHALT                                         ; halt simulator
00000CC2                          2114  
00000CC2                          2115  ; strings
00000CC2= 4D 44 46 2D 6D 6F ...   2116  VERSION DC.B 'MDF-mon V1.54 (10/04/2021)',CR,LF,NULL
00000CDF= 3F 09 09 09 68 65 ...   2117  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000CE9= 5B 76 5D 09 09 09 ...   2118          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000CF8= 78 78 78 78 78 78 ...   2119          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D10= 78 78 78 78 78 78 ...   2120          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D30= 5B 73 5D 09 09 09 ...   2121          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000D4A= 78 78 78 78 78 78 ...   2122          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000D5B= 5B 7A 5D 09 09 09 ...   2123          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000D6D= 78 78 78 78 78 78 ...   2124          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000D8F= 48 75 68 3F 0D 0A 00    2125  HUH     DC.B 'Huh?',CR,LF,NULL
00000D96= 20 53 20 72 65 63 ...   2126  READ    DC.B ' S records read, start address = ',NULL
00000DB8= 57 3A 20 55 6E 6B ...   2127  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000DCF= 57 3A 20 43 53 20 ...   2128  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000DE1= 57 3A 20 52 41 4D ...   2129  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000DF3= 30 31 32 33 34 35 ...   2130  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E03= 00 01 02 03 04 05 ...   2131  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E1A= 4C 6F 61 64 69 6E ...   2132  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E2E= 0D 0A 00                2133  CRLF    DC.B CR,LF,NULL
00000E31= 3E 20 00                2134  PROMPT  DC.B '> ',NULL
00000E34= 30 78 00                2135  ox      DC.B '0x',NULL
00000E37                          2136      
00000E37                          2137      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         DF3
CONTINUE_37         37C
CONTINUE_40         3CC
CONTINUE_44         422
CONTINUE_52         4DA
CONTINUE_57         54E
CONTINUE_62         5CC
CONTINUE_67         64C
CONTINUE_72         6DA
CONTINUE_77         74E
CONTINUE_82         7C2
CONTINUE_96         8BE
CR                  D
CRLF                E2E
CS_FAILURE          DCF
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            93A
DOWNLOAD_BYTE       C1F
DOWNLOAD_DONE       9CA
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             15A
EXIT_101            92A
EXIT_103            954
EXIT_106            976
EXIT_111            9C4
EXIT_114            9EC
EXIT_118            A3A
EXIT_121            A5E
EXIT_126            AAC
EXIT_128            B1E
EXIT_131            B44
EXIT_136            B92
EXIT_143            C1A
EXIT_145            C6A
EXIT_16             1E0
EXIT_18             232
EXIT_20             262
EXIT_23             28E
EXIT_28             2DC
EXIT_3              EA
EXIT_35             354
EXIT_49             496
EXIT_5              10C
EXIT_8              12E
EXIT_87             83A
EXIT_89             85C
EXIT_93             890
G                   AB0
GET_INPUT           15A
H                   236
HELP                CDF
HEX2BIN             134
HEX2BIN_LUT         E03
HEX_DIGIT           CA2
HUH                 D8F
L                   BA2
LF                  A
LOADING             E1A
LOOP_10             13E
LOOP_101            90E
LOOP_103            938
LOOP_105            978
LOOP_106            95A
LOOP_111            9A8
LOOP_113            9EE
LOOP_114            9D0
LOOP_118            A1E
LOOP_120            A60
LOOP_121            A42
LOOP_126            A90
LOOP_128            B02
LOOP_130            B46
LOOP_131            B28
LOOP_136            B76
LOOP_143            BFE
LOOP_145            C4E
LOOP_16             1C4
LOOP_18             216
LOOP_20             246
LOOP_22             290
LOOP_23             272
LOOP_28             2C0
LOOP_3              CE
LOOP_35             338
LOOP_49             47A
LOOP_5              F0
LOOP_8              112
LOOP_87             81E
LOOP_89             840
LOOP_93             874
MAIN_LOOP           138
NULL                0
OX                  E34
PRINTSTR            246
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
PROMPT              E31
R                   266
RAM                 200000
RAM_ERROR           DE1
READ                D96
READ_CHAR           7D4
READ_DATA_TO_POKE   2E4
RESET               4
ROM                 0
S                   358
STACK               0
START               8
TAB                 9
UNREC               DB8
V                   240
VERSION             CC2
W                   2E0
WAIT_CHAR           625
WAIT_FOR_COMPLETE   C7C
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_102  916
WAIT_FOR_READY_104  940
WAIT_FOR_READY_107  962
WAIT_FOR_READY_109  98C
WAIT_FOR_READY_11   146
WAIT_FOR_READY_112  9B0
WAIT_FOR_READY_115  9D8
WAIT_FOR_READY_117  A02
WAIT_FOR_READY_119  A26
WAIT_FOR_READY_12   15A
WAIT_FOR_READY_122  A4A
WAIT_FOR_READY_124  A74
WAIT_FOR_READY_127  A98
WAIT_FOR_READY_129  B0A
WAIT_FOR_READY_132  B30
WAIT_FOR_READY_134  B5A
WAIT_FOR_READY_137  B7E
WAIT_FOR_READY_138  BAE
WAIT_FOR_READY_14   174
WAIT_FOR_READY_140  BC8
WAIT_FOR_READY_144  C06
WAIT_FOR_READY_146  C56
WAIT_FOR_READY_17   1CC
WAIT_FOR_READY_19   21E
WAIT_FOR_READY_21   24E
WAIT_FOR_READY_24   27A
WAIT_FOR_READY_26   2A4
WAIT_FOR_READY_29   2C8
WAIT_FOR_READY_30   2E6
WAIT_FOR_READY_32   300
WAIT_FOR_READY_36   340
WAIT_FOR_READY_37   360
WAIT_FOR_READY_39   39A
WAIT_FOR_READY_4    D6
WAIT_FOR_READY_40   3B0
WAIT_FOR_READY_42   3E4
WAIT_FOR_READY_44   406
WAIT_FOR_READY_46   43A
WAIT_FOR_READY_50   482
WAIT_FOR_READY_52   4BE
WAIT_FOR_READY_54   4F2
WAIT_FOR_READY_57   532
WAIT_FOR_READY_59   566
WAIT_FOR_READY_6    F8
WAIT_FOR_READY_62   5B0
WAIT_FOR_READY_64   5E4
WAIT_FOR_READY_67   630
WAIT_FOR_READY_69   664
WAIT_FOR_READY_72   6BE
WAIT_FOR_READY_74   6F2
WAIT_FOR_READY_77   732
WAIT_FOR_READY_79   766
WAIT_FOR_READY_82   7A6
WAIT_FOR_READY_84   7DA
WAIT_FOR_READY_88   826
WAIT_FOR_READY_9    11A
WAIT_FOR_READY_90   848
WAIT_FOR_READY_91   85C
WAIT_FOR_READY_94   87C
WAIT_FOR_READY_96   8A2
WAIT_FOR_READY_98   8D6
WAIT_FOR_SRECORD    360
Z                   AB8
_00000000           19A
_00000001           1AE
_00000002           49E
_00000003           894
_00000004           4AC
_00000005           6A6
_00000006           616
_00000007           894
_00000008           818
_00000009           894
_0000000A           9C8
_0000000B           B92
_0000000C           C86
_10000000           3FC
_10000001           466
_10000002           4B4
_10000003           51E
_10000004           528
_10000005           592
_10000006           5A6
_10000007           610
_10000008           61A
_10000009           69E
_1000000A           626
_1000000B           690
_1000000C           6B4
_1000000D           71E
_1000000E           728
_1000000F           792
_10000010           79C
_10000011           806
_10000012           898
_10000013           902
_10000014           C6A
_10000015           C8C
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           AC4
_20000005           AD4
_20000006           AE8
_20000007           B94
_20000008           BAC
_20000009           BF2
