00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08/04/2021 12:12:46

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; don't waste code on reading the srec header - just ignore it
00000000                             9  ; implement DOWNLOAD_BYTE to remove repeated code and shorten the gap between S1 and S2
00000000                            10  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            11  ; tidy up NAND gate invertor and wiring for OE and WE on eeproms
00000000                            12  ; tidy up power loom
00000000                            13  ; increase baud rate x 4?
00000000                            14  ; add LDS and UDS with an OR gate and test because then I can do byte writes and it will make the download simpler
00000000                            15  ; stop using two registers in download
00000000                            16  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            17  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            18  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            19  
00000000                            20  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            21  ; keep track of highest address hit during srec download
00000000                            22  ; fix the reset vector so that it jumps to the start
00000000                            23  ; Replace JMP -> BRA
00000000                            24  ; implement backspace
00000000                            25  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            26  ; fix being able to enter random chars when W'ing
00000000                            27  ; ram check at startup?  Not sure if this is a good idea!
00000000                            28  
00000000                            29      ;ORG  $0
00200000                            30      ORG  $200000
00200000                            31  
00200000  =00000000                 32  DEBUG               EQU 0
00200000                            33  
00200000                            34  ; constants
00200000  =00000000                 35  ROM                 EQU $0
00200000  =00200000                 36  RAM                 EQU $200000
00200000                            37     
00200000  =00C00000                 38  DUART_BASE          EQU $C00000
00200000  =00000000                 39  DUART_MRA_          EQU $0
00200000  =00000001                 40  DUART_CSRA_         EQU $1
00200000  =00000001                 41  DUART_SRA_          EQU $1
00200000  =00000002                 42  DUART_CRA_          EQU $2
00200000  =00000003                 43  DUART_TXA_          EQU $3
00200000  =00000003                 44  DUART_RXA_          EQU $3
00200000  =00000004                 45  DUART_ACR_          EQU $4
00200000  =00000005                 46  DUART_IMR_          EQU $5
00200000  =00000008                 47  DUART_MRB_          EQU $8
00200000  =00000009                 48  DUART_CSRB_         EQU $9
00200000  =00000009                 49  DUART_SRB_          EQU $9
00200000  =0000000A                 50  DUART_CRB_          EQU $A
00200000  =0000000B                 51  DUART_TXB_          EQU $B
00200000  =0000000B                 52  DUART_RXB_          EQU $B
00200000  =0000000C                 53  DUART_IVR_          EQU $C
00200000  =0000000D                 54  DUART_OPCR_         EQU $D
00200000  =0000000E                 55  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 56  DUART_RESET_OPR_    EQU $F
00200000                            57  
00200000  =00C00001                 58  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 59  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 60  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 61  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 62  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 63  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            64  
00200000  =00C00011                 65  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 66  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 67  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 68  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 69  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 70  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            71  
00200000  =00C00009                 72  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 73  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 74  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 75  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 76  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 77  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            78  
00200000  =00E00000                 79  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 80  DISPLAY_            EQU $0
00200000  =00E00001                 81  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            82  
00200000                            83  ; macros
00200000                            84  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            85  ; the input register is changed during the process
00200000                            86  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            87  BIN2HEX MACRO
00200000                            88      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            89      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            90      MOVE.B \1,\2
00200000                            91      ANDI.L #$F,\2
00200000                            92      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            93      ENDM
00200000                            94  
00200000                            95  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            96  ; the input register is changed during the process
00200000                            97  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            98  HEX2BIN MACRO
00200000                            99      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                           100      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                           101      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                           102      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           103      ENDM
00200000                           104  
00200000                           105  ; send a single char to the serial port
00200000                           106  ; \1 = char to send, \2 = data register to use for status poll
00200000                           107  ; will stamp on D0 and D1 in debug mode
00200000                           108  PRINT_CHAR MACRO
00200000                           109  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           110      IFEQ DEBUG
00200000                           111          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           112          BTST #2,\2                              ; check for space to send
00200000                           113          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           114          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           115      ENDC
00200000                           116      
00200000                           117      IFNE DEBUG
00200000                           118          MOVE.B \1,D1
00200000                           119          MOVE.L #6,D0   
00200000                           120          TRAP #15                                ; write to terminal in simulator
00200000                           121      ENDC
00200000                           122  
00200000                           123      ENDM
00200000                           124  
00200000                           125  ; send CR,LF to the serial port
00200000                           126  ; \1 = data register to use for status poll
00200000                           127  PRINT_CRLF MACRO
00200000                           128      PRINT_CHAR #13,\1                           ; CR
00200000                           129      PRINT_CHAR #10,\1                           ; LF
00200000                           130      ENDM
00200000                           131  
00200000                           132  ; send C-style, zero terminated string to the serial port
00200000                           133  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           134  PRINT_STR MACRO
00200000                           135  LOOP\@
00200000                           136      CMP.B #0,(\1)                               ; 0 -> done
00200000                           137      BEQ EXIT\@
00200000                           138      PRINT_CHAR (\1)+,\2
00200000                           139      JMP LOOP\@
00200000                           140  EXIT\@
00200000                           141      ENDM
00200000                           142    
00200000                           143  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           144  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           145  PRINT_REG MACRO
00200000                           146      PRINT_CHAR #'0',\2                          ;0x header
00200000                           147      PRINT_CHAR #'x',\2
00200000                           148      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           149  LOOP\@
00200000                           150      BIN2HEX \1,\3,\5
00200000                           151      PRINT_CHAR \3,\2
00200000                           152      DBEQ \4,LOOP\@
00200000                           153      ENDM
00200000                           154    
00200000                           155  ; wait for a char from the serial port
00200000                           156  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           157  ; will stamp on D0 and D1 in debug mode
00200000                           158  WAIT_CHAR MACRO
00200000                           159  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           160  
00200000                           161      IFEQ DEBUG
00200000                           162          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           163          BTST #0,\2                              ; check for character
00200000                           164          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           165      ENDC
00200000                           166      
00200000                           167      READ_CHAR \1
00200000                           168  
00200000                           169      IFEQ DEBUG
00200000                           170          PRINT_CHAR \1,\2                        ; echo it back
00200000                           171      ENDC
00200000                           172      ENDM
00200000                           173      
00200000                           174  ; read a char from the serial port - assumes that there is one!
00200000                           175  ; \ 1= data register for read char
00200000                           176  ; will stamp on D0 and D1 in debug mode
00200000                           177  READ_CHAR MACRO
00200000                           178      IFEQ DEBUG
00200000                           179          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           180      ENDC
00200000                           181      IFNE DEBUG
00200000                           182          MOVE.L #5,D0    
00200000                           183          TRAP #15                                ; read from keyboard in simulator
00200000                           184          MOVE.L D1,\1
00200000                           185      ENDC
00200000                           186       
00200000                           187      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           188      BEQ START
00200000                           189      ENDM
00200000                           190      
00200000                           191      
00200000                           192  ; read data from the download serial port
00200000                           193  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           194  DOWNLOAD MACRO
00200000                           195  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           196  
00200000                           197      MOVE.B DUART_SRA,\2                         ; check for command
00200000                           198      BTST #0,\2                                  ; check for character
00200000                           199      BEQ CONTINUE\@                              ; nothing, continue
00200000                           200   
00200000                           201      READ_CHAR \1
00200000                           202  CONTINUE\@
00200000                           203      MOVE.B DUART_SRB,\2                         ; read status register
00200000                           204      BTST #0,\2                                  ; check for character
00200000                           205      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           206      
00200000                           207      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           208      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           209      
00200000                           210      ENDM
00200000                           211  
00200000                           212  ; register catalogue
00200000                           213  ; D0 - used for simulator I/O
00200000                           214  ; D1 - used for simulator I/O
00200000                           215  ; D2 - read character
00200000                           216  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           217  ; D4 - count of S records read
00200000                           218  ; D5 - data to write / data read / byte count for S record load
00200000                           219  ; D6 - working register used in R/W and download
00200000                           220  ; D7 - address accumulator / reset by download
00200000                           221  ; A0 - address of string to print 
00200000                           222  
00200000                           223  ; start vector
00200000= 00000000                 224  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 225  RESET    DC.L START                             ; RESET
00200008                           226      
00200008                           227  ; start of program  
00200008                           228  START
00200008  13FC 0000 00E00001       229      MOVE.B #0,DISPLAY
00200010                           230  
00200010                           231  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       232      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       233      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     234      NOP
00200022  13FC 0040 00C00005       235      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     236      NOP
0020002C  13FC 0030 00C00005       237      MOVE.B #$30,DUART_CRA
00200034  4E71                     238      NOP
00200036  13FC 0020 00C00005       239      MOVE.B #$20,DUART_CRA
0020003E  4E71                     240      NOP
00200040  13FC 0010 00C00005       241      MOVE.B #$10,DUART_CRA   
00200048                           242  
00200048  13FC 000A 00C00015       243      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       244      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     245      NOP
0020005A  13FC 0040 00C00015       246      MOVE.B #$40,DUART_CRB           
00200062  4E71                     247      NOP
00200064  13FC 0030 00C00015       248      MOVE.B #$30,DUART_CRB
0020006C  4E71                     249      NOP
0020006E  13FC 0020 00C00015       250      MOVE.B #$20,DUART_CRB
00200076  4E71                     251      NOP
00200078  13FC 0010 00C00015       252      MOVE.B #$10,DUART_CRB   
00200080                           253  
00200080                           254  ;initialise UART
00200080  13FC 0000 00C00009       255      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       256      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       257      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           258  
00200098                           259  ; channel A
00200098  13FC 0013 00C00001       260      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       261      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       262      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       263      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           264  
002000B8                           265  ; channel B
002000B8  13FC 0013 00C00011       266      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       267      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       268      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       269      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           270  
002000D8                           271m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           272m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      273m     IFEQ DEBUG
002000D8  1639 00C00003            274m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                275m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     276m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       277m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           278m     ENDC
002000EC                           279m     
002000EC                 FALSE     280m     IFNE DEBUG
002000EC                           281m     ENDC
002000EC                           282m 
002000EC                           283m     ENDM
002000EC                           284  
002000EC  13FC 0001 00E00001       285      MOVE.B #1,DISPLAY
002000F4                           286         
002000F4                           287m     PRINT_CRLF D3
002000F4                           288mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           289mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      290mm     IFEQ DEBUG
002000F4  1639 00C00003            291mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                292mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     293mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       294mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           295mm     ENDC
00200108                           296mm     
00200108                 FALSE     297mm     IFNE DEBUG
00200108                           298mm     ENDC
00200108                           299mm 
00200108                           300mm     ENDM
00200108                           301mm     PRINT_CHAR #10,D3                           ; LF
00200108                           302mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      303mm     IFEQ DEBUG
00200108  1639 00C00003            304mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                305mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     306mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       307mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           308mm     ENDC
0020011C                           309mm     
0020011C                 FALSE     310mm     IFNE DEBUG
0020011C                           311mm     ENDC
0020011C                           312mm 
0020011C                           313mm     ENDM
0020011C                           314m     ENDM
0020011C                           315  
0020011C  41F9 002019E2            316      LEA VERSION,A0
00200122                           317m     PRINT_STR A0,D3
00200122                           318m LOOP_5
00200122  0C10 0000                319m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                320m     BEQ EXIT_5
0020012A                           321mm     PRINT_CHAR (A0)+,D3
0020012A                           322mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      323mm     IFEQ DEBUG
0020012A  1639 00C00003            324mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                325mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     326mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            327mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           328mm     ENDC
0020013C                           329mm     
0020013C                 FALSE     330mm     IFNE DEBUG
0020013C                           331mm     ENDC
0020013C                           332mm 
0020013C                           333mm     ENDM
0020013C  4EF9 00200122            334m     JMP LOOP_5
00200142                           335m EXIT_5
00200142                           336m     ENDM
00200142                           337m     PRINT_CRLF D3
00200142                           338mm     PRINT_CHAR #13,D3                           ; CR
00200142                           339mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      340mm     IFEQ DEBUG
00200142  1639 00C00003            341mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                342mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     343mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       344mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           345mm     ENDC
00200156                           346mm     
00200156                 FALSE     347mm     IFNE DEBUG
00200156                           348mm     ENDC
00200156                           349mm 
00200156                           350mm     ENDM
00200156                           351mm     PRINT_CHAR #10,D3                           ; LF
00200156                           352mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      353mm     IFEQ DEBUG
00200156  1639 00C00003            354mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                355mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     356mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       357mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           358mm     ENDC
0020016A                           359mm     
0020016A                 FALSE     360mm     IFNE DEBUG
0020016A                           361mm     ENDC
0020016A                           362mm 
0020016A                           363mm     ENDM
0020016A                           364m     ENDM
0020016A                           365m     PRINT_CHAR #7,D3
0020016A                           366m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      367m     IFEQ DEBUG
0020016A  1639 00C00003            368m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                369m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     370m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       371m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           372m     ENDC
0020017E                           373m     
0020017E                 FALSE     374m     IFNE DEBUG
0020017E                           375m     ENDC
0020017E                           376m 
0020017E                           377m     ENDM
0020017E                           378  
0020017E  7E00                     379      MOVE.L #0,D7                                ; address accumulator
00200180                           380  
00200180  13FC 0002 00E00001       381      MOVE.B #2,DISPLAY
00200188                           382  MAIN_LOOP
00200188                           383m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           384m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      385m     IFEQ DEBUG
00200188  1639 00C00003            386m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                387m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     388m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       389m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           390m     ENDC
0020019C                           391m     
0020019C                 FALSE     392m     IFNE DEBUG
0020019C                           393m     ENDC
0020019C                           394m 
0020019C                           395m     ENDM
0020019C                           396m     PRINT_CHAR #32,D3                           ; space
0020019C                           397m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      398m     IFEQ DEBUG
0020019C  1639 00C00003            399m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                400m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     401m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       402m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           403m     ENDC
002001B0                           404m     
002001B0                 FALSE     405m     IFNE DEBUG
002001B0                           406m     ENDC
002001B0                           407m 
002001B0                           408m     ENDM
002001B0                           409      
002001B0                           410  GET_INPUT
002001B0                           411m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           412m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           413m 
002001B0                 TRUE      414m     IFEQ DEBUG
002001B0  1639 00C00003            415m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                416m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     417m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           418m     ENDC
002001BC                           419m     
002001BC                           420mm     READ_CHAR D2
002001BC                 TRUE      421mm     IFEQ DEBUG
002001BC  1439 00C00007            422mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           423mm     ENDC
002001C2                 FALSE     424mm     IFNE DEBUG
002001C2                           425mm     ENDC
002001C2                           426mm      
002001C2  B43C 001B                427mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                428mm     BEQ START
002001CA                           429mm     ENDM
002001CA                           430m 
002001CA                 TRUE      431m     IFEQ DEBUG
002001CA                           432mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           433mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      434mm     IFEQ DEBUG
002001CA  1639 00C00003            435mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                436mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     437mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            438mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           439mm     ENDC
002001DC                           440mm     
002001DC                 FALSE     441mm     IFNE DEBUG
002001DC                           442mm     ENDC
002001DC                           443mm 
002001DC                           444mm     ENDM
002001DC                           445m     ENDC
002001DC                           446m     ENDM
002001DC                           447      
002001DC  B43C 0030                448      CMP.B #'0',D2
002001E0  6700 17DE                449      BEQ HEX_DIGIT
002001E4  B43C 0031                450      CMP.B #'1',D2
002001E8  6700 17D6                451      BEQ HEX_DIGIT
002001EC  B43C 0032                452      CMP.B #'2',D2
002001F0  6700 17CE                453      BEQ HEX_DIGIT
002001F4  B43C 0033                454      CMP.B #'3',D2
002001F8  6700 17C6                455      BEQ HEX_DIGIT
002001FC  B43C 0034                456      CMP.B #'4',D2
00200200  6700 17BE                457      BEQ HEX_DIGIT
00200204  B43C 0035                458      CMP.B #'5',D2
00200208  6700 17B6                459      BEQ HEX_DIGIT
0020020C  B43C 0036                460      CMP.B #'6',D2
00200210  6700 17AE                461      BEQ HEX_DIGIT
00200214  B43C 0037                462      CMP.B #'7',D2
00200218  6700 17A6                463      BEQ HEX_DIGIT
0020021C  B43C 0038                464      CMP.B #'8',D2
00200220  6700 179E                465      BEQ HEX_DIGIT
00200224  B43C 0039                466      CMP.B #'9',D2
00200228  6700 1796                467      BEQ HEX_DIGIT
0020022C  B43C 0041                468      CMP.B #'A',D2
00200230  6700 178E                469      BEQ HEX_DIGIT
00200234  B43C 0042                470      CMP.B #'B',D2
00200238  6700 1786                471      BEQ HEX_DIGIT
0020023C  B43C 0043                472      CMP.B #'C',D2
00200240  6700 177E                473      BEQ HEX_DIGIT
00200244  B43C 0044                474      CMP.B #'D',D2
00200248  6700 1776                475      BEQ HEX_DIGIT
0020024C  B43C 0045                476      CMP.B #'E',D2
00200250  6700 176E                477      BEQ HEX_DIGIT
00200254  B43C 0046                478      CMP.B #'F',D2
00200258  6700 1766                479      BEQ HEX_DIGIT
0020025C                           480      
0020025C  B43C 0057                481      CMP.B #'W',D2
00200260  6700 016E                482      BEQ W
00200264                           483      
00200264  B43C 004C                484      CMP.B #'L',D2
00200268  6700 15E0                485      BEQ L 
0020026C                           486  
0020026C                           487m     PRINT_CRLF D3
0020026C                           488mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           489mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      490mm     IFEQ DEBUG
0020026C  1639 00C00003            491mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                492mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     493mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       494mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           495mm     ENDC
00200280                           496mm     
00200280                 FALSE     497mm     IFNE DEBUG
00200280                           498mm     ENDC
00200280                           499mm 
00200280                           500mm     ENDM
00200280                           501mm     PRINT_CHAR #10,D3                           ; LF
00200280                           502mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      503mm     IFEQ DEBUG
00200280  1639 00C00003            504mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                505mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     506mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       507mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           508mm     ENDC
00200294                           509mm     
00200294                 FALSE     510mm     IFNE DEBUG
00200294                           511mm     ENDC
00200294                           512mm 
00200294                           513mm     ENDM
00200294                           514m     ENDM
00200294                           515   
00200294  B43C 003F                516      CMP.B #'?',D2
00200298  6700 0056                517      BEQ H
0020029C                           518  
0020029C  B43C 0056                519      CMP.B #'V',D2
002002A0  6700 007A                520      BEQ V
002002A4                           521      
002002A4  B43C 0052                522      CMP.B #'R',D2
002002A8  6700 009E                523      BEQ R
002002AC                           524  
002002AC  B43C 0053                525      CMP.B #'S',D2
002002B0  6700 01E6                526      BEQ S
002002B4                           527  
002002B4  B43C 0047                528      CMP.B #'G',D2
002002B8  6700 147C                529      BEQ G   
002002BC                           530  
002002BC  B43C 005A                531      CMP.B #'Z',D2
002002C0  6700 147C                532      BEQ Z   
002002C4                           533  
002002C4  41F9 00201A96            534      LEA HUH,A0
002002CA                           535m     PRINT_STR A0,D3
002002CA                           536m LOOP_19
002002CA  0C10 0000                537m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                538m     BEQ EXIT_19
002002D2                           539mm     PRINT_CHAR (A0)+,D3
002002D2                           540mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      541mm     IFEQ DEBUG
002002D2  1639 00C00003            542mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                543mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     544mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            545mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           546mm     ENDC
002002E4                           547mm     
002002E4                 FALSE     548mm     IFNE DEBUG
002002E4                           549mm     ENDC
002002E4                           550mm 
002002E4                           551mm     ENDM
002002E4  4EF9 002002CA            552m     JMP LOOP_19
002002EA                           553m EXIT_19
002002EA                           554m     ENDM
002002EA                           555                         
002002EA  4EF9 00200188            556      JMP MAIN_LOOP
002002F0                           557      
002002F0                           558  ; commands
002002F0                           559  H   
002002F0  41F9 002019FF            560      LEA HELP,A0
002002F6                           561m     PRINT_STR A0,D3
002002F6                           562m LOOP_21
002002F6  0C10 0000                563m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                564m     BEQ EXIT_21
002002FE                           565mm     PRINT_CHAR (A0)+,D3
002002FE                           566mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      567mm     IFEQ DEBUG
002002FE  1639 00C00003            568mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                569mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     570mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            571mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           572mm     ENDC
00200310                           573mm     
00200310                 FALSE     574mm     IFNE DEBUG
00200310                           575mm     ENDC
00200310                           576mm 
00200310                           577mm     ENDM
00200310  4EF9 002002F6            578m     JMP LOOP_21
00200316                           579m EXIT_21
00200316                           580m     ENDM
00200316  4EF9 00200188            581      JMP MAIN_LOOP
0020031C                           582  
0020031C                           583  V   
0020031C  41F9 002019E2            584      LEA VERSION,A0
00200322                           585m     PRINT_STR A0,D3       
00200322                           586m LOOP_23
00200322  0C10 0000                587m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                588m     BEQ EXIT_23
0020032A                           589mm     PRINT_CHAR (A0)+,D3
0020032A                           590mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      591mm     IFEQ DEBUG
0020032A  1639 00C00003            592mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                593mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     594mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            595mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           596mm     ENDC
0020033C                           597mm     
0020033C                 FALSE     598mm     IFNE DEBUG
0020033C                           599mm     ENDC
0020033C                           600mm 
0020033C                           601mm     ENDM
0020033C  4EF9 00200322            602m     JMP LOOP_23
00200342                           603m EXIT_23
00200342                           604m     ENDM
00200342  4EF9 00200188            605      JMP MAIN_LOOP
00200348                           606      
00200348                           607  R   
00200348  2047                     608      MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     609      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           610m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           611mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           612mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      613mm     IFEQ DEBUG
0020034C  1639 00C00003            614mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                615mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     616mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       617mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           618mm     ENDC
00200360                           619mm     
00200360                 FALSE     620mm     IFNE DEBUG
00200360                           621mm     ENDC
00200360                           622mm 
00200360                           623mm     ENDM
00200360                           624mm     PRINT_CHAR #'x',D3
00200360                           625mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      626mm     IFEQ DEBUG
00200360  1639 00C00003            627mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                628mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     629mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       630mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           631mm     ENDC
00200374                           632mm     
00200374                 FALSE     633mm     IFNE DEBUG
00200374                           634mm     ENDC
00200374                           635mm 
00200374                           636mm     ENDM
00200374  7C07                     637m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           638m LOOP_25
00200376                           639mm     BIN2HEX D5,D7,A0
00200376  41F9 00201AFA            640mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     641mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     642mm     MOVE.B D5,D7
00200380  0287 0000000F            643mm     ANDI.L #$F,D7
00200386  1E30 7000                644mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           645mm     ENDM
0020038A                           646mm     PRINT_CHAR D7,D3
0020038A                           647mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      648mm     IFEQ DEBUG
0020038A  1639 00C00003            649mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                650mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     651mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            652mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           653mm     ENDC
0020039C                           654mm     
0020039C                 FALSE     655mm     IFNE DEBUG
0020039C                           656mm     ENDC
0020039C                           657mm 
0020039C                           658mm     ENDM
0020039C  57CE FFD8                659m     DBEQ D6,LOOP_25
002003A0                           660m     ENDM
002003A0                           661m     PRINT_CRLF D3
002003A0                           662mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           663mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      664mm     IFEQ DEBUG
002003A0  1639 00C00003            665mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                666mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     667mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       668mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           669mm     ENDC
002003B4                           670mm     
002003B4                 FALSE     671mm     IFNE DEBUG
002003B4                           672mm     ENDC
002003B4                           673mm 
002003B4                           674mm     ENDM
002003B4                           675mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           676mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      677mm     IFEQ DEBUG
002003B4  1639 00C00003            678mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                679mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     680mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       681mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           682mm     ENDC
002003C8                           683mm     
002003C8                 FALSE     684mm     IFNE DEBUG
002003C8                           685mm     ENDC
002003C8                           686mm 
002003C8                           687mm     ENDM
002003C8                           688m     ENDM
002003C8  7E00                     689      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            690      JMP MAIN_LOOP
002003D0                           691  
002003D0                           692  W
002003D0  7A00                     693      MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           694  
002003D2                           695m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           696m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           697m 
002003D2                 TRUE      698m     IFEQ DEBUG
002003D2  1639 00C00003            699m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                700m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     701m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           702m     ENDC
002003DE                           703m     
002003DE                           704mm     READ_CHAR D2
002003DE                 TRUE      705mm     IFEQ DEBUG
002003DE  1439 00C00007            706mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           707mm     ENDC
002003E4                 FALSE     708mm     IFNE DEBUG
002003E4                           709mm     ENDC
002003E4                           710mm      
002003E4  B43C 001B                711mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                712mm     BEQ START
002003EC                           713mm     ENDM
002003EC                           714m 
002003EC                 TRUE      715m     IFEQ DEBUG
002003EC                           716mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           717mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      718mm     IFEQ DEBUG
002003EC  1639 00C00003            719mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                720mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     721mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            722mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           723mm     ENDC
002003FE                           724mm     
002003FE                 FALSE     725mm     IFNE DEBUG
002003FE                           726mm     ENDC
002003FE                           727mm 
002003FE                           728mm     ENDM
002003FE                           729m     ENDC
002003FE                           730m     ENDM
002003FE                           731m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 00201B0A            732m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                733m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            734m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                735m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           736m     ENDM
00200412  1A02                     737      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           738  
00200414  3C3C 0006                739      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           740      
00200418                           741  READ_DATA_TO_POKE
00200418  E98D                     742      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           743m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           744m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           745m 
0020041A                 TRUE      746m     IFEQ DEBUG
0020041A  1639 00C00003            747m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                748m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     749m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           750m     ENDC
00200426                           751m     
00200426                           752mm     READ_CHAR D2
00200426                 TRUE      753mm     IFEQ DEBUG
00200426  1439 00C00007            754mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           755mm     ENDC
0020042C                 FALSE     756mm     IFNE DEBUG
0020042C                           757mm     ENDC
0020042C                           758mm      
0020042C  B43C 001B                759mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                760mm     BEQ START
00200434                           761mm     ENDM
00200434                           762m 
00200434                 TRUE      763m     IFEQ DEBUG
00200434                           764mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           765mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      766mm     IFEQ DEBUG
00200434  1639 00C00003            767mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                768mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     769mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            770mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           771mm     ENDC
00200446                           772mm     
00200446                 FALSE     773mm     IFNE DEBUG
00200446                           774mm     ENDC
00200446                           775mm 
00200446                           776mm     ENDM
00200446                           777m     ENDC
00200446                           778m     ENDM
00200446                           779m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 00201B0A            780m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                781m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            782m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                783m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           784m     ENDM
0020045A  8A02                     785      OR.B D2,D5
0020045C  023C 00FB                786      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                787      DBEQ D6,READ_DATA_TO_POKE
00200464                           788      
00200464  2047                     789      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     790      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           791      
00200468  2085                     792      MOVE.L D5,(A0)                              ; write the data
0020046A                           793  
0020046A                           794m     PRINT_CRLF D3
0020046A                           795mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           796mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      797mm     IFEQ DEBUG
0020046A  1639 00C00003            798mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                799mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     800mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       801mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           802mm     ENDC
0020047E                           803mm     
0020047E                 FALSE     804mm     IFNE DEBUG
0020047E                           805mm     ENDC
0020047E                           806mm 
0020047E                           807mm     ENDM
0020047E                           808mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           809mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      810mm     IFEQ DEBUG
0020047E  1639 00C00003            811mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                812mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     813mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       814mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           815mm     ENDC
00200492                           816mm     
00200492                 FALSE     817mm     IFNE DEBUG
00200492                           818mm     ENDC
00200492                           819mm 
00200492                           820mm     ENDM
00200492                           821m     ENDM
00200492  4EF9 00200188            822      JMP MAIN_LOOP
00200498                           823  
00200498                           824          
00200498                           825  S
00200498  2647                     826      MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     827      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                828      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           829      
002004A0                           830  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           831m     DOWNLOAD D2,D3                  
002004A0                           832m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           833m 
002004A0  1639 00C00003            834m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004A6  0803 0000                835m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                836m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           837m  
002004AE                           838mm     READ_CHAR D2
002004AE                 TRUE      839mm     IFEQ DEBUG
002004AE  1439 00C00007            840mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           841mm     ENDC
002004B4                 FALSE     842mm     IFNE DEBUG
002004B4                           843mm     ENDC
002004B4                           844mm      
002004B4  B43C 001B                845mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                846mm     BEQ START
002004BC                           847mm     ENDM
002004BC                           848m CONTINUE_44
002004BC  1639 00C00013            849m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002004C2  0803 0000                850m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004C6  67D8                     851m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           852m     
002004C8  1439 00C00017            853m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            854m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           855m     
002004D4                           856m     ENDM
002004D4  B43C 0053                857      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     858      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           859      
002004DA  5284                     860      ADD.L #1,D4                                 ; read another S record, increment count
002004DC                           861      
002004DC                           862m     DOWNLOAD D7,D3                              ; read the record digit
002004DC                           863m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DC                           864m 
002004DC  1639 00C00003            865m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004E2  0803 0000                866m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004E6  6700 0010                867m     BEQ CONTINUE_46                             ; NOTHING, CONTINUE
002004EA                           868m  
002004EA                           869mm     READ_CHAR D7
002004EA                 TRUE      870mm     IFEQ DEBUG
002004EA  1E39 00C00007            871mm         MOVE.B DUART_RXA,D7                     ; GOT A CHARACTER, READ IT
002004F0                           872mm     ENDC
002004F0                 FALSE     873mm     IFNE DEBUG
002004F0                           874mm     ENDC
002004F0                           875mm      
002004F0  BE3C 001B                876mm     CMP.B #$1B,D7                               ; CHECK FOR ESCAPE AND GO TO START
002004F4  6700 FB12                877mm     BEQ START
002004F8                           878mm     ENDM
002004F8                           879m CONTINUE_46
002004F8  1639 00C00013            880m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002004FE  0803 0000                881m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200502  67D8                     882m     BEQ WAIT_FOR_READY_46                       ; NOTHING, CHECK AGAIN
00200504                           883m     
00200504  1E39 00C00017            884m     MOVE.B DUART_RXB,D7                         ; GOT A CHARACTER, READ IT
0020050A  13C7 00E00001            885m     MOVE.B D7,DISPLAY                           ; ECHO TO THE DISPLAY
00200510                           886m     
00200510                           887m     ENDM
00200510                           888  
00200510  7C00                     889      MOVE.L #0,D6                                ; checksum
00200512                           890  
00200512  7A00                     891      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00200514                           892m     DOWNLOAD D2,D3              
00200514                           893m WAIT_FOR_READY_48                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                           894m 
00200514  1639 00C00003            895m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020051A  0803 0000                896m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020051E  6700 0010                897m     BEQ CONTINUE_48                             ; NOTHING, CONTINUE
00200522                           898m  
00200522                           899mm     READ_CHAR D2
00200522                 TRUE      900mm     IFEQ DEBUG
00200522  1439 00C00007            901mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200528                           902mm     ENDC
00200528                 FALSE     903mm     IFNE DEBUG
00200528                           904mm     ENDC
00200528                           905mm      
00200528  B43C 001B                906mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020052C  6700 FADA                907mm     BEQ START
00200530                           908mm     ENDM
00200530                           909m CONTINUE_48
00200530  1639 00C00013            910m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200536  0803 0000                911m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020053A  67D8                     912m     BEQ WAIT_FOR_READY_48                       ; NOTHING, CHECK AGAIN
0020053C                           913m     
0020053C  1439 00C00017            914m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200542  13C2 00E00001            915m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200548                           916m     
00200548                           917m     ENDM
00200548                           918m     HEX2BIN D2,D2,A0
00200548  41F9 00201B0A            919m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020054E  0402 0030                920m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200552  C4BC 000000FF            921m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200558  1430 2000                922m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020055C                           923m     ENDM
0020055C  8A82                     924      OR.L D2,D5
0020055E  E98D                     925      LSL.L #4,D5    
00200560                           926m     DOWNLOAD D2,D3
00200560                           927m WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200560                           928m 
00200560  1639 00C00003            929m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200566  0803 0000                930m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020056A  6700 0010                931m     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0020056E                           932m  
0020056E                           933mm     READ_CHAR D2
0020056E                 TRUE      934mm     IFEQ DEBUG
0020056E  1439 00C00007            935mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200574                           936mm     ENDC
00200574                 FALSE     937mm     IFNE DEBUG
00200574                           938mm     ENDC
00200574                           939mm      
00200574  B43C 001B                940mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200578  6700 FA8E                941mm     BEQ START
0020057C                           942mm     ENDM
0020057C                           943m CONTINUE_51
0020057C  1639 00C00013            944m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200582  0803 0000                945m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200586  67D8                     946m     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200588                           947m     
00200588  1439 00C00017            948m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020058E  13C2 00E00001            949m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200594                           950m     
00200594                           951m     ENDM
00200594                           952m     HEX2BIN D2,D2,A0  
00200594  41F9 00201B0A            953m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020059A  0402 0030                954m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020059E  C4BC 000000FF            955m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005A4  1430 2000                956m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005A8                           957m     ENDM
002005A8  8A82                     958      OR.L D2,D5
002005AA                           959                  
002005AA  DC85                     960      ADD.L D5,D6                                 ; add byte count into checksum
002005AC                           961  
002005AC                           962      IF.B D7 <EQ> #'0' THEN.L                    ; header
002005AC  BE3C 0030                963s     CMP.B   #'0',D7
002005B0  6600 022A                964s     BNE.L   _00000000
002005B4  7E00                     965          MOVE.L #0,D7                            ; read the 16 bit address, just checksum and then ignore
002005B6                           966m         DOWNLOAD D2,D3                          ; top byte
002005B6                           967m WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B6                           968m 
002005B6  1639 00C00003            969m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002005BC  0803 0000                970m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005C0  6700 0010                971m     BEQ CONTINUE_54                             ; NOTHING, CONTINUE
002005C4                           972m  
002005C4                           973mm     READ_CHAR D2
002005C4                 TRUE      974mm     IFEQ DEBUG
002005C4  1439 00C00007            975mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002005CA                           976mm     ENDC
002005CA                 FALSE     977mm     IFNE DEBUG
002005CA                           978mm     ENDC
002005CA                           979mm      
002005CA  B43C 001B                980mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002005CE  6700 FA38                981mm     BEQ START
002005D2                           982mm     ENDM
002005D2                           983m CONTINUE_54
002005D2  1639 00C00013            984m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002005D8  0803 0000                985m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005DC  67D8                     986m     BEQ WAIT_FOR_READY_54                       ; NOTHING, CHECK AGAIN
002005DE                           987m     
002005DE  1439 00C00017            988m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002005E4  13C2 00E00001            989m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002005EA                           990m     
002005EA                           991m     ENDM
002005EA                           992m         HEX2BIN D2,D2,A0
002005EA  41F9 00201B0A            993m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002005F0  0402 0030                994m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005F4  C4BC 000000FF            995m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005FA  1430 2000                996m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005FE                           997m     ENDM
002005FE  8E82                     998          OR.L D2,D7
00200600  E98F                     999          LSL.L #4,D7
00200602                          1000m         DOWNLOAD D2,D3         
00200602                          1001m WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200602                          1002m 
00200602  1639 00C00003           1003m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200608  0803 0000               1004m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020060C  6700 0010               1005m     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00200610                          1006m  
00200610                          1007mm     READ_CHAR D2
00200610                 TRUE     1008mm     IFEQ DEBUG
00200610  1439 00C00007           1009mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200616                          1010mm     ENDC
00200616                 FALSE    1011mm     IFNE DEBUG
00200616                          1012mm     ENDC
00200616                          1013mm      
00200616  B43C 001B               1014mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020061A  6700 F9EC               1015mm     BEQ START
0020061E                          1016mm     ENDM
0020061E                          1017m CONTINUE_57
0020061E  1639 00C00013           1018m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200624  0803 0000               1019m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200628  67D8                    1020m     BEQ WAIT_FOR_READY_57                       ; NOTHING, CHECK AGAIN
0020062A                          1021m     
0020062A  1439 00C00017           1022m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200630  13C2 00E00001           1023m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200636                          1024m     
00200636                          1025m     ENDM
00200636                          1026m         HEX2BIN D2,D2,A0
00200636  41F9 00201B0A           1027m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020063C  0402 0030               1028m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200640  C4BC 000000FF           1029m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200646  1430 2000               1030m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020064A                          1031m     ENDM
0020064A  8E82                    1032          OR.L D2,D7
0020064C                          1033          
0020064C  DC87                    1034          ADD.L D7,D6                             ; add top byte of address into checksum
0020064E                          1035  
0020064E  E98F                    1036          LSL.L #4,D7                             ; bottom byte
00200650                          1037m         DOWNLOAD D2,D3
00200650                          1038m WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200650                          1039m 
00200650  1639 00C00003           1040m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200656  0803 0000               1041m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020065A  6700 0010               1042m     BEQ CONTINUE_60                             ; NOTHING, CONTINUE
0020065E                          1043m  
0020065E                          1044mm     READ_CHAR D2
0020065E                 TRUE     1045mm     IFEQ DEBUG
0020065E  1439 00C00007           1046mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200664                          1047mm     ENDC
00200664                 FALSE    1048mm     IFNE DEBUG
00200664                          1049mm     ENDC
00200664                          1050mm      
00200664  B43C 001B               1051mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200668  6700 F99E               1052mm     BEQ START
0020066C                          1053mm     ENDM
0020066C                          1054m CONTINUE_60
0020066C  1639 00C00013           1055m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200672  0803 0000               1056m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200676  67D8                    1057m     BEQ WAIT_FOR_READY_60                       ; NOTHING, CHECK AGAIN
00200678                          1058m     
00200678  1439 00C00017           1059m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020067E  13C2 00E00001           1060m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200684                          1061m     
00200684                          1062m     ENDM
00200684                          1063m         HEX2BIN D2,D2,A0
00200684  41F9 00201B0A           1064m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020068A  0402 0030               1065m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020068E  C4BC 000000FF           1066m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200694  1430 2000               1067m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200698                          1068m     ENDM
00200698  8E82                    1069          OR.L D2,D7
0020069A  E98F                    1070          LSL.L #4,D7        
0020069C                          1071m         DOWNLOAD D2,D3
0020069C                          1072m WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020069C                          1073m 
0020069C  1639 00C00003           1074m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002006A2  0803 0000               1075m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006A6  6700 0010               1076m     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
002006AA                          1077m  
002006AA                          1078mm     READ_CHAR D2
002006AA                 TRUE     1079mm     IFEQ DEBUG
002006AA  1439 00C00007           1080mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002006B0                          1081mm     ENDC
002006B0                 FALSE    1082mm     IFNE DEBUG
002006B0                          1083mm     ENDC
002006B0                          1084mm      
002006B0  B43C 001B               1085mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002006B4  6700 F952               1086mm     BEQ START
002006B8                          1087mm     ENDM
002006B8                          1088m CONTINUE_63
002006B8  1639 00C00013           1089m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002006BE  0803 0000               1090m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006C2  67D8                    1091m     BEQ WAIT_FOR_READY_63                       ; NOTHING, CHECK AGAIN
002006C4                          1092m     
002006C4  1439 00C00017           1093m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006CA  13C2 00E00001           1094m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006D0                          1095m     
002006D0                          1096m     ENDM
002006D0                          1097m         HEX2BIN D2,D2,A0
002006D0  41F9 00201B0A           1098m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006D6  0402 0030               1099m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006DA  C4BC 000000FF           1100m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006E0  1430 2000               1101m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006E4                          1102m     ENDM
002006E4  8E82                    1103          OR.L D2,D7
002006E6                          1104          
002006E6  7400                    1105          MOVE.L #0,D2                            ; rextract bottom byte of address and add into checksum
002006E8  1407                    1106          MOVE.B D7,D2
002006EA  DC82                    1107          ADD.L D2,D6
002006EC                          1108          
002006EC  5785                    1109          SUB.L #3,D5                             ; subtract three bytes for 16 bit address and 1 byte checksum
002006EE                          1110          WHILE.L D5 <GT> #0 DO                   ; read the data bytes
002006EE                          1111s _10000000
002006EE  BABC 00000000           1112s     CMP.L   #0,D5
002006F4  6F00 00B4               1113s     BLE _10000001
002006F8  5385                    1114              SUB.L #1,D5
002006FA                          1115              
002006FA  7E00                    1116              MOVE.L #0,D7                        ; D7 holds the byte
002006FC                          1117              
002006FC                          1118m             DOWNLOAD D2,D3                      ; MS 4 bits
002006FC                          1119m WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006FC                          1120m 
002006FC  1639 00C00003           1121m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200702  0803 0000               1122m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200706  6700 0010               1123m     BEQ CONTINUE_66                             ; NOTHING, CONTINUE
0020070A                          1124m  
0020070A                          1125mm     READ_CHAR D2
0020070A                 TRUE     1126mm     IFEQ DEBUG
0020070A  1439 00C00007           1127mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200710                          1128mm     ENDC
00200710                 FALSE    1129mm     IFNE DEBUG
00200710                          1130mm     ENDC
00200710                          1131mm      
00200710  B43C 001B               1132mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200714  6700 F8F2               1133mm     BEQ START
00200718                          1134mm     ENDM
00200718                          1135m CONTINUE_66
00200718  1639 00C00013           1136m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020071E  0803 0000               1137m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200722  67D8                    1138m     BEQ WAIT_FOR_READY_66                       ; NOTHING, CHECK AGAIN
00200724                          1139m     
00200724  1439 00C00017           1140m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020072A  13C2 00E00001           1141m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200730                          1142m     
00200730                          1143m     ENDM
00200730                          1144m             HEX2BIN D2,D2,A0
00200730  41F9 00201B0A           1145m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200736  0402 0030               1146m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020073A  C4BC 000000FF           1147m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200740  1430 2000               1148m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200744                          1149m     ENDM
00200744  8E82                    1150              OR.L D2,D7
00200746  E98F                    1151              LSL.L #4,D7
00200748                          1152               
00200748                          1153m             DOWNLOAD D2,D3                      ; LS 4 bits    
00200748                          1154m WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200748                          1155m 
00200748  1639 00C00003           1156m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020074E  0803 0000               1157m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200752  6700 0010               1158m     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00200756                          1159m  
00200756                          1160mm     READ_CHAR D2
00200756                 TRUE     1161mm     IFEQ DEBUG
00200756  1439 00C00007           1162mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020075C                          1163mm     ENDC
0020075C                 FALSE    1164mm     IFNE DEBUG
0020075C                          1165mm     ENDC
0020075C                          1166mm      
0020075C  B43C 001B               1167mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200760  6700 F8A6               1168mm     BEQ START
00200764                          1169mm     ENDM
00200764                          1170m CONTINUE_69
00200764  1639 00C00013           1171m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020076A  0803 0000               1172m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020076E  67D8                    1173m     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00200770                          1174m     
00200770  1439 00C00017           1175m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200776  13C2 00E00001           1176m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020077C                          1177m     
0020077C                          1178m     ENDM
0020077C                          1179m             HEX2BIN D2,D2,A0
0020077C  41F9 00201B0A           1180m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200782  0402 0030               1181m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200786  C4BC 000000FF           1182m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020078C  1430 2000               1183m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200790                          1184m     ENDM
00200790  8E82                    1185              OR.L D2,D7
00200792                          1186              
00200792  DC87                    1187              ADD.L D7,D6                         ; add into checksum
00200794                          1188            
00200794                          1189m             PRINT_CHAR D7,D3                    ; assume ASCII and print it
00200794                          1190m WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200794                 TRUE     1191m     IFEQ DEBUG
00200794  1639 00C00003           1192m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020079A  0803 0002               1193m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020079E  67F4                    1194m         BEQ WAIT_FOR_READY_72                   ; NO SPACE, CHECK AGAIN
002007A0  13C7 00C00007           1195m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007A6                          1196m     ENDC
002007A6                          1197m     
002007A6                 FALSE    1198m     IFNE DEBUG
002007A6                          1199m     ENDC
002007A6                          1200m 
002007A6                          1201m     ENDM
002007A6                          1202          ENDW
002007A6  6000 FF46               1203s     BRA _10000000
002007AA                          1204s _10000001
002007AA                          1205m         PRINT_CRLF D3
002007AA                          1206mm     PRINT_CHAR #13,D3                           ; CR
002007AA                          1207mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007AA                 TRUE     1208mm     IFEQ DEBUG
002007AA  1639 00C00003           1209mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007B0  0803 0002               1210mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007B4  67F4                    1211mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
002007B6  13FC 000D 00C00007      1212mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002007BE                          1213mm     ENDC
002007BE                          1214mm     
002007BE                 FALSE    1215mm     IFNE DEBUG
002007BE                          1216mm     ENDC
002007BE                          1217mm 
002007BE                          1218mm     ENDM
002007BE                          1219mm     PRINT_CHAR #10,D3                           ; LF
002007BE                          1220mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007BE                 TRUE     1221mm     IFEQ DEBUG
002007BE  1639 00C00003           1222mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007C4  0803 0002               1223mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007C8  67F4                    1224mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
002007CA  13FC 000A 00C00007      1225mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002007D2                          1226mm     ENDC
002007D2                          1227mm     
002007D2                 FALSE    1228mm     IFNE DEBUG
002007D2                          1229mm     ENDC
002007D2                          1230mm 
002007D2                          1231mm     ENDM
002007D2                          1232m     ENDM
002007D2  43F9 002004A0           1233         LEA WAIT_FOR_SRECORD,A1            
002007D8                          1234      ELSE
002007D8  6000 0D0E               1235s     BRA _00000001
002007DC                          1236s _00000000
002007DC                          1237          IF.B D7 <EQ> #'1' THEN.L                ; 16 bit address data record
002007DC  BE3C 0031               1238s     CMP.B   #'1',D7
002007E0  6600 04F6               1239s     BNE.L   _00000002
002007E4  7E00                    1240              MOVE.L #0,D7                        ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007E6                          1241m             DOWNLOAD D2,D3                      ; top byte
002007E6                          1242m WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007E6                          1243m 
002007E6  1639 00C00003           1244m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002007EC  0803 0000               1245m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002007F0  6700 0010               1246m     BEQ CONTINUE_76                             ; NOTHING, CONTINUE
002007F4                          1247m  
002007F4                          1248mm     READ_CHAR D2
002007F4                 TRUE     1249mm     IFEQ DEBUG
002007F4  1439 00C00007           1250mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002007FA                          1251mm     ENDC
002007FA                 FALSE    1252mm     IFNE DEBUG
002007FA                          1253mm     ENDC
002007FA                          1254mm      
002007FA  B43C 001B               1255mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002007FE  6700 F808               1256mm     BEQ START
00200802                          1257mm     ENDM
00200802                          1258m CONTINUE_76
00200802  1639 00C00013           1259m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200808  0803 0000               1260m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020080C  67D8                    1261m     BEQ WAIT_FOR_READY_76                       ; NOTHING, CHECK AGAIN
0020080E                          1262m     
0020080E  1439 00C00017           1263m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200814  13C2 00E00001           1264m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020081A                          1265m     
0020081A                          1266m     ENDM
0020081A                          1267m             PRINT_CHAR D2,D3
0020081A                          1268m WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020081A                 TRUE     1269m     IFEQ DEBUG
0020081A  1639 00C00003           1270m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200820  0803 0002               1271m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200824  67F4                    1272m         BEQ WAIT_FOR_READY_78                   ; NO SPACE, CHECK AGAIN
00200826  13C2 00C00007           1273m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020082C                          1274m     ENDC
0020082C                          1275m     
0020082C                 FALSE    1276m     IFNE DEBUG
0020082C                          1277m     ENDC
0020082C                          1278m 
0020082C                          1279m     ENDM
0020082C                          1280m             HEX2BIN D2,D2,A0
0020082C  41F9 00201B0A           1281m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200832  0402 0030               1282m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200836  C4BC 000000FF           1283m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020083C  1430 2000               1284m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200840                          1285m     ENDM
00200840  8E82                    1286              OR.L D2,D7
00200842  E98F                    1287              LSL.L #4,D7
00200844                          1288m             DOWNLOAD D2,D3         
00200844                          1289m WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200844                          1290m 
00200844  1639 00C00003           1291m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020084A  0803 0000               1292m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020084E  6700 0010               1293m     BEQ CONTINUE_80                             ; NOTHING, CONTINUE
00200852                          1294m  
00200852                          1295mm     READ_CHAR D2
00200852                 TRUE     1296mm     IFEQ DEBUG
00200852  1439 00C00007           1297mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200858                          1298mm     ENDC
00200858                 FALSE    1299mm     IFNE DEBUG
00200858                          1300mm     ENDC
00200858                          1301mm      
00200858  B43C 001B               1302mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020085C  6700 F7AA               1303mm     BEQ START
00200860                          1304mm     ENDM
00200860                          1305m CONTINUE_80
00200860  1639 00C00013           1306m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200866  0803 0000               1307m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020086A  67D8                    1308m     BEQ WAIT_FOR_READY_80                       ; NOTHING, CHECK AGAIN
0020086C                          1309m     
0020086C  1439 00C00017           1310m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200872  13C2 00E00001           1311m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200878                          1312m     
00200878                          1313m     ENDM
00200878                          1314m             PRINT_CHAR D2,D3
00200878                          1315m WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1316m     IFEQ DEBUG
00200878  1639 00C00003           1317m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020087E  0803 0002               1318m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200882  67F4                    1319m         BEQ WAIT_FOR_READY_82                   ; NO SPACE, CHECK AGAIN
00200884  13C2 00C00007           1320m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020088A                          1321m     ENDC
0020088A                          1322m     
0020088A                 FALSE    1323m     IFNE DEBUG
0020088A                          1324m     ENDC
0020088A                          1325m 
0020088A                          1326m     ENDM
0020088A                          1327m             HEX2BIN D2,D2,A0
0020088A  41F9 00201B0A           1328m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200890  0402 0030               1329m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200894  C4BC 000000FF           1330m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020089A  1430 2000               1331m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020089E                          1332m     ENDM
0020089E  8E82                    1333              OR.L D2,D7
002008A0                          1334          
002008A0  DC87                    1335              ADD.L D7,D6                         ; add top byte of address into checksum
002008A2                          1336  
002008A2  E98F                    1337              LSL.L #4,D7                         ; bottom byte
002008A4                          1338m             DOWNLOAD D2,D3
002008A4                          1339m WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A4                          1340m 
002008A4  1639 00C00003           1341m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002008AA  0803 0000               1342m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008AE  6700 0010               1343m     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
002008B2                          1344m  
002008B2                          1345mm     READ_CHAR D2
002008B2                 TRUE     1346mm     IFEQ DEBUG
002008B2  1439 00C00007           1347mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008B8                          1348mm     ENDC
002008B8                 FALSE    1349mm     IFNE DEBUG
002008B8                          1350mm     ENDC
002008B8                          1351mm      
002008B8  B43C 001B               1352mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002008BC  6700 F74A               1353mm     BEQ START
002008C0                          1354mm     ENDM
002008C0                          1355m CONTINUE_84
002008C0  1639 00C00013           1356m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002008C6  0803 0000               1357m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008CA  67D8                    1358m     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
002008CC                          1359m     
002008CC  1439 00C00017           1360m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008D2  13C2 00E00001           1361m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008D8                          1362m     
002008D8                          1363m     ENDM
002008D8                          1364m             PRINT_CHAR D2,D3
002008D8                          1365m WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1366m     IFEQ DEBUG
002008D8  1639 00C00003           1367m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008DE  0803 0002               1368m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1369m         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008E4  13C2 00C00007           1370m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008EA                          1371m     ENDC
002008EA                          1372m     
002008EA                 FALSE    1373m     IFNE DEBUG
002008EA                          1374m     ENDC
002008EA                          1375m 
002008EA                          1376m     ENDM
002008EA                          1377m             HEX2BIN D2,D2,A0
002008EA  41F9 00201B0A           1378m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008F0  0402 0030               1379m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F4  C4BC 000000FF           1380m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008FA  1430 2000               1381m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008FE                          1382m     ENDM
002008FE  8E82                    1383              OR.L D2,D7
00200900  E98F                    1384              LSL.L #4,D7        
00200902                          1385m             DOWNLOAD D2,D3
00200902                          1386m WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200902                          1387m 
00200902  1639 00C00003           1388m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200908  0803 0000               1389m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020090C  6700 0010               1390m     BEQ CONTINUE_88                             ; NOTHING, CONTINUE
00200910                          1391m  
00200910                          1392mm     READ_CHAR D2
00200910                 TRUE     1393mm     IFEQ DEBUG
00200910  1439 00C00007           1394mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200916                          1395mm     ENDC
00200916                 FALSE    1396mm     IFNE DEBUG
00200916                          1397mm     ENDC
00200916                          1398mm      
00200916  B43C 001B               1399mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020091A  6700 F6EC               1400mm     BEQ START
0020091E                          1401mm     ENDM
0020091E                          1402m CONTINUE_88
0020091E  1639 00C00013           1403m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200924  0803 0000               1404m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200928  67D8                    1405m     BEQ WAIT_FOR_READY_88                       ; NOTHING, CHECK AGAIN
0020092A                          1406m     
0020092A  1439 00C00017           1407m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200930  13C2 00E00001           1408m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200936                          1409m     
00200936                          1410m     ENDM
00200936                          1411m             PRINT_CHAR D2,D3
00200936                          1412m WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200936                 TRUE     1413m     IFEQ DEBUG
00200936  1639 00C00003           1414m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020093C  0803 0002               1415m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200940  67F4                    1416m         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00200942  13C2 00C00007           1417m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200948                          1418m     ENDC
00200948                          1419m     
00200948                 FALSE    1420m     IFNE DEBUG
00200948                          1421m     ENDC
00200948                          1422m 
00200948                          1423m     ENDM
00200948                          1424m             HEX2BIN D2,D2,A0
00200948  41F9 00201B0A           1425m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020094E  0402 0030               1426m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200952  C4BC 000000FF           1427m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200958  1430 2000               1428m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020095C                          1429m     ENDM
0020095C  8E82                    1430              OR.L D2,D7
0020095E                          1431          
0020095E  7400                    1432              MOVE.L #0,D2                        ; rextract bottom byte of address and add into checksum
00200960  1407                    1433              MOVE.B D7,D2
00200962  DC82                    1434              ADD.L D2,D6
00200964                          1435          
00200964  DE8B                    1436              ADD.L A3,D7                         ; add in the offset
00200966                          1437          
00200966  5785                    1438              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
00200968                          1439          
00200968  0807 0000               1440              BTST #0,D7                          ; deal with odd addresses
0020096C                          1441  
0020096C  2247                    1442              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
0020096E  6700 00D0               1443              BEQ EVEN
00200972                          1444                  
00200972  5385                    1445              SUB.L #1,D5
00200974  5389                    1446              SUB.L #1,A1
00200976                          1447          
00200976  7E00                    1448              MOVE.L #0,D7
00200978                          1449m             DOWNLOAD D2,D3                      ; MS 4 bits
00200978                          1450m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200978                          1451m 
00200978  1639 00C00003           1452m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020097E  0803 0000               1453m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200982  6700 0010               1454m     BEQ CONTINUE_92                             ; NOTHING, CONTINUE
00200986                          1455m  
00200986                          1456mm     READ_CHAR D2
00200986                 TRUE     1457mm     IFEQ DEBUG
00200986  1439 00C00007           1458mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020098C                          1459mm     ENDC
0020098C                 FALSE    1460mm     IFNE DEBUG
0020098C                          1461mm     ENDC
0020098C                          1462mm      
0020098C  B43C 001B               1463mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200990  6700 F676               1464mm     BEQ START
00200994                          1465mm     ENDM
00200994                          1466m CONTINUE_92
00200994  1639 00C00013           1467m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020099A  0803 0000               1468m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020099E  67D8                    1469m     BEQ WAIT_FOR_READY_92                       ; NOTHING, CHECK AGAIN
002009A0                          1470m     
002009A0  1439 00C00017           1471m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002009A6  13C2 00E00001           1472m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002009AC                          1473m     
002009AC                          1474m     ENDM
002009AC                          1475m             PRINT_CHAR D2,D3
002009AC                          1476m WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009AC                 TRUE     1477m     IFEQ DEBUG
002009AC  1639 00C00003           1478m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009B2  0803 0002               1479m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009B6  67F4                    1480m         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
002009B8  13C2 00C00007           1481m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009BE                          1482m     ENDC
002009BE                          1483m     
002009BE                 FALSE    1484m     IFNE DEBUG
002009BE                          1485m     ENDC
002009BE                          1486m 
002009BE                          1487m     ENDM
002009BE                          1488m             HEX2BIN D2,D2,A0
002009BE  41F9 00201B0A           1489m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002009C4  0402 0030               1490m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009C8  C4BC 000000FF           1491m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002009CE  1430 2000               1492m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002009D2                          1493m     ENDM
002009D2  8E82                    1494              OR.L D2,D7
002009D4  E98F                    1495              LSL.L #4,D7
002009D6                          1496               
002009D6                          1497m             DOWNLOAD D2,D3                      ; LS 4 bits    
002009D6                          1498m WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                          1499m 
002009D6  1639 00C00003           1500m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002009DC  0803 0000               1501m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009E0  6700 0010               1502m     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
002009E4                          1503m  
002009E4                          1504mm     READ_CHAR D2
002009E4                 TRUE     1505mm     IFEQ DEBUG
002009E4  1439 00C00007           1506mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002009EA                          1507mm     ENDC
002009EA                 FALSE    1508mm     IFNE DEBUG
002009EA                          1509mm     ENDC
002009EA                          1510mm      
002009EA  B43C 001B               1511mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002009EE  6700 F618               1512mm     BEQ START
002009F2                          1513mm     ENDM
002009F2                          1514m CONTINUE_96
002009F2  1639 00C00013           1515m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002009F8  0803 0000               1516m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009FC  67D8                    1517m     BEQ WAIT_FOR_READY_96                       ; NOTHING, CHECK AGAIN
002009FE                          1518m     
002009FE  1439 00C00017           1519m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A04  13C2 00E00001           1520m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A0A                          1521m     
00200A0A                          1522m     ENDM
00200A0A                          1523m             PRINT_CHAR D2,D3
00200A0A                          1524m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A0A                 TRUE     1525m     IFEQ DEBUG
00200A0A  1639 00C00003           1526m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A10  0803 0002               1527m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A14  67F4                    1528m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00200A16  13C2 00C00007           1529m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A1C                          1530m     ENDC
00200A1C                          1531m     
00200A1C                 FALSE    1532m     IFNE DEBUG
00200A1C                          1533m     ENDC
00200A1C                          1534m 
00200A1C                          1535m     ENDM
00200A1C                          1536m             HEX2BIN D2,D2,A0
00200A1C  41F9 00201B0A           1537m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A22  0402 0030               1538m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A26  C4BC 000000FF           1539m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A2C  1430 2000               1540m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A30                          1541m     ENDM
00200A30  8E82                    1542              OR.L D2,D7
00200A32                          1543                          
00200A32  DC87                    1544              ADD.L D7,D6                         ; add into checksum
00200A34                          1545                        
00200A34  3611                    1546              MOVE.W (A1),D3                      ; get the current data and replace the bottom byte
00200A36                          1547          
00200A36  0243 FF00               1548              ANDI.W #$FF00,D3
00200A3A  8647                    1549              OR.W D7,D3
00200A3C                          1550          
00200A3C  3283                    1551              MOVE.W D3,(A1)                      ; store it!
00200A3E  5489                    1552              ADD.L #2,A1
00200A40                          1553  EVEN        
00200A40                          1554              WHILE.L D5 <GE> #2 DO               ; read the data bytes
00200A40                          1555s _10000002
00200A40  BABC 00000002           1556s     CMP.L   #2,D5
00200A46  6D00 018A               1557s     BLT _10000003
00200A4A  5585                    1558                  SUB.L #2,D5
00200A4C  7E00                    1559                  MOVE.L #0,D7                    ; D7 holds the word
00200A4E                          1560              
00200A4E                          1561m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200A4E                          1562m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4E                          1563m 
00200A4E  1639 00C00003           1564m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200A54  0803 0000               1565m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A58  6700 0010               1566m     BEQ CONTINUE_100                                ; NOTHING, CONTINUE
00200A5C                          1567m  
00200A5C                          1568mm     READ_CHAR D2
00200A5C                 TRUE     1569mm     IFEQ DEBUG
00200A5C  1439 00C00007           1570mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A62                          1571mm     ENDC
00200A62                 FALSE    1572mm     IFNE DEBUG
00200A62                          1573mm     ENDC
00200A62                          1574mm      
00200A62  B43C 001B               1575mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A66  6700 F5A0               1576mm     BEQ START
00200A6A                          1577mm     ENDM
00200A6A                          1578m CONTINUE_100
00200A6A  1639 00C00013           1579m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200A70  0803 0000               1580m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A74  67D8                    1581m     BEQ WAIT_FOR_READY_100                      ; NOTHING, CHECK AGAIN
00200A76                          1582m     
00200A76  1439 00C00017           1583m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A7C  13C2 00E00001           1584m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A82                          1585m     
00200A82                          1586m     ENDM
00200A82                          1587m                 PRINT_CHAR D2,D3
00200A82                          1588m WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A82                 TRUE     1589m     IFEQ DEBUG
00200A82  1639 00C00003           1590m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A88  0803 0002               1591m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A8C  67F4                    1592m         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00200A8E  13C2 00C00007           1593m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A94                          1594m     ENDC
00200A94                          1595m     
00200A94                 FALSE    1596m     IFNE DEBUG
00200A94                          1597m     ENDC
00200A94                          1598m 
00200A94                          1599m     ENDM
00200A94                          1600m                 HEX2BIN D2,D2,A0
00200A94  41F9 00201B0A           1601m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A9A  0402 0030               1602m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A9E  C4BC 000000FF           1603m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200AA4  1430 2000               1604m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200AA8                          1605m     ENDM
00200AA8  8E82                    1606                  OR.L D2,D7
00200AAA  E98F                    1607                  LSL.L #4,D7
00200AAC                          1608               
00200AAC                          1609m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200AAC                          1610m WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAC                          1611m 
00200AAC  1639 00C00003           1612m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200AB2  0803 0000               1613m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AB6  6700 0010               1614m     BEQ CONTINUE_104                                ; NOTHING, CONTINUE
00200ABA                          1615m  
00200ABA                          1616mm     READ_CHAR D2
00200ABA                 TRUE     1617mm     IFEQ DEBUG
00200ABA  1439 00C00007           1618mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200AC0                          1619mm     ENDC
00200AC0                 FALSE    1620mm     IFNE DEBUG
00200AC0                          1621mm     ENDC
00200AC0                          1622mm      
00200AC0  B43C 001B               1623mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200AC4  6700 F542               1624mm     BEQ START
00200AC8                          1625mm     ENDM
00200AC8                          1626m CONTINUE_104
00200AC8  1639 00C00013           1627m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200ACE  0803 0000               1628m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AD2  67D8                    1629m     BEQ WAIT_FOR_READY_104                      ; NOTHING, CHECK AGAIN
00200AD4                          1630m     
00200AD4  1439 00C00017           1631m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200ADA  13C2 00E00001           1632m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200AE0                          1633m     
00200AE0                          1634m     ENDM
00200AE0                          1635m                 PRINT_CHAR D2,D3
00200AE0                          1636m WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1637m     IFEQ DEBUG
00200AE0  1639 00C00003           1638m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AE6  0803 0002               1639m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1640m         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00200AEC  13C2 00C00007           1641m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AF2                          1642m     ENDC
00200AF2                          1643m     
00200AF2                 FALSE    1644m     IFNE DEBUG
00200AF2                          1645m     ENDC
00200AF2                          1646m 
00200AF2                          1647m     ENDM
00200AF2                          1648m                 HEX2BIN D2,D2,A0
00200AF2  41F9 00201B0A           1649m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200AF8  0402 0030               1650m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AFC  C4BC 000000FF           1651m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B02  1430 2000               1652m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B06                          1653m     ENDM
00200B06  8E82                    1654                  OR.L D2,D7
00200B08                          1655                          
00200B08  DC87                    1656                  ADD.L D7,D6                     ; add into checksum
00200B0A                          1657              
00200B0A  E98F                    1658                  LSL.L #4,D7
00200B0C                          1659m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200B0C                          1660m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0C                          1661m 
00200B0C  1639 00C00003           1662m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200B12  0803 0000               1663m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B16  6700 0010               1664m     BEQ CONTINUE_108                                ; NOTHING, CONTINUE
00200B1A                          1665m  
00200B1A                          1666mm     READ_CHAR D2
00200B1A                 TRUE     1667mm     IFEQ DEBUG
00200B1A  1439 00C00007           1668mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B20                          1669mm     ENDC
00200B20                 FALSE    1670mm     IFNE DEBUG
00200B20                          1671mm     ENDC
00200B20                          1672mm      
00200B20  B43C 001B               1673mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B24  6700 F4E2               1674mm     BEQ START
00200B28                          1675mm     ENDM
00200B28                          1676m CONTINUE_108
00200B28  1639 00C00013           1677m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B2E  0803 0000               1678m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B32  67D8                    1679m     BEQ WAIT_FOR_READY_108                      ; NOTHING, CHECK AGAIN
00200B34                          1680m     
00200B34  1439 00C00017           1681m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B3A  13C2 00E00001           1682m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B40                          1683m     
00200B40                          1684m     ENDM
00200B40                          1685m                 PRINT_CHAR D2,D3
00200B40                          1686m WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B40                 TRUE     1687m     IFEQ DEBUG
00200B40  1639 00C00003           1688m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B46  0803 0002               1689m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B4A  67F4                    1690m         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200B4C  13C2 00C00007           1691m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B52                          1692m     ENDC
00200B52                          1693m     
00200B52                 FALSE    1694m     IFNE DEBUG
00200B52                          1695m     ENDC
00200B52                          1696m 
00200B52                          1697m     ENDM
00200B52                          1698m                 HEX2BIN D2,D2,A0
00200B52  41F9 00201B0A           1699m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B58  0402 0030               1700m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B5C  C4BC 000000FF           1701m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B62  1430 2000               1702m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B66                          1703m     ENDM
00200B66  8E82                    1704                  OR.L D2,D7
00200B68                          1705               
00200B68  E98F                    1706                  LSL.L #4,D7
00200B6A                          1707m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200B6A                          1708m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B6A                          1709m 
00200B6A  1639 00C00003           1710m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200B70  0803 0000               1711m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B74  6700 0010               1712m     BEQ CONTINUE_112                                ; NOTHING, CONTINUE
00200B78                          1713m  
00200B78                          1714mm     READ_CHAR D2
00200B78                 TRUE     1715mm     IFEQ DEBUG
00200B78  1439 00C00007           1716mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B7E                          1717mm     ENDC
00200B7E                 FALSE    1718mm     IFNE DEBUG
00200B7E                          1719mm     ENDC
00200B7E                          1720mm      
00200B7E  B43C 001B               1721mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B82  6700 F484               1722mm     BEQ START
00200B86                          1723mm     ENDM
00200B86                          1724m CONTINUE_112
00200B86  1639 00C00013           1725m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B8C  0803 0000               1726m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B90  67D8                    1727m     BEQ WAIT_FOR_READY_112                      ; NOTHING, CHECK AGAIN
00200B92                          1728m     
00200B92  1439 00C00017           1729m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B98  13C2 00E00001           1730m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B9E                          1731m     
00200B9E                          1732m     ENDM
00200B9E                          1733m                 PRINT_CHAR D2,D3
00200B9E                          1734m WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B9E                 TRUE     1735m     IFEQ DEBUG
00200B9E  1639 00C00003           1736m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BA4  0803 0002               1737m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BA8  67F4                    1738m         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200BAA  13C2 00C00007           1739m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200BB0                          1740m     ENDC
00200BB0                          1741m     
00200BB0                 FALSE    1742m     IFNE DEBUG
00200BB0                          1743m     ENDC
00200BB0                          1744m 
00200BB0                          1745m     ENDM
00200BB0                          1746m                 HEX2BIN D2,D2,A0
00200BB0  41F9 00201B0A           1747m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200BB6  0402 0030               1748m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BBA  C4BC 000000FF           1749m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200BC0  1430 2000               1750m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200BC4                          1751m     ENDM
00200BC4  8E82                    1752                  OR.L D2,D7
00200BC6                          1753              
00200BC6  7400                    1754                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200BC8  1407                    1755                  MOVE.B D7,D2
00200BCA  DC82                    1756                  ADD.L D2,D6
00200BCC                          1757              
00200BCC  32C7                    1758                  MOVE.W D7,(A1)+                 ; store it!
00200BCE                          1759              ENDW
00200BCE  6000 FE70               1760s     BRA _10000002
00200BD2                          1761s _10000003
00200BD2                          1762          
00200BD2                          1763              IF D5 <EQ> #1 THEN
00200BD2  BA7C 0001               1764s     CMP.W   #1,D5
00200BD6  6600 00CE               1765s     BNE _00000003
00200BDA  7E00                    1766                  MOVE.L #0,D7                    ; D7 holds the word
00200BDC                          1767                      
00200BDC                          1768m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200BDC                          1769m WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BDC                          1770m 
00200BDC  1639 00C00003           1771m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200BE2  0803 0000               1772m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200BE6  6700 0010               1773m     BEQ CONTINUE_116                                ; NOTHING, CONTINUE
00200BEA                          1774m  
00200BEA                          1775mm     READ_CHAR D2
00200BEA                 TRUE     1776mm     IFEQ DEBUG
00200BEA  1439 00C00007           1777mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200BF0                          1778mm     ENDC
00200BF0                 FALSE    1779mm     IFNE DEBUG
00200BF0                          1780mm     ENDC
00200BF0                          1781mm      
00200BF0  B43C 001B               1782mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200BF4  6700 F412               1783mm     BEQ START
00200BF8                          1784mm     ENDM
00200BF8                          1785m CONTINUE_116
00200BF8  1639 00C00013           1786m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200BFE  0803 0000               1787m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C02  67D8                    1788m     BEQ WAIT_FOR_READY_116                      ; NOTHING, CHECK AGAIN
00200C04                          1789m     
00200C04  1439 00C00017           1790m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C0A  13C2 00E00001           1791m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C10                          1792m     
00200C10                          1793m     ENDM
00200C10                          1794m                 PRINT_CHAR D2,D3
00200C10                          1795m WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C10                 TRUE     1796m     IFEQ DEBUG
00200C10  1639 00C00003           1797m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C16  0803 0002               1798m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C1A  67F4                    1799m         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200C1C  13C2 00C00007           1800m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C22                          1801m     ENDC
00200C22                          1802m     
00200C22                 FALSE    1803m     IFNE DEBUG
00200C22                          1804m     ENDC
00200C22                          1805m 
00200C22                          1806m     ENDM
00200C22                          1807m                 HEX2BIN D2,D2,A0
00200C22  41F9 00201B0A           1808m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C28  0402 0030               1809m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C2C  C4BC 000000FF           1810m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C32  1430 2000               1811m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C36                          1812m     ENDM
00200C36  8E82                    1813                  OR.L D2,D7
00200C38  E98F                    1814              LSL.L #4,D7
00200C3A                          1815               
00200C3A                          1816m             DOWNLOAD D2,D3                      ; LS 4 bits    
00200C3A                          1817m WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C3A                          1818m 
00200C3A  1639 00C00003           1819m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200C40  0803 0000               1820m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C44  6700 0010               1821m     BEQ CONTINUE_120                                ; NOTHING, CONTINUE
00200C48                          1822m  
00200C48                          1823mm     READ_CHAR D2
00200C48                 TRUE     1824mm     IFEQ DEBUG
00200C48  1439 00C00007           1825mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C4E                          1826mm     ENDC
00200C4E                 FALSE    1827mm     IFNE DEBUG
00200C4E                          1828mm     ENDC
00200C4E                          1829mm      
00200C4E  B43C 001B               1830mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200C52  6700 F3B4               1831mm     BEQ START
00200C56                          1832mm     ENDM
00200C56                          1833m CONTINUE_120
00200C56  1639 00C00013           1834m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200C5C  0803 0000               1835m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C60  67D8                    1836m     BEQ WAIT_FOR_READY_120                      ; NOTHING, CHECK AGAIN
00200C62                          1837m     
00200C62  1439 00C00017           1838m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C68  13C2 00E00001           1839m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C6E                          1840m     
00200C6E                          1841m     ENDM
00200C6E                          1842m             PRINT_CHAR D2,D3
00200C6E                          1843m WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6E                 TRUE     1844m     IFEQ DEBUG
00200C6E  1639 00C00003           1845m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C74  0803 0002               1846m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C78  67F4                    1847m         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200C7A  13C2 00C00007           1848m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C80                          1849m     ENDC
00200C80                          1850m     
00200C80                 FALSE    1851m     IFNE DEBUG
00200C80                          1852m     ENDC
00200C80                          1853m 
00200C80                          1854m     ENDM
00200C80                          1855m             HEX2BIN D2,D2,A0
00200C80  41F9 00201B0A           1856m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C86  0402 0030               1857m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C8A  C4BC 000000FF           1858m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C90  1430 2000               1859m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C94                          1860m     ENDM
00200C94  8E82                    1861              OR.L D2,D7
00200C96                          1862                          
00200C96  DC87                    1863              ADD.L D7,D6                         ; add into checksum
00200C98                          1864              
00200C98  3611                    1865              MOVE.W (A1),D3                      ; get the current data and replace the top byte
00200C9A  E18F                    1866              LSL.L #8,D7
00200C9C  C6BC 000000FF           1867              AND.L #$00FF,D3
00200CA2  8687                    1868              OR.L D7,D3
00200CA4                          1869  
00200CA4  32C3                    1870              MOVE.W D3,(A1)+                     ; store it!
00200CA6                          1871          ENDI
00200CA6                          1872s _00000003
00200CA6                          1873    
00200CA6                          1874m         PRINT_CRLF D3
00200CA6                          1875mm     PRINT_CHAR #13,D3                           ; CR
00200CA6                          1876mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CA6                 TRUE     1877mm     IFEQ DEBUG
00200CA6  1639 00C00003           1878mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CAC  0803 0002               1879mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CB0  67F4                    1880mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00200CB2  13FC 000D 00C00007      1881mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200CBA                          1882mm     ENDC
00200CBA                          1883mm     
00200CBA                 FALSE    1884mm     IFNE DEBUG
00200CBA                          1885mm     ENDC
00200CBA                          1886mm 
00200CBA                          1887mm     ENDM
00200CBA                          1888mm     PRINT_CHAR #10,D3                           ; LF
00200CBA                          1889mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBA                 TRUE     1890mm     IFEQ DEBUG
00200CBA  1639 00C00003           1891mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CC0  0803 0002               1892mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC4  67F4                    1893mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200CC6  13FC 000A 00C00007      1894mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200CCE                          1895mm     ENDC
00200CCE                          1896mm     
00200CCE                 FALSE    1897mm     IFNE DEBUG
00200CCE                          1898mm     ENDC
00200CCE                          1899mm 
00200CCE                          1900mm     ENDM
00200CCE                          1901m     ENDM
00200CCE  43F9 002004A0           1902          LEA WAIT_FOR_SRECORD,A1                 ; next place to go
00200CD4                          1903        ELSE
00200CD4  6000 0812               1904s     BRA _00000004
00200CD8                          1905s _00000002
00200CD8                          1906              IF.B D7 <EQ> #'2' THEN.L            ; 24 bit address data record
00200CD8  BE3C 0032               1907s     CMP.B   #'2',D7
00200CDC  6600 05BA               1908s     BNE.L   _00000005
00200CE0  7E00                    1909                  MOVE.L #0,D7                    ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200CE2                          1910m                 DOWNLOAD D2,D3                  ; top byte
00200CE2                          1911m WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE2                          1912m 
00200CE2  1639 00C00003           1913m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200CE8  0803 0000               1914m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200CEC  6700 0010               1915m     BEQ CONTINUE_127                                ; NOTHING, CONTINUE
00200CF0                          1916m  
00200CF0                          1917mm     READ_CHAR D2
00200CF0                 TRUE     1918mm     IFEQ DEBUG
00200CF0  1439 00C00007           1919mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200CF6                          1920mm     ENDC
00200CF6                 FALSE    1921mm     IFNE DEBUG
00200CF6                          1922mm     ENDC
00200CF6                          1923mm      
00200CF6  B43C 001B               1924mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFA  6700 F30C               1925mm     BEQ START
00200CFE                          1926mm     ENDM
00200CFE                          1927m CONTINUE_127
00200CFE  1639 00C00013           1928m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D04  0803 0000               1929m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D08  67D8                    1930m     BEQ WAIT_FOR_READY_127                      ; NOTHING, CHECK AGAIN
00200D0A                          1931m     
00200D0A  1439 00C00017           1932m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D10  13C2 00E00001           1933m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D16                          1934m     
00200D16                          1935m     ENDM
00200D16                          1936m                 PRINT_CHAR D2,D3
00200D16                          1937m WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D16                 TRUE     1938m     IFEQ DEBUG
00200D16  1639 00C00003           1939m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D1C  0803 0002               1940m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D20  67F4                    1941m         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200D22  13C2 00C00007           1942m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D28                          1943m     ENDC
00200D28                          1944m     
00200D28                 FALSE    1945m     IFNE DEBUG
00200D28                          1946m     ENDC
00200D28                          1947m 
00200D28                          1948m     ENDM
00200D28                          1949m                 HEX2BIN D2,D2,A0
00200D28  41F9 00201B0A           1950m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D2E  0402 0030               1951m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D32  C4BC 000000FF           1952m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D38  1430 2000               1953m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D3C                          1954m     ENDM
00200D3C  8E82                    1955                  OR.L D2,D7
00200D3E  E98F                    1956                  LSL.L #4,D7
00200D40                          1957m                 DOWNLOAD D2,D3         
00200D40                          1958m WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D40                          1959m 
00200D40  1639 00C00003           1960m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200D46  0803 0000               1961m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D4A  6700 0010               1962m     BEQ CONTINUE_131                                ; NOTHING, CONTINUE
00200D4E                          1963m  
00200D4E                          1964mm     READ_CHAR D2
00200D4E                 TRUE     1965mm     IFEQ DEBUG
00200D4E  1439 00C00007           1966mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D54                          1967mm     ENDC
00200D54                 FALSE    1968mm     IFNE DEBUG
00200D54                          1969mm     ENDC
00200D54                          1970mm      
00200D54  B43C 001B               1971mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D58  6700 F2AE               1972mm     BEQ START
00200D5C                          1973mm     ENDM
00200D5C                          1974m CONTINUE_131
00200D5C  1639 00C00013           1975m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D62  0803 0000               1976m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D66  67D8                    1977m     BEQ WAIT_FOR_READY_131                      ; NOTHING, CHECK AGAIN
00200D68                          1978m     
00200D68  1439 00C00017           1979m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D6E  13C2 00E00001           1980m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D74                          1981m     
00200D74                          1982m     ENDM
00200D74                          1983m                 PRINT_CHAR D2,D3
00200D74                          1984m WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D74                 TRUE     1985m     IFEQ DEBUG
00200D74  1639 00C00003           1986m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D7A  0803 0002               1987m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D7E  67F4                    1988m         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200D80  13C2 00C00007           1989m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D86                          1990m     ENDC
00200D86                          1991m     
00200D86                 FALSE    1992m     IFNE DEBUG
00200D86                          1993m     ENDC
00200D86                          1994m 
00200D86                          1995m     ENDM
00200D86                          1996m                 HEX2BIN D2,D2,A0
00200D86  41F9 00201B0A           1997m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D8C  0402 0030               1998m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D90  C4BC 000000FF           1999m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D96  1430 2000               2000m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D9A                          2001m     ENDM
00200D9A  8E82                    2002                  OR.L D2,D7
00200D9C                          2003                  
00200D9C  DC87                    2004                  ADD.L D7,D6                     ; add top byte of address into checksum
00200D9E                          2005  
00200D9E  E98F                    2006                  LSL.L #4,D7                     ; middle byte
00200DA0                          2007m                 DOWNLOAD D2,D3
00200DA0                          2008m WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA0                          2009m 
00200DA0  1639 00C00003           2010m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200DA6  0803 0000               2011m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DAA  6700 0010               2012m     BEQ CONTINUE_135                                ; NOTHING, CONTINUE
00200DAE                          2013m  
00200DAE                          2014mm     READ_CHAR D2
00200DAE                 TRUE     2015mm     IFEQ DEBUG
00200DAE  1439 00C00007           2016mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DB4                          2017mm     ENDC
00200DB4                 FALSE    2018mm     IFNE DEBUG
00200DB4                          2019mm     ENDC
00200DB4                          2020mm      
00200DB4  B43C 001B               2021mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DB8  6700 F24E               2022mm     BEQ START
00200DBC                          2023mm     ENDM
00200DBC                          2024m CONTINUE_135
00200DBC  1639 00C00013           2025m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200DC2  0803 0000               2026m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DC6  67D8                    2027m     BEQ WAIT_FOR_READY_135                      ; NOTHING, CHECK AGAIN
00200DC8                          2028m     
00200DC8  1439 00C00017           2029m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200DCE  13C2 00E00001           2030m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200DD4                          2031m     
00200DD4                          2032m     ENDM
00200DD4                          2033m                 PRINT_CHAR D2,D3
00200DD4                          2034m WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DD4                 TRUE     2035m     IFEQ DEBUG
00200DD4  1639 00C00003           2036m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DDA  0803 0002               2037m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DDE  67F4                    2038m         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00200DE0  13C2 00C00007           2039m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DE6                          2040m     ENDC
00200DE6                          2041m     
00200DE6                 FALSE    2042m     IFNE DEBUG
00200DE6                          2043m     ENDC
00200DE6                          2044m 
00200DE6                          2045m     ENDM
00200DE6                          2046m                 HEX2BIN D2,D2,A0
00200DE6  41F9 00201B0A           2047m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DEC  0402 0030               2048m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF0  C4BC 000000FF           2049m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DF6  1430 2000               2050m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DFA                          2051m     ENDM
00200DFA  8E82                    2052                  OR.L D2,D7
00200DFC  E98F                    2053                  LSL.L #4,D7        
00200DFE                          2054m                 DOWNLOAD D2,D3
00200DFE                          2055m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DFE                          2056m 
00200DFE  1639 00C00003           2057m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200E04  0803 0000               2058m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E08  6700 0010               2059m     BEQ CONTINUE_139                                ; NOTHING, CONTINUE
00200E0C                          2060m  
00200E0C                          2061mm     READ_CHAR D2
00200E0C                 TRUE     2062mm     IFEQ DEBUG
00200E0C  1439 00C00007           2063mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E12                          2064mm     ENDC
00200E12                 FALSE    2065mm     IFNE DEBUG
00200E12                          2066mm     ENDC
00200E12                          2067mm      
00200E12  B43C 001B               2068mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E16  6700 F1F0               2069mm     BEQ START
00200E1A                          2070mm     ENDM
00200E1A                          2071m CONTINUE_139
00200E1A  1639 00C00013           2072m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200E20  0803 0000               2073m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E24  67D8                    2074m     BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00200E26                          2075m     
00200E26  1439 00C00017           2076m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200E2C  13C2 00E00001           2077m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200E32                          2078m     
00200E32                          2079m     ENDM
00200E32                          2080m                 PRINT_CHAR D2,D3
00200E32                          2081m WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E32                 TRUE     2082m     IFEQ DEBUG
00200E32  1639 00C00003           2083m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E38  0803 0002               2084m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E3C  67F4                    2085m         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200E3E  13C2 00C00007           2086m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200E44                          2087m     ENDC
00200E44                          2088m     
00200E44                 FALSE    2089m     IFNE DEBUG
00200E44                          2090m     ENDC
00200E44                          2091m 
00200E44                          2092m     ENDM
00200E44                          2093m                 HEX2BIN D2,D2,A0
00200E44  41F9 00201B0A           2094m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200E4A  0402 0030               2095m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E4E  C4BC 000000FF           2096m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200E54  1430 2000               2097m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200E58                          2098m     ENDM
00200E58  8E82                    2099                  OR.L D2,D7
00200E5A                          2100                  
00200E5A  7400                    2101                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
00200E5C  1407                    2102                  MOVE.B D7,D2
00200E5E  DC82                    2103                  ADD.L D2,D6
00200E60                          2104            
00200E60  E98F                    2105                  LSL.L #4,D7                     ; bottom byte
00200E62                          2106m                 DOWNLOAD D2,D3
00200E62                          2107m WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                          2108m 
00200E62  1639 00C00003           2109m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200E68  0803 0000               2110m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E6C  6700 0010               2111m     BEQ CONTINUE_143                                ; NOTHING, CONTINUE
00200E70                          2112m  
00200E70                          2113mm     READ_CHAR D2
00200E70                 TRUE     2114mm     IFEQ DEBUG
00200E70  1439 00C00007           2115mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E76                          2116mm     ENDC
00200E76                 FALSE    2117mm     IFNE DEBUG
00200E76                          2118mm     ENDC
00200E76                          2119mm      
00200E76  B43C 001B               2120mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E7A  6700 F18C               2121mm     BEQ START
00200E7E                          2122mm     ENDM
00200E7E                          2123m CONTINUE_143
00200E7E  1639 00C00013           2124m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200E84  0803 0000               2125m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E88  67D8                    2126m     BEQ WAIT_FOR_READY_143                      ; NOTHING, CHECK AGAIN
00200E8A                          2127m     
00200E8A  1439 00C00017           2128m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200E90  13C2 00E00001           2129m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200E96                          2130m     
00200E96                          2131m     ENDM
00200E96                          2132m                 PRINT_CHAR D2,D3
00200E96                          2133m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E96                 TRUE     2134m     IFEQ DEBUG
00200E96  1639 00C00003           2135m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E9C  0803 0002               2136m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EA0  67F4                    2137m         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00200EA2  13C2 00C00007           2138m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200EA8                          2139m     ENDC
00200EA8                          2140m     
00200EA8                 FALSE    2141m     IFNE DEBUG
00200EA8                          2142m     ENDC
00200EA8                          2143m 
00200EA8                          2144m     ENDM
00200EA8                          2145m                 HEX2BIN D2,D2,A0
00200EA8  41F9 00201B0A           2146m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200EAE  0402 0030               2147m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EB2  C4BC 000000FF           2148m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EB8  1430 2000               2149m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EBC                          2150m     ENDM
00200EBC  8E82                    2151                  OR.L D2,D7
00200EBE  E98F                    2152                  LSL.L #4,D7        
00200EC0                          2153m                 DOWNLOAD D2,D3
00200EC0                          2154m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC0                          2155m 
00200EC0  1639 00C00003           2156m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200EC6  0803 0000               2157m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200ECA  6700 0010               2158m     BEQ CONTINUE_147                                ; NOTHING, CONTINUE
00200ECE                          2159m  
00200ECE                          2160mm     READ_CHAR D2
00200ECE                 TRUE     2161mm     IFEQ DEBUG
00200ECE  1439 00C00007           2162mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200ED4                          2163mm     ENDC
00200ED4                 FALSE    2164mm     IFNE DEBUG
00200ED4                          2165mm     ENDC
00200ED4                          2166mm      
00200ED4  B43C 001B               2167mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200ED8  6700 F12E               2168mm     BEQ START
00200EDC                          2169mm     ENDM
00200EDC                          2170m CONTINUE_147
00200EDC  1639 00C00013           2171m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200EE2  0803 0000               2172m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200EE6  67D8                    2173m     BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00200EE8                          2174m     
00200EE8  1439 00C00017           2175m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200EEE  13C2 00E00001           2176m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200EF4                          2177m     
00200EF4                          2178m     ENDM
00200EF4                          2179m                 PRINT_CHAR D2,D3
00200EF4                          2180m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EF4                 TRUE     2181m     IFEQ DEBUG
00200EF4  1639 00C00003           2182m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200EFA  0803 0002               2183m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EFE  67F4                    2184m         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00200F00  13C2 00C00007           2185m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F06                          2186m     ENDC
00200F06                          2187m     
00200F06                 FALSE    2188m     IFNE DEBUG
00200F06                          2189m     ENDC
00200F06                          2190m 
00200F06                          2191m     ENDM
00200F06                          2192m                 HEX2BIN D2,D2,A0
00200F06  41F9 00201B0A           2193m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F0C  0402 0030               2194m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F10  C4BC 000000FF           2195m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F16  1430 2000               2196m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F1A                          2197m     ENDM
00200F1A  8E82                    2198                  OR.L D2,D7
00200F1C                          2199          
00200F1C  7400                    2200                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200F1E  1407                    2201                  MOVE.B D7,D2
00200F20  DC82                    2202                  ADD.L D2,D6
00200F22                          2203                  
00200F22  2247                    2204                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200F24  D3CB                    2205                  ADD.L A3,A1                     ; add in the offset
00200F26                          2206                    
00200F26  0807 0000               2207                  BTST #0,D7                      ; deal with odd addresses
00200F2A                          2208  
00200F2A  2247                    2209                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200F2C  6700 00D0               2210                  BEQ EVEN2
00200F30                          2211                          
00200F30  5385                    2212                  SUB.L #1,D5
00200F32  5389                    2213                  SUB.L #1,A1
00200F34                          2214                  
00200F34  7E00                    2215                  MOVE.L #0,D7
00200F36                          2216m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200F36                          2217m WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F36                          2218m 
00200F36  1639 00C00003           2219m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200F3C  0803 0000               2220m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F40  6700 0010               2221m     BEQ CONTINUE_151                                ; NOTHING, CONTINUE
00200F44                          2222m  
00200F44                          2223mm     READ_CHAR D2
00200F44                 TRUE     2224mm     IFEQ DEBUG
00200F44  1439 00C00007           2225mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200F4A                          2226mm     ENDC
00200F4A                 FALSE    2227mm     IFNE DEBUG
00200F4A                          2228mm     ENDC
00200F4A                          2229mm      
00200F4A  B43C 001B               2230mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200F4E  6700 F0B8               2231mm     BEQ START
00200F52                          2232mm     ENDM
00200F52                          2233m CONTINUE_151
00200F52  1639 00C00013           2234m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200F58  0803 0000               2235m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F5C  67D8                    2236m     BEQ WAIT_FOR_READY_151                      ; NOTHING, CHECK AGAIN
00200F5E                          2237m     
00200F5E  1439 00C00017           2238m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200F64  13C2 00E00001           2239m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200F6A                          2240m     
00200F6A                          2241m     ENDM
00200F6A                          2242m                 PRINT_CHAR D2,D3
00200F6A                          2243m WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F6A                 TRUE     2244m     IFEQ DEBUG
00200F6A  1639 00C00003           2245m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F70  0803 0002               2246m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F74  67F4                    2247m         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00200F76  13C2 00C00007           2248m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F7C                          2249m     ENDC
00200F7C                          2250m     
00200F7C                 FALSE    2251m     IFNE DEBUG
00200F7C                          2252m     ENDC
00200F7C                          2253m 
00200F7C                          2254m     ENDM
00200F7C                          2255m                 HEX2BIN D2,D2,A0
00200F7C  41F9 00201B0A           2256m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F82  0402 0030               2257m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F86  C4BC 000000FF           2258m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F8C  1430 2000               2259m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F90                          2260m     ENDM
00200F90  8E82                    2261                  OR.L D2,D7
00200F92  E98F                    2262                  LSL.L #4,D7
00200F94                          2263                       
00200F94                          2264m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200F94                          2265m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                          2266m 
00200F94  1639 00C00003           2267m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200F9A  0803 0000               2268m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F9E  6700 0010               2269m     BEQ CONTINUE_155                                ; NOTHING, CONTINUE
00200FA2                          2270m  
00200FA2                          2271mm     READ_CHAR D2
00200FA2                 TRUE     2272mm     IFEQ DEBUG
00200FA2  1439 00C00007           2273mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200FA8                          2274mm     ENDC
00200FA8                 FALSE    2275mm     IFNE DEBUG
00200FA8                          2276mm     ENDC
00200FA8                          2277mm      
00200FA8  B43C 001B               2278mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200FAC  6700 F05A               2279mm     BEQ START
00200FB0                          2280mm     ENDM
00200FB0                          2281m CONTINUE_155
00200FB0  1639 00C00013           2282m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200FB6  0803 0000               2283m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200FBA  67D8                    2284m     BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00200FBC                          2285m     
00200FBC  1439 00C00017           2286m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200FC2  13C2 00E00001           2287m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200FC8                          2288m     
00200FC8                          2289m     ENDM
00200FC8                          2290m                 PRINT_CHAR D2,D3
00200FC8                          2291m WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FC8                 TRUE     2292m     IFEQ DEBUG
00200FC8  1639 00C00003           2293m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FCE  0803 0002               2294m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FD2  67F4                    2295m         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200FD4  13C2 00C00007           2296m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200FDA                          2297m     ENDC
00200FDA                          2298m     
00200FDA                 FALSE    2299m     IFNE DEBUG
00200FDA                          2300m     ENDC
00200FDA                          2301m 
00200FDA                          2302m     ENDM
00200FDA                          2303m                 HEX2BIN D2,D2,A0
00200FDA  41F9 00201B0A           2304m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200FE0  0402 0030               2305m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FE4  C4BC 000000FF           2306m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200FEA  1430 2000               2307m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200FEE                          2308m     ENDM
00200FEE  8E82                    2309                  OR.L D2,D7
00200FF0                          2310                          
00200FF0  DC87                    2311                  ADD.L D7,D6                     ; add into checksum
00200FF2                          2312                                
00200FF2  3611                    2313                  MOVE.W (A1),D3                  ; get the current data and replace the bottom byte
00200FF4                          2314                  
00200FF4  0243 FF00               2315                  ANDI.W #$FF00,D3
00200FF8  8647                    2316                  OR.W D7,D3
00200FFA                          2317                  
00200FFA  3283                    2318                  MOVE.W D3,(A1)                  ; store it!
00200FFC  5489                    2319                  ADD.L #2,A1
00200FFE                          2320  EVEN2
00200FFE  5985                    2321                  SUB.L #4,D5                     ; subtract four bytes for 24 bit address and 1 byte checksum
00201000                          2322                  WHILE.L D5 <GE> #2 DO           ; read the data bytes
00201000                          2323s _10000004
00201000  BABC 00000002           2324s     CMP.L   #2,D5
00201006  6D00 018A               2325s     BLT _10000005
0020100A  5585                    2326                      SUB.L #2,D5
0020100C                          2327                      
0020100C  7E00                    2328                      MOVE.L #0,D7                ; D7 holds the word
0020100E                          2329                      
0020100E                          2330m                     DOWNLOAD D2,D3              ; MS 4 bits
0020100E                          2331m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020100E                          2332m 
0020100E  1639 00C00003           2333m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201014  0803 0000               2334m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201018  6700 0010               2335m     BEQ CONTINUE_159                                ; NOTHING, CONTINUE
0020101C                          2336m  
0020101C                          2337mm     READ_CHAR D2
0020101C                 TRUE     2338mm     IFEQ DEBUG
0020101C  1439 00C00007           2339mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201022                          2340mm     ENDC
00201022                 FALSE    2341mm     IFNE DEBUG
00201022                          2342mm     ENDC
00201022                          2343mm      
00201022  B43C 001B               2344mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201026  6700 EFE0               2345mm     BEQ START
0020102A                          2346mm     ENDM
0020102A                          2347m CONTINUE_159
0020102A  1639 00C00013           2348m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201030  0803 0000               2349m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201034  67D8                    2350m     BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00201036                          2351m     
00201036  1439 00C00017           2352m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020103C  13C2 00E00001           2353m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201042                          2354m     
00201042                          2355m     ENDM
00201042                          2356m                     PRINT_CHAR D2,D3
00201042                          2357m WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201042                 TRUE     2358m     IFEQ DEBUG
00201042  1639 00C00003           2359m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201048  0803 0002               2360m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020104C  67F4                    2361m         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
0020104E  13C2 00C00007           2362m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201054                          2363m     ENDC
00201054                          2364m     
00201054                 FALSE    2365m     IFNE DEBUG
00201054                          2366m     ENDC
00201054                          2367m 
00201054                          2368m     ENDM
00201054                          2369m                     HEX2BIN D2,D2,A0
00201054  41F9 00201B0A           2370m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020105A  0402 0030               2371m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020105E  C4BC 000000FF           2372m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201064  1430 2000               2373m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201068                          2374m     ENDM
00201068  8E82                    2375                      OR.L D2,D7
0020106A  E98F                    2376                      LSL.L #4,D7
0020106C                          2377                       
0020106C                          2378m                     DOWNLOAD D2,D3              ; LS 4 bits    
0020106C                          2379m WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020106C                          2380m 
0020106C  1639 00C00003           2381m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201072  0803 0000               2382m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201076  6700 0010               2383m     BEQ CONTINUE_163                                ; NOTHING, CONTINUE
0020107A                          2384m  
0020107A                          2385mm     READ_CHAR D2
0020107A                 TRUE     2386mm     IFEQ DEBUG
0020107A  1439 00C00007           2387mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201080                          2388mm     ENDC
00201080                 FALSE    2389mm     IFNE DEBUG
00201080                          2390mm     ENDC
00201080                          2391mm      
00201080  B43C 001B               2392mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201084  6700 EF82               2393mm     BEQ START
00201088                          2394mm     ENDM
00201088                          2395m CONTINUE_163
00201088  1639 00C00013           2396m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020108E  0803 0000               2397m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201092  67D8                    2398m     BEQ WAIT_FOR_READY_163                      ; NOTHING, CHECK AGAIN
00201094                          2399m     
00201094  1439 00C00017           2400m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020109A  13C2 00E00001           2401m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002010A0                          2402m     
002010A0                          2403m     ENDM
002010A0                          2404m                     PRINT_CHAR D2,D3
002010A0                          2405m WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A0                 TRUE     2406m     IFEQ DEBUG
002010A0  1639 00C00003           2407m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010A6  0803 0002               2408m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010AA  67F4                    2409m         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
002010AC  13C2 00C00007           2410m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002010B2                          2411m     ENDC
002010B2                          2412m     
002010B2                 FALSE    2413m     IFNE DEBUG
002010B2                          2414m     ENDC
002010B2                          2415m 
002010B2                          2416m     ENDM
002010B2                          2417m                     HEX2BIN D2,D2,A0
002010B2  41F9 00201B0A           2418m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002010B8  0402 0030               2419m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002010BC  C4BC 000000FF           2420m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002010C2  1430 2000               2421m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002010C6                          2422m     ENDM
002010C6  8E82                    2423                      OR.L D2,D7
002010C8                          2424                          
002010C8  DC87                    2425                      ADD.L D7,D6                 ; add into checksum
002010CA                          2426                      
002010CA  E98F                    2427                      LSL.L #4,D7
002010CC                          2428m                     DOWNLOAD D2,D3              ; MS 4 bits
002010CC                          2429m WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010CC                          2430m 
002010CC  1639 00C00003           2431m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002010D2  0803 0000               2432m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002010D6  6700 0010               2433m     BEQ CONTINUE_167                                ; NOTHING, CONTINUE
002010DA                          2434m  
002010DA                          2435mm     READ_CHAR D2
002010DA                 TRUE     2436mm     IFEQ DEBUG
002010DA  1439 00C00007           2437mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002010E0                          2438mm     ENDC
002010E0                 FALSE    2439mm     IFNE DEBUG
002010E0                          2440mm     ENDC
002010E0                          2441mm      
002010E0  B43C 001B               2442mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002010E4  6700 EF22               2443mm     BEQ START
002010E8                          2444mm     ENDM
002010E8                          2445m CONTINUE_167
002010E8  1639 00C00013           2446m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002010EE  0803 0000               2447m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002010F2  67D8                    2448m     BEQ WAIT_FOR_READY_167                      ; NOTHING, CHECK AGAIN
002010F4                          2449m     
002010F4  1439 00C00017           2450m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002010FA  13C2 00E00001           2451m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201100                          2452m     
00201100                          2453m     ENDM
00201100                          2454m                     PRINT_CHAR D2,D3
00201100                          2455m WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201100                 TRUE     2456m     IFEQ DEBUG
00201100  1639 00C00003           2457m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201106  0803 0002               2458m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020110A  67F4                    2459m         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
0020110C  13C2 00C00007           2460m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201112                          2461m     ENDC
00201112                          2462m     
00201112                 FALSE    2463m     IFNE DEBUG
00201112                          2464m     ENDC
00201112                          2465m 
00201112                          2466m     ENDM
00201112                          2467m                     HEX2BIN D2,D2,A0
00201112  41F9 00201B0A           2468m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201118  0402 0030               2469m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020111C  C4BC 000000FF           2470m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201122  1430 2000               2471m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201126                          2472m     ENDM
00201126  8E82                    2473                      OR.L D2,D7
00201128                          2474                       
00201128  E98F                    2475                      LSL.L #4,D7
0020112A                          2476m                     DOWNLOAD D2,D3              ; LS 4 bits    
0020112A                          2477m WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020112A                          2478m 
0020112A  1639 00C00003           2479m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201130  0803 0000               2480m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201134  6700 0010               2481m     BEQ CONTINUE_171                                ; NOTHING, CONTINUE
00201138                          2482m  
00201138                          2483mm     READ_CHAR D2
00201138                 TRUE     2484mm     IFEQ DEBUG
00201138  1439 00C00007           2485mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020113E                          2486mm     ENDC
0020113E                 FALSE    2487mm     IFNE DEBUG
0020113E                          2488mm     ENDC
0020113E                          2489mm      
0020113E  B43C 001B               2490mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201142  6700 EEC4               2491mm     BEQ START
00201146                          2492mm     ENDM
00201146                          2493m CONTINUE_171
00201146  1639 00C00013           2494m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020114C  0803 0000               2495m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201150  67D8                    2496m     BEQ WAIT_FOR_READY_171                      ; NOTHING, CHECK AGAIN
00201152                          2497m     
00201152  1439 00C00017           2498m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201158  13C2 00E00001           2499m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020115E                          2500m     
0020115E                          2501m     ENDM
0020115E                          2502m                     PRINT_CHAR D2,D3
0020115E                          2503m WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020115E                 TRUE     2504m     IFEQ DEBUG
0020115E  1639 00C00003           2505m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201164  0803 0002               2506m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201168  67F4                    2507m         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
0020116A  13C2 00C00007           2508m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201170                          2509m     ENDC
00201170                          2510m     
00201170                 FALSE    2511m     IFNE DEBUG
00201170                          2512m     ENDC
00201170                          2513m 
00201170                          2514m     ENDM
00201170                          2515m                     HEX2BIN D2,D2,A0
00201170  41F9 00201B0A           2516m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201176  0402 0030               2517m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020117A  C4BC 000000FF           2518m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201180  1430 2000               2519m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201184                          2520m     ENDM
00201184  8E82                    2521                      OR.L D2,D7
00201186                          2522                      
00201186  7400                    2523                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00201188  1407                    2524                      MOVE.B D7,D2
0020118A  DC82                    2525                      ADD.L D2,D6
0020118C                          2526                      
0020118C  32C7                    2527                      MOVE.W D7,(A1)+             ; store it!
0020118E                          2528              
0020118E                          2529                  ENDW
0020118E  6000 FE70               2530s     BRA _10000004
00201192                          2531s _10000005
00201192                          2532              
00201192                          2533                  IF D5 <EQ> #1 THEN
00201192  BA7C 0001               2534s     CMP.W   #1,D5
00201196  6600 00CE               2535s     BNE _00000006
0020119A  7E00                    2536                      MOVE.L #0,D7                ; D7 holds the word
0020119C                          2537                              
0020119C                          2538m                     DOWNLOAD D2,D3              ; MS 4 bits
0020119C                          2539m WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020119C                          2540m 
0020119C  1639 00C00003           2541m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002011A2  0803 0000               2542m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002011A6  6700 0010               2543m     BEQ CONTINUE_175                                ; NOTHING, CONTINUE
002011AA                          2544m  
002011AA                          2545mm     READ_CHAR D2
002011AA                 TRUE     2546mm     IFEQ DEBUG
002011AA  1439 00C00007           2547mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002011B0                          2548mm     ENDC
002011B0                 FALSE    2549mm     IFNE DEBUG
002011B0                          2550mm     ENDC
002011B0                          2551mm      
002011B0  B43C 001B               2552mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002011B4  6700 EE52               2553mm     BEQ START
002011B8                          2554mm     ENDM
002011B8                          2555m CONTINUE_175
002011B8  1639 00C00013           2556m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002011BE  0803 0000               2557m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002011C2  67D8                    2558m     BEQ WAIT_FOR_READY_175                      ; NOTHING, CHECK AGAIN
002011C4                          2559m     
002011C4  1439 00C00017           2560m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002011CA  13C2 00E00001           2561m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002011D0                          2562m     
002011D0                          2563m     ENDM
002011D0                          2564m                     PRINT_CHAR D2,D3
002011D0                          2565m WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011D0                 TRUE     2566m     IFEQ DEBUG
002011D0  1639 00C00003           2567m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011D6  0803 0002               2568m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011DA  67F4                    2569m         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
002011DC  13C2 00C00007           2570m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002011E2                          2571m     ENDC
002011E2                          2572m     
002011E2                 FALSE    2573m     IFNE DEBUG
002011E2                          2574m     ENDC
002011E2                          2575m 
002011E2                          2576m     ENDM
002011E2                          2577m                     HEX2BIN D2,D2,A0
002011E2  41F9 00201B0A           2578m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002011E8  0402 0030               2579m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002011EC  C4BC 000000FF           2580m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002011F2  1430 2000               2581m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002011F6                          2582m     ENDM
002011F6  8E82                    2583                      OR.L D2,D7
002011F8  E98F                    2584                      LSL.L #4,D7
002011FA                          2585                       
002011FA                          2586m                     DOWNLOAD D2,D3              ; LS 4 bits    
002011FA                          2587m WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011FA                          2588m 
002011FA  1639 00C00003           2589m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201200  0803 0000               2590m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201204  6700 0010               2591m     BEQ CONTINUE_179                                ; NOTHING, CONTINUE
00201208                          2592m  
00201208                          2593mm     READ_CHAR D2
00201208                 TRUE     2594mm     IFEQ DEBUG
00201208  1439 00C00007           2595mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020120E                          2596mm     ENDC
0020120E                 FALSE    2597mm     IFNE DEBUG
0020120E                          2598mm     ENDC
0020120E                          2599mm      
0020120E  B43C 001B               2600mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201212  6700 EDF4               2601mm     BEQ START
00201216                          2602mm     ENDM
00201216                          2603m CONTINUE_179
00201216  1639 00C00013           2604m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020121C  0803 0000               2605m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201220  67D8                    2606m     BEQ WAIT_FOR_READY_179                      ; NOTHING, CHECK AGAIN
00201222                          2607m     
00201222  1439 00C00017           2608m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201228  13C2 00E00001           2609m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020122E                          2610m     
0020122E                          2611m     ENDM
0020122E                          2612m                     PRINT_CHAR D2,D3
0020122E                          2613m WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122E                 TRUE     2614m     IFEQ DEBUG
0020122E  1639 00C00003           2615m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201234  0803 0002               2616m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201238  67F4                    2617m         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
0020123A  13C2 00C00007           2618m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201240                          2619m     ENDC
00201240                          2620m     
00201240                 FALSE    2621m     IFNE DEBUG
00201240                          2622m     ENDC
00201240                          2623m 
00201240                          2624m     ENDM
00201240                          2625m                     HEX2BIN D2,D2,A0
00201240  41F9 00201B0A           2626m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201246  0402 0030               2627m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020124A  C4BC 000000FF           2628m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201250  1430 2000               2629m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201254                          2630m     ENDM
00201254  8E82                    2631                      OR.L D2,D7
00201256                          2632                                  
00201256  DC87                    2633                      ADD.L D7,D6                 ; add into checksum
00201258                          2634                      
00201258  3611                    2635                      MOVE.W (A1),D3              ; get the current data and replace the top byte
0020125A  E18F                    2636                      LSL.L #8,D7
0020125C  C6BC 000000FF           2637                      AND.L #$00FF,D3
00201262  8687                    2638                      OR.L D7,D3
00201264                          2639  
00201264  32C3                    2640                      MOVE.W D3,(A1)+             ; store it!
00201266                          2641                  ENDI
00201266                          2642s _00000006
00201266                          2643m                 PRINT_CRLF D3
00201266                          2644mm     PRINT_CHAR #13,D3                           ; CR
00201266                          2645mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201266                 TRUE     2646mm     IFEQ DEBUG
00201266  1639 00C00003           2647mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020126C  0803 0002               2648mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201270  67F4                    2649mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00201272  13FC 000D 00C00007      2650mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020127A                          2651mm     ENDC
0020127A                          2652mm     
0020127A                 FALSE    2653mm     IFNE DEBUG
0020127A                          2654mm     ENDC
0020127A                          2655mm 
0020127A                          2656mm     ENDM
0020127A                          2657mm     PRINT_CHAR #10,D3                           ; LF
0020127A                          2658mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020127A                 TRUE     2659mm     IFEQ DEBUG
0020127A  1639 00C00003           2660mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201280  0803 0002               2661mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201284  67F4                    2662mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00201286  13FC 000A 00C00007      2663mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020128E                          2664mm     ENDC
0020128E                          2665mm     
0020128E                 FALSE    2666mm     IFNE DEBUG
0020128E                          2667mm     ENDC
0020128E                          2668mm 
0020128E                          2669mm     ENDM
0020128E                          2670m     ENDM
0020128E  43F9 002004A0           2671                  LEA WAIT_FOR_SRECORD,A1         ; next place to go
00201294                          2672              ELSE
00201294  6000 0252               2673s     BRA _00000007
00201298                          2674s _00000005
00201298                          2675                  IF.B D7 <EQ> #'8' THEN.L        ; termination record, exit
00201298  BE3C 0038               2676s     CMP.B   #'8',D7
0020129C  6600 01E4               2677s     BNE.L   _00000008
002012A0  7E00                    2678                      MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002012A2                          2679m                     DOWNLOAD D2,D3              ; top byte
002012A2                          2680m WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012A2                          2681m 
002012A2  1639 00C00003           2682m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002012A8  0803 0000               2683m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012AC  6700 0010               2684m     BEQ CONTINUE_186                                ; NOTHING, CONTINUE
002012B0                          2685m  
002012B0                          2686mm     READ_CHAR D2
002012B0                 TRUE     2687mm     IFEQ DEBUG
002012B0  1439 00C00007           2688mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002012B6                          2689mm     ENDC
002012B6                 FALSE    2690mm     IFNE DEBUG
002012B6                          2691mm     ENDC
002012B6                          2692mm      
002012B6  B43C 001B               2693mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002012BA  6700 ED4C               2694mm     BEQ START
002012BE                          2695mm     ENDM
002012BE                          2696m CONTINUE_186
002012BE  1639 00C00013           2697m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002012C4  0803 0000               2698m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012C8  67D8                    2699m     BEQ WAIT_FOR_READY_186                      ; NOTHING, CHECK AGAIN
002012CA                          2700m     
002012CA  1439 00C00017           2701m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002012D0  13C2 00E00001           2702m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002012D6                          2703m     
002012D6                          2704m     ENDM
002012D6                          2705m                     HEX2BIN D2,D2,A0
002012D6  41F9 00201B0A           2706m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002012DC  0402 0030               2707m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012E0  C4BC 000000FF           2708m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002012E6  1430 2000               2709m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002012EA                          2710m     ENDM
002012EA  8E82                    2711                      OR.L D2,D7
002012EC  E98F                    2712                      LSL.L #4,D7
002012EE                          2713m                     DOWNLOAD D2,D3         
002012EE                          2714m WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012EE                          2715m 
002012EE  1639 00C00003           2716m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002012F4  0803 0000               2717m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012F8  6700 0010               2718m     BEQ CONTINUE_189                                ; NOTHING, CONTINUE
002012FC                          2719m  
002012FC                          2720mm     READ_CHAR D2
002012FC                 TRUE     2721mm     IFEQ DEBUG
002012FC  1439 00C00007           2722mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201302                          2723mm     ENDC
00201302                 FALSE    2724mm     IFNE DEBUG
00201302                          2725mm     ENDC
00201302                          2726mm      
00201302  B43C 001B               2727mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201306  6700 ED00               2728mm     BEQ START
0020130A                          2729mm     ENDM
0020130A                          2730m CONTINUE_189
0020130A  1639 00C00013           2731m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201310  0803 0000               2732m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201314  67D8                    2733m     BEQ WAIT_FOR_READY_189                      ; NOTHING, CHECK AGAIN
00201316                          2734m     
00201316  1439 00C00017           2735m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020131C  13C2 00E00001           2736m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201322                          2737m     
00201322                          2738m     ENDM
00201322                          2739m                     HEX2BIN D2,D2,A0
00201322  41F9 00201B0A           2740m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201328  0402 0030               2741m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020132C  C4BC 000000FF           2742m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201332  1430 2000               2743m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201336                          2744m     ENDM
00201336  8E82                    2745                      OR.L D2,D7
00201338                          2746                  
00201338  DC87                    2747                      ADD.L D7,D6                 ; add top byte of address into checksum
0020133A                          2748  
0020133A  E98F                    2749                      LSL.L #4,D7                 ; middle byte
0020133C                          2750m                     DOWNLOAD D2,D3
0020133C                          2751m WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133C                          2752m 
0020133C  1639 00C00003           2753m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201342  0803 0000               2754m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201346  6700 0010               2755m     BEQ CONTINUE_192                                ; NOTHING, CONTINUE
0020134A                          2756m  
0020134A                          2757mm     READ_CHAR D2
0020134A                 TRUE     2758mm     IFEQ DEBUG
0020134A  1439 00C00007           2759mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201350                          2760mm     ENDC
00201350                 FALSE    2761mm     IFNE DEBUG
00201350                          2762mm     ENDC
00201350                          2763mm      
00201350  B43C 001B               2764mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201354  6700 ECB2               2765mm     BEQ START
00201358                          2766mm     ENDM
00201358                          2767m CONTINUE_192
00201358  1639 00C00013           2768m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020135E  0803 0000               2769m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201362  67D8                    2770m     BEQ WAIT_FOR_READY_192                      ; NOTHING, CHECK AGAIN
00201364                          2771m     
00201364  1439 00C00017           2772m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020136A  13C2 00E00001           2773m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201370                          2774m     
00201370                          2775m     ENDM
00201370                          2776m                     HEX2BIN D2,D2,A0
00201370  41F9 00201B0A           2777m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201376  0402 0030               2778m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020137A  C4BC 000000FF           2779m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201380  1430 2000               2780m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201384                          2781m     ENDM
00201384  8E82                    2782                      OR.L D2,D7
00201386  E98F                    2783                      LSL.L #4,D7        
00201388                          2784m                     DOWNLOAD D2,D3
00201388                          2785m WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201388                          2786m 
00201388  1639 00C00003           2787m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020138E  0803 0000               2788m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201392  6700 0010               2789m     BEQ CONTINUE_195                                ; NOTHING, CONTINUE
00201396                          2790m  
00201396                          2791mm     READ_CHAR D2
00201396                 TRUE     2792mm     IFEQ DEBUG
00201396  1439 00C00007           2793mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020139C                          2794mm     ENDC
0020139C                 FALSE    2795mm     IFNE DEBUG
0020139C                          2796mm     ENDC
0020139C                          2797mm      
0020139C  B43C 001B               2798mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002013A0  6700 EC66               2799mm     BEQ START
002013A4                          2800mm     ENDM
002013A4                          2801m CONTINUE_195
002013A4  1639 00C00013           2802m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002013AA  0803 0000               2803m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002013AE  67D8                    2804m     BEQ WAIT_FOR_READY_195                      ; NOTHING, CHECK AGAIN
002013B0                          2805m     
002013B0  1439 00C00017           2806m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002013B6  13C2 00E00001           2807m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002013BC                          2808m     
002013BC                          2809m     ENDM
002013BC                          2810m                     HEX2BIN D2,D2,A0
002013BC  41F9 00201B0A           2811m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002013C2  0402 0030               2812m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013C6  C4BC 000000FF           2813m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002013CC  1430 2000               2814m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002013D0                          2815m     ENDM
002013D0  8E82                    2816                      OR.L D2,D7
002013D2                          2817          
002013D2  7400                    2818                      MOVE.L #0,D2                ; rextract middle byte of address and add into checksum
002013D4  1407                    2819                      MOVE.B D7,D2
002013D6  DC82                    2820                      ADD.L D2,D6
002013D8                          2821                    
002013D8  E98F                    2822                      LSL.L #4,D7                 ; bottom byte
002013DA                          2823m                     DOWNLOAD D2,D3
002013DA                          2824m WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013DA                          2825m 
002013DA  1639 00C00003           2826m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002013E0  0803 0000               2827m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002013E4  6700 0010               2828m     BEQ CONTINUE_198                                ; NOTHING, CONTINUE
002013E8                          2829m  
002013E8                          2830mm     READ_CHAR D2
002013E8                 TRUE     2831mm     IFEQ DEBUG
002013E8  1439 00C00007           2832mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002013EE                          2833mm     ENDC
002013EE                 FALSE    2834mm     IFNE DEBUG
002013EE                          2835mm     ENDC
002013EE                          2836mm      
002013EE  B43C 001B               2837mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002013F2  6700 EC14               2838mm     BEQ START
002013F6                          2839mm     ENDM
002013F6                          2840m CONTINUE_198
002013F6  1639 00C00013           2841m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002013FC  0803 0000               2842m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201400  67D8                    2843m     BEQ WAIT_FOR_READY_198                      ; NOTHING, CHECK AGAIN
00201402                          2844m     
00201402  1439 00C00017           2845m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201408  13C2 00E00001           2846m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020140E                          2847m     
0020140E                          2848m     ENDM
0020140E                          2849m                     HEX2BIN D2,D2,A0
0020140E  41F9 00201B0A           2850m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201414  0402 0030               2851m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201418  C4BC 000000FF           2852m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020141E  1430 2000               2853m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201422                          2854m     ENDM
00201422  8E82                    2855                      OR.L D2,D7
00201424  E98F                    2856                      LSL.L #4,D7        
00201426                          2857m                     DOWNLOAD D2,D3
00201426                          2858m WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201426                          2859m 
00201426  1639 00C00003           2860m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020142C  0803 0000               2861m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201430  6700 0010               2862m     BEQ CONTINUE_201                                ; NOTHING, CONTINUE
00201434                          2863m  
00201434                          2864mm     READ_CHAR D2
00201434                 TRUE     2865mm     IFEQ DEBUG
00201434  1439 00C00007           2866mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020143A                          2867mm     ENDC
0020143A                 FALSE    2868mm     IFNE DEBUG
0020143A                          2869mm     ENDC
0020143A                          2870mm      
0020143A  B43C 001B               2871mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020143E  6700 EBC8               2872mm     BEQ START
00201442                          2873mm     ENDM
00201442                          2874m CONTINUE_201
00201442  1639 00C00013           2875m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201448  0803 0000               2876m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020144C  67D8                    2877m     BEQ WAIT_FOR_READY_201                      ; NOTHING, CHECK AGAIN
0020144E                          2878m     
0020144E  1439 00C00017           2879m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201454  13C2 00E00001           2880m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020145A                          2881m     
0020145A                          2882m     ENDM
0020145A                          2883m                     HEX2BIN D2,D2,A0
0020145A  41F9 00201B0A           2884m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201460  0402 0030               2885m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201464  C4BC 000000FF           2886m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020146A  1430 2000               2887m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020146E                          2888m     ENDM
0020146E  8E82                    2889                      OR.L D2,D7
00201470                          2890                  
00201470  7400                    2891                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00201472  1407                    2892                      MOVE.B D7,D2
00201474  DC82                    2893                      ADD.L D2,D6
00201476                          2894                    
00201476  2447                    2895                      MOVE.L D7,A2                ; start address -> A2
00201478                          2896                  
00201478  43F9 00201638           2897                      LEA DOWNLOAD_DONE,A1        ; next place to go
0020147E                          2898                  ELSE
0020147E  6000 0068               2899s     BRA _00000009
00201482                          2900s _00000008
00201482  41F9 00201ABF           2901                      LEA UNREC,A0                ; warn for unrecognised type
00201488                          2902m                     PRINT_STR A0,D3
00201488                          2903m LOOP_204
00201488  0C10 0000               2904m     CMP.B #0,(A0)                               ; 0 -> DONE
0020148C  6700 001A               2905m     BEQ EXIT_204
00201490                          2906mm     PRINT_CHAR (A0)+,D3
00201490                          2907mm WAIT_FOR_READY_205                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201490                 TRUE     2908mm     IFEQ DEBUG
00201490  1639 00C00003           2909mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201496  0803 0002               2910mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020149A  67F4                    2911mm         BEQ WAIT_FOR_READY_205                      ; NO SPACE, CHECK AGAIN
0020149C  13D8 00C00007           2912mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002014A2                          2913mm     ENDC
002014A2                          2914mm     
002014A2                 FALSE    2915mm     IFNE DEBUG
002014A2                          2916mm     ENDC
002014A2                          2917mm 
002014A2                          2918mm     ENDM
002014A2  4EF9 00201488           2919m     JMP LOOP_204
002014A8                          2920m EXIT_204
002014A8                          2921m     ENDM
002014A8                          2922m                     PRINT_CHAR D7,D3
002014A8                          2923m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014A8                 TRUE     2924m     IFEQ DEBUG
002014A8  1639 00C00003           2925m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014AE  0803 0002               2926m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014B2  67F4                    2927m         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
002014B4  13C7 00C00007           2928m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002014BA                          2929m     ENDC
002014BA                          2930m     
002014BA                 FALSE    2931m     IFNE DEBUG
002014BA                          2932m     ENDC
002014BA                          2933m 
002014BA                          2934m     ENDM
002014BA                          2935m                     PRINT_CRLF D3
002014BA                          2936mm     PRINT_CHAR #13,D3                           ; CR
002014BA                          2937mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014BA                 TRUE     2938mm     IFEQ DEBUG
002014BA  1639 00C00003           2939mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014C0  0803 0002               2940mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014C4  67F4                    2941mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
002014C6  13FC 000D 00C00007      2942mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002014CE                          2943mm     ENDC
002014CE                          2944mm     
002014CE                 FALSE    2945mm     IFNE DEBUG
002014CE                          2946mm     ENDC
002014CE                          2947mm 
002014CE                          2948mm     ENDM
002014CE                          2949mm     PRINT_CHAR #10,D3                           ; LF
002014CE                          2950mm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014CE                 TRUE     2951mm     IFEQ DEBUG
002014CE  1639 00C00003           2952mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014D4  0803 0002               2953mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014D8  67F4                    2954mm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
002014DA  13FC 000A 00C00007      2955mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002014E2                          2956mm     ENDC
002014E2                          2957mm     
002014E2                 FALSE    2958mm     IFNE DEBUG
002014E2                          2959mm     ENDC
002014E2                          2960mm 
002014E2                          2961mm     ENDM
002014E2                          2962m     ENDM
002014E2                          2963              
002014E2  4EF9 002004A0           2964                      JMP WAIT_FOR_SRECORD        ; ignore any other type    
002014E8                          2965                  ENDI
002014E8                          2966s _00000009
002014E8                          2967              ENDI
002014E8                          2968s _00000007
002014E8                          2969          ENDI
002014E8                          2970s _00000004
002014E8                          2971      ENDI
002014E8                          2972s _00000001
002014E8                          2973      
002014E8  4686                    2974      NOT.L D6                                    ; ones complement the checksum
002014EA  0286 000000FF           2975      ANDI.L #$FF,D6                              ; and take the LSByte
002014F0                          2976          
002014F0  7E00                    2977      MOVE.L #0,D7                                ; read the checksum from the data stream
002014F2                          2978m     DOWNLOAD D2,D3                              ; top byte
002014F2                          2979m WAIT_FOR_READY_210                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014F2                          2980m 
002014F2  1639 00C00003           2981m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002014F8  0803 0000               2982m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002014FC  6700 0010               2983m     BEQ CONTINUE_210                                ; NOTHING, CONTINUE
00201500                          2984m  
00201500                          2985mm     READ_CHAR D2
00201500                 TRUE     2986mm     IFEQ DEBUG
00201500  1439 00C00007           2987mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201506                          2988mm     ENDC
00201506                 FALSE    2989mm     IFNE DEBUG
00201506                          2990mm     ENDC
00201506                          2991mm      
00201506  B43C 001B               2992mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020150A  6700 EAFC               2993mm     BEQ START
0020150E                          2994mm     ENDM
0020150E                          2995m CONTINUE_210
0020150E  1639 00C00013           2996m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201514  0803 0000               2997m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201518  67D8                    2998m     BEQ WAIT_FOR_READY_210                      ; NOTHING, CHECK AGAIN
0020151A                          2999m     
0020151A  1439 00C00017           3000m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201520  13C2 00E00001           3001m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201526                          3002m     
00201526                          3003m     ENDM
00201526                          3004m     HEX2BIN D2,D2,A0
00201526  41F9 00201B0A           3005m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020152C  0402 0030               3006m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201530  C4BC 000000FF           3007m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201536  1430 2000               3008m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020153A                          3009m     ENDM
0020153A  8E82                    3010      OR.L D2,D7
0020153C  E98F                    3011      LSL.L #4,D7
0020153E                          3012m     DOWNLOAD D2,D3                              ; bottom byte
0020153E                          3013m WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020153E                          3014m 
0020153E  1639 00C00003           3015m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201544  0803 0000               3016m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201548  6700 0010               3017m     BEQ CONTINUE_213                                ; NOTHING, CONTINUE
0020154C                          3018m  
0020154C                          3019mm     READ_CHAR D2
0020154C                 TRUE     3020mm     IFEQ DEBUG
0020154C  1439 00C00007           3021mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201552                          3022mm     ENDC
00201552                 FALSE    3023mm     IFNE DEBUG
00201552                          3024mm     ENDC
00201552                          3025mm      
00201552  B43C 001B               3026mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201556  6700 EAB0               3027mm     BEQ START
0020155A                          3028mm     ENDM
0020155A                          3029m CONTINUE_213
0020155A  1639 00C00013           3030m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201560  0803 0000               3031m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201564  67D8                    3032m     BEQ WAIT_FOR_READY_213                      ; NOTHING, CHECK AGAIN
00201566                          3033m     
00201566  1439 00C00017           3034m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020156C  13C2 00E00001           3035m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201572                          3036m     
00201572                          3037m     ENDM
00201572                          3038m     HEX2BIN D2,D2,A0
00201572  41F9 00201B0A           3039m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201578  0402 0030               3040m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020157C  C4BC 000000FF           3041m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201582  1430 2000               3042m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201586                          3043m     ENDM
00201586  8E82                    3044      OR.L D2,D7
00201588                          3045                  
00201588                          3046      IF.B D7 <NE> D6 THEN.L
00201588  BE06                    3047s     CMP.B   D6,D7
0020158A  6700 00AA               3048s     BEQ.L   _0000000A
0020158E  41F9 00201AD6           3049          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00201594                          3050m         PRINT_STR A0,D3
00201594                          3051m LOOP_216
00201594  0C10 0000               3052m     CMP.B #0,(A0)                               ; 0 -> DONE
00201598  6700 001A               3053m     BEQ EXIT_216
0020159C                          3054mm     PRINT_CHAR (A0)+,D3
0020159C                          3055mm WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020159C                 TRUE     3056mm     IFEQ DEBUG
0020159C  1639 00C00003           3057mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015A2  0803 0002               3058mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015A6  67F4                    3059mm         BEQ WAIT_FOR_READY_217                      ; NO SPACE, CHECK AGAIN
002015A8  13D8 00C00007           3060mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002015AE                          3061mm     ENDC
002015AE                          3062mm     
002015AE                 FALSE    3063mm     IFNE DEBUG
002015AE                          3064mm     ENDC
002015AE                          3065mm 
002015AE                          3066mm     ENDM
002015AE  4EF9 00201594           3067m     JMP LOOP_216
002015B4                          3068m EXIT_216
002015B4                          3069m     ENDM
002015B4                          3070m         PRINT_REG D4,D3,D6,D7,A0
002015B4                          3071mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002015B4                          3072mm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015B4                 TRUE     3073mm     IFEQ DEBUG
002015B4  1639 00C00003           3074mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015BA  0803 0002               3075mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015BE  67F4                    3076mm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
002015C0  13FC 0030 00C00007      3077mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002015C8                          3078mm     ENDC
002015C8                          3079mm     
002015C8                 FALSE    3080mm     IFNE DEBUG
002015C8                          3081mm     ENDC
002015C8                          3082mm 
002015C8                          3083mm     ENDM
002015C8                          3084mm     PRINT_CHAR #'x',D3
002015C8                          3085mm WAIT_FOR_READY_220                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015C8                 TRUE     3086mm     IFEQ DEBUG
002015C8  1639 00C00003           3087mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015CE  0803 0002               3088mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015D2  67F4                    3089mm         BEQ WAIT_FOR_READY_220                      ; NO SPACE, CHECK AGAIN
002015D4  13FC 0078 00C00007      3090mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002015DC                          3091mm     ENDC
002015DC                          3092mm     
002015DC                 FALSE    3093mm     IFNE DEBUG
002015DC                          3094mm     ENDC
002015DC                          3095mm 
002015DC                          3096mm     ENDM
002015DC  7E07                    3097m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002015DE                          3098m LOOP_218
002015DE                          3099mm     BIN2HEX D4,D6,A0
002015DE  41F9 00201AFA           3100mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002015E4  E99C                    3101mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002015E6  1C04                    3102mm     MOVE.B D4,D6
002015E8  0286 0000000F           3103mm     ANDI.L #$F,D6
002015EE  1C30 6000               3104mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
002015F2                          3105mm     ENDM
002015F2                          3106mm     PRINT_CHAR D6,D3
002015F2                          3107mm WAIT_FOR_READY_222                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015F2                 TRUE     3108mm     IFEQ DEBUG
002015F2  1639 00C00003           3109mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015F8  0803 0002               3110mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015FC  67F4                    3111mm         BEQ WAIT_FOR_READY_222                      ; NO SPACE, CHECK AGAIN
002015FE  13C6 00C00007           3112mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201604                          3113mm     ENDC
00201604                          3114mm     
00201604                 FALSE    3115mm     IFNE DEBUG
00201604                          3116mm     ENDC
00201604                          3117mm 
00201604                          3118mm     ENDM
00201604  57CF FFD8               3119m     DBEQ D7,LOOP_218
00201608                          3120m     ENDM
00201608                          3121m         PRINT_CRLF D3
00201608                          3122mm     PRINT_CHAR #13,D3                           ; CR
00201608                          3123mm WAIT_FOR_READY_224                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201608                 TRUE     3124mm     IFEQ DEBUG
00201608  1639 00C00003           3125mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020160E  0803 0002               3126mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201612  67F4                    3127mm         BEQ WAIT_FOR_READY_224                      ; NO SPACE, CHECK AGAIN
00201614  13FC 000D 00C00007      3128mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020161C                          3129mm     ENDC
0020161C                          3130mm     
0020161C                 FALSE    3131mm     IFNE DEBUG
0020161C                          3132mm     ENDC
0020161C                          3133mm 
0020161C                          3134mm     ENDM
0020161C                          3135mm     PRINT_CHAR #10,D3                           ; LF
0020161C                          3136mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020161C                 TRUE     3137mm     IFEQ DEBUG
0020161C  1639 00C00003           3138mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201622  0803 0002               3139mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201626  67F4                    3140mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
00201628  13FC 000A 00C00007      3141mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201630                          3142mm     ENDC
00201630                          3143mm     
00201630                 FALSE    3144mm     IFNE DEBUG
00201630                          3145mm     ENDC
00201630                          3146mm 
00201630                          3147mm     ENDM
00201630                          3148m     ENDM
00201630  4EF9 00200188           3149          JMP MAIN_LOOP
00201636                          3150      ENDI
00201636                          3151s _0000000A
00201636                          3152      
00201636  4ED1                    3153      JMP (A1)
00201638                          3154  DOWNLOAD_DONE
00201638                          3155m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00201638                          3156mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201638                          3157mm WAIT_FOR_READY_227                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201638                 TRUE     3158mm     IFEQ DEBUG
00201638  1639 00C00003           3159mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020163E  0803 0002               3160mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201642  67F4                    3161mm         BEQ WAIT_FOR_READY_227                      ; NO SPACE, CHECK AGAIN
00201644  13FC 0030 00C00007      3162mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020164C                          3163mm     ENDC
0020164C                          3164mm     
0020164C                 FALSE    3165mm     IFNE DEBUG
0020164C                          3166mm     ENDC
0020164C                          3167mm 
0020164C                          3168mm     ENDM
0020164C                          3169mm     PRINT_CHAR #'x',D3
0020164C                          3170mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020164C                 TRUE     3171mm     IFEQ DEBUG
0020164C  1639 00C00003           3172mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201652  0803 0002               3173mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201656  67F4                    3174mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
00201658  13FC 0078 00C00007      3175mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00201660                          3176mm     ENDC
00201660                          3177mm     
00201660                 FALSE    3178mm     IFNE DEBUG
00201660                          3179mm     ENDC
00201660                          3180mm 
00201660                          3181mm     ENDM
00201660  7C07                    3182m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201662                          3183m LOOP_226
00201662                          3184mm     BIN2HEX D4,D7,A0
00201662  41F9 00201AFA           3185mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201668  E99C                    3186mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020166A  1E04                    3187mm     MOVE.B D4,D7
0020166C  0287 0000000F           3188mm     ANDI.L #$F,D7
00201672  1E30 7000               3189mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00201676                          3190mm     ENDM
00201676                          3191mm     PRINT_CHAR D7,D3
00201676                          3192mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201676                 TRUE     3193mm     IFEQ DEBUG
00201676  1639 00C00003           3194mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020167C  0803 0002               3195mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201680  67F4                    3196mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00201682  13C7 00C00007           3197mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201688                          3198mm     ENDC
00201688                          3199mm     
00201688                 FALSE    3200mm     IFNE DEBUG
00201688                          3201mm     ENDC
00201688                          3202mm 
00201688                          3203mm     ENDM
00201688  57CE FFD8               3204m     DBEQ D6,LOOP_226
0020168C                          3205m     ENDM
0020168C  41F9 00201A9D           3206      LEA READ,A0
00201692                          3207m     PRINT_STR A0,D3
00201692                          3208m LOOP_231
00201692  0C10 0000               3209m     CMP.B #0,(A0)                               ; 0 -> DONE
00201696  6700 001A               3210m     BEQ EXIT_231
0020169A                          3211mm     PRINT_CHAR (A0)+,D3
0020169A                          3212mm WAIT_FOR_READY_232                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020169A                 TRUE     3213mm     IFEQ DEBUG
0020169A  1639 00C00003           3214mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016A0  0803 0002               3215mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016A4  67F4                    3216mm         BEQ WAIT_FOR_READY_232                      ; NO SPACE, CHECK AGAIN
002016A6  13D8 00C00007           3217mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002016AC                          3218mm     ENDC
002016AC                          3219mm     
002016AC                 FALSE    3220mm     IFNE DEBUG
002016AC                          3221mm     ENDC
002016AC                          3222mm 
002016AC                          3223mm     ENDM
002016AC  4EF9 00201692           3224m     JMP LOOP_231
002016B2                          3225m EXIT_231
002016B2                          3226m     ENDM
002016B2  2E0A                    3227      MOVE.L A2,D7                                ; set address accumulator to start address
002016B4                          3228m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
002016B4                          3229mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002016B4                          3230mm WAIT_FOR_READY_234                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016B4                 TRUE     3231mm     IFEQ DEBUG
002016B4  1639 00C00003           3232mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016BA  0803 0002               3233mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016BE  67F4                    3234mm         BEQ WAIT_FOR_READY_234                      ; NO SPACE, CHECK AGAIN
002016C0  13FC 0030 00C00007      3235mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002016C8                          3236mm     ENDC
002016C8                          3237mm     
002016C8                 FALSE    3238mm     IFNE DEBUG
002016C8                          3239mm     ENDC
002016C8                          3240mm 
002016C8                          3241mm     ENDM
002016C8                          3242mm     PRINT_CHAR #'x',D3
002016C8                          3243mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016C8                 TRUE     3244mm     IFEQ DEBUG
002016C8  1639 00C00003           3245mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016CE  0803 0002               3246mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016D2  67F4                    3247mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
002016D4  13FC 0078 00C00007      3248mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002016DC                          3249mm     ENDC
002016DC                          3250mm     
002016DC                 FALSE    3251mm     IFNE DEBUG
002016DC                          3252mm     ENDC
002016DC                          3253mm 
002016DC                          3254mm     ENDM
002016DC  7C07                    3255m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002016DE                          3256m LOOP_233
002016DE                          3257mm     BIN2HEX D7,D2,A0
002016DE  41F9 00201AFA           3258mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002016E4  E99F                    3259mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002016E6  1407                    3260mm     MOVE.B D7,D2
002016E8  0282 0000000F           3261mm     ANDI.L #$F,D2
002016EE  1430 2000               3262mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002016F2                          3263mm     ENDM
002016F2                          3264mm     PRINT_CHAR D2,D3
002016F2                          3265mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016F2                 TRUE     3266mm     IFEQ DEBUG
002016F2  1639 00C00003           3267mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016F8  0803 0002               3268mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016FC  67F4                    3269mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
002016FE  13C2 00C00007           3270mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201704                          3271mm     ENDC
00201704                          3272mm     
00201704                 FALSE    3273mm     IFNE DEBUG
00201704                          3274mm     ENDC
00201704                          3275mm 
00201704                          3276mm     ENDM
00201704  57CE FFD8               3277m     DBEQ D6,LOOP_233
00201708                          3278m     ENDM
00201708                          3279m     PRINT_CRLF D3     
00201708                          3280mm     PRINT_CHAR #13,D3                           ; CR
00201708                          3281mm WAIT_FOR_READY_239                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201708                 TRUE     3282mm     IFEQ DEBUG
00201708  1639 00C00003           3283mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020170E  0803 0002               3284mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201712  67F4                    3285mm         BEQ WAIT_FOR_READY_239                      ; NO SPACE, CHECK AGAIN
00201714  13FC 000D 00C00007      3286mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020171C                          3287mm     ENDC
0020171C                          3288mm     
0020171C                 FALSE    3289mm     IFNE DEBUG
0020171C                          3290mm     ENDC
0020171C                          3291mm 
0020171C                          3292mm     ENDM
0020171C                          3293mm     PRINT_CHAR #10,D3                           ; LF
0020171C                          3294mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020171C                 TRUE     3295mm     IFEQ DEBUG
0020171C  1639 00C00003           3296mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201722  0803 0002               3297mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201726  67F4                    3298mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00201728  13FC 000A 00C00007      3299mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201730                          3300mm     ENDC
00201730                          3301mm     
00201730                 FALSE    3302mm     IFNE DEBUG
00201730                          3303mm     ENDC
00201730                          3304mm 
00201730                          3305mm     ENDM
00201730                          3306m     ENDM
00201730                          3307          
00201730  4EF9 00200188           3308      JMP MAIN_LOOP
00201736                          3309      
00201736                          3310  G
00201736  2047                    3311      MOVE.L D7,A0                                ; address accumulator -> address register
00201738  3E3C 0000               3312      MOVE #0,D7                                  ; clear the now used address accumulator
0020173C  4ED0                    3313      JMP (A0)                                    ; jump to it!
0020173E                          3314      
0020173E                          3315  Z
0020173E  207C 00200000           3316      MOVE.L #RAM,A0                              ; address of RAM
00201744  7000                    3317      MOVE.L #0,D0                                ; number of bytes
00201746                          3318     
00201746                          3319      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201746                          3320s _10000006
00201746  B0BC 00040000           3321s     CMP.L   #$40000,D0
0020174C  6E00 001A               3322s     BGT _10000007
00201750                          3323         
00201750  2200                    3324          MOVE.L D0,D1                            ; progress update
00201752  E089                    3325          LSR.L #8,D1 
00201754  E089                    3326          LSR.L #8,D1
00201756  0281 0000000F           3327          ANDI.L #$F,D1
0020175C  13C1 00E00001           3328          MOVE.B D1,DISPLAY
00201762                          3329  
00201762  20C0                    3330          MOVE.L D0,(A0)+ 
00201764  5880                    3331          ADD.L #4,D0
00201766                          3332      ENDW
00201766  60DE                    3333s     BRA _10000006
00201768                          3334s _10000007
00201768                          3335   
00201768  207C 00200000           3336      MOVE.L #RAM,A0                              ; address of RAM
0020176E  7000                    3337      MOVE.L #0,D0                                ; number of bytes
00201770                          3338     
00201770                          3339      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201770                          3340s _10000008
00201770  B0BC 00040000           3341s     CMP.L   #$40000,D0
00201776  6E00 00CC               3342s     BGT _10000009
0020177A                          3343  
0020177A  2200                    3344          MOVE.L D0,D1                            ; progress update
0020177C  E089                    3345          LSR.L #8,D1
0020177E  E089                    3346          LSR.L #8,D1
00201780  0281 0000000F           3347          ANDI.L #$F,D1
00201786  13C1 00E00001           3348          MOVE.B D1,DISPLAY
0020178C                          3349  
0020178C  2218                    3350          MOVE.L (A0)+,D1
0020178E                          3351            
0020178E                          3352          IF.L D0 <EQ> D1 THEN
0020178E  B081                    3353s     CMP.L   D1,D0
00201790  6600 0006               3354s     BNE _0000000B
00201794  6000 00A8               3355              BRA OK
00201798                          3356          ENDI 
00201798                          3357s _0000000B
00201798                          3358            
00201798  43F9 00201AE8           3359          LEA RAM_ERROR,A1
0020179E                          3360m         PRINT_STR A1,D1
0020179E                          3361m LOOP_241
0020179E  0C11 0000               3362m     CMP.B #0,(A1)                               ; 0 -> DONE
002017A2  6700 001A               3363m     BEQ EXIT_241
002017A6                          3364mm     PRINT_CHAR (A1)+,D1
002017A6                          3365mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017A6                 TRUE     3366mm     IFEQ DEBUG
002017A6  1239 00C00003           3367mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
002017AC  0801 0002               3368mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
002017B0  67F4                    3369mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
002017B2  13D9 00C00007           3370mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002017B8                          3371mm     ENDC
002017B8                          3372mm     
002017B8                 FALSE    3373mm     IFNE DEBUG
002017B8                          3374mm     ENDC
002017B8                          3375mm 
002017B8                          3376mm     ENDM
002017B8  4EF9 0020179E           3377m     JMP LOOP_241
002017BE                          3378m EXIT_241
002017BE                          3379m     ENDM
002017BE  2208                    3380          MOVE.L A0,D1
002017C0  5981                    3381          SUB.L #4,D1
002017C2                          3382m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
002017C2                          3383mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002017C2                          3384mm WAIT_FOR_READY_244                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017C2                 TRUE     3385mm     IFEQ DEBUG
002017C2  1639 00C00003           3386mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002017C8  0803 0002               3387mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002017CC  67F4                    3388mm         BEQ WAIT_FOR_READY_244                      ; NO SPACE, CHECK AGAIN
002017CE  13FC 0030 00C00007      3389mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002017D6                          3390mm     ENDC
002017D6                          3391mm     
002017D6                 FALSE    3392mm     IFNE DEBUG
002017D6                          3393mm     ENDC
002017D6                          3394mm 
002017D6                          3395mm     ENDM
002017D6                          3396mm     PRINT_CHAR #'x',D3
002017D6                          3397mm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017D6                 TRUE     3398mm     IFEQ DEBUG
002017D6  1639 00C00003           3399mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002017DC  0803 0002               3400mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002017E0  67F4                    3401mm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
002017E2  13FC 0078 00C00007      3402mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002017EA                          3403mm     ENDC
002017EA                          3404mm     
002017EA                 FALSE    3405mm     IFNE DEBUG
002017EA                          3406mm     ENDC
002017EA                          3407mm 
002017EA                          3408mm     ENDM
002017EA  7C07                    3409m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002017EC                          3410m LOOP_243
002017EC                          3411mm     BIN2HEX D1,D2,A1
002017EC  43F9 00201AFA           3412mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
002017F2  E999                    3413mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002017F4  1401                    3414mm     MOVE.B D1,D2
002017F6  0282 0000000F           3415mm     ANDI.L #$F,D2
002017FC  1431 2000               3416mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00201800                          3417mm     ENDM
00201800                          3418mm     PRINT_CHAR D2,D3
00201800                          3419mm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201800                 TRUE     3420mm     IFEQ DEBUG
00201800  1639 00C00003           3421mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201806  0803 0002               3422mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020180A  67F4                    3423mm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
0020180C  13C2 00C00007           3424mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201812                          3425mm     ENDC
00201812                          3426mm     
00201812                 FALSE    3427mm     IFNE DEBUG
00201812                          3428mm     ENDC
00201812                          3429mm 
00201812                          3430mm     ENDM
00201812  57CE FFD8               3431m     DBEQ D6,LOOP_243
00201816                          3432m     ENDM
00201816                          3433m         PRINT_CRLF D3
00201816                          3434mm     PRINT_CHAR #13,D3                           ; CR
00201816                          3435mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201816                 TRUE     3436mm     IFEQ DEBUG
00201816  1639 00C00003           3437mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020181C  0803 0002               3438mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201820  67F4                    3439mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00201822  13FC 000D 00C00007      3440mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020182A                          3441mm     ENDC
0020182A                          3442mm     
0020182A                 FALSE    3443mm     IFNE DEBUG
0020182A                          3444mm     ENDC
0020182A                          3445mm 
0020182A                          3446mm     ENDM
0020182A                          3447mm     PRINT_CHAR #10,D3                           ; LF
0020182A                          3448mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020182A                 TRUE     3449mm     IFEQ DEBUG
0020182A  1639 00C00003           3450mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201830  0803 0002               3451mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201834  67F4                    3452mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
00201836  13FC 000A 00C00007      3453mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020183E                          3454mm     ENDC
0020183E                          3455mm     
0020183E                 FALSE    3456mm     IFNE DEBUG
0020183E                          3457mm     ENDC
0020183E                          3458mm 
0020183E                          3459mm     ENDM
0020183E                          3460m     ENDM
0020183E                          3461  OK    
0020183E  5880                    3462          ADD.L #4,D0
00201840                          3463      ENDW
00201840  6000 FF2E               3464s     BRA _10000008
00201844                          3465s _10000009
00201844                          3466      
00201844  4EF9 00200188           3467      JMP MAIN_LOOP
0020184A                          3468    
0020184A                          3469  L
0020184A  7A00                    3470      MOVE.L #0,D5                                ; D5 will be the length  to write            
0020184C                          3471  
0020184C                          3472m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
0020184C                          3473m WAIT_FOR_READY_251                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020184C                          3474m 
0020184C                 TRUE     3475m     IFEQ DEBUG
0020184C  1639 00C00003           3476m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201852  0803 0000               3477m         BTST #0,D3                              ; CHECK FOR CHARACTER
00201856  67F4                    3478m         BEQ WAIT_FOR_READY_251                      ; NOTHING, CHECK AGAIN
00201858                          3479m     ENDC
00201858                          3480m     
00201858                          3481mm     READ_CHAR D2
00201858                 TRUE     3482mm     IFEQ DEBUG
00201858  1439 00C00007           3483mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020185E                          3484mm     ENDC
0020185E                 FALSE    3485mm     IFNE DEBUG
0020185E                          3486mm     ENDC
0020185E                          3487mm      
0020185E  B43C 001B               3488mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201862  6700 E7A4               3489mm     BEQ START
00201866                          3490mm     ENDM
00201866                          3491m 
00201866                 TRUE     3492m     IFEQ DEBUG
00201866                          3493mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00201866                          3494mm WAIT_FOR_READY_253                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201866                 TRUE     3495mm     IFEQ DEBUG
00201866  1639 00C00003           3496mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020186C  0803 0002               3497mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201870  67F4                    3498mm         BEQ WAIT_FOR_READY_253                      ; NO SPACE, CHECK AGAIN
00201872  13C2 00C00007           3499mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201878                          3500mm     ENDC
00201878                          3501mm     
00201878                 FALSE    3502mm     IFNE DEBUG
00201878                          3503mm     ENDC
00201878                          3504mm 
00201878                          3505mm     ENDM
00201878                          3506m     ENDC
00201878                          3507m     ENDM
00201878                          3508m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00201878  41F9 00201B0A           3509m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020187E  0402 0030               3510m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201882  C4BC 000000FF           3511m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201888  1430 2000               3512m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020188C                          3513m     ENDM
0020188C  1A02                    3514      MOVE.B D2,D5                                ; put at bottom of D5
0020188E                          3515  
0020188E  3C3C 0002               3516      MOVE #2,D6                                  ; 3 bytes left to read
00201892                          3517      
00201892                          3518  READ_LENGTH
00201892  E98D                    3519      LSL.L #4,D5                                 ; make what we have so far more significant
00201894                          3520m     WAIT_CHAR D2,D3                             ; next character -> D2
00201894                          3521m WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201894                          3522m 
00201894                 TRUE     3523m     IFEQ DEBUG
00201894  1639 00C00003           3524m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020189A  0803 0000               3525m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020189E  67F4                    3526m         BEQ WAIT_FOR_READY_255                      ; NOTHING, CHECK AGAIN
002018A0                          3527m     ENDC
002018A0                          3528m     
002018A0                          3529mm     READ_CHAR D2
002018A0                 TRUE     3530mm     IFEQ DEBUG
002018A0  1439 00C00007           3531mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002018A6                          3532mm     ENDC
002018A6                 FALSE    3533mm     IFNE DEBUG
002018A6                          3534mm     ENDC
002018A6                          3535mm      
002018A6  B43C 001B               3536mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002018AA  6700 E75C               3537mm     BEQ START
002018AE                          3538mm     ENDM
002018AE                          3539m 
002018AE                 TRUE     3540m     IFEQ DEBUG
002018AE                          3541mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002018AE                          3542mm WAIT_FOR_READY_257                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018AE                 TRUE     3543mm     IFEQ DEBUG
002018AE  1639 00C00003           3544mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018B4  0803 0002               3545mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018B8  67F4                    3546mm         BEQ WAIT_FOR_READY_257                      ; NO SPACE, CHECK AGAIN
002018BA  13C2 00C00007           3547mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002018C0                          3548mm     ENDC
002018C0                          3549mm     
002018C0                 FALSE    3550mm     IFNE DEBUG
002018C0                          3551mm     ENDC
002018C0                          3552mm 
002018C0                          3553mm     ENDM
002018C0                          3554m     ENDC
002018C0                          3555m     ENDM
002018C0                          3556m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002018C0  41F9 00201B0A           3557m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002018C6  0402 0030               3558m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002018CA  C4BC 000000FF           3559m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002018D0  1430 2000               3560m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002018D4                          3561m     ENDM
002018D4  8A02                    3562      OR.B D2,D5
002018D6  023C 00FB               3563      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
002018DA  57CE FFB6               3564      DBEQ D6,READ_LENGTH
002018DE                          3565          
002018DE                          3566m     PRINT_CRLF D3
002018DE                          3567mm     PRINT_CHAR #13,D3                           ; CR
002018DE                          3568mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018DE                 TRUE     3569mm     IFEQ DEBUG
002018DE  1639 00C00003           3570mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018E4  0803 0002               3571mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018E8  67F4                    3572mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
002018EA  13FC 000D 00C00007      3573mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002018F2                          3574mm     ENDC
002018F2                          3575mm     
002018F2                 FALSE    3576mm     IFNE DEBUG
002018F2                          3577mm     ENDC
002018F2                          3578mm 
002018F2                          3579mm     ENDM
002018F2                          3580mm     PRINT_CHAR #10,D3                           ; LF
002018F2                          3581mm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018F2                 TRUE     3582mm     IFEQ DEBUG
002018F2  1639 00C00003           3583mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018F8  0803 0002               3584mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018FC  67F4                    3585mm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
002018FE  13FC 000A 00C00007      3586mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201906                          3587mm     ENDC
00201906                          3588mm     
00201906                 FALSE    3589mm     IFNE DEBUG
00201906                          3590mm     ENDC
00201906                          3591mm 
00201906                          3592mm     ENDM
00201906                          3593m     ENDM
00201906                          3594  
00201906  207C 00000000           3595      MOVE.L #ROM,A0                              ; start of ROM
0020190C                          3596      
0020190C  2247                    3597      MOVE.L D7,A1                                ; address accumulator -> address register
0020190E  7E00                    3598      MOVE.L #0,D7                                ; clear the now used address accumulator
00201910                          3599      
00201910  267C 00002AAA           3600      MOVE.L #$2AAA,A3
00201916  36BC AAAA               3601      MOVE.W #$AAAA,(A3)
0020191A  267C 00001554           3602      MOVE.L #$1554,A3
00201920  36BC 5555               3603      MOVE.W #$5555,(A3)
00201924  267C 00002AAA           3604      MOVE.L #$2AAA,A3
0020192A  36BC 8080               3605      MOVE.W #$8080,(A3)
0020192E  267C 00002AAA           3606      MOVE.L #$2AAA,A3
00201934  36BC AAAA               3607      MOVE.W #$AAAA,(A3)
00201938  267C 00001554           3608      MOVE.L #$1554,A3
0020193E  36BC 5555               3609      MOVE.W #$5555,(A3)
00201942  267C 00002AAA           3610      MOVE.L #$2AAA,A3
00201948  36BC 2020               3611      MOVE.W #$2020,(A3)
0020194C                          3612      
0020194C  45F9 00201B21           3613      LEA LOADING,A2                              ; important for timing
00201952                          3614m     PRINT_STR A2,D3
00201952                          3615m LOOP_262
00201952  0C12 0000               3616m     CMP.B #0,(A2)                               ; 0 -> DONE
00201956  6700 001A               3617m     BEQ EXIT_262
0020195A                          3618mm     PRINT_CHAR (A2)+,D3
0020195A                          3619mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020195A                 TRUE     3620mm     IFEQ DEBUG
0020195A  1639 00C00003           3621mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201960  0803 0002               3622mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201964  67F4                    3623mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
00201966  13DA 00C00007           3624mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020196C                          3625mm     ENDC
0020196C                          3626mm     
0020196C                 FALSE    3627mm     IFNE DEBUG
0020196C                          3628mm     ENDC
0020196C                          3629mm 
0020196C                          3630mm     ENDM
0020196C  4EF9 00201952           3631m     JMP LOOP_262
00201972                          3632m EXIT_262
00201972                          3633m     ENDM
00201972                          3634  
00201972  023C 00FB               3635      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00201976                          3636      
00201976                          3637      WHILE D5 <GT> #0 DO
00201976                          3638s _1000000A
00201976  BA7C 0000               3639s     CMP.W   #0,D5
0020197A  6F00 0020               3640s     BLE _1000000B
0020197E  5585                    3641          SUB.L #2,D5
00201980                          3642            
00201980  13D1 00E00001           3643          MOVE.B (A1),DISPLAY
00201986  3091                    3644          MOVE.W (A1),(A0)                        ; write the data
00201988                          3645        
00201988                          3646  WAIT_FOR_COMPLETE
00201988  3410                    3647          MOVE.W (A0),D2
0020198A                          3648  
0020198A                          3649          IF D2 <NE> (A1) THEN
0020198A  B451                    3650s     CMP.W   (A1),D2
0020198C  6700 0008               3651s     BEQ _0000000C
00201990  4EF9 00201988           3652              JMP WAIT_FOR_COMPLETE
00201996                          3653          ENDI
00201996                          3654s _0000000C
00201996                          3655        
00201996  5488                    3656          ADD.L #2,A0
00201998  5489                    3657          ADD.L #2,A1
0020199A                          3658      ENDW  
0020199A  60DA                    3659s     BRA _1000000A
0020199C                          3660s _1000000B
0020199C                          3661      
0020199C  267C 00002AAA           3662      MOVE.L #$2AAA,A3
002019A2  36BC AAAA               3663      MOVE.W #$AAAA,(A3)
002019A6  267C 00001554           3664      MOVE.L #$1554,A3
002019AC  36BC 5555               3665      MOVE.W #$5555,(A3)
002019B0  267C 00002AAA           3666      MOVE.L #$2AAA,A3
002019B6  36BC A0A0               3667      MOVE.W #$A0A0,(A3)
002019BA                          3668              
002019BA  4EF9 00200188           3669      JMP MAIN_LOOP
002019C0                          3670          
002019C0                          3671  HEX_DIGIT
002019C0  E98F                    3672      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
002019C2                          3673m     HEX2BIN D2,D2,A0
002019C2  41F9 00201B0A           3674m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002019C8  0402 0030               3675m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002019CC  C4BC 000000FF           3676m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002019D2  1430 2000               3677m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002019D6                          3678m     ENDM
002019D6  8E02                    3679      OR.B D2,D7  
002019D8  4EF9 002001B0           3680      JMP GET_INPUT
002019DE                          3681  
002019DE  FFFF FFFF               3682      SIMHALT                                     ; halt simulator
002019E2                          3683  
002019E2                          3684  ; strings
002019E2= 4D 44 46 2D 6D 6F ...   3685  VERSION DC.B 'MDF-mon V1.31 (08/04/2021)',13,10,0
002019FF= 3F 20 48 65 6C 70 ...   3686  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201A96= 48 75 68 3F 0D 0A 00    3687  HUH     DC.B 'Huh?',13,10,0
00201A9D= 20 53 20 72 65 63 ...   3688  READ    DC.B ' S records read, start address = ',0
00201ABF= 57 3A 20 55 6E 6B ...   3689  UNREC   DC.B 'W: Unknown Srec type: ',0
00201AD6= 57 3A 20 43 53 20 ...   3690  CS_FAILURE   DC.B 'W: CS failure at ',0
00201AE8= 57 3A 20 52 41 4D ...   3691  RAM_ERROR DC.B 'W: RAM error at: ',0
00201AFA= 30 31 32 33 34 35 ...   3692  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201B0A= 00 01 02 03 04 05 ...   3693  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201B21= 4C 6F 61 64 69 6E ...   3694  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201B35                          3695      
00201B35                          3696      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201AFA
CONTINUE_100        200A6A
CONTINUE_104        200AC8
CONTINUE_108        200B28
CONTINUE_112        200B86
CONTINUE_116        200BF8
CONTINUE_120        200C56
CONTINUE_127        200CFE
CONTINUE_131        200D5C
CONTINUE_135        200DBC
CONTINUE_139        200E1A
CONTINUE_143        200E7E
CONTINUE_147        200EDC
CONTINUE_151        200F52
CONTINUE_155        200FB0
CONTINUE_159        20102A
CONTINUE_163        201088
CONTINUE_167        2010E8
CONTINUE_171        201146
CONTINUE_175        2011B8
CONTINUE_179        201216
CONTINUE_186        2012BE
CONTINUE_189        20130A
CONTINUE_192        201358
CONTINUE_195        2013A4
CONTINUE_198        2013F6
CONTINUE_201        201442
CONTINUE_210        20150E
CONTINUE_213        20155A
CONTINUE_44         2004BC
CONTINUE_46         2004F8
CONTINUE_48         200530
CONTINUE_51         20057C
CONTINUE_54         2005D2
CONTINUE_57         20061E
CONTINUE_60         20066C
CONTINUE_63         2006B8
CONTINUE_66         200718
CONTINUE_69         200764
CONTINUE_76         200802
CONTINUE_80         200860
CONTINUE_84         2008C0
CONTINUE_88         20091E
CONTINUE_92         200994
CONTINUE_96         2009F2
CS_FAILURE          201AD6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_DONE       201638
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EVEN                200A40
EVEN2               200FFE
EXIT_19             2002EA
EXIT_204            2014A8
EXIT_21             200316
EXIT_216            2015B4
EXIT_23             200342
EXIT_231            2016B2
EXIT_241            2017BE
EXIT_262            201972
EXIT_5              200142
G                   201736
GET_INPUT           2001B0
H                   2002F0
HELP                2019FF
HEX2BIN             134
HEX2BIN_LUT         201B0A
HEX_DIGIT           2019C0
HUH                 201A96
L                   20184A
LOADING             201B21
LOOP_19             2002CA
LOOP_204            201488
LOOP_21             2002F6
LOOP_216            201594
LOOP_218            2015DE
LOOP_226            201662
LOOP_23             200322
LOOP_231            201692
LOOP_233            2016DE
LOOP_241            20179E
LOOP_243            2017EC
LOOP_25             200376
LOOP_262            201952
LOOP_5              200122
MAIN_LOOP           200188
OK                  20183E
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           201AE8
READ                201A9D
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         201892
RESET               200004
ROM                 0
S                   200498
STACK               200000
START               200008
UNREC               201ABF
V                   20031C
VERSION             2019E2
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   201988
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  200A4E
WAIT_FOR_READY_102  200A82
WAIT_FOR_READY_104  200AAC
WAIT_FOR_READY_106  200AE0
WAIT_FOR_READY_108  200B0C
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200B40
WAIT_FOR_READY_112  200B6A
WAIT_FOR_READY_114  200B9E
WAIT_FOR_READY_116  200BDC
WAIT_FOR_READY_118  200C10
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_120  200C3A
WAIT_FOR_READY_122  200C6E
WAIT_FOR_READY_125  200CA6
WAIT_FOR_READY_126  200CBA
WAIT_FOR_READY_127  200CE2
WAIT_FOR_READY_129  200D16
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D40
WAIT_FOR_READY_133  200D74
WAIT_FOR_READY_135  200DA0
WAIT_FOR_READY_137  200DD4
WAIT_FOR_READY_139  200DFE
WAIT_FOR_READY_141  200E32
WAIT_FOR_READY_143  200E62
WAIT_FOR_READY_145  200E96
WAIT_FOR_READY_147  200EC0
WAIT_FOR_READY_149  200EF4
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200F36
WAIT_FOR_READY_153  200F6A
WAIT_FOR_READY_155  200F94
WAIT_FOR_READY_157  200FC8
WAIT_FOR_READY_159  20100E
WAIT_FOR_READY_161  201042
WAIT_FOR_READY_163  20106C
WAIT_FOR_READY_165  2010A0
WAIT_FOR_READY_167  2010CC
WAIT_FOR_READY_169  201100
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  20112A
WAIT_FOR_READY_173  20115E
WAIT_FOR_READY_175  20119C
WAIT_FOR_READY_177  2011D0
WAIT_FOR_READY_179  2011FA
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  20122E
WAIT_FOR_READY_184  201266
WAIT_FOR_READY_185  20127A
WAIT_FOR_READY_186  2012A2
WAIT_FOR_READY_189  2012EE
WAIT_FOR_READY_192  20133C
WAIT_FOR_READY_195  201388
WAIT_FOR_READY_198  2013DA
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  201426
WAIT_FOR_READY_205  201490
WAIT_FOR_READY_206  2014A8
WAIT_FOR_READY_208  2014BA
WAIT_FOR_READY_209  2014CE
WAIT_FOR_READY_210  2014F2
WAIT_FOR_READY_213  20153E
WAIT_FOR_READY_217  20159C
WAIT_FOR_READY_219  2015B4
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_220  2015C8
WAIT_FOR_READY_222  2015F2
WAIT_FOR_READY_224  201608
WAIT_FOR_READY_225  20161C
WAIT_FOR_READY_227  201638
WAIT_FOR_READY_228  20164C
WAIT_FOR_READY_230  201676
WAIT_FOR_READY_232  20169A
WAIT_FOR_READY_234  2016B4
WAIT_FOR_READY_235  2016C8
WAIT_FOR_READY_237  2016F2
WAIT_FOR_READY_239  201708
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_240  20171C
WAIT_FOR_READY_242  2017A6
WAIT_FOR_READY_244  2017C2
WAIT_FOR_READY_245  2017D6
WAIT_FOR_READY_247  201800
WAIT_FOR_READY_249  201816
WAIT_FOR_READY_250  20182A
WAIT_FOR_READY_251  20184C
WAIT_FOR_READY_253  201866
WAIT_FOR_READY_255  201894
WAIT_FOR_READY_257  2018AE
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_260  2018DE
WAIT_FOR_READY_261  2018F2
WAIT_FOR_READY_263  20195A
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DC
WAIT_FOR_READY_48   200514
WAIT_FOR_READY_51   200560
WAIT_FOR_READY_54   2005B6
WAIT_FOR_READY_57   200602
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200650
WAIT_FOR_READY_63   20069C
WAIT_FOR_READY_66   2006FC
WAIT_FOR_READY_69   200748
WAIT_FOR_READY_72   200794
WAIT_FOR_READY_74   2007AA
WAIT_FOR_READY_75   2007BE
WAIT_FOR_READY_76   2007E6
WAIT_FOR_READY_78   20081A
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   200844
WAIT_FOR_READY_82   200878
WAIT_FOR_READY_84   2008A4
WAIT_FOR_READY_86   2008D8
WAIT_FOR_READY_88   200902
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   200936
WAIT_FOR_READY_92   200978
WAIT_FOR_READY_94   2009AC
WAIT_FOR_READY_96   2009D6
WAIT_FOR_READY_98   200A0A
WAIT_FOR_SRECORD    2004A0
Z                   20173E
_00000000           2007DC
_00000001           2014E8
_00000002           200CD8
_00000003           200CA6
_00000004           2014E8
_00000005           201298
_00000006           201266
_00000007           2014E8
_00000008           201482
_00000009           2014E8
_0000000A           201636
_0000000B           201798
_0000000C           201996
_10000000           2006EE
_10000001           2007AA
_10000002           200A40
_10000003           200BD2
_10000004           201000
_10000005           201192
_10000006           201746
_10000007           201768
_10000008           201770
_10000009           201844
_1000000A           201976
_1000000B           20199C
