00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 09:50:15

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; include the checksum in download_byte
00000000                             9  ; revisit register usage in S record download
00000000                            10  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            11  ; revisit use of bytes and longs
00000000                            12  ; can I operate READ_CHAR with just one register?
00000000                            13  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            14  ; Review for any other savings
00000000                            15  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            16  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            17  
00000000                            18  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            19  ; keep track of highest address hit during srec download
00000000                            20  ; fix the reset vector so that it jumps to the start
00000000                            21  ; Replace JMP -> BRA
00000000                            22  ; implement backspace
00000000                            23  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            24  ; fix being able to enter random chars when W'ing
00000000                            25  ; ram check at startup?  Not sure if this is a good idea!
00000000                            26  ; byte W?
00000000                            27  
00000000                            28      ;ORG  $0
00200000                            29      ORG  $200000
00200000                            30  
00200000  =00000000                 31  DEBUG               EQU 0
00200000                            32  
00200000                            33  ; constants
00200000  =00000000                 34  ROM                 EQU $0
00200000  =00200000                 35  RAM                 EQU $200000
00200000                            36     
00200000  =00C00000                 37  DUART_BASE          EQU $C00000
00200000  =00000000                 38  DUART_MRA_          EQU $0
00200000  =00000001                 39  DUART_CSRA_         EQU $1
00200000  =00000001                 40  DUART_SRA_          EQU $1
00200000  =00000002                 41  DUART_CRA_          EQU $2
00200000  =00000003                 42  DUART_TXA_          EQU $3
00200000  =00000003                 43  DUART_RXA_          EQU $3
00200000  =00000004                 44  DUART_ACR_          EQU $4
00200000  =00000005                 45  DUART_IMR_          EQU $5
00200000  =00000008                 46  DUART_MRB_          EQU $8
00200000  =00000009                 47  DUART_CSRB_         EQU $9
00200000  =00000009                 48  DUART_SRB_          EQU $9
00200000  =0000000A                 49  DUART_CRB_          EQU $A
00200000  =0000000B                 50  DUART_TXB_          EQU $B
00200000  =0000000B                 51  DUART_RXB_          EQU $B
00200000  =0000000C                 52  DUART_IVR_          EQU $C
00200000  =0000000D                 53  DUART_OPCR_         EQU $D
00200000  =0000000E                 54  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 55  DUART_RESET_OPR_    EQU $F
00200000                            56  
00200000  =00C00001                 57  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 58  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 59  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 60  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 61  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 62  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            63  
00200000  =00C00011                 64  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 65  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 66  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 67  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 68  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 69  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            70  
00200000  =00C00009                 71  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 72  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 73  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 74  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 75  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 76  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            77  
00200000  =00E00000                 78  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 79  DISPLAY_            EQU $0
00200000  =00E00001                 80  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            81  
00200000                            82  ; macros
00200000                            83  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            84  ; the input register is changed during the process
00200000                            85  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            86  BIN2HEX MACRO
00200000                            87      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            88      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            89      MOVE.B \1,\2
00200000                            90      ANDI.L #$F,\2
00200000                            91      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            92      ENDM
00200000                            93  
00200000                            94  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            95  ; the input register is changed during the process
00200000                            96  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            97  HEX2BIN MACRO
00200000                            98      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            99      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                           100      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                           101      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           102      ENDM
00200000                           103  
00200000                           104  ; send a single char to the serial port
00200000                           105  ; \1 = char to send, \2 = data register to use for status poll
00200000                           106  ; will stamp on D0 and D1 in debug mode
00200000                           107  PRINT_CHAR MACRO
00200000                           108  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           109      IFEQ DEBUG
00200000                           110          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           111          BTST #2,\2                              ; check for space to send
00200000                           112          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           113          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           114      ENDC
00200000                           115      
00200000                           116      IFNE DEBUG
00200000                           117          MOVE.B \1,D1
00200000                           118          MOVE.L #6,D0   
00200000                           119          TRAP #15                                ; write to terminal in simulator
00200000                           120      ENDC
00200000                           121  
00200000                           122      ENDM
00200000                           123  
00200000                           124  ; send CR,LF to the serial port
00200000                           125  ; \1 = data register to use for status poll
00200000                           126  PRINT_CRLF MACRO
00200000                           127      PRINT_CHAR #13,\1                           ; CR
00200000                           128      PRINT_CHAR #10,\1                           ; LF
00200000                           129      ENDM
00200000                           130  
00200000                           131  ; send C-style, zero terminated string to the serial port
00200000                           132  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           133  PRINT_STR MACRO
00200000                           134  LOOP\@
00200000                           135      CMP.B #0,(\1)                               ; 0 -> done
00200000                           136      BEQ EXIT\@
00200000                           137      PRINT_CHAR (\1)+,\2
00200000                           138      JMP LOOP\@
00200000                           139  EXIT\@
00200000                           140      ENDM
00200000                           141    
00200000                           142  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           143  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           144  PRINT_REG MACRO
00200000                           145      PRINT_CHAR #'0',\2                          ;0x header
00200000                           146      PRINT_CHAR #'x',\2
00200000                           147      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           148  LOOP\@
00200000                           149      BIN2HEX \1,\3,\5
00200000                           150      PRINT_CHAR \3,\2
00200000                           151      DBEQ \4,LOOP\@
00200000                           152      ENDM
00200000                           153    
00200000                           154  ; wait for a char from the serial port
00200000                           155  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           156  ; will stamp on D0 and D1 in debug mode
00200000                           157  WAIT_CHAR MACRO
00200000                           158  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           159  
00200000                           160      IFEQ DEBUG
00200000                           161          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           162          BTST #0,\2                              ; check for character
00200000                           163          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           164      ENDC
00200000                           165      
00200000                           166      READ_CHAR \1
00200000                           167  
00200000                           168      IFEQ DEBUG
00200000                           169          PRINT_CHAR \1,\2                        ; echo it back
00200000                           170      ENDC
00200000                           171      ENDM
00200000                           172      
00200000                           173  ; read a char from the serial port - assumes that there is one!
00200000                           174  ; \ 1= data register for read char
00200000                           175  ; will stamp on D0 and D1 in debug mode
00200000                           176  READ_CHAR MACRO
00200000                           177      IFEQ DEBUG
00200000                           178          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           179      ENDC
00200000                           180      IFNE DEBUG
00200000                           181          MOVE.L #5,D0    
00200000                           182          TRAP #15                                ; read from keyboard in simulator
00200000                           183          MOVE.L D1,\1
00200000                           184      ENDC
00200000                           185       
00200000                           186      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           187      BEQ START
00200000                           188      ENDM
00200000                           189      
00200000                           190      
00200000                           191  ; read data from the download serial port
00200000                           192  ; \ 1= data register for read char
00200000                           193  DOWNLOAD MACRO
00200000                           194  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           195  
00200000                           196      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           197      BTST #0,\1                                  ; check for character
00200000                           198      BEQ CONTINUE\@                              ; nothing, continue
00200000                           199   
00200000                           200      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           201  CONTINUE\@
00200000                           202      MOVE.B DUART_SRB,\1                         ; read download status register
00200000                           203      BTST #0,\1                                  ; check for character
00200000                           204      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           205      
00200000                           206      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           207      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           208      
00200000                           209      ENDM
00200000                           210      
00200000                           211  ; read two hex digits from the download serial port and convert to a byte
00200000                           212  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           213  DOWNLOAD_BYTE MACRO
00200000                           214      MOVE.B #2,\4
00200000                           215      WHILE.B \4 <GT> 0 DO
00200000                           216          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200000                           217          DOWNLOAD \1
00200000                           218          PRINT_CHAR \1,\3
00200000                           219          HEX2BIN \1,\1,\6
00200000                           220          OR.B \1,\2
00200000                           221          SUB.B #1,\4
00200000                           222      ENDW
00200000                           223      
00200000                           224      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00200000                           225      MOVE.B \2,\1
00200000                           226      ADD.L \2,\5
00200000                           227  
00200000                           228      ENDM
00200000                           229      
00200000                           230  
00200000                           231  ; register catalogue
00200000                           232  ; D0 - used for simulator I/O
00200000                           233  ; D1 - used for simulator I/O
00200000                           234  ; D2 - read character
00200000                           235  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           236  ; D4 - count of S records read
00200000                           237  ; D5 - data to write / data read / byte count for S record load
00200000                           238  ; D6 - working register used in R/W and download
00200000                           239  ; D7 - address accumulator / reset by download
00200000                           240  ; A0 - address of string to print 
00200000                           241  
00200000                           242  ; start vector
00200000= 00000000                 243  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 244  RESET    DC.L START                             ; RESET
00200008                           245      
00200008                           246  ; start of program  
00200008                           247  START
00200008  13FC 0000 00E00001       248      MOVE.B #0,DISPLAY
00200010                           249  
00200010                           250  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       251      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       252      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     253      NOP
00200022  13FC 0040 00C00005       254      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     255      NOP
0020002C  13FC 0030 00C00005       256      MOVE.B #$30,DUART_CRA
00200034  4E71                     257      NOP
00200036  13FC 0020 00C00005       258      MOVE.B #$20,DUART_CRA
0020003E  4E71                     259      NOP
00200040  13FC 0010 00C00005       260      MOVE.B #$10,DUART_CRA   
00200048                           261  
00200048  13FC 000A 00C00015       262      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       263      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     264      NOP
0020005A  13FC 0040 00C00015       265      MOVE.B #$40,DUART_CRB           
00200062  4E71                     266      NOP
00200064  13FC 0030 00C00015       267      MOVE.B #$30,DUART_CRB
0020006C  4E71                     268      NOP
0020006E  13FC 0020 00C00015       269      MOVE.B #$20,DUART_CRB
00200076  4E71                     270      NOP
00200078  13FC 0010 00C00015       271      MOVE.B #$10,DUART_CRB   
00200080                           272  
00200080                           273  ;initialise UART
00200080  13FC 0000 00C00009       274      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       275      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       276      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           277  
00200098                           278  ; channel A
00200098  13FC 0013 00C00001       279      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       280      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       281      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       282      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           283  
002000B8                           284  ; channel B
002000B8  13FC 0013 00C00011       285      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       286      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       287      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       288      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           289  
002000D8                           290m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           291m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      292m     IFEQ DEBUG
002000D8  1639 00C00003            293m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                294m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     295m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       296m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           297m     ENDC
002000EC                           298m     
002000EC                 FALSE     299m     IFNE DEBUG
002000EC                           300m     ENDC
002000EC                           301m 
002000EC                           302m     ENDM
002000EC                           303  
002000EC  13FC 0001 00E00001       304      MOVE.B #1,DISPLAY
002000F4                           305         
002000F4                           306m     PRINT_CRLF D3
002000F4                           307mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           308mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      309mm     IFEQ DEBUG
002000F4  1639 00C00003            310mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                311mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     312mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       313mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           314mm     ENDC
00200108                           315mm     
00200108                 FALSE     316mm     IFNE DEBUG
00200108                           317mm     ENDC
00200108                           318mm 
00200108                           319mm     ENDM
00200108                           320mm     PRINT_CHAR #10,D3                           ; LF
00200108                           321mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      322mm     IFEQ DEBUG
00200108  1639 00C00003            323mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                324mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     325mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       326mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           327mm     ENDC
0020011C                           328mm     
0020011C                 FALSE     329mm     IFNE DEBUG
0020011C                           330mm     ENDC
0020011C                           331mm 
0020011C                           332mm     ENDM
0020011C                           333m     ENDM
0020011C                           334  
0020011C  41F9 00200F4A            335      LEA VERSION,A0
00200122                           336m     PRINT_STR A0,D3
00200122                           337m LOOP_5
00200122  0C10 0000                338m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                339m     BEQ EXIT_5
0020012A                           340mm     PRINT_CHAR (A0)+,D3
0020012A                           341mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      342mm     IFEQ DEBUG
0020012A  1639 00C00003            343mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                344mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     345mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            346mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           347mm     ENDC
0020013C                           348mm     
0020013C                 FALSE     349mm     IFNE DEBUG
0020013C                           350mm     ENDC
0020013C                           351mm 
0020013C                           352mm     ENDM
0020013C  4EF9 00200122            353m     JMP LOOP_5
00200142                           354m EXIT_5
00200142                           355m     ENDM
00200142                           356m     PRINT_CRLF D3
00200142                           357mm     PRINT_CHAR #13,D3                           ; CR
00200142                           358mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      359mm     IFEQ DEBUG
00200142  1639 00C00003            360mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                361mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     362mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       363mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           364mm     ENDC
00200156                           365mm     
00200156                 FALSE     366mm     IFNE DEBUG
00200156                           367mm     ENDC
00200156                           368mm 
00200156                           369mm     ENDM
00200156                           370mm     PRINT_CHAR #10,D3                           ; LF
00200156                           371mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      372mm     IFEQ DEBUG
00200156  1639 00C00003            373mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                374mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     375mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       376mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           377mm     ENDC
0020016A                           378mm     
0020016A                 FALSE     379mm     IFNE DEBUG
0020016A                           380mm     ENDC
0020016A                           381mm 
0020016A                           382mm     ENDM
0020016A                           383m     ENDM
0020016A                           384m     PRINT_CHAR #7,D3
0020016A                           385m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      386m     IFEQ DEBUG
0020016A  1639 00C00003            387m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                388m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     389m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       390m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           391m     ENDC
0020017E                           392m     
0020017E                 FALSE     393m     IFNE DEBUG
0020017E                           394m     ENDC
0020017E                           395m 
0020017E                           396m     ENDM
0020017E                           397  
0020017E  7E00                     398      MOVE.L #0,D7                                ; address accumulator
00200180                           399  
00200180  13FC 0002 00E00001       400      MOVE.B #2,DISPLAY
00200188                           401  MAIN_LOOP
00200188                           402m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           403m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      404m     IFEQ DEBUG
00200188  1639 00C00003            405m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                406m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     407m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       408m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           409m     ENDC
0020019C                           410m     
0020019C                 FALSE     411m     IFNE DEBUG
0020019C                           412m     ENDC
0020019C                           413m 
0020019C                           414m     ENDM
0020019C                           415m     PRINT_CHAR #32,D3                           ; space
0020019C                           416m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      417m     IFEQ DEBUG
0020019C  1639 00C00003            418m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                419m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     420m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       421m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           422m     ENDC
002001B0                           423m     
002001B0                 FALSE     424m     IFNE DEBUG
002001B0                           425m     ENDC
002001B0                           426m 
002001B0                           427m     ENDM
002001B0                           428      
002001B0                           429  GET_INPUT
002001B0                           430m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           431m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           432m 
002001B0                 TRUE      433m     IFEQ DEBUG
002001B0  1639 00C00003            434m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                435m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     436m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           437m     ENDC
002001BC                           438m     
002001BC                           439mm     READ_CHAR D2
002001BC                 TRUE      440mm     IFEQ DEBUG
002001BC  1439 00C00007            441mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           442mm     ENDC
002001C2                 FALSE     443mm     IFNE DEBUG
002001C2                           444mm     ENDC
002001C2                           445mm      
002001C2  B43C 001B                446mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                447mm     BEQ START
002001CA                           448mm     ENDM
002001CA                           449m 
002001CA                 TRUE      450m     IFEQ DEBUG
002001CA                           451mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           452mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      453mm     IFEQ DEBUG
002001CA  1639 00C00003            454mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                455mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     456mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            457mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           458mm     ENDC
002001DC                           459mm     
002001DC                 FALSE     460mm     IFNE DEBUG
002001DC                           461mm     ENDC
002001DC                           462mm 
002001DC                           463mm     ENDM
002001DC                           464m     ENDC
002001DC                           465m     ENDM
002001DC                           466      
002001DC  B43C 0030                467      CMP.B #'0',D2
002001E0  6700 0D46                468      BEQ HEX_DIGIT
002001E4  B43C 0031                469      CMP.B #'1',D2
002001E8  6700 0D3E                470      BEQ HEX_DIGIT
002001EC  B43C 0032                471      CMP.B #'2',D2
002001F0  6700 0D36                472      BEQ HEX_DIGIT
002001F4  B43C 0033                473      CMP.B #'3',D2
002001F8  6700 0D2E                474      BEQ HEX_DIGIT
002001FC  B43C 0034                475      CMP.B #'4',D2
00200200  6700 0D26                476      BEQ HEX_DIGIT
00200204  B43C 0035                477      CMP.B #'5',D2
00200208  6700 0D1E                478      BEQ HEX_DIGIT
0020020C  B43C 0036                479      CMP.B #'6',D2
00200210  6700 0D16                480      BEQ HEX_DIGIT
00200214  B43C 0037                481      CMP.B #'7',D2
00200218  6700 0D0E                482      BEQ HEX_DIGIT
0020021C  B43C 0038                483      CMP.B #'8',D2
00200220  6700 0D06                484      BEQ HEX_DIGIT
00200224  B43C 0039                485      CMP.B #'9',D2
00200228  6700 0CFE                486      BEQ HEX_DIGIT
0020022C  B43C 0041                487      CMP.B #'A',D2
00200230  6700 0CF6                488      BEQ HEX_DIGIT
00200234  B43C 0042                489      CMP.B #'B',D2
00200238  6700 0CEE                490      BEQ HEX_DIGIT
0020023C  B43C 0043                491      CMP.B #'C',D2
00200240  6700 0CE6                492      BEQ HEX_DIGIT
00200244  B43C 0044                493      CMP.B #'D',D2
00200248  6700 0CDE                494      BEQ HEX_DIGIT
0020024C  B43C 0045                495      CMP.B #'E',D2
00200250  6700 0CD6                496      BEQ HEX_DIGIT
00200254  B43C 0046                497      CMP.B #'F',D2
00200258  6700 0CCE                498      BEQ HEX_DIGIT
0020025C                           499      
0020025C  B43C 0057                500      CMP.B #'W',D2
00200260  6700 016E                501      BEQ W
00200264                           502      
00200264  B43C 004C                503      CMP.B #'L',D2
00200268  6700 0B48                504      BEQ L 
0020026C                           505  
0020026C                           506m     PRINT_CRLF D3
0020026C                           507mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           508mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      509mm     IFEQ DEBUG
0020026C  1639 00C00003            510mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                511mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     512mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       513mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           514mm     ENDC
00200280                           515mm     
00200280                 FALSE     516mm     IFNE DEBUG
00200280                           517mm     ENDC
00200280                           518mm 
00200280                           519mm     ENDM
00200280                           520mm     PRINT_CHAR #10,D3                           ; LF
00200280                           521mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      522mm     IFEQ DEBUG
00200280  1639 00C00003            523mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                524mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     525mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       526mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           527mm     ENDC
00200294                           528mm     
00200294                 FALSE     529mm     IFNE DEBUG
00200294                           530mm     ENDC
00200294                           531mm 
00200294                           532mm     ENDM
00200294                           533m     ENDM
00200294                           534   
00200294  B43C 003F                535      CMP.B #'?',D2
00200298  6700 0056                536      BEQ H
0020029C                           537  
0020029C  B43C 0056                538      CMP.B #'V',D2
002002A0  6700 007A                539      BEQ V
002002A4                           540      
002002A4  B43C 0052                541      CMP.B #'R',D2
002002A8  6700 009E                542      BEQ R
002002AC                           543  
002002AC  B43C 0053                544      CMP.B #'S',D2
002002B0  6700 01E6                545      BEQ S
002002B4                           546  
002002B4  B43C 0047                547      CMP.B #'G',D2
002002B8  6700 09E4                548      BEQ G   
002002BC                           549  
002002BC  B43C 005A                550      CMP.B #'Z',D2
002002C0  6700 09E4                551      BEQ Z   
002002C4                           552  
002002C4  41F9 00200FFE            553      LEA HUH,A0
002002CA                           554m     PRINT_STR A0,D3
002002CA                           555m LOOP_19
002002CA  0C10 0000                556m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                557m     BEQ EXIT_19
002002D2                           558mm     PRINT_CHAR (A0)+,D3
002002D2                           559mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      560mm     IFEQ DEBUG
002002D2  1639 00C00003            561mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                562mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     563mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            564mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           565mm     ENDC
002002E4                           566mm     
002002E4                 FALSE     567mm     IFNE DEBUG
002002E4                           568mm     ENDC
002002E4                           569mm 
002002E4                           570mm     ENDM
002002E4  4EF9 002002CA            571m     JMP LOOP_19
002002EA                           572m EXIT_19
002002EA                           573m     ENDM
002002EA                           574                         
002002EA  4EF9 00200188            575      JMP MAIN_LOOP
002002F0                           576      
002002F0                           577  ; commands
002002F0                           578  H   
002002F0  41F9 00200F67            579      LEA HELP,A0
002002F6                           580m     PRINT_STR A0,D3
002002F6                           581m LOOP_21
002002F6  0C10 0000                582m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                583m     BEQ EXIT_21
002002FE                           584mm     PRINT_CHAR (A0)+,D3
002002FE                           585mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      586mm     IFEQ DEBUG
002002FE  1639 00C00003            587mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                588mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     589mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            590mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           591mm     ENDC
00200310                           592mm     
00200310                 FALSE     593mm     IFNE DEBUG
00200310                           594mm     ENDC
00200310                           595mm 
00200310                           596mm     ENDM
00200310  4EF9 002002F6            597m     JMP LOOP_21
00200316                           598m EXIT_21
00200316                           599m     ENDM
00200316  4EF9 00200188            600      JMP MAIN_LOOP
0020031C                           601  
0020031C                           602  V   
0020031C  41F9 00200F4A            603      LEA VERSION,A0
00200322                           604m     PRINT_STR A0,D3       
00200322                           605m LOOP_23
00200322  0C10 0000                606m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                607m     BEQ EXIT_23
0020032A                           608mm     PRINT_CHAR (A0)+,D3
0020032A                           609mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      610mm     IFEQ DEBUG
0020032A  1639 00C00003            611mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                612mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     613mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            614mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           615mm     ENDC
0020033C                           616mm     
0020033C                 FALSE     617mm     IFNE DEBUG
0020033C                           618mm     ENDC
0020033C                           619mm 
0020033C                           620mm     ENDM
0020033C  4EF9 00200322            621m     JMP LOOP_23
00200342                           622m EXIT_23
00200342                           623m     ENDM
00200342  4EF9 00200188            624      JMP MAIN_LOOP
00200348                           625      
00200348                           626  R   
00200348  2047                     627      MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     628      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           629m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           630mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           631mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      632mm     IFEQ DEBUG
0020034C  1639 00C00003            633mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                634mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     635mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       636mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           637mm     ENDC
00200360                           638mm     
00200360                 FALSE     639mm     IFNE DEBUG
00200360                           640mm     ENDC
00200360                           641mm 
00200360                           642mm     ENDM
00200360                           643mm     PRINT_CHAR #'x',D3
00200360                           644mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      645mm     IFEQ DEBUG
00200360  1639 00C00003            646mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                647mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     648mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       649mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           650mm     ENDC
00200374                           651mm     
00200374                 FALSE     652mm     IFNE DEBUG
00200374                           653mm     ENDC
00200374                           654mm 
00200374                           655mm     ENDM
00200374  7C07                     656m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           657m LOOP_25
00200376                           658mm     BIN2HEX D5,D7,A0
00200376  41F9 00201062            659mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     660mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     661mm     MOVE.B D5,D7
00200380  0287 0000000F            662mm     ANDI.L #$F,D7
00200386  1E30 7000                663mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           664mm     ENDM
0020038A                           665mm     PRINT_CHAR D7,D3
0020038A                           666mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      667mm     IFEQ DEBUG
0020038A  1639 00C00003            668mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                669mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     670mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            671mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           672mm     ENDC
0020039C                           673mm     
0020039C                 FALSE     674mm     IFNE DEBUG
0020039C                           675mm     ENDC
0020039C                           676mm 
0020039C                           677mm     ENDM
0020039C  57CE FFD8                678m     DBEQ D6,LOOP_25
002003A0                           679m     ENDM
002003A0                           680m     PRINT_CRLF D3
002003A0                           681mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           682mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      683mm     IFEQ DEBUG
002003A0  1639 00C00003            684mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                685mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     686mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       687mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           688mm     ENDC
002003B4                           689mm     
002003B4                 FALSE     690mm     IFNE DEBUG
002003B4                           691mm     ENDC
002003B4                           692mm 
002003B4                           693mm     ENDM
002003B4                           694mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           695mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      696mm     IFEQ DEBUG
002003B4  1639 00C00003            697mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                698mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     699mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       700mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           701mm     ENDC
002003C8                           702mm     
002003C8                 FALSE     703mm     IFNE DEBUG
002003C8                           704mm     ENDC
002003C8                           705mm 
002003C8                           706mm     ENDM
002003C8                           707m     ENDM
002003C8  7E00                     708      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            709      JMP MAIN_LOOP
002003D0                           710  
002003D0                           711  W
002003D0  7A00                     712      MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           713  
002003D2                           714m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           715m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           716m 
002003D2                 TRUE      717m     IFEQ DEBUG
002003D2  1639 00C00003            718m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                719m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     720m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           721m     ENDC
002003DE                           722m     
002003DE                           723mm     READ_CHAR D2
002003DE                 TRUE      724mm     IFEQ DEBUG
002003DE  1439 00C00007            725mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           726mm     ENDC
002003E4                 FALSE     727mm     IFNE DEBUG
002003E4                           728mm     ENDC
002003E4                           729mm      
002003E4  B43C 001B                730mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                731mm     BEQ START
002003EC                           732mm     ENDM
002003EC                           733m 
002003EC                 TRUE      734m     IFEQ DEBUG
002003EC                           735mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           736mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      737mm     IFEQ DEBUG
002003EC  1639 00C00003            738mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                739mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     740mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            741mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           742mm     ENDC
002003FE                           743mm     
002003FE                 FALSE     744mm     IFNE DEBUG
002003FE                           745mm     ENDC
002003FE                           746mm 
002003FE                           747mm     ENDM
002003FE                           748m     ENDC
002003FE                           749m     ENDM
002003FE                           750m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 00201072            751m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                752m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            753m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                754m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           755m     ENDM
00200412  1A02                     756      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           757  
00200414  3C3C 0006                758      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           759      
00200418                           760  READ_DATA_TO_POKE
00200418  E98D                     761      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           762m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           763m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           764m 
0020041A                 TRUE      765m     IFEQ DEBUG
0020041A  1639 00C00003            766m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                767m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     768m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           769m     ENDC
00200426                           770m     
00200426                           771mm     READ_CHAR D2
00200426                 TRUE      772mm     IFEQ DEBUG
00200426  1439 00C00007            773mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           774mm     ENDC
0020042C                 FALSE     775mm     IFNE DEBUG
0020042C                           776mm     ENDC
0020042C                           777mm      
0020042C  B43C 001B                778mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                779mm     BEQ START
00200434                           780mm     ENDM
00200434                           781m 
00200434                 TRUE      782m     IFEQ DEBUG
00200434                           783mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           784mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      785mm     IFEQ DEBUG
00200434  1639 00C00003            786mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                787mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     788mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            789mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           790mm     ENDC
00200446                           791mm     
00200446                 FALSE     792mm     IFNE DEBUG
00200446                           793mm     ENDC
00200446                           794mm 
00200446                           795mm     ENDM
00200446                           796m     ENDC
00200446                           797m     ENDM
00200446                           798m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 00201072            799m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                800m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            801m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                802m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           803m     ENDM
0020045A  8A02                     804      OR.B D2,D5
0020045C  023C 00FB                805      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                806      DBEQ D6,READ_DATA_TO_POKE
00200464                           807      
00200464  2047                     808      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     809      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           810      
00200468  2085                     811      MOVE.L D5,(A0)                              ; write the data
0020046A                           812  
0020046A                           813m     PRINT_CRLF D3
0020046A                           814mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           815mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      816mm     IFEQ DEBUG
0020046A  1639 00C00003            817mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                818mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     819mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       820mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           821mm     ENDC
0020047E                           822mm     
0020047E                 FALSE     823mm     IFNE DEBUG
0020047E                           824mm     ENDC
0020047E                           825mm 
0020047E                           826mm     ENDM
0020047E                           827mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           828mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      829mm     IFEQ DEBUG
0020047E  1639 00C00003            830mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                831mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     832mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       833mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           834mm     ENDC
00200492                           835mm     
00200492                 FALSE     836mm     IFNE DEBUG
00200492                           837mm     ENDC
00200492                           838mm 
00200492                           839mm     ENDM
00200492                           840m     ENDM
00200492  4EF9 00200188            841      JMP MAIN_LOOP
00200498                           842  
00200498                           843          
00200498                           844  S
00200498  2647                     845      MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     846      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                847      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           848      
002004A0                           849  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           850m     DOWNLOAD D2                 
002004A0                           851m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           852m 
002004A0  1439 00C00003            853m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002004A6  0802 0000                854m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                855m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           856m  
002004AE                           857mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002004AE                 TRUE      858mm     IFEQ DEBUG
002004AE  1439 00C00007            859mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           860mm     ENDC
002004B4                 FALSE     861mm     IFNE DEBUG
002004B4                           862mm     ENDC
002004B4                           863mm      
002004B4  B43C 001B                864mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                865mm     BEQ START
002004BC                           866mm     ENDM
002004BC                           867m CONTINUE_44
002004BC  1439 00C00013            868m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002004C2  0802 0000                869m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004C6  67D8                     870m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           871m     
002004C8  1439 00C00017            872m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            873m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           874m     
002004D4                           875m     ENDM
002004D4  B43C 0053                876      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     877      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           878      
002004DA                           879m     PRINT_CHAR #'S',D3                          ; print it
002004DA                           880m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      881m     IFEQ DEBUG
002004DA  1639 00C00003            882m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002004E0  0803 0002                883m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     884m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004E6  13FC 0053 00C00007       885m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004EE                           886m     ENDC
002004EE                           887m     
002004EE                 FALSE     888m     IFNE DEBUG
002004EE                           889m     ENDC
002004EE                           890m 
002004EE                           891m     ENDM
002004EE  5284                     892      ADD.L #1,D4                                 ; read another S record, increment count
002004F0                           893      
002004F0                           894m     DOWNLOAD D0                                 ; read the record identifier
002004F0                           895m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004F0                           896m 
002004F0  1039 00C00003            897m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
002004F6  0800 0000                898m     BTST #0,D0                                  ; CHECK FOR CHARACTER
002004FA  6700 0010                899m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004FE                           900m  
002004FE                           901mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
002004FE                 TRUE      902mm     IFEQ DEBUG
002004FE  1039 00C00007            903mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
00200504                           904mm     ENDC
00200504                 FALSE     905mm     IFNE DEBUG
00200504                           906mm     ENDC
00200504                           907mm      
00200504  B03C 001B                908mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
00200508  6700 FAFE                909mm     BEQ START
0020050C                           910mm     ENDM
0020050C                           911m CONTINUE_47
0020050C  1039 00C00013            912m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
00200512  0800 0000                913m     BTST #0,D0                                  ; CHECK FOR CHARACTER
00200516  67D8                     914m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00200518                           915m     
00200518  1039 00C00017            916m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
0020051E  13C0 00E00001            917m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
00200524                           918m     
00200524                           919m     ENDM
00200524                           920m     PRINT_CHAR D0,D3                            ; print it
00200524                           921m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200524                 TRUE      922m     IFEQ DEBUG
00200524  1639 00C00003            923m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020052A  0803 0002                924m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020052E  67F4                     925m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200530  13C0 00C00007            926m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200536                           927m     ENDC
00200536                           928m     
00200536                 FALSE     929m     IFNE DEBUG
00200536                           930m     ENDC
00200536                           931m 
00200536                           932m     ENDM
00200536                           933  
00200536  7C00                     934      MOVE.L #0,D6                                ; clear the checksum
00200538                           935  
00200538  7A00                     936      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
0020053A                           937m     DOWNLOAD_BYTE D2,D5,D3,D1,D6,A0                                        
0020053A  123C 0002                938m     MOVE.B #2,D1
0020053E                           939m     WHILE.B D1 <GT> 0 DO
0020053E                           940ms _10000000
0020053E  B238 0000                941ms     CMP.B   0,D1
00200542  6F00 0064                942ms     BLE _10000001
00200546  E98D                     943m         LSL.L #4,D5                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200548                           944mm         DOWNLOAD D2
00200548                           945mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200548                           946mm 
00200548  1439 00C00003            947mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020054E  0802 0000                948mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200552  6700 0010                949mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
00200556                           950mm  
00200556                           951mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200556                 TRUE      952mmm     IFEQ DEBUG
00200556  1439 00C00007            953mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020055C                           954mmm     ENDC
0020055C                 FALSE     955mmm     IFNE DEBUG
0020055C                           956mmm     ENDC
0020055C                           957mmm      
0020055C  B43C 001B                958mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200560  6700 FAA6                959mmm     BEQ START
00200564                           960mmm     ENDM
00200564                           961mm CONTINUE_51
00200564  1439 00C00013            962mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020056A  0802 0000                963mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020056E  67D8                     964mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200570                           965mm     
00200570  1439 00C00017            966mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200576  13C2 00E00001            967mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020057C                           968mm     
0020057C                           969mm     ENDM
0020057C                           970mm         PRINT_CHAR D2,D3
0020057C                           971mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020057C                 TRUE      972mm     IFEQ DEBUG
0020057C  1639 00C00003            973mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200582  0803 0002                974mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200586  67F4                     975mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00200588  13C2 00C00007            976mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020058E                           977mm     ENDC
0020058E                           978mm     
0020058E                 FALSE     979mm     IFNE DEBUG
0020058E                           980mm     ENDC
0020058E                           981mm 
0020058E                           982mm     ENDM
0020058E                           983mm         HEX2BIN D2,D2,A0
0020058E  41F9 00201072            984mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200594  0402 0030                985mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200598  C4BC 000000FF            986mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020059E  1430 2000                987mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005A2                           988mm     ENDM
002005A2  8A02                     989m         OR.B D2,D5
002005A4  5301                     990m         SUB.B #1,D1
002005A6                           991m     ENDW
002005A6  6096                     992ms     BRA _10000000
002005A8                           993ms _10000001
002005A8                           994m     
002005A8  7400                     995m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002005AA  1405                     996m     MOVE.B D5,D2
002005AC  DC85                     997m     ADD.L D5,D6
002005AE                           998m 
002005AE                           999m     ENDM
002005AE                          1000  
002005AE                          1001      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
002005AE  B03C 0030               1002s     CMP.B   #'0',D0
002005B2  6600 0032               1003s     BNE.L   _00000000
002005B6                          1004m         PRINT_CRLF D3
002005B6                          1005mm     PRINT_CHAR #13,D3                           ; CR
002005B6                          1006mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B6                 TRUE     1007mm     IFEQ DEBUG
002005B6  1639 00C00003           1008mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005BC  0803 0002               1009mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005C0  67F4                    1010mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
002005C2  13FC 000D 00C00007      1011mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005CA                          1012mm     ENDC
002005CA                          1013mm     
002005CA                 FALSE    1014mm     IFNE DEBUG
002005CA                          1015mm     ENDC
002005CA                          1016mm 
002005CA                          1017mm     ENDM
002005CA                          1018mm     PRINT_CHAR #10,D3                           ; LF
002005CA                          1019mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005CA                 TRUE     1020mm     IFEQ DEBUG
002005CA  1639 00C00003           1021mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005D0  0803 0002               1022mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005D4  67F4                    1023mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005D6  13FC 000A 00C00007      1024mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005DE                          1025mm     ENDC
002005DE                          1026mm     
002005DE                 FALSE    1027mm     IFNE DEBUG
002005DE                          1028mm     ENDC
002005DE                          1029mm 
002005DE                          1030mm     ENDM
002005DE                          1031m     ENDM
002005DE  6000 FEC0               1032          BRA WAIT_FOR_SRECORD
002005E2                          1033      ELSE
002005E2  6000 0410               1034s     BRA _00000001
002005E6                          1035s _00000000
002005E6                          1036          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
002005E6  B03C 0031               1037s     CMP.B   #'1',D0
002005EA  6708                    1038s     BEQ.S   _00000002
002005EC  B03C 0032               1039s     CMP.B   #'2',D0
002005F0  6600 0202               1040s     BNE.L   _00000003
002005F4                          1041s _00000002
002005F4  5785                    1042              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
002005F6                          1043      
002005F6  7E00                    1044              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
002005F8                          1045m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; first byte                           
002005F8  123C 0002               1046m     MOVE.B #2,D1
002005FC                          1047m     WHILE.B D1 <GT> 0 DO
002005FC                          1048ms _10000002
002005FC  B238 0000               1049ms     CMP.B   0,D1
00200600  6F00 0064               1050ms     BLE _10000003
00200604  E98F                    1051m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200606                          1052mm         DOWNLOAD D2
00200606                          1053mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200606                          1054mm 
00200606  1439 00C00003           1055mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020060C  0802 0000               1056mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200610  6700 0010               1057mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
00200614                          1058mm  
00200614                          1059mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200614                 TRUE     1060mmm     IFEQ DEBUG
00200614  1439 00C00007           1061mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020061A                          1062mmm     ENDC
0020061A                 FALSE    1063mmm     IFNE DEBUG
0020061A                          1064mmm     ENDC
0020061A                          1065mmm      
0020061A  B43C 001B               1066mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020061E  6700 F9E8               1067mmm     BEQ START
00200622                          1068mmm     ENDM
00200622                          1069mm CONTINUE_59
00200622  1439 00C00013           1070mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200628  0802 0000               1071mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020062C  67D8                    1072mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
0020062E                          1073mm     
0020062E  1439 00C00017           1074mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200634  13C2 00E00001           1075mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020063A                          1076mm     
0020063A                          1077mm     ENDM
0020063A                          1078mm         PRINT_CHAR D2,D3
0020063A                          1079mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020063A                 TRUE     1080mm     IFEQ DEBUG
0020063A  1639 00C00003           1081mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200640  0803 0002               1082mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200644  67F4                    1083mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
00200646  13C2 00C00007           1084mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020064C                          1085mm     ENDC
0020064C                          1086mm     
0020064C                 FALSE    1087mm     IFNE DEBUG
0020064C                          1088mm     ENDC
0020064C                          1089mm 
0020064C                          1090mm     ENDM
0020064C                          1091mm         HEX2BIN D2,D2,A0
0020064C  41F9 00201072           1092mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200652  0402 0030               1093mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200656  C4BC 000000FF           1094mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020065C  1430 2000               1095mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200660                          1096mm     ENDM
00200660  8E02                    1097m         OR.B D2,D7
00200662  5301                    1098m         SUB.B #1,D1
00200664                          1099m     ENDW
00200664  6096                    1100ms     BRA _10000002
00200666                          1101ms _10000003
00200666                          1102m     
00200666  7400                    1103m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200668  1407                    1104m     MOVE.B D7,D2
0020066A  DC87                    1105m     ADD.L D7,D6
0020066C                          1106m 
0020066C                          1107m     ENDM
0020066C                          1108m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; second one
0020066C  123C 0002               1109m     MOVE.B #2,D1
00200670                          1110m     WHILE.B D1 <GT> 0 DO
00200670                          1111ms _10000004
00200670  B238 0000               1112ms     CMP.B   0,D1
00200674  6F00 0064               1113ms     BLE _10000005
00200678  E98F                    1114m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0020067A                          1115mm         DOWNLOAD D2
0020067A                          1116mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020067A                          1117mm 
0020067A  1439 00C00003           1118mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200680  0802 0000               1119mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200684  6700 0010               1120mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
00200688                          1121mm  
00200688                          1122mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200688                 TRUE     1123mmm     IFEQ DEBUG
00200688  1439 00C00007           1124mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020068E                          1125mmm     ENDC
0020068E                 FALSE    1126mmm     IFNE DEBUG
0020068E                          1127mmm     ENDC
0020068E                          1128mmm      
0020068E  B43C 001B               1129mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200692  6700 F974               1130mmm     BEQ START
00200696                          1131mmm     ENDM
00200696                          1132mm CONTINUE_64
00200696  1439 00C00013           1133mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020069C  0802 0000               1134mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002006A0  67D8                    1135mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
002006A2                          1136mm     
002006A2  1439 00C00017           1137mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006A8  13C2 00E00001           1138mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006AE                          1139mm     
002006AE                          1140mm     ENDM
002006AE                          1141mm         PRINT_CHAR D2,D3
002006AE                          1142mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006AE                 TRUE     1143mm     IFEQ DEBUG
002006AE  1639 00C00003           1144mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002006B4  0803 0002               1145mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002006B8  67F4                    1146mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006BA  13C2 00C00007           1147mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006C0                          1148mm     ENDC
002006C0                          1149mm     
002006C0                 FALSE    1150mm     IFNE DEBUG
002006C0                          1151mm     ENDC
002006C0                          1152mm 
002006C0                          1153mm     ENDM
002006C0                          1154mm         HEX2BIN D2,D2,A0
002006C0  41F9 00201072           1155mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006C6  0402 0030               1156mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006CA  C4BC 000000FF           1157mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006D0  1430 2000               1158mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006D4                          1159mm     ENDM
002006D4  8E02                    1160m         OR.B D2,D7
002006D6  5301                    1161m         SUB.B #1,D1
002006D8                          1162m     ENDW
002006D8  6096                    1163ms     BRA _10000004
002006DA                          1164ms _10000005
002006DA                          1165m     
002006DA  7400                    1166m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006DC  1407                    1167m     MOVE.B D7,D2
002006DE  DC87                    1168m     ADD.L D7,D6
002006E0                          1169m 
002006E0                          1170m     ENDM
002006E0                          1171              
002006E0                          1172              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
002006E0  B03C 0032               1173s     CMP.B   #'2',D0
002006E4  6600 0078               1174s     BNE.L   _00000004
002006E8  5385                    1175                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address    
002006EA                          1176m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; 3rd byte       
002006EA  123C 0002               1177m     MOVE.B #2,D1
002006EE                          1178m     WHILE.B D1 <GT> 0 DO
002006EE                          1179ms _10000006
002006EE  B238 0000               1180ms     CMP.B   0,D1
002006F2  6F00 0064               1181ms     BLE _10000007
002006F6  E98F                    1182m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002006F8                          1183mm         DOWNLOAD D2
002006F8                          1184mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006F8                          1185mm 
002006F8  1439 00C00003           1186mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002006FE  0802 0000               1187mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200702  6700 0010               1188mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00200706                          1189mm  
00200706                          1190mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200706                 TRUE     1191mmm     IFEQ DEBUG
00200706  1439 00C00007           1192mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020070C                          1193mmm     ENDC
0020070C                 FALSE    1194mmm     IFNE DEBUG
0020070C                          1195mmm     ENDC
0020070C                          1196mmm      
0020070C  B43C 001B               1197mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200710  6700 F8F6               1198mmm     BEQ START
00200714                          1199mmm     ENDM
00200714                          1200mm CONTINUE_69
00200714  1439 00C00013           1201mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020071A  0802 0000               1202mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020071E  67D8                    1203mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00200720                          1204mm     
00200720  1439 00C00017           1205mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200726  13C2 00E00001           1206mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020072C                          1207mm     
0020072C                          1208mm     ENDM
0020072C                          1209mm         PRINT_CHAR D2,D3
0020072C                          1210mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020072C                 TRUE     1211mm     IFEQ DEBUG
0020072C  1639 00C00003           1212mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200732  0803 0002               1213mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200736  67F4                    1214mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
00200738  13C2 00C00007           1215mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020073E                          1216mm     ENDC
0020073E                          1217mm     
0020073E                 FALSE    1218mm     IFNE DEBUG
0020073E                          1219mm     ENDC
0020073E                          1220mm 
0020073E                          1221mm     ENDM
0020073E                          1222mm         HEX2BIN D2,D2,A0
0020073E  41F9 00201072           1223mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200744  0402 0030               1224mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200748  C4BC 000000FF           1225mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020074E  1430 2000               1226mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200752                          1227mm     ENDM
00200752  8E02                    1228m         OR.B D2,D7
00200754  5301                    1229m         SUB.B #1,D1
00200756                          1230m     ENDW
00200756  6096                    1231ms     BRA _10000006
00200758                          1232ms _10000007
00200758                          1233m     
00200758  7400                    1234m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020075A  1407                    1235m     MOVE.B D7,D2
0020075C  DC87                    1236m     ADD.L D7,D6
0020075E                          1237m 
0020075E                          1238m     ENDM
0020075E                          1239              ENDI
0020075E                          1240s _00000004
0020075E                          1241              
0020075E  2247                    1242              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00200760  D3CB                    1243              ADD.L A3,A1                         ; add in the offset
00200762                          1244  
00200762                          1245              WHILE.L D5 <GT> #0 DO               ; read the data bytes                
00200762                          1246s _10000008
00200762  BABC 00000000           1247s     CMP.L   #0,D5
00200768  6F00 0080               1248s     BLE _10000009
0020076C  7E00                    1249                  MOVE.L #0,D7                    ; D7 holds the byte
0020076E                          1250m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; read it                               
0020076E  123C 0002               1251m     MOVE.B #2,D1
00200772                          1252m     WHILE.B D1 <GT> 0 DO
00200772                          1253ms _1000000A
00200772  B238 0000               1254ms     CMP.B   0,D1
00200776  6F00 0064               1255ms     BLE _1000000B
0020077A  E98F                    1256m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0020077C                          1257mm         DOWNLOAD D2
0020077C                          1258mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020077C                          1259mm 
0020077C  1439 00C00003           1260mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200782  0802 0000               1261mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200786  6700 0010               1262mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
0020078A                          1263mm  
0020078A                          1264mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020078A                 TRUE     1265mmm     IFEQ DEBUG
0020078A  1439 00C00007           1266mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200790                          1267mmm     ENDC
00200790                 FALSE    1268mmm     IFNE DEBUG
00200790                          1269mmm     ENDC
00200790                          1270mmm      
00200790  B43C 001B               1271mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200794  6700 F872               1272mmm     BEQ START
00200798                          1273mmm     ENDM
00200798                          1274mm CONTINUE_74
00200798  1439 00C00013           1275mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020079E  0802 0000               1276mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002007A2  67D8                    1277mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
002007A4                          1278mm     
002007A4  1439 00C00017           1279mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002007AA  13C2 00E00001           1280mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002007B0                          1281mm     
002007B0                          1282mm     ENDM
002007B0                          1283mm         PRINT_CHAR D2,D3
002007B0                          1284mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007B0                 TRUE     1285mm     IFEQ DEBUG
002007B0  1639 00C00003           1286mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007B6  0803 0002               1287mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007BA  67F4                    1288mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
002007BC  13C2 00C00007           1289mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007C2                          1290mm     ENDC
002007C2                          1291mm     
002007C2                 FALSE    1292mm     IFNE DEBUG
002007C2                          1293mm     ENDC
002007C2                          1294mm 
002007C2                          1295mm     ENDM
002007C2                          1296mm         HEX2BIN D2,D2,A0
002007C2  41F9 00201072           1297mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002007C8  0402 0030               1298mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007CC  C4BC 000000FF           1299mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002007D2  1430 2000               1300mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002007D6                          1301mm     ENDM
002007D6  8E02                    1302m         OR.B D2,D7
002007D8  5301                    1303m         SUB.B #1,D1
002007DA                          1304m     ENDW
002007DA  6096                    1305ms     BRA _1000000A
002007DC                          1306ms _1000000B
002007DC                          1307m     
002007DC  7400                    1308m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007DE  1407                    1309m     MOVE.B D7,D2
002007E0  DC87                    1310m     ADD.L D7,D6
002007E2                          1311m 
002007E2                          1312m     ENDM
002007E2                          1313                          
002007E2  12C7                    1314                  MOVE.B D7,(A1)+                 ; store it!
002007E4                          1315  
002007E4  5385                    1316                  SUB.L #1,D5                     ; 1 less byte to go
002007E6                          1317              ENDW
002007E6  6000 FF7A               1318s     BRA _10000008
002007EA                          1319s _10000009
002007EA                          1320          
002007EA  43F9 002004A0           1321              LEA WAIT_FOR_SRECORD,A1             ; next place to go
002007F0                          1322          ELSE
002007F0  6000 0202               1323s     BRA _00000005
002007F4                          1324s _00000003
002007F4                          1325              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
002007F4  B03C 0038               1326s     CMP.B   #'8',D0
002007F8  6600 016C               1327s     BNE.L   _00000006
002007FC  7E00                    1328                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007FE                          1329m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; top byte  
002007FE  123C 0002               1330m     MOVE.B #2,D1
00200802                          1331m     WHILE.B D1 <GT> 0 DO
00200802                          1332ms _1000000C
00200802  B238 0000               1333ms     CMP.B   0,D1
00200806  6F00 0064               1334ms     BLE _1000000D
0020080A  E98F                    1335m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0020080C                          1336mm         DOWNLOAD D2
0020080C                          1337mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020080C                          1338mm 
0020080C  1439 00C00003           1339mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200812  0802 0000               1340mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200816  6700 0010               1341mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
0020081A                          1342mm  
0020081A                          1343mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020081A                 TRUE     1344mmm     IFEQ DEBUG
0020081A  1439 00C00007           1345mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200820                          1346mmm     ENDC
00200820                 FALSE    1347mmm     IFNE DEBUG
00200820                          1348mmm     ENDC
00200820                          1349mmm      
00200820  B43C 001B               1350mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200824  6700 F7E2               1351mmm     BEQ START
00200828                          1352mmm     ENDM
00200828                          1353mm CONTINUE_79
00200828  1439 00C00013           1354mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020082E  0802 0000               1355mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200832  67D8                    1356mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
00200834                          1357mm     
00200834  1439 00C00017           1358mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020083A  13C2 00E00001           1359mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200840                          1360mm     
00200840                          1361mm     ENDM
00200840                          1362mm         PRINT_CHAR D2,D3
00200840                          1363mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200840                 TRUE     1364mm     IFEQ DEBUG
00200840  1639 00C00003           1365mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200846  0803 0002               1366mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020084A  67F4                    1367mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
0020084C  13C2 00C00007           1368mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200852                          1369mm     ENDC
00200852                          1370mm     
00200852                 FALSE    1371mm     IFNE DEBUG
00200852                          1372mm     ENDC
00200852                          1373mm 
00200852                          1374mm     ENDM
00200852                          1375mm         HEX2BIN D2,D2,A0
00200852  41F9 00201072           1376mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200858  0402 0030               1377mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020085C  C4BC 000000FF           1378mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200862  1430 2000               1379mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200866                          1380mm     ENDM
00200866  8E02                    1381m         OR.B D2,D7
00200868  5301                    1382m         SUB.B #1,D1
0020086A                          1383m     ENDW
0020086A  6096                    1384ms     BRA _1000000C
0020086C                          1385ms _1000000D
0020086C                          1386m     
0020086C  7400                    1387m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020086E  1407                    1388m     MOVE.B D7,D2
00200870  DC87                    1389m     ADD.L D7,D6
00200872                          1390m 
00200872                          1391m     ENDM
00200872                          1392m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; middle byte     
00200872  123C 0002               1393m     MOVE.B #2,D1
00200876                          1394m     WHILE.B D1 <GT> 0 DO
00200876                          1395ms _1000000E
00200876  B238 0000               1396ms     CMP.B   0,D1
0020087A  6F00 0064               1397ms     BLE _1000000F
0020087E  E98F                    1398m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200880                          1399mm         DOWNLOAD D2
00200880                          1400mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200880                          1401mm 
00200880  1439 00C00003           1402mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200886  0802 0000               1403mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020088A  6700 0010               1404mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
0020088E                          1405mm  
0020088E                          1406mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020088E                 TRUE     1407mmm     IFEQ DEBUG
0020088E  1439 00C00007           1408mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200894                          1409mmm     ENDC
00200894                 FALSE    1410mmm     IFNE DEBUG
00200894                          1411mmm     ENDC
00200894                          1412mmm      
00200894  B43C 001B               1413mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200898  6700 F76E               1414mmm     BEQ START
0020089C                          1415mmm     ENDM
0020089C                          1416mm CONTINUE_84
0020089C  1439 00C00013           1417mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002008A2  0802 0000               1418mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008A6  67D8                    1419mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
002008A8                          1420mm     
002008A8  1439 00C00017           1421mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008AE  13C2 00E00001           1422mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008B4                          1423mm     
002008B4                          1424mm     ENDM
002008B4                          1425mm         PRINT_CHAR D2,D3
002008B4                          1426mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008B4                 TRUE     1427mm     IFEQ DEBUG
002008B4  1639 00C00003           1428mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008BA  0803 0002               1429mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008BE  67F4                    1430mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008C0  13C2 00C00007           1431mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008C6                          1432mm     ENDC
002008C6                          1433mm     
002008C6                 FALSE    1434mm     IFNE DEBUG
002008C6                          1435mm     ENDC
002008C6                          1436mm 
002008C6                          1437mm     ENDM
002008C6                          1438mm         HEX2BIN D2,D2,A0
002008C6  41F9 00201072           1439mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008CC  0402 0030               1440mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008D0  C4BC 000000FF           1441mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008D6  1430 2000               1442mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008DA                          1443mm     ENDM
002008DA  8E02                    1444m         OR.B D2,D7
002008DC  5301                    1445m         SUB.B #1,D1
002008DE                          1446m     ENDW
002008DE  6096                    1447ms     BRA _1000000E
002008E0                          1448ms _1000000F
002008E0                          1449m     
002008E0  7400                    1450m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002008E2  1407                    1451m     MOVE.B D7,D2
002008E4  DC87                    1452m     ADD.L D7,D6
002008E6                          1453m 
002008E6                          1454m     ENDM
002008E6                          1455m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; bottom byte
002008E6  123C 0002               1456m     MOVE.B #2,D1
002008EA                          1457m     WHILE.B D1 <GT> 0 DO
002008EA                          1458ms _10000010
002008EA  B238 0000               1459ms     CMP.B   0,D1
002008EE  6F00 0064               1460ms     BLE _10000011
002008F2  E98F                    1461m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002008F4                          1462mm         DOWNLOAD D2
002008F4                          1463mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008F4                          1464mm 
002008F4  1439 00C00003           1465mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002008FA  0802 0000               1466mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008FE  6700 0010               1467mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
00200902                          1468mm  
00200902                          1469mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200902                 TRUE     1470mmm     IFEQ DEBUG
00200902  1439 00C00007           1471mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200908                          1472mmm     ENDC
00200908                 FALSE    1473mmm     IFNE DEBUG
00200908                          1474mmm     ENDC
00200908                          1475mmm      
00200908  B43C 001B               1476mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020090C  6700 F6FA               1477mmm     BEQ START
00200910                          1478mmm     ENDM
00200910                          1479mm CONTINUE_89
00200910  1439 00C00013           1480mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200916  0802 0000               1481mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020091A  67D8                    1482mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
0020091C                          1483mm     
0020091C  1439 00C00017           1484mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200922  13C2 00E00001           1485mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200928                          1486mm     
00200928                          1487mm     ENDM
00200928                          1488mm         PRINT_CHAR D2,D3
00200928                          1489mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200928                 TRUE     1490mm     IFEQ DEBUG
00200928  1639 00C00003           1491mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020092E  0803 0002               1492mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200932  67F4                    1493mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00200934  13C2 00C00007           1494mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020093A                          1495mm     ENDC
0020093A                          1496mm     
0020093A                 FALSE    1497mm     IFNE DEBUG
0020093A                          1498mm     ENDC
0020093A                          1499mm 
0020093A                          1500mm     ENDM
0020093A                          1501mm         HEX2BIN D2,D2,A0
0020093A  41F9 00201072           1502mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200940  0402 0030               1503mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200944  C4BC 000000FF           1504mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020094A  1430 2000               1505mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020094E                          1506mm     ENDM
0020094E  8E02                    1507m         OR.B D2,D7
00200950  5301                    1508m         SUB.B #1,D1
00200952                          1509m     ENDW
00200952  6096                    1510ms     BRA _10000010
00200954                          1511ms _10000011
00200954                          1512m     
00200954  7400                    1513m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200956  1407                    1514m     MOVE.B D7,D2
00200958  DC87                    1515m     ADD.L D7,D6
0020095A                          1516m 
0020095A                          1517m     ENDM
0020095A                          1518                    
0020095A  2447                    1519                  MOVE.L D7,A2                    ; start address -> A2
0020095C                          1520                  
0020095C  43F9 00200BA0           1521                  LEA DOWNLOAD_DONE,A1            ; next place to go
00200962                          1522              ELSE
00200962  6000 0090               1523s     BRA _00000007
00200966                          1524s _00000006
00200966                          1525m                 PRINT_CRLF D3
00200966                          1526mm     PRINT_CHAR #13,D3                           ; CR
00200966                          1527mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200966                 TRUE     1528mm     IFEQ DEBUG
00200966  1639 00C00003           1529mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020096C  0803 0002               1530mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200970  67F4                    1531mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00200972  13FC 000D 00C00007      1532mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020097A                          1533mm     ENDC
0020097A                          1534mm     
0020097A                 FALSE    1535mm     IFNE DEBUG
0020097A                          1536mm     ENDC
0020097A                          1537mm 
0020097A                          1538mm     ENDM
0020097A                          1539mm     PRINT_CHAR #10,D3                           ; LF
0020097A                          1540mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020097A                 TRUE     1541mm     IFEQ DEBUG
0020097A  1639 00C00003           1542mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200980  0803 0002               1543mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200984  67F4                    1544mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00200986  13FC 000A 00C00007      1545mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020098E                          1546mm     ENDC
0020098E                          1547mm     
0020098E                 FALSE    1548mm     IFNE DEBUG
0020098E                          1549mm     ENDC
0020098E                          1550mm 
0020098E                          1551mm     ENDM
0020098E                          1552m     ENDM
0020098E                          1553              
0020098E  41F9 00201027           1554                  LEA UNREC,A0                    ; warn for unrecognised type
00200994                          1555m                 PRINT_STR A0,D3
00200994                          1556m LOOP_96
00200994  0C10 0000               1557m     CMP.B #0,(A0)                               ; 0 -> DONE
00200998  6700 001A               1558m     BEQ EXIT_96
0020099C                          1559mm     PRINT_CHAR (A0)+,D3
0020099C                          1560mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020099C                 TRUE     1561mm     IFEQ DEBUG
0020099C  1639 00C00003           1562mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009A2  0803 0002               1563mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009A6  67F4                    1564mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
002009A8  13D8 00C00007           1565mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002009AE                          1566mm     ENDC
002009AE                          1567mm     
002009AE                 FALSE    1568mm     IFNE DEBUG
002009AE                          1569mm     ENDC
002009AE                          1570mm 
002009AE                          1571mm     ENDM
002009AE  4EF9 00200994           1572m     JMP LOOP_96
002009B4                          1573m EXIT_96
002009B4                          1574m     ENDM
002009B4                          1575m                 PRINT_CHAR D7,D3
002009B4                          1576m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009B4                 TRUE     1577m     IFEQ DEBUG
002009B4  1639 00C00003           1578m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009BA  0803 0002               1579m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009BE  67F4                    1580m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
002009C0  13C7 00C00007           1581m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009C6                          1582m     ENDC
002009C6                          1583m     
002009C6                 FALSE    1584m     IFNE DEBUG
002009C6                          1585m     ENDC
002009C6                          1586m 
002009C6                          1587m     ENDM
002009C6                          1588m                 PRINT_CRLF D3
002009C6                          1589mm     PRINT_CHAR #13,D3                           ; CR
002009C6                          1590mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009C6                 TRUE     1591mm     IFEQ DEBUG
002009C6  1639 00C00003           1592mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009CC  0803 0002               1593mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009D0  67F4                    1594mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
002009D2  13FC 000D 00C00007      1595mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009DA                          1596mm     ENDC
002009DA                          1597mm     
002009DA                 FALSE    1598mm     IFNE DEBUG
002009DA                          1599mm     ENDC
002009DA                          1600mm 
002009DA                          1601mm     ENDM
002009DA                          1602mm     PRINT_CHAR #10,D3                           ; LF
002009DA                          1603mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009DA                 TRUE     1604mm     IFEQ DEBUG
002009DA  1639 00C00003           1605mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009E0  0803 0002               1606mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009E4  67F4                    1607mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
002009E6  13FC 000A 00C00007      1608mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009EE                          1609mm     ENDC
002009EE                          1610mm     
002009EE                 FALSE    1611mm     IFNE DEBUG
002009EE                          1612mm     ENDC
002009EE                          1613mm 
002009EE                          1614mm     ENDM
002009EE                          1615m     ENDM
002009EE                          1616              
002009EE  4EF9 002004A0           1617                  JMP WAIT_FOR_SRECORD            ; ignore any other type    
002009F4                          1618              ENDI
002009F4                          1619s _00000007
002009F4                          1620          ENDI
002009F4                          1621s _00000005
002009F4                          1622      ENDI
002009F4                          1623s _00000001
002009F4                          1624      
002009F4  CCBC 000000FF           1625      AND.L #$FF,D6
002009FA  4686                    1626      NOT.L D6                                    ; ones complement the checksum
002009FC                          1627          
002009FC  7E00                    1628      MOVE.L #0,D7                                ; read the checksum from the data stream, and add into the inverted checksum: should make it FF
002009FE                          1629m     DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0                         
002009FE  123C 0002               1630m     MOVE.B #2,D1
00200A02                          1631m     WHILE.B D1 <GT> 0 DO
00200A02                          1632ms _10000012
00200A02  B238 0000               1633ms     CMP.B   0,D1
00200A06  6F00 0064               1634ms     BLE _10000013
00200A0A  E98F                    1635m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200A0C                          1636mm         DOWNLOAD D2
00200A0C                          1637mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A0C                          1638mm 
00200A0C  1439 00C00003           1639mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200A12  0802 0000               1640mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A16  6700 0010               1641mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
00200A1A                          1642mm  
00200A1A                          1643mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200A1A                 TRUE     1644mmm     IFEQ DEBUG
00200A1A  1439 00C00007           1645mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A20                          1646mmm     ENDC
00200A20                 FALSE    1647mmm     IFNE DEBUG
00200A20                          1648mmm     ENDC
00200A20                          1649mmm      
00200A20  B43C 001B               1650mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A24  6700 F5E2               1651mmm     BEQ START
00200A28                          1652mmm     ENDM
00200A28                          1653mm CONTINUE_103
00200A28  1439 00C00013           1654mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200A2E  0802 0000               1655mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A32  67D8                    1656mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00200A34                          1657mm     
00200A34  1439 00C00017           1658mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A3A  13C2 00E00001           1659mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A40                          1660mm     
00200A40                          1661mm     ENDM
00200A40                          1662mm         PRINT_CHAR D2,D3
00200A40                          1663mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A40                 TRUE     1664mm     IFEQ DEBUG
00200A40  1639 00C00003           1665mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A46  0803 0002               1666mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A4A  67F4                    1667mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00200A4C  13C2 00C00007           1668mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A52                          1669mm     ENDC
00200A52                          1670mm     
00200A52                 FALSE    1671mm     IFNE DEBUG
00200A52                          1672mm     ENDC
00200A52                          1673mm 
00200A52                          1674mm     ENDM
00200A52                          1675mm         HEX2BIN D2,D2,A0
00200A52  41F9 00201072           1676mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A58  0402 0030               1677mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A5C  C4BC 000000FF           1678mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A62  1430 2000               1679mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A66                          1680mm     ENDM
00200A66  8E02                    1681m         OR.B D2,D7
00200A68  5301                    1682m         SUB.B #1,D1
00200A6A                          1683m     ENDW
00200A6A  6096                    1684ms     BRA _10000012
00200A6C                          1685ms _10000013
00200A6C                          1686m     
00200A6C  7400                    1687m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200A6E  1407                    1688m     MOVE.B D7,D2
00200A70  DC87                    1689m     ADD.L D7,D6
00200A72                          1690m 
00200A72                          1691m     ENDM
00200A72                          1692m     PRINT_CRLF D3
00200A72                          1693mm     PRINT_CHAR #13,D3                           ; CR
00200A72                          1694mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A72                 TRUE     1695mm     IFEQ DEBUG
00200A72  1639 00C00003           1696mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A78  0803 0002               1697mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A7C  67F4                    1698mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A7E  13FC 000D 00C00007      1699mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A86                          1700mm     ENDC
00200A86                          1701mm     
00200A86                 FALSE    1702mm     IFNE DEBUG
00200A86                          1703mm     ENDC
00200A86                          1704mm 
00200A86                          1705mm     ENDM
00200A86                          1706mm     PRINT_CHAR #10,D3                           ; LF
00200A86                          1707mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A86                 TRUE     1708mm     IFEQ DEBUG
00200A86  1639 00C00003           1709mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A8C  0803 0002               1710mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A90  67F4                    1711mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00200A92  13FC 000A 00C00007      1712mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A9A                          1713mm     ENDC
00200A9A                          1714mm     
00200A9A                 FALSE    1715mm     IFNE DEBUG
00200A9A                          1716mm     ENDC
00200A9A                          1717mm 
00200A9A                          1718mm     ENDM
00200A9A                          1719m     ENDM
00200A9A                          1720          
00200A9A                          1721      IF.B D6 <NE> #$FF THEN.L
00200A9A  BC3C 00FF               1722s     CMP.B   #$FF,D6
00200A9E  6700 00FE               1723s     BEQ.L   _00000008
00200AA2                          1724m         PRINT_REG D6,D3,D6,D7,A0
00200AA2                          1725mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200AA2                          1726mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AA2                 TRUE     1727mm     IFEQ DEBUG
00200AA2  1639 00C00003           1728mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AA8  0803 0002               1729mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AAC  67F4                    1730mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200AAE  13FC 0030 00C00007      1731mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AB6                          1732mm     ENDC
00200AB6                          1733mm     
00200AB6                 FALSE    1734mm     IFNE DEBUG
00200AB6                          1735mm     ENDC
00200AB6                          1736mm 
00200AB6                          1737mm     ENDM
00200AB6                          1738mm     PRINT_CHAR #'x',D3
00200AB6                          1739mm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB6                 TRUE     1740mm     IFEQ DEBUG
00200AB6  1639 00C00003           1741mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200ABC  0803 0002               1742mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AC0  67F4                    1743mm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00200AC2  13FC 0078 00C00007      1744mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200ACA                          1745mm     ENDC
00200ACA                          1746mm     
00200ACA                 FALSE    1747mm     IFNE DEBUG
00200ACA                          1748mm     ENDC
00200ACA                          1749mm 
00200ACA                          1750mm     ENDM
00200ACA  7E07                    1751m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200ACC                          1752m LOOP_110
00200ACC                          1753mm     BIN2HEX D6,D6,A0
00200ACC  41F9 00201062           1754mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200AD2  E99E                    1755mm     ROL.L #4,D6                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200AD4  1C06                    1756mm     MOVE.B D6,D6
00200AD6  0286 0000000F           1757mm     ANDI.L #$F,D6
00200ADC  1C30 6000               1758mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200AE0                          1759mm     ENDM
00200AE0                          1760mm     PRINT_CHAR D6,D3
00200AE0                          1761mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1762mm     IFEQ DEBUG
00200AE0  1639 00C00003           1763mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AE6  0803 0002               1764mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1765mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200AEC  13C6 00C00007           1766mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AF2                          1767mm     ENDC
00200AF2                          1768mm     
00200AF2                 FALSE    1769mm     IFNE DEBUG
00200AF2                          1770mm     ENDC
00200AF2                          1771mm 
00200AF2                          1772mm     ENDM
00200AF2  57CF FFD8               1773m     DBEQ D7,LOOP_110
00200AF6                          1774m     ENDM
00200AF6  41F9 0020103E           1775          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00200AFC                          1776m         PRINT_STR A0,D3
00200AFC                          1777m LOOP_115
00200AFC  0C10 0000               1778m     CMP.B #0,(A0)                               ; 0 -> DONE
00200B00  6700 001A               1779m     BEQ EXIT_115
00200B04                          1780mm     PRINT_CHAR (A0)+,D3
00200B04                          1781mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B04                 TRUE     1782mm     IFEQ DEBUG
00200B04  1639 00C00003           1783mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B0A  0803 0002               1784mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B0E  67F4                    1785mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200B10  13D8 00C00007           1786mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200B16                          1787mm     ENDC
00200B16                          1788mm     
00200B16                 FALSE    1789mm     IFNE DEBUG
00200B16                          1790mm     ENDC
00200B16                          1791mm 
00200B16                          1792mm     ENDM
00200B16  4EF9 00200AFC           1793m     JMP LOOP_115
00200B1C                          1794m EXIT_115
00200B1C                          1795m     ENDM
00200B1C                          1796m         PRINT_REG D4,D3,D6,D7,A0
00200B1C                          1797mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200B1C                          1798mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B1C                 TRUE     1799mm     IFEQ DEBUG
00200B1C  1639 00C00003           1800mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B22  0803 0002               1801mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B26  67F4                    1802mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200B28  13FC 0030 00C00007      1803mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B30                          1804mm     ENDC
00200B30                          1805mm     
00200B30                 FALSE    1806mm     IFNE DEBUG
00200B30                          1807mm     ENDC
00200B30                          1808mm 
00200B30                          1809mm     ENDM
00200B30                          1810mm     PRINT_CHAR #'x',D3
00200B30                          1811mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B30                 TRUE     1812mm     IFEQ DEBUG
00200B30  1639 00C00003           1813mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B36  0803 0002               1814mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B3A  67F4                    1815mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B3C  13FC 0078 00C00007      1816mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B44                          1817mm     ENDC
00200B44                          1818mm     
00200B44                 FALSE    1819mm     IFNE DEBUG
00200B44                          1820mm     ENDC
00200B44                          1821mm 
00200B44                          1822mm     ENDM
00200B44  7E07                    1823m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B46                          1824m LOOP_117
00200B46                          1825mm     BIN2HEX D4,D6,A0
00200B46  41F9 00201062           1826mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B4C  E99C                    1827mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B4E  1C04                    1828mm     MOVE.B D4,D6
00200B50  0286 0000000F           1829mm     ANDI.L #$F,D6
00200B56  1C30 6000               1830mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200B5A                          1831mm     ENDM
00200B5A                          1832mm     PRINT_CHAR D6,D3
00200B5A                          1833mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B5A                 TRUE     1834mm     IFEQ DEBUG
00200B5A  1639 00C00003           1835mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B60  0803 0002               1836mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B64  67F4                    1837mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200B66  13C6 00C00007           1838mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B6C                          1839mm     ENDC
00200B6C                          1840mm     
00200B6C                 FALSE    1841mm     IFNE DEBUG
00200B6C                          1842mm     ENDC
00200B6C                          1843mm 
00200B6C                          1844mm     ENDM
00200B6C  57CF FFD8               1845m     DBEQ D7,LOOP_117
00200B70                          1846m     ENDM
00200B70                          1847m         PRINT_CRLF D3
00200B70                          1848mm     PRINT_CHAR #13,D3                           ; CR
00200B70                          1849mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B70                 TRUE     1850mm     IFEQ DEBUG
00200B70  1639 00C00003           1851mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B76  0803 0002               1852mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B7A  67F4                    1853mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00200B7C  13FC 000D 00C00007      1854mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B84                          1855mm     ENDC
00200B84                          1856mm     
00200B84                 FALSE    1857mm     IFNE DEBUG
00200B84                          1858mm     ENDC
00200B84                          1859mm 
00200B84                          1860mm     ENDM
00200B84                          1861mm     PRINT_CHAR #10,D3                           ; LF
00200B84                          1862mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B84                 TRUE     1863mm     IFEQ DEBUG
00200B84  1639 00C00003           1864mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B8A  0803 0002               1865mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B8E  67F4                    1866mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00200B90  13FC 000A 00C00007      1867mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B98                          1868mm     ENDC
00200B98                          1869mm     
00200B98                 FALSE    1870mm     IFNE DEBUG
00200B98                          1871mm     ENDC
00200B98                          1872mm 
00200B98                          1873mm     ENDM
00200B98                          1874m     ENDM
00200B98  4EF9 00200188           1875          JMP MAIN_LOOP
00200B9E                          1876      ENDI
00200B9E                          1877s _00000008
00200B9E                          1878      
00200B9E  4ED1                    1879      JMP (A1)
00200BA0                          1880  DOWNLOAD_DONE
00200BA0                          1881m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00200BA0                          1882mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200BA0                          1883mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BA0                 TRUE     1884mm     IFEQ DEBUG
00200BA0  1639 00C00003           1885mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BA6  0803 0002               1886mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BAA  67F4                    1887mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200BAC  13FC 0030 00C00007      1888mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BB4                          1889mm     ENDC
00200BB4                          1890mm     
00200BB4                 FALSE    1891mm     IFNE DEBUG
00200BB4                          1892mm     ENDC
00200BB4                          1893mm 
00200BB4                          1894mm     ENDM
00200BB4                          1895mm     PRINT_CHAR #'x',D3
00200BB4                          1896mm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BB4                 TRUE     1897mm     IFEQ DEBUG
00200BB4  1639 00C00003           1898mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BBA  0803 0002               1899mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BBE  67F4                    1900mm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00200BC0  13FC 0078 00C00007      1901mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BC8                          1902mm     ENDC
00200BC8                          1903mm     
00200BC8                 FALSE    1904mm     IFNE DEBUG
00200BC8                          1905mm     ENDC
00200BC8                          1906mm 
00200BC8                          1907mm     ENDM
00200BC8  7C07                    1908m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200BCA                          1909m LOOP_125
00200BCA                          1910mm     BIN2HEX D4,D7,A0
00200BCA  41F9 00201062           1911mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200BD0  E99C                    1912mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200BD2  1E04                    1913mm     MOVE.B D4,D7
00200BD4  0287 0000000F           1914mm     ANDI.L #$F,D7
00200BDA  1E30 7000               1915mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00200BDE                          1916mm     ENDM
00200BDE                          1917mm     PRINT_CHAR D7,D3
00200BDE                          1918mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BDE                 TRUE     1919mm     IFEQ DEBUG
00200BDE  1639 00C00003           1920mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BE4  0803 0002               1921mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BE8  67F4                    1922mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200BEA  13C7 00C00007           1923mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200BF0                          1924mm     ENDC
00200BF0                          1925mm     
00200BF0                 FALSE    1926mm     IFNE DEBUG
00200BF0                          1927mm     ENDC
00200BF0                          1928mm 
00200BF0                          1929mm     ENDM
00200BF0  57CE FFD8               1930m     DBEQ D6,LOOP_125
00200BF4                          1931m     ENDM
00200BF4  41F9 00201005           1932      LEA READ,A0
00200BFA                          1933m     PRINT_STR A0,D3
00200BFA                          1934m LOOP_130
00200BFA  0C10 0000               1935m     CMP.B #0,(A0)                               ; 0 -> DONE
00200BFE  6700 001A               1936m     BEQ EXIT_130
00200C02                          1937mm     PRINT_CHAR (A0)+,D3
00200C02                          1938mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C02                 TRUE     1939mm     IFEQ DEBUG
00200C02  1639 00C00003           1940mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C08  0803 0002               1941mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C0C  67F4                    1942mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200C0E  13D8 00C00007           1943mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200C14                          1944mm     ENDC
00200C14                          1945mm     
00200C14                 FALSE    1946mm     IFNE DEBUG
00200C14                          1947mm     ENDC
00200C14                          1948mm 
00200C14                          1949mm     ENDM
00200C14  4EF9 00200BFA           1950m     JMP LOOP_130
00200C1A                          1951m EXIT_130
00200C1A                          1952m     ENDM
00200C1A  2E0A                    1953      MOVE.L A2,D7                                ; set address accumulator to start address
00200C1C                          1954m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00200C1C                          1955mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200C1C                          1956mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C1C                 TRUE     1957mm     IFEQ DEBUG
00200C1C  1639 00C00003           1958mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C22  0803 0002               1959mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C26  67F4                    1960mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200C28  13FC 0030 00C00007      1961mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C30                          1962mm     ENDC
00200C30                          1963mm     
00200C30                 FALSE    1964mm     IFNE DEBUG
00200C30                          1965mm     ENDC
00200C30                          1966mm 
00200C30                          1967mm     ENDM
00200C30                          1968mm     PRINT_CHAR #'x',D3
00200C30                          1969mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C30                 TRUE     1970mm     IFEQ DEBUG
00200C30  1639 00C00003           1971mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C36  0803 0002               1972mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C3A  67F4                    1973mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00200C3C  13FC 0078 00C00007      1974mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C44                          1975mm     ENDC
00200C44                          1976mm     
00200C44                 FALSE    1977mm     IFNE DEBUG
00200C44                          1978mm     ENDC
00200C44                          1979mm 
00200C44                          1980mm     ENDM
00200C44  7C07                    1981m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200C46                          1982m LOOP_132
00200C46                          1983mm     BIN2HEX D7,D2,A0
00200C46  41F9 00201062           1984mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C4C  E99F                    1985mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200C4E  1407                    1986mm     MOVE.B D7,D2
00200C50  0282 0000000F           1987mm     ANDI.L #$F,D2
00200C56  1430 2000               1988mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200C5A                          1989mm     ENDM
00200C5A                          1990mm     PRINT_CHAR D2,D3
00200C5A                          1991mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C5A                 TRUE     1992mm     IFEQ DEBUG
00200C5A  1639 00C00003           1993mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C60  0803 0002               1994mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C64  67F4                    1995mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C66  13C2 00C00007           1996mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C6C                          1997mm     ENDC
00200C6C                          1998mm     
00200C6C                 FALSE    1999mm     IFNE DEBUG
00200C6C                          2000mm     ENDC
00200C6C                          2001mm 
00200C6C                          2002mm     ENDM
00200C6C  57CE FFD8               2003m     DBEQ D6,LOOP_132
00200C70                          2004m     ENDM
00200C70                          2005m     PRINT_CRLF D3     
00200C70                          2006mm     PRINT_CHAR #13,D3                           ; CR
00200C70                          2007mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C70                 TRUE     2008mm     IFEQ DEBUG
00200C70  1639 00C00003           2009mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C76  0803 0002               2010mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C7A  67F4                    2011mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200C7C  13FC 000D 00C00007      2012mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C84                          2013mm     ENDC
00200C84                          2014mm     
00200C84                 FALSE    2015mm     IFNE DEBUG
00200C84                          2016mm     ENDC
00200C84                          2017mm 
00200C84                          2018mm     ENDM
00200C84                          2019mm     PRINT_CHAR #10,D3                           ; LF
00200C84                          2020mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C84                 TRUE     2021mm     IFEQ DEBUG
00200C84  1639 00C00003           2022mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C8A  0803 0002               2023mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C8E  67F4                    2024mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00200C90  13FC 000A 00C00007      2025mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C98                          2026mm     ENDC
00200C98                          2027mm     
00200C98                 FALSE    2028mm     IFNE DEBUG
00200C98                          2029mm     ENDC
00200C98                          2030mm 
00200C98                          2031mm     ENDM
00200C98                          2032m     ENDM
00200C98                          2033          
00200C98  4EF9 00200188           2034      JMP MAIN_LOOP
00200C9E                          2035      
00200C9E                          2036  G
00200C9E  2047                    2037      MOVE.L D7,A0                                ; address accumulator -> address register
00200CA0  3E3C 0000               2038      MOVE #0,D7                                  ; clear the now used address accumulator
00200CA4  4ED0                    2039      JMP (A0)                                    ; jump to it!
00200CA6                          2040      
00200CA6                          2041  Z
00200CA6  207C 00200000           2042      MOVE.L #RAM,A0                              ; address of RAM
00200CAC  7000                    2043      MOVE.L #0,D0                                ; number of bytes
00200CAE                          2044     
00200CAE                          2045      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200CAE                          2046s _10000014
00200CAE  B0BC 00040000           2047s     CMP.L   #$40000,D0
00200CB4  6E00 001A               2048s     BGT _10000015
00200CB8  2200                    2049          MOVE.L D0,D1                            ; progress update
00200CBA  E089                    2050          LSR.L #8,D1 
00200CBC  E089                    2051          LSR.L #8,D1
00200CBE  0281 0000000F           2052          ANDI.L #$F,D1
00200CC4  13C1 00E00001           2053          MOVE.B D1,DISPLAY
00200CCA                          2054  
00200CCA  20C0                    2055          MOVE.L D0,(A0)+ 
00200CCC  5880                    2056          ADD.L #4,D0
00200CCE                          2057      ENDW
00200CCE  60DE                    2058s     BRA _10000014
00200CD0                          2059s _10000015
00200CD0                          2060   
00200CD0  207C 00200000           2061      MOVE.L #RAM,A0                              ; address of RAM
00200CD6  7000                    2062      MOVE.L #0,D0                                ; number of bytes
00200CD8                          2063     
00200CD8                          2064      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200CD8                          2065s _10000016
00200CD8  B0BC 00040000           2066s     CMP.L   #$40000,D0
00200CDE  6E00 00CC               2067s     BGT _10000017
00200CE2  2200                    2068          MOVE.L D0,D1                            ; progress update
00200CE4  E089                    2069          LSR.L #8,D1
00200CE6  E089                    2070          LSR.L #8,D1
00200CE8  0281 0000000F           2071          ANDI.L #$F,D1
00200CEE  13C1 00E00001           2072          MOVE.B D1,DISPLAY
00200CF4                          2073  
00200CF4  2218                    2074          MOVE.L (A0)+,D1
00200CF6                          2075            
00200CF6                          2076          IF.L D0 <EQ> D1 THEN
00200CF6  B081                    2077s     CMP.L   D1,D0
00200CF8  6600 0006               2078s     BNE _00000009
00200CFC  6000 00A8               2079              BRA OK
00200D00                          2080          ENDI 
00200D00                          2081s _00000009
00200D00                          2082            
00200D00  43F9 00201050           2083          LEA RAM_ERROR,A1
00200D06                          2084m         PRINT_STR A1,D1
00200D06                          2085m LOOP_140
00200D06  0C11 0000               2086m     CMP.B #0,(A1)                               ; 0 -> DONE
00200D0A  6700 001A               2087m     BEQ EXIT_140
00200D0E                          2088mm     PRINT_CHAR (A1)+,D1
00200D0E                          2089mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D0E                 TRUE     2090mm     IFEQ DEBUG
00200D0E  1239 00C00003           2091mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200D14  0801 0002               2092mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200D18  67F4                    2093mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200D1A  13D9 00C00007           2094mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200D20                          2095mm     ENDC
00200D20                          2096mm     
00200D20                 FALSE    2097mm     IFNE DEBUG
00200D20                          2098mm     ENDC
00200D20                          2099mm 
00200D20                          2100mm     ENDM
00200D20  4EF9 00200D06           2101m     JMP LOOP_140
00200D26                          2102m EXIT_140
00200D26                          2103m     ENDM
00200D26  2208                    2104          MOVE.L A0,D1
00200D28  5981                    2105          SUB.L #4,D1
00200D2A                          2106m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200D2A                          2107mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200D2A                          2108mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D2A                 TRUE     2109mm     IFEQ DEBUG
00200D2A  1639 00C00003           2110mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D30  0803 0002               2111mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D34  67F4                    2112mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00200D36  13FC 0030 00C00007      2113mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200D3E                          2114mm     ENDC
00200D3E                          2115mm     
00200D3E                 FALSE    2116mm     IFNE DEBUG
00200D3E                          2117mm     ENDC
00200D3E                          2118mm 
00200D3E                          2119mm     ENDM
00200D3E                          2120mm     PRINT_CHAR #'x',D3
00200D3E                          2121mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D3E                 TRUE     2122mm     IFEQ DEBUG
00200D3E  1639 00C00003           2123mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D44  0803 0002               2124mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D48  67F4                    2125mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200D4A  13FC 0078 00C00007      2126mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200D52                          2127mm     ENDC
00200D52                          2128mm     
00200D52                 FALSE    2129mm     IFNE DEBUG
00200D52                          2130mm     ENDC
00200D52                          2131mm 
00200D52                          2132mm     ENDM
00200D52  7C07                    2133m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200D54                          2134m LOOP_142
00200D54                          2135mm     BIN2HEX D1,D2,A1
00200D54  43F9 00201062           2136mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200D5A  E999                    2137mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200D5C  1401                    2138mm     MOVE.B D1,D2
00200D5E  0282 0000000F           2139mm     ANDI.L #$F,D2
00200D64  1431 2000               2140mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200D68                          2141mm     ENDM
00200D68                          2142mm     PRINT_CHAR D2,D3
00200D68                          2143mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D68                 TRUE     2144mm     IFEQ DEBUG
00200D68  1639 00C00003           2145mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D6E  0803 0002               2146mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D72  67F4                    2147mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00200D74  13C2 00C00007           2148mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D7A                          2149mm     ENDC
00200D7A                          2150mm     
00200D7A                 FALSE    2151mm     IFNE DEBUG
00200D7A                          2152mm     ENDC
00200D7A                          2153mm 
00200D7A                          2154mm     ENDM
00200D7A  57CE FFD8               2155m     DBEQ D6,LOOP_142
00200D7E                          2156m     ENDM
00200D7E                          2157m         PRINT_CRLF D3
00200D7E                          2158mm     PRINT_CHAR #13,D3                           ; CR
00200D7E                          2159mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D7E                 TRUE     2160mm     IFEQ DEBUG
00200D7E  1639 00C00003           2161mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D84  0803 0002               2162mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D88  67F4                    2163mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00200D8A  13FC 000D 00C00007      2164mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D92                          2165mm     ENDC
00200D92                          2166mm     
00200D92                 FALSE    2167mm     IFNE DEBUG
00200D92                          2168mm     ENDC
00200D92                          2169mm 
00200D92                          2170mm     ENDM
00200D92                          2171mm     PRINT_CHAR #10,D3                           ; LF
00200D92                          2172mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D92                 TRUE     2173mm     IFEQ DEBUG
00200D92  1639 00C00003           2174mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D98  0803 0002               2175mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D9C  67F4                    2176mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00200D9E  13FC 000A 00C00007      2177mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DA6                          2178mm     ENDC
00200DA6                          2179mm     
00200DA6                 FALSE    2180mm     IFNE DEBUG
00200DA6                          2181mm     ENDC
00200DA6                          2182mm 
00200DA6                          2183mm     ENDM
00200DA6                          2184m     ENDM
00200DA6                          2185  OK    
00200DA6  5880                    2186          ADD.L #4,D0
00200DA8                          2187      ENDW
00200DA8  6000 FF2E               2188s     BRA _10000016
00200DAC                          2189s _10000017
00200DAC                          2190      
00200DAC  4EF9 00200188           2191      JMP MAIN_LOOP
00200DB2                          2192    
00200DB2                          2193  L
00200DB2  7A00                    2194      MOVE.L #0,D5                                ; D5 will be the length  to write            
00200DB4                          2195  
00200DB4                          2196m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200DB4                          2197m WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DB4                          2198m 
00200DB4                 TRUE     2199m     IFEQ DEBUG
00200DB4  1639 00C00003           2200m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DBA  0803 0000               2201m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200DBE  67F4                    2202m         BEQ WAIT_FOR_READY_150                      ; NOTHING, CHECK AGAIN
00200DC0                          2203m     ENDC
00200DC0                          2204m     
00200DC0                          2205mm     READ_CHAR D2
00200DC0                 TRUE     2206mm     IFEQ DEBUG
00200DC0  1439 00C00007           2207mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DC6                          2208mm     ENDC
00200DC6                 FALSE    2209mm     IFNE DEBUG
00200DC6                          2210mm     ENDC
00200DC6                          2211mm      
00200DC6  B43C 001B               2212mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DCA  6700 F23C               2213mm     BEQ START
00200DCE                          2214mm     ENDM
00200DCE                          2215m 
00200DCE                 TRUE     2216m     IFEQ DEBUG
00200DCE                          2217mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200DCE                          2218mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DCE                 TRUE     2219mm     IFEQ DEBUG
00200DCE  1639 00C00003           2220mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DD4  0803 0002               2221mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DD8  67F4                    2222mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00200DDA  13C2 00C00007           2223mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DE0                          2224mm     ENDC
00200DE0                          2225mm     
00200DE0                 FALSE    2226mm     IFNE DEBUG
00200DE0                          2227mm     ENDC
00200DE0                          2228mm 
00200DE0                          2229mm     ENDM
00200DE0                          2230m     ENDC
00200DE0                          2231m     ENDM
00200DE0                          2232m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200DE0  41F9 00201072           2233m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DE6  0402 0030               2234m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DEA  C4BC 000000FF           2235m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DF0  1430 2000               2236m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DF4                          2237m     ENDM
00200DF4  1A02                    2238      MOVE.B D2,D5                                ; put at bottom of D5
00200DF6                          2239  
00200DF6  3C3C 0002               2240      MOVE #2,D6                                  ; 3 bytes left to read
00200DFA                          2241      
00200DFA                          2242  READ_LENGTH
00200DFA  E98D                    2243      LSL.L #4,D5                                 ; make what we have so far more significant
00200DFC                          2244m     WAIT_CHAR D2,D3                             ; next character -> D2
00200DFC                          2245m WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DFC                          2246m 
00200DFC                 TRUE     2247m     IFEQ DEBUG
00200DFC  1639 00C00003           2248m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E02  0803 0000               2249m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200E06  67F4                    2250m         BEQ WAIT_FOR_READY_154                      ; NOTHING, CHECK AGAIN
00200E08                          2251m     ENDC
00200E08                          2252m     
00200E08                          2253mm     READ_CHAR D2
00200E08                 TRUE     2254mm     IFEQ DEBUG
00200E08  1439 00C00007           2255mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E0E                          2256mm     ENDC
00200E0E                 FALSE    2257mm     IFNE DEBUG
00200E0E                          2258mm     ENDC
00200E0E                          2259mm      
00200E0E  B43C 001B               2260mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E12  6700 F1F4               2261mm     BEQ START
00200E16                          2262mm     ENDM
00200E16                          2263m 
00200E16                 TRUE     2264m     IFEQ DEBUG
00200E16                          2265mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200E16                          2266mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E16                 TRUE     2267mm     IFEQ DEBUG
00200E16  1639 00C00003           2268mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E1C  0803 0002               2269mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E20  67F4                    2270mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00200E22  13C2 00C00007           2271mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200E28                          2272mm     ENDC
00200E28                          2273mm     
00200E28                 FALSE    2274mm     IFNE DEBUG
00200E28                          2275mm     ENDC
00200E28                          2276mm 
00200E28                          2277mm     ENDM
00200E28                          2278m     ENDC
00200E28                          2279m     ENDM
00200E28                          2280m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200E28  41F9 00201072           2281m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200E2E  0402 0030               2282m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E32  C4BC 000000FF           2283m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200E38  1430 2000               2284m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200E3C                          2285m     ENDM
00200E3C  8A02                    2286      OR.B D2,D5
00200E3E  023C 00FB               2287      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200E42  57CE FFB6               2288      DBEQ D6,READ_LENGTH
00200E46                          2289          
00200E46                          2290m     PRINT_CRLF D3
00200E46                          2291mm     PRINT_CHAR #13,D3                           ; CR
00200E46                          2292mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E46                 TRUE     2293mm     IFEQ DEBUG
00200E46  1639 00C00003           2294mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E4C  0803 0002               2295mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E50  67F4                    2296mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00200E52  13FC 000D 00C00007      2297mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E5A                          2298mm     ENDC
00200E5A                          2299mm     
00200E5A                 FALSE    2300mm     IFNE DEBUG
00200E5A                          2301mm     ENDC
00200E5A                          2302mm 
00200E5A                          2303mm     ENDM
00200E5A                          2304mm     PRINT_CHAR #10,D3                           ; LF
00200E5A                          2305mm WAIT_FOR_READY_160                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E5A                 TRUE     2306mm     IFEQ DEBUG
00200E5A  1639 00C00003           2307mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E60  0803 0002               2308mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E64  67F4                    2309mm         BEQ WAIT_FOR_READY_160                      ; NO SPACE, CHECK AGAIN
00200E66  13FC 000A 00C00007      2310mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E6E                          2311mm     ENDC
00200E6E                          2312mm     
00200E6E                 FALSE    2313mm     IFNE DEBUG
00200E6E                          2314mm     ENDC
00200E6E                          2315mm 
00200E6E                          2316mm     ENDM
00200E6E                          2317m     ENDM
00200E6E                          2318  
00200E6E  207C 00000000           2319      MOVE.L #ROM,A0                              ; start of ROM
00200E74                          2320      
00200E74  2247                    2321      MOVE.L D7,A1                                ; address accumulator -> address register
00200E76  7E00                    2322      MOVE.L #0,D7                                ; clear the now used address accumulator
00200E78                          2323      
00200E78  267C 00002AAA           2324      MOVE.L #$2AAA,A3
00200E7E  36BC AAAA               2325      MOVE.W #$AAAA,(A3)
00200E82  267C 00001554           2326      MOVE.L #$1554,A3
00200E88  36BC 5555               2327      MOVE.W #$5555,(A3)
00200E8C  267C 00002AAA           2328      MOVE.L #$2AAA,A3
00200E92  36BC 8080               2329      MOVE.W #$8080,(A3)
00200E96  267C 00002AAA           2330      MOVE.L #$2AAA,A3
00200E9C  36BC AAAA               2331      MOVE.W #$AAAA,(A3)
00200EA0  267C 00001554           2332      MOVE.L #$1554,A3
00200EA6  36BC 5555               2333      MOVE.W #$5555,(A3)
00200EAA  267C 00002AAA           2334      MOVE.L #$2AAA,A3
00200EB0  36BC 2020               2335      MOVE.W #$2020,(A3)
00200EB4                          2336      
00200EB4  45F9 00201089           2337      LEA LOADING,A2                              ; important for timing
00200EBA                          2338m     PRINT_STR A2,D3
00200EBA                          2339m LOOP_161
00200EBA  0C12 0000               2340m     CMP.B #0,(A2)                               ; 0 -> DONE
00200EBE  6700 001A               2341m     BEQ EXIT_161
00200EC2                          2342mm     PRINT_CHAR (A2)+,D3
00200EC2                          2343mm WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC2                 TRUE     2344mm     IFEQ DEBUG
00200EC2  1639 00C00003           2345mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200EC8  0803 0002               2346mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200ECC  67F4                    2347mm         BEQ WAIT_FOR_READY_162                      ; NO SPACE, CHECK AGAIN
00200ECE  13DA 00C00007           2348mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200ED4                          2349mm     ENDC
00200ED4                          2350mm     
00200ED4                 FALSE    2351mm     IFNE DEBUG
00200ED4                          2352mm     ENDC
00200ED4                          2353mm 
00200ED4                          2354mm     ENDM
00200ED4  4EF9 00200EBA           2355m     JMP LOOP_161
00200EDA                          2356m EXIT_161
00200EDA                          2357m     ENDM
00200EDA                          2358  
00200EDA  023C 00FB               2359      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200EDE                          2360      
00200EDE                          2361      WHILE D5 <GT> #0 DO
00200EDE                          2362s _10000018
00200EDE  BA7C 0000               2363s     CMP.W   #0,D5
00200EE2  6F00 0020               2364s     BLE _10000019
00200EE6  5585                    2365          SUB.L #2,D5
00200EE8                          2366            
00200EE8  13D1 00E00001           2367          MOVE.B (A1),DISPLAY
00200EEE  3091                    2368          MOVE.W (A1),(A0)                        ; write the data
00200EF0                          2369        
00200EF0                          2370  WAIT_FOR_COMPLETE
00200EF0  3410                    2371          MOVE.W (A0),D2
00200EF2                          2372  
00200EF2                          2373          IF D2 <NE> (A1) THEN
00200EF2  B451                    2374s     CMP.W   (A1),D2
00200EF4  6700 0008               2375s     BEQ _0000000A
00200EF8  4EF9 00200EF0           2376              JMP WAIT_FOR_COMPLETE
00200EFE                          2377          ENDI
00200EFE                          2378s _0000000A
00200EFE                          2379        
00200EFE  5488                    2380          ADD.L #2,A0
00200F00  5489                    2381          ADD.L #2,A1
00200F02                          2382      ENDW  
00200F02  60DA                    2383s     BRA _10000018
00200F04                          2384s _10000019
00200F04                          2385      
00200F04  267C 00002AAA           2386      MOVE.L #$2AAA,A3
00200F0A  36BC AAAA               2387      MOVE.W #$AAAA,(A3)
00200F0E  267C 00001554           2388      MOVE.L #$1554,A3
00200F14  36BC 5555               2389      MOVE.W #$5555,(A3)
00200F18  267C 00002AAA           2390      MOVE.L #$2AAA,A3
00200F1E  36BC A0A0               2391      MOVE.W #$A0A0,(A3)
00200F22                          2392              
00200F22  4EF9 00200188           2393      JMP MAIN_LOOP
00200F28                          2394          
00200F28                          2395  HEX_DIGIT
00200F28  E98F                    2396      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200F2A                          2397m     HEX2BIN D2,D2,A0
00200F2A  41F9 00201072           2398m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F30  0402 0030               2399m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F34  C4BC 000000FF           2400m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F3A  1430 2000               2401m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F3E                          2402m     ENDM
00200F3E  8E02                    2403      OR.B D2,D7  
00200F40  4EF9 002001B0           2404      JMP GET_INPUT
00200F46                          2405  
00200F46  FFFF FFFF               2406      SIMHALT                                     ; halt simulator
00200F4A                          2407  
00200F4A                          2408  ; strings
00200F4A= 4D 44 46 2D 6D 6F ...   2409  VERSION DC.B 'MDF-mon V1.47 (10/04/2021)',13,10,0
00200F67= 3F 20 48 65 6C 70 ...   2410  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00200FFE= 48 75 68 3F 0D 0A 00    2411  HUH     DC.B 'Huh?',13,10,0
00201005= 20 53 20 72 65 63 ...   2412  READ    DC.B ' S records read, start address = ',0
00201027= 57 3A 20 55 6E 6B ...   2413  UNREC   DC.B 'W: Unknown Srec type: ',0
0020103E= 57 3A 20 43 53 20 ...   2414  CS_FAILURE   DC.B 'W: CS failure at ',0
00201050= 57 3A 20 52 41 4D ...   2415  RAM_ERROR DC.B 'W: RAM error at: ',0
00201062= 30 31 32 33 34 35 ...   2416  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201072= 00 01 02 03 04 05 ...   2417  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201089= 4C 6F 61 64 69 6E ...   2418  LOADING  DC.B 'Loading EEPROM...',13,11,0
0020109D                          2419      
0020109D                          2420      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201062
CONTINUE_103        200A28
CONTINUE_44         2004BC
CONTINUE_47         20050C
CONTINUE_51         200564
CONTINUE_59         200622
CONTINUE_64         200696
CONTINUE_69         200714
CONTINUE_74         200798
CONTINUE_79         200828
CONTINUE_84         20089C
CONTINUE_89         200910
CS_FAILURE          20103E
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       200BA0
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_115            200B1C
EXIT_130            200C1A
EXIT_140            200D26
EXIT_161            200EDA
EXIT_19             2002EA
EXIT_21             200316
EXIT_23             200342
EXIT_5              200142
EXIT_96             2009B4
G                   200C9E
GET_INPUT           2001B0
H                   2002F0
HELP                200F67
HEX2BIN             134
HEX2BIN_LUT         201072
HEX_DIGIT           200F28
HUH                 200FFE
L                   200DB2
LOADING             201089
LOOP_110            200ACC
LOOP_115            200AFC
LOOP_117            200B46
LOOP_125            200BCA
LOOP_130            200BFA
LOOP_132            200C46
LOOP_140            200D06
LOOP_142            200D54
LOOP_161            200EBA
LOOP_19             2002CA
LOOP_21             2002F6
LOOP_23             200322
LOOP_25             200376
LOOP_5              200122
LOOP_96             200994
MAIN_LOOP           200188
OK                  200DA6
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           201050
READ                201005
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         200DFA
RESET               200004
ROM                 0
S                   200498
STACK               200000
START               200008
UNREC               201027
V                   20031C
VERSION             200F4A
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   200EF0
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  2009C6
WAIT_FOR_READY_101  2009DA
WAIT_FOR_READY_103  200A0C
WAIT_FOR_READY_105  200A40
WAIT_FOR_READY_108  200A72
WAIT_FOR_READY_109  200A86
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_111  200AA2
WAIT_FOR_READY_112  200AB6
WAIT_FOR_READY_114  200AE0
WAIT_FOR_READY_116  200B04
WAIT_FOR_READY_118  200B1C
WAIT_FOR_READY_119  200B30
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_121  200B5A
WAIT_FOR_READY_123  200B70
WAIT_FOR_READY_124  200B84
WAIT_FOR_READY_126  200BA0
WAIT_FOR_READY_127  200BB4
WAIT_FOR_READY_129  200BDE
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200C02
WAIT_FOR_READY_133  200C1C
WAIT_FOR_READY_134  200C30
WAIT_FOR_READY_136  200C5A
WAIT_FOR_READY_138  200C70
WAIT_FOR_READY_139  200C84
WAIT_FOR_READY_141  200D0E
WAIT_FOR_READY_143  200D2A
WAIT_FOR_READY_144  200D3E
WAIT_FOR_READY_146  200D68
WAIT_FOR_READY_148  200D7E
WAIT_FOR_READY_149  200D92
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_150  200DB4
WAIT_FOR_READY_152  200DCE
WAIT_FOR_READY_154  200DFC
WAIT_FOR_READY_156  200E16
WAIT_FOR_READY_159  200E46
WAIT_FOR_READY_160  200E5A
WAIT_FOR_READY_162  200EC2
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DA
WAIT_FOR_READY_47   2004F0
WAIT_FOR_READY_49   200524
WAIT_FOR_READY_51   200548
WAIT_FOR_READY_53   20057C
WAIT_FOR_READY_56   2005B6
WAIT_FOR_READY_57   2005CA
WAIT_FOR_READY_59   200606
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   20063A
WAIT_FOR_READY_64   20067A
WAIT_FOR_READY_66   2006AE
WAIT_FOR_READY_69   2006F8
WAIT_FOR_READY_71   20072C
WAIT_FOR_READY_74   20077C
WAIT_FOR_READY_76   2007B0
WAIT_FOR_READY_79   20080C
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_81   200840
WAIT_FOR_READY_84   200880
WAIT_FOR_READY_86   2008B4
WAIT_FOR_READY_89   2008F4
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_91   200928
WAIT_FOR_READY_94   200966
WAIT_FOR_READY_95   20097A
WAIT_FOR_READY_97   20099C
WAIT_FOR_READY_98   2009B4
WAIT_FOR_SRECORD    2004A0
Z                   200CA6
_00000000           2005E6
_00000001           2009F4
_00000002           2005F4
_00000003           2007F4
_00000004           20075E
_00000005           2009F4
_00000006           200966
_00000007           2009F4
_00000008           200B9E
_00000009           200D00
_0000000A           200EFE
_10000000           20053E
_10000001           2005A8
_10000002           2005FC
_10000003           200666
_10000004           200670
_10000005           2006DA
_10000006           2006EE
_10000007           200758
_10000008           200762
_10000009           2007EA
_1000000A           200772
_1000000B           2007DC
_1000000C           200802
_1000000D           20086C
_1000000E           200876
_1000000F           2008E0
_10000010           2008EA
_10000011           200954
_10000012           200A02
_10000013           200A6C
_10000014           200CAE
_10000015           200CD0
_10000016           200CD8
_10000017           200DAC
_10000018           200EDE
_10000019           200F04
