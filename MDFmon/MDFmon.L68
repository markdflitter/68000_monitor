00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 18:34:04

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000                             9  ; other ideas
00000000                            10  ;------------
00000000                            11  ; use DBLoop?
00000000                            12  ; keep track of highest address hit during srec download
00000000                            13  ; implement backspace
00000000                            14  ; fix being able to enter random chars when W'ing
00000000                            15  ; ram check at startup?  Not sure if this is a good idea!
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  
00000000                            18      ORG  $0
00000000                            19  
00000000  =00000000                 20  DEBUG               EQU 0
00000000                            21  
00000000                            22  ; constants
00000000  =00000000                 23  NULL                EQU 0
00000000  =00000009                 24  TAB                 EQU 9
00000000  =0000000D                 25  CR                  EQU 13
00000000  =0000000A                 26  LF                  EQU 10
00000000                            27  
00000000  =00000000                 28  ROM                 EQU $0
00000000  =00200000                 29  RAM                 EQU $200000
00000000                            30  
00000000  =00C00000                 31  DUART_BASE          EQU $C00000
00000000  =00000000                 32  DUART_MRA_          EQU $0
00000000  =00000001                 33  DUART_CSRA_         EQU $1
00000000  =00000001                 34  DUART_SRA_          EQU $1
00000000  =00000002                 35  DUART_CRA_          EQU $2
00000000  =00000003                 36  DUART_TXA_          EQU $3
00000000  =00000003                 37  DUART_RXA_          EQU $3
00000000  =00000004                 38  DUART_ACR_          EQU $4
00000000  =00000005                 39  DUART_IMR_          EQU $5
00000000  =00000008                 40  DUART_MRB_          EQU $8
00000000  =00000009                 41  DUART_CSRB_         EQU $9
00000000  =00000009                 42  DUART_SRB_          EQU $9
00000000  =0000000A                 43  DUART_CRB_          EQU $A
00000000  =0000000B                 44  DUART_TXB_          EQU $B
00000000  =0000000B                 45  DUART_RXB_          EQU $B
00000000  =0000000C                 46  DUART_IVR_          EQU $C
00000000  =0000000D                 47  DUART_OPCR_         EQU $D
00000000  =0000000E                 48  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 49  DUART_RESET_OPR_    EQU $F
00000000                            50  
00000000  =00C00001                 51  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 52  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 53  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 54  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 55  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 56  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            57  
00000000  =00C00011                 58  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 59  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 60  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 61  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 62  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 63  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            64  
00000000  =00C00009                 65  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 66  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 67  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 68  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 69  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 70  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            71  
00000000  =00E00000                 72  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 73  DISPLAY_            EQU $0
00000000  =00E00001                 74  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            75  
00000000                            76  ; macros
00000000                            77  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            78  ; the input register is changed during the process
00000000                            79  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            80  BIN2HEX MACRO
00000000                            81      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            82      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            83      MOVE.B \1,\2
00000000                            84      ANDI.L #$F,\2
00000000                            85      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            86      ENDM
00000000                            87  
00000000                            88  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            89  ; the input register is changed during the process
00000000                            90  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            91  HEX2BIN MACRO
00000000                            92      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            93      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            94      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            95      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            96      ENDM
00000000                            97  
00000000                            98  ; send a single char to the serial port
00000000                            99  ; \1 = char to send, \2 = data register to use for status poll
00000000                           100  ; will stamp on D0 and D1 in debug mode
00000000                           101  PRINT_CHAR MACRO
00000000                           102  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           103      IFEQ DEBUG
00000000                           104          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           105          BTST #2,\2                                  ; check for space to send
00000000                           106          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           107          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           108      ENDC
00000000                           109  
00000000                           110      IFNE DEBUG
00000000                           111          MOVE.B \1,D1
00000000                           112          MOVE.L #6,D0   
00000000                           113          TRAP #15                                    ; write to terminal in simulator
00000000                           114      ENDC
00000000                           115  
00000000                           116      ENDM
00000000                           117  
00000000                           118  ; send CR,LF to the serial port
00000000                           119  ; \1 = data register to use for status poll, /2 = working address register
00000000                           120  PRINT_CRLF MACRO
00000000                           121      LEA CRLF(PC),\2
00000000                           122      PRINT_STR \2,\1
00000000                           123      ENDM
00000000                           124  
00000000                           125  ; send C-style, zero terminated string to the serial port
00000000                           126  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           127  PRINT_STR MACRO
00000000                           128  LOOP\@
00000000                           129      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           130      BEQ EXIT\@
00000000                           131      PRINT_CHAR (\1)+,\2
00000000                           132      BRA LOOP\@
00000000                           133  EXIT\@
00000000                           134      ENDM
00000000                           135    
00000000                           136  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           137  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           138  PRINT_REG MACRO
00000000                           139      LEA ox(PC),\5
00000000                           140      PRINT_STR \5,\2
00000000                           141      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           142  LOOP\@
00000000                           143      BIN2HEX \1,\3,\5
00000000                           144      PRINT_CHAR \3,\2
00000000                           145      DBEQ \4,LOOP\@
00000000                           146      ENDM
00000000                           147  
00000000                           148  ; wait for a char from the serial port
00000000                           149  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           150  ; will stamp on D0 and D1 in debug mode
00000000                           151  WAIT_CHAR MACRO
00000000                           152  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           153      IFEQ DEBUG
00000000                           154          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           155          BTST #0,\2                                  ; check for character
00000000                           156          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           157      ENDC
00000000                           158  
00000000                           159      READ_CHAR \1
00000000                           160  
00000000                           161      IFEQ DEBUG
00000000                           162          PRINT_CHAR \1,\2                            ; echo it back
00000000                           163      ENDC
00000000                           164      ENDM
00000000                           165  
00000000                           166  ; read a char from the serial port - assumes that there is one!
00000000                           167  ; \ 1= data register for read char
00000000                           168  ; will stamp on D0 and D1 in debug mode
00000000                           169  READ_CHAR MACRO
00000000                           170      IFEQ DEBUG
00000000                           171          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           172      ENDC
00000000                           173      IFNE DEBUG
00000000                           174          MOVE.L #5,D0    
00000000                           175          TRAP #15                                    ; read from keyboard in simulator
00000000                           176          MOVE.L D1,\1
00000000                           177      ENDC
00000000                           178  
00000000                           179      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           180      BEQ START
00000000                           181      ENDM
00000000                           182  
00000000                           183  
00000000                           184  ; read data from the download serial port
00000000                           185  ; \ 1= data register for read char
00000000                           186  DOWNLOAD MACRO
00000000                           187  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           188  
00000000                           189      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           190      BTST #0,\1                                      ; check for character
00000000                           191      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           192  
00000000                           193      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           194  CONTINUE\@
00000000                           195      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           196      BTST #0,\1                                      ; check for character
00000000                           197      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           198      
00000000                           199      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           200      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           201  
00000000                           202      ENDM
00000000                           203  
00000000                           204  ; unprotect the EEPROM
00000000                           205  UNPROTECT MACRO
00000000                           206      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           207      NOP
00000000                           208      MOVE.W #$5555,$1554
00000000                           209      NOP
00000000                           210      MOVE.W #$8080,$2AAA
00000000                           211      NOP
00000000                           212      MOVE.W #$AAAA,$2AAA
00000000                           213      NOP
00000000                           214      MOVE.W #$5555,$1554
00000000                           215      NOP
00000000                           216      MOVE.W #$2020,$2AAA
00000000                           217      ENDM
00000000                           218      
00000000                           219  ; protect the EEPROM
00000000                           220  PROTECT MACRO
00000000                           221      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           222      MOVE.W #$5555,$1554
00000000                           223      MOVE.W #$A0A0,$2AAA
00000000                           224      ENDM
00000000                           225  
00000000                           226  
00000000                           227  ; read two hex digits from the download serial port and convert to a byte
00000000                           228  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           229  DOWNLOAD_BYTE MACRO
00000000                           230      MOVE.B #2,\4
00000000                           231      WHILE.B \4 <GT> 0 DO
00000000                           232          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           233          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           234          PRINT_CHAR \2,\3
00000000                           235          HEX2BIN \2,\2,\6
00000000                           236          OR.B \2,\1
00000000                           237          SUB.B #1,\4
00000000                           238      ENDW
00000000                           239  
00000000                           240      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           241      MOVE.B \1,\2
00000000                           242      ADD.L \1,\5
00000000                           243  
00000000                           244      ENDM
00000000                           245  
00000000                           246  ; write word to EEPROM
00000000                           247  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           248  PROGRAM MACRO
00000000                           249    MOVE.W \1,\2                                      ; write the data
00000000                           250  
00000000                           251  WAIT_FOR_COMPLETE\@
00000000                           252          MOVE.W \2,\3
00000000                           253  
00000000                           254          IF.W \3 <NE> \1 THEN
00000000                           255              BRA WAIT_FOR_COMPLETE\@
00000000                           256          ENDI
00000000                           257          ENDM
00000000                           258          
00000000                           259  ; register catalogue
00000000                           260  ; D0 - used for simulator I/O
00000000                           261  ; D1 - used for simulator I/O
00000000                           262  ; D2 - read character
00000000                           263  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           264  ; D6 - working register used in R/W
00000000                           265  ; D7 - address accumulator, reset by download
00000000                           266  ; A0 - address of string to print 
00000000                           267  
00000000                           268  ; start vector
00000000= 00000000                 269  STACK   DC.L $00000000                              ; STACK
00000004= 00000008                 270  RESET   DC.L START                                  ; RESET
00000008                           271  
00000008                           272  ; start of program  
00000008                           273  START
00000008  13FC 0000 00E00001       274      MOVE.B #0,DISPLAY
00000010                           275  
00000010                           276  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       277      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       278      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           279      
00000020                           280      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                281s     MOVE.W  #$50,D1
00000024  6000 000E                282s     BRA _20000001
00000028                           283s _20000000
00000028  13C1 00C00005            284          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     285          NOP
00000030                           286      ENDF
00000030  0441 0010                287s     SUB.W   #$10,D1
00000034                           288s _20000001
00000034  B27C 0010                289s     CMP.W   #$10,D1
00000038  6CEE                     290s     BGE _20000000
0000003A                           291  
0000003A                           292      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                293s     MOVE.W  #$50,D1
0000003E  6000 000E                294s     BRA _20000003
00000042                           295s _20000002
00000042  13C1 00C00015            296          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     297          NOP
0000004A                           298      ENDF
0000004A  0441 0010                299s     SUB.W   #$10,D1
0000004E                           300s _20000003
0000004E  B27C 0010                301s     CMP.W   #$10,D1
00000052  6CEE                     302s     BGE _20000002
00000054                           303      
00000054                           304  ;initialise UART
00000054  13FC 0000 00C00009       305      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       306      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       307      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           308  
0000006C                           309  ; channel A
0000006C  13FC 0013 00C00001       310      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       311      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       312      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       313      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           314  
0000008C                           315  ; channel B
0000008C  13FC 0013 00C00011       316      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       317      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       318      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       319      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           320  
000000AC                           321m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           322m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      323m     IFEQ DEBUG
000000AC  1239 00C00003            324m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                325m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     326m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       327m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           328m     ENDC
000000C0                           329m 
000000C0                 FALSE     330m     IFNE DEBUG
000000C0                           331m     ENDC
000000C0                           332m 
000000C0                           333m     ENDM
000000C0                           334m     PRINT_CHAR #0,D1
000000C0                           335m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      336m     IFEQ DEBUG
000000C0  1239 00C00003            337m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                338m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     339m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       340m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           341m     ENDC
000000D4                           342m 
000000D4                 FALSE     343m     IFNE DEBUG
000000D4                           344m     ENDC
000000D4                           345m 
000000D4                           346m     ENDM
000000D4                           347m     PRINT_CHAR #0,D1
000000D4                           348m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      349m     IFEQ DEBUG
000000D4  1239 00C00003            350m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                351m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     352m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       353m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           354m     ENDC
000000E8                           355m 
000000E8                 FALSE     356m     IFNE DEBUG
000000E8                           357m     ENDC
000000E8                           358m 
000000E8                           359m     ENDM
000000E8                           360  
000000E8  13FC 0001 00E00001       361      MOVE.B #1,DISPLAY
000000F0                           362  
000000F0                           363m     PRINT_CRLF D1,A0
000000F0  41FA 1118                364m     LEA CRLF(PC),A0
000000F4                           365mm     PRINT_STR A0,D1
000000F4                           366mm LOOP_5
000000F4  0C10 0000                367mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                368mm     BEQ EXIT_5
000000FC                           369mmm     PRINT_CHAR (A0)+,D1
000000FC                           370mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      371mmm     IFEQ DEBUG
000000FC  1239 00C00003            372mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                373mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     374mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            375mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           376mmm     ENDC
0000010E                           377mmm 
0000010E                 FALSE     378mmm     IFNE DEBUG
0000010E                           379mmm     ENDC
0000010E                           380mmm 
0000010E                           381mmm     ENDM
0000010E  60E4                     382mm     BRA LOOP_5
00000110                           383mm EXIT_5
00000110                           384mm     ENDM
00000110                           385m     ENDM
00000110  41FA 1106                386      LEA VERSION(PC),A0
00000114                           387m     PRINT_STR A0,D3
00000114                           388m LOOP_7
00000114  0C10 0000                389m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                390m     BEQ EXIT_7
0000011C                           391mm     PRINT_CHAR (A0)+,D3
0000011C                           392mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      393mm     IFEQ DEBUG
0000011C  1639 00C00003            394mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                395mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     396mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            397mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           398mm     ENDC
0000012E                           399mm 
0000012E                 FALSE     400mm     IFNE DEBUG
0000012E                           401mm     ENDC
0000012E                           402mm 
0000012E                           403mm     ENDM
0000012E  60E4                     404m     BRA LOOP_7
00000130                           405m EXIT_7
00000130                           406m     ENDM
00000130                           407  
00000130  41FA 0F36                408      LEA HELPPROMPT(PC),A0
00000134                           409m     PRINT_STR A0,D3
00000134                           410m LOOP_9
00000134  0C10 0000                411m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                412m     BEQ EXIT_9
0000013C                           413mm     PRINT_CHAR (A0)+,D3
0000013C                           414mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      415mm     IFEQ DEBUG
0000013C  1639 00C00003            416mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                417mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     418mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            419mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           420mm     ENDC
0000014E                           421mm 
0000014E                 FALSE     422mm     IFNE DEBUG
0000014E                           423mm     ENDC
0000014E                           424mm 
0000014E                           425mm     ENDM
0000014E  60E4                     426m     BRA LOOP_9
00000150                           427m EXIT_9
00000150                           428m     ENDM
00000150                           429  
00000150                           430m     PRINT_CRLF D3,A0
00000150  41FA 10B8                431m     LEA CRLF(PC),A0
00000154                           432mm     PRINT_STR A0,D3
00000154                           433mm LOOP_12
00000154  0C10 0000                434mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                435mm     BEQ EXIT_12
0000015C                           436mmm     PRINT_CHAR (A0)+,D3
0000015C                           437mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      438mmm     IFEQ DEBUG
0000015C  1639 00C00003            439mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                440mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     441mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            442mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           443mmm     ENDC
0000016E                           444mmm 
0000016E                 FALSE     445mmm     IFNE DEBUG
0000016E                           446mmm     ENDC
0000016E                           447mmm 
0000016E                           448mmm     ENDM
0000016E  60E4                     449mm     BRA LOOP_12
00000170                           450mm EXIT_12
00000170                           451mm     ENDM
00000170                           452m     ENDM
00000170                           453  
00000170  7E00                     454      MOVE.L #0,D7                                    ; address accumulator
00000172                           455  
00000172  13FC 0002 00E00001       456      MOVE.B #2,DISPLAY
0000017A                           457  MAIN_LOOP
0000017A  41FA 1091                458      LEA PROMPT(PC),A0
0000017E                           459m     PRINT_STR A0,D3
0000017E                           460m LOOP_14
0000017E  0C10 0000                461m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                462m     BEQ EXIT_14
00000186                           463mm     PRINT_CHAR (A0)+,D3
00000186                           464mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      465mm     IFEQ DEBUG
00000186  1639 00C00003            466mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                467mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     468mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            469mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           470mm     ENDC
00000198                           471mm 
00000198                 FALSE     472mm     IFNE DEBUG
00000198                           473mm     ENDC
00000198                           474mm 
00000198                           475mm     ENDM
00000198  60E4                     476m     BRA LOOP_14
0000019A                           477m EXIT_14
0000019A                           478m     ENDM
0000019A                           479  
0000019A                           480  GET_INPUT
0000019A                           481m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           482m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      483m     IFEQ DEBUG
0000019A  1639 00C00003            484m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                485m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     486m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           487m     ENDC
000001A6                           488m 
000001A6                           489mm     READ_CHAR D2
000001A6                 TRUE      490mm     IFEQ DEBUG
000001A6  1439 00C00007            491mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           492mm     ENDC
000001AC                 FALSE     493mm     IFNE DEBUG
000001AC                           494mm     ENDC
000001AC                           495mm 
000001AC  B43C 001B                496mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                497mm     BEQ START
000001B4                           498mm     ENDM
000001B4                           499m 
000001B4                 TRUE      500m     IFEQ DEBUG
000001B4                           501mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           502mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      503mm     IFEQ DEBUG
000001B4  1639 00C00003            504mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                505mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     506mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            507mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           508mm     ENDC
000001C6                           509mm 
000001C6                 FALSE     510mm     IFNE DEBUG
000001C6                           511mm     ENDC
000001C6                           512mm 
000001C6                           513mm     ENDM
000001C6                           514m     ENDC
000001C6                           515m     ENDM
000001C6                           516  
000001C6                           517      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                518s     CMP.B   #'0',D2
000001CA  6D00 000E                519s     BLT _00000000
000001CE  B43C 0039                520s     CMP.B   #'9',D2
000001D2  6E00 0006                521s     BGT _00000000
000001D6  6000 0E72                522          BRA HEX_DIGIT
000001DA                           523      ENDI
000001DA                           524s _00000000
000001DA                           525      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                526s     CMP.B   #'A',D2
000001DE  6D00 000E                527s     BLT _00000001
000001E2  B43C 0046                528s     CMP.B   #'F',D2
000001E6  6E00 0006                529s     BGT _00000001
000001EA  6000 0E5E                530          BRA HEX_DIGIT
000001EE                           531      ENDI
000001EE                           532s _00000001
000001EE                           533  
000001EE  B43C 0077                534      CMP.B #'w',D2
000001F2  6700 012E                535      BEQ W
000001F6                           536  
000001F6  B43C 006C                537      CMP.B #'l',D2
000001FA  6700 09B0                538      BEQ L 
000001FE                           539  
000001FE  B43C 0070                540      CMP.B #'p',D2
00000202  6700 0BD8                541      BEQ P
00000206                           542  
00000206  B43C 006D                543      CMP.B #'m',D2
0000020A  6700 0DA2                544      BEQ M
0000020E                           545  
0000020E                           546m     PRINT_CRLF D3,A0
0000020E  41FA 0FFA                547m     LEA CRLF(PC),A0
00000212                           548mm     PRINT_STR A0,D3
00000212                           549mm LOOP_20
00000212  0C10 0000                550mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                551mm     BEQ EXIT_20
0000021A                           552mmm     PRINT_CHAR (A0)+,D3
0000021A                           553mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      554mmm     IFEQ DEBUG
0000021A  1639 00C00003            555mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                556mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     557mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            558mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           559mmm     ENDC
0000022C                           560mmm 
0000022C                 FALSE     561mmm     IFNE DEBUG
0000022C                           562mmm     ENDC
0000022C                           563mmm 
0000022C                           564mmm     ENDM
0000022C  60E4                     565mm     BRA LOOP_20
0000022E                           566mm EXIT_20
0000022E                           567mm     ENDM
0000022E                           568m     ENDM
0000022E                           569   
0000022E  B43C 003F                570      CMP.B #'?',D2
00000232  6700 004E                571      BEQ H
00000236                           572   
00000236  B43C 0076                573      CMP.B #'v',D2
0000023A  6700 004E                574      BEQ V
0000023E                           575      
0000023E  B43C 0072                576      CMP.B #'r',D2
00000242  6700 006A                577      BEQ R
00000246                           578  
00000246  B43C 0073                579      CMP.B #'s',D2
0000024A  6700 014A                580      BEQ S
0000024E                           581  
0000024E  B43C 0067                582      CMP.B #'g',D2
00000252  6700 086E                583      BEQ G   
00000256                           584  
00000256  B43C 007A                585      CMP.B #'z',D2
0000025A  6700 086E                586      BEQ Z   
0000025E                           587  
0000025E  41FA 0F0B                588      LEA HUH(PC),A0
00000262                           589m     PRINT_STR A0,D3
00000262                           590m LOOP_22
00000262  0C10 0000                591m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000266  6700 0016                592m     BEQ EXIT_22
0000026A                           593mm     PRINT_CHAR (A0)+,D3
0000026A                           594mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      595mm     IFEQ DEBUG
0000026A  1639 00C00003            596mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000270  0803 0002                597mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000274  67F4                     598mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000276  13D8 00C00007            599mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000027C                           600mm     ENDC
0000027C                           601mm 
0000027C                 FALSE     602mm     IFNE DEBUG
0000027C                           603mm     ENDC
0000027C                           604mm 
0000027C                           605mm     ENDM
0000027C  60E4                     606m     BRA LOOP_22
0000027E                           607m EXIT_22
0000027E                           608m     ENDM
0000027E                           609  
0000027E  6000 FEFA                610      BRA MAIN_LOOP
00000282                           611  
00000282                           612  ; commands
00000282                           613  H
00000282  41FA 0DF7                614      LEA HELP(PC),A0
00000286  6000 0006                615      BRA PRINTSTR
0000028A                           616  
0000028A                           617  V
0000028A  41FA 0F8C                618      LEA VERSION(PC),A0
0000028E                           619  PRINTSTR
0000028E                           620m     PRINT_STR A0,D3    
0000028E                           621m LOOP_24
0000028E  0C10 0000                622m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000292  6700 0016                623m     BEQ EXIT_24
00000296                           624mm     PRINT_CHAR (A0)+,D3
00000296                           625mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000296                 TRUE      626mm     IFEQ DEBUG
00000296  1639 00C00003            627mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000029C  0803 0002                628mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A0  67F4                     629mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002A2  13D8 00C00007            630mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A8                           631mm     ENDC
000002A8                           632mm 
000002A8                 FALSE     633mm     IFNE DEBUG
000002A8                           634mm     ENDC
000002A8                           635mm 
000002A8                           636mm     ENDM
000002A8  60E4                     637m     BRA LOOP_24
000002AA                           638m EXIT_24
000002AA                           639m     ENDM
000002AA  6000 FECE                640      BRA MAIN_LOOP
000002AE                           641  
000002AE                           642  R
000002AE  2047                     643      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B0  7E00                     644      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002B2  2410                     645      MOVE.L (A0),D2                                  ; read the memory and print it
000002B4                           646m     PRINT_REG D2,D3,D4,D5,A0
000002B4  41FA 0F5A                647m     LEA OX(PC),A0
000002B8                           648mm     PRINT_STR A0,D3
000002B8                           649mm LOOP_27
000002B8  0C10 0000                650mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BC  6700 0016                651mm     BEQ EXIT_27
000002C0                           652mmm     PRINT_CHAR (A0)+,D3
000002C0                           653mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      654mmm     IFEQ DEBUG
000002C0  1639 00C00003            655mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002C6  0803 0002                656mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002CA  67F4                     657mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002CC  13D8 00C00007            658mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D2                           659mmm     ENDC
000002D2                           660mmm 
000002D2                 FALSE     661mmm     IFNE DEBUG
000002D2                           662mmm     ENDC
000002D2                           663mmm 
000002D2                           664mmm     ENDM
000002D2  60E4                     665mm     BRA LOOP_27
000002D4                           666mm EXIT_27
000002D4                           667mm     ENDM
000002D4  7A07                     668m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002D6                           669m LOOP_26
000002D6                           670mm     BIN2HEX D2,D4,A0
000002D6  41FA 0EF7                671mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002DA  E99A                     672mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002DC  1802                     673mm     MOVE.B D2,D4
000002DE  0284 0000000F            674mm     ANDI.L #$F,D4
000002E4  1830 4000                675mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002E8                           676mm     ENDM
000002E8                           677mm     PRINT_CHAR D4,D3
000002E8                           678mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      679mm     IFEQ DEBUG
000002E8  1639 00C00003            680mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EE  0803 0002                681mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002F2  67F4                     682mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002F4  13C4 00C00007            683mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002FA                           684mm     ENDC
000002FA                           685mm 
000002FA                 FALSE     686mm     IFNE DEBUG
000002FA                           687mm     ENDC
000002FA                           688mm 
000002FA                           689mm     ENDM
000002FA  57CD FFDA                690m     DBEQ D5,LOOP_26
000002FE                           691m     ENDM
000002FE                           692m     PRINT_CRLF D3,A0
000002FE  41FA 0F0A                693m     LEA CRLF(PC),A0
00000302                           694mm     PRINT_STR A0,D3
00000302                           695mm LOOP_32
00000302  0C10 0000                696mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000306  6700 0016                697mm     BEQ EXIT_32
0000030A                           698mmm     PRINT_CHAR (A0)+,D3
0000030A                           699mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000030A                 TRUE      700mmm     IFEQ DEBUG
0000030A  1639 00C00003            701mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000310  0803 0002                702mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000314  67F4                     703mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000316  13D8 00C00007            704mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000031C                           705mmm     ENDC
0000031C                           706mmm 
0000031C                 FALSE     707mmm     IFNE DEBUG
0000031C                           708mmm     ENDC
0000031C                           709mmm 
0000031C                           710mmm     ENDM
0000031C  60E4                     711mm     BRA LOOP_32
0000031E                           712mm EXIT_32
0000031E                           713mm     ENDM
0000031E                           714m     ENDM
0000031E  6000 FE5A                715      BRA MAIN_LOOP
00000322                           716  
00000322                           717  W
00000322  3C3C 0007                718      MOVE #7,D6                                      ; 7 bytes left to read
00000326                           719      
00000326                           720  READ_DATA_TO_POKE
00000326  E98D                     721      LSL.L #4,D5                                     ; make what we have so far more significant
00000328                           722m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000328                           723m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      724m     IFEQ DEBUG
00000328  1639 00C00003            725m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0000                726m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000332  67F4                     727m         BEQ WAIT_FOR_READY_34                       ; NOTHING, CHECK AGAIN
00000334                           728m     ENDC
00000334                           729m 
00000334                           730mm     READ_CHAR D2
00000334                 TRUE      731mm     IFEQ DEBUG
00000334  1439 00C00007            732mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000033A                           733mm     ENDC
0000033A                 FALSE     734mm     IFNE DEBUG
0000033A                           735mm     ENDC
0000033A                           736mm 
0000033A  B43C 001B                737mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000033E  6700 FCC8                738mm     BEQ START
00000342                           739mm     ENDM
00000342                           740m 
00000342                 TRUE      741m     IFEQ DEBUG
00000342                           742mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000342                           743mm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000342                 TRUE      744mm     IFEQ DEBUG
00000342  1639 00C00003            745mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000348  0803 0002                746mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000034C  67F4                     747mm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
0000034E  13C2 00C00007            748mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000354                           749mm     ENDC
00000354                           750mm 
00000354                 FALSE     751mm     IFNE DEBUG
00000354                           752mm     ENDC
00000354                           753mm 
00000354                           754mm     ENDM
00000354                           755m     ENDC
00000354                           756m     ENDM
00000354                           757m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000354  41FA 0E89                758m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000358  0402 0030                759m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000035C  C4BC 000000FF            760m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000362  1430 2000                761m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000366                           762m     ENDM
00000366  8A02                     763      OR.B D2,D5
00000368  57CE FFBC                764      DBEQ D6,READ_DATA_TO_POKE
0000036C                           765      
0000036C  2047                     766      MOVE.L D7,A0                                    ; address accumulator -> address register
0000036E  7E00                     767      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000370                           768      
00000370  2085                     769      MOVE.L D5,(A0)                                  ; write the data
00000372                           770  
00000372                           771m     PRINT_CRLF D3,A0
00000372  41FA 0E96                772m     LEA CRLF(PC),A0
00000376                           773mm     PRINT_STR A0,D3
00000376                           774mm LOOP_39
00000376  0C10 0000                775mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000037A  6700 0016                776mm     BEQ EXIT_39
0000037E                           777mmm     PRINT_CHAR (A0)+,D3
0000037E                           778mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      779mmm     IFEQ DEBUG
0000037E  1639 00C00003            780mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                781mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     782mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000038A  13D8 00C00007            783mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000390                           784mmm     ENDC
00000390                           785mmm 
00000390                 FALSE     786mmm     IFNE DEBUG
00000390                           787mmm     ENDC
00000390                           788mmm 
00000390                           789mmm     ENDM
00000390  60E4                     790mm     BRA LOOP_39
00000392                           791mm EXIT_39
00000392                           792mm     ENDM
00000392                           793m     ENDM
00000392  6000 FDE6                794      BRA MAIN_LOOP
00000396                           795  
00000396                           796  ; register map for S
00000396                           797  ; A0 - start address
00000396                           798  ; A1 - offset
00000396                           799  ; A2 - next address to write
00000396                           800  ; A3 - next location (jmp)
00000396                           801  ; A4 - Working Address Register
00000396                           802  ; D0 - record count
00000396                           803  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000396                           804  ; D2 - checksum
00000396                           805  ; D3 - data byte count
00000396                           806  ; D4 - read address, moved into A2
00000396                           807  ; D5 - temp
00000396                           808  ; D6 - temp
00000396                           809  ; D7 - temp
00000396                           810  S
00000396  2078 0000                811      MOVE.L 0,A0                                     ; start address -> A0
0000039A  2247                     812      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000039C                           813      
0000039C  7000                     814      MOVE.L #0,D0                                    ; count of records read -> D0
0000039E                           815          
0000039E                           816  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000039E                           817m     DOWNLOAD D1
0000039E                           818m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                           819m 
0000039E  1239 00C00003            820m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000003A4  0801 0000                821m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003A8  6700 0010                822m     BEQ CONTINUE_41                                 ; NOTHING, CONTINUE
000003AC                           823m 
000003AC                           824mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000003AC                 TRUE      825mm     IFEQ DEBUG
000003AC  1239 00C00007            826mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003B2                           827mm     ENDC
000003B2                 FALSE     828mm     IFNE DEBUG
000003B2                           829mm     ENDC
000003B2                           830mm 
000003B2  B23C 001B                831mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000003B6  6700 FC50                832mm     BEQ START
000003BA                           833mm     ENDM
000003BA                           834m CONTINUE_41
000003BA  1239 00C00013            835m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003C0  0801 0000                836m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003C4  67D8                     837m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003C6                           838m     
000003C6  1239 00C00017            839m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003CC  13C1 00E00001            840m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003D2                           841m 
000003D2                           842m     ENDM
000003D2  B23C 0053                843      CMP.B #'S',D1                                   ; found S?
000003D6  66C6                     844      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003D8                           845      
000003D8                           846m     PRINT_CHAR #'S',D5                              ; print the S
000003D8                           847m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D8                 TRUE      848m     IFEQ DEBUG
000003D8  1A39 00C00003            849m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000003DE  0805 0002                850m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000003E2  67F4                     851m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
000003E4  13FC 0053 00C00007       852m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
000003EC                           853m     ENDC
000003EC                           854m 
000003EC                 FALSE     855m     IFNE DEBUG
000003EC                           856m     ENDC
000003EC                           857m 
000003EC                           858m     ENDM
000003EC  5280                     859      ADD.L #1,D0                                     ; read another S record, increment count
000003EE                           860      
000003EE                           861m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003EE                           862m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EE                           863m 
000003EE  1239 00C00003            864m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000003F4  0801 0000                865m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003F8  6700 0010                866m     BEQ CONTINUE_44                                 ; NOTHING, CONTINUE
000003FC                           867m 
000003FC                           868mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000003FC                 TRUE      869mm     IFEQ DEBUG
000003FC  1239 00C00007            870mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000402                           871mm     ENDC
00000402                 FALSE     872mm     IFNE DEBUG
00000402                           873mm     ENDC
00000402                           874mm 
00000402  B23C 001B                875mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000406  6700 FC00                876mm     BEQ START
0000040A                           877mm     ENDM
0000040A                           878m CONTINUE_44
0000040A  1239 00C00013            879m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000410  0801 0000                880m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000414  67D8                     881m     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00000416                           882m     
00000416  1239 00C00017            883m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000041C  13C1 00E00001            884m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000422                           885m 
00000422                           886m     ENDM
00000422                           887m     PRINT_CHAR D1,D5
00000422                           888m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000422                 TRUE      889m     IFEQ DEBUG
00000422  1A39 00C00003            890m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000428  0805 0002                891m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000042C  67F4                     892m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000042E  13C1 00C00007            893m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000434                           894m     ENDC
00000434                           895m 
00000434                 FALSE     896m     IFNE DEBUG
00000434                           897m     ENDC
00000434                           898m 
00000434                           899m     ENDM
00000434                           900  
00000434  7400                     901      MOVE.L #0,D2                                    ; clear the checksum
00000436                           902  
00000436                           903m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000436  1E3C 0002                904m     MOVE.B #2,D7
0000043A                           905m     WHILE.B D7 <GT> 0 DO
0000043A                           906ms _10000000
0000043A  BE38 0000                907ms     CMP.B   0,D7
0000043E  6F00 0062                908ms     BLE _10000001
00000442  E98B                     909m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000444                           910mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000444                           911mm WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000444                           912mm 
00000444  1A39 00C00003            913mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000044A  0805 0000                914mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000044E  6700 0010                915mm     BEQ CONTINUE_48                                 ; NOTHING, CONTINUE
00000452                           916mm 
00000452                           917mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000452                 TRUE      918mmm     IFEQ DEBUG
00000452  1A39 00C00007            919mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000458                           920mmm     ENDC
00000458                 FALSE     921mmm     IFNE DEBUG
00000458                           922mmm     ENDC
00000458                           923mmm 
00000458  BA3C 001B                924mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000045C  6700 FBAA                925mmm     BEQ START
00000460                           926mmm     ENDM
00000460                           927mm CONTINUE_48
00000460  1A39 00C00013            928mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000466  0805 0000                929mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000046A  67D8                     930mm     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
0000046C                           931mm     
0000046C  1A39 00C00017            932mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000472  13C5 00E00001            933mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000478                           934mm 
00000478                           935mm     ENDM
00000478                           936mm         PRINT_CHAR D5,D6
00000478                           937mm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000478                 TRUE      938mm     IFEQ DEBUG
00000478  1C39 00C00003            939mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000047E  0806 0002                940mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000482  67F4                     941mm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
00000484  13C5 00C00007            942mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000048A                           943mm     ENDC
0000048A                           944mm 
0000048A                 FALSE     945mm     IFNE DEBUG
0000048A                           946mm     ENDC
0000048A                           947mm 
0000048A                           948mm     ENDM
0000048A                           949mm         HEX2BIN D5,D5,A4
0000048A  49FA 0D53                950mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000048E  0405 0030                951mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000492  CABC 000000FF            952mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000498  1A34 5000                953mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000049C                           954mm     ENDM
0000049C  8605                     955m         OR.B D5,D3
0000049E  5307                     956m         SUB.B #1,D7
000004A0                           957m     ENDW
000004A0  6098                     958ms     BRA _10000000
000004A2                           959ms _10000001
000004A2                           960m 
000004A2  7A00                     961m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000004A4  1A03                     962m     MOVE.B D3,D5
000004A6  D483                     963m     ADD.L D3,D2
000004A8                           964m 
000004A8                           965m     ENDM
000004A8                           966  
000004A8                           967      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004A8  B23C 0030                968s     CMP.B   #'0',D1
000004AC  6600 002A                969s     BNE.L   _00000002
000004B0                           970m         PRINT_CRLF D5,A4
000004B0  49FA 0D58                971m     LEA CRLF(PC),A4
000004B4                           972mm     PRINT_STR A4,D5
000004B4                           973mm LOOP_53
000004B4  0C14 0000                974mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000004B8  6700 0016                975mm     BEQ EXIT_53
000004BC                           976mmm     PRINT_CHAR (A4)+,D5
000004BC                           977mmm WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BC                 TRUE      978mmm     IFEQ DEBUG
000004BC  1A39 00C00003            979mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000004C2  0805 0002                980mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000004C6  67F4                     981mmm         BEQ WAIT_FOR_READY_54                       ; NO SPACE, CHECK AGAIN
000004C8  13DC 00C00007            982mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004CE                           983mmm     ENDC
000004CE                           984mmm 
000004CE                 FALSE     985mmm     IFNE DEBUG
000004CE                           986mmm     ENDC
000004CE                           987mmm 
000004CE                           988mmm     ENDM
000004CE  60E4                     989mm     BRA LOOP_53
000004D0                           990mm EXIT_53
000004D0                           991mm     ENDM
000004D0                           992m     ENDM
000004D0  6000 FECC                993          BRA WAIT_FOR_SRECORD
000004D4                           994      ELSE
000004D4  6000 03DE                995s     BRA _00000003
000004D8                           996s _00000002
000004D8                           997          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000004D8  B23C 0031                998s     CMP.B   #'1',D1
000004DC  6708                     999s     BEQ.S   _00000004
000004DE  B23C 0032               1000s     CMP.B   #'2',D1
000004E2  6600 01F0               1001s     BNE.L   _00000005
000004E6                          1002s _00000004
000004E6  5783                    1003              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004E8                          1004  
000004E8  7800                    1005              MOVE.L #0,D4                            ; read two bytes of address
000004EA                          1006m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000004EA  1E3C 0002               1007m     MOVE.B #2,D7
000004EE                          1008m     WHILE.B D7 <GT> 0 DO
000004EE                          1009ms _10000002
000004EE  BE38 0000               1010ms     CMP.B   0,D7
000004F2  6F00 0062               1011ms     BLE _10000003
000004F6  E98C                    1012m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000004F8                          1013mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004F8                          1014mm WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F8                          1015mm 
000004F8  1A39 00C00003           1016mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004FE  0805 0000               1017mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000502  6700 0010               1018mm     BEQ CONTINUE_56                                 ; NOTHING, CONTINUE
00000506                          1019mm 
00000506                          1020mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000506                 TRUE     1021mmm     IFEQ DEBUG
00000506  1A39 00C00007           1022mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000050C                          1023mmm     ENDC
0000050C                 FALSE    1024mmm     IFNE DEBUG
0000050C                          1025mmm     ENDC
0000050C                          1026mmm 
0000050C  BA3C 001B               1027mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000510  6700 FAF6               1028mmm     BEQ START
00000514                          1029mmm     ENDM
00000514                          1030mm CONTINUE_56
00000514  1A39 00C00013           1031mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000051A  0805 0000               1032mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000051E  67D8                    1033mm     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
00000520                          1034mm     
00000520  1A39 00C00017           1035mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000526  13C5 00E00001           1036mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000052C                          1037mm 
0000052C                          1038mm     ENDM
0000052C                          1039mm         PRINT_CHAR D5,D6
0000052C                          1040mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052C                 TRUE     1041mm     IFEQ DEBUG
0000052C  1C39 00C00003           1042mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000532  0806 0002               1043mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000536  67F4                    1044mm         BEQ WAIT_FOR_READY_58                       ; NO SPACE, CHECK AGAIN
00000538  13C5 00C00007           1045mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000053E                          1046mm     ENDC
0000053E                          1047mm 
0000053E                 FALSE    1048mm     IFNE DEBUG
0000053E                          1049mm     ENDC
0000053E                          1050mm 
0000053E                          1051mm     ENDM
0000053E                          1052mm         HEX2BIN D5,D5,A4
0000053E  49FA 0C9F               1053mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000542  0405 0030               1054mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000546  CABC 000000FF           1055mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000054C  1A34 5000               1056mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000550                          1057mm     ENDM
00000550  8805                    1058m         OR.B D5,D4
00000552  5307                    1059m         SUB.B #1,D7
00000554                          1060m     ENDW
00000554  6098                    1061ms     BRA _10000002
00000556                          1062ms _10000003
00000556                          1063m 
00000556  7A00                    1064m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000558  1A04                    1065m     MOVE.B D4,D5
0000055A  D484                    1066m     ADD.L D4,D2
0000055C                          1067m 
0000055C                          1068m     ENDM
0000055C                          1069m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
0000055C  1E3C 0002               1070m     MOVE.B #2,D7
00000560                          1071m     WHILE.B D7 <GT> 0 DO
00000560                          1072ms _10000004
00000560  BE38 0000               1073ms     CMP.B   0,D7
00000564  6F00 0062               1074ms     BLE _10000005
00000568  E98C                    1075m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000056A                          1076mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000056A                          1077mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056A                          1078mm 
0000056A  1A39 00C00003           1079mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000570  0805 0000               1080mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000574  6700 0010               1081mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000578                          1082mm 
00000578                          1083mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000578                 TRUE     1084mmm     IFEQ DEBUG
00000578  1A39 00C00007           1085mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000057E                          1086mmm     ENDC
0000057E                 FALSE    1087mmm     IFNE DEBUG
0000057E                          1088mmm     ENDC
0000057E                          1089mmm 
0000057E  BA3C 001B               1090mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000582  6700 FA84               1091mmm     BEQ START
00000586                          1092mmm     ENDM
00000586                          1093mm CONTINUE_61
00000586  1A39 00C00013           1094mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000058C  0805 0000               1095mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000590  67D8                    1096mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000592                          1097mm     
00000592  1A39 00C00017           1098mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000598  13C5 00E00001           1099mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000059E                          1100mm 
0000059E                          1101mm     ENDM
0000059E                          1102mm         PRINT_CHAR D5,D6
0000059E                          1103mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059E                 TRUE     1104mm     IFEQ DEBUG
0000059E  1C39 00C00003           1105mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000005A4  0806 0002               1106mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000005A8  67F4                    1107mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000005AA  13C5 00C00007           1108mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005B0                          1109mm     ENDC
000005B0                          1110mm 
000005B0                 FALSE    1111mm     IFNE DEBUG
000005B0                          1112mm     ENDC
000005B0                          1113mm 
000005B0                          1114mm     ENDM
000005B0                          1115mm         HEX2BIN D5,D5,A4
000005B0  49FA 0C2D               1116mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005B4  0405 0030               1117mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B8  CABC 000000FF           1118mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005BE  1A34 5000               1119mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005C2                          1120mm     ENDM
000005C2  8805                    1121m         OR.B D5,D4
000005C4  5307                    1122m         SUB.B #1,D7
000005C6                          1123m     ENDW
000005C6  6098                    1124ms     BRA _10000004
000005C8                          1125ms _10000005
000005C8                          1126m 
000005C8  7A00                    1127m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005CA  1A04                    1128m     MOVE.B D4,D5
000005CC  D484                    1129m     ADD.L D4,D2
000005CE                          1130m 
000005CE                          1131m     ENDM
000005CE                          1132  
000005CE                          1133              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000005CE  B23C 0032               1134s     CMP.B   #'2',D1
000005D2  6600 0076               1135s     BNE.L   _00000006
000005D6  5383                    1136                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005D8                          1137m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000005D8  1E3C 0002               1138m     MOVE.B #2,D7
000005DC                          1139m     WHILE.B D7 <GT> 0 DO
000005DC                          1140ms _10000006
000005DC  BE38 0000               1141ms     CMP.B   0,D7
000005E0  6F00 0062               1142ms     BLE _10000007
000005E4  E98C                    1143m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005E6                          1144mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005E6                          1145mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E6                          1146mm 
000005E6  1A39 00C00003           1147mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005EC  0805 0000               1148mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005F0  6700 0010               1149mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005F4                          1150mm 
000005F4                          1151mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005F4                 TRUE     1152mmm     IFEQ DEBUG
000005F4  1A39 00C00007           1153mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005FA                          1154mmm     ENDC
000005FA                 FALSE    1155mmm     IFNE DEBUG
000005FA                          1156mmm     ENDC
000005FA                          1157mmm 
000005FA  BA3C 001B               1158mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005FE  6700 FA08               1159mmm     BEQ START
00000602                          1160mmm     ENDM
00000602                          1161mm CONTINUE_66
00000602  1A39 00C00013           1162mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000608  0805 0000               1163mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000060C  67D8                    1164mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
0000060E                          1165mm     
0000060E  1A39 00C00017           1166mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000614  13C5 00E00001           1167mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000061A                          1168mm 
0000061A                          1169mm     ENDM
0000061A                          1170mm         PRINT_CHAR D5,D6
0000061A                          1171mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061A                 TRUE     1172mm     IFEQ DEBUG
0000061A  1C39 00C00003           1173mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000620  0806 0002               1174mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000624  67F4                    1175mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
00000626  13C5 00C00007           1176mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000062C                          1177mm     ENDC
0000062C                          1178mm 
0000062C                 FALSE    1179mm     IFNE DEBUG
0000062C                          1180mm     ENDC
0000062C                          1181mm 
0000062C                          1182mm     ENDM
0000062C                          1183mm         HEX2BIN D5,D5,A4
0000062C  49FA 0BB1               1184mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000630  0405 0030               1185mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000634  CABC 000000FF           1186mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000063A  1A34 5000               1187mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000063E                          1188mm     ENDM
0000063E  8805                    1189m         OR.B D5,D4
00000640  5307                    1190m         SUB.B #1,D7
00000642                          1191m     ENDW
00000642  6098                    1192ms     BRA _10000006
00000644                          1193ms _10000007
00000644                          1194m 
00000644  7A00                    1195m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000646  1A04                    1196m     MOVE.B D4,D5
00000648  D484                    1197m     ADD.L D4,D2
0000064A                          1198m 
0000064A                          1199m     ENDM
0000064A                          1200              ENDI
0000064A                          1201s _00000006
0000064A                          1202  
0000064A  2444                    1203              MOVE.L D4,A2                            ; put the address in an address register
0000064C  D5C9                    1204              ADD.L A1,A2                             ; add in the offset
0000064E                          1205  
0000064E                          1206              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000064E                          1207s _10000008
0000064E  B63C 0000               1208s     CMP.B   #0,D3
00000652  6F00 007A               1209s     BLE _10000009
00000656                          1210m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000656  1E3C 0002               1211m     MOVE.B #2,D7
0000065A                          1212m     WHILE.B D7 <GT> 0 DO
0000065A                          1213ms _1000000A
0000065A  BE38 0000               1214ms     CMP.B   0,D7
0000065E  6F00 0062               1215ms     BLE _1000000B
00000662  E989                    1216m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000664                          1217mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000664                          1218mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000664                          1219mm 
00000664  1A39 00C00003           1220mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000066A  0805 0000               1221mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000066E  6700 0010               1222mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
00000672                          1223mm 
00000672                          1224mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000672                 TRUE     1225mmm     IFEQ DEBUG
00000672  1A39 00C00007           1226mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000678                          1227mmm     ENDC
00000678                 FALSE    1228mmm     IFNE DEBUG
00000678                          1229mmm     ENDC
00000678                          1230mmm 
00000678  BA3C 001B               1231mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000067C  6700 F98A               1232mmm     BEQ START
00000680                          1233mmm     ENDM
00000680                          1234mm CONTINUE_71
00000680  1A39 00C00013           1235mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000686  0805 0000               1236mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000068A  67D8                    1237mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
0000068C                          1238mm     
0000068C  1A39 00C00017           1239mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000692  13C5 00E00001           1240mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000698                          1241mm 
00000698                          1242mm     ENDM
00000698                          1243mm         PRINT_CHAR D5,D6
00000698                          1244mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000698                 TRUE     1245mm     IFEQ DEBUG
00000698  1C39 00C00003           1246mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000069E  0806 0002               1247mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006A2  67F4                    1248mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
000006A4  13C5 00C00007           1249mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006AA                          1250mm     ENDC
000006AA                          1251mm 
000006AA                 FALSE    1252mm     IFNE DEBUG
000006AA                          1253mm     ENDC
000006AA                          1254mm 
000006AA                          1255mm     ENDM
000006AA                          1256mm         HEX2BIN D5,D5,A4
000006AA  49FA 0B33               1257mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006AE  0405 0030               1258mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B2  CABC 000000FF           1259mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006B8  1A34 5000               1260mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006BC                          1261mm     ENDM
000006BC  8205                    1262m         OR.B D5,D1
000006BE  5307                    1263m         SUB.B #1,D7
000006C0                          1264m     ENDW
000006C0  6098                    1265ms     BRA _1000000A
000006C2                          1266ms _1000000B
000006C2                          1267m 
000006C2  7A00                    1268m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006C4  1A01                    1269m     MOVE.B D1,D5
000006C6  D481                    1270m     ADD.L D1,D2
000006C8                          1271m 
000006C8                          1272m     ENDM
000006C8                          1273   
000006C8  14C1                    1274                  MOVE.B D1,(A2)+                     ; store it!
000006CA                          1275  
000006CA  5303                    1276                  SUB.B #1,D3                         ; 1 less byte to go
000006CC                          1277              ENDW
000006CC  6080                    1278s     BRA _10000008
000006CE                          1279s _10000009
000006CE                          1280  
000006CE  7200                    1281              MOVE.L #0,D1                            ; not done yet
000006D0                          1282          ELSE
000006D0  6000 01E2               1283s     BRA _00000007
000006D4                          1284s _00000005
000006D4                          1285              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006D4  B23C 0038               1286s     CMP.B   #'8',D1
000006D8  6600 0164               1287s     BNE.L   _00000008
000006DC  7800                    1288                  MOVE.L #0,D4                        ; read the 24 bit start address
000006DE                          1289m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000006DE  1E3C 0002               1290m     MOVE.B #2,D7
000006E2                          1291m     WHILE.B D7 <GT> 0 DO
000006E2                          1292ms _1000000C
000006E2  BE38 0000               1293ms     CMP.B   0,D7
000006E6  6F00 0062               1294ms     BLE _1000000D
000006EA  E98C                    1295m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006EC                          1296mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006EC                          1297mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006EC                          1298mm 
000006EC  1A39 00C00003           1299mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006F2  0805 0000               1300mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006F6  6700 0010               1301mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006FA                          1302mm 
000006FA                          1303mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006FA                 TRUE     1304mmm     IFEQ DEBUG
000006FA  1A39 00C00007           1305mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000700                          1306mmm     ENDC
00000700                 FALSE    1307mmm     IFNE DEBUG
00000700                          1308mmm     ENDC
00000700                          1309mmm 
00000700  BA3C 001B               1310mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000704  6700 F902               1311mmm     BEQ START
00000708                          1312mmm     ENDM
00000708                          1313mm CONTINUE_76
00000708  1A39 00C00013           1314mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000070E  0805 0000               1315mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000712  67D8                    1316mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000714                          1317mm     
00000714  1A39 00C00017           1318mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000071A  13C5 00E00001           1319mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000720                          1320mm 
00000720                          1321mm     ENDM
00000720                          1322mm         PRINT_CHAR D5,D6
00000720                          1323mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000720                 TRUE     1324mm     IFEQ DEBUG
00000720  1C39 00C00003           1325mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000726  0806 0002               1326mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000072A  67F4                    1327mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
0000072C  13C5 00C00007           1328mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000732                          1329mm     ENDC
00000732                          1330mm 
00000732                 FALSE    1331mm     IFNE DEBUG
00000732                          1332mm     ENDC
00000732                          1333mm 
00000732                          1334mm     ENDM
00000732                          1335mm         HEX2BIN D5,D5,A4
00000732  49FA 0AAB               1336mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000736  0405 0030               1337mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000073A  CABC 000000FF           1338mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000740  1A34 5000               1339mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000744                          1340mm     ENDM
00000744  8805                    1341m         OR.B D5,D4
00000746  5307                    1342m         SUB.B #1,D7
00000748                          1343m     ENDW
00000748  6098                    1344ms     BRA _1000000C
0000074A                          1345ms _1000000D
0000074A                          1346m 
0000074A  7A00                    1347m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000074C  1A04                    1348m     MOVE.B D4,D5
0000074E  D484                    1349m     ADD.L D4,D2
00000750                          1350m 
00000750                          1351m     ENDM
00000750                          1352m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000750  1E3C 0002               1353m     MOVE.B #2,D7
00000754                          1354m     WHILE.B D7 <GT> 0 DO
00000754                          1355ms _1000000E
00000754  BE38 0000               1356ms     CMP.B   0,D7
00000758  6F00 0062               1357ms     BLE _1000000F
0000075C  E98C                    1358m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000075E                          1359mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000075E                          1360mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000075E                          1361mm 
0000075E  1A39 00C00003           1362mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000764  0805 0000               1363mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000768  6700 0010               1364mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
0000076C                          1365mm 
0000076C                          1366mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000076C                 TRUE     1367mmm     IFEQ DEBUG
0000076C  1A39 00C00007           1368mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000772                          1369mmm     ENDC
00000772                 FALSE    1370mmm     IFNE DEBUG
00000772                          1371mmm     ENDC
00000772                          1372mmm 
00000772  BA3C 001B               1373mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000776  6700 F890               1374mmm     BEQ START
0000077A                          1375mmm     ENDM
0000077A                          1376mm CONTINUE_81
0000077A  1A39 00C00013           1377mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000780  0805 0000               1378mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000784  67D8                    1379mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00000786                          1380mm     
00000786  1A39 00C00017           1381mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000078C  13C5 00E00001           1382mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000792                          1383mm 
00000792                          1384mm     ENDM
00000792                          1385mm         PRINT_CHAR D5,D6
00000792                          1386mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000792                 TRUE     1387mm     IFEQ DEBUG
00000792  1C39 00C00003           1388mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000798  0806 0002               1389mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000079C  67F4                    1390mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
0000079E  13C5 00C00007           1391mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007A4                          1392mm     ENDC
000007A4                          1393mm 
000007A4                 FALSE    1394mm     IFNE DEBUG
000007A4                          1395mm     ENDC
000007A4                          1396mm 
000007A4                          1397mm     ENDM
000007A4                          1398mm         HEX2BIN D5,D5,A4
000007A4  49FA 0A39               1399mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A8  0405 0030               1400mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007AC  CABC 000000FF           1401mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007B2  1A34 5000               1402mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B6                          1403mm     ENDM
000007B6  8805                    1404m         OR.B D5,D4
000007B8  5307                    1405m         SUB.B #1,D7
000007BA                          1406m     ENDW
000007BA  6098                    1407ms     BRA _1000000E
000007BC                          1408ms _1000000F
000007BC                          1409m 
000007BC  7A00                    1410m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007BE  1A04                    1411m     MOVE.B D4,D5
000007C0  D484                    1412m     ADD.L D4,D2
000007C2                          1413m 
000007C2                          1414m     ENDM
000007C2                          1415m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000007C2  1E3C 0002               1416m     MOVE.B #2,D7
000007C6                          1417m     WHILE.B D7 <GT> 0 DO
000007C6                          1418ms _10000010
000007C6  BE38 0000               1419ms     CMP.B   0,D7
000007CA  6F00 0062               1420ms     BLE _10000011
000007CE  E98C                    1421m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007D0                          1422mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007D0                          1423mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D0                          1424mm 
000007D0  1A39 00C00003           1425mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007D6  0805 0000               1426mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007DA  6700 0010               1427mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007DE                          1428mm 
000007DE                          1429mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007DE                 TRUE     1430mmm     IFEQ DEBUG
000007DE  1A39 00C00007           1431mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007E4                          1432mmm     ENDC
000007E4                 FALSE    1433mmm     IFNE DEBUG
000007E4                          1434mmm     ENDC
000007E4                          1435mmm 
000007E4  BA3C 001B               1436mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007E8  6700 F81E               1437mmm     BEQ START
000007EC                          1438mmm     ENDM
000007EC                          1439mm CONTINUE_86
000007EC  1A39 00C00013           1440mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007F2  0805 0000               1441mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007F6  67D8                    1442mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007F8                          1443mm     
000007F8  1A39 00C00017           1444mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007FE  13C5 00E00001           1445mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000804                          1446mm 
00000804                          1447mm     ENDM
00000804                          1448mm         PRINT_CHAR D5,D6
00000804                          1449mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000804                 TRUE     1450mm     IFEQ DEBUG
00000804  1C39 00C00003           1451mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000080A  0806 0002               1452mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000080E  67F4                    1453mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
00000810  13C5 00C00007           1454mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000816                          1455mm     ENDC
00000816                          1456mm 
00000816                 FALSE    1457mm     IFNE DEBUG
00000816                          1458mm     ENDC
00000816                          1459mm 
00000816                          1460mm     ENDM
00000816                          1461mm         HEX2BIN D5,D5,A4
00000816  49FA 09C7               1462mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000081A  0405 0030               1463mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000081E  CABC 000000FF           1464mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000824  1A34 5000               1465mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000828                          1466mm     ENDM
00000828  8805                    1467m         OR.B D5,D4
0000082A  5307                    1468m         SUB.B #1,D7
0000082C                          1469m     ENDW
0000082C  6098                    1470ms     BRA _10000010
0000082E                          1471ms _10000011
0000082E                          1472m 
0000082E  7A00                    1473m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000830  1A04                    1474m     MOVE.B D4,D5
00000832  D484                    1475m     ADD.L D4,D2
00000834                          1476m 
00000834                          1477m     ENDM
00000834                          1478  
00000834  2044                    1479                  MOVE.L D4,A0                        ; start address -> A0
00000836  D1C9                    1480                  ADD.L A1,A0                         ; add in the offset
00000838                          1481  
00000838  72FF                    1482                  MOVE.L #$FFFFFFFF,D1                ; done
0000083A                          1483              ELSE
0000083A  6000 0078               1484s     BRA _00000009
0000083E                          1485s _00000008
0000083E                          1486m                 PRINT_CRLF D5,A4
0000083E  49FA 09CA               1487m     LEA CRLF(PC),A4
00000842                          1488mm     PRINT_STR A4,D5
00000842                          1489mm LOOP_91
00000842  0C14 0000               1490mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000846  6700 0016               1491mm     BEQ EXIT_91
0000084A                          1492mmm     PRINT_CHAR (A4)+,D5
0000084A                          1493mmm WAIT_FOR_READY_92                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000084A                 TRUE     1494mmm     IFEQ DEBUG
0000084A  1A39 00C00003           1495mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000850  0805 0002               1496mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000854  67F4                    1497mmm         BEQ WAIT_FOR_READY_92                       ; NO SPACE, CHECK AGAIN
00000856  13DC 00C00007           1498mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000085C                          1499mmm     ENDC
0000085C                          1500mmm 
0000085C                 FALSE    1501mmm     IFNE DEBUG
0000085C                          1502mmm     ENDC
0000085C                          1503mmm 
0000085C                          1504mmm     ENDM
0000085C  60E4                    1505mm     BRA LOOP_91
0000085E                          1506mm EXIT_91
0000085E                          1507mm     ENDM
0000085E                          1508m     ENDM
0000085E                          1509  
0000085E  49FA 0934               1510                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000862                          1511m                 PRINT_STR A4,D5
00000862                          1512m LOOP_93
00000862  0C14 0000               1513m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000866  6700 0016               1514m     BEQ EXIT_93
0000086A                          1515mm     PRINT_CHAR (A4)+,D5
0000086A                          1516mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000086A                 TRUE     1517mm     IFEQ DEBUG
0000086A  1A39 00C00003           1518mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000870  0805 0002               1519mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000874  67F4                    1520mm         BEQ WAIT_FOR_READY_94                       ; NO SPACE, CHECK AGAIN
00000876  13DC 00C00007           1521mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000087C                          1522mm     ENDC
0000087C                          1523mm 
0000087C                 FALSE    1524mm     IFNE DEBUG
0000087C                          1525mm     ENDC
0000087C                          1526mm 
0000087C                          1527mm     ENDM
0000087C  60E4                    1528m     BRA LOOP_93
0000087E                          1529m EXIT_93
0000087E                          1530m     ENDM
0000087E                          1531m                 PRINT_CHAR D1,D5
0000087E                          1532m WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087E                 TRUE     1533m     IFEQ DEBUG
0000087E  1A39 00C00003           1534m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000884  0805 0002               1535m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000888  67F4                    1536m         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
0000088A  13C1 00C00007           1537m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000890                          1538m     ENDC
00000890                          1539m 
00000890                 FALSE    1540m     IFNE DEBUG
00000890                          1541m     ENDC
00000890                          1542m 
00000890                          1543m     ENDM
00000890                          1544m                 PRINT_CRLF D5,A4
00000890  49FA 0978               1545m     LEA CRLF(PC),A4
00000894                          1546mm     PRINT_STR A4,D5
00000894                          1547mm LOOP_97
00000894  0C14 0000               1548mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000898  6700 0016               1549mm     BEQ EXIT_97
0000089C                          1550mmm     PRINT_CHAR (A4)+,D5
0000089C                          1551mmm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000089C                 TRUE     1552mmm     IFEQ DEBUG
0000089C  1A39 00C00003           1553mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008A2  0805 0002               1554mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008A6  67F4                    1555mmm         BEQ WAIT_FOR_READY_98                       ; NO SPACE, CHECK AGAIN
000008A8  13DC 00C00007           1556mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008AE                          1557mmm     ENDC
000008AE                          1558mmm 
000008AE                 FALSE    1559mmm     IFNE DEBUG
000008AE                          1560mmm     ENDC
000008AE                          1561mmm 
000008AE                          1562mmm     ENDM
000008AE  60E4                    1563mm     BRA LOOP_97
000008B0                          1564mm EXIT_97
000008B0                          1565mm     ENDM
000008B0                          1566m     ENDM
000008B0                          1567  
000008B0  6000 FAEC               1568                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
000008B4                          1569              ENDI
000008B4                          1570s _00000009
000008B4                          1571          ENDI
000008B4                          1572s _00000007
000008B4                          1573      ENDI
000008B4                          1574s _00000003
000008B4                          1575  
000008B4                          1576m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
000008B4  1E3C 0002               1577m     MOVE.B #2,D7
000008B8                          1578m     WHILE.B D7 <GT> 0 DO
000008B8                          1579ms _10000012
000008B8  BE38 0000               1580ms     CMP.B   0,D7
000008BC  6F00 0062               1581ms     BLE _10000013
000008C0  E98C                    1582m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008C2                          1583mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008C2                          1584mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008C2                          1585mm 
000008C2  1A39 00C00003           1586mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C8  0805 0000               1587mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008CC  6700 0010               1588mm     BEQ CONTINUE_100                                    ; NOTHING, CONTINUE
000008D0                          1589mm 
000008D0                          1590mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008D0                 TRUE     1591mmm     IFEQ DEBUG
000008D0  1A39 00C00007           1592mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008D6                          1593mmm     ENDC
000008D6                 FALSE    1594mmm     IFNE DEBUG
000008D6                          1595mmm     ENDC
000008D6                          1596mmm 
000008D6  BA3C 001B               1597mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008DA  6700 F72C               1598mmm     BEQ START
000008DE                          1599mmm     ENDM
000008DE                          1600mm CONTINUE_100
000008DE  1A39 00C00013           1601mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008E4  0805 0000               1602mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E8  67D8                    1603mm     BEQ WAIT_FOR_READY_100                          ; NOTHING, CHECK AGAIN
000008EA                          1604mm     
000008EA  1A39 00C00017           1605mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008F0  13C5 00E00001           1606mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008F6                          1607mm 
000008F6                          1608mm     ENDM
000008F6                          1609mm         PRINT_CHAR D5,D6
000008F6                          1610mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F6                 TRUE     1611mm     IFEQ DEBUG
000008F6  1C39 00C00003           1612mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008FC  0806 0002               1613mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000900  67F4                    1614mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000902  13C5 00C00007           1615mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000908                          1616mm     ENDC
00000908                          1617mm 
00000908                 FALSE    1618mm     IFNE DEBUG
00000908                          1619mm     ENDC
00000908                          1620mm 
00000908                          1621mm     ENDM
00000908                          1622mm         HEX2BIN D5,D5,A4
00000908  49FA 08D5               1623mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000090C  0405 0030               1624mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000910  CABC 000000FF           1625mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000916  1A34 5000               1626mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000091A                          1627mm     ENDM
0000091A  8805                    1628m         OR.B D5,D4
0000091C  5307                    1629m         SUB.B #1,D7
0000091E                          1630m     ENDW
0000091E  6098                    1631ms     BRA _10000012
00000920                          1632ms _10000013
00000920                          1633m 
00000920  7A00                    1634m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000922  1A04                    1635m     MOVE.B D4,D5
00000924  D484                    1636m     ADD.L D4,D2
00000926                          1637m 
00000926                          1638m     ENDM
00000926                          1639m     PRINT_CRLF D5,A4
00000926  49FA 08E2               1640m     LEA CRLF(PC),A4
0000092A                          1641mm     PRINT_STR A4,D5
0000092A                          1642mm LOOP_105
0000092A  0C14 0000               1643mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000092E  6700 0016               1644mm     BEQ EXIT_105
00000932                          1645mmm     PRINT_CHAR (A4)+,D5
00000932                          1646mmm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000932                 TRUE     1647mmm     IFEQ DEBUG
00000932  1A39 00C00003           1648mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000938  0805 0002               1649mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000093C  67F4                    1650mmm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
0000093E  13DC 00C00007           1651mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000944                          1652mmm     ENDC
00000944                          1653mmm 
00000944                 FALSE    1654mmm     IFNE DEBUG
00000944                          1655mmm     ENDC
00000944                          1656mmm 
00000944                          1657mmm     ENDM
00000944  60E4                    1658mm     BRA LOOP_105
00000946                          1659mm EXIT_105
00000946                          1660mm     ENDM
00000946                          1661m     ENDM
00000946                          1662  
00000946                          1663      IF.B D2 <NE> #$FF THEN.L
00000946  B43C 00FF               1664s     CMP.B   #$FF,D2
0000094A  6700 0090               1665s     BEQ.L   _0000000A
0000094E  49FA 085B               1666          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000952                          1667m         PRINT_STR A4,D5
00000952                          1668m LOOP_107
00000952  0C14 0000               1669m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000956  6700 0016               1670m     BEQ EXIT_107
0000095A                          1671mm     PRINT_CHAR (A4)+,D5
0000095A                          1672mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095A                 TRUE     1673mm     IFEQ DEBUG
0000095A  1A39 00C00003           1674mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000960  0805 0002               1675mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000964  67F4                    1676mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000966  13DC 00C00007           1677mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000096C                          1678mm     ENDC
0000096C                          1679mm 
0000096C                 FALSE    1680mm     IFNE DEBUG
0000096C                          1681mm     ENDC
0000096C                          1682mm 
0000096C                          1683mm     ENDM
0000096C  60E4                    1684m     BRA LOOP_107
0000096E                          1685m EXIT_107
0000096E                          1686m     ENDM
0000096E                          1687m         PRINT_REG D0,D5,D2,D6,A4
0000096E  49FA 08A0               1688m     LEA OX(PC),A4
00000972                          1689mm     PRINT_STR A4,D5
00000972                          1690mm LOOP_110
00000972  0C14 0000               1691mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000976  6700 0016               1692mm     BEQ EXIT_110
0000097A                          1693mmm     PRINT_CHAR (A4)+,D5
0000097A                          1694mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000097A                 TRUE     1695mmm     IFEQ DEBUG
0000097A  1A39 00C00003           1696mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000980  0805 0002               1697mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000984  67F4                    1698mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000986  13DC 00C00007           1699mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000098C                          1700mmm     ENDC
0000098C                          1701mmm 
0000098C                 FALSE    1702mmm     IFNE DEBUG
0000098C                          1703mmm     ENDC
0000098C                          1704mmm 
0000098C                          1705mmm     ENDM
0000098C  60E4                    1706mm     BRA LOOP_110
0000098E                          1707mm EXIT_110
0000098E                          1708mm     ENDM
0000098E  7C07                    1709m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000990                          1710m LOOP_109
00000990                          1711mm     BIN2HEX D0,D2,A4
00000990  49FA 083D               1712mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000994  E998                    1713mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000996  1400                    1714mm     MOVE.B D0,D2
00000998  0282 0000000F           1715mm     ANDI.L #$F,D2
0000099E  1434 2000               1716mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000009A2                          1717mm     ENDM
000009A2                          1718mm     PRINT_CHAR D2,D5
000009A2                          1719mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A2                 TRUE     1720mm     IFEQ DEBUG
000009A2  1A39 00C00003           1721mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A8  0805 0002               1722mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009AC  67F4                    1723mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009AE  13C2 00C00007           1724mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009B4                          1725mm     ENDC
000009B4                          1726mm 
000009B4                 FALSE    1727mm     IFNE DEBUG
000009B4                          1728mm     ENDC
000009B4                          1729mm 
000009B4                          1730mm     ENDM
000009B4  57CE FFDA               1731m     DBEQ D6,LOOP_109
000009B8                          1732m     ENDM
000009B8                          1733m         PRINT_CRLF D5,A4
000009B8  49FA 0850               1734m     LEA CRLF(PC),A4
000009BC                          1735mm     PRINT_STR A4,D5
000009BC                          1736mm LOOP_115
000009BC  0C14 0000               1737mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009C0  6700 0016               1738mm     BEQ EXIT_115
000009C4                          1739mmm     PRINT_CHAR (A4)+,D5
000009C4                          1740mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C4                 TRUE     1741mmm     IFEQ DEBUG
000009C4  1A39 00C00003           1742mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009CA  0805 0002               1743mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009CE  67F4                    1744mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009D0  13DC 00C00007           1745mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009D6                          1746mmm     ENDC
000009D6                          1747mmm 
000009D6                 FALSE    1748mmm     IFNE DEBUG
000009D6                          1749mmm     ENDC
000009D6                          1750mmm 
000009D6                          1751mmm     ENDM
000009D6  60E4                    1752mm     BRA LOOP_115
000009D8                          1753mm EXIT_115
000009D8                          1754mm     ENDM
000009D8                          1755m     ENDM
000009D8  6000 F7A0               1756          BRA MAIN_LOOP
000009DC                          1757      ENDI
000009DC                          1758s _0000000A
000009DC                          1759  
000009DC                          1760      IF D1 <EQ> #0 THEN
000009DC  B27C 0000               1761s     CMP.W   #0,D1
000009E0  6600 0006               1762s     BNE _0000000B
000009E4  6000 F9B8               1763        BRA WAIT_FOR_SRECORD
000009E8                          1764      ENDI
000009E8                          1765s _0000000B
000009E8                          1766  DOWNLOAD_DONE
000009E8                          1767m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009E8  43FA 0826               1768m     LEA OX(PC),A1
000009EC                          1769mm     PRINT_STR A1,D5
000009EC                          1770mm LOOP_118
000009EC  0C11 0000               1771mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000009F0  6700 0016               1772mm     BEQ EXIT_118
000009F4                          1773mmm     PRINT_CHAR (A1)+,D5
000009F4                          1774mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F4                 TRUE     1775mmm     IFEQ DEBUG
000009F4  1A39 00C00003           1776mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009FA  0805 0002               1777mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009FE  67F4                    1778mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A00  13D9 00C00007           1779mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A06                          1780mmm     ENDC
00000A06                          1781mmm 
00000A06                 FALSE    1782mmm     IFNE DEBUG
00000A06                          1783mmm     ENDC
00000A06                          1784mmm 
00000A06                          1785mmm     ENDM
00000A06  60E4                    1786mm     BRA LOOP_118
00000A08                          1787mm EXIT_118
00000A08                          1788mm     ENDM
00000A08  7407                    1789m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A0A                          1790m LOOP_117
00000A0A                          1791mm     BIN2HEX D0,D6,A1
00000A0A  43FA 07C3               1792mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A0E  E998                    1793mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A10  1C00                    1794mm     MOVE.B D0,D6
00000A12  0286 0000000F           1795mm     ANDI.L #$F,D6
00000A18  1C31 6000               1796mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A1C                          1797mm     ENDM
00000A1C                          1798mm     PRINT_CHAR D6,D5
00000A1C                          1799mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1C                 TRUE     1800mm     IFEQ DEBUG
00000A1C  1A39 00C00003           1801mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A22  0805 0002               1802mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A26  67F4                    1803mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A28  13C6 00C00007           1804mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A2E                          1805mm     ENDC
00000A2E                          1806mm 
00000A2E                 FALSE    1807mm     IFNE DEBUG
00000A2E                          1808mm     ENDC
00000A2E                          1809mm 
00000A2E                          1810mm     ENDM
00000A2E  57CA FFDA               1811m     DBEQ D2,LOOP_117
00000A32                          1812m     ENDM
00000A32  43FA 073E               1813      LEA READ(PC),A1
00000A36                          1814m     PRINT_STR A1,D5
00000A36                          1815m LOOP_122
00000A36  0C11 0000               1816m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A3A  6700 0016               1817m     BEQ EXIT_122
00000A3E                          1818mm     PRINT_CHAR (A1)+,D5
00000A3E                          1819mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A3E                 TRUE     1820mm     IFEQ DEBUG
00000A3E  1A39 00C00003           1821mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A44  0805 0002               1822mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A48  67F4                    1823mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A4A  13D9 00C00007           1824mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A50                          1825mm     ENDC
00000A50                          1826mm 
00000A50                 FALSE    1827mm     IFNE DEBUG
00000A50                          1828mm     ENDC
00000A50                          1829mm 
00000A50                          1830mm     ENDM
00000A50  60E4                    1831m     BRA LOOP_122
00000A52                          1832m EXIT_122
00000A52                          1833m     ENDM
00000A52  2E08                    1834      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A54                          1835m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A54  43FA 07BA               1836m     LEA OX(PC),A1
00000A58                          1837mm     PRINT_STR A1,D5
00000A58                          1838mm LOOP_125
00000A58  0C11 0000               1839mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A5C  6700 0016               1840mm     BEQ EXIT_125
00000A60                          1841mmm     PRINT_CHAR (A1)+,D5
00000A60                          1842mmm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A60                 TRUE     1843mmm     IFEQ DEBUG
00000A60  1A39 00C00003           1844mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A66  0805 0002               1845mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A6A  67F4                    1846mmm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A6C  13D9 00C00007           1847mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A72                          1848mmm     ENDC
00000A72                          1849mmm 
00000A72                 FALSE    1850mmm     IFNE DEBUG
00000A72                          1851mmm     ENDC
00000A72                          1852mmm 
00000A72                          1853mmm     ENDM
00000A72  60E4                    1854mm     BRA LOOP_125
00000A74                          1855mm EXIT_125
00000A74                          1856mm     ENDM
00000A74  7407                    1857m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A76                          1858m LOOP_124
00000A76                          1859mm     BIN2HEX D7,D6,A1
00000A76  43FA 0757               1860mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A7A  E99F                    1861mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A7C  1C07                    1862mm     MOVE.B D7,D6
00000A7E  0286 0000000F           1863mm     ANDI.L #$F,D6
00000A84  1C31 6000               1864mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A88                          1865mm     ENDM
00000A88                          1866mm     PRINT_CHAR D6,D5
00000A88                          1867mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A88                 TRUE     1868mm     IFEQ DEBUG
00000A88  1A39 00C00003           1869mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A8E  0805 0002               1870mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A92  67F4                    1871mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A94  13C6 00C00007           1872mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A9A                          1873mm     ENDC
00000A9A                          1874mm 
00000A9A                 FALSE    1875mm     IFNE DEBUG
00000A9A                          1876mm     ENDC
00000A9A                          1877mm 
00000A9A                          1878mm     ENDM
00000A9A  57CA FFDA               1879m     DBEQ D2,LOOP_124
00000A9E                          1880m     ENDM
00000A9E                          1881m     PRINT_CRLF D5,A4
00000A9E  49FA 076A               1882m     LEA CRLF(PC),A4
00000AA2                          1883mm     PRINT_STR A4,D5
00000AA2                          1884mm LOOP_130
00000AA2  0C14 0000               1885mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AA6  6700 0016               1886mm     BEQ EXIT_130
00000AAA                          1887mmm     PRINT_CHAR (A4)+,D5
00000AAA                          1888mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAA                 TRUE     1889mmm     IFEQ DEBUG
00000AAA  1A39 00C00003           1890mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB0  0805 0002               1891mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AB4  67F4                    1892mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AB6  13DC 00C00007           1893mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ABC                          1894mmm     ENDC
00000ABC                          1895mmm 
00000ABC                 FALSE    1896mmm     IFNE DEBUG
00000ABC                          1897mmm     ENDC
00000ABC                          1898mmm 
00000ABC                          1899mmm     ENDM
00000ABC  60E4                    1900mm     BRA LOOP_130
00000ABE                          1901mm EXIT_130
00000ABE                          1902mm     ENDM
00000ABE                          1903m     ENDM
00000ABE                          1904  
00000ABE  6000 F6BA               1905      BRA MAIN_LOOP
00000AC2                          1906  
00000AC2                          1907  G
00000AC2  2047                    1908      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AC4  3E3C 0000               1909      MOVE #0,D7                                      ; clear the now used address accumulator
00000AC8  4ED0                    1910      JMP (A0)                                        ; jump to it!
00000ACA                          1911  
00000ACA                          1912  Z
00000ACA  207C 00200000           1913      MOVE.L #RAM,A0                                  ; address of RAM
00000AD0                          1914      
00000AD0                          1915      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; write
00000AD0  7000                    1916s     MOVE.L  #0,D0
00000AD2  6000 0012               1917s     BRA _20000005
00000AD6                          1918s _20000004
00000AD6  2200                    1919          MOVE.L D0,D1                                ; progress update
00000AD8  E089                    1920          LSR.L #8,D1 
00000ADA  E089                    1921          LSR.L #8,D1
00000ADC  13C1 00E00001           1922          MOVE.B D1,DISPLAY
00000AE2                          1923  
00000AE2  20C0                    1924          MOVE.L D0,(A0)+
00000AE4                          1925      ENDF
00000AE4  5880                    1926s     ADD.L   #4,D0
00000AE6                          1927s _20000005
00000AE6  B0BC 00040000           1928s     CMP.L   #$40000,D0
00000AEC  6FE8                    1929s     BLE _20000004
00000AEE                          1930  
00000AEE  207C 00200000           1931      MOVE.L #RAM,A0                                  ; address of RAM
00000AF4                          1932  
00000AF4                          1933      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AF4  7000                    1934s     MOVE.L  #0,D0
00000AF6  6000 00A6               1935s     BRA _20000007
00000AFA                          1936s _20000006
00000AFA  2200                    1937          MOVE.L D0,D1                                ; progress update
00000AFC  E089                    1938          LSR.L #8,D1
00000AFE  E089                    1939          LSR.L #8,D1
00000B00  13C1 00E00001           1940          MOVE.B D1,DISPLAY
00000B06                          1941  
00000B06  2218                    1942          MOVE.L (A0)+,D1
00000B08                          1943  
00000B08                          1944          IF.L D0 <NE> D1 THEN
00000B08  B081                    1945s     CMP.L   D1,D0
00000B0A  6700 0090               1946s     BEQ _0000000C
00000B0E  43FA 06AD               1947              LEA RAM_ERROR(PC),A1
00000B12                          1948m             PRINT_STR A1,D1
00000B12                          1949m LOOP_132
00000B12  0C11 0000               1950m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B16  6700 0016               1951m     BEQ EXIT_132
00000B1A                          1952mm     PRINT_CHAR (A1)+,D1
00000B1A                          1953mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1A                 TRUE     1954mm     IFEQ DEBUG
00000B1A  1239 00C00003           1955mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B20  0801 0002               1956mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B24  67F4                    1957mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B26  13D9 00C00007           1958mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B2C                          1959mm     ENDC
00000B2C                          1960mm 
00000B2C                 FALSE    1961mm     IFNE DEBUG
00000B2C                          1962mm     ENDC
00000B2C                          1963mm 
00000B2C                          1964mm     ENDM
00000B2C  60E4                    1965m     BRA LOOP_132
00000B2E                          1966m EXIT_132
00000B2E                          1967m     ENDM
00000B2E  2208                    1968              MOVE.L A0,D1
00000B30  5981                    1969              SUB.L #4,D1
00000B32                          1970m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B32  43FA 06DC               1971m     LEA OX(PC),A1
00000B36                          1972mm     PRINT_STR A1,D3
00000B36                          1973mm LOOP_135
00000B36  0C11 0000               1974mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B3A  6700 0016               1975mm     BEQ EXIT_135
00000B3E                          1976mmm     PRINT_CHAR (A1)+,D3
00000B3E                          1977mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3E                 TRUE     1978mmm     IFEQ DEBUG
00000B3E  1639 00C00003           1979mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B44  0803 0002               1980mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B48  67F4                    1981mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B4A  13D9 00C00007           1982mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B50                          1983mmm     ENDC
00000B50                          1984mmm 
00000B50                 FALSE    1985mmm     IFNE DEBUG
00000B50                          1986mmm     ENDC
00000B50                          1987mmm 
00000B50                          1988mmm     ENDM
00000B50  60E4                    1989mm     BRA LOOP_135
00000B52                          1990mm EXIT_135
00000B52                          1991mm     ENDM
00000B52  7C07                    1992m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B54                          1993m LOOP_134
00000B54                          1994mm     BIN2HEX D1,D2,A1
00000B54  43FA 0679               1995mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B58  E999                    1996mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B5A  1401                    1997mm     MOVE.B D1,D2
00000B5C  0282 0000000F           1998mm     ANDI.L #$F,D2
00000B62  1431 2000               1999mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000B66                          2000mm     ENDM
00000B66                          2001mm     PRINT_CHAR D2,D3
00000B66                          2002mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B66                 TRUE     2003mm     IFEQ DEBUG
00000B66  1639 00C00003           2004mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B6C  0803 0002               2005mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B70  67F4                    2006mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B72  13C2 00C00007           2007mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B78                          2008mm     ENDC
00000B78                          2009mm 
00000B78                 FALSE    2010mm     IFNE DEBUG
00000B78                          2011mm     ENDC
00000B78                          2012mm 
00000B78                          2013mm     ENDM
00000B78  57CE FFDA               2014m     DBEQ D6,LOOP_134
00000B7C                          2015m     ENDM
00000B7C                          2016m             PRINT_CRLF D3,A1
00000B7C  43FA 068C               2017m     LEA CRLF(PC),A1
00000B80                          2018mm     PRINT_STR A1,D3
00000B80                          2019mm LOOP_140
00000B80  0C11 0000               2020mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B84  6700 0016               2021mm     BEQ EXIT_140
00000B88                          2022mmm     PRINT_CHAR (A1)+,D3
00000B88                          2023mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2024mmm     IFEQ DEBUG
00000B88  1639 00C00003           2025mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B8E  0803 0002               2026mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2027mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B94  13D9 00C00007           2028mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          2029mmm     ENDC
00000B9A                          2030mmm 
00000B9A                 FALSE    2031mmm     IFNE DEBUG
00000B9A                          2032mmm     ENDC
00000B9A                          2033mmm 
00000B9A                          2034mmm     ENDM
00000B9A  60E4                    2035mm     BRA LOOP_140
00000B9C                          2036mm EXIT_140
00000B9C                          2037mm     ENDM
00000B9C                          2038m     ENDM
00000B9C                          2039          ENDI 
00000B9C                          2040s _0000000C
00000B9C                          2041      ENDF
00000B9C  5880                    2042s     ADD.L   #4,D0
00000B9E                          2043s _20000007
00000B9E  B0BC 00040000           2044s     CMP.L   #$40000,D0
00000BA4  6F00 FF54               2045s     BLE _20000006
00000BA8                          2046  
00000BA8  6000 F5D0               2047      BRA MAIN_LOOP
00000BAC                          2048  
00000BAC                          2049  L
00000BAC  7000                    2050      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000BAE  7200                    2051      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000BB0                          2052  
00000BB0                          2053      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000BB0  343C 0000               2054s     MOVE.W  #0,D2
00000BB4  6000 0046               2055s     BRA _20000009
00000BB8                          2056s _20000008
00000BB8  E989                    2057          LSL.L #4,D1                                 ; make what we have so far more significant
00000BBA                          2058m         WAIT_CHAR D3,D4                             ; next character -> D2
00000BBA                          2059m WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BBA                 TRUE     2060m     IFEQ DEBUG
00000BBA  1839 00C00003           2061m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BC0  0804 0000               2062m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000BC4  67F4                    2063m         BEQ WAIT_FOR_READY_142                      ; NOTHING, CHECK AGAIN
00000BC6                          2064m     ENDC
00000BC6                          2065m 
00000BC6                          2066mm     READ_CHAR D3
00000BC6                 TRUE     2067mm     IFEQ DEBUG
00000BC6  1639 00C00007           2068mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000BCC                          2069mm     ENDC
00000BCC                 FALSE    2070mm     IFNE DEBUG
00000BCC                          2071mm     ENDC
00000BCC                          2072mm 
00000BCC  B63C 001B               2073mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000BD0  6700 F436               2074mm     BEQ START
00000BD4                          2075mm     ENDM
00000BD4                          2076m 
00000BD4                 TRUE     2077m     IFEQ DEBUG
00000BD4                          2078mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000BD4                          2079mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD4                 TRUE     2080mm     IFEQ DEBUG
00000BD4  1839 00C00003           2081mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BDA  0804 0002               2082mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000BDE  67F4                    2083mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000BE0  13C3 00C00007           2084mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BE6                          2085mm     ENDC
00000BE6                          2086mm 
00000BE6                 FALSE    2087mm     IFNE DEBUG
00000BE6                          2088mm     ENDC
00000BE6                          2089mm 
00000BE6                          2090mm     ENDM
00000BE6                          2091m     ENDC
00000BE6                          2092m     ENDM
00000BE6                          2093m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BE6  41FA 05F7               2094m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BEA  0403 0030               2095m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BEE  C6BC 000000FF           2096m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BF4  1630 3000               2097m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BF8                          2098m     ENDM
00000BF8  8203                    2099          OR.B D3,D1
00000BFA                          2100      ENDF
00000BFA  5242                    2101s     ADD.W   #1,D2
00000BFC                          2102s _20000009
00000BFC  B47C 0007               2103s     CMP.W   #7,D2
00000C00  6FB6                    2104s     BLE _20000008
00000C02                          2105  
00000C02  3001                    2106      MOVE.W D1,D0                                    ; extract the LSword for the length
00000C04  E089                    2107      LSR.L #8,D1                                     ; extract the MSword for the address
00000C06  E089                    2108      LSR.L #8,D1
00000C08                          2109  
00000C08                          2110m     PRINT_CRLF D2,A1
00000C08  43FA 0600               2111m     LEA CRLF(PC),A1
00000C0C                          2112mm     PRINT_STR A1,D2
00000C0C                          2113mm LOOP_147
00000C0C  0C11 0000               2114mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C10  6700 0016               2115mm     BEQ EXIT_147
00000C14                          2116mmm     PRINT_CHAR (A1)+,D2
00000C14                          2117mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C14                 TRUE     2118mmm     IFEQ DEBUG
00000C14  1439 00C00003           2119mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C1A  0802 0002               2120mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C1E  67F4                    2121mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C20  13D9 00C00007           2122mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C26                          2123mmm     ENDC
00000C26                          2124mmm 
00000C26                 FALSE    2125mmm     IFNE DEBUG
00000C26                          2126mmm     ENDC
00000C26                          2127mmm 
00000C26                          2128mmm     ENDM
00000C26  60E4                    2129mm     BRA LOOP_147
00000C28                          2130mm EXIT_147
00000C28                          2131mm     ENDM
00000C28                          2132m     ENDM
00000C28                          2133  
00000C28  2041                    2134      MOVE.L D1,A0                                    ; target address
00000C2A                          2135  
00000C2A  2247                    2136      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C2C  7E00                    2137      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C2E                          2138  
00000C2E  5089                    2139      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000C30  5180                    2140      SUB.L #8,D0
00000C32                          2141  
00000C32                          2142m     UNPROTECT
00000C32  31FC AAAA 2AAA          2143m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000C38  4E71                    2144m     NOP
00000C3A  31FC 5555 1554          2145m     MOVE.W #$5555,$1554
00000C40  4E71                    2146m     NOP
00000C42  31FC 8080 2AAA          2147m     MOVE.W #$8080,$2AAA
00000C48  4E71                    2148m     NOP
00000C4A  31FC AAAA 2AAA          2149m     MOVE.W #$AAAA,$2AAA
00000C50  4E71                    2150m     NOP
00000C52  31FC 5555 1554          2151m     MOVE.W #$5555,$1554
00000C58  4E71                    2152m     NOP
00000C5A  31FC 2020 2AAA          2153m     MOVE.W #$2020,$2AAA
00000C60                          2154m     ENDM
00000C60                          2155  
00000C60  45FA 0594               2156      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000C64                          2157m     PRINT_STR A2,D2
00000C64                          2158m LOOP_150
00000C64  0C12 0000               2159m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C68  6700 0016               2160m     BEQ EXIT_150
00000C6C                          2161mm     PRINT_CHAR (A2)+,D2
00000C6C                          2162mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6C                 TRUE     2163mm     IFEQ DEBUG
00000C6C  1439 00C00003           2164mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C72  0802 0002               2165mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C76  67F4                    2166mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C78  13DA 00C00007           2167mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C7E                          2168mm     ENDC
00000C7E                          2169mm 
00000C7E                 FALSE    2170mm     IFNE DEBUG
00000C7E                          2171mm     ENDC
00000C7E                          2172mm 
00000C7E                          2173mm     ENDM
00000C7E  60E4                    2174m     BRA LOOP_150
00000C80                          2175m EXIT_150
00000C80                          2176m     ENDM
00000C80                          2177  
00000C80  2409                    2178      MOVE.L A1,D2
00000C82                          2179m     PRINT_REG D2,D3,D4,D5,A2
00000C82  45FA 058C               2180m     LEA OX(PC),A2
00000C86                          2181mm     PRINT_STR A2,D3
00000C86                          2182mm LOOP_153
00000C86  0C12 0000               2183mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C8A  6700 0016               2184mm     BEQ EXIT_153
00000C8E                          2185mmm     PRINT_CHAR (A2)+,D3
00000C8E                          2186mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     2187mmm     IFEQ DEBUG
00000C8E  1639 00C00003           2188mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C94  0803 0002               2189mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    2190mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C9A  13DA 00C00007           2191mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA0                          2192mmm     ENDC
00000CA0                          2193mmm 
00000CA0                 FALSE    2194mmm     IFNE DEBUG
00000CA0                          2195mmm     ENDC
00000CA0                          2196mmm 
00000CA0                          2197mmm     ENDM
00000CA0  60E4                    2198mm     BRA LOOP_153
00000CA2                          2199mm EXIT_153
00000CA2                          2200mm     ENDM
00000CA2  7A07                    2201m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CA4                          2202m LOOP_152
00000CA4                          2203mm     BIN2HEX D2,D4,A2
00000CA4  45FA 0529               2204mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000CA8  E99A                    2205mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CAA  1802                    2206mm     MOVE.B D2,D4
00000CAC  0284 0000000F           2207mm     ANDI.L #$F,D4
00000CB2  1832 4000               2208mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000CB6                          2209mm     ENDM
00000CB6                          2210mm     PRINT_CHAR D4,D3
00000CB6                          2211mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2212mm     IFEQ DEBUG
00000CB6  1639 00C00003           2213mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CBC  0803 0002               2214mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2215mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CC2  13C4 00C00007           2216mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CC8                          2217mm     ENDC
00000CC8                          2218mm 
00000CC8                 FALSE    2219mm     IFNE DEBUG
00000CC8                          2220mm     ENDC
00000CC8                          2221mm 
00000CC8                          2222mm     ENDM
00000CC8  57CD FFDA               2223m     DBEQ D5,LOOP_152
00000CCC                          2224m     ENDM
00000CCC                          2225  
00000CCC  45FA 0545               2226      LEA TO(PC),A2
00000CD0                          2227m     PRINT_STR A2,D3
00000CD0                          2228m LOOP_157
00000CD0  0C12 0000               2229m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CD4  6700 0016               2230m     BEQ EXIT_157
00000CD8                          2231mm     PRINT_CHAR (A2)+,D3
00000CD8                          2232mm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD8                 TRUE     2233mm     IFEQ DEBUG
00000CD8  1639 00C00003           2234mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CDE  0803 0002               2235mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CE2  67F4                    2236mm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000CE4  13DA 00C00007           2237mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CEA                          2238mm     ENDC
00000CEA                          2239mm 
00000CEA                 FALSE    2240mm     IFNE DEBUG
00000CEA                          2241mm     ENDC
00000CEA                          2242mm 
00000CEA                          2243mm     ENDM
00000CEA  60E4                    2244m     BRA LOOP_157
00000CEC                          2245m EXIT_157
00000CEC                          2246m     ENDM
00000CEC                          2247  
00000CEC  2408                    2248      MOVE.L A0,D2
00000CEE                          2249m     PRINT_REG D2,D3,D4,D5,A2
00000CEE  45FA 0520               2250m     LEA OX(PC),A2
00000CF2                          2251mm     PRINT_STR A2,D3
00000CF2                          2252mm LOOP_160
00000CF2  0C12 0000               2253mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CF6  6700 0016               2254mm     BEQ EXIT_160
00000CFA                          2255mmm     PRINT_CHAR (A2)+,D3
00000CFA                          2256mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CFA                 TRUE     2257mmm     IFEQ DEBUG
00000CFA  1639 00C00003           2258mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D00  0803 0002               2259mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D04  67F4                    2260mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D06  13DA 00C00007           2261mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D0C                          2262mmm     ENDC
00000D0C                          2263mmm 
00000D0C                 FALSE    2264mmm     IFNE DEBUG
00000D0C                          2265mmm     ENDC
00000D0C                          2266mmm 
00000D0C                          2267mmm     ENDM
00000D0C  60E4                    2268mm     BRA LOOP_160
00000D0E                          2269mm EXIT_160
00000D0E                          2270mm     ENDM
00000D0E  7A07                    2271m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D10                          2272m LOOP_159
00000D10                          2273mm     BIN2HEX D2,D4,A2
00000D10  45FA 04BD               2274mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D14  E99A                    2275mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D16  1802                    2276mm     MOVE.B D2,D4
00000D18  0284 0000000F           2277mm     ANDI.L #$F,D4
00000D1E  1832 4000               2278mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D22                          2279mm     ENDM
00000D22                          2280mm     PRINT_CHAR D4,D3
00000D22                          2281mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D22                 TRUE     2282mm     IFEQ DEBUG
00000D22  1639 00C00003           2283mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D28  0803 0002               2284mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D2C  67F4                    2285mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D2E  13C4 00C00007           2286mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D34                          2287mm     ENDC
00000D34                          2288mm 
00000D34                 FALSE    2289mm     IFNE DEBUG
00000D34                          2290mm     ENDC
00000D34                          2291mm 
00000D34                          2292mm     ENDM
00000D34  57CD FFDA               2293m     DBEQ D5,LOOP_159
00000D38                          2294m     ENDM
00000D38                          2295  
00000D38                          2296m     PRINT_CRLF D3,A2
00000D38  45FA 04D0               2297m     LEA CRLF(PC),A2
00000D3C                          2298mm     PRINT_STR A2,D3
00000D3C                          2299mm LOOP_165
00000D3C  0C12 0000               2300mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D40  6700 0016               2301mm     BEQ EXIT_165
00000D44                          2302mmm     PRINT_CHAR (A2)+,D3
00000D44                          2303mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D44                 TRUE     2304mmm     IFEQ DEBUG
00000D44  1639 00C00003           2305mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D4A  0803 0002               2306mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D4E  67F4                    2307mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D50  13DA 00C00007           2308mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D56                          2309mmm     ENDC
00000D56                          2310mmm 
00000D56                 FALSE    2311mmm     IFNE DEBUG
00000D56                          2312mmm     ENDC
00000D56                          2313mmm 
00000D56                          2314mmm     ENDM
00000D56  60E4                    2315mm     BRA LOOP_165
00000D58                          2316mm EXIT_165
00000D58                          2317mm     ENDM
00000D58                          2318m     ENDM
00000D58                          2319  
00000D58                          2320      WHILE D0 <GT> #0 DO
00000D58                          2321s _10000014
00000D58  B07C 0000               2322s     CMP.W   #0,D0
00000D5C  6F00 001C               2323s     BLE _10000015
00000D60  5580                    2324          SUB.L #2,D0
00000D62                          2325  
00000D62  13D1 00E00001           2326          MOVE.B (A1),DISPLAY
00000D68                          2327m         PROGRAM (A1),(A0),D2
00000D68  3091                    2328m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000D6A                          2329m 
00000D6A                          2330m WAIT_FOR_COMPLETE_167
00000D6A  3410                    2331m         MOVE.W (A0),D2
00000D6C                          2332m 
00000D6C                          2333m         IF.W D2 <NE> (A1) THEN
00000D6C  B451                    2334ms     CMP.W   (A1),D2
00000D6E  6700 0004               2335ms     BEQ _0000000D
00000D72  60F6                    2336m             BRA WAIT_FOR_COMPLETE_167
00000D74                          2337m         ENDI
00000D74                          2338ms _0000000D
00000D74                          2339m         ENDM
00000D74                          2340  
00000D74  5488                    2341          ADD.L #2,A0
00000D76  5489                    2342          ADD.L #2,A1
00000D78                          2343      ENDW
00000D78  60DE                    2344s     BRA _10000014
00000D7A                          2345s _10000015
00000D7A                          2346  
00000D7A                          2347m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000D7A  31FC 0000 0000          2348m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000D80                          2349m 
00000D80                          2350m WAIT_FOR_COMPLETE_168
00000D80  3438 0000               2351m         MOVE.W $0,D2
00000D84                          2352m 
00000D84                          2353m         IF.W D2 <NE> #0 THEN
00000D84  B47C 0000               2354ms     CMP.W   #0,D2
00000D88  6700 0004               2355ms     BEQ _0000000E
00000D8C  60F2                    2356m             BRA WAIT_FOR_COMPLETE_168
00000D8E                          2357m         ENDI
00000D8E                          2358ms _0000000E
00000D8E                          2359m         ENDM
00000D8E                          2360m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D8E  31FC 0000 0002          2361m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000D94                          2362m 
00000D94                          2363m WAIT_FOR_COMPLETE_169
00000D94  3438 0002               2364m         MOVE.W $2,D2
00000D98                          2365m 
00000D98                          2366m         IF.W D2 <NE> #0 THEN
00000D98  B47C 0000               2367ms     CMP.W   #0,D2
00000D9C  6700 0004               2368ms     BEQ _0000000F
00000DA0  60F2                    2369m             BRA WAIT_FOR_COMPLETE_169
00000DA2                          2370m         ENDI
00000DA2                          2371ms _0000000F
00000DA2                          2372m         ENDM
00000DA2                          2373  
00000DA2                          2374m     PROGRAM D1, $6, D2
00000DA2  31C1 0006               2375m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000DA6                          2376m 
00000DA6                          2377m WAIT_FOR_COMPLETE_170
00000DA6  3438 0006               2378m         MOVE.W $6,D2
00000DAA                          2379m 
00000DAA                          2380m         IF.W D2 <NE> D1 THEN
00000DAA  B441                    2381ms     CMP.W   D1,D2
00000DAC  6700 0004               2382ms     BEQ _00000010
00000DB0  60F4                    2383m             BRA WAIT_FOR_COMPLETE_170
00000DB2                          2384m         ENDI
00000DB2                          2385ms _00000010
00000DB2                          2386m         ENDM
00000DB2  E089                    2387      LSR.L #8,D1
00000DB4  E089                    2388      LSR.L #8,D1
00000DB6                          2389m     PROGRAM D1, $4, D2
00000DB6  31C1 0004               2390m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000DBA                          2391m 
00000DBA                          2392m WAIT_FOR_COMPLETE_171
00000DBA  3438 0004               2393m         MOVE.W $4,D2
00000DBE                          2394m 
00000DBE                          2395m         IF.W D2 <NE> D1 THEN
00000DBE  B441                    2396ms     CMP.W   D1,D2
00000DC0  6700 0004               2397ms     BEQ _00000011
00000DC4  60F4                    2398m             BRA WAIT_FOR_COMPLETE_171
00000DC6                          2399m         ENDI
00000DC6                          2400ms _00000011
00000DC6                          2401m         ENDM
00000DC6                          2402  
00000DC6                          2403m     PROTECT
00000DC6  31FC AAAA 2AAA          2404m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000DCC  31FC 5555 1554          2405m     MOVE.W #$5555,$1554
00000DD2  31FC A0A0 2AAA          2406m     MOVE.W #$A0A0,$2AAA
00000DD8                          2407m     ENDM
00000DD8                          2408  
00000DD8  6000 F3A0               2409      BRA MAIN_LOOP
00000DDC                          2410  
00000DDC                          2411  P
00000DDC  7000                    2412      MOVE.L #0,D0                                    ; D0 will be the data to write
00000DDE                          2413  
00000DDE                          2414      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000DDE  323C 0000               2415s     MOVE.W  #0,D1
00000DE2  6000 0046               2416s     BRA _2000000B
00000DE6                          2417s _2000000A
00000DE6  E988                    2418          LSL.L #4,D0                                 ; make what we have so far more significant
00000DE8                          2419m         WAIT_CHAR D2,D3                             ; next character -> D2
00000DE8                          2420m WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE8                 TRUE     2421m     IFEQ DEBUG
00000DE8  1639 00C00003           2422m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DEE  0803 0000               2423m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000DF2  67F4                    2424m         BEQ WAIT_FOR_READY_173                      ; NOTHING, CHECK AGAIN
00000DF4                          2425m     ENDC
00000DF4                          2426m 
00000DF4                          2427mm     READ_CHAR D2
00000DF4                 TRUE     2428mm     IFEQ DEBUG
00000DF4  1439 00C00007           2429mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000DFA                          2430mm     ENDC
00000DFA                 FALSE    2431mm     IFNE DEBUG
00000DFA                          2432mm     ENDC
00000DFA                          2433mm 
00000DFA  B43C 001B               2434mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000DFE  6700 F208               2435mm     BEQ START
00000E02                          2436mm     ENDM
00000E02                          2437m 
00000E02                 TRUE     2438m     IFEQ DEBUG
00000E02                          2439mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000E02                          2440mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E02                 TRUE     2441mm     IFEQ DEBUG
00000E02  1639 00C00003           2442mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E08  0803 0002               2443mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E0C  67F4                    2444mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00000E0E  13C2 00C00007           2445mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E14                          2446mm     ENDC
00000E14                          2447mm 
00000E14                 FALSE    2448mm     IFNE DEBUG
00000E14                          2449mm     ENDC
00000E14                          2450mm 
00000E14                          2451mm     ENDM
00000E14                          2452m     ENDC
00000E14                          2453m     ENDM
00000E14                          2454m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E14  41FA 03C9               2455m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E18  0402 0030               2456m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E1C  C4BC 000000FF           2457m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E22  1430 2000               2458m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E26                          2459m     ENDM
00000E26  8002                    2460          OR.B D2,D0
00000E28                          2461      ENDF
00000E28  5241                    2462s     ADD.W   #1,D1
00000E2A                          2463s _2000000B
00000E2A  B27C 0003               2464s     CMP.W   #3,D1
00000E2E  6FB6                    2465s     BLE _2000000A
00000E30                          2466  
00000E30                          2467m     PRINT_CRLF D2,A1
00000E30  43FA 03D8               2468m     LEA CRLF(PC),A1
00000E34                          2469mm     PRINT_STR A1,D2
00000E34                          2470mm LOOP_178
00000E34  0C11 0000               2471mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E38  6700 0016               2472mm     BEQ EXIT_178
00000E3C                          2473mmm     PRINT_CHAR (A1)+,D2
00000E3C                          2474mmm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3C                 TRUE     2475mmm     IFEQ DEBUG
00000E3C  1439 00C00003           2476mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E42  0802 0002               2477mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E46  67F4                    2478mmm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000E48  13D9 00C00007           2479mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E4E                          2480mmm     ENDC
00000E4E                          2481mmm 
00000E4E                 FALSE    2482mmm     IFNE DEBUG
00000E4E                          2483mmm     ENDC
00000E4E                          2484mmm 
00000E4E                          2485mmm     ENDM
00000E4E  60E4                    2486mm     BRA LOOP_178
00000E50                          2487mm EXIT_178
00000E50                          2488mm     ENDM
00000E50                          2489m     ENDM
00000E50                          2490  
00000E50  2047                    2491      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000E52  7E00                    2492      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E54                          2493  
00000E54                          2494m     UNPROTECT
00000E54  31FC AAAA 2AAA          2495m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E5A  4E71                    2496m     NOP
00000E5C  31FC 5555 1554          2497m     MOVE.W #$5555,$1554
00000E62  4E71                    2498m     NOP
00000E64  31FC 8080 2AAA          2499m     MOVE.W #$8080,$2AAA
00000E6A  4E71                    2500m     NOP
00000E6C  31FC AAAA 2AAA          2501m     MOVE.W #$AAAA,$2AAA
00000E72  4E71                    2502m     NOP
00000E74  31FC 5555 1554          2503m     MOVE.W #$5555,$1554
00000E7A  4E71                    2504m     NOP
00000E7C  31FC 2020 2AAA          2505m     MOVE.W #$2020,$2AAA
00000E82                          2506m     ENDM
00000E82                          2507               
00000E82  45FA 0372               2508      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000E86                          2509m     PRINT_STR A2,D2
00000E86                          2510m LOOP_181
00000E86  0C12 0000               2511m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E8A  6700 0016               2512m     BEQ EXIT_181
00000E8E                          2513mm     PRINT_CHAR (A2)+,D2
00000E8E                          2514mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E8E                 TRUE     2515mm     IFEQ DEBUG
00000E8E  1439 00C00003           2516mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E94  0802 0002               2517mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E98  67F4                    2518mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000E9A  13DA 00C00007           2519mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EA0                          2520mm     ENDC
00000EA0                          2521mm 
00000EA0                 FALSE    2522mm     IFNE DEBUG
00000EA0                          2523mm     ENDC
00000EA0                          2524mm 
00000EA0                          2525mm     ENDM
00000EA0  60E4                    2526m     BRA LOOP_181
00000EA2                          2527m EXIT_181
00000EA2                          2528m     ENDM
00000EA2                          2529  
00000EA2                          2530m     PRINT_CHAR '#',D3
00000EA2                          2531m WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA2                 TRUE     2532m     IFEQ DEBUG
00000EA2  1639 00C00003           2533m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EA8  0803 0002               2534m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EAC  67F4                    2535m         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000EAE  13F8 0023 00C00007      2536m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000EB6                          2537m     ENDC
00000EB6                          2538m 
00000EB6                 FALSE    2539m     IFNE DEBUG
00000EB6                          2540m     ENDC
00000EB6                          2541m 
00000EB6                          2542m     ENDM
00000EB6                          2543m     PRINT_REG D0,D3,D4,D5,A2
00000EB6  45FA 0358               2544m     LEA OX(PC),A2
00000EBA                          2545mm     PRINT_STR A2,D3
00000EBA                          2546mm LOOP_185
00000EBA  0C12 0000               2547mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EBE  6700 0016               2548mm     BEQ EXIT_185
00000EC2                          2549mmm     PRINT_CHAR (A2)+,D3
00000EC2                          2550mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC2                 TRUE     2551mmm     IFEQ DEBUG
00000EC2  1639 00C00003           2552mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EC8  0803 0002               2553mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ECC  67F4                    2554mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00000ECE  13DA 00C00007           2555mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ED4                          2556mmm     ENDC
00000ED4                          2557mmm 
00000ED4                 FALSE    2558mmm     IFNE DEBUG
00000ED4                          2559mmm     ENDC
00000ED4                          2560mmm 
00000ED4                          2561mmm     ENDM
00000ED4  60E4                    2562mm     BRA LOOP_185
00000ED6                          2563mm EXIT_185
00000ED6                          2564mm     ENDM
00000ED6  7A07                    2565m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000ED8                          2566m LOOP_184
00000ED8                          2567mm     BIN2HEX D0,D4,A2
00000ED8  45FA 02F5               2568mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EDC  E998                    2569mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EDE  1800                    2570mm     MOVE.B D0,D4
00000EE0  0284 0000000F           2571mm     ANDI.L #$F,D4
00000EE6  1832 4000               2572mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EEA                          2573mm     ENDM
00000EEA                          2574mm     PRINT_CHAR D4,D3
00000EEA                          2575mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEA                 TRUE     2576mm     IFEQ DEBUG
00000EEA  1639 00C00003           2577mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EF0  0803 0002               2578mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EF4  67F4                    2579mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000EF6  13C4 00C00007           2580mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EFC                          2581mm     ENDC
00000EFC                          2582mm 
00000EFC                 FALSE    2583mm     IFNE DEBUG
00000EFC                          2584mm     ENDC
00000EFC                          2585mm 
00000EFC                          2586mm     ENDM
00000EFC  57CD FFDA               2587m     DBEQ D5,LOOP_184
00000F00                          2588m     ENDM
00000F00                          2589  
00000F00  45FA 0311               2590      LEA TO(PC),A2
00000F04                          2591m     PRINT_STR A2,D3
00000F04                          2592m LOOP_189
00000F04  0C12 0000               2593m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F08  6700 0016               2594m     BEQ EXIT_189
00000F0C                          2595mm     PRINT_CHAR (A2)+,D3
00000F0C                          2596mm WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F0C                 TRUE     2597mm     IFEQ DEBUG
00000F0C  1639 00C00003           2598mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F12  0803 0002               2599mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F16  67F4                    2600mm         BEQ WAIT_FOR_READY_190                      ; NO SPACE, CHECK AGAIN
00000F18  13DA 00C00007           2601mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F1E                          2602mm     ENDC
00000F1E                          2603mm 
00000F1E                 FALSE    2604mm     IFNE DEBUG
00000F1E                          2605mm     ENDC
00000F1E                          2606mm 
00000F1E                          2607mm     ENDM
00000F1E  60E4                    2608m     BRA LOOP_189
00000F20                          2609m EXIT_189
00000F20                          2610m     ENDM
00000F20                          2611  
00000F20  2408                    2612      MOVE.L A0,D2
00000F22                          2613m     PRINT_REG D2,D3,D4,D5,A2
00000F22  45FA 02EC               2614m     LEA OX(PC),A2
00000F26                          2615mm     PRINT_STR A2,D3
00000F26                          2616mm LOOP_192
00000F26  0C12 0000               2617mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F2A  6700 0016               2618mm     BEQ EXIT_192
00000F2E                          2619mmm     PRINT_CHAR (A2)+,D3
00000F2E                          2620mmm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F2E                 TRUE     2621mmm     IFEQ DEBUG
00000F2E  1639 00C00003           2622mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F34  0803 0002               2623mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F38  67F4                    2624mmm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F3A  13DA 00C00007           2625mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F40                          2626mmm     ENDC
00000F40                          2627mmm 
00000F40                 FALSE    2628mmm     IFNE DEBUG
00000F40                          2629mmm     ENDC
00000F40                          2630mmm 
00000F40                          2631mmm     ENDM
00000F40  60E4                    2632mm     BRA LOOP_192
00000F42                          2633mm EXIT_192
00000F42                          2634mm     ENDM
00000F42  7A07                    2635m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F44                          2636m LOOP_191
00000F44                          2637mm     BIN2HEX D2,D4,A2
00000F44  45FA 0289               2638mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F48  E99A                    2639mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F4A  1802                    2640mm     MOVE.B D2,D4
00000F4C  0284 0000000F           2641mm     ANDI.L #$F,D4
00000F52  1832 4000               2642mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F56                          2643mm     ENDM
00000F56                          2644mm     PRINT_CHAR D4,D3
00000F56                          2645mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F56                 TRUE     2646mm     IFEQ DEBUG
00000F56  1639 00C00003           2647mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5C  0803 0002               2648mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F60  67F4                    2649mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F62  13C4 00C00007           2650mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F68                          2651mm     ENDC
00000F68                          2652mm 
00000F68                 FALSE    2653mm     IFNE DEBUG
00000F68                          2654mm     ENDC
00000F68                          2655mm 
00000F68                          2656mm     ENDM
00000F68  57CD FFDA               2657m     DBEQ D5,LOOP_191
00000F6C                          2658m     ENDM
00000F6C                          2659  
00000F6C                          2660m     PRINT_CRLF D3,A2
00000F6C  45FA 029C               2661m     LEA CRLF(PC),A2
00000F70                          2662mm     PRINT_STR A2,D3
00000F70                          2663mm LOOP_197
00000F70  0C12 0000               2664mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F74  6700 0016               2665mm     BEQ EXIT_197
00000F78                          2666mmm     PRINT_CHAR (A2)+,D3
00000F78                          2667mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F78                 TRUE     2668mmm     IFEQ DEBUG
00000F78  1639 00C00003           2669mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F7E  0803 0002               2670mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F82  67F4                    2671mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000F84  13DA 00C00007           2672mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8A                          2673mmm     ENDC
00000F8A                          2674mmm 
00000F8A                 FALSE    2675mmm     IFNE DEBUG
00000F8A                          2676mmm     ENDC
00000F8A                          2677mmm 
00000F8A                          2678mmm     ENDM
00000F8A  60E4                    2679mm     BRA LOOP_197
00000F8C                          2680mm EXIT_197
00000F8C                          2681mm     ENDM
00000F8C                          2682m     ENDM
00000F8C                          2683  
00000F8C                          2684m     PROGRAM D0,(A0),D2
00000F8C  3080                    2685m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F8E                          2686m 
00000F8E                          2687m WAIT_FOR_COMPLETE_199
00000F8E  3410                    2688m         MOVE.W (A0),D2
00000F90                          2689m 
00000F90                          2690m         IF.W D2 <NE> D0 THEN
00000F90  B440                    2691ms     CMP.W   D0,D2
00000F92  6700 0004               2692ms     BEQ _00000012
00000F96  60F6                    2693m             BRA WAIT_FOR_COMPLETE_199
00000F98                          2694m         ENDI
00000F98                          2695ms _00000012
00000F98                          2696m         ENDM
00000F98                          2697  
00000F98                          2698m     PROTECT
00000F98  31FC AAAA 2AAA          2699m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F9E  31FC 5555 1554          2700m     MOVE.W #$5555,$1554
00000FA4  31FC A0A0 2AAA          2701m     MOVE.W #$A0A0,$2AAA
00000FAA                          2702m     ENDM
00000FAA                          2703  
00000FAA  6000 F1CE               2704      BRA MAIN_LOOP
00000FAE                          2705      
00000FAE                          2706  M
00000FAE  7000                    2707      MOVE.L #0,D0                                        ; D0 will be the length to read            
00000FB0  7200                    2708      MOVE.L #0,D1                                        ; D1 will be the address to read 
00000FB2                          2709  
00000FB2                          2710      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000FB2  343C 0000               2711s     MOVE.W  #0,D2
00000FB6  6000 0046               2712s     BRA _2000000D
00000FBA                          2713s _2000000C
00000FBA  E989                    2714          LSL.L #4,D1                                     ; make what we have so far more significant
00000FBC                          2715m         WAIT_CHAR D3,D4                                 ; next character -> D2
00000FBC                          2716m WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FBC                 TRUE     2717m     IFEQ DEBUG
00000FBC  1839 00C00003           2718m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000FC2  0804 0000               2719m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000FC6  67F4                    2720m         BEQ WAIT_FOR_READY_201                      ; NOTHING, CHECK AGAIN
00000FC8                          2721m     ENDC
00000FC8                          2722m 
00000FC8                          2723mm     READ_CHAR D3
00000FC8                 TRUE     2724mm     IFEQ DEBUG
00000FC8  1639 00C00007           2725mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000FCE                          2726mm     ENDC
00000FCE                 FALSE    2727mm     IFNE DEBUG
00000FCE                          2728mm     ENDC
00000FCE                          2729mm 
00000FCE  B63C 001B               2730mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000FD2  6700 F034               2731mm     BEQ START
00000FD6                          2732mm     ENDM
00000FD6                          2733m 
00000FD6                 TRUE     2734m     IFEQ DEBUG
00000FD6                          2735mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000FD6                          2736mm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD6                 TRUE     2737mm     IFEQ DEBUG
00000FD6  1839 00C00003           2738mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000FDC  0804 0002               2739mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000FE0  67F4                    2740mm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00000FE2  13C3 00C00007           2741mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FE8                          2742mm     ENDC
00000FE8                          2743mm 
00000FE8                 FALSE    2744mm     IFNE DEBUG
00000FE8                          2745mm     ENDC
00000FE8                          2746mm 
00000FE8                          2747mm     ENDM
00000FE8                          2748m     ENDC
00000FE8                          2749m     ENDM
00000FE8                          2750m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00000FE8  41FA 01F5               2751m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000FEC  0403 0030               2752m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FF0  C6BC 000000FF           2753m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000FF6  1630 3000               2754m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000FFA                          2755m     ENDM
00000FFA  8203                    2756          OR.B D3,D1
00000FFC                          2757      ENDF
00000FFC  5242                    2758s     ADD.W   #1,D2
00000FFE                          2759s _2000000D
00000FFE  B47C 0007               2760s     CMP.W   #7,D2
00001002  6FB6                    2761s     BLE _2000000C
00001004                          2762m     PRINT_CRLF D2,A1
00001004  43FA 0204               2763m     LEA CRLF(PC),A1
00001008                          2764mm     PRINT_STR A1,D2
00001008                          2765mm LOOP_206
00001008  0C11 0000               2766mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000100C  6700 0016               2767mm     BEQ EXIT_206
00001010                          2768mmm     PRINT_CHAR (A1)+,D2
00001010                          2769mmm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001010                 TRUE     2770mmm     IFEQ DEBUG
00001010  1439 00C00003           2771mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001016  0802 0002               2772mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000101A  67F4                    2773mmm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
0000101C  13D9 00C00007           2774mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001022                          2775mmm     ENDC
00001022                          2776mmm 
00001022                 FALSE    2777mmm     IFNE DEBUG
00001022                          2778mmm     ENDC
00001022                          2779mmm 
00001022                          2780mmm     ENDM
00001022  60E4                    2781mm     BRA LOOP_206
00001024                          2782mm EXIT_206
00001024                          2783mm     ENDM
00001024                          2784m     ENDM
00001024                          2785  
00001024  3001                    2786      MOVE.W D1,D0                                        ; extract the LSword for the length
00001026  E089                    2787      LSR.L #8,D1                                         ; extract the MSword for the address
00001028  E089                    2788      LSR.L #8,D1
0000102A                          2789  
0000102A  2241                    2790      MOVE.L D1,A1
0000102C                          2791      
0000102C  2047                    2792      MOVE.L D7,A0                                        ; address accumulator -> target address register
0000102E  7E00                    2793      MOVE.L #0,D7                                        ; clear the now used address accumulator
00001030                          2794  
00001030                          2795      WHILE D0 <GT> #0 DO
00001030                          2796s _10000016
00001030  B07C 0000               2797s     CMP.W   #0,D0
00001034  6F00 000E               2798s     BLE _10000017
00001038  5580                    2799          SUB.L #2,D0
0000103A                          2800  
0000103A  13D1 00E00001           2801          MOVE.B (A1),DISPLAY
00001040  30D9                    2802          MOVE.W (A1)+,(A0)+
00001042                          2803      ENDW
00001042  60EC                    2804s     BRA _10000016
00001044                          2805s _10000017
00001044                          2806      
00001044  2E01                    2807      MOVE.L D1,D7                                        ; put the start address in the address accumulator
00001046                          2808  
00001046  6000 F132               2809      BRA MAIN_LOOP
0000104A                          2810  
0000104A                          2811  
0000104A                          2812  HEX_DIGIT
0000104A  E98F                    2813      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
0000104C                          2814m     HEX2BIN D2,D2,A0
0000104C  41FA 0191               2815m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001050  0402 0030               2816m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001054  C4BC 000000FF           2817m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000105A  1430 2000               2818m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000105E                          2819m     ENDM
0000105E  8E02                    2820      OR.B D2,D7  
00001060  6000 F138               2821      BRA GET_INPUT
00001064                          2822  
00001064  FFFF FFFF               2823      SIMHALT                                             ; halt simulator
00001068                          2824  
00001068                          2825  ; strings
00001068= 50 72 65 73 73 20 ...   2826  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
0000107B= 3F 09 09 09 68 65 ...   2827  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00001085= 5B 76 5D 09 09 09 ...   2828          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001094= 78 78 78 78 78 78 ...   2829          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
000010AC= 78 78 78 78 78 78 ...   2830          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
000010CC= 5B 73 5D 09 09 09 ...   2831          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
000010E6= 78 78 78 78 78 78 ...   2832          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000010F7= 5B 7A 5D 09 09 09 ...   2833          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001109= 78 78 78 78 78 78 ...   2834          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
0000112A= 78 78 78 78 78 78 ...   2835          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001149= 78 78 78 78 78 78 ...   2836          DC.B 'xxxxxxxx[m]xxxx',TAB,TAB,'monitor to RAM',CR,LF,NULL
0000116B= 48 75 68 3F 0D 0A 00    2837  HUH  DC.B 'Huh?',CR,LF,NULL
00001172= 20 53 20 72 65 63 ...   2838  READ    DC.B ' S records read, start address = ',NULL
00001194= 57 3A 20 55 6E 6B ...   2839  UNREC   DC.B 'W: Unknown Srec type: ',NULL
000011AB= 57 3A 20 43 53 20 ...   2840  CS_FAILURE  DC.B 'W: CS failure at ',NULL
000011BD= 57 3A 20 52 41 4D ...   2841  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
000011CF= 30 31 32 33 34 35 ...   2842  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000011DF= 00 01 02 03 04 05 ...   2843  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000011F6= 4C 6F 61 64 69 6E ...   2844  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
0000120A= 0D 0A 00                2845  CRLF    DC.B CR,LF,NULL
0000120D= 3E 20 00                2846  PROMPT  DC.B '> ',NULL
00001210= 30 78 00                2847  ox      DC.B '0x',NULL
00001213= 20 2D 3E 20 00          2848  to      DC.B ' -> ',NULL
00001218= 4D 44 46 2D 6D 6F ...   2849  VERSION DC.B 'MDF-mon V1.70 (11/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001235                          2850  
00001235                          2851      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         11CF
CONTINUE_100        8DE
CONTINUE_41         3BA
CONTINUE_44         40A
CONTINUE_48         460
CONTINUE_56         514
CONTINUE_61         586
CONTINUE_66         602
CONTINUE_71         680
CONTINUE_76         708
CONTINUE_81         77A
CONTINUE_86         7EC
CR                  D
CRLF                120A
CS_FAILURE          11AB
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       9E8
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_105            946
EXIT_107            96E
EXIT_110            98E
EXIT_115            9D8
EXIT_118            A08
EXIT_12             170
EXIT_122            A52
EXIT_125            A74
EXIT_130            ABE
EXIT_132            B2E
EXIT_135            B52
EXIT_14             19A
EXIT_140            B9C
EXIT_147            C28
EXIT_150            C80
EXIT_153            CA2
EXIT_157            CEC
EXIT_160            D0E
EXIT_165            D58
EXIT_178            E50
EXIT_181            EA2
EXIT_185            ED6
EXIT_189            F20
EXIT_192            F42
EXIT_197            F8C
EXIT_20             22E
EXIT_206            1024
EXIT_22             27E
EXIT_24             2AA
EXIT_27             2D4
EXIT_32             31E
EXIT_39             392
EXIT_5              110
EXIT_53             4D0
EXIT_7              130
EXIT_9              150
EXIT_91             85E
EXIT_93             87E
EXIT_97             8B0
G                   AC2
GET_INPUT           19A
H                   282
HELP                107B
HELPPROMPT          1068
HEX2BIN             10B
HEX2BIN_LUT         11DF
HEX_DIGIT           104A
HUH                 116B
L                   BAC
LF                  A
LOADING             11F6
LOOP_105            92A
LOOP_107            952
LOOP_109            990
LOOP_110            972
LOOP_115            9BC
LOOP_117            A0A
LOOP_118            9EC
LOOP_12             154
LOOP_122            A36
LOOP_124            A76
LOOP_125            A58
LOOP_130            AA2
LOOP_132            B12
LOOP_134            B54
LOOP_135            B36
LOOP_14             17E
LOOP_140            B80
LOOP_147            C0C
LOOP_150            C64
LOOP_152            CA4
LOOP_153            C86
LOOP_157            CD0
LOOP_159            D10
LOOP_160            CF2
LOOP_165            D3C
LOOP_178            E34
LOOP_181            E86
LOOP_184            ED8
LOOP_185            EBA
LOOP_189            F04
LOOP_191            F44
LOOP_192            F26
LOOP_197            F70
LOOP_20             212
LOOP_206            1008
LOOP_22             262
LOOP_24             28E
LOOP_26             2D6
LOOP_27             2B8
LOOP_32             302
LOOP_39             376
LOOP_5              F4
LOOP_53             4B4
LOOP_7              114
LOOP_9              134
LOOP_91             842
LOOP_93             862
LOOP_97             894
M                   FAE
MAIN_LOOP           17A
NULL                0
OX                  1210
P                   DDC
PRINTSTR            28E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              120D
PROTECT             A40
R                   2AE
RAM                 200000
RAM_ERROR           11BD
READ                1172
READ_CHAR           62D
READ_DATA_TO_POKE   326
RESET               4
ROM                 0
S                   396
STACK               0
START               8
TAB                 9
TO                  1213
UNPROTECT           979
UNREC               1194
V                   28A
VERSION             1218
W                   322
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_167  D6A
WAIT_FOR_COMPLETE_168  D80
WAIT_FOR_COMPLETE_169  D94
WAIT_FOR_COMPLETE_170  DA6
WAIT_FOR_COMPLETE_171  DBA
WAIT_FOR_COMPLETE_199  F8E
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8C2
WAIT_FOR_READY_102  8F6
WAIT_FOR_READY_106  932
WAIT_FOR_READY_108  95A
WAIT_FOR_READY_111  97A
WAIT_FOR_READY_113  9A2
WAIT_FOR_READY_116  9C4
WAIT_FOR_READY_119  9F4
WAIT_FOR_READY_121  A1C
WAIT_FOR_READY_123  A3E
WAIT_FOR_READY_126  A60
WAIT_FOR_READY_128  A88
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  AAA
WAIT_FOR_READY_133  B1A
WAIT_FOR_READY_136  B3E
WAIT_FOR_READY_138  B66
WAIT_FOR_READY_141  B88
WAIT_FOR_READY_142  BBA
WAIT_FOR_READY_144  BD4
WAIT_FOR_READY_148  C14
WAIT_FOR_READY_15   186
WAIT_FOR_READY_151  C6C
WAIT_FOR_READY_154  C8E
WAIT_FOR_READY_156  CB6
WAIT_FOR_READY_158  CD8
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  CFA
WAIT_FOR_READY_163  D22
WAIT_FOR_READY_166  D44
WAIT_FOR_READY_173  DE8
WAIT_FOR_READY_175  E02
WAIT_FOR_READY_179  E3C
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_182  E8E
WAIT_FOR_READY_183  EA2
WAIT_FOR_READY_186  EC2
WAIT_FOR_READY_188  EEA
WAIT_FOR_READY_190  F0C
WAIT_FOR_READY_193  F2E
WAIT_FOR_READY_195  F56
WAIT_FOR_READY_198  F78
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_201  FBC
WAIT_FOR_READY_203  FD6
WAIT_FOR_READY_207  1010
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_23   26A
WAIT_FOR_READY_25   296
WAIT_FOR_READY_28   2C0
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2E8
WAIT_FOR_READY_33   30A
WAIT_FOR_READY_34   328
WAIT_FOR_READY_36   342
WAIT_FOR_READY_40   37E
WAIT_FOR_READY_41   39E
WAIT_FOR_READY_43   3D8
WAIT_FOR_READY_44   3EE
WAIT_FOR_READY_46   422
WAIT_FOR_READY_48   444
WAIT_FOR_READY_50   478
WAIT_FOR_READY_54   4BC
WAIT_FOR_READY_56   4F8
WAIT_FOR_READY_58   52C
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   56A
WAIT_FOR_READY_63   59E
WAIT_FOR_READY_66   5E6
WAIT_FOR_READY_68   61A
WAIT_FOR_READY_71   664
WAIT_FOR_READY_73   698
WAIT_FOR_READY_76   6EC
WAIT_FOR_READY_78   720
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   75E
WAIT_FOR_READY_83   792
WAIT_FOR_READY_86   7D0
WAIT_FOR_READY_88   804
WAIT_FOR_READY_92   84A
WAIT_FOR_READY_94   86A
WAIT_FOR_READY_95   87E
WAIT_FOR_READY_98   89C
WAIT_FOR_SRECORD    39E
Z                   ACA
_00000000           1DA
_00000001           1EE
_00000002           4D8
_00000003           8B4
_00000004           4E6
_00000005           6D4
_00000006           64A
_00000007           8B4
_00000008           83E
_00000009           8B4
_0000000A           9DC
_0000000B           9E8
_0000000C           B9C
_0000000D           D74
_0000000E           D8E
_0000000F           DA2
_00000010           DB2
_00000011           DC6
_00000012           F98
_10000000           43A
_10000001           4A2
_10000002           4EE
_10000003           556
_10000004           560
_10000005           5C8
_10000006           5DC
_10000007           644
_10000008           64E
_10000009           6CE
_1000000A           65A
_1000000B           6C2
_1000000C           6E2
_1000000D           74A
_1000000E           754
_1000000F           7BC
_10000010           7C6
_10000011           82E
_10000012           8B8
_10000013           920
_10000014           D58
_10000015           D7A
_10000016           1030
_10000017           1044
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           AD6
_20000005           AE6
_20000006           AFA
_20000007           B9E
_20000008           BB8
_20000009           BFC
_2000000A           DE6
_2000000B           E2A
_2000000C           FBA
_2000000D           FFE
