00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 14:06:35

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Replace JMP -> BRA, THEN.L
00000000                             9  ; revisit register usage in S record download
00000000                            10  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            11  ; revisit use of bytes and longs
00000000                            12  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            13  ; Review for any other savings
00000000                            14  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            15  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            16  
00000000                            17  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; fix the reset vector so that it jumps to the start
00000000                            20  ; implement backspace
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  ; fix being able to enter random chars when W'ing
00000000                            23  ; ram check at startup?  Not sure if this is a good idea!
00000000                            24  ; byte W?
00000000                            25  
00000000                            26      ORG  $0
00000000                            27      ;ORG  $200000
00000000                            28  
00000000  =00000000                 29  DEBUG               EQU 0
00000000                            30  
00000000                            31  ; constants
00000000  =00000000                 32  ROM                 EQU $0
00000000  =00200000                 33  RAM                 EQU $200000
00000000                            34     
00000000  =00C00000                 35  DUART_BASE          EQU $C00000
00000000  =00000000                 36  DUART_MRA_          EQU $0
00000000  =00000001                 37  DUART_CSRA_         EQU $1
00000000  =00000001                 38  DUART_SRA_          EQU $1
00000000  =00000002                 39  DUART_CRA_          EQU $2
00000000  =00000003                 40  DUART_TXA_          EQU $3
00000000  =00000003                 41  DUART_RXA_          EQU $3
00000000  =00000004                 42  DUART_ACR_          EQU $4
00000000  =00000005                 43  DUART_IMR_          EQU $5
00000000  =00000008                 44  DUART_MRB_          EQU $8
00000000  =00000009                 45  DUART_CSRB_         EQU $9
00000000  =00000009                 46  DUART_SRB_          EQU $9
00000000  =0000000A                 47  DUART_CRB_          EQU $A
00000000  =0000000B                 48  DUART_TXB_          EQU $B
00000000  =0000000B                 49  DUART_RXB_          EQU $B
00000000  =0000000C                 50  DUART_IVR_          EQU $C
00000000  =0000000D                 51  DUART_OPCR_         EQU $D
00000000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00000000                            54  
00000000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            61  
00000000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            68  
00000000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            75  
00000000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 77  DISPLAY_            EQU $0
00000000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            79  
00000000                            80  ; macros
00000000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            82  ; the input register is changed during the process
00000000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            84  BIN2HEX MACRO
00000000                            85      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            86      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            87      MOVE.B \1,\2
00000000                            88      ANDI.L #$F,\2
00000000                            89      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            90      ENDM
00000000                            91  
00000000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            93  ; the input register is changed during the process
00000000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            95  HEX2BIN MACRO
00000000                            96      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            97      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            98      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                            99      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                           100      ENDM
00000000                           101  
00000000                           102  ; send a single char to the serial port
00000000                           103  ; \1 = char to send, \2 = data register to use for status poll
00000000                           104  ; will stamp on D0 and D1 in debug mode
00000000                           105  PRINT_CHAR MACRO
00000000                           106  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           107      IFEQ DEBUG
00000000                           108          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           109          BTST #2,\2                              ; check for space to send
00000000                           110          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           111          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           112      ENDC
00000000                           113      
00000000                           114      IFNE DEBUG
00000000                           115          MOVE.B \1,D1
00000000                           116          MOVE.L #6,D0   
00000000                           117          TRAP #15                                ; write to terminal in simulator
00000000                           118      ENDC
00000000                           119  
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send CR,LF to the serial port
00000000                           123  ; \1 = data register to use for status poll
00000000                           124  PRINT_CRLF MACRO
00000000                           125      PRINT_CHAR #13,\1                           ; CR
00000000                           126      PRINT_CHAR #10,\1                           ; LF
00000000                           127      ENDM
00000000                           128  
00000000                           129  ; send C-style, zero terminated string to the serial port
00000000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           131  PRINT_STR MACRO
00000000                           132  LOOP\@
00000000                           133      CMP.B #0,(\1)                               ; 0 -> done
00000000                           134      BEQ EXIT\@
00000000                           135      PRINT_CHAR (\1)+,\2
00000000                           136      BRA LOOP\@
00000000                           137  EXIT\@
00000000                           138      ENDM
00000000                           139    
00000000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           142  PRINT_REG MACRO
00000000                           143      PRINT_CHAR #'0',\2                          ;0x header
00000000                           144      PRINT_CHAR #'x',\2
00000000                           145      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           146  LOOP\@
00000000                           147      BIN2HEX \1,\3,\5
00000000                           148      PRINT_CHAR \3,\2
00000000                           149      DBEQ \4,LOOP\@
00000000                           150      ENDM
00000000                           151    
00000000                           152  ; wait for a char from the serial port
00000000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           154  ; will stamp on D0 and D1 in debug mode
00000000                           155  WAIT_CHAR MACRO
00000000                           156  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           157  
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                        ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           195      BTST #0,\1                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           201      BTST #0,\1                                  ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; read two hex digits from the download serial port and convert to a byte
00000000                           210  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           211  DOWNLOAD_BYTE MACRO
00000000                           212      MOVE.B #2,\4
00000000                           213      WHILE.B \4 <GT> 0 DO
00000000                           214          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           215          DOWNLOAD \1
00000000                           216          PRINT_CHAR \1,\3
00000000                           217          HEX2BIN \1,\1,\6
00000000                           218          OR.B \1,\2
00000000                           219          SUB.B #1,\4
00000000                           220      ENDW
00000000                           221      
00000000                           222      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00000000                           223      MOVE.B \2,\1
00000000                           224      ADD.L \2,\5
00000000                           225  
00000000                           226      ENDM
00000000                           227      
00000000                           228  
00000000                           229  ; register catalogue
00000000                           230  ; D0 - used for simulator I/O
00000000                           231  ; D1 - used for simulator I/O
00000000                           232  ; D2 - read character
00000000                           233  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           234  ; D4 - count of S records read
00000000                           235  ; D5 - data to write / data read / byte count for S record load
00000000                           236  ; D6 - working register used in R/W and download
00000000                           237  ; D7 - address accumulator / reset by download
00000000                           238  ; A0 - address of string to print 
00000000                           239  
00000000                           240  ; start vector
00000000= 00000000                 241  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 242  RESET    DC.L START                             ; RESET
00000008                           243      
00000008                           244  ; start of program  
00000008                           245  START
00000008  13FC 0000 00E00001       246      MOVE.B #0,DISPLAY
00000010                           247  
00000010                           248  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       249      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       250      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     251      NOP
00000022  13FC 0040 00C00005       252      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     253      NOP
0000002C  13FC 0030 00C00005       254      MOVE.B #$30,DUART_CRA
00000034  4E71                     255      NOP
00000036  13FC 0020 00C00005       256      MOVE.B #$20,DUART_CRA
0000003E  4E71                     257      NOP
00000040  13FC 0010 00C00005       258      MOVE.B #$10,DUART_CRA   
00000048                           259  
00000048  13FC 000A 00C00015       260      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       261      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     262      NOP
0000005A  13FC 0040 00C00015       263      MOVE.B #$40,DUART_CRB           
00000062  4E71                     264      NOP
00000064  13FC 0030 00C00015       265      MOVE.B #$30,DUART_CRB
0000006C  4E71                     266      NOP
0000006E  13FC 0020 00C00015       267      MOVE.B #$20,DUART_CRB
00000076  4E71                     268      NOP
00000078  13FC 0010 00C00015       269      MOVE.B #$10,DUART_CRB   
00000080                           270  
00000080                           271  ;initialise UART
00000080  13FC 0000 00C00009       272      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       273      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       274      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           275  
00000098                           276  ; channel A
00000098  13FC 0013 00C00001       277      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       278      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       279      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       280      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           281  
000000B8                           282  ; channel B
000000B8  13FC 0013 00C00011       283      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       284      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       285      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       286      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           287  
000000D8                           288m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           289m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      290m     IFEQ DEBUG
000000D8  1639 00C00003            291m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                292m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     293m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       294m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           295m     ENDC
000000EC                           296m     
000000EC                 FALSE     297m     IFNE DEBUG
000000EC                           298m     ENDC
000000EC                           299m 
000000EC                           300m     ENDM
000000EC                           301  
000000EC  13FC 0001 00E00001       302      MOVE.B #1,DISPLAY
000000F4                           303         
000000F4                           304m     PRINT_CRLF D3
000000F4                           305mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           306mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      307mm     IFEQ DEBUG
000000F4  1639 00C00003            308mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                309mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     310mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       311mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           312mm     ENDC
00000108                           313mm     
00000108                 FALSE     314mm     IFNE DEBUG
00000108                           315mm     ENDC
00000108                           316mm 
00000108                           317mm     ENDM
00000108                           318mm     PRINT_CHAR #10,D3                           ; LF
00000108                           319mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      320mm     IFEQ DEBUG
00000108  1639 00C00003            321mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                322mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     323mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       324mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           325mm     ENDC
0000011C                           326mm     
0000011C                 FALSE     327mm     IFNE DEBUG
0000011C                           328mm     ENDC
0000011C                           329mm 
0000011C                           330mm     ENDM
0000011C                           331m     ENDM
0000011C                           332  
0000011C  41F9 00000EAE            333      LEA VERSION,A0
00000122                           334m     PRINT_STR A0,D3
00000122                           335m LOOP_5
00000122  0C10 0000                336m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0016                337m     BEQ EXIT_5
0000012A                           338mm     PRINT_CHAR (A0)+,D3
0000012A                           339mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      340mm     IFEQ DEBUG
0000012A  1639 00C00003            341mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                342mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     343mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            344mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           345mm     ENDC
0000013C                           346mm     
0000013C                 FALSE     347mm     IFNE DEBUG
0000013C                           348mm     ENDC
0000013C                           349mm 
0000013C                           350mm     ENDM
0000013C  60E4                     351m     BRA LOOP_5
0000013E                           352m EXIT_5
0000013E                           353m     ENDM
0000013E                           354m     PRINT_CRLF D3
0000013E                           355mm     PRINT_CHAR #13,D3                           ; CR
0000013E                           356mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      357mm     IFEQ DEBUG
0000013E  1639 00C00003            358mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                359mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     360mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014A  13FC 000D 00C00007       361mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000152                           362mm     ENDC
00000152                           363mm     
00000152                 FALSE     364mm     IFNE DEBUG
00000152                           365mm     ENDC
00000152                           366mm 
00000152                           367mm     ENDM
00000152                           368mm     PRINT_CHAR #10,D3                           ; LF
00000152                           369mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      370mm     IFEQ DEBUG
00000152  1639 00C00003            371mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000158  0803 0002                372mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015C  67F4                     373mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0000015E  13FC 000A 00C00007       374mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000166                           375mm     ENDC
00000166                           376mm     
00000166                 FALSE     377mm     IFNE DEBUG
00000166                           378mm     ENDC
00000166                           379mm 
00000166                           380mm     ENDM
00000166                           381m     ENDM
00000166                           382m     PRINT_CHAR #7,D3
00000166                           383m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000166                 TRUE      384m     IFEQ DEBUG
00000166  1639 00C00003            385m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016C  0803 0002                386m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000170  67F4                     387m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000172  13FC 0007 00C00007       388m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017A                           389m     ENDC
0000017A                           390m     
0000017A                 FALSE     391m     IFNE DEBUG
0000017A                           392m     ENDC
0000017A                           393m 
0000017A                           394m     ENDM
0000017A                           395  
0000017A  7E00                     396      MOVE.L #0,D7                                ; address accumulator
0000017C                           397  
0000017C  13FC 0002 00E00001       398      MOVE.B #2,DISPLAY
00000184                           399  MAIN_LOOP
00000184                           400m     PRINT_CHAR #'>',D3                          ; prompt
00000184                           401m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000184                 TRUE      402m     IFEQ DEBUG
00000184  1639 00C00003            403m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018A  0803 0002                404m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000018E  67F4                     405m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000190  13FC 003E 00C00007       406m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000198                           407m     ENDC
00000198                           408m     
00000198                 FALSE     409m     IFNE DEBUG
00000198                           410m     ENDC
00000198                           411m 
00000198                           412m     ENDM
00000198                           413m     PRINT_CHAR #32,D3                           ; space
00000198                           414m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000198                 TRUE      415m     IFEQ DEBUG
00000198  1639 00C00003            416m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000019E  0803 0002                417m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A2  67F4                     418m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A4  13FC 0020 00C00007       419m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AC                           420m     ENDC
000001AC                           421m     
000001AC                 FALSE     422m     IFNE DEBUG
000001AC                           423m     ENDC
000001AC                           424m 
000001AC                           425m     ENDM
000001AC                           426      
000001AC                           427  GET_INPUT
000001AC                           428m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AC                           429m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AC                           430m 
000001AC                 TRUE      431m     IFEQ DEBUG
000001AC  1639 00C00003            432m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B2  0803 0000                433m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B6  67F4                     434m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001B8                           435m     ENDC
000001B8                           436m     
000001B8                           437mm     READ_CHAR D2
000001B8                 TRUE      438mm     IFEQ DEBUG
000001B8  1439 00C00007            439mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001BE                           440mm     ENDC
000001BE                 FALSE     441mm     IFNE DEBUG
000001BE                           442mm     ENDC
000001BE                           443mm      
000001BE  B43C 001B                444mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C2  6700 FE44                445mm     BEQ START
000001C6                           446mm     ENDM
000001C6                           447m 
000001C6                 TRUE      448m     IFEQ DEBUG
000001C6                           449mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C6                           450mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C6                 TRUE      451mm     IFEQ DEBUG
000001C6  1639 00C00003            452mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CC  0803 0002                453mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D0  67F4                     454mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D2  13C2 00C00007            455mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001D8                           456mm     ENDC
000001D8                           457mm     
000001D8                 FALSE     458mm     IFNE DEBUG
000001D8                           459mm     ENDC
000001D8                           460mm 
000001D8                           461mm     ENDM
000001D8                           462m     ENDC
000001D8                           463m     ENDM
000001D8                           464      
000001D8  B43C 0030                465      CMP.B #'0',D2
000001DC  6700 0CB0                466      BEQ HEX_DIGIT
000001E0  B43C 0031                467      CMP.B #'1',D2
000001E4  6700 0CA8                468      BEQ HEX_DIGIT
000001E8  B43C 0032                469      CMP.B #'2',D2
000001EC  6700 0CA0                470      BEQ HEX_DIGIT
000001F0  B43C 0033                471      CMP.B #'3',D2
000001F4  6700 0C98                472      BEQ HEX_DIGIT
000001F8  B43C 0034                473      CMP.B #'4',D2
000001FC  6700 0C90                474      BEQ HEX_DIGIT
00000200  B43C 0035                475      CMP.B #'5',D2
00000204  6700 0C88                476      BEQ HEX_DIGIT
00000208  B43C 0036                477      CMP.B #'6',D2
0000020C  6700 0C80                478      BEQ HEX_DIGIT
00000210  B43C 0037                479      CMP.B #'7',D2
00000214  6700 0C78                480      BEQ HEX_DIGIT
00000218  B43C 0038                481      CMP.B #'8',D2
0000021C  6700 0C70                482      BEQ HEX_DIGIT
00000220  B43C 0039                483      CMP.B #'9',D2
00000224  6700 0C68                484      BEQ HEX_DIGIT
00000228  B43C 0061                485      CMP.B #'a',D2
0000022C  6700 0C60                486      BEQ HEX_DIGIT
00000230  B43C 0062                487      CMP.B #'b',D2
00000234  6700 0C58                488      BEQ HEX_DIGIT
00000238  B43C 0063                489      CMP.B #'c',D2
0000023C  6700 0C50                490      BEQ HEX_DIGIT
00000240  B43C 0064                491      CMP.B #'d',D2
00000244  6700 0C48                492      BEQ HEX_DIGIT
00000248  B43C 0065                493      CMP.B #'e',D2
0000024C  6700 0C40                494      BEQ HEX_DIGIT
00000250  B43C 0066                495      CMP.B #'f',D2
00000254  6700 0C38                496      BEQ HEX_DIGIT
00000258                           497      
00000258  B43C 0077                498      CMP.B #'w',D2
0000025C  6700 015A                499      BEQ W
00000260                           500      
00000260  B43C 006C                501      CMP.B #'l',D2
00000264  6700 0ABC                502      BEQ L 
00000268                           503  
00000268                           504m     PRINT_CRLF D3
00000268                           505mm     PRINT_CHAR #13,D3                           ; CR
00000268                           506mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000268                 TRUE      507mm     IFEQ DEBUG
00000268  1639 00C00003            508mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000026E  0803 0002                509mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000272  67F4                     510mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000274  13FC 000D 00C00007       511mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000027C                           512mm     ENDC
0000027C                           513mm     
0000027C                 FALSE     514mm     IFNE DEBUG
0000027C                           515mm     ENDC
0000027C                           516mm 
0000027C                           517mm     ENDM
0000027C                           518mm     PRINT_CHAR #10,D3                           ; LF
0000027C                           519mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      520mm     IFEQ DEBUG
0000027C  1639 00C00003            521mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000282  0803 0002                522mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000286  67F4                     523mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00000288  13FC 000A 00C00007       524mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000290                           525mm     ENDC
00000290                           526mm     
00000290                 FALSE     527mm     IFNE DEBUG
00000290                           528mm     ENDC
00000290                           529mm 
00000290                           530mm     ENDM
00000290                           531m     ENDM
00000290                           532   
00000290  B43C 003F                533      CMP.B #'?',D2
00000294  6700 0050                534      BEQ H
00000298                           535  
00000298  B43C 0076                536      CMP.B #'v',D2
0000029C  6700 006E                537      BEQ V
000002A0                           538      
000002A0  B43C 0072                539      CMP.B #'r',D2
000002A4  6700 008C                540      BEQ R
000002A8                           541  
000002A8  B43C 0073                542      CMP.B #'s',D2
000002AC  6700 01D0                543      BEQ S
000002B0                           544  
000002B0  B43C 0067                545      CMP.B #'g',D2
000002B4  6700 095E                546      BEQ G   
000002B8                           547  
000002B8  B43C 007A                548      CMP.B #'z',D2
000002BC  6700 095E                549      BEQ Z   
000002C0                           550  
000002C0  41F9 00000F70            551      LEA HUH,A0
000002C6                           552m     PRINT_STR A0,D3
000002C6                           553m LOOP_19
000002C6  0C10 0000                554m     CMP.B #0,(A0)                               ; 0 -> DONE
000002CA  6700 0016                555m     BEQ EXIT_19
000002CE                           556mm     PRINT_CHAR (A0)+,D3
000002CE                           557mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002CE                 TRUE      558mm     IFEQ DEBUG
000002CE  1639 00C00003            559mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D4  0803 0002                560mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D8  67F4                     561mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
000002DA  13D8 00C00007            562mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E0                           563mm     ENDC
000002E0                           564mm     
000002E0                 FALSE     565mm     IFNE DEBUG
000002E0                           566mm     ENDC
000002E0                           567mm 
000002E0                           568mm     ENDM
000002E0  60E4                     569m     BRA LOOP_19
000002E2                           570m EXIT_19
000002E2                           571m     ENDM
000002E2                           572                         
000002E2  6000 FEA0                573      BRA MAIN_LOOP
000002E6                           574      
000002E6                           575  ; commands
000002E6                           576  H   
000002E6  41F9 00000ECB            577      LEA HELP,A0
000002EC                           578m     PRINT_STR A0,D3
000002EC                           579m LOOP_21
000002EC  0C10 0000                580m     CMP.B #0,(A0)                               ; 0 -> DONE
000002F0  6700 0016                581m     BEQ EXIT_21
000002F4                           582mm     PRINT_CHAR (A0)+,D3
000002F4                           583mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F4                 TRUE      584mm     IFEQ DEBUG
000002F4  1639 00C00003            585mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FA  0803 0002                586mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002FE  67F4                     587mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000300  13D8 00C00007            588mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000306                           589mm     ENDC
00000306                           590mm     
00000306                 FALSE     591mm     IFNE DEBUG
00000306                           592mm     ENDC
00000306                           593mm 
00000306                           594mm     ENDM
00000306  60E4                     595m     BRA LOOP_21
00000308                           596m EXIT_21
00000308                           597m     ENDM
00000308  6000 FE7A                598      BRA MAIN_LOOP
0000030C                           599  
0000030C                           600  V   
0000030C  41F9 00000EAE            601      LEA VERSION,A0
00000312                           602m     PRINT_STR A0,D3       
00000312                           603m LOOP_23
00000312  0C10 0000                604m     CMP.B #0,(A0)                               ; 0 -> DONE
00000316  6700 0016                605m     BEQ EXIT_23
0000031A                           606mm     PRINT_CHAR (A0)+,D3
0000031A                           607mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031A                 TRUE      608mm     IFEQ DEBUG
0000031A  1639 00C00003            609mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000320  0803 0002                610mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000324  67F4                     611mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000326  13D8 00C00007            612mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000032C                           613mm     ENDC
0000032C                           614mm     
0000032C                 FALSE     615mm     IFNE DEBUG
0000032C                           616mm     ENDC
0000032C                           617mm 
0000032C                           618mm     ENDM
0000032C  60E4                     619m     BRA LOOP_23
0000032E                           620m EXIT_23
0000032E                           621m     ENDM
0000032E  6000 FE54                622      BRA MAIN_LOOP
00000332                           623      
00000332                           624  R   
00000332  2047                     625      MOVE.L D7,A0                                ; address accumulator -> address register
00000334  2A10                     626      MOVE.L (A0),D5                              ; read the memory and print it
00000336                           627m     PRINT_REG D5,D3,D7,D6,A0
00000336                           628mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000336                           629mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000336                 TRUE      630mm     IFEQ DEBUG
00000336  1639 00C00003            631mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000033C  0803 0002                632mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000340  67F4                     633mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00000342  13FC 0030 00C00007       634mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000034A                           635mm     ENDC
0000034A                           636mm     
0000034A                 FALSE     637mm     IFNE DEBUG
0000034A                           638mm     ENDC
0000034A                           639mm 
0000034A                           640mm     ENDM
0000034A                           641mm     PRINT_CHAR #'x',D3
0000034A                           642mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000034A                 TRUE      643mm     IFEQ DEBUG
0000034A  1639 00C00003            644mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000350  0803 0002                645mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000354  67F4                     646mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
00000356  13FC 0078 00C00007       647mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000035E                           648mm     ENDC
0000035E                           649mm     
0000035E                 FALSE     650mm     IFNE DEBUG
0000035E                           651mm     ENDC
0000035E                           652mm 
0000035E                           653mm     ENDM
0000035E  7C07                     654m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000360                           655m LOOP_25
00000360                           656mm     BIN2HEX D5,D7,A0
00000360  41F9 00000FD4            657mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000366  E99D                     658mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000368  1E05                     659mm     MOVE.B D5,D7
0000036A  0287 0000000F            660mm     ANDI.L #$F,D7
00000370  1E30 7000                661mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000374                           662mm     ENDM
00000374                           663mm     PRINT_CHAR D7,D3
00000374                           664mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000374                 TRUE      665mm     IFEQ DEBUG
00000374  1639 00C00003            666mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000037A  0803 0002                667mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000037E  67F4                     668mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000380  13C7 00C00007            669mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000386                           670mm     ENDC
00000386                           671mm     
00000386                 FALSE     672mm     IFNE DEBUG
00000386                           673mm     ENDC
00000386                           674mm 
00000386                           675mm     ENDM
00000386  57CE FFD8                676m     DBEQ D6,LOOP_25
0000038A                           677m     ENDM
0000038A                           678m     PRINT_CRLF D3
0000038A                           679mm     PRINT_CHAR #13,D3                           ; CR
0000038A                           680mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                 TRUE      681mm     IFEQ DEBUG
0000038A  1639 00C00003            682mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000390  0803 0002                683mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000394  67F4                     684mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
00000396  13FC 000D 00C00007       685mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000039E                           686mm     ENDC
0000039E                           687mm     
0000039E                 FALSE     688mm     IFNE DEBUG
0000039E                           689mm     ENDC
0000039E                           690mm 
0000039E                           691mm     ENDM
0000039E                           692mm     PRINT_CHAR #10,D3                           ; LF
0000039E                           693mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                 TRUE      694mm     IFEQ DEBUG
0000039E  1639 00C00003            695mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003A4  0803 0002                696mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003A8  67F4                     697mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000003AA  13FC 000A 00C00007       698mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003B2                           699mm     ENDC
000003B2                           700mm     
000003B2                 FALSE     701mm     IFNE DEBUG
000003B2                           702mm     ENDC
000003B2                           703mm 
000003B2                           704mm     ENDM
000003B2                           705m     ENDM
000003B2  7E00                     706      MOVE.L #0,D7                                ; clear the now used address accumulator
000003B4  6000 FDCE                707      BRA MAIN_LOOP
000003B8                           708  
000003B8                           709  W
000003B8  7A00                     710      MOVE.L #0,D5                                ; D5 will be the value to write            
000003BA                           711  
000003BA                           712m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000003BA                           713m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BA                           714m 
000003BA                 TRUE      715m     IFEQ DEBUG
000003BA  1639 00C00003            716m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003C0  0803 0000                717m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003C4  67F4                     718m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
000003C6                           719m     ENDC
000003C6                           720m     
000003C6                           721mm     READ_CHAR D2
000003C6                 TRUE      722mm     IFEQ DEBUG
000003C6  1439 00C00007            723mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003CC                           724mm     ENDC
000003CC                 FALSE     725mm     IFNE DEBUG
000003CC                           726mm     ENDC
000003CC                           727mm      
000003CC  B43C 001B                728mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003D0  6700 FC36                729mm     BEQ START
000003D4                           730mm     ENDM
000003D4                           731m 
000003D4                 TRUE      732m     IFEQ DEBUG
000003D4                           733mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003D4                           734mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D4                 TRUE      735mm     IFEQ DEBUG
000003D4  1639 00C00003            736mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003DA  0803 0002                737mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003DE  67F4                     738mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
000003E0  13C2 00C00007            739mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003E6                           740mm     ENDC
000003E6                           741mm     
000003E6                 FALSE     742mm     IFNE DEBUG
000003E6                           743mm     ENDC
000003E6                           744mm 
000003E6                           745mm     ENDM
000003E6                           746m     ENDC
000003E6                           747m     ENDM
000003E6                           748m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003E6  41F9 00000FE4            749m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003EC  0402 0030                750m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F0  C4BC 000000FF            751m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003F6  1430 2000                752m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003FA                           753m     ENDM
000003FA  1A02                     754      MOVE.B D2,D5                                ; put at bottom of D5
000003FC                           755  
000003FC  3C3C 0006                756      MOVE #6,D6                                  ; 7 bytes left to read
00000400                           757      
00000400                           758  READ_DATA_TO_POKE
00000400  E98D                     759      LSL.L #4,D5                                 ; make what we have so far more significant
00000402                           760m     WAIT_CHAR D2,D3                             ; next character -> D2
00000402                           761m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           762m 
00000402                 TRUE      763m     IFEQ DEBUG
00000402  1639 00C00003            764m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000408  0803 0000                765m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000040C  67F4                     766m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
0000040E                           767m     ENDC
0000040E                           768m     
0000040E                           769mm     READ_CHAR D2
0000040E                 TRUE      770mm     IFEQ DEBUG
0000040E  1439 00C00007            771mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000414                           772mm     ENDC
00000414                 FALSE     773mm     IFNE DEBUG
00000414                           774mm     ENDC
00000414                           775mm      
00000414  B43C 001B                776mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                777mm     BEQ START
0000041C                           778mm     ENDM
0000041C                           779m 
0000041C                 TRUE      780m     IFEQ DEBUG
0000041C                           781mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000041C                           782mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      783mm     IFEQ DEBUG
0000041C  1639 00C00003            784mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000422  0803 0002                785mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000426  67F4                     786mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00000428  13C2 00C00007            787mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000042E                           788mm     ENDC
0000042E                           789mm     
0000042E                 FALSE     790mm     IFNE DEBUG
0000042E                           791mm     ENDC
0000042E                           792mm 
0000042E                           793mm     ENDM
0000042E                           794m     ENDC
0000042E                           795m     ENDM
0000042E                           796m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0000042E  41F9 00000FE4            797m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000434  0402 0030                798m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000438  C4BC 000000FF            799m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000043E  1430 2000                800m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000442                           801m     ENDM
00000442  8A02                     802      OR.B D2,D5
00000444  023C 00FB                803      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000448  57CE FFB6                804      DBEQ D6,READ_DATA_TO_POKE
0000044C                           805      
0000044C  2047                     806      MOVE.L D7,A0                                ; address accumulator -> address register
0000044E  7E00                     807      MOVE.L #0,D7                                ; clear the now used address accumulator
00000450                           808      
00000450  2085                     809      MOVE.L D5,(A0)                              ; write the data
00000452                           810  
00000452                           811m     PRINT_CRLF D3
00000452                           812mm     PRINT_CHAR #13,D3                           ; CR
00000452                           813mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                 TRUE      814mm     IFEQ DEBUG
00000452  1639 00C00003            815mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000458  0803 0002                816mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000045C  67F4                     817mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0000045E  13FC 000D 00C00007       818mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000466                           819mm     ENDC
00000466                           820mm     
00000466                 FALSE     821mm     IFNE DEBUG
00000466                           822mm     ENDC
00000466                           823mm 
00000466                           824mm     ENDM
00000466                           825mm     PRINT_CHAR #10,D3                           ; LF
00000466                           826mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000466                 TRUE      827mm     IFEQ DEBUG
00000466  1639 00C00003            828mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000046C  0803 0002                829mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000470  67F4                     830mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00000472  13FC 000A 00C00007       831mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000047A                           832mm     ENDC
0000047A                           833mm     
0000047A                 FALSE     834mm     IFNE DEBUG
0000047A                           835mm     ENDC
0000047A                           836mm 
0000047A                           837mm     ENDM
0000047A                           838m     ENDM
0000047A  6000 FD08                839      BRA MAIN_LOOP
0000047E                           840  
0000047E                           841          
0000047E                           842  S
0000047E  2647                     843      MOVE.L D7,A3                                ; grab the address accumulator
00000480  7800                     844      MOVE.L #0,D4                                ; count of records read -> D4
00000482  2478 0000                845      MOVE.L 0,A2                                 ; start address -> A2
00000486                           846      
00000486                           847  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
00000486                           848m     DOWNLOAD D2                 
00000486                           849m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                           850m 
00000486  1439 00C00003            851m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000048C  0802 0000                852m     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000490  6700 0010                853m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000494                           854m  
00000494                           855mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000494                 TRUE      856mm     IFEQ DEBUG
00000494  1439 00C00007            857mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000049A                           858mm     ENDC
0000049A                 FALSE     859mm     IFNE DEBUG
0000049A                           860mm     ENDC
0000049A                           861mm      
0000049A  B43C 001B                862mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000049E  6700 FB68                863mm     BEQ START
000004A2                           864mm     ENDM
000004A2                           865m CONTINUE_44
000004A2  1439 00C00013            866m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
000004A8  0802 0000                867m     BTST #0,D2                                  ; CHECK FOR CHARACTER
000004AC  67D8                     868m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
000004AE                           869m     
000004AE  1439 00C00017            870m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000004B4  13C2 00E00001            871m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000004BA                           872m     
000004BA                           873m     ENDM
000004BA  B43C 0053                874      CMP.B #'S',D2                               ; found S?    
000004BE  66C6                     875      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
000004C0                           876      
000004C0                           877m     PRINT_CHAR #'S',D3                          ; print it
000004C0                           878m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                 TRUE      879m     IFEQ DEBUG
000004C0  1639 00C00003            880m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000004C6  0803 0002                881m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000004CA  67F4                     882m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
000004CC  13FC 0053 00C00007       883m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000004D4                           884m     ENDC
000004D4                           885m     
000004D4                 FALSE     886m     IFNE DEBUG
000004D4                           887m     ENDC
000004D4                           888m 
000004D4                           889m     ENDM
000004D4  5284                     890      ADD.L #1,D4                                 ; read another S record, increment count
000004D6                           891      
000004D6                           892m     DOWNLOAD D0                                 ; read the record identifier
000004D6                           893m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                           894m 
000004D6  1039 00C00003            895m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
000004DC  0800 0000                896m     BTST #0,D0                                  ; CHECK FOR CHARACTER
000004E0  6700 0010                897m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
000004E4                           898m  
000004E4                           899mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
000004E4                 TRUE      900mm     IFEQ DEBUG
000004E4  1039 00C00007            901mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
000004EA                           902mm     ENDC
000004EA                 FALSE     903mm     IFNE DEBUG
000004EA                           904mm     ENDC
000004EA                           905mm      
000004EA  B03C 001B                906mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
000004EE  6700 FB18                907mm     BEQ START
000004F2                           908mm     ENDM
000004F2                           909m CONTINUE_47
000004F2  1039 00C00013            910m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
000004F8  0800 0000                911m     BTST #0,D0                                  ; CHECK FOR CHARACTER
000004FC  67D8                     912m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
000004FE                           913m     
000004FE  1039 00C00017            914m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
00000504  13C0 00E00001            915m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
0000050A                           916m     
0000050A                           917m     ENDM
0000050A                           918m     PRINT_CHAR D0,D3                            ; print it
0000050A                           919m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      920m     IFEQ DEBUG
0000050A  1639 00C00003            921m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000510  0803 0002                922m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000514  67F4                     923m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00000516  13C0 00C00007            924m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000051C                           925m     ENDC
0000051C                           926m     
0000051C                 FALSE     927m     IFNE DEBUG
0000051C                           928m     ENDC
0000051C                           929m 
0000051C                           930m     ENDM
0000051C                           931  
0000051C  7C00                     932      MOVE.L #0,D6                                ; clear the checksum
0000051E                           933  
0000051E  7A00                     934      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00000520                           935m     DOWNLOAD_BYTE D2,D5,D3,D1,D6,A0                                        
00000520  123C 0002                936m     MOVE.B #2,D1
00000524                           937m     WHILE.B D1 <GT> 0 DO
00000524                           938ms _10000000
00000524  B238 0000                939ms     CMP.B   0,D1
00000528  6F00 0064                940ms     BLE _10000001
0000052C  E98D                     941m         LSL.L #4,D5                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000052E                           942mm         DOWNLOAD D2
0000052E                           943mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052E                           944mm 
0000052E  1439 00C00003            945mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000534  0802 0000                946mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000538  6700 0010                947mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0000053C                           948mm  
0000053C                           949mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000053C                 TRUE      950mmm     IFEQ DEBUG
0000053C  1439 00C00007            951mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000542                           952mmm     ENDC
00000542                 FALSE     953mmm     IFNE DEBUG
00000542                           954mmm     ENDC
00000542                           955mmm      
00000542  B43C 001B                956mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000546  6700 FAC0                957mmm     BEQ START
0000054A                           958mmm     ENDM
0000054A                           959mm CONTINUE_51
0000054A  1439 00C00013            960mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000550  0802 0000                961mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000554  67D8                     962mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00000556                           963mm     
00000556  1439 00C00017            964mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000055C  13C2 00E00001            965mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000562                           966mm     
00000562                           967mm     ENDM
00000562                           968mm         PRINT_CHAR D2,D3
00000562                           969mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000562                 TRUE      970mm     IFEQ DEBUG
00000562  1639 00C00003            971mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000568  0803 0002                972mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000056C  67F4                     973mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0000056E  13C2 00C00007            974mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000574                           975mm     ENDC
00000574                           976mm     
00000574                 FALSE     977mm     IFNE DEBUG
00000574                           978mm     ENDC
00000574                           979mm 
00000574                           980mm     ENDM
00000574                           981mm         HEX2BIN D2,D2,A0
00000574  41F9 00000FE4            982mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000057A  0402 0030                983mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  C4BC 000000FF            984mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000584  1430 2000                985mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000588                           986mm     ENDM
00000588  8A02                     987m         OR.B D2,D5
0000058A  5301                     988m         SUB.B #1,D1
0000058C                           989m     ENDW
0000058C  6096                     990ms     BRA _10000000
0000058E                           991ms _10000001
0000058E                           992m     
0000058E  7400                     993m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000590  1405                     994m     MOVE.B D5,D2
00000592  DC85                     995m     ADD.L D5,D6
00000594                           996m 
00000594                           997m     ENDM
00000594                           998  
00000594                           999      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
00000594  B03C 0030               1000s     CMP.B   #'0',D0
00000598  6600 0032               1001s     BNE.L   _00000000
0000059C                          1002m         PRINT_CRLF D3
0000059C                          1003mm     PRINT_CHAR #13,D3                           ; CR
0000059C                          1004mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059C                 TRUE     1005mm     IFEQ DEBUG
0000059C  1639 00C00003           1006mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005A2  0803 0002               1007mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005A6  67F4                    1008mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
000005A8  13FC 000D 00C00007      1009mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005B0                          1010mm     ENDC
000005B0                          1011mm     
000005B0                 FALSE    1012mm     IFNE DEBUG
000005B0                          1013mm     ENDC
000005B0                          1014mm 
000005B0                          1015mm     ENDM
000005B0                          1016mm     PRINT_CHAR #10,D3                           ; LF
000005B0                          1017mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                 TRUE     1018mm     IFEQ DEBUG
000005B0  1639 00C00003           1019mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005B6  0803 0002               1020mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005BA  67F4                    1021mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
000005BC  13FC 000A 00C00007      1022mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005C4                          1023mm     ENDC
000005C4                          1024mm     
000005C4                 FALSE    1025mm     IFNE DEBUG
000005C4                          1026mm     ENDC
000005C4                          1027mm 
000005C4                          1028mm     ENDM
000005C4                          1029m     ENDM
000005C4  6000 FEC0               1030          BRA WAIT_FOR_SRECORD
000005C8                          1031      ELSE
000005C8  6000 0408               1032s     BRA _00000001
000005CC                          1033s _00000000
000005CC                          1034          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000005CC  B03C 0031               1035s     CMP.B   #'1',D0
000005D0  6708                    1036s     BEQ.S   _00000002
000005D2  B03C 0032               1037s     CMP.B   #'2',D0
000005D6  6600 0200               1038s     BNE.L   _00000003
000005DA                          1039s _00000002
000005DA  5785                    1040              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
000005DC                          1041      
000005DC  7E00                    1042              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
000005DE                          1043m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; first byte                           
000005DE  123C 0002               1044m     MOVE.B #2,D1
000005E2                          1045m     WHILE.B D1 <GT> 0 DO
000005E2                          1046ms _10000002
000005E2  B238 0000               1047ms     CMP.B   0,D1
000005E6  6F00 0064               1048ms     BLE _10000003
000005EA  E98F                    1049m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000005EC                          1050mm         DOWNLOAD D2
000005EC                          1051mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005EC                          1052mm 
000005EC  1439 00C00003           1053mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000005F2  0802 0000               1054mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000005F6  6700 0010               1055mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
000005FA                          1056mm  
000005FA                          1057mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000005FA                 TRUE     1058mmm     IFEQ DEBUG
000005FA  1439 00C00007           1059mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000600                          1060mmm     ENDC
00000600                 FALSE    1061mmm     IFNE DEBUG
00000600                          1062mmm     ENDC
00000600                          1063mmm      
00000600  B43C 001B               1064mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000604  6700 FA02               1065mmm     BEQ START
00000608                          1066mmm     ENDM
00000608                          1067mm CONTINUE_59
00000608  1439 00C00013           1068mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000060E  0802 0000               1069mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000612  67D8                    1070mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00000614                          1071mm     
00000614  1439 00C00017           1072mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000061A  13C2 00E00001           1073mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000620                          1074mm     
00000620                          1075mm     ENDM
00000620                          1076mm         PRINT_CHAR D2,D3
00000620                          1077mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                 TRUE     1078mm     IFEQ DEBUG
00000620  1639 00C00003           1079mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000626  0803 0002               1080mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000062A  67F4                    1081mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
0000062C  13C2 00C00007           1082mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000632                          1083mm     ENDC
00000632                          1084mm     
00000632                 FALSE    1085mm     IFNE DEBUG
00000632                          1086mm     ENDC
00000632                          1087mm 
00000632                          1088mm     ENDM
00000632                          1089mm         HEX2BIN D2,D2,A0
00000632  41F9 00000FE4           1090mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000638  0402 0030               1091mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000063C  C4BC 000000FF           1092mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000642  1430 2000               1093mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000646                          1094mm     ENDM
00000646  8E02                    1095m         OR.B D2,D7
00000648  5301                    1096m         SUB.B #1,D1
0000064A                          1097m     ENDW
0000064A  6096                    1098ms     BRA _10000002
0000064C                          1099ms _10000003
0000064C                          1100m     
0000064C  7400                    1101m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000064E  1407                    1102m     MOVE.B D7,D2
00000650  DC87                    1103m     ADD.L D7,D6
00000652                          1104m 
00000652                          1105m     ENDM
00000652                          1106m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; second one
00000652  123C 0002               1107m     MOVE.B #2,D1
00000656                          1108m     WHILE.B D1 <GT> 0 DO
00000656                          1109ms _10000004
00000656  B238 0000               1110ms     CMP.B   0,D1
0000065A  6F00 0064               1111ms     BLE _10000005
0000065E  E98F                    1112m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000660                          1113mm         DOWNLOAD D2
00000660                          1114mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000660                          1115mm 
00000660  1439 00C00003           1116mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000666  0802 0000               1117mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000066A  6700 0010               1118mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0000066E                          1119mm  
0000066E                          1120mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000066E                 TRUE     1121mmm     IFEQ DEBUG
0000066E  1439 00C00007           1122mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000674                          1123mmm     ENDC
00000674                 FALSE    1124mmm     IFNE DEBUG
00000674                          1125mmm     ENDC
00000674                          1126mmm      
00000674  B43C 001B               1127mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000678  6700 F98E               1128mmm     BEQ START
0000067C                          1129mmm     ENDM
0000067C                          1130mm CONTINUE_64
0000067C  1439 00C00013           1131mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000682  0802 0000               1132mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000686  67D8                    1133mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000688                          1134mm     
00000688  1439 00C00017           1135mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000068E  13C2 00E00001           1136mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000694                          1137mm     
00000694                          1138mm     ENDM
00000694                          1139mm         PRINT_CHAR D2,D3
00000694                          1140mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000694                 TRUE     1141mm     IFEQ DEBUG
00000694  1639 00C00003           1142mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000069A  0803 0002               1143mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000069E  67F4                    1144mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
000006A0  13C2 00C00007           1145mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006A6                          1146mm     ENDC
000006A6                          1147mm     
000006A6                 FALSE    1148mm     IFNE DEBUG
000006A6                          1149mm     ENDC
000006A6                          1150mm 
000006A6                          1151mm     ENDM
000006A6                          1152mm         HEX2BIN D2,D2,A0
000006A6  41F9 00000FE4           1153mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000006AC  0402 0030               1154mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B0  C4BC 000000FF           1155mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000006B6  1430 2000               1156mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000006BA                          1157mm     ENDM
000006BA  8E02                    1158m         OR.B D2,D7
000006BC  5301                    1159m         SUB.B #1,D1
000006BE                          1160m     ENDW
000006BE  6096                    1161ms     BRA _10000004
000006C0                          1162ms _10000005
000006C0                          1163m     
000006C0  7400                    1164m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006C2  1407                    1165m     MOVE.B D7,D2
000006C4  DC87                    1166m     ADD.L D7,D6
000006C6                          1167m 
000006C6                          1168m     ENDM
000006C6                          1169              
000006C6                          1170              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
000006C6  B03C 0032               1171s     CMP.B   #'2',D0
000006CA  6600 0078               1172s     BNE.L   _00000004
000006CE  5385                    1173                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address    
000006D0                          1174m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; 3rd byte       
000006D0  123C 0002               1175m     MOVE.B #2,D1
000006D4                          1176m     WHILE.B D1 <GT> 0 DO
000006D4                          1177ms _10000006
000006D4  B238 0000               1178ms     CMP.B   0,D1
000006D8  6F00 0064               1179ms     BLE _10000007
000006DC  E98F                    1180m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000006DE                          1181mm         DOWNLOAD D2
000006DE                          1182mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DE                          1183mm 
000006DE  1439 00C00003           1184mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000006E4  0802 0000               1185mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000006E8  6700 0010               1186mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
000006EC                          1187mm  
000006EC                          1188mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000006EC                 TRUE     1189mmm     IFEQ DEBUG
000006EC  1439 00C00007           1190mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000006F2                          1191mmm     ENDC
000006F2                 FALSE    1192mmm     IFNE DEBUG
000006F2                          1193mmm     ENDC
000006F2                          1194mmm      
000006F2  B43C 001B               1195mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000006F6  6700 F910               1196mmm     BEQ START
000006FA                          1197mmm     ENDM
000006FA                          1198mm CONTINUE_69
000006FA  1439 00C00013           1199mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000700  0802 0000               1200mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000704  67D8                    1201mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00000706                          1202mm     
00000706  1439 00C00017           1203mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000070C  13C2 00E00001           1204mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000712                          1205mm     
00000712                          1206mm     ENDM
00000712                          1207mm         PRINT_CHAR D2,D3
00000712                          1208mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1209mm     IFEQ DEBUG
00000712  1639 00C00003           1210mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000718  0803 0002               1211mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1212mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0000071E  13C2 00C00007           1213mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000724                          1214mm     ENDC
00000724                          1215mm     
00000724                 FALSE    1216mm     IFNE DEBUG
00000724                          1217mm     ENDC
00000724                          1218mm 
00000724                          1219mm     ENDM
00000724                          1220mm         HEX2BIN D2,D2,A0
00000724  41F9 00000FE4           1221mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000072A  0402 0030               1222mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000072E  C4BC 000000FF           1223mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000734  1430 2000               1224mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000738                          1225mm     ENDM
00000738  8E02                    1226m         OR.B D2,D7
0000073A  5301                    1227m         SUB.B #1,D1
0000073C                          1228m     ENDW
0000073C  6096                    1229ms     BRA _10000006
0000073E                          1230ms _10000007
0000073E                          1231m     
0000073E  7400                    1232m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000740  1407                    1233m     MOVE.B D7,D2
00000742  DC87                    1234m     ADD.L D7,D6
00000744                          1235m 
00000744                          1236m     ENDM
00000744                          1237              ENDI
00000744                          1238s _00000004
00000744                          1239              
00000744  2247                    1240              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00000746  D3CB                    1241              ADD.L A3,A1                         ; add in the offset
00000748                          1242  
00000748                          1243              WHILE.L D5 <GT> #0 DO               ; read the data bytes                
00000748                          1244s _10000008
00000748  BABC 00000000           1245s     CMP.L   #0,D5
0000074E  6F00 0080               1246s     BLE _10000009
00000752  7E00                    1247                  MOVE.L #0,D7                    ; D7 holds the byte
00000754                          1248m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; read it                               
00000754  123C 0002               1249m     MOVE.B #2,D1
00000758                          1250m     WHILE.B D1 <GT> 0 DO
00000758                          1251ms _1000000A
00000758  B238 0000               1252ms     CMP.B   0,D1
0000075C  6F00 0064               1253ms     BLE _1000000B
00000760  E98F                    1254m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000762                          1255mm         DOWNLOAD D2
00000762                          1256mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000762                          1257mm 
00000762  1439 00C00003           1258mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000768  0802 0000               1259mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000076C  6700 0010               1260mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000770                          1261mm  
00000770                          1262mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000770                 TRUE     1263mmm     IFEQ DEBUG
00000770  1439 00C00007           1264mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000776                          1265mmm     ENDC
00000776                 FALSE    1266mmm     IFNE DEBUG
00000776                          1267mmm     ENDC
00000776                          1268mmm      
00000776  B43C 001B               1269mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000077A  6700 F88C               1270mmm     BEQ START
0000077E                          1271mmm     ENDM
0000077E                          1272mm CONTINUE_74
0000077E  1439 00C00013           1273mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000784  0802 0000               1274mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000788  67D8                    1275mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0000078A                          1276mm     
0000078A  1439 00C00017           1277mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000790  13C2 00E00001           1278mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000796                          1279mm     
00000796                          1280mm     ENDM
00000796                          1281mm         PRINT_CHAR D2,D3
00000796                          1282mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000796                 TRUE     1283mm     IFEQ DEBUG
00000796  1639 00C00003           1284mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000079C  0803 0002               1285mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000007A0  67F4                    1286mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
000007A2  13C2 00C00007           1287mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007A8                          1288mm     ENDC
000007A8                          1289mm     
000007A8                 FALSE    1290mm     IFNE DEBUG
000007A8                          1291mm     ENDC
000007A8                          1292mm 
000007A8                          1293mm     ENDM
000007A8                          1294mm         HEX2BIN D2,D2,A0
000007A8  41F9 00000FE4           1295mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000007AE  0402 0030               1296mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B2  C4BC 000000FF           1297mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000007B8  1430 2000               1298mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000007BC                          1299mm     ENDM
000007BC  8E02                    1300m         OR.B D2,D7
000007BE  5301                    1301m         SUB.B #1,D1
000007C0                          1302m     ENDW
000007C0  6096                    1303ms     BRA _1000000A
000007C2                          1304ms _1000000B
000007C2                          1305m     
000007C2  7400                    1306m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C4  1407                    1307m     MOVE.B D7,D2
000007C6  DC87                    1308m     ADD.L D7,D6
000007C8                          1309m 
000007C8                          1310m     ENDM
000007C8                          1311                          
000007C8  12C7                    1312                  MOVE.B D7,(A1)+                 ; store it!
000007CA                          1313  
000007CA  5385                    1314                  SUB.L #1,D5                     ; 1 less byte to go
000007CC                          1315              ENDW
000007CC  6000 FF7A               1316s     BRA _10000008
000007D0                          1317s _10000009
000007D0                          1318          
000007D0  43F8 0486               1319              LEA WAIT_FOR_SRECORD,A1             ; next place to go
000007D4                          1320          ELSE
000007D4  6000 01FC               1321s     BRA _00000005
000007D8                          1322s _00000003
000007D8                          1323              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
000007D8  B03C 0038               1324s     CMP.B   #'8',D0
000007DC  6600 016C               1325s     BNE.L   _00000006
000007E0  7E00                    1326                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007E2                          1327m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; top byte  
000007E2  123C 0002               1328m     MOVE.B #2,D1
000007E6                          1329m     WHILE.B D1 <GT> 0 DO
000007E6                          1330ms _1000000C
000007E6  B238 0000               1331ms     CMP.B   0,D1
000007EA  6F00 0064               1332ms     BLE _1000000D
000007EE  E98F                    1333m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000007F0                          1334mm         DOWNLOAD D2
000007F0                          1335mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F0                          1336mm 
000007F0  1439 00C00003           1337mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000007F6  0802 0000               1338mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000007FA  6700 0010               1339mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
000007FE                          1340mm  
000007FE                          1341mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000007FE                 TRUE     1342mmm     IFEQ DEBUG
000007FE  1439 00C00007           1343mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000804                          1344mmm     ENDC
00000804                 FALSE    1345mmm     IFNE DEBUG
00000804                          1346mmm     ENDC
00000804                          1347mmm      
00000804  B43C 001B               1348mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000808  6700 F7FE               1349mmm     BEQ START
0000080C                          1350mmm     ENDM
0000080C                          1351mm CONTINUE_79
0000080C  1439 00C00013           1352mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000812  0802 0000               1353mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000816  67D8                    1354mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
00000818                          1355mm     
00000818  1439 00C00017           1356mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000081E  13C2 00E00001           1357mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000824                          1358mm     
00000824                          1359mm     ENDM
00000824                          1360mm         PRINT_CHAR D2,D3
00000824                          1361mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000824                 TRUE     1362mm     IFEQ DEBUG
00000824  1639 00C00003           1363mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000082A  0803 0002               1364mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000082E  67F4                    1365mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00000830  13C2 00C00007           1366mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000836                          1367mm     ENDC
00000836                          1368mm     
00000836                 FALSE    1369mm     IFNE DEBUG
00000836                          1370mm     ENDC
00000836                          1371mm 
00000836                          1372mm     ENDM
00000836                          1373mm         HEX2BIN D2,D2,A0
00000836  41F9 00000FE4           1374mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000083C  0402 0030               1375mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000840  C4BC 000000FF           1376mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000846  1430 2000               1377mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000084A                          1378mm     ENDM
0000084A  8E02                    1379m         OR.B D2,D7
0000084C  5301                    1380m         SUB.B #1,D1
0000084E                          1381m     ENDW
0000084E  6096                    1382ms     BRA _1000000C
00000850                          1383ms _1000000D
00000850                          1384m     
00000850  7400                    1385m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000852  1407                    1386m     MOVE.B D7,D2
00000854  DC87                    1387m     ADD.L D7,D6
00000856                          1388m 
00000856                          1389m     ENDM
00000856                          1390m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; middle byte     
00000856  123C 0002               1391m     MOVE.B #2,D1
0000085A                          1392m     WHILE.B D1 <GT> 0 DO
0000085A                          1393ms _1000000E
0000085A  B238 0000               1394ms     CMP.B   0,D1
0000085E  6F00 0064               1395ms     BLE _1000000F
00000862  E98F                    1396m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000864                          1397mm         DOWNLOAD D2
00000864                          1398mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000864                          1399mm 
00000864  1439 00C00003           1400mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000086A  0802 0000               1401mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000086E  6700 0010               1402mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00000872                          1403mm  
00000872                          1404mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000872                 TRUE     1405mmm     IFEQ DEBUG
00000872  1439 00C00007           1406mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000878                          1407mmm     ENDC
00000878                 FALSE    1408mmm     IFNE DEBUG
00000878                          1409mmm     ENDC
00000878                          1410mmm      
00000878  B43C 001B               1411mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000087C  6700 F78A               1412mmm     BEQ START
00000880                          1413mmm     ENDM
00000880                          1414mm CONTINUE_84
00000880  1439 00C00013           1415mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000886  0802 0000               1416mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000088A  67D8                    1417mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0000088C                          1418mm     
0000088C  1439 00C00017           1419mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000892  13C2 00E00001           1420mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000898                          1421mm     
00000898                          1422mm     ENDM
00000898                          1423mm         PRINT_CHAR D2,D3
00000898                          1424mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000898                 TRUE     1425mm     IFEQ DEBUG
00000898  1639 00C00003           1426mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000089E  0803 0002               1427mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000008A2  67F4                    1428mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
000008A4  13C2 00C00007           1429mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008AA                          1430mm     ENDC
000008AA                          1431mm     
000008AA                 FALSE    1432mm     IFNE DEBUG
000008AA                          1433mm     ENDC
000008AA                          1434mm 
000008AA                          1435mm     ENDM
000008AA                          1436mm         HEX2BIN D2,D2,A0
000008AA  41F9 00000FE4           1437mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000008B0  0402 0030               1438mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B4  C4BC 000000FF           1439mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000008BA  1430 2000               1440mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000008BE                          1441mm     ENDM
000008BE  8E02                    1442m         OR.B D2,D7
000008C0  5301                    1443m         SUB.B #1,D1
000008C2                          1444m     ENDW
000008C2  6096                    1445ms     BRA _1000000E
000008C4                          1446ms _1000000F
000008C4                          1447m     
000008C4  7400                    1448m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C6  1407                    1449m     MOVE.B D7,D2
000008C8  DC87                    1450m     ADD.L D7,D6
000008CA                          1451m 
000008CA                          1452m     ENDM
000008CA                          1453m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; bottom byte
000008CA  123C 0002               1454m     MOVE.B #2,D1
000008CE                          1455m     WHILE.B D1 <GT> 0 DO
000008CE                          1456ms _10000010
000008CE  B238 0000               1457ms     CMP.B   0,D1
000008D2  6F00 0064               1458ms     BLE _10000011
000008D6  E98F                    1459m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000008D8                          1460mm         DOWNLOAD D2
000008D8                          1461mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D8                          1462mm 
000008D8  1439 00C00003           1463mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000008DE  0802 0000               1464mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000008E2  6700 0010               1465mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
000008E6                          1466mm  
000008E6                          1467mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000008E6                 TRUE     1468mmm     IFEQ DEBUG
000008E6  1439 00C00007           1469mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000008EC                          1470mmm     ENDC
000008EC                 FALSE    1471mmm     IFNE DEBUG
000008EC                          1472mmm     ENDC
000008EC                          1473mmm      
000008EC  B43C 001B               1474mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000008F0  6700 F716               1475mmm     BEQ START
000008F4                          1476mmm     ENDM
000008F4                          1477mm CONTINUE_89
000008F4  1439 00C00013           1478mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
000008FA  0802 0000               1479mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000008FE  67D8                    1480mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00000900                          1481mm     
00000900  1439 00C00017           1482mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000906  13C2 00E00001           1483mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000090C                          1484mm     
0000090C                          1485mm     ENDM
0000090C                          1486mm         PRINT_CHAR D2,D3
0000090C                          1487mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                 TRUE     1488mm     IFEQ DEBUG
0000090C  1639 00C00003           1489mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000912  0803 0002               1490mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000916  67F4                    1491mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000918  13C2 00C00007           1492mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000091E                          1493mm     ENDC
0000091E                          1494mm     
0000091E                 FALSE    1495mm     IFNE DEBUG
0000091E                          1496mm     ENDC
0000091E                          1497mm 
0000091E                          1498mm     ENDM
0000091E                          1499mm         HEX2BIN D2,D2,A0
0000091E  41F9 00000FE4           1500mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000924  0402 0030               1501mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000928  C4BC 000000FF           1502mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000092E  1430 2000               1503mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000932                          1504mm     ENDM
00000932  8E02                    1505m         OR.B D2,D7
00000934  5301                    1506m         SUB.B #1,D1
00000936                          1507m     ENDW
00000936  6096                    1508ms     BRA _10000010
00000938                          1509ms _10000011
00000938                          1510m     
00000938  7400                    1511m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000093A  1407                    1512m     MOVE.B D7,D2
0000093C  DC87                    1513m     ADD.L D7,D6
0000093E                          1514m 
0000093E                          1515m     ENDM
0000093E                          1516                    
0000093E  2447                    1517                  MOVE.L D7,A2                    ; start address -> A2
00000940                          1518                  
00000940  43F9 00000B1C           1519                  LEA DOWNLOAD_DONE,A1            ; next place to go
00000946                          1520              ELSE
00000946  6000 008A               1521s     BRA _00000007
0000094A                          1522s _00000006
0000094A                          1523m                 PRINT_CRLF D3
0000094A                          1524mm     PRINT_CHAR #13,D3                           ; CR
0000094A                          1525mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094A                 TRUE     1526mm     IFEQ DEBUG
0000094A  1639 00C00003           1527mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000950  0803 0002               1528mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000954  67F4                    1529mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000956  13FC 000D 00C00007      1530mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000095E                          1531mm     ENDC
0000095E                          1532mm     
0000095E                 FALSE    1533mm     IFNE DEBUG
0000095E                          1534mm     ENDC
0000095E                          1535mm 
0000095E                          1536mm     ENDM
0000095E                          1537mm     PRINT_CHAR #10,D3                           ; LF
0000095E                          1538mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1539mm     IFEQ DEBUG
0000095E  1639 00C00003           1540mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000964  0803 0002               1541mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000968  67F4                    1542mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0000096A  13FC 000A 00C00007      1543mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000972                          1544mm     ENDC
00000972                          1545mm     
00000972                 FALSE    1546mm     IFNE DEBUG
00000972                          1547mm     ENDC
00000972                          1548mm 
00000972                          1549mm     ENDM
00000972                          1550m     ENDM
00000972                          1551              
00000972  41F9 00000F99           1552                  LEA UNREC,A0                    ; warn for unrecognised type
00000978                          1553m                 PRINT_STR A0,D3
00000978                          1554m LOOP_96
00000978  0C10 0000               1555m     CMP.B #0,(A0)                               ; 0 -> DONE
0000097C  6700 0016               1556m     BEQ EXIT_96
00000980                          1557mm     PRINT_CHAR (A0)+,D3
00000980                          1558mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000980                 TRUE     1559mm     IFEQ DEBUG
00000980  1639 00C00003           1560mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000986  0803 0002               1561mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000098A  67F4                    1562mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0000098C  13D8 00C00007           1563mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000992                          1564mm     ENDC
00000992                          1565mm     
00000992                 FALSE    1566mm     IFNE DEBUG
00000992                          1567mm     ENDC
00000992                          1568mm 
00000992                          1569mm     ENDM
00000992  60E4                    1570m     BRA LOOP_96
00000994                          1571m EXIT_96
00000994                          1572m     ENDM
00000994                          1573m                 PRINT_CHAR D7,D3
00000994                          1574m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000994                 TRUE     1575m     IFEQ DEBUG
00000994  1639 00C00003           1576m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000099A  0803 0002               1577m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000099E  67F4                    1578m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000009A0  13C7 00C00007           1579m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009A6                          1580m     ENDC
000009A6                          1581m     
000009A6                 FALSE    1582m     IFNE DEBUG
000009A6                          1583m     ENDC
000009A6                          1584m 
000009A6                          1585m     ENDM
000009A6                          1586m                 PRINT_CRLF D3
000009A6                          1587mm     PRINT_CHAR #13,D3                           ; CR
000009A6                          1588mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A6                 TRUE     1589mm     IFEQ DEBUG
000009A6  1639 00C00003           1590mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009AC  0803 0002               1591mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009B0  67F4                    1592mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000009B2  13FC 000D 00C00007      1593mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009BA                          1594mm     ENDC
000009BA                          1595mm     
000009BA                 FALSE    1596mm     IFNE DEBUG
000009BA                          1597mm     ENDC
000009BA                          1598mm 
000009BA                          1599mm     ENDM
000009BA                          1600mm     PRINT_CHAR #10,D3                           ; LF
000009BA                          1601mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BA                 TRUE     1602mm     IFEQ DEBUG
000009BA  1639 00C00003           1603mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009C0  0803 0002               1604mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009C4  67F4                    1605mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
000009C6  13FC 000A 00C00007      1606mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009CE                          1607mm     ENDC
000009CE                          1608mm     
000009CE                 FALSE    1609mm     IFNE DEBUG
000009CE                          1610mm     ENDC
000009CE                          1611mm 
000009CE                          1612mm     ENDM
000009CE                          1613m     ENDM
000009CE                          1614              
000009CE  6000 FAB6               1615                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
000009D2                          1616              ENDI
000009D2                          1617s _00000007
000009D2                          1618          ENDI
000009D2                          1619s _00000005
000009D2                          1620      ENDI
000009D2                          1621s _00000001
000009D2                          1622      
000009D2  7E00                    1623      MOVE.L #0,D7                                ; read the checksum from the data stream, and add into the inverted checksum: should make it FF
000009D4                          1624m     DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0                         
000009D4  123C 0002               1625m     MOVE.B #2,D1
000009D8                          1626m     WHILE.B D1 <GT> 0 DO
000009D8                          1627ms _10000012
000009D8  B238 0000               1628ms     CMP.B   0,D1
000009DC  6F00 0064               1629ms     BLE _10000013
000009E0  E98F                    1630m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000009E2                          1631mm         DOWNLOAD D2
000009E2                          1632mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E2                          1633mm 
000009E2  1439 00C00003           1634mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000009E8  0802 0000               1635mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000009EC  6700 0010               1636mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
000009F0                          1637mm  
000009F0                          1638mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000009F0                 TRUE     1639mmm     IFEQ DEBUG
000009F0  1439 00C00007           1640mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000009F6                          1641mmm     ENDC
000009F6                 FALSE    1642mmm     IFNE DEBUG
000009F6                          1643mmm     ENDC
000009F6                          1644mmm      
000009F6  B43C 001B               1645mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000009FA  6700 F60C               1646mmm     BEQ START
000009FE                          1647mmm     ENDM
000009FE                          1648mm CONTINUE_103
000009FE  1439 00C00013           1649mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000A04  0802 0000               1650mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000A08  67D8                    1651mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00000A0A                          1652mm     
00000A0A  1439 00C00017           1653mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000A10  13C2 00E00001           1654mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000A16                          1655mm     
00000A16                          1656mm     ENDM
00000A16                          1657mm         PRINT_CHAR D2,D3
00000A16                          1658mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1659mm     IFEQ DEBUG
00000A16  1639 00C00003           1660mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A1C  0803 0002               1661mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1662mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A22  13C2 00C00007           1663mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A28                          1664mm     ENDC
00000A28                          1665mm     
00000A28                 FALSE    1666mm     IFNE DEBUG
00000A28                          1667mm     ENDC
00000A28                          1668mm 
00000A28                          1669mm     ENDM
00000A28                          1670mm         HEX2BIN D2,D2,A0
00000A28  41F9 00000FE4           1671mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000A2E  0402 0030               1672mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A32  C4BC 000000FF           1673mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000A38  1430 2000               1674mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A3C                          1675mm     ENDM
00000A3C  8E02                    1676m         OR.B D2,D7
00000A3E  5301                    1677m         SUB.B #1,D1
00000A40                          1678m     ENDW
00000A40  6096                    1679ms     BRA _10000012
00000A42                          1680ms _10000013
00000A42                          1681m     
00000A42  7400                    1682m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A44  1407                    1683m     MOVE.B D7,D2
00000A46  DC87                    1684m     ADD.L D7,D6
00000A48                          1685m 
00000A48                          1686m     ENDM
00000A48                          1687m     PRINT_CRLF D3
00000A48                          1688mm     PRINT_CHAR #13,D3                           ; CR
00000A48                          1689mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A48                 TRUE     1690mm     IFEQ DEBUG
00000A48  1639 00C00003           1691mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A4E  0803 0002               1692mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A52  67F4                    1693mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A54  13FC 000D 00C00007      1694mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A5C                          1695mm     ENDC
00000A5C                          1696mm     
00000A5C                 FALSE    1697mm     IFNE DEBUG
00000A5C                          1698mm     ENDC
00000A5C                          1699mm 
00000A5C                          1700mm     ENDM
00000A5C                          1701mm     PRINT_CHAR #10,D3                           ; LF
00000A5C                          1702mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5C                 TRUE     1703mm     IFEQ DEBUG
00000A5C  1639 00C00003           1704mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A62  0803 0002               1705mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A66  67F4                    1706mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A68  13FC 000A 00C00007      1707mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A70                          1708mm     ENDC
00000A70                          1709mm     
00000A70                 FALSE    1710mm     IFNE DEBUG
00000A70                          1711mm     ENDC
00000A70                          1712mm 
00000A70                          1713mm     ENDM
00000A70                          1714m     ENDM
00000A70                          1715          
00000A70                          1716      IF.B D6 <NE> #$FF THEN.L
00000A70  BC3C 00FF               1717s     CMP.B   #$FF,D6
00000A74  6700 00A4               1718s     BEQ.L   _00000008
00000A78  41F9 00000FB0           1719          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00000A7E                          1720m         PRINT_STR A0,D3
00000A7E                          1721m LOOP_110
00000A7E  0C10 0000               1722m     CMP.B #0,(A0)                               ; 0 -> DONE
00000A82  6700 0016               1723m     BEQ EXIT_110
00000A86                          1724mm     PRINT_CHAR (A0)+,D3
00000A86                          1725mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A86                 TRUE     1726mm     IFEQ DEBUG
00000A86  1639 00C00003           1727mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A8C  0803 0002               1728mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A90  67F4                    1729mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A92  13D8 00C00007           1730mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A98                          1731mm     ENDC
00000A98                          1732mm     
00000A98                 FALSE    1733mm     IFNE DEBUG
00000A98                          1734mm     ENDC
00000A98                          1735mm 
00000A98                          1736mm     ENDM
00000A98  60E4                    1737m     BRA LOOP_110
00000A9A                          1738m EXIT_110
00000A9A                          1739m     ENDM
00000A9A                          1740m         PRINT_REG D4,D3,D6,D7,A0
00000A9A                          1741mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000A9A                          1742mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1743mm     IFEQ DEBUG
00000A9A  1639 00C00003           1744mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AA0  0803 0002               1745mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1746mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000AA6  13FC 0030 00C00007      1747mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AAE                          1748mm     ENDC
00000AAE                          1749mm     
00000AAE                 FALSE    1750mm     IFNE DEBUG
00000AAE                          1751mm     ENDC
00000AAE                          1752mm 
00000AAE                          1753mm     ENDM
00000AAE                          1754mm     PRINT_CHAR #'x',D3
00000AAE                          1755mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAE                 TRUE     1756mm     IFEQ DEBUG
00000AAE  1639 00C00003           1757mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AB4  0803 0002               1758mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AB8  67F4                    1759mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000ABA  13FC 0078 00C00007      1760mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AC2                          1761mm     ENDC
00000AC2                          1762mm     
00000AC2                 FALSE    1763mm     IFNE DEBUG
00000AC2                          1764mm     ENDC
00000AC2                          1765mm 
00000AC2                          1766mm     ENDM
00000AC2  7E07                    1767m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AC4                          1768m LOOP_112
00000AC4                          1769mm     BIN2HEX D4,D6,A0
00000AC4  41F9 00000FD4           1770mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000ACA  E99C                    1771mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000ACC  1C04                    1772mm     MOVE.B D4,D6
00000ACE  0286 0000000F           1773mm     ANDI.L #$F,D6
00000AD4  1C30 6000               1774mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000AD8                          1775mm     ENDM
00000AD8                          1776mm     PRINT_CHAR D6,D3
00000AD8                          1777mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1778mm     IFEQ DEBUG
00000AD8  1639 00C00003           1779mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000ADE  0803 0002               1780mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1781mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000AE4  13C6 00C00007           1782mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AEA                          1783mm     ENDC
00000AEA                          1784mm     
00000AEA                 FALSE    1785mm     IFNE DEBUG
00000AEA                          1786mm     ENDC
00000AEA                          1787mm 
00000AEA                          1788mm     ENDM
00000AEA  57CF FFD8               1789m     DBEQ D7,LOOP_112
00000AEE                          1790m     ENDM
00000AEE                          1791m         PRINT_CRLF D3
00000AEE                          1792mm     PRINT_CHAR #13,D3                           ; CR
00000AEE                          1793mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEE                 TRUE     1794mm     IFEQ DEBUG
00000AEE  1639 00C00003           1795mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AF4  0803 0002               1796mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AF8  67F4                    1797mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AFA  13FC 000D 00C00007      1798mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B02                          1799mm     ENDC
00000B02                          1800mm     
00000B02                 FALSE    1801mm     IFNE DEBUG
00000B02                          1802mm     ENDC
00000B02                          1803mm 
00000B02                          1804mm     ENDM
00000B02                          1805mm     PRINT_CHAR #10,D3                           ; LF
00000B02                          1806mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B02                 TRUE     1807mm     IFEQ DEBUG
00000B02  1639 00C00003           1808mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B08  0803 0002               1809mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B0C  67F4                    1810mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B0E  13FC 000A 00C00007      1811mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B16                          1812mm     ENDC
00000B16                          1813mm     
00000B16                 FALSE    1814mm     IFNE DEBUG
00000B16                          1815mm     ENDC
00000B16                          1816mm 
00000B16                          1817mm     ENDM
00000B16                          1818m     ENDM
00000B16  6000 F66C               1819          BRA MAIN_LOOP
00000B1A                          1820      ENDI
00000B1A                          1821s _00000008
00000B1A                          1822      
00000B1A  4ED1                    1823      JMP (A1)
00000B1C                          1824  DOWNLOAD_DONE
00000B1C                          1825m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00000B1C                          1826mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000B1C                          1827mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1C                 TRUE     1828mm     IFEQ DEBUG
00000B1C  1639 00C00003           1829mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B22  0803 0002               1830mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B26  67F4                    1831mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B28  13FC 0030 00C00007      1832mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B30                          1833mm     ENDC
00000B30                          1834mm     
00000B30                 FALSE    1835mm     IFNE DEBUG
00000B30                          1836mm     ENDC
00000B30                          1837mm 
00000B30                          1838mm     ENDM
00000B30                          1839mm     PRINT_CHAR #'x',D3
00000B30                          1840mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1841mm     IFEQ DEBUG
00000B30  1639 00C00003           1842mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1843mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1844mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000B3C  13FC 0078 00C00007      1845mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B44                          1846mm     ENDC
00000B44                          1847mm     
00000B44                 FALSE    1848mm     IFNE DEBUG
00000B44                          1849mm     ENDC
00000B44                          1850mm 
00000B44                          1851mm     ENDM
00000B44  7C07                    1852m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1853m LOOP_120
00000B46                          1854mm     BIN2HEX D4,D7,A0
00000B46  41F9 00000FD4           1855mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000B4C  E99C                    1856mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1E04                    1857mm     MOVE.B D4,D7
00000B50  0287 0000000F           1858mm     ANDI.L #$F,D7
00000B56  1E30 7000               1859mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1860mm     ENDM
00000B5A                          1861mm     PRINT_CHAR D7,D3
00000B5A                          1862mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1863mm     IFEQ DEBUG
00000B5A  1639 00C00003           1864mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B60  0803 0002               1865mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1866mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B66  13C7 00C00007           1867mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1868mm     ENDC
00000B6C                          1869mm     
00000B6C                 FALSE    1870mm     IFNE DEBUG
00000B6C                          1871mm     ENDC
00000B6C                          1872mm 
00000B6C                          1873mm     ENDM
00000B6C  57CE FFD8               1874m     DBEQ D6,LOOP_120
00000B70                          1875m     ENDM
00000B70  41F9 00000F77           1876      LEA READ,A0
00000B76                          1877m     PRINT_STR A0,D3
00000B76                          1878m LOOP_125
00000B76  0C10 0000               1879m     CMP.B #0,(A0)                               ; 0 -> DONE
00000B7A  6700 0016               1880m     BEQ EXIT_125
00000B7E                          1881mm     PRINT_CHAR (A0)+,D3
00000B7E                          1882mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1883mm     IFEQ DEBUG
00000B7E  1639 00C00003           1884mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B84  0803 0002               1885mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1886mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B8A  13D8 00C00007           1887mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1888mm     ENDC
00000B90                          1889mm     
00000B90                 FALSE    1890mm     IFNE DEBUG
00000B90                          1891mm     ENDC
00000B90                          1892mm 
00000B90                          1893mm     ENDM
00000B90  60E4                    1894m     BRA LOOP_125
00000B92                          1895m EXIT_125
00000B92                          1896m     ENDM
00000B92  2E0A                    1897      MOVE.L A2,D7                                ; set address accumulator to start address
00000B94                          1898m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00000B94                          1899mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000B94                          1900mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B94                 TRUE     1901mm     IFEQ DEBUG
00000B94  1639 00C00003           1902mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B9A  0803 0002               1903mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B9E  67F4                    1904mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BA0  13FC 0030 00C00007      1905mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BA8                          1906mm     ENDC
00000BA8                          1907mm     
00000BA8                 FALSE    1908mm     IFNE DEBUG
00000BA8                          1909mm     ENDC
00000BA8                          1910mm 
00000BA8                          1911mm     ENDM
00000BA8                          1912mm     PRINT_CHAR #'x',D3
00000BA8                          1913mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA8                 TRUE     1914mm     IFEQ DEBUG
00000BA8  1639 00C00003           1915mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BAE  0803 0002               1916mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BB2  67F4                    1917mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BB4  13FC 0078 00C00007      1918mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BBC                          1919mm     ENDC
00000BBC                          1920mm     
00000BBC                 FALSE    1921mm     IFNE DEBUG
00000BBC                          1922mm     ENDC
00000BBC                          1923mm 
00000BBC                          1924mm     ENDM
00000BBC  7C07                    1925m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBE                          1926m LOOP_127
00000BBE                          1927mm     BIN2HEX D7,D2,A0
00000BBE  41F9 00000FD4           1928mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000BC4  E99F                    1929mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC6  1407                    1930mm     MOVE.B D7,D2
00000BC8  0282 0000000F           1931mm     ANDI.L #$F,D2
00000BCE  1430 2000               1932mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BD2                          1933mm     ENDM
00000BD2                          1934mm     PRINT_CHAR D2,D3
00000BD2                          1935mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                 TRUE     1936mm     IFEQ DEBUG
00000BD2  1639 00C00003           1937mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BD8  0803 0002               1938mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BDC  67F4                    1939mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000BDE  13C2 00C00007           1940mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BE4                          1941mm     ENDC
00000BE4                          1942mm     
00000BE4                 FALSE    1943mm     IFNE DEBUG
00000BE4                          1944mm     ENDC
00000BE4                          1945mm 
00000BE4                          1946mm     ENDM
00000BE4  57CE FFD8               1947m     DBEQ D6,LOOP_127
00000BE8                          1948m     ENDM
00000BE8                          1949m     PRINT_CRLF D3     
00000BE8                          1950mm     PRINT_CHAR #13,D3                           ; CR
00000BE8                          1951mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE8                 TRUE     1952mm     IFEQ DEBUG
00000BE8  1639 00C00003           1953mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BEE  0803 0002               1954mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BF2  67F4                    1955mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000BF4  13FC 000D 00C00007      1956mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BFC                          1957mm     ENDC
00000BFC                          1958mm     
00000BFC                 FALSE    1959mm     IFNE DEBUG
00000BFC                          1960mm     ENDC
00000BFC                          1961mm 
00000BFC                          1962mm     ENDM
00000BFC                          1963mm     PRINT_CHAR #10,D3                           ; LF
00000BFC                          1964mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BFC                 TRUE     1965mm     IFEQ DEBUG
00000BFC  1639 00C00003           1966mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C02  0803 0002               1967mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C06  67F4                    1968mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C08  13FC 000A 00C00007      1969mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000C10                          1970mm     ENDC
00000C10                          1971mm     
00000C10                 FALSE    1972mm     IFNE DEBUG
00000C10                          1973mm     ENDC
00000C10                          1974mm 
00000C10                          1975mm     ENDM
00000C10                          1976m     ENDM
00000C10                          1977          
00000C10  6000 F572               1978      BRA MAIN_LOOP
00000C14                          1979      
00000C14                          1980  G
00000C14  2047                    1981      MOVE.L D7,A0                                ; address accumulator -> address register
00000C16  3E3C 0000               1982      MOVE #0,D7                                  ; clear the now used address accumulator
00000C1A  4ED0                    1983      JMP (A0)                                    ; jump to it!
00000C1C                          1984      
00000C1C                          1985  Z
00000C1C  207C 00200000           1986      MOVE.L #RAM,A0                              ; address of RAM
00000C22  7000                    1987      MOVE.L #0,D0                                ; number of bytes
00000C24                          1988     
00000C24                          1989      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C24                          1990s _10000014
00000C24  B0BC 00040000           1991s     CMP.L   #$40000,D0
00000C2A  6E00 001A               1992s     BGT _10000015
00000C2E  2200                    1993          MOVE.L D0,D1                            ; progress update
00000C30  E089                    1994          LSR.L #8,D1 
00000C32  E089                    1995          LSR.L #8,D1
00000C34  0281 0000000F           1996          ANDI.L #$F,D1
00000C3A  13C1 00E00001           1997          MOVE.B D1,DISPLAY
00000C40                          1998  
00000C40  20C0                    1999          MOVE.L D0,(A0)+ 
00000C42  5880                    2000          ADD.L #4,D0
00000C44                          2001      ENDW
00000C44  60DE                    2002s     BRA _10000014
00000C46                          2003s _10000015
00000C46                          2004   
00000C46  207C 00200000           2005      MOVE.L #RAM,A0                              ; address of RAM
00000C4C  7000                    2006      MOVE.L #0,D0                                ; number of bytes
00000C4E                          2007     
00000C4E                          2008      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C4E                          2009s _10000016
00000C4E  B0BC 00040000           2010s     CMP.L   #$40000,D0
00000C54  6E00 00C8               2011s     BGT _10000017
00000C58  2200                    2012          MOVE.L D0,D1                            ; progress update
00000C5A  E089                    2013          LSR.L #8,D1
00000C5C  E089                    2014          LSR.L #8,D1
00000C5E  0281 0000000F           2015          ANDI.L #$F,D1
00000C64  13C1 00E00001           2016          MOVE.B D1,DISPLAY
00000C6A                          2017  
00000C6A  2218                    2018          MOVE.L (A0)+,D1
00000C6C                          2019            
00000C6C                          2020          IF.L D0 <EQ> D1 THEN
00000C6C  B081                    2021s     CMP.L   D1,D0
00000C6E  6600 0006               2022s     BNE _00000009
00000C72  6000 00A4               2023              BRA OK
00000C76                          2024          ENDI 
00000C76                          2025s _00000009
00000C76                          2026            
00000C76  43F9 00000FC2           2027          LEA RAM_ERROR,A1
00000C7C                          2028m         PRINT_STR A1,D1
00000C7C                          2029m LOOP_135
00000C7C  0C11 0000               2030m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C80  6700 0016               2031m     BEQ EXIT_135
00000C84                          2032mm     PRINT_CHAR (A1)+,D1
00000C84                          2033mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C84                 TRUE     2034mm     IFEQ DEBUG
00000C84  1239 00C00003           2035mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C8A  0801 0002               2036mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C8E  67F4                    2037mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C90  13D9 00C00007           2038mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C96                          2039mm     ENDC
00000C96                          2040mm     
00000C96                 FALSE    2041mm     IFNE DEBUG
00000C96                          2042mm     ENDC
00000C96                          2043mm 
00000C96                          2044mm     ENDM
00000C96  60E4                    2045m     BRA LOOP_135
00000C98                          2046m EXIT_135
00000C98                          2047m     ENDM
00000C98  2208                    2048          MOVE.L A0,D1
00000C9A  5981                    2049          SUB.L #4,D1
00000C9C                          2050m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C9C                          2051mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000C9C                          2052mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9C                 TRUE     2053mm     IFEQ DEBUG
00000C9C  1639 00C00003           2054mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CA2  0803 0002               2055mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA6  67F4                    2056mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000CA8  13FC 0030 00C00007      2057mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CB0                          2058mm     ENDC
00000CB0                          2059mm     
00000CB0                 FALSE    2060mm     IFNE DEBUG
00000CB0                          2061mm     ENDC
00000CB0                          2062mm 
00000CB0                          2063mm     ENDM
00000CB0                          2064mm     PRINT_CHAR #'x',D3
00000CB0                          2065mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB0                 TRUE     2066mm     IFEQ DEBUG
00000CB0  1639 00C00003           2067mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB6  0803 0002               2068mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CBA  67F4                    2069mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CBC  13FC 0078 00C00007      2070mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CC4                          2071mm     ENDC
00000CC4                          2072mm     
00000CC4                 FALSE    2073mm     IFNE DEBUG
00000CC4                          2074mm     ENDC
00000CC4                          2075mm 
00000CC4                          2076mm     ENDM
00000CC4  7C07                    2077m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CC6                          2078m LOOP_137
00000CC6                          2079mm     BIN2HEX D1,D2,A1
00000CC6  43F9 00000FD4           2080mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000CCC  E999                    2081mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CCE  1401                    2082mm     MOVE.B D1,D2
00000CD0  0282 0000000F           2083mm     ANDI.L #$F,D2
00000CD6  1431 2000               2084mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000CDA                          2085mm     ENDM
00000CDA                          2086mm     PRINT_CHAR D2,D3
00000CDA                          2087mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDA                 TRUE     2088mm     IFEQ DEBUG
00000CDA  1639 00C00003           2089mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE0  0803 0002               2090mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE4  67F4                    2091mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CE6  13C2 00C00007           2092mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CEC                          2093mm     ENDC
00000CEC                          2094mm     
00000CEC                 FALSE    2095mm     IFNE DEBUG
00000CEC                          2096mm     ENDC
00000CEC                          2097mm 
00000CEC                          2098mm     ENDM
00000CEC  57CE FFD8               2099m     DBEQ D6,LOOP_137
00000CF0                          2100m     ENDM
00000CF0                          2101m         PRINT_CRLF D3
00000CF0                          2102mm     PRINT_CHAR #13,D3                           ; CR
00000CF0                          2103mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF0                 TRUE     2104mm     IFEQ DEBUG
00000CF0  1639 00C00003           2105mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CF6  0803 0002               2106mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CFA  67F4                    2107mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CFC  13FC 000D 00C00007      2108mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D04                          2109mm     ENDC
00000D04                          2110mm     
00000D04                 FALSE    2111mm     IFNE DEBUG
00000D04                          2112mm     ENDC
00000D04                          2113mm 
00000D04                          2114mm     ENDM
00000D04                          2115mm     PRINT_CHAR #10,D3                           ; LF
00000D04                          2116mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D04                 TRUE     2117mm     IFEQ DEBUG
00000D04  1639 00C00003           2118mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D0A  0803 0002               2119mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0E  67F4                    2120mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D10  13FC 000A 00C00007      2121mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D18                          2122mm     ENDC
00000D18                          2123mm     
00000D18                 FALSE    2124mm     IFNE DEBUG
00000D18                          2125mm     ENDC
00000D18                          2126mm 
00000D18                          2127mm     ENDM
00000D18                          2128m     ENDM
00000D18                          2129  OK    
00000D18  5880                    2130          ADD.L #4,D0
00000D1A                          2131      ENDW
00000D1A  6000 FF32               2132s     BRA _10000016
00000D1E                          2133s _10000017
00000D1E                          2134      
00000D1E  6000 F464               2135      BRA MAIN_LOOP
00000D22                          2136    
00000D22                          2137  L
00000D22  7A00                    2138      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000D24                          2139  
00000D24                          2140m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000D24                          2141m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D24                          2142m 
00000D24                 TRUE     2143m     IFEQ DEBUG
00000D24  1639 00C00003           2144m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D2A  0803 0000               2145m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D2E  67F4                    2146m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D30                          2147m     ENDC
00000D30                          2148m     
00000D30                          2149mm     READ_CHAR D2
00000D30                 TRUE     2150mm     IFEQ DEBUG
00000D30  1439 00C00007           2151mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D36                          2152mm     ENDC
00000D36                 FALSE    2153mm     IFNE DEBUG
00000D36                          2154mm     ENDC
00000D36                          2155mm      
00000D36  B43C 001B               2156mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D3A  6700 F2CC               2157mm     BEQ START
00000D3E                          2158mm     ENDM
00000D3E                          2159m 
00000D3E                 TRUE     2160m     IFEQ DEBUG
00000D3E                          2161mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D3E                          2162mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                 TRUE     2163mm     IFEQ DEBUG
00000D3E  1639 00C00003           2164mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D44  0803 0002               2165mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D48  67F4                    2166mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D4A  13C2 00C00007           2167mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D50                          2168mm     ENDC
00000D50                          2169mm     
00000D50                 FALSE    2170mm     IFNE DEBUG
00000D50                          2171mm     ENDC
00000D50                          2172mm 
00000D50                          2173mm     ENDM
00000D50                          2174m     ENDC
00000D50                          2175m     ENDM
00000D50                          2176m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D50  41F9 00000FE4           2177m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D56  0402 0030               2178m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D5A  C4BC 000000FF           2179m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D60  1430 2000               2180m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D64                          2181m     ENDM
00000D64  1A02                    2182      MOVE.B D2,D5                                ; put at bottom of D5
00000D66                          2183  
00000D66  3C3C 0002               2184      MOVE #2,D6                                  ; 3 bytes left to read
00000D6A                          2185      
00000D6A                          2186  READ_LENGTH
00000D6A  E98D                    2187      LSL.L #4,D5                                 ; make what we have so far more significant
00000D6C                          2188m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D6C                          2189m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6C                          2190m 
00000D6C                 TRUE     2191m     IFEQ DEBUG
00000D6C  1639 00C00003           2192m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D72  0803 0000               2193m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D76  67F4                    2194m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D78                          2195m     ENDC
00000D78                          2196m     
00000D78                          2197mm     READ_CHAR D2
00000D78                 TRUE     2198mm     IFEQ DEBUG
00000D78  1439 00C00007           2199mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D7E                          2200mm     ENDC
00000D7E                 FALSE    2201mm     IFNE DEBUG
00000D7E                          2202mm     ENDC
00000D7E                          2203mm      
00000D7E  B43C 001B               2204mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D82  6700 F284               2205mm     BEQ START
00000D86                          2206mm     ENDM
00000D86                          2207m 
00000D86                 TRUE     2208m     IFEQ DEBUG
00000D86                          2209mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D86                          2210mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D86                 TRUE     2211mm     IFEQ DEBUG
00000D86  1639 00C00003           2212mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D8C  0803 0002               2213mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D90  67F4                    2214mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000D92  13C2 00C00007           2215mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D98                          2216mm     ENDC
00000D98                          2217mm     
00000D98                 FALSE    2218mm     IFNE DEBUG
00000D98                          2219mm     ENDC
00000D98                          2220mm 
00000D98                          2221mm     ENDM
00000D98                          2222m     ENDC
00000D98                          2223m     ENDM
00000D98                          2224m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D98  41F9 00000FE4           2225m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D9E  0402 0030               2226m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DA2  C4BC 000000FF           2227m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000DA8  1430 2000               2228m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000DAC                          2229m     ENDM
00000DAC  8A02                    2230      OR.B D2,D5
00000DAE  023C 00FB               2231      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DB2  57CE FFB6               2232      DBEQ D6,READ_LENGTH
00000DB6                          2233          
00000DB6                          2234m     PRINT_CRLF D3
00000DB6                          2235mm     PRINT_CHAR #13,D3                           ; CR
00000DB6                          2236mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB6                 TRUE     2237mm     IFEQ DEBUG
00000DB6  1639 00C00003           2238mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DBC  0803 0002               2239mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DC0  67F4                    2240mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC2  13FC 000D 00C00007      2241mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DCA                          2242mm     ENDC
00000DCA                          2243mm     
00000DCA                 FALSE    2244mm     IFNE DEBUG
00000DCA                          2245mm     ENDC
00000DCA                          2246mm 
00000DCA                          2247mm     ENDM
00000DCA                          2248mm     PRINT_CHAR #10,D3                           ; LF
00000DCA                          2249mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DCA                 TRUE     2250mm     IFEQ DEBUG
00000DCA  1639 00C00003           2251mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DD0  0803 0002               2252mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DD4  67F4                    2253mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000DD6  13FC 000A 00C00007      2254mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DDE                          2255mm     ENDC
00000DDE                          2256mm     
00000DDE                 FALSE    2257mm     IFNE DEBUG
00000DDE                          2258mm     ENDC
00000DDE                          2259mm 
00000DDE                          2260mm     ENDM
00000DDE                          2261m     ENDM
00000DDE                          2262  
00000DDE  207C 00000000           2263      MOVE.L #ROM,A0                              ; start of ROM
00000DE4                          2264      
00000DE4  2247                    2265      MOVE.L D7,A1                                ; address accumulator -> address register
00000DE6  7E00                    2266      MOVE.L #0,D7                                ; clear the now used address accumulator
00000DE8                          2267      
00000DE8  267C 00002AAA           2268      MOVE.L #$2AAA,A3
00000DEE  36BC AAAA               2269      MOVE.W #$AAAA,(A3)
00000DF2  267C 00001554           2270      MOVE.L #$1554,A3
00000DF8  36BC 5555               2271      MOVE.W #$5555,(A3)
00000DFC  267C 00002AAA           2272      MOVE.L #$2AAA,A3
00000E02  36BC 8080               2273      MOVE.W #$8080,(A3)
00000E06  267C 00002AAA           2274      MOVE.L #$2AAA,A3
00000E0C  36BC AAAA               2275      MOVE.W #$AAAA,(A3)
00000E10  267C 00001554           2276      MOVE.L #$1554,A3
00000E16  36BC 5555               2277      MOVE.W #$5555,(A3)
00000E1A  267C 00002AAA           2278      MOVE.L #$2AAA,A3
00000E20  36BC 2020               2279      MOVE.W #$2020,(A3)
00000E24                          2280      
00000E24  45F9 00000FFB           2281      LEA LOADING,A2                              ; important for timing
00000E2A                          2282m     PRINT_STR A2,D3
00000E2A                          2283m LOOP_156
00000E2A  0C12 0000               2284m     CMP.B #0,(A2)                               ; 0 -> DONE
00000E2E  6700 0016               2285m     BEQ EXIT_156
00000E32                          2286mm     PRINT_CHAR (A2)+,D3
00000E32                          2287mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E32                 TRUE     2288mm     IFEQ DEBUG
00000E32  1639 00C00003           2289mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E38  0803 0002               2290mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E3C  67F4                    2291mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E3E  13DA 00C00007           2292mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E44                          2293mm     ENDC
00000E44                          2294mm     
00000E44                 FALSE    2295mm     IFNE DEBUG
00000E44                          2296mm     ENDC
00000E44                          2297mm 
00000E44                          2298mm     ENDM
00000E44  60E4                    2299m     BRA LOOP_156
00000E46                          2300m EXIT_156
00000E46                          2301m     ENDM
00000E46                          2302  
00000E46  023C 00FB               2303      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000E4A                          2304      
00000E4A                          2305      WHILE D5 <GT> #0 DO
00000E4A                          2306s _10000018
00000E4A  BA7C 0000               2307s     CMP.W   #0,D5
00000E4E  6F00 001C               2308s     BLE _10000019
00000E52  5585                    2309          SUB.L #2,D5
00000E54                          2310            
00000E54  13D1 00E00001           2311          MOVE.B (A1),DISPLAY
00000E5A  3091                    2312          MOVE.W (A1),(A0)                        ; write the data
00000E5C                          2313        
00000E5C                          2314  WAIT_FOR_COMPLETE
00000E5C  3410                    2315          MOVE.W (A0),D2
00000E5E                          2316  
00000E5E                          2317          IF D2 <NE> (A1) THEN
00000E5E  B451                    2318s     CMP.W   (A1),D2
00000E60  6700 0004               2319s     BEQ _0000000A
00000E64  60F6                    2320              BRA WAIT_FOR_COMPLETE
00000E66                          2321          ENDI
00000E66                          2322s _0000000A
00000E66                          2323        
00000E66  5488                    2324          ADD.L #2,A0
00000E68  5489                    2325          ADD.L #2,A1
00000E6A                          2326      ENDW  
00000E6A  60DE                    2327s     BRA _10000018
00000E6C                          2328s _10000019
00000E6C                          2329      
00000E6C  267C 00002AAA           2330      MOVE.L #$2AAA,A3
00000E72  36BC AAAA               2331      MOVE.W #$AAAA,(A3)
00000E76  267C 00001554           2332      MOVE.L #$1554,A3
00000E7C  36BC 5555               2333      MOVE.W #$5555,(A3)
00000E80  267C 00002AAA           2334      MOVE.L #$2AAA,A3
00000E86  36BC A0A0               2335      MOVE.W #$A0A0,(A3)
00000E8A                          2336              
00000E8A  6000 F2F8               2337      BRA MAIN_LOOP
00000E8E                          2338          
00000E8E                          2339  HEX_DIGIT
00000E8E  E98F                    2340      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000E90                          2341m     HEX2BIN D2,D2,A0
00000E90  41F9 00000FE4           2342m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000E96  0402 0030               2343m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E9A  C4BC 000000FF           2344m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EA0  1430 2000               2345m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000EA4                          2346m     ENDM
00000EA4  8E02                    2347      OR.B D2,D7  
00000EA6  6000 F304               2348      BRA GET_INPUT
00000EAA                          2349  
00000EAA  FFFF FFFF               2350      SIMHALT                                     ; halt simulator
00000EAE                          2351  
00000EAE                          2352  ; strings
00000EAE= 4D 44 46 2D 6D 6F ...   2353  VERSION DC.B 'MDF-mon V1.49 (10/04/2021)',13,10,0
00000ECB= 3F 20 48 65 6C 70 ...   2354  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00000F70= 48 75 68 3F 0D 0A 00    2355  HUH     DC.B 'Huh?',13,10,0
00000F77= 20 53 20 72 65 63 ...   2356  READ    DC.B ' S records read, start address = ',0
00000F99= 57 3A 20 55 6E 6B ...   2357  UNREC   DC.B 'W: Unknown Srec type: ',0
00000FB0= 57 3A 20 43 53 20 ...   2358  CS_FAILURE   DC.B 'W: CS failure at ',0
00000FC2= 57 3A 20 52 41 4D ...   2359  RAM_ERROR DC.B 'W: RAM error at: ',0
00000FD4= 30 31 32 33 34 35 ...   2360  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000FE4= 00 01 02 03 04 05 ...   2361  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000FFB= 4C 6F 61 64 69 6E ...   2362  LOADING  DC.B 'Loading EEPROM...',13,11,0
0000100F                          2363      
0000100F                          2364      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         FD4
CONTINUE_103        9FE
CONTINUE_44         4A2
CONTINUE_47         4F2
CONTINUE_51         54A
CONTINUE_59         608
CONTINUE_64         67C
CONTINUE_69         6FA
CONTINUE_74         77E
CONTINUE_79         80C
CONTINUE_84         880
CONTINUE_89         8F4
CS_FAILURE          FB0
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       B1C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            A9A
EXIT_125            B92
EXIT_135            C98
EXIT_156            E46
EXIT_19             2E2
EXIT_21             308
EXIT_23             32E
EXIT_5              13E
EXIT_96             994
G                   C14
GET_INPUT           1AC
H                   2E6
HELP                ECB
HEX2BIN             134
HEX2BIN_LUT         FE4
HEX_DIGIT           E8E
HUH                 F70
L                   D22
LOADING             FFB
LOOP_110            A7E
LOOP_112            AC4
LOOP_120            B46
LOOP_125            B76
LOOP_127            BBE
LOOP_135            C7C
LOOP_137            CC6
LOOP_156            E2A
LOOP_19             2C6
LOOP_21             2EC
LOOP_23             312
LOOP_25             360
LOOP_5              122
LOOP_96             978
MAIN_LOOP           184
OK                  D18
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   332
RAM                 200000
RAM_ERROR           FC2
READ                F77
READ_CHAR           805
READ_DATA_TO_POKE   400
READ_LENGTH         D6A
RESET               4
ROM                 0
S                   47E
STACK               0
START               8
UNREC               F99
V                   30C
VERSION             EAE
W                   3B8
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E5C
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   166
WAIT_FOR_READY_100  9A6
WAIT_FOR_READY_101  9BA
WAIT_FOR_READY_103  9E2
WAIT_FOR_READY_105  A16
WAIT_FOR_READY_108  A48
WAIT_FOR_READY_109  A5C
WAIT_FOR_READY_11   184
WAIT_FOR_READY_111  A86
WAIT_FOR_READY_113  A9A
WAIT_FOR_READY_114  AAE
WAIT_FOR_READY_116  AD8
WAIT_FOR_READY_118  AEE
WAIT_FOR_READY_119  B02
WAIT_FOR_READY_12   198
WAIT_FOR_READY_121  B1C
WAIT_FOR_READY_122  B30
WAIT_FOR_READY_124  B5A
WAIT_FOR_READY_126  B7E
WAIT_FOR_READY_128  B94
WAIT_FOR_READY_129  BA8
WAIT_FOR_READY_13   1AC
WAIT_FOR_READY_131  BD2
WAIT_FOR_READY_133  BE8
WAIT_FOR_READY_134  BFC
WAIT_FOR_READY_136  C84
WAIT_FOR_READY_138  C9C
WAIT_FOR_READY_139  CB0
WAIT_FOR_READY_141  CDA
WAIT_FOR_READY_143  CF0
WAIT_FOR_READY_144  D04
WAIT_FOR_READY_145  D24
WAIT_FOR_READY_147  D3E
WAIT_FOR_READY_149  D6C
WAIT_FOR_READY_15   1C6
WAIT_FOR_READY_151  D86
WAIT_FOR_READY_154  DB6
WAIT_FOR_READY_155  DCA
WAIT_FOR_READY_157  E32
WAIT_FOR_READY_17   268
WAIT_FOR_READY_18   27C
WAIT_FOR_READY_20   2CE
WAIT_FOR_READY_22   2F4
WAIT_FOR_READY_24   31A
WAIT_FOR_READY_26   336
WAIT_FOR_READY_27   34A
WAIT_FOR_READY_29   374
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_32   39E
WAIT_FOR_READY_33   3BA
WAIT_FOR_READY_35   3D4
WAIT_FOR_READY_37   402
WAIT_FOR_READY_39   41C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   452
WAIT_FOR_READY_43   466
WAIT_FOR_READY_44   486
WAIT_FOR_READY_46   4C0
WAIT_FOR_READY_47   4D6
WAIT_FOR_READY_49   50A
WAIT_FOR_READY_51   52E
WAIT_FOR_READY_53   562
WAIT_FOR_READY_56   59C
WAIT_FOR_READY_57   5B0
WAIT_FOR_READY_59   5EC
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   620
WAIT_FOR_READY_64   660
WAIT_FOR_READY_66   694
WAIT_FOR_READY_69   6DE
WAIT_FOR_READY_71   712
WAIT_FOR_READY_74   762
WAIT_FOR_READY_76   796
WAIT_FOR_READY_79   7F0
WAIT_FOR_READY_8    13E
WAIT_FOR_READY_81   824
WAIT_FOR_READY_84   864
WAIT_FOR_READY_86   898
WAIT_FOR_READY_89   8D8
WAIT_FOR_READY_9    152
WAIT_FOR_READY_91   90C
WAIT_FOR_READY_94   94A
WAIT_FOR_READY_95   95E
WAIT_FOR_READY_97   980
WAIT_FOR_READY_98   994
WAIT_FOR_SRECORD    486
Z                   C1C
_00000000           5CC
_00000001           9D2
_00000002           5DA
_00000003           7D8
_00000004           744
_00000005           9D2
_00000006           94A
_00000007           9D2
_00000008           B1A
_00000009           C76
_0000000A           E66
_10000000           524
_10000001           58E
_10000002           5E2
_10000003           64C
_10000004           656
_10000005           6C0
_10000006           6D4
_10000007           73E
_10000008           748
_10000009           7D0
_1000000A           758
_1000000B           7C2
_1000000C           7E6
_1000000D           850
_1000000E           85A
_1000000F           8C4
_10000010           8CE
_10000011           938
_10000012           9D8
_10000013           A42
_10000014           C24
_10000015           C46
_10000016           C4E
_10000017           D1E
_10000018           E4A
_10000019           E6C
