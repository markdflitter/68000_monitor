00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 14/04/2021 18:53:07

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 00000000                 270  STACK   DC.L 0                                      ; STACK
00000004= 00000008                 271  RESET   DC.L START                                  ; RESET
00000008                           272  
00000008                           273  ; start of program  
00000008                           274  START
00000008  13FC 0000 00E00001       275      MOVE.B #0,DISPLAY
00000010                           276  
00000010                           277  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       278      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       279      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           280      
00000020                           281      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                282s     MOVE.W  #$50,D1
00000024  6000 000E                283s     BRA _20000001
00000028                           284s _20000000
00000028  13C1 00C00005            285          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     286          NOP
00000030                           287      ENDF
00000030  0441 0010                288s     SUB.W   #$10,D1
00000034                           289s _20000001
00000034  B27C 0010                290s     CMP.W   #$10,D1
00000038  6CEE                     291s     BGE _20000000
0000003A                           292  
0000003A                           293      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                294s     MOVE.W  #$50,D1
0000003E  6000 000E                295s     BRA _20000003
00000042                           296s _20000002
00000042  13C1 00C00015            297          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     298          NOP
0000004A                           299      ENDF
0000004A  0441 0010                300s     SUB.W   #$10,D1
0000004E                           301s _20000003
0000004E  B27C 0010                302s     CMP.W   #$10,D1
00000052  6CEE                     303s     BGE _20000002
00000054                           304      
00000054                           305  ;initialise UART
00000054  13FC 0000 00C00009       306      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       307      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       308      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           309  
0000006C                           310  ; channel A
0000006C  13FC 0013 00C00001       311      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       312      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       313      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       314      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           315  
0000008C                           316  ; channel B
0000008C  13FC 0013 00C00011       317      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       318      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       319      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       320      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           321  
000000AC                           322m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           323m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      324m     IFEQ DEBUG
000000AC  1239 00C00003            325m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                326m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     327m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       328m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           329m     ENDC
000000C0                           330m 
000000C0                 FALSE     331m     IFNE DEBUG
000000C0                           332m     ENDC
000000C0                           333m 
000000C0                           334m     ENDM
000000C0                           335m     PRINT_CHAR #0,D1
000000C0                           336m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      337m     IFEQ DEBUG
000000C0  1239 00C00003            338m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                339m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     340m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       341m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           342m     ENDC
000000D4                           343m 
000000D4                 FALSE     344m     IFNE DEBUG
000000D4                           345m     ENDC
000000D4                           346m 
000000D4                           347m     ENDM
000000D4                           348m     PRINT_CHAR #0,D1
000000D4                           349m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      350m     IFEQ DEBUG
000000D4  1239 00C00003            351m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                352m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     353m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       354m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           355m     ENDC
000000E8                           356m 
000000E8                 FALSE     357m     IFNE DEBUG
000000E8                           358m     ENDC
000000E8                           359m 
000000E8                           360m     ENDM
000000E8                           361  
000000E8  13FC 0001 00E00001       362      MOVE.B #1,DISPLAY
000000F0                           363  
000000F0                           364m     PRINT_CRLF D1,A0
000000F0  41FA 11E0                365m     LEA CRLF(PC),A0
000000F4                           366mm     PRINT_STR A0,D1
000000F4                           367mm LOOP_5
000000F4  0C10 0000                368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                369mm     BEQ EXIT_5
000000FC                           370mmm     PRINT_CHAR (A0)+,D1
000000FC                           371mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      372mmm     IFEQ DEBUG
000000FC  1239 00C00003            373mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                374mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     375mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           377mmm     ENDC
0000010E                           378mmm 
0000010E                 FALSE     379mmm     IFNE DEBUG
0000010E                           380mmm     ENDC
0000010E                           381mmm 
0000010E                           382mmm     ENDM
0000010E  60E4                     383mm     BRA LOOP_5
00000110                           384mm EXIT_5
00000110                           385mm     ENDM
00000110                           386m     ENDM
00000110  41FA 11E4                387      LEA VERSION(PC),A0
00000114                           388m     PRINT_STR A0,D3
00000114                           389m LOOP_7
00000114  0C10 0000                390m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                391m     BEQ EXIT_7
0000011C                           392mm     PRINT_CHAR (A0)+,D3
0000011C                           393mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      394mm     IFEQ DEBUG
0000011C  1639 00C00003            395mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                396mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     397mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            398mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           399mm     ENDC
0000012E                           400mm 
0000012E                 FALSE     401mm     IFNE DEBUG
0000012E                           402mm     ENDC
0000012E                           403mm 
0000012E                           404mm     ENDM
0000012E  60E4                     405m     BRA LOOP_7
00000130                           406m EXIT_7
00000130                           407m     ENDM
00000130                           408  
00000130  41FA 0FD6                409      LEA HELPPROMPT(PC),A0
00000134                           410m     PRINT_STR A0,D3
00000134                           411m LOOP_9
00000134  0C10 0000                412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                413m     BEQ EXIT_9
0000013C                           414mm     PRINT_CHAR (A0)+,D3
0000013C                           415mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      416mm     IFEQ DEBUG
0000013C  1639 00C00003            417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     419mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           421mm     ENDC
0000014E                           422mm 
0000014E                 FALSE     423mm     IFNE DEBUG
0000014E                           424mm     ENDC
0000014E                           425mm 
0000014E                           426mm     ENDM
0000014E  60E4                     427m     BRA LOOP_9
00000150                           428m EXIT_9
00000150                           429m     ENDM
00000150                           430  
00000150                           431m     PRINT_CRLF D3,A0
00000150  41FA 1180                432m     LEA CRLF(PC),A0
00000154                           433mm     PRINT_STR A0,D3
00000154                           434mm LOOP_12
00000154  0C10 0000                435mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                436mm     BEQ EXIT_12
0000015C                           437mmm     PRINT_CHAR (A0)+,D3
0000015C                           438mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      439mmm     IFEQ DEBUG
0000015C  1639 00C00003            440mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                441mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     442mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            443mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           444mmm     ENDC
0000016E                           445mmm 
0000016E                 FALSE     446mmm     IFNE DEBUG
0000016E                           447mmm     ENDC
0000016E                           448mmm 
0000016E                           449mmm     ENDM
0000016E  60E4                     450mm     BRA LOOP_12
00000170                           451mm EXIT_12
00000170                           452mm     ENDM
00000170                           453m     ENDM
00000170                           454  
00000170  7E00                     455      MOVE.L #0,D7                                    ; address accumulator
00000172                           456  
00000172  13FC 0002 00E00001       457      MOVE.B #2,DISPLAY
0000017A                           458  MAIN_LOOP
0000017A  41FA 1159                459      LEA PROMPT(PC),A0
0000017E                           460m     PRINT_STR A0,D3
0000017E                           461m LOOP_14
0000017E  0C10 0000                462m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                463m     BEQ EXIT_14
00000186                           464mm     PRINT_CHAR (A0)+,D3
00000186                           465mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      466mm     IFEQ DEBUG
00000186  1639 00C00003            467mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                468mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     469mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            470mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           471mm     ENDC
00000198                           472mm 
00000198                 FALSE     473mm     IFNE DEBUG
00000198                           474mm     ENDC
00000198                           475mm 
00000198                           476mm     ENDM
00000198  60E4                     477m     BRA LOOP_14
0000019A                           478m EXIT_14
0000019A                           479m     ENDM
0000019A                           480  
0000019A                           481  GET_INPUT
0000019A                           482m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           483m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      484m     IFEQ DEBUG
0000019A  1639 00C00003            485m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                486m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     487m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           488m     ENDC
000001A6                           489m 
000001A6                           490mm     READ_CHAR D2
000001A6                 TRUE      491mm     IFEQ DEBUG
000001A6  1439 00C00007            492mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           493mm     ENDC
000001AC                 FALSE     494mm     IFNE DEBUG
000001AC                           495mm     ENDC
000001AC                           496mm 
000001AC  B43C 001B                497mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                498mm     BEQ START
000001B4                           499mm     ENDM
000001B4                           500m 
000001B4                 TRUE      501m     IFEQ DEBUG
000001B4                           502mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           503mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      504mm     IFEQ DEBUG
000001B4  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                506mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     507mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            508mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           509mm     ENDC
000001C6                           510mm 
000001C6                 FALSE     511mm     IFNE DEBUG
000001C6                           512mm     ENDC
000001C6                           513mm 
000001C6                           514mm     ENDM
000001C6                           515m     ENDC
000001C6                           516m     ENDM
000001C6                           517  
000001C6                           518      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                519s     CMP.B   #'0',D2
000001CA  6D00 000E                520s     BLT _00000000
000001CE  B43C 0039                521s     CMP.B   #'9',D2
000001D2  6E00 0006                522s     BGT _00000000
000001D6  6000 0F12                523          BRA HEX_DIGIT
000001DA                           524      ENDI
000001DA                           525s _00000000
000001DA                           526      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                527s     CMP.B   #'A',D2
000001DE  6D00 000E                528s     BLT _00000001
000001E2  B43C 0046                529s     CMP.B   #'F',D2
000001E6  6E00 0006                530s     BGT _00000001
000001EA  6000 0EFE                531          BRA HEX_DIGIT
000001EE                           532      ENDI
000001EE                           533s _00000001
000001EE                           534  
000001EE  B43C 0077                535      CMP.B #'w',D2
000001F2  6700 019A                536      BEQ W
000001F6                           537  
000001F6  B43C 006C                538      CMP.B #'l',D2
000001FA  6700 0A1E                539      BEQ L 
000001FE                           540  
000001FE  B43C 0070                541      CMP.B #'p',D2
00000202  6700 0C46                542      BEQ P
00000206                           543  
00000206  B43C 006D                544      CMP.B #'m',D2
0000020A  6700 0E10                545      BEQ M
0000020E                           546  
0000020E                           547m     PRINT_CRLF D3,A0
0000020E  41FA 10C2                548m     LEA CRLF(PC),A0
00000212                           549mm     PRINT_STR A0,D3
00000212                           550mm LOOP_20
00000212  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                552mm     BEQ EXIT_20
0000021A                           553mmm     PRINT_CHAR (A0)+,D3
0000021A                           554mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      555mmm     IFEQ DEBUG
0000021A  1639 00C00003            556mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                557mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     558mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            559mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           560mmm     ENDC
0000022C                           561mmm 
0000022C                 FALSE     562mmm     IFNE DEBUG
0000022C                           563mmm     ENDC
0000022C                           564mmm 
0000022C                           565mmm     ENDM
0000022C  60E4                     566mm     BRA LOOP_20
0000022E                           567mm EXIT_20
0000022E                           568mm     ENDM
0000022E                           569m     ENDM
0000022E                           570   
0000022E  B43C 003F                571      CMP.B #'?',D2
00000232  6700 0056                572      BEQ H
00000236                           573   
00000236  B43C 0076                574      CMP.B #'v',D2
0000023A  6700 0056                575      BEQ V
0000023E                           576      
0000023E  B43C 0072                577      CMP.B #'r',D2
00000242  6700 0072                578      BEQ R
00000246                           579  
00000246  B43C 0073                580      CMP.B #'s',D2
0000024A  6700 01B6                581      BEQ S
0000024E                           582  
0000024E  B43C 0067                583      CMP.B #'g',D2
00000252  6700 08DA                584      BEQ G   
00000256                           585  
00000256  B43C 007A                586      CMP.B #'z',D2
0000025A  6700 08DA                587      BEQ Z   
0000025E                           588  
0000025E  B43C 006A                589      CMP.B #'j',D2
00000262  6700 0E50                590      BEQ j
00000266                           591  
00000266  41FA 0FCB                592      LEA HUH(PC),A0
0000026A                           593m     PRINT_STR A0,D3
0000026A                           594m LOOP_22
0000026A  0C10 0000                595m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000026E  6700 0016                596m     BEQ EXIT_22
00000272                           597mm     PRINT_CHAR (A0)+,D3
00000272                           598mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000272                 TRUE      599mm     IFEQ DEBUG
00000272  1639 00C00003            600mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000278  0803 0002                601mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000027C  67F4                     602mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000027E  13D8 00C00007            603mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000284                           604mm     ENDC
00000284                           605mm 
00000284                 FALSE     606mm     IFNE DEBUG
00000284                           607mm     ENDC
00000284                           608mm 
00000284                           609mm     ENDM
00000284  60E4                     610m     BRA LOOP_22
00000286                           611m EXIT_22
00000286                           612m     ENDM
00000286                           613  
00000286  6000 FEF2                614      BRA MAIN_LOOP
0000028A                           615  
0000028A                           616  ; commands
0000028A                           617  H
0000028A  41FA 0E8F                618      LEA HELP(PC),A0
0000028E  6000 0006                619      BRA PRINTSTR
00000292                           620  
00000292                           621  V
00000292  41FA 1062                622      LEA VERSION(PC),A0
00000296                           623  PRINTSTR
00000296                           624m     PRINT_STR A0,D3    
00000296                           625m LOOP_24
00000296  0C10 0000                626m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000029A  6700 0016                627m     BEQ EXIT_24
0000029E                           628mm     PRINT_CHAR (A0)+,D3
0000029E                           629mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029E                 TRUE      630mm     IFEQ DEBUG
0000029E  1639 00C00003            631mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002A4  0803 0002                632mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A8  67F4                     633mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002AA  13D8 00C00007            634mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002B0                           635mm     ENDC
000002B0                           636mm 
000002B0                 FALSE     637mm     IFNE DEBUG
000002B0                           638mm     ENDC
000002B0                           639mm 
000002B0                           640mm     ENDM
000002B0  60E4                     641m     BRA LOOP_24
000002B2                           642m EXIT_24
000002B2                           643m     ENDM
000002B2  6000 FEC6                644      BRA MAIN_LOOP
000002B6                           645  
000002B6                           646  R
000002B6  2047                     647      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B8  7E00                     648      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002BA  2410                     649      MOVE.L (A0),D2                                  ; read the memory and print it
000002BC                           650m     PRINT_REG D2,D3,D4,D5,A0
000002BC  41FA 101A                651m     LEA OX(PC),A0
000002C0                           652mm     PRINT_STR A0,D3
000002C0                           653mm LOOP_27
000002C0  0C10 0000                654mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002C4  6700 0016                655mm     BEQ EXIT_27
000002C8                           656mmm     PRINT_CHAR (A0)+,D3
000002C8                           657mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      658mmm     IFEQ DEBUG
000002C8  1639 00C00003            659mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002CE  0803 0002                660mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002D2  67F4                     661mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            662mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002DA                           663mmm     ENDC
000002DA                           664mmm 
000002DA                 FALSE     665mmm     IFNE DEBUG
000002DA                           666mmm     ENDC
000002DA                           667mmm 
000002DA                           668mmm     ENDM
000002DA  60E4                     669mm     BRA LOOP_27
000002DC                           670mm EXIT_27
000002DC                           671mm     ENDM
000002DC  7A07                     672m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002DE                           673m LOOP_26
000002DE                           674mm     BIN2HEX D2,D4,A0
000002DE  41FA 0FB7                675mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002E2  E99A                     676mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002E4  1802                     677mm     MOVE.B D2,D4
000002E6  0284 0000000F            678mm     ANDI.L #$F,D4
000002EC  1830 4000                679mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002F0                           680mm     ENDM
000002F0                           681mm     PRINT_CHAR D4,D3
000002F0                           682mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      683mm     IFEQ DEBUG
000002F0  1639 00C00003            684mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F6  0803 0002                685mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002FA  67F4                     686mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002FC  13C4 00C00007            687mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000302                           688mm     ENDC
00000302                           689mm 
00000302                 FALSE     690mm     IFNE DEBUG
00000302                           691mm     ENDC
00000302                           692mm 
00000302                           693mm     ENDM
00000302  57CD FFDA                694m     DBEQ D5,LOOP_26
00000306                           695m     ENDM
00000306                           696      
00000306                           697m     PRINT_CHAR #32,D3
00000306                           698m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000306                 TRUE      699m     IFEQ DEBUG
00000306  1639 00C00003            700m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000030C  0803 0002                701m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000310  67F4                     702m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000312  13FC 0020 00C00007       703m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000031A                           704m     ENDC
0000031A                           705m 
0000031A                 FALSE     706m     IFNE DEBUG
0000031A                           707m     ENDC
0000031A                           708m 
0000031A                           709m     ENDM
0000031A                           710  
0000031A  E19A                     711      ROL.L #8,D2
0000031C                           712m     PRINT_CHAR D2,D3
0000031C                           713m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031C                 TRUE      714m     IFEQ DEBUG
0000031C  1639 00C00003            715m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000322  0803 0002                716m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000326  67F4                     717m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000328  13C2 00C00007            718m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000032E                           719m     ENDC
0000032E                           720m 
0000032E                 FALSE     721m     IFNE DEBUG
0000032E                           722m     ENDC
0000032E                           723m 
0000032E                           724m     ENDM
0000032E  E19A                     725      ROL.L #8,D2
00000330                           726m     PRINT_CHAR D2,D3
00000330                           727m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000330                 TRUE      728m     IFEQ DEBUG
00000330  1639 00C00003            729m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000336  0803 0002                730m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000033A  67F4                     731m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000033C  13C2 00C00007            732m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000342                           733m     ENDC
00000342                           734m 
00000342                 FALSE     735m     IFNE DEBUG
00000342                           736m     ENDC
00000342                           737m 
00000342                           738m     ENDM
00000342  E19A                     739      ROL.L #8,D2
00000344                           740m     PRINT_CHAR D2,D3
00000344                           741m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      742m     IFEQ DEBUG
00000344  1639 00C00003            743m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000034A  0803 0002                744m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000034E  67F4                     745m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000350  13C2 00C00007            746m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000356                           747m     ENDC
00000356                           748m 
00000356                 FALSE     749m     IFNE DEBUG
00000356                           750m     ENDC
00000356                           751m 
00000356                           752m     ENDM
00000356  E19A                     753      ROL.L #8,D2
00000358                           754m     PRINT_CHAR D2,D3
00000358                           755m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000358                 TRUE      756m     IFEQ DEBUG
00000358  1639 00C00003            757m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035E  0803 0002                758m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000362  67F4                     759m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000364  13C2 00C00007            760m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000036A                           761m     ENDC
0000036A                           762m 
0000036A                 FALSE     763m     IFNE DEBUG
0000036A                           764m     ENDC
0000036A                           765m 
0000036A                           766m     ENDM
0000036A                           767  
0000036A                           768m     PRINT_CRLF D3,A0
0000036A  41FA 0F66                769m     LEA CRLF(PC),A0
0000036E                           770mm     PRINT_STR A0,D3
0000036E                           771mm LOOP_37
0000036E  0C10 0000                772mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000372  6700 0016                773mm     BEQ EXIT_37
00000376                           774mmm     PRINT_CHAR (A0)+,D3
00000376                           775mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000376                 TRUE      776mmm     IFEQ DEBUG
00000376  1639 00C00003            777mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000037C  0803 0002                778mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000380  67F4                     779mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
00000382  13D8 00C00007            780mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000388                           781mmm     ENDC
00000388                           782mmm 
00000388                 FALSE     783mmm     IFNE DEBUG
00000388                           784mmm     ENDC
00000388                           785mmm 
00000388                           786mmm     ENDM
00000388  60E4                     787mm     BRA LOOP_37
0000038A                           788mm EXIT_37
0000038A                           789mm     ENDM
0000038A                           790m     ENDM
0000038A                           791      
0000038A  6000 FDEE                792      BRA MAIN_LOOP
0000038E                           793  
0000038E                           794  W
0000038E  3C3C 0007                795      MOVE #7,D6                                      ; 7 bytes left to read
00000392                           796      
00000392                           797  READ_DATA_TO_POKE
00000392  E98D                     798      LSL.L #4,D5                                     ; make what we have so far more significant
00000394                           799m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000394                           800m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000394                 TRUE      801m     IFEQ DEBUG
00000394  1639 00C00003            802m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000039A  0803 0000                803m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000039E  67F4                     804m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
000003A0                           805m     ENDC
000003A0                           806m 
000003A0                           807mm     READ_CHAR D2
000003A0                 TRUE      808mm     IFEQ DEBUG
000003A0  1439 00C00007            809mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000003A6                           810mm     ENDC
000003A6                 FALSE     811mm     IFNE DEBUG
000003A6                           812mm     ENDC
000003A6                           813mm 
000003A6  B43C 001B                814mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003AA  6700 FC5C                815mm     BEQ START
000003AE                           816mm     ENDM
000003AE                           817m 
000003AE                 TRUE      818m     IFEQ DEBUG
000003AE                           819mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003AE                           820mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AE                 TRUE      821mm     IFEQ DEBUG
000003AE  1639 00C00003            822mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003B4  0803 0002                823mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B8  67F4                     824mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003BA  13C2 00C00007            825mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003C0                           826mm     ENDC
000003C0                           827mm 
000003C0                 FALSE     828mm     IFNE DEBUG
000003C0                           829mm     ENDC
000003C0                           830mm 
000003C0                           831mm     ENDM
000003C0                           832m     ENDC
000003C0                           833m     ENDM
000003C0                           834m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003C0  41FA 0EE5                835m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003C4  0402 0030                836m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C8  C4BC 000000FF            837m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003CE  1430 2000                838m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003D2                           839m     ENDM
000003D2  8A02                     840      OR.B D2,D5
000003D4  57CE FFBC                841      DBEQ D6,READ_DATA_TO_POKE
000003D8                           842      
000003D8  2047                     843      MOVE.L D7,A0                                    ; address accumulator -> address register
000003DA  7E00                     844      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003DC                           845      
000003DC  2085                     846      MOVE.L D5,(A0)                                  ; write the data
000003DE                           847  
000003DE                           848m     PRINT_CRLF D3,A0
000003DE  41FA 0EF2                849m     LEA CRLF(PC),A0
000003E2                           850mm     PRINT_STR A0,D3
000003E2                           851mm LOOP_44
000003E2  0C10 0000                852mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003E6  6700 0016                853mm     BEQ EXIT_44
000003EA                           854mmm     PRINT_CHAR (A0)+,D3
000003EA                           855mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EA                 TRUE      856mmm     IFEQ DEBUG
000003EA  1639 00C00003            857mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003F0  0803 0002                858mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003F4  67F4                     859mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003F6  13D8 00C00007            860mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003FC                           861mmm     ENDC
000003FC                           862mmm 
000003FC                 FALSE     863mmm     IFNE DEBUG
000003FC                           864mmm     ENDC
000003FC                           865mmm 
000003FC                           866mmm     ENDM
000003FC  60E4                     867mm     BRA LOOP_44
000003FE                           868mm EXIT_44
000003FE                           869mm     ENDM
000003FE                           870m     ENDM
000003FE  6000 FD7A                871      BRA MAIN_LOOP
00000402                           872  
00000402                           873  ; register map for S
00000402                           874  ; A0 - start address
00000402                           875  ; A1 - offset
00000402                           876  ; A2 - next address to write
00000402                           877  ; A3 - next location (jmp)
00000402                           878  ; A4 - Working Address Register
00000402                           879  ; D0 - record count
00000402                           880  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000402                           881  ; D2 - checksum
00000402                           882  ; D3 - data byte count
00000402                           883  ; D4 - read address, moved into A2
00000402                           884  ; D5 - temp
00000402                           885  ; D6 - temp
00000402                           886  ; D7 - temp
00000402                           887  S
00000402  2078 0000                888      MOVE.L 0,A0                                     ; start address -> A0
00000406  2247                     889      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000408                           890      
00000408  7000                     891      MOVE.L #0,D0                                    ; count of records read -> D0
0000040A                           892          
0000040A                           893  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000040A                           894m     DOWNLOAD D1
0000040A                           895m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040A                           896m 
0000040A  1239 00C00003            897m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000410  0801 0000                898m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000414  6700 0010                899m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000418                           900m 
00000418                           901mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000418                 TRUE      902mm     IFEQ DEBUG
00000418  1239 00C00007            903mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000041E                           904mm     ENDC
0000041E                 FALSE     905mm     IFNE DEBUG
0000041E                           906mm     ENDC
0000041E                           907mm 
0000041E  B23C 001B                908mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000422  6700 FBE4                909mm     BEQ START
00000426                           910mm     ENDM
00000426                           911m CONTINUE_46
00000426  1239 00C00013            912m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000042C  0801 0000                913m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000430  67D8                     914m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
00000432                           915m     
00000432  1239 00C00017            916m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000438  13C1 00E00001            917m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000043E                           918m 
0000043E                           919m     ENDM
0000043E  B23C 0053                920      CMP.B #'S',D1                                   ; found S?
00000442  66C6                     921      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000444                           922      
00000444                           923m     PRINT_CHAR #'S',D5                              ; print the S
00000444                           924m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000444                 TRUE      925m     IFEQ DEBUG
00000444  1A39 00C00003            926m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000044A  0805 0002                927m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000044E  67F4                     928m         BEQ WAIT_FOR_READY_48                       ; NO SPACE, CHECK AGAIN
00000450  13FC 0053 00C00007       929m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000458                           930m     ENDC
00000458                           931m 
00000458                 FALSE     932m     IFNE DEBUG
00000458                           933m     ENDC
00000458                           934m 
00000458                           935m     ENDM
00000458  5280                     936      ADD.L #1,D0                                     ; read another S record, increment count
0000045A                           937      
0000045A                           938m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000045A                           939m WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000045A                           940m 
0000045A  1239 00C00003            941m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000460  0801 0000                942m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000464  6700 0010                943m     BEQ CONTINUE_49                                 ; NOTHING, CONTINUE
00000468                           944m 
00000468                           945mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000468                 TRUE      946mm     IFEQ DEBUG
00000468  1239 00C00007            947mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000046E                           948mm     ENDC
0000046E                 FALSE     949mm     IFNE DEBUG
0000046E                           950mm     ENDC
0000046E                           951mm 
0000046E  B23C 001B                952mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000472  6700 FB94                953mm     BEQ START
00000476                           954mm     ENDM
00000476                           955m CONTINUE_49
00000476  1239 00C00013            956m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000047C  0801 0000                957m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000480  67D8                     958m     BEQ WAIT_FOR_READY_49                           ; NOTHING, CHECK AGAIN
00000482                           959m     
00000482  1239 00C00017            960m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000488  13C1 00E00001            961m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000048E                           962m 
0000048E                           963m     ENDM
0000048E                           964m     PRINT_CHAR D1,D5
0000048E                           965m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048E                 TRUE      966m     IFEQ DEBUG
0000048E  1A39 00C00003            967m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000494  0805 0002                968m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000498  67F4                     969m         BEQ WAIT_FOR_READY_51                       ; NO SPACE, CHECK AGAIN
0000049A  13C1 00C00007            970m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004A0                           971m     ENDC
000004A0                           972m 
000004A0                 FALSE     973m     IFNE DEBUG
000004A0                           974m     ENDC
000004A0                           975m 
000004A0                           976m     ENDM
000004A0                           977  
000004A0  7400                     978      MOVE.L #0,D2                                    ; clear the checksum
000004A2                           979  
000004A2                           980m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000004A2  1E3C 0002                981m     MOVE.B #2,D7
000004A6                           982m     WHILE.B D7 <GT> 0 DO
000004A6                           983ms _10000000
000004A6  BE38 0000                984ms     CMP.B   0,D7
000004AA  6F00 0062                985ms     BLE _10000001
000004AE  E98B                     986m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000004B0                           987mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004B0                           988mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B0                           989mm 
000004B0  1A39 00C00003            990mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004B6  0805 0000                991mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004BA  6700 0010                992mm     BEQ CONTINUE_53                                 ; NOTHING, CONTINUE
000004BE                           993mm 
000004BE                           994mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000004BE                 TRUE      995mmm     IFEQ DEBUG
000004BE  1A39 00C00007            996mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C4                           997mmm     ENDC
000004C4                 FALSE     998mmm     IFNE DEBUG
000004C4                           999mmm     ENDC
000004C4                          1000mmm 
000004C4  BA3C 001B               1001mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000004C8  6700 FB3E               1002mmm     BEQ START
000004CC                          1003mmm     ENDM
000004CC                          1004mm CONTINUE_53
000004CC  1A39 00C00013           1005mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004D2  0805 0000               1006mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004D6  67D8                    1007mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D8                          1008mm     
000004D8  1A39 00C00017           1009mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004DE  13C5 00E00001           1010mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E4                          1011mm 
000004E4                          1012mm     ENDM
000004E4                          1013mm         PRINT_CHAR D5,D6
000004E4                          1014mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E4                 TRUE     1015mm     IFEQ DEBUG
000004E4  1C39 00C00003           1016mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000004EA  0806 0002               1017mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000004EE  67F4                    1018mm         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
000004F0  13C5 00C00007           1019mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F6                          1020mm     ENDC
000004F6                          1021mm 
000004F6                 FALSE    1022mm     IFNE DEBUG
000004F6                          1023mm     ENDC
000004F6                          1024mm 
000004F6                          1025mm     ENDM
000004F6                          1026mm         HEX2BIN D5,D5,A4
000004F6  49FA 0DAF               1027mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004FA  0405 0030               1028mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004FE  CABC 000000FF           1029mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000504  1A34 5000               1030mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000508                          1031mm     ENDM
00000508  8605                    1032m         OR.B D5,D3
0000050A  5307                    1033m         SUB.B #1,D7
0000050C                          1034m     ENDW
0000050C  6098                    1035ms     BRA _10000000
0000050E                          1036ms _10000001
0000050E                          1037m 
0000050E  7A00                    1038m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000510  1A03                    1039m     MOVE.B D3,D5
00000512  D483                    1040m     ADD.L D3,D2
00000514                          1041m 
00000514                          1042m     ENDM
00000514                          1043  
00000514                          1044      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000514  B23C 0030               1045s     CMP.B   #'0',D1
00000518  6600 002A               1046s     BNE.L   _00000002
0000051C                          1047m         PRINT_CRLF D5,A4
0000051C  49FA 0DB4               1048m     LEA CRLF(PC),A4
00000520                          1049mm     PRINT_STR A4,D5
00000520                          1050mm LOOP_58
00000520  0C14 0000               1051mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000524  6700 0016               1052mm     BEQ EXIT_58
00000528                          1053mmm     PRINT_CHAR (A4)+,D5
00000528                          1054mmm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000528                 TRUE     1055mmm     IFEQ DEBUG
00000528  1A39 00C00003           1056mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000052E  0805 0002               1057mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000532  67F4                    1058mmm         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000534  13DC 00C00007           1059mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000053A                          1060mmm     ENDC
0000053A                          1061mmm 
0000053A                 FALSE    1062mmm     IFNE DEBUG
0000053A                          1063mmm     ENDC
0000053A                          1064mmm 
0000053A                          1065mmm     ENDM
0000053A  60E4                    1066mm     BRA LOOP_58
0000053C                          1067mm EXIT_58
0000053C                          1068mm     ENDM
0000053C                          1069m     ENDM
0000053C  6000 FECC               1070          BRA WAIT_FOR_SRECORD
00000540                          1071      ELSE
00000540  6000 03DE               1072s     BRA _00000003
00000544                          1073s _00000002
00000544                          1074          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000544  B23C 0031               1075s     CMP.B   #'1',D1
00000548  6708                    1076s     BEQ.S   _00000004
0000054A  B23C 0032               1077s     CMP.B   #'2',D1
0000054E  6600 01F0               1078s     BNE.L   _00000005
00000552                          1079s _00000004
00000552  5783                    1080              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000554                          1081  
00000554  7800                    1082              MOVE.L #0,D4                            ; read two bytes of address
00000556                          1083m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000556  1E3C 0002               1084m     MOVE.B #2,D7
0000055A                          1085m     WHILE.B D7 <GT> 0 DO
0000055A                          1086ms _10000002
0000055A  BE38 0000               1087ms     CMP.B   0,D7
0000055E  6F00 0062               1088ms     BLE _10000003
00000562  E98C                    1089m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000564                          1090mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000564                          1091mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                          1092mm 
00000564  1A39 00C00003           1093mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000056A  0805 0000               1094mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000056E  6700 0010               1095mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000572                          1096mm 
00000572                          1097mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000572                 TRUE     1098mmm     IFEQ DEBUG
00000572  1A39 00C00007           1099mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000578                          1100mmm     ENDC
00000578                 FALSE    1101mmm     IFNE DEBUG
00000578                          1102mmm     ENDC
00000578                          1103mmm 
00000578  BA3C 001B               1104mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000057C  6700 FA8A               1105mmm     BEQ START
00000580                          1106mmm     ENDM
00000580                          1107mm CONTINUE_61
00000580  1A39 00C00013           1108mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000586  0805 0000               1109mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000058A  67D8                    1110mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
0000058C                          1111mm     
0000058C  1A39 00C00017           1112mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000592  13C5 00E00001           1113mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000598                          1114mm 
00000598                          1115mm     ENDM
00000598                          1116mm         PRINT_CHAR D5,D6
00000598                          1117mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000598                 TRUE     1118mm     IFEQ DEBUG
00000598  1C39 00C00003           1119mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000059E  0806 0002               1120mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000005A2  67F4                    1121mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000005A4  13C5 00C00007           1122mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005AA                          1123mm     ENDC
000005AA                          1124mm 
000005AA                 FALSE    1125mm     IFNE DEBUG
000005AA                          1126mm     ENDC
000005AA                          1127mm 
000005AA                          1128mm     ENDM
000005AA                          1129mm         HEX2BIN D5,D5,A4
000005AA  49FA 0CFB               1130mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005AE  0405 0030               1131mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B2  CABC 000000FF           1132mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005B8  1A34 5000               1133mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005BC                          1134mm     ENDM
000005BC  8805                    1135m         OR.B D5,D4
000005BE  5307                    1136m         SUB.B #1,D7
000005C0                          1137m     ENDW
000005C0  6098                    1138ms     BRA _10000002
000005C2                          1139ms _10000003
000005C2                          1140m 
000005C2  7A00                    1141m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005C4  1A04                    1142m     MOVE.B D4,D5
000005C6  D484                    1143m     ADD.L D4,D2
000005C8                          1144m 
000005C8                          1145m     ENDM
000005C8                          1146m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000005C8  1E3C 0002               1147m     MOVE.B #2,D7
000005CC                          1148m     WHILE.B D7 <GT> 0 DO
000005CC                          1149ms _10000004
000005CC  BE38 0000               1150ms     CMP.B   0,D7
000005D0  6F00 0062               1151ms     BLE _10000005
000005D4  E98C                    1152m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005D6                          1153mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005D6                          1154mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D6                          1155mm 
000005D6  1A39 00C00003           1156mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005DC  0805 0000               1157mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005E0  6700 0010               1158mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005E4                          1159mm 
000005E4                          1160mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005E4                 TRUE     1161mmm     IFEQ DEBUG
000005E4  1A39 00C00007           1162mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005EA                          1163mmm     ENDC
000005EA                 FALSE    1164mmm     IFNE DEBUG
000005EA                          1165mmm     ENDC
000005EA                          1166mmm 
000005EA  BA3C 001B               1167mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005EE  6700 FA18               1168mmm     BEQ START
000005F2                          1169mmm     ENDM
000005F2                          1170mm CONTINUE_66
000005F2  1A39 00C00013           1171mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F8  0805 0000               1172mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005FC  67D8                    1173mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
000005FE                          1174mm     
000005FE  1A39 00C00017           1175mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000604  13C5 00E00001           1176mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000060A                          1177mm 
0000060A                          1178mm     ENDM
0000060A                          1179mm         PRINT_CHAR D5,D6
0000060A                          1180mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060A                 TRUE     1181mm     IFEQ DEBUG
0000060A  1C39 00C00003           1182mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000610  0806 0002               1183mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000614  67F4                    1184mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
00000616  13C5 00C00007           1185mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000061C                          1186mm     ENDC
0000061C                          1187mm 
0000061C                 FALSE    1188mm     IFNE DEBUG
0000061C                          1189mm     ENDC
0000061C                          1190mm 
0000061C                          1191mm     ENDM
0000061C                          1192mm         HEX2BIN D5,D5,A4
0000061C  49FA 0C89               1193mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000620  0405 0030               1194mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000624  CABC 000000FF           1195mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000062A  1A34 5000               1196mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000062E                          1197mm     ENDM
0000062E  8805                    1198m         OR.B D5,D4
00000630  5307                    1199m         SUB.B #1,D7
00000632                          1200m     ENDW
00000632  6098                    1201ms     BRA _10000004
00000634                          1202ms _10000005
00000634                          1203m 
00000634  7A00                    1204m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000636  1A04                    1205m     MOVE.B D4,D5
00000638  D484                    1206m     ADD.L D4,D2
0000063A                          1207m 
0000063A                          1208m     ENDM
0000063A                          1209  
0000063A                          1210              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000063A  B23C 0032               1211s     CMP.B   #'2',D1
0000063E  6600 0076               1212s     BNE.L   _00000006
00000642  5383                    1213                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000644                          1214m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000644  1E3C 0002               1215m     MOVE.B #2,D7
00000648                          1216m     WHILE.B D7 <GT> 0 DO
00000648                          1217ms _10000006
00000648  BE38 0000               1218ms     CMP.B   0,D7
0000064C  6F00 0062               1219ms     BLE _10000007
00000650  E98C                    1220m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000652                          1221mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000652                          1222mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000652                          1223mm 
00000652  1A39 00C00003           1224mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000658  0805 0000               1225mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000065C  6700 0010               1226mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
00000660                          1227mm 
00000660                          1228mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000660                 TRUE     1229mmm     IFEQ DEBUG
00000660  1A39 00C00007           1230mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000666                          1231mmm     ENDC
00000666                 FALSE    1232mmm     IFNE DEBUG
00000666                          1233mmm     ENDC
00000666                          1234mmm 
00000666  BA3C 001B               1235mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000066A  6700 F99C               1236mmm     BEQ START
0000066E                          1237mmm     ENDM
0000066E                          1238mm CONTINUE_71
0000066E  1A39 00C00013           1239mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000674  0805 0000               1240mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000678  67D8                    1241mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
0000067A                          1242mm     
0000067A  1A39 00C00017           1243mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000680  13C5 00E00001           1244mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000686                          1245mm 
00000686                          1246mm     ENDM
00000686                          1247mm         PRINT_CHAR D5,D6
00000686                          1248mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000686                 TRUE     1249mm     IFEQ DEBUG
00000686  1C39 00C00003           1250mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000068C  0806 0002               1251mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000690  67F4                    1252mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
00000692  13C5 00C00007           1253mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000698                          1254mm     ENDC
00000698                          1255mm 
00000698                 FALSE    1256mm     IFNE DEBUG
00000698                          1257mm     ENDC
00000698                          1258mm 
00000698                          1259mm     ENDM
00000698                          1260mm         HEX2BIN D5,D5,A4
00000698  49FA 0C0D               1261mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000069C  0405 0030               1262mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006A0  CABC 000000FF           1263mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006A6  1A34 5000               1264mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006AA                          1265mm     ENDM
000006AA  8805                    1266m         OR.B D5,D4
000006AC  5307                    1267m         SUB.B #1,D7
000006AE                          1268m     ENDW
000006AE  6098                    1269ms     BRA _10000006
000006B0                          1270ms _10000007
000006B0                          1271m 
000006B0  7A00                    1272m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006B2  1A04                    1273m     MOVE.B D4,D5
000006B4  D484                    1274m     ADD.L D4,D2
000006B6                          1275m 
000006B6                          1276m     ENDM
000006B6                          1277              ENDI
000006B6                          1278s _00000006
000006B6                          1279  
000006B6  2444                    1280              MOVE.L D4,A2                            ; put the address in an address register
000006B8  D5C9                    1281              ADD.L A1,A2                             ; add in the offset
000006BA                          1282  
000006BA                          1283              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000006BA                          1284s _10000008
000006BA  B63C 0000               1285s     CMP.B   #0,D3
000006BE  6F00 007A               1286s     BLE _10000009
000006C2                          1287m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000006C2  1E3C 0002               1288m     MOVE.B #2,D7
000006C6                          1289m     WHILE.B D7 <GT> 0 DO
000006C6                          1290ms _1000000A
000006C6  BE38 0000               1291ms     CMP.B   0,D7
000006CA  6F00 0062               1292ms     BLE _1000000B
000006CE  E989                    1293m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000006D0                          1294mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006D0                          1295mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D0                          1296mm 
000006D0  1A39 00C00003           1297mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006D6  0805 0000               1298mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DA  6700 0010               1299mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006DE                          1300mm 
000006DE                          1301mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006DE                 TRUE     1302mmm     IFEQ DEBUG
000006DE  1A39 00C00007           1303mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006E4                          1304mmm     ENDC
000006E4                 FALSE    1305mmm     IFNE DEBUG
000006E4                          1306mmm     ENDC
000006E4                          1307mmm 
000006E4  BA3C 001B               1308mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006E8  6700 F91E               1309mmm     BEQ START
000006EC                          1310mmm     ENDM
000006EC                          1311mm CONTINUE_76
000006EC  1A39 00C00013           1312mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006F2  0805 0000               1313mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006F6  67D8                    1314mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
000006F8                          1315mm     
000006F8  1A39 00C00017           1316mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006FE  13C5 00E00001           1317mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000704                          1318mm 
00000704                          1319mm     ENDM
00000704                          1320mm         PRINT_CHAR D5,D6
00000704                          1321mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000704                 TRUE     1322mm     IFEQ DEBUG
00000704  1C39 00C00003           1323mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000070A  0806 0002               1324mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000070E  67F4                    1325mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
00000710  13C5 00C00007           1326mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000716                          1327mm     ENDC
00000716                          1328mm 
00000716                 FALSE    1329mm     IFNE DEBUG
00000716                          1330mm     ENDC
00000716                          1331mm 
00000716                          1332mm     ENDM
00000716                          1333mm         HEX2BIN D5,D5,A4
00000716  49FA 0B8F               1334mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000071A  0405 0030               1335mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000071E  CABC 000000FF           1336mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000724  1A34 5000               1337mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000728                          1338mm     ENDM
00000728  8205                    1339m         OR.B D5,D1
0000072A  5307                    1340m         SUB.B #1,D7
0000072C                          1341m     ENDW
0000072C  6098                    1342ms     BRA _1000000A
0000072E                          1343ms _1000000B
0000072E                          1344m 
0000072E  7A00                    1345m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000730  1A01                    1346m     MOVE.B D1,D5
00000732  D481                    1347m     ADD.L D1,D2
00000734                          1348m 
00000734                          1349m     ENDM
00000734                          1350   
00000734  14C1                    1351                  MOVE.B D1,(A2)+                     ; store it!
00000736                          1352  
00000736  5303                    1353                  SUB.B #1,D3                         ; 1 less byte to go
00000738                          1354              ENDW
00000738  6080                    1355s     BRA _10000008
0000073A                          1356s _10000009
0000073A                          1357  
0000073A  7200                    1358              MOVE.L #0,D1                            ; not done yet
0000073C                          1359          ELSE
0000073C  6000 01E2               1360s     BRA _00000007
00000740                          1361s _00000005
00000740                          1362              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000740  B23C 0038               1363s     CMP.B   #'8',D1
00000744  6600 0164               1364s     BNE.L   _00000008
00000748  7800                    1365                  MOVE.L #0,D4                        ; read the 24 bit start address
0000074A                          1366m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
0000074A  1E3C 0002               1367m     MOVE.B #2,D7
0000074E                          1368m     WHILE.B D7 <GT> 0 DO
0000074E                          1369ms _1000000C
0000074E  BE38 0000               1370ms     CMP.B   0,D7
00000752  6F00 0062               1371ms     BLE _1000000D
00000756  E98C                    1372m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000758                          1373mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000758                          1374mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000758                          1375mm 
00000758  1A39 00C00003           1376mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075E  0805 0000               1377mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000762  6700 0010               1378mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
00000766                          1379mm 
00000766                          1380mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000766                 TRUE     1381mmm     IFEQ DEBUG
00000766  1A39 00C00007           1382mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000076C                          1383mmm     ENDC
0000076C                 FALSE    1384mmm     IFNE DEBUG
0000076C                          1385mmm     ENDC
0000076C                          1386mmm 
0000076C  BA3C 001B               1387mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000770  6700 F896               1388mmm     BEQ START
00000774                          1389mmm     ENDM
00000774                          1390mm CONTINUE_81
00000774  1A39 00C00013           1391mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000077A  0805 0000               1392mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000077E  67D8                    1393mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00000780                          1394mm     
00000780  1A39 00C00017           1395mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000786  13C5 00E00001           1396mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000078C                          1397mm 
0000078C                          1398mm     ENDM
0000078C                          1399mm         PRINT_CHAR D5,D6
0000078C                          1400mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                 TRUE     1401mm     IFEQ DEBUG
0000078C  1C39 00C00003           1402mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000792  0806 0002               1403mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000796  67F4                    1404mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000798  13C5 00C00007           1405mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000079E                          1406mm     ENDC
0000079E                          1407mm 
0000079E                 FALSE    1408mm     IFNE DEBUG
0000079E                          1409mm     ENDC
0000079E                          1410mm 
0000079E                          1411mm     ENDM
0000079E                          1412mm         HEX2BIN D5,D5,A4
0000079E  49FA 0B07               1413mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A2  0405 0030               1414mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007A6  CABC 000000FF           1415mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007AC  1A34 5000               1416mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B0                          1417mm     ENDM
000007B0  8805                    1418m         OR.B D5,D4
000007B2  5307                    1419m         SUB.B #1,D7
000007B4                          1420m     ENDW
000007B4  6098                    1421ms     BRA _1000000C
000007B6                          1422ms _1000000D
000007B6                          1423m 
000007B6  7A00                    1424m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B8  1A04                    1425m     MOVE.B D4,D5
000007BA  D484                    1426m     ADD.L D4,D2
000007BC                          1427m 
000007BC                          1428m     ENDM
000007BC                          1429m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000007BC  1E3C 0002               1430m     MOVE.B #2,D7
000007C0                          1431m     WHILE.B D7 <GT> 0 DO
000007C0                          1432ms _1000000E
000007C0  BE38 0000               1433ms     CMP.B   0,D7
000007C4  6F00 0062               1434ms     BLE _1000000F
000007C8  E98C                    1435m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007CA                          1436mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007CA                          1437mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CA                          1438mm 
000007CA  1A39 00C00003           1439mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007D0  0805 0000               1440mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007D4  6700 0010               1441mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007D8                          1442mm 
000007D8                          1443mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007D8                 TRUE     1444mmm     IFEQ DEBUG
000007D8  1A39 00C00007           1445mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007DE                          1446mmm     ENDC
000007DE                 FALSE    1447mmm     IFNE DEBUG
000007DE                          1448mmm     ENDC
000007DE                          1449mmm 
000007DE  BA3C 001B               1450mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007E2  6700 F824               1451mmm     BEQ START
000007E6                          1452mmm     ENDM
000007E6                          1453mm CONTINUE_86
000007E6  1A39 00C00013           1454mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007EC  0805 0000               1455mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007F0  67D8                    1456mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007F2                          1457mm     
000007F2  1A39 00C00017           1458mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007F8  13C5 00E00001           1459mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007FE                          1460mm 
000007FE                          1461mm     ENDM
000007FE                          1462mm         PRINT_CHAR D5,D6
000007FE                          1463mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FE                 TRUE     1464mm     IFEQ DEBUG
000007FE  1C39 00C00003           1465mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000804  0806 0002               1466mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000808  67F4                    1467mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
0000080A  13C5 00C00007           1468mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000810                          1469mm     ENDC
00000810                          1470mm 
00000810                 FALSE    1471mm     IFNE DEBUG
00000810                          1472mm     ENDC
00000810                          1473mm 
00000810                          1474mm     ENDM
00000810                          1475mm         HEX2BIN D5,D5,A4
00000810  49FA 0A95               1476mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000814  0405 0030               1477mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000818  CABC 000000FF           1478mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000081E  1A34 5000               1479mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000822                          1480mm     ENDM
00000822  8805                    1481m         OR.B D5,D4
00000824  5307                    1482m         SUB.B #1,D7
00000826                          1483m     ENDW
00000826  6098                    1484ms     BRA _1000000E
00000828                          1485ms _1000000F
00000828                          1486m 
00000828  7A00                    1487m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000082A  1A04                    1488m     MOVE.B D4,D5
0000082C  D484                    1489m     ADD.L D4,D2
0000082E                          1490m 
0000082E                          1491m     ENDM
0000082E                          1492m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000082E  1E3C 0002               1493m     MOVE.B #2,D7
00000832                          1494m     WHILE.B D7 <GT> 0 DO
00000832                          1495ms _10000010
00000832  BE38 0000               1496ms     CMP.B   0,D7
00000836  6F00 0062               1497ms     BLE _10000011
0000083A  E98C                    1498m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083C                          1499mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083C                          1500mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083C                          1501mm 
0000083C  1A39 00C00003           1502mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000842  0805 0000               1503mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000846  6700 0010               1504mm     BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
0000084A                          1505mm 
0000084A                          1506mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                 TRUE     1507mmm     IFEQ DEBUG
0000084A  1A39 00C00007           1508mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000850                          1509mmm     ENDC
00000850                 FALSE    1510mmm     IFNE DEBUG
00000850                          1511mmm     ENDC
00000850                          1512mmm 
00000850  BA3C 001B               1513mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F7B2               1514mmm     BEQ START
00000858                          1515mmm     ENDM
00000858                          1516mm CONTINUE_91
00000858  1A39 00C00013           1517mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085E  0805 0000               1518mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  67D8                    1519mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
00000864                          1520mm     
00000864  1A39 00C00017           1521mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086A  13C5 00E00001           1522mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000870                          1523mm 
00000870                          1524mm     ENDM
00000870                          1525mm         PRINT_CHAR D5,D6
00000870                          1526mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1527mm     IFEQ DEBUG
00000870  1C39 00C00003           1528mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000876  0806 0002               1529mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1530mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
0000087C  13C5 00C00007           1531mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000882                          1532mm     ENDC
00000882                          1533mm 
00000882                 FALSE    1534mm     IFNE DEBUG
00000882                          1535mm     ENDC
00000882                          1536mm 
00000882                          1537mm     ENDM
00000882                          1538mm         HEX2BIN D5,D5,A4
00000882  49FA 0A23               1539mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000886  0405 0030               1540mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000088A  CABC 000000FF           1541mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000890  1A34 5000               1542mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000894                          1543mm     ENDM
00000894  8805                    1544m         OR.B D5,D4
00000896  5307                    1545m         SUB.B #1,D7
00000898                          1546m     ENDW
00000898  6098                    1547ms     BRA _10000010
0000089A                          1548ms _10000011
0000089A                          1549m 
0000089A  7A00                    1550m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000089C  1A04                    1551m     MOVE.B D4,D5
0000089E  D484                    1552m     ADD.L D4,D2
000008A0                          1553m 
000008A0                          1554m     ENDM
000008A0                          1555  
000008A0  2044                    1556                  MOVE.L D4,A0                        ; start address -> A0
000008A2  D1C9                    1557                  ADD.L A1,A0                         ; add in the offset
000008A4                          1558  
000008A4  72FF                    1559                  MOVE.L #$FFFFFFFF,D1                ; done
000008A6                          1560              ELSE
000008A6  6000 0078               1561s     BRA _00000009
000008AA                          1562s _00000008
000008AA                          1563m                 PRINT_CRLF D5,A4
000008AA  49FA 0A26               1564m     LEA CRLF(PC),A4
000008AE                          1565mm     PRINT_STR A4,D5
000008AE                          1566mm LOOP_96
000008AE  0C14 0000               1567mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008B2  6700 0016               1568mm     BEQ EXIT_96
000008B6                          1569mmm     PRINT_CHAR (A4)+,D5
000008B6                          1570mmm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B6                 TRUE     1571mmm     IFEQ DEBUG
000008B6  1A39 00C00003           1572mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008BC  0805 0002               1573mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008C0  67F4                    1574mmm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
000008C2  13DC 00C00007           1575mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008C8                          1576mmm     ENDC
000008C8                          1577mmm 
000008C8                 FALSE    1578mmm     IFNE DEBUG
000008C8                          1579mmm     ENDC
000008C8                          1580mmm 
000008C8                          1581mmm     ENDM
000008C8  60E4                    1582mm     BRA LOOP_96
000008CA                          1583mm EXIT_96
000008CA                          1584mm     ENDM
000008CA                          1585m     ENDM
000008CA                          1586  
000008CA  49FA 0990               1587                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008CE                          1588m                 PRINT_STR A4,D5
000008CE                          1589m LOOP_98
000008CE  0C14 0000               1590m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008D2  6700 0016               1591m     BEQ EXIT_98
000008D6                          1592mm     PRINT_CHAR (A4)+,D5
000008D6                          1593mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                 TRUE     1594mm     IFEQ DEBUG
000008D6  1A39 00C00003           1595mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008DC  0805 0002               1596mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008E0  67F4                    1597mm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
000008E2  13DC 00C00007           1598mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008E8                          1599mm     ENDC
000008E8                          1600mm 
000008E8                 FALSE    1601mm     IFNE DEBUG
000008E8                          1602mm     ENDC
000008E8                          1603mm 
000008E8                          1604mm     ENDM
000008E8  60E4                    1605m     BRA LOOP_98
000008EA                          1606m EXIT_98
000008EA                          1607m     ENDM
000008EA                          1608m                 PRINT_CHAR D1,D5
000008EA                          1609m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EA                 TRUE     1610m     IFEQ DEBUG
000008EA  1A39 00C00003           1611m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008F0  0805 0002               1612m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008F4  67F4                    1613m         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000008F6  13C1 00C00007           1614m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008FC                          1615m     ENDC
000008FC                          1616m 
000008FC                 FALSE    1617m     IFNE DEBUG
000008FC                          1618m     ENDC
000008FC                          1619m 
000008FC                          1620m     ENDM
000008FC                          1621m                 PRINT_CRLF D5,A4
000008FC  49FA 09D4               1622m     LEA CRLF(PC),A4
00000900                          1623mm     PRINT_STR A4,D5
00000900                          1624mm LOOP_102
00000900  0C14 0000               1625mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000904  6700 0016               1626mm     BEQ EXIT_102
00000908                          1627mmm     PRINT_CHAR (A4)+,D5
00000908                          1628mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000908                 TRUE     1629mmm     IFEQ DEBUG
00000908  1A39 00C00003           1630mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000090E  0805 0002               1631mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000912  67F4                    1632mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
00000914  13DC 00C00007           1633mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000091A                          1634mmm     ENDC
0000091A                          1635mmm 
0000091A                 FALSE    1636mmm     IFNE DEBUG
0000091A                          1637mmm     ENDC
0000091A                          1638mmm 
0000091A                          1639mmm     ENDM
0000091A  60E4                    1640mm     BRA LOOP_102
0000091C                          1641mm EXIT_102
0000091C                          1642mm     ENDM
0000091C                          1643m     ENDM
0000091C                          1644  
0000091C  6000 FAEC               1645                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000920                          1646              ENDI
00000920                          1647s _00000009
00000920                          1648          ENDI
00000920                          1649s _00000007
00000920                          1650      ENDI
00000920                          1651s _00000003
00000920                          1652  
00000920                          1653m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000920  1E3C 0002               1654m     MOVE.B #2,D7
00000924                          1655m     WHILE.B D7 <GT> 0 DO
00000924                          1656ms _10000012
00000924  BE38 0000               1657ms     CMP.B   0,D7
00000928  6F00 0062               1658ms     BLE _10000013
0000092C  E98C                    1659m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000092E                          1660mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000092E                          1661mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092E                          1662mm 
0000092E  1A39 00C00003           1663mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000934  0805 0000               1664mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000938  6700 0010               1665mm     BEQ CONTINUE_105                                    ; NOTHING, CONTINUE
0000093C                          1666mm 
0000093C                          1667mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000093C                 TRUE     1668mmm     IFEQ DEBUG
0000093C  1A39 00C00007           1669mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000942                          1670mmm     ENDC
00000942                 FALSE    1671mmm     IFNE DEBUG
00000942                          1672mmm     ENDC
00000942                          1673mmm 
00000942  BA3C 001B               1674mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000946  6700 F6C0               1675mmm     BEQ START
0000094A                          1676mmm     ENDM
0000094A                          1677mm CONTINUE_105
0000094A  1A39 00C00013           1678mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000950  0805 0000               1679mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000954  67D8                    1680mm     BEQ WAIT_FOR_READY_105                          ; NOTHING, CHECK AGAIN
00000956                          1681mm     
00000956  1A39 00C00017           1682mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000095C  13C5 00E00001           1683mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000962                          1684mm 
00000962                          1685mm     ENDM
00000962                          1686mm         PRINT_CHAR D5,D6
00000962                          1687mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1688mm     IFEQ DEBUG
00000962  1C39 00C00003           1689mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000968  0806 0002               1690mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1691mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096E  13C5 00C00007           1692mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000974                          1693mm     ENDC
00000974                          1694mm 
00000974                 FALSE    1695mm     IFNE DEBUG
00000974                          1696mm     ENDC
00000974                          1697mm 
00000974                          1698mm     ENDM
00000974                          1699mm         HEX2BIN D5,D5,A4
00000974  49FA 0931               1700mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000978  0405 0030               1701mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000097C  CABC 000000FF           1702mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000982  1A34 5000               1703mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000986                          1704mm     ENDM
00000986  8805                    1705m         OR.B D5,D4
00000988  5307                    1706m         SUB.B #1,D7
0000098A                          1707m     ENDW
0000098A  6098                    1708ms     BRA _10000012
0000098C                          1709ms _10000013
0000098C                          1710m 
0000098C  7A00                    1711m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000098E  1A04                    1712m     MOVE.B D4,D5
00000990  D484                    1713m     ADD.L D4,D2
00000992                          1714m 
00000992                          1715m     ENDM
00000992                          1716m     PRINT_CRLF D5,A4
00000992  49FA 093E               1717m     LEA CRLF(PC),A4
00000996                          1718mm     PRINT_STR A4,D5
00000996                          1719mm LOOP_110
00000996  0C14 0000               1720mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000099A  6700 0016               1721mm     BEQ EXIT_110
0000099E                          1722mmm     PRINT_CHAR (A4)+,D5
0000099E                          1723mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099E                 TRUE     1724mmm     IFEQ DEBUG
0000099E  1A39 00C00003           1725mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A4  0805 0002               1726mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A8  67F4                    1727mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009AA  13DC 00C00007           1728mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009B0                          1729mmm     ENDC
000009B0                          1730mmm 
000009B0                 FALSE    1731mmm     IFNE DEBUG
000009B0                          1732mmm     ENDC
000009B0                          1733mmm 
000009B0                          1734mmm     ENDM
000009B0  60E4                    1735mm     BRA LOOP_110
000009B2                          1736mm EXIT_110
000009B2                          1737mm     ENDM
000009B2                          1738m     ENDM
000009B2                          1739  
000009B2                          1740      IF.B D2 <NE> #$FF THEN.L
000009B2  B43C 00FF               1741s     CMP.B   #$FF,D2
000009B6  6700 0090               1742s     BEQ.L   _0000000A
000009BA  49FA 08B7               1743          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009BE                          1744m         PRINT_STR A4,D5
000009BE                          1745m LOOP_112
000009BE  0C14 0000               1746m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009C2  6700 0016               1747m     BEQ EXIT_112
000009C6                          1748mm     PRINT_CHAR (A4)+,D5
000009C6                          1749mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C6                 TRUE     1750mm     IFEQ DEBUG
000009C6  1A39 00C00003           1751mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009CC  0805 0002               1752mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009D0  67F4                    1753mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009D2  13DC 00C00007           1754mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009D8                          1755mm     ENDC
000009D8                          1756mm 
000009D8                 FALSE    1757mm     IFNE DEBUG
000009D8                          1758mm     ENDC
000009D8                          1759mm 
000009D8                          1760mm     ENDM
000009D8  60E4                    1761m     BRA LOOP_112
000009DA                          1762m EXIT_112
000009DA                          1763m     ENDM
000009DA                          1764m         PRINT_REG D0,D5,D2,D6,A4
000009DA  49FA 08FC               1765m     LEA OX(PC),A4
000009DE                          1766mm     PRINT_STR A4,D5
000009DE                          1767mm LOOP_115
000009DE  0C14 0000               1768mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009E2  6700 0016               1769mm     BEQ EXIT_115
000009E6                          1770mmm     PRINT_CHAR (A4)+,D5
000009E6                          1771mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1772mmm     IFEQ DEBUG
000009E6  1A39 00C00003           1773mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009EC  0805 0002               1774mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1775mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009F2  13DC 00C00007           1776mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F8                          1777mmm     ENDC
000009F8                          1778mmm 
000009F8                 FALSE    1779mmm     IFNE DEBUG
000009F8                          1780mmm     ENDC
000009F8                          1781mmm 
000009F8                          1782mmm     ENDM
000009F8  60E4                    1783mm     BRA LOOP_115
000009FA                          1784mm EXIT_115
000009FA                          1785mm     ENDM
000009FA  7C07                    1786m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009FC                          1787m LOOP_114
000009FC                          1788mm     BIN2HEX D0,D2,A4
000009FC  49FA 0899               1789mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A00  E998                    1790mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A02  1400                    1791mm     MOVE.B D0,D2
00000A04  0282 0000000F           1792mm     ANDI.L #$F,D2
00000A0A  1434 2000               1793mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000A0E                          1794mm     ENDM
00000A0E                          1795mm     PRINT_CHAR D2,D5
00000A0E                          1796mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A0E                 TRUE     1797mm     IFEQ DEBUG
00000A0E  1A39 00C00003           1798mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A14  0805 0002               1799mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A18  67F4                    1800mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A1A  13C2 00C00007           1801mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A20                          1802mm     ENDC
00000A20                          1803mm 
00000A20                 FALSE    1804mm     IFNE DEBUG
00000A20                          1805mm     ENDC
00000A20                          1806mm 
00000A20                          1807mm     ENDM
00000A20  57CE FFDA               1808m     DBEQ D6,LOOP_114
00000A24                          1809m     ENDM
00000A24                          1810m         PRINT_CRLF D5,A4
00000A24  49FA 08AC               1811m     LEA CRLF(PC),A4
00000A28                          1812mm     PRINT_STR A4,D5
00000A28                          1813mm LOOP_120
00000A28  0C14 0000               1814mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A2C  6700 0016               1815mm     BEQ EXIT_120
00000A30                          1816mmm     PRINT_CHAR (A4)+,D5
00000A30                          1817mmm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A30                 TRUE     1818mmm     IFEQ DEBUG
00000A30  1A39 00C00003           1819mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A36  0805 0002               1820mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A3A  67F4                    1821mmm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A3C  13DC 00C00007           1822mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A42                          1823mmm     ENDC
00000A42                          1824mmm 
00000A42                 FALSE    1825mmm     IFNE DEBUG
00000A42                          1826mmm     ENDC
00000A42                          1827mmm 
00000A42                          1828mmm     ENDM
00000A42  60E4                    1829mm     BRA LOOP_120
00000A44                          1830mm EXIT_120
00000A44                          1831mm     ENDM
00000A44                          1832m     ENDM
00000A44  6000 F734               1833          BRA MAIN_LOOP
00000A48                          1834      ENDI
00000A48                          1835s _0000000A
00000A48                          1836  
00000A48                          1837      IF D1 <EQ> #0 THEN
00000A48  B27C 0000               1838s     CMP.W   #0,D1
00000A4C  6600 0006               1839s     BNE _0000000B
00000A50  6000 F9B8               1840        BRA WAIT_FOR_SRECORD
00000A54                          1841      ENDI
00000A54                          1842s _0000000B
00000A54                          1843  DOWNLOAD_DONE
00000A54                          1844m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A54  43FA 0882               1845m     LEA OX(PC),A1
00000A58                          1846mm     PRINT_STR A1,D5
00000A58                          1847mm LOOP_123
00000A58  0C11 0000               1848mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A5C  6700 0016               1849mm     BEQ EXIT_123
00000A60                          1850mmm     PRINT_CHAR (A1)+,D5
00000A60                          1851mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A60                 TRUE     1852mmm     IFEQ DEBUG
00000A60  1A39 00C00003           1853mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A66  0805 0002               1854mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A6A  67F4                    1855mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A6C  13D9 00C00007           1856mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A72                          1857mmm     ENDC
00000A72                          1858mmm 
00000A72                 FALSE    1859mmm     IFNE DEBUG
00000A72                          1860mmm     ENDC
00000A72                          1861mmm 
00000A72                          1862mmm     ENDM
00000A72  60E4                    1863mm     BRA LOOP_123
00000A74                          1864mm EXIT_123
00000A74                          1865mm     ENDM
00000A74  7407                    1866m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A76                          1867m LOOP_122
00000A76                          1868mm     BIN2HEX D0,D6,A1
00000A76  43FA 081F               1869mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A7A  E998                    1870mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A7C  1C00                    1871mm     MOVE.B D0,D6
00000A7E  0286 0000000F           1872mm     ANDI.L #$F,D6
00000A84  1C31 6000               1873mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A88                          1874mm     ENDM
00000A88                          1875mm     PRINT_CHAR D6,D5
00000A88                          1876mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A88                 TRUE     1877mm     IFEQ DEBUG
00000A88  1A39 00C00003           1878mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A8E  0805 0002               1879mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A92  67F4                    1880mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A94  13C6 00C00007           1881mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A9A                          1882mm     ENDC
00000A9A                          1883mm 
00000A9A                 FALSE    1884mm     IFNE DEBUG
00000A9A                          1885mm     ENDC
00000A9A                          1886mm 
00000A9A                          1887mm     ENDM
00000A9A  57CA FFDA               1888m     DBEQ D2,LOOP_122
00000A9E                          1889m     ENDM
00000A9E  43FA 079A               1890      LEA READ(PC),A1
00000AA2                          1891m     PRINT_STR A1,D5
00000AA2                          1892m LOOP_127
00000AA2  0C11 0000               1893m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AA6  6700 0016               1894m     BEQ EXIT_127
00000AAA                          1895mm     PRINT_CHAR (A1)+,D5
00000AAA                          1896mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAA                 TRUE     1897mm     IFEQ DEBUG
00000AAA  1A39 00C00003           1898mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB0  0805 0002               1899mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AB4  67F4                    1900mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000AB6  13D9 00C00007           1901mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ABC                          1902mm     ENDC
00000ABC                          1903mm 
00000ABC                 FALSE    1904mm     IFNE DEBUG
00000ABC                          1905mm     ENDC
00000ABC                          1906mm 
00000ABC                          1907mm     ENDM
00000ABC  60E4                    1908m     BRA LOOP_127
00000ABE                          1909m EXIT_127
00000ABE                          1910m     ENDM
00000ABE  2E08                    1911      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AC0                          1912m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000AC0  43FA 0816               1913m     LEA OX(PC),A1
00000AC4                          1914mm     PRINT_STR A1,D5
00000AC4                          1915mm LOOP_130
00000AC4  0C11 0000               1916mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AC8  6700 0016               1917mm     BEQ EXIT_130
00000ACC                          1918mmm     PRINT_CHAR (A1)+,D5
00000ACC                          1919mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACC                 TRUE     1920mmm     IFEQ DEBUG
00000ACC  1A39 00C00003           1921mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD2  0805 0002               1922mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AD6  67F4                    1923mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AD8  13D9 00C00007           1924mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ADE                          1925mmm     ENDC
00000ADE                          1926mmm 
00000ADE                 FALSE    1927mmm     IFNE DEBUG
00000ADE                          1928mmm     ENDC
00000ADE                          1929mmm 
00000ADE                          1930mmm     ENDM
00000ADE  60E4                    1931mm     BRA LOOP_130
00000AE0                          1932mm EXIT_130
00000AE0                          1933mm     ENDM
00000AE0  7407                    1934m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AE2                          1935m LOOP_129
00000AE2                          1936mm     BIN2HEX D7,D6,A1
00000AE2  43FA 07B3               1937mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AE6  E99F                    1938mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AE8  1C07                    1939mm     MOVE.B D7,D6
00000AEA  0286 0000000F           1940mm     ANDI.L #$F,D6
00000AF0  1C31 6000               1941mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AF4                          1942mm     ENDM
00000AF4                          1943mm     PRINT_CHAR D6,D5
00000AF4                          1944mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF4                 TRUE     1945mm     IFEQ DEBUG
00000AF4  1A39 00C00003           1946mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AFA  0805 0002               1947mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFE  67F4                    1948mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B00  13C6 00C00007           1949mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B06                          1950mm     ENDC
00000B06                          1951mm 
00000B06                 FALSE    1952mm     IFNE DEBUG
00000B06                          1953mm     ENDC
00000B06                          1954mm 
00000B06                          1955mm     ENDM
00000B06  57CA FFDA               1956m     DBEQ D2,LOOP_129
00000B0A                          1957m     ENDM
00000B0A                          1958m     PRINT_CRLF D5,A4
00000B0A  49FA 07C6               1959m     LEA CRLF(PC),A4
00000B0E                          1960mm     PRINT_STR A4,D5
00000B0E                          1961mm LOOP_135
00000B0E  0C14 0000               1962mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B12  6700 0016               1963mm     BEQ EXIT_135
00000B16                          1964mmm     PRINT_CHAR (A4)+,D5
00000B16                          1965mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B16                 TRUE     1966mmm     IFEQ DEBUG
00000B16  1A39 00C00003           1967mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B1C  0805 0002               1968mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B20  67F4                    1969mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B22  13DC 00C00007           1970mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B28                          1971mmm     ENDC
00000B28                          1972mmm 
00000B28                 FALSE    1973mmm     IFNE DEBUG
00000B28                          1974mmm     ENDC
00000B28                          1975mmm 
00000B28                          1976mmm     ENDM
00000B28  60E4                    1977mm     BRA LOOP_135
00000B2A                          1978mm EXIT_135
00000B2A                          1979mm     ENDM
00000B2A                          1980m     ENDM
00000B2A                          1981  
00000B2A  6000 F64E               1982      BRA MAIN_LOOP
00000B2E                          1983  
00000B2E                          1984  G
00000B2E  2047                    1985      MOVE.L D7,A0                                    ; address accumulator -> address register
00000B30  3E3C 0000               1986      MOVE #0,D7                                      ; clear the now used address accumulator
00000B34  4ED0                    1987      JMP (A0)                                        ; jump to it!
00000B36                          1988  
00000B36                          1989  Z
00000B36  207C 00200000           1990      MOVE.L #RAM,A0                                  ; address of RAM
00000B3C                          1991      
00000B3C                          1992      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000B3C  7000                    1993s     MOVE.L  #0,D0
00000B3E  6000 0012               1994s     BRA _20000005
00000B42                          1995s _20000004
00000B42  2200                    1996          MOVE.L D0,D1                                ; progress update
00000B44  E089                    1997          LSR.L #8,D1 
00000B46  E089                    1998          LSR.L #8,D1
00000B48  13C1 00E00001           1999          MOVE.B D1,DISPLAY
00000B4E                          2000          
00000B4E  20C8                    2001          MOVE.L A0,(A0)+
00000B50                          2002      ENDF
00000B50  5880                    2003s     ADD.L   #4,D0
00000B52                          2004s _20000005
00000B52  B0BC 000FFFFC           2005s     CMP.L   #$FFFFC,D0
00000B58  6FE8                    2006s     BLE _20000004
00000B5A                          2007  
00000B5A  207C 00200000           2008      MOVE.L #RAM,A0                                  ; address of RAM
00000B60                          2009  
00000B60                          2010      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000B60  7000                    2011s     MOVE.L  #0,D0
00000B62  6000 00A8               2012s     BRA _20000007
00000B66                          2013s _20000006
00000B66  2200                    2014          MOVE.L D0,D1                                ; progress update
00000B68  E089                    2015          LSR.L #8,D1
00000B6A  E089                    2016          LSR.L #8,D1
00000B6C  13C1 00E00001           2017          MOVE.B D1,DISPLAY
00000B72                          2018  
00000B72  2408                    2019          MOVE.L A0,D2
00000B74  2218                    2020          MOVE.L (A0)+,D1
00000B76                          2021  
00000B76                          2022          IF.L D2 <NE> D1 THEN
00000B76  B481                    2023s     CMP.L   D1,D2
00000B78  6700 0090               2024s     BEQ _0000000C
00000B7C  43FA 0707               2025              LEA RAM_ERROR(PC),A1
00000B80                          2026m             PRINT_STR A1,D1
00000B80                          2027m LOOP_137
00000B80  0C11 0000               2028m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B84  6700 0016               2029m     BEQ EXIT_137
00000B88                          2030mm     PRINT_CHAR (A1)+,D1
00000B88                          2031mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2032mm     IFEQ DEBUG
00000B88  1239 00C00003           2033mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B8E  0801 0002               2034mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2035mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B94  13D9 00C00007           2036mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          2037mm     ENDC
00000B9A                          2038mm 
00000B9A                 FALSE    2039mm     IFNE DEBUG
00000B9A                          2040mm     ENDC
00000B9A                          2041mm 
00000B9A                          2042mm     ENDM
00000B9A  60E4                    2043m     BRA LOOP_137
00000B9C                          2044m EXIT_137
00000B9C                          2045m     ENDM
00000B9C  2208                    2046              MOVE.L A0,D1
00000B9E  5981                    2047              SUB.L #4,D1
00000BA0                          2048m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000BA0  43FA 0736               2049m     LEA OX(PC),A1
00000BA4                          2050mm     PRINT_STR A1,D3
00000BA4                          2051mm LOOP_140
00000BA4  0C11 0000               2052mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BA8  6700 0016               2053mm     BEQ EXIT_140
00000BAC                          2054mmm     PRINT_CHAR (A1)+,D3
00000BAC                          2055mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAC                 TRUE     2056mmm     IFEQ DEBUG
00000BAC  1639 00C00003           2057mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BB2  0803 0002               2058mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BB6  67F4                    2059mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000BB8  13D9 00C00007           2060mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BBE                          2061mmm     ENDC
00000BBE                          2062mmm 
00000BBE                 FALSE    2063mmm     IFNE DEBUG
00000BBE                          2064mmm     ENDC
00000BBE                          2065mmm 
00000BBE                          2066mmm     ENDM
00000BBE  60E4                    2067mm     BRA LOOP_140
00000BC0                          2068mm EXIT_140
00000BC0                          2069mm     ENDM
00000BC0  7C07                    2070m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BC2                          2071m LOOP_139
00000BC2                          2072mm     BIN2HEX D1,D2,A1
00000BC2  43FA 06D3               2073mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BC6  E999                    2074mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC8  1401                    2075mm     MOVE.B D1,D2
00000BCA  0282 0000000F           2076mm     ANDI.L #$F,D2
00000BD0  1431 2000               2077mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000BD4                          2078mm     ENDM
00000BD4                          2079mm     PRINT_CHAR D2,D3
00000BD4                          2080mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD4                 TRUE     2081mm     IFEQ DEBUG
00000BD4  1639 00C00003           2082mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BDA  0803 0002               2083mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BDE  67F4                    2084mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000BE0  13C2 00C00007           2085mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BE6                          2086mm     ENDC
00000BE6                          2087mm 
00000BE6                 FALSE    2088mm     IFNE DEBUG
00000BE6                          2089mm     ENDC
00000BE6                          2090mm 
00000BE6                          2091mm     ENDM
00000BE6  57CE FFDA               2092m     DBEQ D6,LOOP_139
00000BEA                          2093m     ENDM
00000BEA                          2094m             PRINT_CRLF D3,A1
00000BEA  43FA 06E6               2095m     LEA CRLF(PC),A1
00000BEE                          2096mm     PRINT_STR A1,D3
00000BEE                          2097mm LOOP_145
00000BEE  0C11 0000               2098mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BF2  6700 0016               2099mm     BEQ EXIT_145
00000BF6                          2100mmm     PRINT_CHAR (A1)+,D3
00000BF6                          2101mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF6                 TRUE     2102mmm     IFEQ DEBUG
00000BF6  1639 00C00003           2103mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BFC  0803 0002               2104mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C00  67F4                    2105mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C02  13D9 00C00007           2106mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C08                          2107mmm     ENDC
00000C08                          2108mmm 
00000C08                 FALSE    2109mmm     IFNE DEBUG
00000C08                          2110mmm     ENDC
00000C08                          2111mmm 
00000C08                          2112mmm     ENDM
00000C08  60E4                    2113mm     BRA LOOP_145
00000C0A                          2114mm EXIT_145
00000C0A                          2115mm     ENDM
00000C0A                          2116m     ENDM
00000C0A                          2117          ENDI 
00000C0A                          2118s _0000000C
00000C0A                          2119      ENDF
00000C0A  5880                    2120s     ADD.L   #4,D0
00000C0C                          2121s _20000007
00000C0C  B0BC 000FFFFC           2122s     CMP.L   #$FFFFC,D0
00000C12  6F00 FF52               2123s     BLE _20000006
00000C16                          2124  
00000C16  6000 F562               2125      BRA MAIN_LOOP
00000C1A                          2126  
00000C1A                          2127  L
00000C1A  7000                    2128      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C1C  7200                    2129      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C1E                          2130  
00000C1E                          2131      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C1E  343C 0000               2132s     MOVE.W  #0,D2
00000C22  6000 0046               2133s     BRA _20000009
00000C26                          2134s _20000008
00000C26  E989                    2135          LSL.L #4,D1                                 ; make what we have so far more significant
00000C28                          2136m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C28                          2137m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C28                 TRUE     2138m     IFEQ DEBUG
00000C28  1839 00C00003           2139m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C2E  0804 0000               2140m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000C32  67F4                    2141m         BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00000C34                          2142m     ENDC
00000C34                          2143m 
00000C34                          2144mm     READ_CHAR D3
00000C34                 TRUE     2145mm     IFEQ DEBUG
00000C34  1639 00C00007           2146mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000C3A                          2147mm     ENDC
00000C3A                 FALSE    2148mm     IFNE DEBUG
00000C3A                          2149mm     ENDC
00000C3A                          2150mm 
00000C3A  B63C 001B               2151mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000C3E  6700 F3C8               2152mm     BEQ START
00000C42                          2153mm     ENDM
00000C42                          2154m 
00000C42                 TRUE     2155m     IFEQ DEBUG
00000C42                          2156mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000C42                          2157mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C42                 TRUE     2158mm     IFEQ DEBUG
00000C42  1839 00C00003           2159mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C48  0804 0002               2160mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000C4C  67F4                    2161mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C4E  13C3 00C00007           2162mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C54                          2163mm     ENDC
00000C54                          2164mm 
00000C54                 FALSE    2165mm     IFNE DEBUG
00000C54                          2166mm     ENDC
00000C54                          2167mm 
00000C54                          2168mm     ENDM
00000C54                          2169m     ENDC
00000C54                          2170m     ENDM
00000C54                          2171m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C54  41FA 0651               2172m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C58  0403 0030               2173m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C5C  C6BC 000000FF           2174m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000C62  1630 3000               2175m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C66                          2176m     ENDM
00000C66  8203                    2177          OR.B D3,D1
00000C68                          2178      ENDF
00000C68  5242                    2179s     ADD.W   #1,D2
00000C6A                          2180s _20000009
00000C6A  B47C 0007               2181s     CMP.W   #7,D2
00000C6E  6FB6                    2182s     BLE _20000008
00000C70                          2183  
00000C70  3001                    2184      MOVE.W D1,D0                                    ; extract the LSword for the length
00000C72  E089                    2185      LSR.L #8,D1                                     ; extract the MSword for the address
00000C74  E089                    2186      LSR.L #8,D1
00000C76                          2187  
00000C76                          2188m     PRINT_CRLF D2,A1
00000C76  43FA 065A               2189m     LEA CRLF(PC),A1
00000C7A                          2190mm     PRINT_STR A1,D2
00000C7A                          2191mm LOOP_152
00000C7A  0C11 0000               2192mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C7E  6700 0016               2193mm     BEQ EXIT_152
00000C82                          2194mmm     PRINT_CHAR (A1)+,D2
00000C82                          2195mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C82                 TRUE     2196mmm     IFEQ DEBUG
00000C82  1439 00C00003           2197mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C88  0802 0002               2198mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C8C  67F4                    2199mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C8E  13D9 00C00007           2200mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C94                          2201mmm     ENDC
00000C94                          2202mmm 
00000C94                 FALSE    2203mmm     IFNE DEBUG
00000C94                          2204mmm     ENDC
00000C94                          2205mmm 
00000C94                          2206mmm     ENDM
00000C94  60E4                    2207mm     BRA LOOP_152
00000C96                          2208mm EXIT_152
00000C96                          2209mm     ENDM
00000C96                          2210m     ENDM
00000C96                          2211  
00000C96  2041                    2212      MOVE.L D1,A0                                    ; target address
00000C98                          2213  
00000C98  2247                    2214      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C9A  7E00                    2215      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C9C                          2216  
00000C9C  5089                    2217      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000C9E  5180                    2218      SUB.L #8,D0
00000CA0                          2219  
00000CA0                          2220m     UNPROTECT
00000CA0  31FC AAAA 2AAA          2221m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000CA6  4E71                    2222m     NOP
00000CA8  31FC 5555 1554          2223m     MOVE.W #$5555,$1554
00000CAE  4E71                    2224m     NOP
00000CB0  31FC 8080 2AAA          2225m     MOVE.W #$8080,$2AAA
00000CB6  4E71                    2226m     NOP
00000CB8  31FC AAAA 2AAA          2227m     MOVE.W #$AAAA,$2AAA
00000CBE  4E71                    2228m     NOP
00000CC0  31FC 5555 1554          2229m     MOVE.W #$5555,$1554
00000CC6  4E71                    2230m     NOP
00000CC8  31FC 2020 2AAA          2231m     MOVE.W #$2020,$2AAA
00000CCE                          2232m     ENDM
00000CCE                          2233  
00000CCE  45FA 05EE               2234      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000CD2                          2235m     PRINT_STR A2,D2
00000CD2                          2236m LOOP_155
00000CD2  0C12 0000               2237m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CD6  6700 0016               2238m     BEQ EXIT_155
00000CDA                          2239mm     PRINT_CHAR (A2)+,D2
00000CDA                          2240mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDA                 TRUE     2241mm     IFEQ DEBUG
00000CDA  1439 00C00003           2242mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CE0  0802 0002               2243mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CE4  67F4                    2244mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CE6  13DA 00C00007           2245mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CEC                          2246mm     ENDC
00000CEC                          2247mm 
00000CEC                 FALSE    2248mm     IFNE DEBUG
00000CEC                          2249mm     ENDC
00000CEC                          2250mm 
00000CEC                          2251mm     ENDM
00000CEC  60E4                    2252m     BRA LOOP_155
00000CEE                          2253m EXIT_155
00000CEE                          2254m     ENDM
00000CEE                          2255  
00000CEE  2409                    2256      MOVE.L A1,D2
00000CF0                          2257m     PRINT_REG D2,D3,D4,D5,A2
00000CF0  45FA 05E6               2258m     LEA OX(PC),A2
00000CF4                          2259mm     PRINT_STR A2,D3
00000CF4                          2260mm LOOP_158
00000CF4  0C12 0000               2261mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CF8  6700 0016               2262mm     BEQ EXIT_158
00000CFC                          2263mmm     PRINT_CHAR (A2)+,D3
00000CFC                          2264mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CFC                 TRUE     2265mmm     IFEQ DEBUG
00000CFC  1639 00C00003           2266mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D02  0803 0002               2267mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D06  67F4                    2268mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000D08  13DA 00C00007           2269mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D0E                          2270mmm     ENDC
00000D0E                          2271mmm 
00000D0E                 FALSE    2272mmm     IFNE DEBUG
00000D0E                          2273mmm     ENDC
00000D0E                          2274mmm 
00000D0E                          2275mmm     ENDM
00000D0E  60E4                    2276mm     BRA LOOP_158
00000D10                          2277mm EXIT_158
00000D10                          2278mm     ENDM
00000D10  7A07                    2279m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D12                          2280m LOOP_157
00000D12                          2281mm     BIN2HEX D2,D4,A2
00000D12  45FA 0583               2282mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D16  E99A                    2283mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D18  1802                    2284mm     MOVE.B D2,D4
00000D1A  0284 0000000F           2285mm     ANDI.L #$F,D4
00000D20  1832 4000               2286mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D24                          2287mm     ENDM
00000D24                          2288mm     PRINT_CHAR D4,D3
00000D24                          2289mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D24                 TRUE     2290mm     IFEQ DEBUG
00000D24  1639 00C00003           2291mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D2A  0803 0002               2292mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D2E  67F4                    2293mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D30  13C4 00C00007           2294mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D36                          2295mm     ENDC
00000D36                          2296mm 
00000D36                 FALSE    2297mm     IFNE DEBUG
00000D36                          2298mm     ENDC
00000D36                          2299mm 
00000D36                          2300mm     ENDM
00000D36  57CD FFDA               2301m     DBEQ D5,LOOP_157
00000D3A                          2302m     ENDM
00000D3A                          2303  
00000D3A  45FA 059F               2304      LEA TO(PC),A2
00000D3E                          2305m     PRINT_STR A2,D3
00000D3E                          2306m LOOP_162
00000D3E  0C12 0000               2307m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D42  6700 0016               2308m     BEQ EXIT_162
00000D46                          2309mm     PRINT_CHAR (A2)+,D3
00000D46                          2310mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D46                 TRUE     2311mm     IFEQ DEBUG
00000D46  1639 00C00003           2312mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D4C  0803 0002               2313mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D50  67F4                    2314mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D52  13DA 00C00007           2315mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D58                          2316mm     ENDC
00000D58                          2317mm 
00000D58                 FALSE    2318mm     IFNE DEBUG
00000D58                          2319mm     ENDC
00000D58                          2320mm 
00000D58                          2321mm     ENDM
00000D58  60E4                    2322m     BRA LOOP_162
00000D5A                          2323m EXIT_162
00000D5A                          2324m     ENDM
00000D5A                          2325  
00000D5A  2408                    2326      MOVE.L A0,D2
00000D5C                          2327m     PRINT_REG D2,D3,D4,D5,A2
00000D5C  45FA 057A               2328m     LEA OX(PC),A2
00000D60                          2329mm     PRINT_STR A2,D3
00000D60                          2330mm LOOP_165
00000D60  0C12 0000               2331mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D64  6700 0016               2332mm     BEQ EXIT_165
00000D68                          2333mmm     PRINT_CHAR (A2)+,D3
00000D68                          2334mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D68                 TRUE     2335mmm     IFEQ DEBUG
00000D68  1639 00C00003           2336mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D6E  0803 0002               2337mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D72  67F4                    2338mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D74  13DA 00C00007           2339mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D7A                          2340mmm     ENDC
00000D7A                          2341mmm 
00000D7A                 FALSE    2342mmm     IFNE DEBUG
00000D7A                          2343mmm     ENDC
00000D7A                          2344mmm 
00000D7A                          2345mmm     ENDM
00000D7A  60E4                    2346mm     BRA LOOP_165
00000D7C                          2347mm EXIT_165
00000D7C                          2348mm     ENDM
00000D7C  7A07                    2349m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D7E                          2350m LOOP_164
00000D7E                          2351mm     BIN2HEX D2,D4,A2
00000D7E  45FA 0517               2352mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D82  E99A                    2353mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D84  1802                    2354mm     MOVE.B D2,D4
00000D86  0284 0000000F           2355mm     ANDI.L #$F,D4
00000D8C  1832 4000               2356mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D90                          2357mm     ENDM
00000D90                          2358mm     PRINT_CHAR D4,D3
00000D90                          2359mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D90                 TRUE     2360mm     IFEQ DEBUG
00000D90  1639 00C00003           2361mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D96  0803 0002               2362mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D9A  67F4                    2363mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000D9C  13C4 00C00007           2364mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DA2                          2365mm     ENDC
00000DA2                          2366mm 
00000DA2                 FALSE    2367mm     IFNE DEBUG
00000DA2                          2368mm     ENDC
00000DA2                          2369mm 
00000DA2                          2370mm     ENDM
00000DA2  57CD FFDA               2371m     DBEQ D5,LOOP_164
00000DA6                          2372m     ENDM
00000DA6                          2373  
00000DA6                          2374m     PRINT_CRLF D3,A2
00000DA6  45FA 052A               2375m     LEA CRLF(PC),A2
00000DAA                          2376mm     PRINT_STR A2,D3
00000DAA                          2377mm LOOP_170
00000DAA  0C12 0000               2378mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DAE  6700 0016               2379mm     BEQ EXIT_170
00000DB2                          2380mmm     PRINT_CHAR (A2)+,D3
00000DB2                          2381mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB2                 TRUE     2382mmm     IFEQ DEBUG
00000DB2  1639 00C00003           2383mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DB8  0803 0002               2384mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DBC  67F4                    2385mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DBE  13DA 00C00007           2386mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DC4                          2387mmm     ENDC
00000DC4                          2388mmm 
00000DC4                 FALSE    2389mmm     IFNE DEBUG
00000DC4                          2390mmm     ENDC
00000DC4                          2391mmm 
00000DC4                          2392mmm     ENDM
00000DC4  60E4                    2393mm     BRA LOOP_170
00000DC6                          2394mm EXIT_170
00000DC6                          2395mm     ENDM
00000DC6                          2396m     ENDM
00000DC6                          2397  
00000DC6                          2398      WHILE D0 <GT> #0 DO
00000DC6                          2399s _10000014
00000DC6  B07C 0000               2400s     CMP.W   #0,D0
00000DCA  6F00 001C               2401s     BLE _10000015
00000DCE  5580                    2402          SUB.L #2,D0
00000DD0                          2403  
00000DD0  13D1 00E00001           2404          MOVE.B (A1),DISPLAY
00000DD6                          2405m         PROGRAM (A1),(A0),D2
00000DD6  3091                    2406m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000DD8                          2407m 
00000DD8                          2408m WAIT_FOR_COMPLETE_172
00000DD8  3410                    2409m         MOVE.W (A0),D2
00000DDA                          2410m 
00000DDA                          2411m         IF.W D2 <NE> (A1) THEN
00000DDA  B451                    2412ms     CMP.W   (A1),D2
00000DDC  6700 0004               2413ms     BEQ _0000000D
00000DE0  60F6                    2414m             BRA WAIT_FOR_COMPLETE_172
00000DE2                          2415m         ENDI
00000DE2                          2416ms _0000000D
00000DE2                          2417m         ENDM
00000DE2                          2418  
00000DE2  5488                    2419          ADD.L #2,A0
00000DE4  5489                    2420          ADD.L #2,A1
00000DE6                          2421      ENDW
00000DE6  60DE                    2422s     BRA _10000014
00000DE8                          2423s _10000015
00000DE8                          2424  
00000DE8                          2425m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000DE8  31FC 0000 0000          2426m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000DEE                          2427m 
00000DEE                          2428m WAIT_FOR_COMPLETE_173
00000DEE  3438 0000               2429m         MOVE.W $0,D2
00000DF2                          2430m 
00000DF2                          2431m         IF.W D2 <NE> #0 THEN
00000DF2  B47C 0000               2432ms     CMP.W   #0,D2
00000DF6  6700 0004               2433ms     BEQ _0000000E
00000DFA  60F2                    2434m             BRA WAIT_FOR_COMPLETE_173
00000DFC                          2435m         ENDI
00000DFC                          2436ms _0000000E
00000DFC                          2437m         ENDM
00000DFC                          2438m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000DFC  31FC 0000 0002          2439m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000E02                          2440m 
00000E02                          2441m WAIT_FOR_COMPLETE_174
00000E02  3438 0002               2442m         MOVE.W $2,D2
00000E06                          2443m 
00000E06                          2444m         IF.W D2 <NE> #0 THEN
00000E06  B47C 0000               2445ms     CMP.W   #0,D2
00000E0A  6700 0004               2446ms     BEQ _0000000F
00000E0E  60F2                    2447m             BRA WAIT_FOR_COMPLETE_174
00000E10                          2448m         ENDI
00000E10                          2449ms _0000000F
00000E10                          2450m         ENDM
00000E10                          2451  
00000E10                          2452m     PROGRAM D1, $6, D2
00000E10  31C1 0006               2453m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000E14                          2454m 
00000E14                          2455m WAIT_FOR_COMPLETE_175
00000E14  3438 0006               2456m         MOVE.W $6,D2
00000E18                          2457m 
00000E18                          2458m         IF.W D2 <NE> D1 THEN
00000E18  B441                    2459ms     CMP.W   D1,D2
00000E1A  6700 0004               2460ms     BEQ _00000010
00000E1E  60F4                    2461m             BRA WAIT_FOR_COMPLETE_175
00000E20                          2462m         ENDI
00000E20                          2463ms _00000010
00000E20                          2464m         ENDM
00000E20  E089                    2465      LSR.L #8,D1
00000E22  E089                    2466      LSR.L #8,D1
00000E24                          2467m     PROGRAM D1, $4, D2
00000E24  31C1 0004               2468m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000E28                          2469m 
00000E28                          2470m WAIT_FOR_COMPLETE_176
00000E28  3438 0004               2471m         MOVE.W $4,D2
00000E2C                          2472m 
00000E2C                          2473m         IF.W D2 <NE> D1 THEN
00000E2C  B441                    2474ms     CMP.W   D1,D2
00000E2E  6700 0004               2475ms     BEQ _00000011
00000E32  60F4                    2476m             BRA WAIT_FOR_COMPLETE_176
00000E34                          2477m         ENDI
00000E34                          2478ms _00000011
00000E34                          2479m         ENDM
00000E34                          2480  
00000E34                          2481m     PROTECT
00000E34  31FC AAAA 2AAA          2482m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000E3A  31FC 5555 1554          2483m     MOVE.W #$5555,$1554
00000E40  31FC A0A0 2AAA          2484m     MOVE.W #$A0A0,$2AAA
00000E46                          2485m     ENDM
00000E46                          2486  
00000E46  6000 F332               2487      BRA MAIN_LOOP
00000E4A                          2488  
00000E4A                          2489  P
00000E4A  7000                    2490      MOVE.L #0,D0                                    ; D0 will be the data to write
00000E4C                          2491  
00000E4C                          2492      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000E4C  323C 0000               2493s     MOVE.W  #0,D1
00000E50  6000 0046               2494s     BRA _2000000B
00000E54                          2495s _2000000A
00000E54  E988                    2496          LSL.L #4,D0                                 ; make what we have so far more significant
00000E56                          2497m         WAIT_CHAR D2,D3                             ; next character -> D2
00000E56                          2498m WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E56                 TRUE     2499m     IFEQ DEBUG
00000E56  1639 00C00003           2500m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E5C  0803 0000               2501m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E60  67F4                    2502m         BEQ WAIT_FOR_READY_178                      ; NOTHING, CHECK AGAIN
00000E62                          2503m     ENDC
00000E62                          2504m 
00000E62                          2505mm     READ_CHAR D2
00000E62                 TRUE     2506mm     IFEQ DEBUG
00000E62  1439 00C00007           2507mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000E68                          2508mm     ENDC
00000E68                 FALSE    2509mm     IFNE DEBUG
00000E68                          2510mm     ENDC
00000E68                          2511mm 
00000E68  B43C 001B               2512mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000E6C  6700 F19A               2513mm     BEQ START
00000E70                          2514mm     ENDM
00000E70                          2515m 
00000E70                 TRUE     2516m     IFEQ DEBUG
00000E70                          2517mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000E70                          2518mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E70                 TRUE     2519mm     IFEQ DEBUG
00000E70  1639 00C00003           2520mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E76  0803 0002               2521mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E7A  67F4                    2522mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E7C  13C2 00C00007           2523mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E82                          2524mm     ENDC
00000E82                          2525mm 
00000E82                 FALSE    2526mm     IFNE DEBUG
00000E82                          2527mm     ENDC
00000E82                          2528mm 
00000E82                          2529mm     ENDM
00000E82                          2530m     ENDC
00000E82                          2531m     ENDM
00000E82                          2532m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E82  41FA 0423               2533m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E86  0402 0030               2534m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E8A  C4BC 000000FF           2535m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E90  1430 2000               2536m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E94                          2537m     ENDM
00000E94  8002                    2538          OR.B D2,D0
00000E96                          2539      ENDF
00000E96  5241                    2540s     ADD.W   #1,D1
00000E98                          2541s _2000000B
00000E98  B27C 0003               2542s     CMP.W   #3,D1
00000E9C  6FB6                    2543s     BLE _2000000A
00000E9E                          2544  
00000E9E                          2545m     PRINT_CRLF D2,A1
00000E9E  43FA 0432               2546m     LEA CRLF(PC),A1
00000EA2                          2547mm     PRINT_STR A1,D2
00000EA2                          2548mm LOOP_183
00000EA2  0C11 0000               2549mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000EA6  6700 0016               2550mm     BEQ EXIT_183
00000EAA                          2551mmm     PRINT_CHAR (A1)+,D2
00000EAA                          2552mmm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EAA                 TRUE     2553mmm     IFEQ DEBUG
00000EAA  1439 00C00003           2554mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EB0  0802 0002               2555mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EB4  67F4                    2556mmm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00000EB6  13D9 00C00007           2557mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EBC                          2558mmm     ENDC
00000EBC                          2559mmm 
00000EBC                 FALSE    2560mmm     IFNE DEBUG
00000EBC                          2561mmm     ENDC
00000EBC                          2562mmm 
00000EBC                          2563mmm     ENDM
00000EBC  60E4                    2564mm     BRA LOOP_183
00000EBE                          2565mm EXIT_183
00000EBE                          2566mm     ENDM
00000EBE                          2567m     ENDM
00000EBE                          2568  
00000EBE  2047                    2569      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000EC0  7E00                    2570      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EC2                          2571  
00000EC2                          2572m     UNPROTECT
00000EC2  31FC AAAA 2AAA          2573m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EC8  4E71                    2574m     NOP
00000ECA  31FC 5555 1554          2575m     MOVE.W #$5555,$1554
00000ED0  4E71                    2576m     NOP
00000ED2  31FC 8080 2AAA          2577m     MOVE.W #$8080,$2AAA
00000ED8  4E71                    2578m     NOP
00000EDA  31FC AAAA 2AAA          2579m     MOVE.W #$AAAA,$2AAA
00000EE0  4E71                    2580m     NOP
00000EE2  31FC 5555 1554          2581m     MOVE.W #$5555,$1554
00000EE8  4E71                    2582m     NOP
00000EEA  31FC 2020 2AAA          2583m     MOVE.W #$2020,$2AAA
00000EF0                          2584m     ENDM
00000EF0                          2585               
00000EF0  45FA 03CC               2586      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000EF4                          2587m     PRINT_STR A2,D2
00000EF4                          2588m LOOP_186
00000EF4  0C12 0000               2589m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EF8  6700 0016               2590m     BEQ EXIT_186
00000EFC                          2591mm     PRINT_CHAR (A2)+,D2
00000EFC                          2592mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EFC                 TRUE     2593mm     IFEQ DEBUG
00000EFC  1439 00C00003           2594mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F02  0802 0002               2595mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F06  67F4                    2596mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000F08  13DA 00C00007           2597mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F0E                          2598mm     ENDC
00000F0E                          2599mm 
00000F0E                 FALSE    2600mm     IFNE DEBUG
00000F0E                          2601mm     ENDC
00000F0E                          2602mm 
00000F0E                          2603mm     ENDM
00000F0E  60E4                    2604m     BRA LOOP_186
00000F10                          2605m EXIT_186
00000F10                          2606m     ENDM
00000F10                          2607  
00000F10                          2608m     PRINT_CHAR '#',D3
00000F10                          2609m WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F10                 TRUE     2610m     IFEQ DEBUG
00000F10  1639 00C00003           2611m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F16  0803 0002               2612m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F1A  67F4                    2613m         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000F1C  13F8 0023 00C00007      2614m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000F24                          2615m     ENDC
00000F24                          2616m 
00000F24                 FALSE    2617m     IFNE DEBUG
00000F24                          2618m     ENDC
00000F24                          2619m 
00000F24                          2620m     ENDM
00000F24                          2621m     PRINT_REG D0,D3,D4,D5,A2
00000F24  45FA 03B2               2622m     LEA OX(PC),A2
00000F28                          2623mm     PRINT_STR A2,D3
00000F28                          2624mm LOOP_190
00000F28  0C12 0000               2625mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F2C  6700 0016               2626mm     BEQ EXIT_190
00000F30                          2627mmm     PRINT_CHAR (A2)+,D3
00000F30                          2628mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F30                 TRUE     2629mmm     IFEQ DEBUG
00000F30  1639 00C00003           2630mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F36  0803 0002               2631mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F3A  67F4                    2632mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
00000F3C  13DA 00C00007           2633mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F42                          2634mmm     ENDC
00000F42                          2635mmm 
00000F42                 FALSE    2636mmm     IFNE DEBUG
00000F42                          2637mmm     ENDC
00000F42                          2638mmm 
00000F42                          2639mmm     ENDM
00000F42  60E4                    2640mm     BRA LOOP_190
00000F44                          2641mm EXIT_190
00000F44                          2642mm     ENDM
00000F44  7A07                    2643m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F46                          2644m LOOP_189
00000F46                          2645mm     BIN2HEX D0,D4,A2
00000F46  45FA 034F               2646mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F4A  E998                    2647mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F4C  1800                    2648mm     MOVE.B D0,D4
00000F4E  0284 0000000F           2649mm     ANDI.L #$F,D4
00000F54  1832 4000               2650mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F58                          2651mm     ENDM
00000F58                          2652mm     PRINT_CHAR D4,D3
00000F58                          2653mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F58                 TRUE     2654mm     IFEQ DEBUG
00000F58  1639 00C00003           2655mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5E  0803 0002               2656mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F62  67F4                    2657mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F64  13C4 00C00007           2658mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F6A                          2659mm     ENDC
00000F6A                          2660mm 
00000F6A                 FALSE    2661mm     IFNE DEBUG
00000F6A                          2662mm     ENDC
00000F6A                          2663mm 
00000F6A                          2664mm     ENDM
00000F6A  57CD FFDA               2665m     DBEQ D5,LOOP_189
00000F6E                          2666m     ENDM
00000F6E                          2667  
00000F6E  45FA 036B               2668      LEA TO(PC),A2
00000F72                          2669m     PRINT_STR A2,D3
00000F72                          2670m LOOP_194
00000F72  0C12 0000               2671m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F76  6700 0016               2672m     BEQ EXIT_194
00000F7A                          2673mm     PRINT_CHAR (A2)+,D3
00000F7A                          2674mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F7A                 TRUE     2675mm     IFEQ DEBUG
00000F7A  1639 00C00003           2676mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F80  0803 0002               2677mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F84  67F4                    2678mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F86  13DA 00C00007           2679mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8C                          2680mm     ENDC
00000F8C                          2681mm 
00000F8C                 FALSE    2682mm     IFNE DEBUG
00000F8C                          2683mm     ENDC
00000F8C                          2684mm 
00000F8C                          2685mm     ENDM
00000F8C  60E4                    2686m     BRA LOOP_194
00000F8E                          2687m EXIT_194
00000F8E                          2688m     ENDM
00000F8E                          2689  
00000F8E  2408                    2690      MOVE.L A0,D2
00000F90                          2691m     PRINT_REG D2,D3,D4,D5,A2
00000F90  45FA 0346               2692m     LEA OX(PC),A2
00000F94                          2693mm     PRINT_STR A2,D3
00000F94                          2694mm LOOP_197
00000F94  0C12 0000               2695mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F98  6700 0016               2696mm     BEQ EXIT_197
00000F9C                          2697mmm     PRINT_CHAR (A2)+,D3
00000F9C                          2698mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F9C                 TRUE     2699mmm     IFEQ DEBUG
00000F9C  1639 00C00003           2700mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FA2  0803 0002               2701mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FA6  67F4                    2702mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000FA8  13DA 00C00007           2703mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FAE                          2704mmm     ENDC
00000FAE                          2705mmm 
00000FAE                 FALSE    2706mmm     IFNE DEBUG
00000FAE                          2707mmm     ENDC
00000FAE                          2708mmm 
00000FAE                          2709mmm     ENDM
00000FAE  60E4                    2710mm     BRA LOOP_197
00000FB0                          2711mm EXIT_197
00000FB0                          2712mm     ENDM
00000FB0  7A07                    2713m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FB2                          2714m LOOP_196
00000FB2                          2715mm     BIN2HEX D2,D4,A2
00000FB2  45FA 02E3               2716mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FB6  E99A                    2717mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FB8  1802                    2718mm     MOVE.B D2,D4
00000FBA  0284 0000000F           2719mm     ANDI.L #$F,D4
00000FC0  1832 4000               2720mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FC4                          2721mm     ENDM
00000FC4                          2722mm     PRINT_CHAR D4,D3
00000FC4                          2723mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC4                 TRUE     2724mm     IFEQ DEBUG
00000FC4  1639 00C00003           2725mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FCA  0803 0002               2726mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FCE  67F4                    2727mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00000FD0  13C4 00C00007           2728mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FD6                          2729mm     ENDC
00000FD6                          2730mm 
00000FD6                 FALSE    2731mm     IFNE DEBUG
00000FD6                          2732mm     ENDC
00000FD6                          2733mm 
00000FD6                          2734mm     ENDM
00000FD6  57CD FFDA               2735m     DBEQ D5,LOOP_196
00000FDA                          2736m     ENDM
00000FDA                          2737  
00000FDA                          2738m     PRINT_CRLF D3,A2
00000FDA  45FA 02F6               2739m     LEA CRLF(PC),A2
00000FDE                          2740mm     PRINT_STR A2,D3
00000FDE                          2741mm LOOP_202
00000FDE  0C12 0000               2742mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE2  6700 0016               2743mm     BEQ EXIT_202
00000FE6                          2744mmm     PRINT_CHAR (A2)+,D3
00000FE6                          2745mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FE6                 TRUE     2746mmm     IFEQ DEBUG
00000FE6  1639 00C00003           2747mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FEC  0803 0002               2748mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FF0  67F4                    2749mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00000FF2  13DA 00C00007           2750mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FF8                          2751mmm     ENDC
00000FF8                          2752mmm 
00000FF8                 FALSE    2753mmm     IFNE DEBUG
00000FF8                          2754mmm     ENDC
00000FF8                          2755mmm 
00000FF8                          2756mmm     ENDM
00000FF8  60E4                    2757mm     BRA LOOP_202
00000FFA                          2758mm EXIT_202
00000FFA                          2759mm     ENDM
00000FFA                          2760m     ENDM
00000FFA                          2761  
00000FFA                          2762m     PROGRAM D0,(A0),D2
00000FFA  3080                    2763m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FFC                          2764m 
00000FFC                          2765m WAIT_FOR_COMPLETE_204
00000FFC  3410                    2766m         MOVE.W (A0),D2
00000FFE                          2767m 
00000FFE                          2768m         IF.W D2 <NE> D0 THEN
00000FFE  B440                    2769ms     CMP.W   D0,D2
00001000  6700 0004               2770ms     BEQ _00000012
00001004  60F6                    2771m             BRA WAIT_FOR_COMPLETE_204
00001006                          2772m         ENDI
00001006                          2773ms _00000012
00001006                          2774m         ENDM
00001006                          2775  
00001006                          2776m     PROTECT
00001006  31FC AAAA 2AAA          2777m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000100C  31FC 5555 1554          2778m     MOVE.W #$5555,$1554
00001012  31FC A0A0 2AAA          2779m     MOVE.W #$A0A0,$2AAA
00001018                          2780m     ENDM
00001018                          2781  
00001018  6000 F160               2782      BRA MAIN_LOOP
0000101C                          2783      
0000101C                          2784  M
0000101C  7000                    2785      MOVE.L #0,D0                                        ; D0 will be the length to read            
0000101E  7200                    2786      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001020                          2787  
00001020                          2788      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001020  343C 0000               2789s     MOVE.W  #0,D2
00001024  6000 0046               2790s     BRA _2000000D
00001028                          2791s _2000000C
00001028  E989                    2792          LSL.L #4,D1                                     ; make what we have so far more significant
0000102A                          2793m         WAIT_CHAR D3,D4                                 ; next character -> D2
0000102A                          2794m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102A                 TRUE     2795m     IFEQ DEBUG
0000102A  1839 00C00003           2796m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001030  0804 0000               2797m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001034  67F4                    2798m         BEQ WAIT_FOR_READY_206                      ; NOTHING, CHECK AGAIN
00001036                          2799m     ENDC
00001036                          2800m 
00001036                          2801mm     READ_CHAR D3
00001036                 TRUE     2802mm     IFEQ DEBUG
00001036  1639 00C00007           2803mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
0000103C                          2804mm     ENDC
0000103C                 FALSE    2805mm     IFNE DEBUG
0000103C                          2806mm     ENDC
0000103C                          2807mm 
0000103C  B63C 001B               2808mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001040  6700 EFC6               2809mm     BEQ START
00001044                          2810mm     ENDM
00001044                          2811m 
00001044                 TRUE     2812m     IFEQ DEBUG
00001044                          2813mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001044                          2814mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001044                 TRUE     2815mm     IFEQ DEBUG
00001044  1839 00C00003           2816mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000104A  0804 0002               2817mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
0000104E  67F4                    2818mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
00001050  13C3 00C00007           2819mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001056                          2820mm     ENDC
00001056                          2821mm 
00001056                 FALSE    2822mm     IFNE DEBUG
00001056                          2823mm     ENDC
00001056                          2824mm 
00001056                          2825mm     ENDM
00001056                          2826m     ENDC
00001056                          2827m     ENDM
00001056                          2828m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00001056  41FA 024F               2829m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000105A  0403 0030               2830m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000105E  C6BC 000000FF           2831m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001064  1630 3000               2832m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001068                          2833m     ENDM
00001068  8203                    2834          OR.B D3,D1
0000106A                          2835      ENDF
0000106A  5242                    2836s     ADD.W   #1,D2
0000106C                          2837s _2000000D
0000106C  B47C 0007               2838s     CMP.W   #7,D2
00001070  6FB6                    2839s     BLE _2000000C
00001072                          2840m     PRINT_CRLF D2,A1
00001072  43FA 025E               2841m     LEA CRLF(PC),A1
00001076                          2842mm     PRINT_STR A1,D2
00001076                          2843mm LOOP_211
00001076  0C11 0000               2844mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000107A  6700 0016               2845mm     BEQ EXIT_211
0000107E                          2846mmm     PRINT_CHAR (A1)+,D2
0000107E                          2847mmm WAIT_FOR_READY_212                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000107E                 TRUE     2848mmm     IFEQ DEBUG
0000107E  1439 00C00003           2849mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001084  0802 0002               2850mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001088  67F4                    2851mmm         BEQ WAIT_FOR_READY_212                      ; NO SPACE, CHECK AGAIN
0000108A  13D9 00C00007           2852mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001090                          2853mmm     ENDC
00001090                          2854mmm 
00001090                 FALSE    2855mmm     IFNE DEBUG
00001090                          2856mmm     ENDC
00001090                          2857mmm 
00001090                          2858mmm     ENDM
00001090  60E4                    2859mm     BRA LOOP_211
00001092                          2860mm EXIT_211
00001092                          2861mm     ENDM
00001092                          2862m     ENDM
00001092                          2863  
00001092  3001                    2864      MOVE.W D1,D0                                        ; extract the LSword for the length
00001094  E089                    2865      LSR.L #8,D1                                         ; extract the MSword for the address
00001096  E089                    2866      LSR.L #8,D1
00001098                          2867  
00001098  2241                    2868      MOVE.L D1,A1
0000109A                          2869      
0000109A  2047                    2870      MOVE.L D7,A0                                        ; address accumulator -> target address register
0000109C                          2871      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
0000109C                          2872  
0000109C                          2873      WHILE D0 <GT> #0 DO
0000109C                          2874s _10000016
0000109C  B07C 0000               2875s     CMP.W   #0,D0
000010A0  6F00 000E               2876s     BLE _10000017
000010A4  5580                    2877          SUB.L #2,D0
000010A6                          2878  
000010A6  13D1 00E00001           2879          MOVE.B (A1),DISPLAY
000010AC  30D9                    2880          MOVE.W (A1)+,(A0)+
000010AE                          2881      ENDW
000010AE  60EC                    2882s     BRA _10000016
000010B0                          2883s _10000017
000010B0                          2884      
000010B0  6000 F0C8               2885      BRA MAIN_LOOP
000010B4                          2886      
000010B4                          2887  j
000010B4  2047                    2888      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
000010B6  7E00                    2889      MOVE.L #0,D7
000010B8  2E7C 002FFFFC           2890      MOVE.L #$2FFFFC,A7                                  ; set up the stack pointer 
000010BE  2C7C 002FFFFC           2891      MOVE.L #$2FFFFC,A6                                  ; set up the frame pointer
000010C4  4E90                    2892      JSR (A0)
000010C6                          2893      
000010C6  41FA 0218               2894      LEA BACK(PC),A0
000010CA                          2895m     PRINT_STR A0,D0
000010CA                          2896m LOOP_213
000010CA  0C10 0000               2897m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000010CE  6700 0016               2898m     BEQ EXIT_213
000010D2                          2899mm     PRINT_CHAR (A0)+,D0
000010D2                          2900mm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010D2                 TRUE     2901mm     IFEQ DEBUG
000010D2  1039 00C00003           2902mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000010D8  0800 0002               2903mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000010DC  67F4                    2904mm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
000010DE  13D8 00C00007           2905mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010E4                          2906mm     ENDC
000010E4                          2907mm 
000010E4                 FALSE    2908mm     IFNE DEBUG
000010E4                          2909mm     ENDC
000010E4                          2910mm 
000010E4                          2911mm     ENDM
000010E4  60E4                    2912m     BRA LOOP_213
000010E6                          2913m EXIT_213
000010E6                          2914m     ENDM
000010E6                          2915      
000010E6  6000 F092               2916      BRA MAIN_LOOP
000010EA                          2917  
000010EA                          2918  HEX_DIGIT
000010EA  E98F                    2919      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000010EC                          2920m     HEX2BIN D2,D2,A0
000010EC  41FA 01B9               2921m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000010F0  0402 0030               2922m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010F4  C4BC 000000FF           2923m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000010FA  1430 2000               2924m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000010FE                          2925m     ENDM
000010FE  8E02                    2926      OR.B D2,D7  
00001100  6000 F098               2927      BRA GET_INPUT
00001104                          2928  
00001104  FFFF FFFF               2929      SIMHALT                                             ; halt simulator
00001108                          2930  
00001108                          2931  ; strings
00001108= 50 72 65 73 73 20 ...   2932  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
0000111B= 5B 3F 5D 09 09 09 ...   2933  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001127= 5B 76 5D 09 09 09 ...   2934          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001136= 78 78 78 78 78 78 ...   2935          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000114E= 78 78 78 78 78 78 ...   2936          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000116E= 78 78 78 78 78 78 ...   2937          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
0000118F= 78 78 78 78 78 78 ...   2938          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000011A0= 5B 7A 5D 09 09 09 ...   2939          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
000011B2= 78 78 78 78 78 78 ...   2940          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000011D3= 78 78 78 78 78 78 ...   2941          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000011F2= 78 78 78 78 78 78 ...   2942          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001216= 78 78 78 78 78 78 ...   2943          DC.B 'xxxxxxxx[j]',TAB,TAB,'JST to C code',CR,LF,NULL
00001233= 48 75 68 3F 0D 0A 00    2944  HUH  DC.B 'Huh?',CR,LF,NULL
0000123A= 20 53 20 72 65 63 ...   2945  READ    DC.B ' S records read, start address = ',NULL
0000125C= 57 3A 20 55 6E 6B ...   2946  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001273= 57 3A 20 43 53 20 ...   2947  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001285= 57 3A 20 52 41 4D ...   2948  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
00001297= 30 31 32 33 34 35 ...   2949  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000012A7= 00 01 02 03 04 05 ...   2950  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000012BE= 4C 6F 61 64 69 6E ...   2951  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000012D2= 0D 0A 00                2952  CRLF    DC.B CR,LF,NULL
000012D5= 3E 20 00                2953  PROMPT  DC.B '> ',NULL
000012D8= 30 78 00                2954  ox      DC.B '0x',NULL
000012DB= 20 2D 3E 20 00          2955  to      DC.B ' -> ',NULL
000012E0= 62 61 63 6B 20 66 ...   2956  BACK    DC.B 'back from the dead!',CR,LF,NULL
000012F6= 4D 44 46 2D 6D 6F ...   2957  VERSION DC.B 'MDF-mon V1.78 (14/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001313                          2958  
00001313                          2959      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BACK                12E0
BIN2HEX             0
BIN2HEX_LUT         1297
CONTINUE_105        94A
CONTINUE_46         426
CONTINUE_49         476
CONTINUE_53         4CC
CONTINUE_61         580
CONTINUE_66         5F2
CONTINUE_71         66E
CONTINUE_76         6EC
CONTINUE_81         774
CONTINUE_86         7E6
CONTINUE_91         858
CR                  D
CRLF                12D2
CS_FAILURE          1273
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A54
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            91C
EXIT_110            9B2
EXIT_112            9DA
EXIT_115            9FA
EXIT_12             170
EXIT_120            A44
EXIT_123            A74
EXIT_127            ABE
EXIT_130            AE0
EXIT_135            B2A
EXIT_137            B9C
EXIT_14             19A
EXIT_140            BC0
EXIT_145            C0A
EXIT_152            C96
EXIT_155            CEE
EXIT_158            D10
EXIT_162            D5A
EXIT_165            D7C
EXIT_170            DC6
EXIT_183            EBE
EXIT_186            F10
EXIT_190            F44
EXIT_194            F8E
EXIT_197            FB0
EXIT_20             22E
EXIT_202            FFA
EXIT_211            1092
EXIT_213            10E6
EXIT_22             286
EXIT_24             2B2
EXIT_27             2DC
EXIT_37             38A
EXIT_44             3FE
EXIT_5              110
EXIT_58             53C
EXIT_7              130
EXIT_9              150
EXIT_96             8CA
EXIT_98             8EA
G                   B2E
GET_INPUT           19A
H                   28A
HELP                111B
HELPPROMPT          1108
HEX2BIN             10B
HEX2BIN_LUT         12A7
HEX_DIGIT           10EA
HUH                 1233
J                   10B4
L                   C1A
LF                  A
LOADING             12BE
LOOP_102            900
LOOP_110            996
LOOP_112            9BE
LOOP_114            9FC
LOOP_115            9DE
LOOP_12             154
LOOP_120            A28
LOOP_122            A76
LOOP_123            A58
LOOP_127            AA2
LOOP_129            AE2
LOOP_130            AC4
LOOP_135            B0E
LOOP_137            B80
LOOP_139            BC2
LOOP_14             17E
LOOP_140            BA4
LOOP_145            BEE
LOOP_152            C7A
LOOP_155            CD2
LOOP_157            D12
LOOP_158            CF4
LOOP_162            D3E
LOOP_164            D7E
LOOP_165            D60
LOOP_170            DAA
LOOP_183            EA2
LOOP_186            EF4
LOOP_189            F46
LOOP_190            F28
LOOP_194            F72
LOOP_196            FB2
LOOP_197            F94
LOOP_20             212
LOOP_202            FDE
LOOP_211            1076
LOOP_213            10CA
LOOP_22             26A
LOOP_24             296
LOOP_26             2DE
LOOP_27             2C0
LOOP_37             36E
LOOP_44             3E2
LOOP_5              F4
LOOP_58             520
LOOP_7              114
LOOP_9              134
LOOP_96             8AE
LOOP_98             8CE
M                   101C
MAIN_LOOP           17A
NULL                0
OX                  12D8
P                   E4A
PRINTSTR            296
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              12D5
PROTECT             A40
R                   2B6
RAM                 200000
RAM_ERROR           1285
READ                123A
READ_CHAR           62D
READ_DATA_TO_POKE   392
RESET               4
ROM                 0
S                   402
STACK               0
START               8
TAB                 9
TO                  12DB
UNPROTECT           979
UNREC               125C
V                   292
VERSION             12F6
W                   38E
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_172  DD8
WAIT_FOR_COMPLETE_173  DEE
WAIT_FOR_COMPLETE_174  E02
WAIT_FOR_COMPLETE_175  E14
WAIT_FOR_COMPLETE_176  E28
WAIT_FOR_COMPLETE_204  FFC
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8EA
WAIT_FOR_READY_103  908
WAIT_FOR_READY_105  92E
WAIT_FOR_READY_107  962
WAIT_FOR_READY_111  99E
WAIT_FOR_READY_113  9C6
WAIT_FOR_READY_116  9E6
WAIT_FOR_READY_118  A0E
WAIT_FOR_READY_121  A30
WAIT_FOR_READY_124  A60
WAIT_FOR_READY_126  A88
WAIT_FOR_READY_128  AAA
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  ACC
WAIT_FOR_READY_133  AF4
WAIT_FOR_READY_136  B16
WAIT_FOR_READY_138  B88
WAIT_FOR_READY_141  BAC
WAIT_FOR_READY_143  BD4
WAIT_FOR_READY_146  BF6
WAIT_FOR_READY_147  C28
WAIT_FOR_READY_149  C42
WAIT_FOR_READY_15   186
WAIT_FOR_READY_153  C82
WAIT_FOR_READY_156  CDA
WAIT_FOR_READY_159  CFC
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  D24
WAIT_FOR_READY_163  D46
WAIT_FOR_READY_166  D68
WAIT_FOR_READY_168  D90
WAIT_FOR_READY_171  DB2
WAIT_FOR_READY_178  E56
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  E70
WAIT_FOR_READY_184  EAA
WAIT_FOR_READY_187  EFC
WAIT_FOR_READY_188  F10
WAIT_FOR_READY_191  F30
WAIT_FOR_READY_193  F58
WAIT_FOR_READY_195  F7A
WAIT_FOR_READY_198  F9C
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_200  FC4
WAIT_FOR_READY_203  FE6
WAIT_FOR_READY_206  102A
WAIT_FOR_READY_208  1044
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_212  107E
WAIT_FOR_READY_214  10D2
WAIT_FOR_READY_23   272
WAIT_FOR_READY_25   29E
WAIT_FOR_READY_28   2C8
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2F0
WAIT_FOR_READY_31   306
WAIT_FOR_READY_32   31C
WAIT_FOR_READY_33   330
WAIT_FOR_READY_34   344
WAIT_FOR_READY_35   358
WAIT_FOR_READY_38   376
WAIT_FOR_READY_39   394
WAIT_FOR_READY_41   3AE
WAIT_FOR_READY_45   3EA
WAIT_FOR_READY_46   40A
WAIT_FOR_READY_48   444
WAIT_FOR_READY_49   45A
WAIT_FOR_READY_51   48E
WAIT_FOR_READY_53   4B0
WAIT_FOR_READY_55   4E4
WAIT_FOR_READY_59   528
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   564
WAIT_FOR_READY_63   598
WAIT_FOR_READY_66   5D6
WAIT_FOR_READY_68   60A
WAIT_FOR_READY_71   652
WAIT_FOR_READY_73   686
WAIT_FOR_READY_76   6D0
WAIT_FOR_READY_78   704
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   758
WAIT_FOR_READY_83   78C
WAIT_FOR_READY_86   7CA
WAIT_FOR_READY_88   7FE
WAIT_FOR_READY_91   83C
WAIT_FOR_READY_93   870
WAIT_FOR_READY_97   8B6
WAIT_FOR_READY_99   8D6
WAIT_FOR_SRECORD    40A
Z                   B36
_00000000           1DA
_00000001           1EE
_00000002           544
_00000003           920
_00000004           552
_00000005           740
_00000006           6B6
_00000007           920
_00000008           8AA
_00000009           920
_0000000A           A48
_0000000B           A54
_0000000C           C0A
_0000000D           DE2
_0000000E           DFC
_0000000F           E10
_00000010           E20
_00000011           E34
_00000012           1006
_10000000           4A6
_10000001           50E
_10000002           55A
_10000003           5C2
_10000004           5CC
_10000005           634
_10000006           648
_10000007           6B0
_10000008           6BA
_10000009           73A
_1000000A           6C6
_1000000B           72E
_1000000C           74E
_1000000D           7B6
_1000000E           7C0
_1000000F           828
_10000010           832
_10000011           89A
_10000012           924
_10000013           98C
_10000014           DC6
_10000015           DE8
_10000016           109C
_10000017           10B0
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           B42
_20000005           B52
_20000006           B66
_20000007           C0C
_20000008           C26
_20000009           C6A
_2000000A           E54
_2000000B           E98
_2000000C           1028
_2000000D           106C
