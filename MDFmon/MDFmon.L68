00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 15:57:17

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  
00000000                            12  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            16  ; fix being able to enter random chars when W'ing
00000000                            17  ; ram check at startup?  Not sure if this is a good idea!
00000000                            18  
00000000                            19      ;ORG  $0
00200000                            20      ORG  $200000
00200000                            21  
00200000  =00000000                 22  DEBUG               EQU 0
00200000                            23  
00200000                            24  ; constants
00200000  =00000000                 25  NULL                EQU 0
00200000  =00000009                 26  TAB                 EQU 9
00200000  =0000000D                 27  CR                  EQU 13
00200000  =0000000A                 28  LF                  EQU 10
00200000                            29  
00200000  =00000000                 30  ROM                 EQU $0
00200000  =00200000                 31  RAM                 EQU $200000
00200000                            32     
00200000  =00C00000                 33  DUART_BASE          EQU $C00000
00200000  =00000000                 34  DUART_MRA_          EQU $0
00200000  =00000001                 35  DUART_CSRA_         EQU $1
00200000  =00000001                 36  DUART_SRA_          EQU $1
00200000  =00000002                 37  DUART_CRA_          EQU $2
00200000  =00000003                 38  DUART_TXA_          EQU $3
00200000  =00000003                 39  DUART_RXA_          EQU $3
00200000  =00000004                 40  DUART_ACR_          EQU $4
00200000  =00000005                 41  DUART_IMR_          EQU $5
00200000  =00000008                 42  DUART_MRB_          EQU $8
00200000  =00000009                 43  DUART_CSRB_         EQU $9
00200000  =00000009                 44  DUART_SRB_          EQU $9
00200000  =0000000A                 45  DUART_CRB_          EQU $A
00200000  =0000000B                 46  DUART_TXB_          EQU $B
00200000  =0000000B                 47  DUART_RXB_          EQU $B
00200000  =0000000C                 48  DUART_IVR_          EQU $C
00200000  =0000000D                 49  DUART_OPCR_         EQU $D
00200000  =0000000E                 50  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 51  DUART_RESET_OPR_    EQU $F
00200000                            52  
00200000  =00C00001                 53  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 54  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 55  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 56  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 57  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 58  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            59  
00200000  =00C00011                 60  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 61  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 62  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 63  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 64  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 65  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            66  
00200000  =00C00009                 67  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 68  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 69  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 70  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 71  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 72  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            73  
00200000  =00E00000                 74  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 75  DISPLAY_            EQU $0
00200000  =00E00001                 76  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            77  
00200000                            78  ; macros
00200000                            79  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            80  ; the input register is changed during the process
00200000                            81  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            82  BIN2HEX MACRO
00200000                            83      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            84      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            85      MOVE.B \1,\2
00200000                            86      ANDI.L #$F,\2
00200000                            87      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            88      ENDM
00200000                            89  
00200000                            90  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            91  ; the input register is changed during the process
00200000                            92  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            93  HEX2BIN MACRO
00200000                            94      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00200000                            95      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00200000                            96      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00200000                            97      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00200000                            98      ENDM
00200000                            99  
00200000                           100  ; send a single char to the serial port
00200000                           101  ; \1 = char to send, \2 = data register to use for status poll
00200000                           102  ; will stamp on D0 and D1 in debug mode
00200000                           103  PRINT_CHAR MACRO
00200000                           104  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           105      IFEQ DEBUG
00200000                           106          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           107          BTST #2,\2                              ; check for space to send
00200000                           108          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           109          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           110      ENDC
00200000                           111      
00200000                           112      IFNE DEBUG
00200000                           113          MOVE.B \1,D1
00200000                           114          MOVE.L #6,D0   
00200000                           115          TRAP #15                                ; write to terminal in simulator
00200000                           116      ENDC
00200000                           117  
00200000                           118      ENDM
00200000                           119  
00200000                           120  ; send CR,LF to the serial port
00200000                           121  ; \1 = data register to use for status poll
00200000                           122  PRINT_CRLF MACRO
00200000                           123      PRINT_CHAR #CR,\1                           ; CR
00200000                           124      PRINT_CHAR #LF,\1                           ; LF
00200000                           125      ENDM
00200000                           126  
00200000                           127  ; send C-style, zero terminated string to the serial port
00200000                           128  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           129  PRINT_STR MACRO
00200000                           130  LOOP\@
00200000                           131      CMP.B #NULL,(\1)                            ; 0 -> done
00200000                           132      BEQ EXIT\@
00200000                           133      PRINT_CHAR (\1)+,\2
00200000                           134      BRA LOOP\@
00200000                           135  EXIT\@
00200000                           136      ENDM
00200000                           137    
00200000                           138  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           139  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00200000                           140  PRINT_REG MACRO
00200000                           141      PRINT_CHAR #'0',\2                              ;0x header
00200000                           142      PRINT_CHAR #'x',\2
00200000                           143      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00200000                           144  LOOP\@
00200000                           145      BIN2HEX \1,\3,\5
00200000                           146      PRINT_CHAR \3,\2
00200000                           147      DBEQ \4,LOOP\@
00200000                           148      ENDM
00200000                           149      
00200000                           150  ; wait for a char from the serial port
00200000                           151  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           152  ; will stamp on D0 and D1 in debug mode
00200000                           153  WAIT_CHAR MACRO
00200000                           154  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           155      IFEQ DEBUG
00200000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00200000                           157          BTST #0,\2                              ; check for character
00200000                           158          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           159      ENDC
00200000                           160      
00200000                           161      READ_CHAR \1
00200000                           162  
00200000                           163      IFEQ DEBUG
00200000                           164          PRINT_CHAR \1,\2                            ; echo it back
00200000                           165      ENDC
00200000                           166      ENDM
00200000                           167      
00200000                           168  ; read a char from the serial port - assumes that there is one!
00200000                           169  ; \ 1= data register for read char
00200000                           170  ; will stamp on D0 and D1 in debug mode
00200000                           171  READ_CHAR MACRO
00200000                           172      IFEQ DEBUG
00200000                           173          MOVE.B DUART_RXA,\1                         ; got a character, read it
00200000                           174      ENDC
00200000                           175      IFNE DEBUG
00200000                           176          MOVE.L #5,D0    
00200000                           177          TRAP #15                                    ; read from keyboard in simulator
00200000                           178          MOVE.L D1,\1
00200000                           179      ENDC
00200000                           180       
00200000                           181      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           182      BEQ START
00200000                           183      ENDM
00200000                           184      
00200000                           185      
00200000                           186  ; read data from the download serial port
00200000                           187  ; \ 1= data register for read char
00200000                           188  DOWNLOAD MACRO
00200000                           189  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           190  
00200000                           191      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           192      BTST #0,\1                                  ; check for character
00200000                           193      BEQ CONTINUE\@                              ; nothing, continue
00200000                           194   
00200000                           195      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           196  CONTINUE\@
00200000                           197      MOVE.B DUART_SRB,\1                             ; read download status register
00200000                           198      BTST #0,\1                                      ; check for character
00200000                           199      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00200000                           200      
00200000                           201      MOVE.B DUART_RXB,\1                             ; got a character, read it
00200000                           202      MOVE.B \1,DISPLAY                               ; echo to the display
00200000                           203      
00200000                           204      ENDM
00200000                           205      
00200000                           206  ; read two hex digits from the download serial port and convert to a byte
00200000                           207  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           208  DOWNLOAD_BYTE MACRO
00200000                           209      MOVE.B #2,\4
00200000                           210      WHILE.B \4 <GT> 0 DO
00200000                           211          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00200000                           212          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00200000                           213          PRINT_CHAR \2,\3
00200000                           214          HEX2BIN \2,\2,\6
00200000                           215          OR.B \2,\1
00200000                           216          SUB.B #1,\4
00200000                           217      ENDW
00200000                           218      
00200000                           219      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00200000                           220      MOVE.B \1,\2
00200000                           221      ADD.L \1,\5
00200000                           222  
00200000                           223      ENDM
00200000                           224      
00200000                           225  
00200000                           226  ; register catalogue
00200000                           227  ; D0 - used for simulator I/O
00200000                           228  ; D1 - used for simulator I/O
00200000                           229  ; D2 - read character
00200000                           230  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           231  ; D6 - working register used in R/W
00200000                           232  ; D7 - address accumulator, reset by download
00200000                           233  ; A0 - address of string to print 
00200000                           234  
00200000                           235  ; start vector
00200000= 00000000                 236  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 237  RESET    DC.L START                             ; RESET
00200008                           238      
00200008                           239  ; start of program  
00200008                           240  START
00200008  13FC 0000 00E00001       241      MOVE.B #0,DISPLAY
00200010                           242  
00200010                           243  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       244      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00200018  13FC 0050 00C00005       245      MOVE.B #$50,DUART_CRA                           ; reset everyting
00200020  4E71                     246      NOP
00200022  13FC 0040 00C00005       247      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     248      NOP
0020002C  13FC 0030 00C00005       249      MOVE.B #$30,DUART_CRA
00200034  4E71                     250      NOP
00200036  13FC 0020 00C00005       251      MOVE.B #$20,DUART_CRA
0020003E  4E71                     252      NOP
00200040  13FC 0010 00C00005       253      MOVE.B #$10,DUART_CRA   
00200048                           254  
00200048  13FC 000A 00C00015       255      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00200050  13FC 0050 00C00015       256      MOVE.B #$50,DUART_CRB                           ; reset everyting
00200058  4E71                     257      NOP
0020005A  13FC 0040 00C00015       258      MOVE.B #$40,DUART_CRB           
00200062  4E71                     259      NOP
00200064  13FC 0030 00C00015       260      MOVE.B #$30,DUART_CRB
0020006C  4E71                     261      NOP
0020006E  13FC 0020 00C00015       262      MOVE.B #$20,DUART_CRB
00200076  4E71                     263      NOP
00200078  13FC 0010 00C00015       264      MOVE.B #$10,DUART_CRB   
00200080                           265  
00200080                           266  ;initialise UART
00200080  13FC 0000 00C00009       267      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       268      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00200090  13FC 0000 00C0001B       269      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00200098                           270  
00200098                           271  ; channel A
00200098  13FC 0013 00C00001       272      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       273      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
002000A8  13FC 00CC 00C00003       274      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
002000B0  13FC 0005 00C00005       275      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
002000B8                           276  
002000B8                           277  ; channel B
002000B8  13FC 0013 00C00011       278      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       279      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
002000C8  13FC 00CC 00C00013       280      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
002000D0  13FC 0005 00C00015       281      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
002000D8                           282  
002000D8                           283m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
002000D8                           284m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      285m     IFEQ DEBUG
002000D8  1639 00C00003            286m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                287m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     288m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       289m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           290m     ENDC
002000EC                           291m     
002000EC                 FALSE     292m     IFNE DEBUG
002000EC                           293m     ENDC
002000EC                           294m 
002000EC                           295m     ENDM
002000EC                           296  
002000EC  13FC 0001 00E00001       297      MOVE.B #1,DISPLAY
002000F4                           298         
002000F4                           299m     PRINT_CRLF D3
002000F4                           300mm     PRINT_CHAR #CR,D3                           ; CR
002000F4                           301mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      302mm     IFEQ DEBUG
002000F4  1639 00C00003            303mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                304mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     305mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       306mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           307mm     ENDC
00200108                           308mm     
00200108                 FALSE     309mm     IFNE DEBUG
00200108                           310mm     ENDC
00200108                           311mm 
00200108                           312mm     ENDM
00200108                           313mm     PRINT_CHAR #LF,D3                           ; LF
00200108                           314mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      315mm     IFEQ DEBUG
00200108  1639 00C00003            316mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                317mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     318mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       319mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           320mm     ENDC
0020011C                           321mm     
0020011C                 FALSE     322mm     IFNE DEBUG
0020011C                           323mm     ENDC
0020011C                           324mm 
0020011C                           325mm     ENDM
0020011C                           326m     ENDM
0020011C                           327  
0020011C  41F9 00200E28            328      LEA VERSION,A0
00200122                           329m     PRINT_STR A0,D3
00200122                           330m LOOP_5
00200122  0C10 0000                331m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00200126  6700 0016                332m     BEQ EXIT_5
0020012A                           333mm     PRINT_CHAR (A0)+,D3
0020012A                           334mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      335mm     IFEQ DEBUG
0020012A  1639 00C00003            336mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                337mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     338mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            339mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           340mm     ENDC
0020013C                           341mm     
0020013C                 FALSE     342mm     IFNE DEBUG
0020013C                           343mm     ENDC
0020013C                           344mm 
0020013C                           345mm     ENDM
0020013C  60E4                     346m     BRA LOOP_5
0020013E                           347m EXIT_5
0020013E                           348m     ENDM
0020013E                           349m     PRINT_CRLF D3
0020013E                           350mm     PRINT_CHAR #CR,D3                           ; CR
0020013E                           351mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020013E                 TRUE      352mm     IFEQ DEBUG
0020013E  1639 00C00003            353mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200144  0803 0002                354mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200148  67F4                     355mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014A  13FC 000D 00C00007       356mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200152                           357mm     ENDC
00200152                           358mm     
00200152                 FALSE     359mm     IFNE DEBUG
00200152                           360mm     ENDC
00200152                           361mm 
00200152                           362mm     ENDM
00200152                           363mm     PRINT_CHAR #LF,D3                           ; LF
00200152                           364mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200152                 TRUE      365mm     IFEQ DEBUG
00200152  1639 00C00003            366mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200158  0803 0002                367mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020015C  67F4                     368mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0020015E  13FC 000A 00C00007       369mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200166                           370mm     ENDC
00200166                           371mm     
00200166                 FALSE     372mm     IFNE DEBUG
00200166                           373mm     ENDC
00200166                           374mm 
00200166                           375mm     ENDM
00200166                           376m     ENDM
00200166                           377  
00200166  7E00                     378      MOVE.L #0,D7                                    ; address accumulator
00200168                           379  
00200168  13FC 0002 00E00001       380      MOVE.B #2,DISPLAY
00200170                           381  MAIN_LOOP
00200170                           382m     PRINT_CHAR #'>',D3                          ; prompt
00200170                           383m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200170                 TRUE      384m     IFEQ DEBUG
00200170  1639 00C00003            385m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200176  0803 0002                386m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020017A  67F4                     387m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0020017C  13FC 003E 00C00007       388m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200184                           389m     ENDC
00200184                           390m     
00200184                 FALSE     391m     IFNE DEBUG
00200184                           392m     ENDC
00200184                           393m 
00200184                           394m     ENDM
00200184                           395m     PRINT_CHAR #32,D3                           ; space
00200184                           396m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200184                 TRUE      397m     IFEQ DEBUG
00200184  1639 00C00003            398m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018A  0803 0002                399m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020018E  67F4                     400m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200190  13FC 0020 00C00007       401m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200198                           402m     ENDC
00200198                           403m     
00200198                 FALSE     404m     IFNE DEBUG
00200198                           405m     ENDC
00200198                           406m 
00200198                           407m     ENDM
00200198                           408      
00200198                           409  GET_INPUT
00200198                           410m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00200198                           411m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200198                 TRUE      412m     IFEQ DEBUG
00200198  1639 00C00003            413m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0020019E  0803 0000                414m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001A2  67F4                     415m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
002001A4                           416m     ENDC
002001A4                           417m     
002001A4                           418mm     READ_CHAR D2
002001A4                 TRUE      419mm     IFEQ DEBUG
002001A4  1439 00C00007            420mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
002001AA                           421mm     ENDC
002001AA                 FALSE     422mm     IFNE DEBUG
002001AA                           423mm     ENDC
002001AA                           424mm      
002001AA  B43C 001B                425mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001AE  6700 FE58                426mm     BEQ START
002001B2                           427mm     ENDM
002001B2                           428m 
002001B2                 TRUE      429m     IFEQ DEBUG
002001B2                           430mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
002001B2                           431mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B2                 TRUE      432mm     IFEQ DEBUG
002001B2  1639 00C00003            433mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B8  0803 0002                434mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001BC  67F4                     435mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
002001BE  13C2 00C00007            436mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001C4                           437mm     ENDC
002001C4                           438mm     
002001C4                 FALSE     439mm     IFNE DEBUG
002001C4                           440mm     ENDC
002001C4                           441mm 
002001C4                           442mm     ENDM
002001C4                           443m     ENDC
002001C4                           444m     ENDM
002001C4                           445      
002001C4                           446      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
002001C4  B43C 0030                447s     CMP.B   #'0',D2
002001C8  6D00 000E                448s     BLT _00000000
002001CC  B43C 0039                449s     CMP.B   #'9',D2
002001D0  6E00 0006                450s     BGT _00000000
002001D4  6000 0C32                451          BRA HEX_DIGIT
002001D8                           452      ENDI
002001D8                           453s _00000000
002001D8                           454      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
002001D8  B43C 0041                455s     CMP.B   #'A',D2
002001DC  6D00 000E                456s     BLT _00000001
002001E0  B43C 0046                457s     CMP.B   #'F',D2
002001E4  6E00 0006                458s     BGT _00000001
002001E8  6000 0C1E                459          BRA HEX_DIGIT
002001EC                           460      ENDI
002001EC                           461s _00000001
002001EC                           462          
002001EC  B43C 0077                463      CMP.B #'w',D2
002001F0  6700 013E                464      BEQ W
002001F4                           465      
002001F4  B43C 006C                466      CMP.B #'l',D2
002001F8  6700 0AA2                467      BEQ L 
002001FC                           468  
002001FC                           469m     PRINT_CRLF D3
002001FC                           470mm     PRINT_CHAR #CR,D3                           ; CR
002001FC                           471mm WAIT_FOR_READY_16                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001FC                 TRUE      472mm     IFEQ DEBUG
002001FC  1639 00C00003            473mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200202  0803 0002                474mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200206  67F4                     475mm         BEQ WAIT_FOR_READY_16                   ; NO SPACE, CHECK AGAIN
00200208  13FC 000D 00C00007       476mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200210                           477mm     ENDC
00200210                           478mm     
00200210                 FALSE     479mm     IFNE DEBUG
00200210                           480mm     ENDC
00200210                           481mm 
00200210                           482mm     ENDM
00200210                           483mm     PRINT_CHAR #LF,D3                           ; LF
00200210                           484mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200210                 TRUE      485mm     IFEQ DEBUG
00200210  1639 00C00003            486mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200216  0803 0002                487mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020021A  67F4                     488mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0020021C  13FC 000A 00C00007       489mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200224                           490mm     ENDC
00200224                           491mm     
00200224                 FALSE     492mm     IFNE DEBUG
00200224                           493mm     ENDC
00200224                           494mm 
00200224                           495mm     ENDM
00200224                           496m     ENDM
00200224                           497   
00200224  B43C 003F                498      CMP.B #'?',D2
00200228  6700 0050                499      BEQ H
0020022C                           500  
0020022C  B43C 0076                501      CMP.B #'v',D2
00200230  6700 0052                502      BEQ V
00200234                           503      
00200234  B43C 0072                504      CMP.B #'r',D2
00200238  6700 0070                505      BEQ R
0020023C                           506  
0020023C  B43C 0073                507      CMP.B #'s',D2
00200240  6700 01B4                508      BEQ S
00200244                           509  
00200244  B43C 0067                510      CMP.B #'g',D2
00200248  6700 0944                511      BEQ G   
0020024C                           512  
0020024C  B43C 007A                513      CMP.B #'z',D2
00200250  6700 0944                514      BEQ Z   
00200254                           515  
00200254  41F9 00200EF5            516      LEA HUH,A0
0020025A                           517m     PRINT_STR A0,D3
0020025A                           518m LOOP_18
0020025A  0C10 0000                519m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0020025E  6700 0016                520m     BEQ EXIT_18
00200262                           521mm     PRINT_CHAR (A0)+,D3
00200262                           522mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200262                 TRUE      523mm     IFEQ DEBUG
00200262  1639 00C00003            524mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200268  0803 0002                525mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020026C  67F4                     526mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0020026E  13D8 00C00007            527mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200274                           528mm     ENDC
00200274                           529mm     
00200274                 FALSE     530mm     IFNE DEBUG
00200274                           531mm     ENDC
00200274                           532mm 
00200274                           533mm     ENDM
00200274  60E4                     534m     BRA LOOP_18
00200276                           535m EXIT_18
00200276                           536m     ENDM
00200276                           537                         
00200276  6000 FEF8                538      BRA MAIN_LOOP
0020027A                           539      
0020027A                           540  ; commands
0020027A                           541  H   
0020027A  41F9 00200E45            542      LEA HELP,A0
00200280  6000 0008                543      BRA PRINTSTR
00200284                           544  
00200284                           545  V   
00200284  41F9 00200E28            546      LEA VERSION,A0
0020028A                           547  PRINTSTR
0020028A                           548m     PRINT_STR A0,D3       
0020028A                           549m LOOP_20
0020028A  0C10 0000                550m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0020028E  6700 0016                551m     BEQ EXIT_20
00200292                           552mm     PRINT_CHAR (A0)+,D3
00200292                           553mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200292                 TRUE      554mm     IFEQ DEBUG
00200292  1639 00C00003            555mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200298  0803 0002                556mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020029C  67F4                     557mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0020029E  13D8 00C00007            558mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002A4                           559mm     ENDC
002002A4                           560mm     
002002A4                 FALSE     561mm     IFNE DEBUG
002002A4                           562mm     ENDC
002002A4                           563mm 
002002A4                           564mm     ENDM
002002A4  60E4                     565m     BRA LOOP_20
002002A6                           566m EXIT_20
002002A6                           567m     ENDM
002002A6  6000 FEC8                568      BRA MAIN_LOOP
002002AA                           569      
002002AA                           570  R   
002002AA  2047                     571      MOVE.L D7,A0                                    ; address accumulator -> address register
002002AC  2A10                     572      MOVE.L (A0),D5                                  ; read the memory and print it
002002AE                           573m     PRINT_REG D5,D3,D7,D6,A0
002002AE                           574mm     PRINT_CHAR #'0',D3                              ;0X HEADER
002002AE                           575mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002AE                 TRUE      576mm     IFEQ DEBUG
002002AE  1639 00C00003            577mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002B4  0803 0002                578mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002B8  67F4                     579mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
002002BA  13FC 0030 00C00007       580mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002C2                           581mm     ENDC
002002C2                           582mm     
002002C2                 FALSE     583mm     IFNE DEBUG
002002C2                           584mm     ENDC
002002C2                           585mm 
002002C2                           586mm     ENDM
002002C2                           587mm     PRINT_CHAR #'x',D3
002002C2                           588mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002C2                 TRUE      589mm     IFEQ DEBUG
002002C2  1639 00C00003            590mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002C8  0803 0002                591mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002CC  67F4                     592mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
002002CE  13FC 0078 00C00007       593mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002D6                           594mm     ENDC
002002D6                           595mm     
002002D6                 FALSE     596mm     IFNE DEBUG
002002D6                           597mm     ENDC
002002D6                           598mm 
002002D6                           599mm     ENDM
002002D6  7C07                     600m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002002D8                           601m LOOP_22
002002D8                           602mm     BIN2HEX D5,D7,A0
002002D8  41F9 00200F59            603mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002002DE  E99D                     604mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002002E0  1E05                     605mm     MOVE.B D5,D7
002002E2  0287 0000000F            606mm     ANDI.L #$F,D7
002002E8  1E30 7000                607mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
002002EC                           608mm     ENDM
002002EC                           609mm     PRINT_CHAR D7,D3
002002EC                           610mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002EC                 TRUE      611mm     IFEQ DEBUG
002002EC  1639 00C00003            612mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002F2  0803 0002                613mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002F6  67F4                     614mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
002002F8  13C7 00C00007            615mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002002FE                           616mm     ENDC
002002FE                           617mm     
002002FE                 FALSE     618mm     IFNE DEBUG
002002FE                           619mm     ENDC
002002FE                           620mm 
002002FE                           621mm     ENDM
002002FE  57CE FFD8                622m     DBEQ D6,LOOP_22
00200302                           623m     ENDM
00200302                           624m     PRINT_CRLF D3
00200302                           625mm     PRINT_CHAR #CR,D3                           ; CR
00200302                           626mm WAIT_FOR_READY_28                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200302                 TRUE      627mm     IFEQ DEBUG
00200302  1639 00C00003            628mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200308  0803 0002                629mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020030C  67F4                     630mm         BEQ WAIT_FOR_READY_28                   ; NO SPACE, CHECK AGAIN
0020030E  13FC 000D 00C00007       631mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200316                           632mm     ENDC
00200316                           633mm     
00200316                 FALSE     634mm     IFNE DEBUG
00200316                           635mm     ENDC
00200316                           636mm 
00200316                           637mm     ENDM
00200316                           638mm     PRINT_CHAR #LF,D3                           ; LF
00200316                           639mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200316                 TRUE      640mm     IFEQ DEBUG
00200316  1639 00C00003            641mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020031C  0803 0002                642mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200320  67F4                     643mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200322  13FC 000A 00C00007       644mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020032A                           645mm     ENDC
0020032A                           646mm     
0020032A                 FALSE     647mm     IFNE DEBUG
0020032A                           648mm     ENDC
0020032A                           649mm 
0020032A                           650mm     ENDM
0020032A                           651m     ENDM
0020032A  7E00                     652      MOVE.L #0,D7                                    ; clear the now used address accumulator
0020032C  6000 FE42                653      BRA MAIN_LOOP
00200330                           654  
00200330                           655  W
00200330  7A00                     656      MOVE.L #0,D5                                    ; D5 will be the value to write            
00200332                           657  
00200332                           658m     WAIT_CHAR D2,D3                                 ; read most significant character -> D2
00200332                           659m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200332                 TRUE      660m     IFEQ DEBUG
00200332  1639 00C00003            661m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200338  0803 0000                662m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020033C  67F4                     663m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
0020033E                           664m     ENDC
0020033E                           665m     
0020033E                           666mm     READ_CHAR D2
0020033E                 TRUE      667mm     IFEQ DEBUG
0020033E  1439 00C00007            668mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200344                           669mm     ENDC
00200344                 FALSE     670mm     IFNE DEBUG
00200344                           671mm     ENDC
00200344                           672mm      
00200344  B43C 001B                673mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200348  6700 FCBE                674mm     BEQ START
0020034C                           675mm     ENDM
0020034C                           676m 
0020034C                 TRUE      677m     IFEQ DEBUG
0020034C                           678mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0020034C                           679mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      680mm     IFEQ DEBUG
0020034C  1639 00C00003            681mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                682mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     683mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00200358  13C2 00C00007            684mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020035E                           685mm     ENDC
0020035E                           686mm     
0020035E                 FALSE     687mm     IFNE DEBUG
0020035E                           688mm     ENDC
0020035E                           689mm 
0020035E                           690mm     ENDM
0020035E                           691m     ENDC
0020035E                           692m     ENDM
0020035E                           693m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0020035E  41F9 00200F69            694m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200364  0402 0030                695m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200368  C4BC 000000FF            696m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0020036E  1430 2000                697m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200372                           698m     ENDM
00200372  1A02                     699      MOVE.B D2,D5                                    ; put at bottom of D5
00200374                           700  
00200374  3C3C 0006                701      MOVE #6,D6                                      ; 7 bytes left to read
00200378                           702      
00200378                           703  READ_DATA_TO_POKE
00200378  E98D                     704      LSL.L #4,D5                                     ; make what we have so far more significant
0020037A                           705m     WAIT_CHAR D2,D3                                 ; next character -> D2
0020037A                           706m WAIT_FOR_READY_34                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020037A                 TRUE      707m     IFEQ DEBUG
0020037A  1639 00C00003            708m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200380  0803 0000                709m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200384  67F4                     710m         BEQ WAIT_FOR_READY_34                   ; NOTHING, CHECK AGAIN
00200386                           711m     ENDC
00200386                           712m     
00200386                           713mm     READ_CHAR D2
00200386                 TRUE      714mm     IFEQ DEBUG
00200386  1439 00C00007            715mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0020038C                           716mm     ENDC
0020038C                 FALSE     717mm     IFNE DEBUG
0020038C                           718mm     ENDC
0020038C                           719mm      
0020038C  B43C 001B                720mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200390  6700 FC76                721mm     BEQ START
00200394                           722mm     ENDM
00200394                           723m 
00200394                 TRUE      724m     IFEQ DEBUG
00200394                           725mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200394                           726mm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200394                 TRUE      727mm     IFEQ DEBUG
00200394  1639 00C00003            728mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020039A  0803 0002                729mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020039E  67F4                     730mm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
002003A0  13C2 00C00007            731mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003A6                           732mm     ENDC
002003A6                           733mm     
002003A6                 FALSE     734mm     IFNE DEBUG
002003A6                           735mm     ENDC
002003A6                           736mm 
002003A6                           737mm     ENDM
002003A6                           738m     ENDC
002003A6                           739m     ENDM
002003A6                           740m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
002003A6  41F9 00200F69            741m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
002003AC  0402 0030                742m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002003B0  C4BC 000000FF            743m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
002003B6  1430 2000                744m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
002003BA                           745m     ENDM
002003BA  8A02                     746      OR.B D2,D5
002003BC  023C 00FB                747      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
002003C0  57CE FFB6                748      DBEQ D6,READ_DATA_TO_POKE
002003C4                           749      
002003C4  2047                     750      MOVE.L D7,A0                                    ; address accumulator -> address register
002003C6  7E00                     751      MOVE.L #0,D7                                    ; clear the now used address accumulator
002003C8                           752      
002003C8  2085                     753      MOVE.L D5,(A0)                                  ; write the data
002003CA                           754  
002003CA                           755m     PRINT_CRLF D3
002003CA                           756mm     PRINT_CHAR #CR,D3                           ; CR
002003CA                           757mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003CA                 TRUE      758mm     IFEQ DEBUG
002003CA  1639 00C00003            759mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D0  0803 0002                760mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003D4  67F4                     761mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
002003D6  13FC 000D 00C00007       762mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003DE                           763mm     ENDC
002003DE                           764mm     
002003DE                 FALSE     765mm     IFNE DEBUG
002003DE                           766mm     ENDC
002003DE                           767mm 
002003DE                           768mm     ENDM
002003DE                           769mm     PRINT_CHAR #LF,D3                           ; LF
002003DE                           770mm WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003DE                 TRUE      771mm     IFEQ DEBUG
002003DE  1639 00C00003            772mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003E4  0803 0002                773mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003E8  67F4                     774mm         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
002003EA  13FC 000A 00C00007       775mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003F2                           776mm     ENDC
002003F2                           777mm     
002003F2                 FALSE     778mm     IFNE DEBUG
002003F2                           779mm     ENDC
002003F2                           780mm 
002003F2                           781mm     ENDM
002003F2                           782m     ENDM
002003F2  6000 FD7C                783      BRA MAIN_LOOP
002003F6                           784  
002003F6                           785  ; register map for S
002003F6                           786  ; A0 - start address
002003F6                           787  ; A1 - offset
002003F6                           788  ; A2 - next address to write
002003F6                           789  ; A3 - next location (jmp)
002003F6                           790  ; A4 - Working Address Register
002003F6                           791  ; D0 - record count
002003F6                           792  ; D1 - 'S', record type, data byte
002003F6                           793  ; D2 - checksum
002003F6                           794  ; D3 - data byte count
002003F6                           795  ; D4 - read address, moved into A2
002003F6                           796  ; D5 - temp
002003F6                           797  ; D6 - temp
002003F6                           798  ; D7 - temp
002003F6                           799  S
002003F6  2078 0000                800      MOVE.L 0,A0                                     ; start address -> A0
002003FA  2247                     801      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
002003FC                           802      
002003FC  7000                     803      MOVE.L #0,D0                                    ; count of records read -> D0
002003FE                           804          
002003FE                           805  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
002003FE                           806m     DOWNLOAD D1                 
002003FE                           807m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003FE                           808m 
002003FE  1239 00C00003            809m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00200404  0801 0000                810m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200408  6700 0010                811m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
0020040C                           812m  
0020040C                           813mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0020040C                 TRUE      814mm     IFEQ DEBUG
0020040C  1239 00C00007            815mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00200412                           816mm     ENDC
00200412                 FALSE     817mm     IFNE DEBUG
00200412                           818mm     ENDC
00200412                           819mm      
00200412  B23C 001B                820mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00200416  6700 FBF0                821mm     BEQ START
0020041A                           822mm     ENDM
0020041A                           823m CONTINUE_41
0020041A  1239 00C00013            824m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00200420  0801 0000                825m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00200424  67D8                     826m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
00200426                           827m     
00200426  1239 00C00017            828m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0020042C  13C1 00E00001            829m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00200432                           830m     
00200432                           831m     ENDM
00200432  B23C 0053                832      CMP.B #'S',D1                                   ; found S?    
00200436  66C6                     833      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00200438                           834      
00200438                           835m     PRINT_CHAR #'S',D5                          ; print the S
00200438                           836m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200438                 TRUE      837m     IFEQ DEBUG
00200438  1A39 00C00003            838m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020043E  0805 0002                839m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200442  67F4                     840m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00200444  13FC 0053 00C00007       841m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020044C                           842m     ENDC
0020044C                           843m     
0020044C                 FALSE     844m     IFNE DEBUG
0020044C                           845m     ENDC
0020044C                           846m 
0020044C                           847m     ENDM
0020044C  5280                     848      ADD.L #1,D0                                     ; read another S record, increment count
0020044E                           849      
0020044E                           850m     DOWNLOAD D1                                 ; read the record identifier and echo it back
0020044E                           851m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020044E                           852m 
0020044E  1239 00C00003            853m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00200454  0801 0000                854m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200458  6700 0010                855m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0020045C                           856m  
0020045C                           857mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0020045C                 TRUE      858mm     IFEQ DEBUG
0020045C  1239 00C00007            859mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00200462                           860mm     ENDC
00200462                 FALSE     861mm     IFNE DEBUG
00200462                           862mm     ENDC
00200462                           863mm      
00200462  B23C 001B                864mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00200466  6700 FBA0                865mm     BEQ START
0020046A                           866mm     ENDM
0020046A                           867m CONTINUE_44
0020046A  1239 00C00013            868m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00200470  0801 0000                869m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00200474  67D8                     870m     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00200476                           871m     
00200476  1239 00C00017            872m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0020047C  13C1 00E00001            873m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00200482                           874m     
00200482                           875m     ENDM
00200482                           876m     PRINT_CHAR D1,D5
00200482                           877m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200482                 TRUE      878m     IFEQ DEBUG
00200482  1A39 00C00003            879m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200488  0805 0002                880m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020048C  67F4                     881m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
0020048E  13C1 00C00007            882m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200494                           883m     ENDC
00200494                           884m     
00200494                 FALSE     885m     IFNE DEBUG
00200494                           886m     ENDC
00200494                           887m 
00200494                           888m     ENDM
00200494                           889  
00200494  7400                     890      MOVE.L #0,D2                                    ; clear the checksum
00200496                           891  
00200496  7600                     892      MOVE.L #0,D3                                    ; read the 2 digit byte count -> D3
00200498                           893m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00200498  1E3C 0002                894m     MOVE.B #2,D7
0020049C                           895m     WHILE.B D7 <GT> 0 DO
0020049C                           896ms _10000000
0020049C  BE38 0000                897ms     CMP.B   0,D7
002004A0  6F00 0064                898ms     BLE _10000001
002004A4  E98B                     899m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
002004A6                           900mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002004A6                           901mm WAIT_FOR_READY_48                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A6                           902mm 
002004A6  1A39 00C00003            903mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002004AC  0805 0000                904mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002004B0  6700 0010                905mm     BEQ CONTINUE_48                             ; NOTHING, CONTINUE
002004B4                           906mm  
002004B4                           907mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002004B4                 TRUE      908mmm     IFEQ DEBUG
002004B4  1A39 00C00007            909mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002004BA                           910mmm     ENDC
002004BA                 FALSE     911mmm     IFNE DEBUG
002004BA                           912mmm     ENDC
002004BA                           913mmm      
002004BA  BA3C 001B                914mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002004BE  6700 FB48                915mmm     BEQ START
002004C2                           916mmm     ENDM
002004C2                           917mm CONTINUE_48
002004C2  1A39 00C00013            918mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002004C8  0805 0000                919mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002004CC  67D8                     920mm     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
002004CE                           921mm     
002004CE  1A39 00C00017            922mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002004D4  13C5 00E00001            923mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002004DA                           924mm     
002004DA                           925mm     ENDM
002004DA                           926mm         PRINT_CHAR D5,D6
002004DA                           927mm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      928mm     IFEQ DEBUG
002004DA  1C39 00C00003            929mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002004E0  0806 0002                930mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     931mm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
002004E6  13C5 00C00007            932mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002004EC                           933mm     ENDC
002004EC                           934mm     
002004EC                 FALSE     935mm     IFNE DEBUG
002004EC                           936mm     ENDC
002004EC                           937mm 
002004EC                           938mm     ENDM
002004EC                           939mm         HEX2BIN D5,D5,A4
002004EC  49F9 00200F69            940mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002004F2  0405 0030                941mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002004F6  CABC 000000FF            942mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002004FC  1A34 5000                943mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200500                           944mm     ENDM
00200500  8605                     945m         OR.B D5,D3
00200502  5307                     946m         SUB.B #1,D7
00200504                           947m     ENDW
00200504  6096                     948ms     BRA _10000000
00200506                           949ms _10000001
00200506                           950m     
00200506  7A00                     951m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200508  1A03                     952m     MOVE.B D3,D5
0020050A  D483                     953m     ADD.L D3,D2
0020050C                           954m 
0020050C                           955m     ENDM
0020050C                           956  
0020050C                           957      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0020050C  B23C 0030                958s     CMP.B   #'0',D1
00200510  6600 0032                959s     BNE.L   _00000002
00200514                           960m         PRINT_CRLF D5
00200514                           961mm     PRINT_CHAR #CR,D5                           ; CR
00200514                           962mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                 TRUE      963mm     IFEQ DEBUG
00200514  1A39 00C00003            964mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020051A  0805 0002                965mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020051E  67F4                     966mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00200520  13FC 000D 00C00007       967mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200528                           968mm     ENDC
00200528                           969mm     
00200528                 FALSE     970mm     IFNE DEBUG
00200528                           971mm     ENDC
00200528                           972mm 
00200528                           973mm     ENDM
00200528                           974mm     PRINT_CHAR #LF,D5                           ; LF
00200528                           975mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200528                 TRUE      976mm     IFEQ DEBUG
00200528  1A39 00C00003            977mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020052E  0805 0002                978mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200532  67F4                     979mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
00200534  13FC 000A 00C00007       980mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020053C                           981mm     ENDC
0020053C                           982mm     
0020053C                 FALSE     983mm     IFNE DEBUG
0020053C                           984mm     ENDC
0020053C                           985mm 
0020053C                           986mm     ENDM
0020053C                           987m     ENDM
0020053C  6000 FEC0                988          BRA WAIT_FOR_SRECORD
00200540                           989      ELSE
00200540  6000 040A                990s     BRA _00000003
00200544                           991s _00000002
00200544                           992          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00200544  B23C 0031                993s     CMP.B   #'1',D1
00200548  6708                     994s     BEQ.S   _00000004
0020054A  B23C 0032                995s     CMP.B   #'2',D1
0020054E  6600 0202                996s     BNE.L   _00000005
00200552                           997s _00000004
00200552  5783                     998              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00200554                           999      
00200554  7800                    1000              MOVE.L #0,D4                            ; read two bytes of address
00200556                          1001m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
00200556  1E3C 0002               1002m     MOVE.B #2,D7
0020055A                          1003m     WHILE.B D7 <GT> 0 DO
0020055A                          1004ms _10000002
0020055A  BE38 0000               1005ms     CMP.B   0,D7
0020055E  6F00 0064               1006ms     BLE _10000003
00200562  E98C                    1007m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200564                          1008mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200564                          1009mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200564                          1010mm 
00200564  1A39 00C00003           1011mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020056A  0805 0000               1012mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020056E  6700 0010               1013mm     BEQ CONTINUE_56                             ; NOTHING, CONTINUE
00200572                          1014mm  
00200572                          1015mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200572                 TRUE     1016mmm     IFEQ DEBUG
00200572  1A39 00C00007           1017mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200578                          1018mmm     ENDC
00200578                 FALSE    1019mmm     IFNE DEBUG
00200578                          1020mmm     ENDC
00200578                          1021mmm      
00200578  BA3C 001B               1022mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020057C  6700 FA8A               1023mmm     BEQ START
00200580                          1024mmm     ENDM
00200580                          1025mm CONTINUE_56
00200580  1A39 00C00013           1026mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200586  0805 0000               1027mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020058A  67D8                    1028mm     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
0020058C                          1029mm     
0020058C  1A39 00C00017           1030mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200592  13C5 00E00001           1031mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200598                          1032mm     
00200598                          1033mm     ENDM
00200598                          1034mm         PRINT_CHAR D5,D6
00200598                          1035mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200598                 TRUE     1036mm     IFEQ DEBUG
00200598  1C39 00C00003           1037mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020059E  0806 0002               1038mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002005A2  67F4                    1039mm         BEQ WAIT_FOR_READY_58                   ; NO SPACE, CHECK AGAIN
002005A4  13C5 00C00007           1040mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002005AA                          1041mm     ENDC
002005AA                          1042mm     
002005AA                 FALSE    1043mm     IFNE DEBUG
002005AA                          1044mm     ENDC
002005AA                          1045mm 
002005AA                          1046mm     ENDM
002005AA                          1047mm         HEX2BIN D5,D5,A4
002005AA  49F9 00200F69           1048mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002005B0  0405 0030               1049mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005B4  CABC 000000FF           1050mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002005BA  1A34 5000               1051mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002005BE                          1052mm     ENDM
002005BE  8805                    1053m         OR.B D5,D4
002005C0  5307                    1054m         SUB.B #1,D7
002005C2                          1055m     ENDW
002005C2  6096                    1056ms     BRA _10000002
002005C4                          1057ms _10000003
002005C4                          1058m     
002005C4  7A00                    1059m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002005C6  1A04                    1060m     MOVE.B D4,D5
002005C8  D484                    1061m     ADD.L D4,D2
002005CA                          1062m 
002005CA                          1063m     ENDM
002005CA                          1064m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
002005CA  1E3C 0002               1065m     MOVE.B #2,D7
002005CE                          1066m     WHILE.B D7 <GT> 0 DO
002005CE                          1067ms _10000004
002005CE  BE38 0000               1068ms     CMP.B   0,D7
002005D2  6F00 0064               1069ms     BLE _10000005
002005D6  E98C                    1070m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002005D8                          1071mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002005D8                          1072mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005D8                          1073mm 
002005D8  1A39 00C00003           1074mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002005DE  0805 0000               1075mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002005E2  6700 0010               1076mm     BEQ CONTINUE_61                             ; NOTHING, CONTINUE
002005E6                          1077mm  
002005E6                          1078mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002005E6                 TRUE     1079mmm     IFEQ DEBUG
002005E6  1A39 00C00007           1080mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002005EC                          1081mmm     ENDC
002005EC                 FALSE    1082mmm     IFNE DEBUG
002005EC                          1083mmm     ENDC
002005EC                          1084mmm      
002005EC  BA3C 001B               1085mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002005F0  6700 FA16               1086mmm     BEQ START
002005F4                          1087mmm     ENDM
002005F4                          1088mm CONTINUE_61
002005F4  1A39 00C00013           1089mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002005FA  0805 0000               1090mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002005FE  67D8                    1091mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00200600                          1092mm     
00200600  1A39 00C00017           1093mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200606  13C5 00E00001           1094mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020060C                          1095mm     
0020060C                          1096mm     ENDM
0020060C                          1097mm         PRINT_CHAR D5,D6
0020060C                          1098mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020060C                 TRUE     1099mm     IFEQ DEBUG
0020060C  1C39 00C00003           1100mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200612  0806 0002               1101mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200616  67F4                    1102mm         BEQ WAIT_FOR_READY_63                   ; NO SPACE, CHECK AGAIN
00200618  13C5 00C00007           1103mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020061E                          1104mm     ENDC
0020061E                          1105mm     
0020061E                 FALSE    1106mm     IFNE DEBUG
0020061E                          1107mm     ENDC
0020061E                          1108mm 
0020061E                          1109mm     ENDM
0020061E                          1110mm         HEX2BIN D5,D5,A4
0020061E  49F9 00200F69           1111mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200624  0405 0030               1112mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200628  CABC 000000FF           1113mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0020062E  1A34 5000               1114mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200632                          1115mm     ENDM
00200632  8805                    1116m         OR.B D5,D4
00200634  5307                    1117m         SUB.B #1,D7
00200636                          1118m     ENDW
00200636  6096                    1119ms     BRA _10000004
00200638                          1120ms _10000005
00200638                          1121m     
00200638  7A00                    1122m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020063A  1A04                    1123m     MOVE.B D4,D5
0020063C  D484                    1124m     ADD.L D4,D2
0020063E                          1125m 
0020063E                          1126m     ENDM
0020063E                          1127              
0020063E                          1128              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
0020063E  B23C 0032               1129s     CMP.B   #'2',D1
00200642  6600 0078               1130s     BNE.L   _00000006
00200646  5383                    1131                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00200648                          1132m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00200648  1E3C 0002               1133m     MOVE.B #2,D7
0020064C                          1134m     WHILE.B D7 <GT> 0 DO
0020064C                          1135ms _10000006
0020064C  BE38 0000               1136ms     CMP.B   0,D7
00200650  6F00 0064               1137ms     BLE _10000007
00200654  E98C                    1138m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200656                          1139mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200656                          1140mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200656                          1141mm 
00200656  1A39 00C00003           1142mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020065C  0805 0000               1143mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200660  6700 0010               1144mm     BEQ CONTINUE_66                             ; NOTHING, CONTINUE
00200664                          1145mm  
00200664                          1146mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200664                 TRUE     1147mmm     IFEQ DEBUG
00200664  1A39 00C00007           1148mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020066A                          1149mmm     ENDC
0020066A                 FALSE    1150mmm     IFNE DEBUG
0020066A                          1151mmm     ENDC
0020066A                          1152mmm      
0020066A  BA3C 001B               1153mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020066E  6700 F998               1154mmm     BEQ START
00200672                          1155mmm     ENDM
00200672                          1156mm CONTINUE_66
00200672  1A39 00C00013           1157mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200678  0805 0000               1158mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020067C  67D8                    1159mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
0020067E                          1160mm     
0020067E  1A39 00C00017           1161mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200684  13C5 00E00001           1162mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020068A                          1163mm     
0020068A                          1164mm     ENDM
0020068A                          1165mm         PRINT_CHAR D5,D6
0020068A                          1166mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020068A                 TRUE     1167mm     IFEQ DEBUG
0020068A  1C39 00C00003           1168mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200690  0806 0002               1169mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200694  67F4                    1170mm         BEQ WAIT_FOR_READY_68                   ; NO SPACE, CHECK AGAIN
00200696  13C5 00C00007           1171mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020069C                          1172mm     ENDC
0020069C                          1173mm     
0020069C                 FALSE    1174mm     IFNE DEBUG
0020069C                          1175mm     ENDC
0020069C                          1176mm 
0020069C                          1177mm     ENDM
0020069C                          1178mm         HEX2BIN D5,D5,A4
0020069C  49F9 00200F69           1179mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002006A2  0405 0030               1180mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006A6  CABC 000000FF           1181mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002006AC  1A34 5000               1182mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002006B0                          1183mm     ENDM
002006B0  8805                    1184m         OR.B D5,D4
002006B2  5307                    1185m         SUB.B #1,D7
002006B4                          1186m     ENDW
002006B4  6096                    1187ms     BRA _10000006
002006B6                          1188ms _10000007
002006B6                          1189m     
002006B6  7A00                    1190m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006B8  1A04                    1191m     MOVE.B D4,D5
002006BA  D484                    1192m     ADD.L D4,D2
002006BC                          1193m 
002006BC                          1194m     ENDM
002006BC                          1195              ENDI
002006BC                          1196s _00000006
002006BC                          1197              
002006BC  2444                    1198                  MOVE.L D4,A2                            ; put the address in an address register
002006BE  D5C9                    1199              ADD.L A1,A2                             ; add in the offset
002006C0                          1200  
002006C0                          1201              WHILE.L D3 <GT> #0 DO                   ; read the data bytes                
002006C0                          1202s _10000008
002006C0  B6BC 00000000           1203s     CMP.L   #0,D3
002006C6  6F00 0080               1204s     BLE _10000009
002006CA  7200                    1205                  MOVE.L #0,D1                        ; D1 holds the byte
002006CC                          1206m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
002006CC  1E3C 0002               1207m     MOVE.B #2,D7
002006D0                          1208m     WHILE.B D7 <GT> 0 DO
002006D0                          1209ms _1000000A
002006D0  BE38 0000               1210ms     CMP.B   0,D7
002006D4  6F00 0064               1211ms     BLE _1000000B
002006D8  E989                    1212m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
002006DA                          1213mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002006DA                          1214mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006DA                          1215mm 
002006DA  1A39 00C00003           1216mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002006E0  0805 0000               1217mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002006E4  6700 0010               1218mm     BEQ CONTINUE_71                             ; NOTHING, CONTINUE
002006E8                          1219mm  
002006E8                          1220mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002006E8                 TRUE     1221mmm     IFEQ DEBUG
002006E8  1A39 00C00007           1222mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002006EE                          1223mmm     ENDC
002006EE                 FALSE    1224mmm     IFNE DEBUG
002006EE                          1225mmm     ENDC
002006EE                          1226mmm      
002006EE  BA3C 001B               1227mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002006F2  6700 F914               1228mmm     BEQ START
002006F6                          1229mmm     ENDM
002006F6                          1230mm CONTINUE_71
002006F6  1A39 00C00013           1231mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002006FC  0805 0000               1232mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200700  67D8                    1233mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
00200702                          1234mm     
00200702  1A39 00C00017           1235mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200708  13C5 00E00001           1236mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020070E                          1237mm     
0020070E                          1238mm     ENDM
0020070E                          1239mm         PRINT_CHAR D5,D6
0020070E                          1240mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020070E                 TRUE     1241mm     IFEQ DEBUG
0020070E  1C39 00C00003           1242mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200714  0806 0002               1243mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200718  67F4                    1244mm         BEQ WAIT_FOR_READY_73                   ; NO SPACE, CHECK AGAIN
0020071A  13C5 00C00007           1245mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200720                          1246mm     ENDC
00200720                          1247mm     
00200720                 FALSE    1248mm     IFNE DEBUG
00200720                          1249mm     ENDC
00200720                          1250mm 
00200720                          1251mm     ENDM
00200720                          1252mm         HEX2BIN D5,D5,A4
00200720  49F9 00200F69           1253mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200726  0405 0030               1254mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020072A  CABC 000000FF           1255mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200730  1A34 5000               1256mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200734                          1257mm     ENDM
00200734  8205                    1258m         OR.B D5,D1
00200736  5307                    1259m         SUB.B #1,D7
00200738                          1260m     ENDW
00200738  6096                    1261ms     BRA _1000000A
0020073A                          1262ms _1000000B
0020073A                          1263m     
0020073A  7A00                    1264m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020073C  1A01                    1265m     MOVE.B D1,D5
0020073E  D481                    1266m     ADD.L D1,D2
00200740                          1267m 
00200740                          1268m     ENDM
00200740                          1269                          
00200740  14C1                    1270                  MOVE.B D1,(A2)+                     ; store it!
00200742                          1271  
00200742  5383                    1272                  SUB.L #1,D3                     ; 1 less byte to go
00200744                          1273              ENDW
00200744  6000 FF7A               1274s     BRA _10000008
00200748                          1275s _10000009
00200748                          1276          
00200748  47F9 002003FE           1277              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
0020074E                          1278          ELSE
0020074E  6000 01FC               1279s     BRA _00000007
00200752                          1280s _00000005
00200752                          1281              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00200752  B23C 0038               1282s     CMP.B   #'8',D1
00200756  6600 016C               1283s     BNE.L   _00000008
0020075A  7800                    1284                  MOVE.L #0,D4                    ; read the 24 bit start address
0020075C                          1285m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0020075C  1E3C 0002               1286m     MOVE.B #2,D7
00200760                          1287m     WHILE.B D7 <GT> 0 DO
00200760                          1288ms _1000000C
00200760  BE38 0000               1289ms     CMP.B   0,D7
00200764  6F00 0064               1290ms     BLE _1000000D
00200768  E98C                    1291m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020076A                          1292mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020076A                          1293mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020076A                          1294mm 
0020076A  1A39 00C00003           1295mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200770  0805 0000               1296mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200774  6700 0010               1297mm     BEQ CONTINUE_76                             ; NOTHING, CONTINUE
00200778                          1298mm  
00200778                          1299mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200778                 TRUE     1300mmm     IFEQ DEBUG
00200778  1A39 00C00007           1301mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020077E                          1302mmm     ENDC
0020077E                 FALSE    1303mmm     IFNE DEBUG
0020077E                          1304mmm     ENDC
0020077E                          1305mmm      
0020077E  BA3C 001B               1306mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200782  6700 F884               1307mmm     BEQ START
00200786                          1308mmm     ENDM
00200786                          1309mm CONTINUE_76
00200786  1A39 00C00013           1310mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020078C  0805 0000               1311mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200790  67D8                    1312mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00200792                          1313mm     
00200792  1A39 00C00017           1314mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200798  13C5 00E00001           1315mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020079E                          1316mm     
0020079E                          1317mm     ENDM
0020079E                          1318mm         PRINT_CHAR D5,D6
0020079E                          1319mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020079E                 TRUE     1320mm     IFEQ DEBUG
0020079E  1C39 00C00003           1321mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002007A4  0806 0002               1322mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002007A8  67F4                    1323mm         BEQ WAIT_FOR_READY_78                   ; NO SPACE, CHECK AGAIN
002007AA  13C5 00C00007           1324mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007B0                          1325mm     ENDC
002007B0                          1326mm     
002007B0                 FALSE    1327mm     IFNE DEBUG
002007B0                          1328mm     ENDC
002007B0                          1329mm 
002007B0                          1330mm     ENDM
002007B0                          1331mm         HEX2BIN D5,D5,A4
002007B0  49F9 00200F69           1332mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002007B6  0405 0030               1333mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007BA  CABC 000000FF           1334mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002007C0  1A34 5000               1335mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002007C4                          1336mm     ENDM
002007C4  8805                    1337m         OR.B D5,D4
002007C6  5307                    1338m         SUB.B #1,D7
002007C8                          1339m     ENDW
002007C8  6096                    1340ms     BRA _1000000C
002007CA                          1341ms _1000000D
002007CA                          1342m     
002007CA  7A00                    1343m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007CC  1A04                    1344m     MOVE.B D4,D5
002007CE  D484                    1345m     ADD.L D4,D2
002007D0                          1346m 
002007D0                          1347m     ENDM
002007D0                          1348m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
002007D0  1E3C 0002               1349m     MOVE.B #2,D7
002007D4                          1350m     WHILE.B D7 <GT> 0 DO
002007D4                          1351ms _1000000E
002007D4  BE38 0000               1352ms     CMP.B   0,D7
002007D8  6F00 0064               1353ms     BLE _1000000F
002007DC  E98C                    1354m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
002007DE                          1355mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
002007DE                          1356mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007DE                          1357mm 
002007DE  1A39 00C00003           1358mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002007E4  0805 0000               1359mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002007E8  6700 0010               1360mm     BEQ CONTINUE_81                             ; NOTHING, CONTINUE
002007EC                          1361mm  
002007EC                          1362mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002007EC                 TRUE     1363mmm     IFEQ DEBUG
002007EC  1A39 00C00007           1364mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002007F2                          1365mmm     ENDC
002007F2                 FALSE    1366mmm     IFNE DEBUG
002007F2                          1367mmm     ENDC
002007F2                          1368mmm      
002007F2  BA3C 001B               1369mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002007F6  6700 F810               1370mmm     BEQ START
002007FA                          1371mmm     ENDM
002007FA                          1372mm CONTINUE_81
002007FA  1A39 00C00013           1373mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200800  0805 0000               1374mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200804  67D8                    1375mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00200806                          1376mm     
00200806  1A39 00C00017           1377mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0020080C  13C5 00E00001           1378mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200812                          1379mm     
00200812                          1380mm     ENDM
00200812                          1381mm         PRINT_CHAR D5,D6
00200812                          1382mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200812                 TRUE     1383mm     IFEQ DEBUG
00200812  1C39 00C00003           1384mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200818  0806 0002               1385mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020081C  67F4                    1386mm         BEQ WAIT_FOR_READY_83                   ; NO SPACE, CHECK AGAIN
0020081E  13C5 00C00007           1387mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200824                          1388mm     ENDC
00200824                          1389mm     
00200824                 FALSE    1390mm     IFNE DEBUG
00200824                          1391mm     ENDC
00200824                          1392mm 
00200824                          1393mm     ENDM
00200824                          1394mm         HEX2BIN D5,D5,A4
00200824  49F9 00200F69           1395mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020082A  0405 0030               1396mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020082E  CABC 000000FF           1397mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200834  1A34 5000               1398mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200838                          1399mm     ENDM
00200838  8805                    1400m         OR.B D5,D4
0020083A  5307                    1401m         SUB.B #1,D7
0020083C                          1402m     ENDW
0020083C  6096                    1403ms     BRA _1000000E
0020083E                          1404ms _1000000F
0020083E                          1405m     
0020083E  7A00                    1406m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200840  1A04                    1407m     MOVE.B D4,D5
00200842  D484                    1408m     ADD.L D4,D2
00200844                          1409m 
00200844                          1410m     ENDM
00200844                          1411m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00200844  1E3C 0002               1412m     MOVE.B #2,D7
00200848                          1413m     WHILE.B D7 <GT> 0 DO
00200848                          1414ms _10000010
00200848  BE38 0000               1415ms     CMP.B   0,D7
0020084C  6F00 0064               1416ms     BLE _10000011
00200850  E98C                    1417m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200852                          1418mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200852                          1419mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200852                          1420mm 
00200852  1A39 00C00003           1421mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200858  0805 0000               1422mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020085C  6700 0010               1423mm     BEQ CONTINUE_86                             ; NOTHING, CONTINUE
00200860                          1424mm  
00200860                          1425mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200860                 TRUE     1426mmm     IFEQ DEBUG
00200860  1A39 00C00007           1427mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200866                          1428mmm     ENDC
00200866                 FALSE    1429mmm     IFNE DEBUG
00200866                          1430mmm     ENDC
00200866                          1431mmm      
00200866  BA3C 001B               1432mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020086A  6700 F79C               1433mmm     BEQ START
0020086E                          1434mmm     ENDM
0020086E                          1435mm CONTINUE_86
0020086E  1A39 00C00013           1436mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200874  0805 0000               1437mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200878  67D8                    1438mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
0020087A                          1439mm     
0020087A  1A39 00C00017           1440mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200880  13C5 00E00001           1441mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200886                          1442mm     
00200886                          1443mm     ENDM
00200886                          1444mm         PRINT_CHAR D5,D6
00200886                          1445mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200886                 TRUE     1446mm     IFEQ DEBUG
00200886  1C39 00C00003           1447mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020088C  0806 0002               1448mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200890  67F4                    1449mm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00200892  13C5 00C00007           1450mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200898                          1451mm     ENDC
00200898                          1452mm     
00200898                 FALSE    1453mm     IFNE DEBUG
00200898                          1454mm     ENDC
00200898                          1455mm 
00200898                          1456mm     ENDM
00200898                          1457mm         HEX2BIN D5,D5,A4
00200898  49F9 00200F69           1458mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020089E  0405 0030               1459mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008A2  CABC 000000FF           1460mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002008A8  1A34 5000               1461mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002008AC                          1462mm     ENDM
002008AC  8805                    1463m         OR.B D5,D4
002008AE  5307                    1464m         SUB.B #1,D7
002008B0                          1465m     ENDW
002008B0  6096                    1466ms     BRA _10000010
002008B2                          1467ms _10000011
002008B2                          1468m     
002008B2  7A00                    1469m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002008B4  1A04                    1470m     MOVE.B D4,D5
002008B6  D484                    1471m     ADD.L D4,D2
002008B8                          1472m 
002008B8                          1473m     ENDM
002008B8                          1474                    
002008B8  2044                    1475                  MOVE.L D4,A0                    ; start address -> A0
002008BA                          1476                  
002008BA  47F9 00200A96           1477                  LEA DOWNLOAD_DONE,A3            ; next place to go
002008C0                          1478              ELSE
002008C0  6000 008A               1479s     BRA _00000009
002008C4                          1480s _00000008
002008C4                          1481m                 PRINT_CRLF D5
002008C4                          1482mm     PRINT_CHAR #CR,D5                           ; CR
002008C4                          1483mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008C4                 TRUE     1484mm     IFEQ DEBUG
002008C4  1A39 00C00003           1485mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008CA  0805 0002               1486mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008CE  67F4                    1487mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
002008D0  13FC 000D 00C00007      1488mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008D8                          1489mm     ENDC
002008D8                          1490mm     
002008D8                 FALSE    1491mm     IFNE DEBUG
002008D8                          1492mm     ENDC
002008D8                          1493mm 
002008D8                          1494mm     ENDM
002008D8                          1495mm     PRINT_CHAR #LF,D5                           ; LF
002008D8                          1496mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1497mm     IFEQ DEBUG
002008D8  1A39 00C00003           1498mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008DE  0805 0002               1499mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1500mm         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
002008E4  13FC 000A 00C00007      1501mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008EC                          1502mm     ENDC
002008EC                          1503mm     
002008EC                 FALSE    1504mm     IFNE DEBUG
002008EC                          1505mm     ENDC
002008EC                          1506mm 
002008EC                          1507mm     ENDM
002008EC                          1508m     ENDM
002008EC                          1509              
002008EC  49F9 00200F1E           1510                  LEA UNREC,A4                    ; warn for unrecognised type
002008F2                          1511m                 PRINT_STR A4,D5
002008F2                          1512m LOOP_93
002008F2  0C14 0000               1513m     CMP.B #NULL,(A4)                            ; 0 -> DONE
002008F6  6700 0016               1514m     BEQ EXIT_93
002008FA                          1515mm     PRINT_CHAR (A4)+,D5
002008FA                          1516mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008FA                 TRUE     1517mm     IFEQ DEBUG
002008FA  1A39 00C00003           1518mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200900  0805 0002               1519mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200904  67F4                    1520mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00200906  13DC 00C00007           1521mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020090C                          1522mm     ENDC
0020090C                          1523mm     
0020090C                 FALSE    1524mm     IFNE DEBUG
0020090C                          1525mm     ENDC
0020090C                          1526mm 
0020090C                          1527mm     ENDM
0020090C  60E4                    1528m     BRA LOOP_93
0020090E                          1529m EXIT_93
0020090E                          1530m     ENDM
0020090E                          1531m                 PRINT_CHAR D1,D5
0020090E                          1532m WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020090E                 TRUE     1533m     IFEQ DEBUG
0020090E  1A39 00C00003           1534m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200914  0805 0002               1535m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200918  67F4                    1536m         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0020091A  13C1 00C00007           1537m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200920                          1538m     ENDC
00200920                          1539m     
00200920                 FALSE    1540m     IFNE DEBUG
00200920                          1541m     ENDC
00200920                          1542m 
00200920                          1543m     ENDM
00200920                          1544m                 PRINT_CRLF D5
00200920                          1545mm     PRINT_CHAR #CR,D5                           ; CR
00200920                          1546mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200920                 TRUE     1547mm     IFEQ DEBUG
00200920  1A39 00C00003           1548mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200926  0805 0002               1549mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020092A  67F4                    1550mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0020092C  13FC 000D 00C00007      1551mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200934                          1552mm     ENDC
00200934                          1553mm     
00200934                 FALSE    1554mm     IFNE DEBUG
00200934                          1555mm     ENDC
00200934                          1556mm 
00200934                          1557mm     ENDM
00200934                          1558mm     PRINT_CHAR #LF,D5                           ; LF
00200934                          1559mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200934                 TRUE     1560mm     IFEQ DEBUG
00200934  1A39 00C00003           1561mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020093A  0805 0002               1562mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020093E  67F4                    1563mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00200940  13FC 000A 00C00007      1564mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200948                          1565mm     ENDC
00200948                          1566mm     
00200948                 FALSE    1567mm     IFNE DEBUG
00200948                          1568mm     ENDC
00200948                          1569mm 
00200948                          1570mm     ENDM
00200948                          1571m     ENDM
00200948                          1572              
00200948  6000 FAB4               1573                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0020094C                          1574              ENDI
0020094C                          1575s _00000009
0020094C                          1576          ENDI
0020094C                          1577s _00000007
0020094C                          1578      ENDI
0020094C                          1579s _00000003
0020094C                          1580      
0020094C  7800                    1581      MOVE.L #0,D4                                    ; read the checksum from the data stream add to our checksum: should make it FF
0020094E                          1582m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0020094E  1E3C 0002               1583m     MOVE.B #2,D7
00200952                          1584m     WHILE.B D7 <GT> 0 DO
00200952                          1585ms _10000012
00200952  BE38 0000               1586ms     CMP.B   0,D7
00200956  6F00 0064               1587ms     BLE _10000013
0020095A  E98C                    1588m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020095C                          1589mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020095C                          1590mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020095C                          1591mm 
0020095C  1A39 00C00003           1592mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200962  0805 0000               1593mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200966  6700 0010               1594mm     BEQ CONTINUE_100                                ; NOTHING, CONTINUE
0020096A                          1595mm  
0020096A                          1596mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0020096A                 TRUE     1597mmm     IFEQ DEBUG
0020096A  1A39 00C00007           1598mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200970                          1599mmm     ENDC
00200970                 FALSE    1600mmm     IFNE DEBUG
00200970                          1601mmm     ENDC
00200970                          1602mmm      
00200970  BA3C 001B               1603mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200974  6700 F692               1604mmm     BEQ START
00200978                          1605mmm     ENDM
00200978                          1606mm CONTINUE_100
00200978  1A39 00C00013           1607mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020097E  0805 0000               1608mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200982  67D8                    1609mm     BEQ WAIT_FOR_READY_100                          ; NOTHING, CHECK AGAIN
00200984                          1610mm     
00200984  1A39 00C00017           1611mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0020098A  13C5 00E00001           1612mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200990                          1613mm     
00200990                          1614mm     ENDM
00200990                          1615mm         PRINT_CHAR D5,D6
00200990                          1616mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200990                 TRUE     1617mm     IFEQ DEBUG
00200990  1C39 00C00003           1618mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200996  0806 0002               1619mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020099A  67F4                    1620mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
0020099C  13C5 00C00007           1621mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A2                          1622mm     ENDC
002009A2                          1623mm     
002009A2                 FALSE    1624mm     IFNE DEBUG
002009A2                          1625mm     ENDC
002009A2                          1626mm 
002009A2                          1627mm     ENDM
002009A2                          1628mm         HEX2BIN D5,D5,A4
002009A2  49F9 00200F69           1629mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002009A8  0405 0030               1630mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009AC  CABC 000000FF           1631mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002009B2  1A34 5000               1632mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002009B6                          1633mm     ENDM
002009B6  8805                    1634m         OR.B D5,D4
002009B8  5307                    1635m         SUB.B #1,D7
002009BA                          1636m     ENDW
002009BA  6096                    1637ms     BRA _10000012
002009BC                          1638ms _10000013
002009BC                          1639m     
002009BC  7A00                    1640m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002009BE  1A04                    1641m     MOVE.B D4,D5
002009C0  D484                    1642m     ADD.L D4,D2
002009C2                          1643m 
002009C2                          1644m     ENDM
002009C2                          1645m     PRINT_CRLF D5
002009C2                          1646mm     PRINT_CHAR #CR,D5                           ; CR
002009C2                          1647mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009C2                 TRUE     1648mm     IFEQ DEBUG
002009C2  1A39 00C00003           1649mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009C8  0805 0002               1650mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009CC  67F4                    1651mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
002009CE  13FC 000D 00C00007      1652mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009D6                          1653mm     ENDC
002009D6                          1654mm     
002009D6                 FALSE    1655mm     IFNE DEBUG
002009D6                          1656mm     ENDC
002009D6                          1657mm 
002009D6                          1658mm     ENDM
002009D6                          1659mm     PRINT_CHAR #LF,D5                           ; LF
002009D6                          1660mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                 TRUE     1661mm     IFEQ DEBUG
002009D6  1A39 00C00003           1662mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009DC  0805 0002               1663mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009E0  67F4                    1664mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
002009E2  13FC 000A 00C00007      1665mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009EA                          1666mm     ENDC
002009EA                          1667mm     
002009EA                 FALSE    1668mm     IFNE DEBUG
002009EA                          1669mm     ENDC
002009EA                          1670mm 
002009EA                          1671mm     ENDM
002009EA                          1672m     ENDM
002009EA                          1673          
002009EA                          1674      IF.B D2 <NE> #$FF THEN.L
002009EA  B43C 00FF               1675s     CMP.B   #$FF,D2
002009EE  6700 00A4               1676s     BEQ.L   _0000000A
002009F2  49F9 00200F35           1677          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
002009F8                          1678m         PRINT_STR A4,D5
002009F8                          1679m LOOP_107
002009F8  0C14 0000               1680m     CMP.B #NULL,(A4)                            ; 0 -> DONE
002009FC  6700 0016               1681m     BEQ EXIT_107
00200A00                          1682mm     PRINT_CHAR (A4)+,D5
00200A00                          1683mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A00                 TRUE     1684mm     IFEQ DEBUG
00200A00  1A39 00C00003           1685mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A06  0805 0002               1686mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A0A  67F4                    1687mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A0C  13DC 00C00007           1688mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200A12                          1689mm     ENDC
00200A12                          1690mm     
00200A12                 FALSE    1691mm     IFNE DEBUG
00200A12                          1692mm     ENDC
00200A12                          1693mm 
00200A12                          1694mm     ENDM
00200A12  60E4                    1695m     BRA LOOP_107
00200A14                          1696m EXIT_107
00200A14                          1697m     ENDM
00200A14                          1698m         PRINT_REG D0,D5,D2,D6,A4
00200A14                          1699mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200A14                          1700mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A14                 TRUE     1701mm     IFEQ DEBUG
00200A14  1A39 00C00003           1702mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A1A  0805 0002               1703mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A1E  67F4                    1704mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200A20  13FC 0030 00C00007      1705mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A28                          1706mm     ENDC
00200A28                          1707mm     
00200A28                 FALSE    1708mm     IFNE DEBUG
00200A28                          1709mm     ENDC
00200A28                          1710mm 
00200A28                          1711mm     ENDM
00200A28                          1712mm     PRINT_CHAR #'x',D5
00200A28                          1713mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A28                 TRUE     1714mm     IFEQ DEBUG
00200A28  1A39 00C00003           1715mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A2E  0805 0002               1716mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A32  67F4                    1717mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200A34  13FC 0078 00C00007      1718mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A3C                          1719mm     ENDC
00200A3C                          1720mm     
00200A3C                 FALSE    1721mm     IFNE DEBUG
00200A3C                          1722mm     ENDC
00200A3C                          1723mm 
00200A3C                          1724mm     ENDM
00200A3C  7C07                    1725m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200A3E                          1726m LOOP_109
00200A3E                          1727mm     BIN2HEX D0,D2,A4
00200A3E  49F9 00200F59           1728mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200A44  E998                    1729mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200A46  1400                    1730mm     MOVE.B D0,D2
00200A48  0282 0000000F           1731mm     ANDI.L #$F,D2
00200A4E  1434 2000               1732mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200A52                          1733mm     ENDM
00200A52                          1734mm     PRINT_CHAR D2,D5
00200A52                          1735mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A52                 TRUE     1736mm     IFEQ DEBUG
00200A52  1A39 00C00003           1737mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A58  0805 0002               1738mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A5C  67F4                    1739mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00200A5E  13C2 00C00007           1740mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A64                          1741mm     ENDC
00200A64                          1742mm     
00200A64                 FALSE    1743mm     IFNE DEBUG
00200A64                          1744mm     ENDC
00200A64                          1745mm 
00200A64                          1746mm     ENDM
00200A64  57CE FFD8               1747m     DBEQ D6,LOOP_109
00200A68                          1748m     ENDM
00200A68                          1749m         PRINT_CRLF D5
00200A68                          1750mm     PRINT_CHAR #CR,D5                           ; CR
00200A68                          1751mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A68                 TRUE     1752mm     IFEQ DEBUG
00200A68  1A39 00C00003           1753mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A6E  0805 0002               1754mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A72  67F4                    1755mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00200A74  13FC 000D 00C00007      1756mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A7C                          1757mm     ENDC
00200A7C                          1758mm     
00200A7C                 FALSE    1759mm     IFNE DEBUG
00200A7C                          1760mm     ENDC
00200A7C                          1761mm 
00200A7C                          1762mm     ENDM
00200A7C                          1763mm     PRINT_CHAR #LF,D5                           ; LF
00200A7C                          1764mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A7C                 TRUE     1765mm     IFEQ DEBUG
00200A7C  1A39 00C00003           1766mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A82  0805 0002               1767mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A86  67F4                    1768mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200A88  13FC 000A 00C00007      1769mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A90                          1770mm     ENDC
00200A90                          1771mm     
00200A90                 FALSE    1772mm     IFNE DEBUG
00200A90                          1773mm     ENDC
00200A90                          1774mm 
00200A90                          1775mm     ENDM
00200A90                          1776m     ENDM
00200A90  6000 F6DE               1777          BRA MAIN_LOOP
00200A94                          1778      ENDI
00200A94                          1779s _0000000A
00200A94                          1780      
00200A94  4ED3                    1781      JMP (A3)
00200A96                          1782  DOWNLOAD_DONE
00200A96                          1783m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00200A96                          1784mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200A96                          1785mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A96                 TRUE     1786mm     IFEQ DEBUG
00200A96  1A39 00C00003           1787mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A9C  0805 0002               1788mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AA0  67F4                    1789mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200AA2  13FC 0030 00C00007      1790mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AAA                          1791mm     ENDC
00200AAA                          1792mm     
00200AAA                 FALSE    1793mm     IFNE DEBUG
00200AAA                          1794mm     ENDC
00200AAA                          1795mm 
00200AAA                          1796mm     ENDM
00200AAA                          1797mm     PRINT_CHAR #'x',D5
00200AAA                          1798mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAA                 TRUE     1799mm     IFEQ DEBUG
00200AAA  1A39 00C00003           1800mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AB0  0805 0002               1801mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AB4  67F4                    1802mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200AB6  13FC 0078 00C00007      1803mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200ABE                          1804mm     ENDC
00200ABE                          1805mm     
00200ABE                 FALSE    1806mm     IFNE DEBUG
00200ABE                          1807mm     ENDC
00200ABE                          1808mm 
00200ABE                          1809mm     ENDM
00200ABE  7407                    1810m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AC0                          1811m LOOP_117
00200AC0                          1812mm     BIN2HEX D0,D6,A1
00200AC0  43F9 00200F59           1813mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200AC6  E998                    1814mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200AC8  1C00                    1815mm     MOVE.B D0,D6
00200ACA  0286 0000000F           1816mm     ANDI.L #$F,D6
00200AD0  1C31 6000               1817mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200AD4                          1818mm     ENDM
00200AD4                          1819mm     PRINT_CHAR D6,D5
00200AD4                          1820mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AD4                 TRUE     1821mm     IFEQ DEBUG
00200AD4  1A39 00C00003           1822mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200ADA  0805 0002               1823mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200ADE  67F4                    1824mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200AE0  13C6 00C00007           1825mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AE6                          1826mm     ENDC
00200AE6                          1827mm     
00200AE6                 FALSE    1828mm     IFNE DEBUG
00200AE6                          1829mm     ENDC
00200AE6                          1830mm 
00200AE6                          1831mm     ENDM
00200AE6  57CA FFD8               1832m     DBEQ D2,LOOP_117
00200AEA                          1833m     ENDM
00200AEA  43F9 00200EFC           1834      LEA READ,A1
00200AF0                          1835m     PRINT_STR A1,D5
00200AF0                          1836m LOOP_122
00200AF0  0C11 0000               1837m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00200AF4  6700 0016               1838m     BEQ EXIT_122
00200AF8                          1839mm     PRINT_CHAR (A1)+,D5
00200AF8                          1840mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF8                 TRUE     1841mm     IFEQ DEBUG
00200AF8  1A39 00C00003           1842mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AFE  0805 0002               1843mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B02  67F4                    1844mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00200B04  13D9 00C00007           1845mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200B0A                          1846mm     ENDC
00200B0A                          1847mm     
00200B0A                 FALSE    1848mm     IFNE DEBUG
00200B0A                          1849mm     ENDC
00200B0A                          1850mm 
00200B0A                          1851mm     ENDM
00200B0A  60E4                    1852m     BRA LOOP_122
00200B0C                          1853m EXIT_122
00200B0C                          1854m     ENDM
00200B0C  2E08                    1855      MOVE.L A0,D7                                    ; set address accumulator to start address
00200B0E                          1856m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00200B0E                          1857mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200B0E                          1858mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0E                 TRUE     1859mm     IFEQ DEBUG
00200B0E  1A39 00C00003           1860mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B14  0805 0002               1861mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B18  67F4                    1862mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00200B1A  13FC 0030 00C00007      1863mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B22                          1864mm     ENDC
00200B22                          1865mm     
00200B22                 FALSE    1866mm     IFNE DEBUG
00200B22                          1867mm     ENDC
00200B22                          1868mm 
00200B22                          1869mm     ENDM
00200B22                          1870mm     PRINT_CHAR #'x',D5
00200B22                          1871mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B22                 TRUE     1872mm     IFEQ DEBUG
00200B22  1A39 00C00003           1873mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B28  0805 0002               1874mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B2C  67F4                    1875mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200B2E  13FC 0078 00C00007      1876mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B36                          1877mm     ENDC
00200B36                          1878mm     
00200B36                 FALSE    1879mm     IFNE DEBUG
00200B36                          1880mm     ENDC
00200B36                          1881mm 
00200B36                          1882mm     ENDM
00200B36  7407                    1883m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B38                          1884m LOOP_124
00200B38                          1885mm     BIN2HEX D7,D6,A1
00200B38  43F9 00200F59           1886mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200B3E  E99F                    1887mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B40  1C07                    1888mm     MOVE.B D7,D6
00200B42  0286 0000000F           1889mm     ANDI.L #$F,D6
00200B48  1C31 6000               1890mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200B4C                          1891mm     ENDM
00200B4C                          1892mm     PRINT_CHAR D6,D5
00200B4C                          1893mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B4C                 TRUE     1894mm     IFEQ DEBUG
00200B4C  1A39 00C00003           1895mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B52  0805 0002               1896mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B56  67F4                    1897mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200B58  13C6 00C00007           1898mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B5E                          1899mm     ENDC
00200B5E                          1900mm     
00200B5E                 FALSE    1901mm     IFNE DEBUG
00200B5E                          1902mm     ENDC
00200B5E                          1903mm 
00200B5E                          1904mm     ENDM
00200B5E  57CA FFD8               1905m     DBEQ D2,LOOP_124
00200B62                          1906m     ENDM
00200B62                          1907m     PRINT_CRLF D5     
00200B62                          1908mm     PRINT_CHAR #CR,D5                           ; CR
00200B62                          1909mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B62                 TRUE     1910mm     IFEQ DEBUG
00200B62  1A39 00C00003           1911mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B68  0805 0002               1912mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B6C  67F4                    1913mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00200B6E  13FC 000D 00C00007      1914mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B76                          1915mm     ENDC
00200B76                          1916mm     
00200B76                 FALSE    1917mm     IFNE DEBUG
00200B76                          1918mm     ENDC
00200B76                          1919mm 
00200B76                          1920mm     ENDM
00200B76                          1921mm     PRINT_CHAR #LF,D5                           ; LF
00200B76                          1922mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B76                 TRUE     1923mm     IFEQ DEBUG
00200B76  1A39 00C00003           1924mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B7C  0805 0002               1925mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B80  67F4                    1926mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200B82  13FC 000A 00C00007      1927mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B8A                          1928mm     ENDC
00200B8A                          1929mm     
00200B8A                 FALSE    1930mm     IFNE DEBUG
00200B8A                          1931mm     ENDC
00200B8A                          1932mm 
00200B8A                          1933mm     ENDM
00200B8A                          1934m     ENDM
00200B8A                          1935          
00200B8A  6000 F5E4               1936      BRA MAIN_LOOP
00200B8E                          1937      
00200B8E                          1938  G
00200B8E  2047                    1939      MOVE.L D7,A0                                    ; address accumulator -> address register
00200B90  3E3C 0000               1940      MOVE #0,D7                                      ; clear the now used address accumulator
00200B94  4ED0                    1941      JMP (A0)                                        ; jump to it!
00200B96                          1942      
00200B96                          1943  Z
00200B96  207C 00200000           1944      MOVE.L #RAM,A0                                  ; address of RAM
00200B9C  7000                    1945      MOVE.L #0,D0                                    ; number of bytes
00200B9E                          1946     
00200B9E                          1947      WHILE.L D0 <LE> #$40000 DO                      ; read the data bytes
00200B9E                          1948s _10000014
00200B9E  B0BC 00040000           1949s     CMP.L   #$40000,D0
00200BA4  6E00 001A               1950s     BGT _10000015
00200BA8  2200                    1951          MOVE.L D0,D1                                ; progress update
00200BAA  E089                    1952          LSR.L #8,D1 
00200BAC  E089                    1953          LSR.L #8,D1
00200BAE  0281 0000000F           1954          ANDI.L #$F,D1
00200BB4  13C1 00E00001           1955          MOVE.B D1,DISPLAY
00200BBA                          1956  
00200BBA  20C0                    1957          MOVE.L D0,(A0)+ 
00200BBC  5880                    1958          ADD.L #4,D0
00200BBE                          1959      ENDW
00200BBE  60DE                    1960s     BRA _10000014
00200BC0                          1961s _10000015
00200BC0                          1962   
00200BC0  207C 00200000           1963      MOVE.L #RAM,A0                                  ; address of RAM
00200BC6  7000                    1964      MOVE.L #0,D0                                    ; number of bytes
00200BC8                          1965     
00200BC8                          1966      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200BC8                          1967s _10000016
00200BC8  B0BC 00040000           1968s     CMP.L   #$40000,D0
00200BCE  6E00 00C8               1969s     BGT _10000017
00200BD2  2200                    1970          MOVE.L D0,D1                            ; progress update
00200BD4  E089                    1971          LSR.L #8,D1
00200BD6  E089                    1972          LSR.L #8,D1
00200BD8  0281 0000000F           1973          ANDI.L #$F,D1
00200BDE  13C1 00E00001           1974          MOVE.B D1,DISPLAY
00200BE4                          1975  
00200BE4  2218                    1976          MOVE.L (A0)+,D1
00200BE6                          1977            
00200BE6                          1978          IF.L D0 <EQ> D1 THEN
00200BE6  B081                    1979s     CMP.L   D1,D0
00200BE8  6600 0006               1980s     BNE _0000000B
00200BEC  6000 00A4               1981              BRA OK
00200BF0                          1982          ENDI 
00200BF0                          1983s _0000000B
00200BF0                          1984            
00200BF0  43F9 00200F47           1985          LEA RAM_ERROR,A1
00200BF6                          1986m         PRINT_STR A1,D1
00200BF6                          1987m LOOP_132
00200BF6  0C11 0000               1988m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00200BFA  6700 0016               1989m     BEQ EXIT_132
00200BFE                          1990mm     PRINT_CHAR (A1)+,D1
00200BFE                          1991mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1992mm     IFEQ DEBUG
00200BFE  1239 00C00003           1993mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200C04  0801 0002               1994mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1995mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200C0A  13D9 00C00007           1996mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200C10                          1997mm     ENDC
00200C10                          1998mm     
00200C10                 FALSE    1999mm     IFNE DEBUG
00200C10                          2000mm     ENDC
00200C10                          2001mm 
00200C10                          2002mm     ENDM
00200C10  60E4                    2003m     BRA LOOP_132
00200C12                          2004m EXIT_132
00200C12                          2005m     ENDM
00200C12  2208                    2006          MOVE.L A0,D1
00200C14  5981                    2007          SUB.L #4,D1
00200C16                          2008m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200C16                          2009mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00200C16                          2010mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C16                 TRUE     2011mm     IFEQ DEBUG
00200C16  1639 00C00003           2012mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C1C  0803 0002               2013mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C20  67F4                    2014mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00200C22  13FC 0030 00C00007      2015mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C2A                          2016mm     ENDC
00200C2A                          2017mm     
00200C2A                 FALSE    2018mm     IFNE DEBUG
00200C2A                          2019mm     ENDC
00200C2A                          2020mm 
00200C2A                          2021mm     ENDM
00200C2A                          2022mm     PRINT_CHAR #'x',D3
00200C2A                          2023mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C2A                 TRUE     2024mm     IFEQ DEBUG
00200C2A  1639 00C00003           2025mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C30  0803 0002               2026mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C34  67F4                    2027mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C36  13FC 0078 00C00007      2028mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200C3E                          2029mm     ENDC
00200C3E                          2030mm     
00200C3E                 FALSE    2031mm     IFNE DEBUG
00200C3E                          2032mm     ENDC
00200C3E                          2033mm 
00200C3E                          2034mm     ENDM
00200C3E  7C07                    2035m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200C40                          2036m LOOP_134
00200C40                          2037mm     BIN2HEX D1,D2,A1
00200C40  43F9 00200F59           2038mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200C46  E999                    2039mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200C48  1401                    2040mm     MOVE.B D1,D2
00200C4A  0282 0000000F           2041mm     ANDI.L #$F,D2
00200C50  1431 2000               2042mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200C54                          2043mm     ENDM
00200C54                          2044mm     PRINT_CHAR D2,D3
00200C54                          2045mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C54                 TRUE     2046mm     IFEQ DEBUG
00200C54  1639 00C00003           2047mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C5A  0803 0002               2048mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C5E  67F4                    2049mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200C60  13C2 00C00007           2050mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C66                          2051mm     ENDC
00200C66                          2052mm     
00200C66                 FALSE    2053mm     IFNE DEBUG
00200C66                          2054mm     ENDC
00200C66                          2055mm 
00200C66                          2056mm     ENDM
00200C66  57CE FFD8               2057m     DBEQ D6,LOOP_134
00200C6A                          2058m     ENDM
00200C6A                          2059m         PRINT_CRLF D3
00200C6A                          2060mm     PRINT_CHAR #CR,D3                           ; CR
00200C6A                          2061mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6A                 TRUE     2062mm     IFEQ DEBUG
00200C6A  1639 00C00003           2063mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C70  0803 0002               2064mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C74  67F4                    2065mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00200C76  13FC 000D 00C00007      2066mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C7E                          2067mm     ENDC
00200C7E                          2068mm     
00200C7E                 FALSE    2069mm     IFNE DEBUG
00200C7E                          2070mm     ENDC
00200C7E                          2071mm 
00200C7E                          2072mm     ENDM
00200C7E                          2073mm     PRINT_CHAR #LF,D3                           ; LF
00200C7E                          2074mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C7E                 TRUE     2075mm     IFEQ DEBUG
00200C7E  1639 00C00003           2076mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C84  0803 0002               2077mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C88  67F4                    2078mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200C8A  13FC 000A 00C00007      2079mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C92                          2080mm     ENDC
00200C92                          2081mm     
00200C92                 FALSE    2082mm     IFNE DEBUG
00200C92                          2083mm     ENDC
00200C92                          2084mm 
00200C92                          2085mm     ENDM
00200C92                          2086m     ENDM
00200C92                          2087  OK    
00200C92  5880                    2088          ADD.L #4,D0
00200C94                          2089      ENDW
00200C94  6000 FF32               2090s     BRA _10000016
00200C98                          2091s _10000017
00200C98                          2092      
00200C98  6000 F4D6               2093      BRA MAIN_LOOP
00200C9C                          2094    
00200C9C                          2095  L
00200C9C  7A00                    2096      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00200C9E                          2097  
00200C9E                          2098m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200C9E                          2099m WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C9E                 TRUE     2100m     IFEQ DEBUG
00200C9E  1639 00C00003           2101m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200CA4  0803 0000               2102m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200CA8  67F4                    2103m         BEQ WAIT_FOR_READY_142                      ; NOTHING, CHECK AGAIN
00200CAA                          2104m     ENDC
00200CAA                          2105m     
00200CAA                          2106mm     READ_CHAR D2
00200CAA                 TRUE     2107mm     IFEQ DEBUG
00200CAA  1439 00C00007           2108mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200CB0                          2109mm     ENDC
00200CB0                 FALSE    2110mm     IFNE DEBUG
00200CB0                          2111mm     ENDC
00200CB0                          2112mm      
00200CB0  B43C 001B               2113mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CB4  6700 F352               2114mm     BEQ START
00200CB8                          2115mm     ENDM
00200CB8                          2116m 
00200CB8                 TRUE     2117m     IFEQ DEBUG
00200CB8                          2118mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200CB8                          2119mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CB8                 TRUE     2120mm     IFEQ DEBUG
00200CB8  1639 00C00003           2121mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CBE  0803 0002               2122mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC2  67F4                    2123mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200CC4  13C2 00C00007           2124mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CCA                          2125mm     ENDC
00200CCA                          2126mm     
00200CCA                 FALSE    2127mm     IFNE DEBUG
00200CCA                          2128mm     ENDC
00200CCA                          2129mm 
00200CCA                          2130mm     ENDM
00200CCA                          2131m     ENDC
00200CCA                          2132m     ENDM
00200CCA                          2133m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200CCA  41F9 00200F69           2134m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200CD0  0402 0030               2135m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200CD4  C4BC 000000FF           2136m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200CDA  1430 2000               2137m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200CDE                          2138m     ENDM
00200CDE  1A02                    2139      MOVE.B D2,D5                                    ; put at bottom of D5
00200CE0                          2140  
00200CE0  3C3C 0002               2141      MOVE #2,D6                                      ; 3 bytes left to read
00200CE4                          2142      
00200CE4                          2143  READ_LENGTH
00200CE4  E98D                    2144      LSL.L #4,D5                                     ; make what we have so far more significant
00200CE6                          2145m     WAIT_CHAR D2,D3                                 ; next character -> D2
00200CE6                          2146m WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE6                 TRUE     2147m     IFEQ DEBUG
00200CE6  1639 00C00003           2148m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200CEC  0803 0000               2149m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200CF0  67F4                    2150m         BEQ WAIT_FOR_READY_146                      ; NOTHING, CHECK AGAIN
00200CF2                          2151m     ENDC
00200CF2                          2152m     
00200CF2                          2153mm     READ_CHAR D2
00200CF2                 TRUE     2154mm     IFEQ DEBUG
00200CF2  1439 00C00007           2155mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200CF8                          2156mm     ENDC
00200CF8                 FALSE    2157mm     IFNE DEBUG
00200CF8                          2158mm     ENDC
00200CF8                          2159mm      
00200CF8  B43C 001B               2160mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFC  6700 F30A               2161mm     BEQ START
00200D00                          2162mm     ENDM
00200D00                          2163m 
00200D00                 TRUE     2164m     IFEQ DEBUG
00200D00                          2165mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200D00                          2166mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D00                 TRUE     2167mm     IFEQ DEBUG
00200D00  1639 00C00003           2168mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D06  0803 0002               2169mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D0A  67F4                    2170mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00200D0C  13C2 00C00007           2171mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D12                          2172mm     ENDC
00200D12                          2173mm     
00200D12                 FALSE    2174mm     IFNE DEBUG
00200D12                          2175mm     ENDC
00200D12                          2176mm 
00200D12                          2177mm     ENDM
00200D12                          2178m     ENDC
00200D12                          2179m     ENDM
00200D12                          2180m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200D12  41F9 00200F69           2181m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200D18  0402 0030               2182m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D1C  C4BC 000000FF           2183m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200D22  1430 2000               2184m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200D26                          2185m     ENDM
00200D26  8A02                    2186      OR.B D2,D5  
00200D28  023C 00FB               2187      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200D2C  57CE FFB6               2188      DBEQ D6,READ_LENGTH
00200D30                          2189          
00200D30                          2190m     PRINT_CRLF D3
00200D30                          2191mm     PRINT_CHAR #CR,D3                           ; CR
00200D30                          2192mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D30                 TRUE     2193mm     IFEQ DEBUG
00200D30  1639 00C00003           2194mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D36  0803 0002               2195mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D3A  67F4                    2196mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00200D3C  13FC 000D 00C00007      2197mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D44                          2198mm     ENDC
00200D44                          2199mm     
00200D44                 FALSE    2200mm     IFNE DEBUG
00200D44                          2201mm     ENDC
00200D44                          2202mm 
00200D44                          2203mm     ENDM
00200D44                          2204mm     PRINT_CHAR #LF,D3                           ; LF
00200D44                          2205mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D44                 TRUE     2206mm     IFEQ DEBUG
00200D44  1639 00C00003           2207mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D4A  0803 0002               2208mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D4E  67F4                    2209mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00200D50  13FC 000A 00C00007      2210mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D58                          2211mm     ENDC
00200D58                          2212mm     
00200D58                 FALSE    2213mm     IFNE DEBUG
00200D58                          2214mm     ENDC
00200D58                          2215mm 
00200D58                          2216mm     ENDM
00200D58                          2217m     ENDM
00200D58                          2218  
00200D58  207C 00000000           2219      MOVE.L #ROM,A0                                  ; start of ROM
00200D5E                          2220      
00200D5E  2247                    2221      MOVE.L D7,A1                                    ; address accumulator -> address register
00200D60  7E00                    2222      MOVE.L #0,D7                                    ; clear the now used address accumulator
00200D62                          2223      
00200D62  267C 00002AAA           2224      MOVE.L #$2AAA,A3
00200D68  36BC AAAA               2225      MOVE.W #$AAAA,(A3)
00200D6C  267C 00001554           2226      MOVE.L #$1554,A3
00200D72  36BC 5555               2227      MOVE.W #$5555,(A3)
00200D76  267C 00002AAA           2228      MOVE.L #$2AAA,A3
00200D7C  36BC 8080               2229      MOVE.W #$8080,(A3)
00200D80  267C 00002AAA           2230      MOVE.L #$2AAA,A3
00200D86  36BC AAAA               2231      MOVE.W #$AAAA,(A3)
00200D8A  267C 00001554           2232      MOVE.L #$1554,A3
00200D90  36BC 5555               2233      MOVE.W #$5555,(A3)
00200D94  267C 00002AAA           2234      MOVE.L #$2AAA,A3
00200D9A  36BC 2020               2235      MOVE.W #$2020,(A3)
00200D9E                          2236      
00200D9E  45F9 00200F80           2237      LEA LOADING,A2                              ; important for timing
00200DA4                          2238m     PRINT_STR A2,D3
00200DA4                          2239m LOOP_153
00200DA4  0C12 0000               2240m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00200DA8  6700 0016               2241m     BEQ EXIT_153
00200DAC                          2242mm     PRINT_CHAR (A2)+,D3
00200DAC                          2243mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DAC                 TRUE     2244mm     IFEQ DEBUG
00200DAC  1639 00C00003           2245mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DB2  0803 0002               2246mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DB6  67F4                    2247mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200DB8  13DA 00C00007           2248mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200DBE                          2249mm     ENDC
00200DBE                          2250mm     
00200DBE                 FALSE    2251mm     IFNE DEBUG
00200DBE                          2252mm     ENDC
00200DBE                          2253mm 
00200DBE                          2254mm     ENDM
00200DBE  60E4                    2255m     BRA LOOP_153
00200DC0                          2256m EXIT_153
00200DC0                          2257m     ENDM
00200DC0                          2258  
00200DC0  023C 00FB               2259      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200DC4                          2260      
00200DC4                          2261      WHILE D5 <GT> #0 DO
00200DC4                          2262s _10000018
00200DC4  BA7C 0000               2263s     CMP.W   #0,D5
00200DC8  6F00 001C               2264s     BLE _10000019
00200DCC  5585                    2265          SUB.L #2,D5
00200DCE                          2266            
00200DCE  13D1 00E00001           2267          MOVE.B (A1),DISPLAY
00200DD4  3091                    2268          MOVE.W (A1),(A0)                            ; write the data
00200DD6                          2269        
00200DD6                          2270  WAIT_FOR_COMPLETE
00200DD6  3410                    2271          MOVE.W (A0),D2
00200DD8                          2272  
00200DD8                          2273          IF D2 <NE> (A1) THEN
00200DD8  B451                    2274s     CMP.W   (A1),D2
00200DDA  6700 0004               2275s     BEQ _0000000C
00200DDE  60F6                    2276              BRA WAIT_FOR_COMPLETE
00200DE0                          2277          ENDI
00200DE0                          2278s _0000000C
00200DE0                          2279        
00200DE0  5488                    2280          ADD.L #2,A0
00200DE2  5489                    2281          ADD.L #2,A1
00200DE4                          2282      ENDW  
00200DE4  60DE                    2283s     BRA _10000018
00200DE6                          2284s _10000019
00200DE6                          2285      
00200DE6  267C 00002AAA           2286      MOVE.L #$2AAA,A3
00200DEC  36BC AAAA               2287      MOVE.W #$AAAA,(A3)
00200DF0  267C 00001554           2288      MOVE.L #$1554,A3
00200DF6  36BC 5555               2289      MOVE.W #$5555,(A3)
00200DFA  267C 00002AAA           2290      MOVE.L #$2AAA,A3
00200E00  36BC A0A0               2291      MOVE.W #$A0A0,(A3)
00200E04                          2292              
00200E04  6000 F36A               2293      BRA MAIN_LOOP
00200E08                          2294          
00200E08                          2295  HEX_DIGIT
00200E08  E98F                    2296      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200E0A                          2297m     HEX2BIN D2,D2,A0
00200E0A  41F9 00200F69           2298m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200E10  0402 0030               2299m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E14  C4BC 000000FF           2300m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200E1A  1430 2000               2301m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200E1E                          2302m     ENDM
00200E1E  8E02                    2303      OR.B D2,D7  
00200E20  6000 F376               2304      BRA GET_INPUT
00200E24                          2305  
00200E24  FFFF FFFF               2306      SIMHALT                                         ; halt simulator
00200E28                          2307  
00200E28                          2308  ; strings
00200E28= 4D 44 46 2D 6D 6F ...   2309  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',CR,LF,NULL
00200E45= 3F 09 09 09 68 65 ...   2310  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00200E4F= 5B 76 5D 09 09 09 ...   2311          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00200E5E= 78 78 78 78 78 78 ...   2312          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00200E76= 78 78 78 78 78 78 ...   2313          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00200E96= 5B 73 5D 09 09 09 ...   2314          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00200EB0= 78 78 78 78 78 78 ...   2315          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00200EC1= 5B 7A 5D 09 09 09 ...   2316          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00200ED3= 78 78 78 78 78 78 ...   2317          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00200EF5= 48 75 68 3F 0D 0A 00    2318  HUH     DC.B 'Huh?',CR,LF,NULL
00200EFC= 20 53 20 72 65 63 ...   2319  READ    DC.B ' S records read, start address = ',NULL
00200F1E= 57 3A 20 55 6E 6B ...   2320  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00200F35= 57 3A 20 43 53 20 ...   2321  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00200F47= 57 3A 20 52 41 4D ...   2322  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00200F59= 30 31 32 33 34 35 ...   2323  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00200F69= 00 01 02 03 04 05 ...   2324  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00200F80= 4C 6F 61 64 69 6E ...   2325  LOADING  DC.B 'Loading EEPROM...',CR,LF,NULL
00200F94                          2326      
00200F94                          2327      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200F59
CONTINUE_100        200978
CONTINUE_41         20041A
CONTINUE_44         20046A
CONTINUE_48         2004C2
CONTINUE_56         200580
CONTINUE_61         2005F4
CONTINUE_66         200672
CONTINUE_71         2006F6
CONTINUE_76         200786
CONTINUE_81         2007FA
CONTINUE_86         20086E
CR                  D
CS_FAILURE          200F35
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            994
DOWNLOAD_BYTE       C79
DOWNLOAD_DONE       200A96
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_107            200A14
EXIT_122            200B0C
EXIT_132            200C12
EXIT_153            200DC0
EXIT_18             200276
EXIT_20             2002A6
EXIT_5              20013E
EXIT_93             20090E
G                   200B8E
GET_INPUT           200198
H                   20027A
HELP                200E45
HEX2BIN             134
HEX2BIN_LUT         200F69
HEX_DIGIT           200E08
HUH                 200EF5
L                   200C9C
LF                  A
LOADING             200F80
LOOP_107            2009F8
LOOP_109            200A3E
LOOP_117            200AC0
LOOP_122            200AF0
LOOP_124            200B38
LOOP_132            200BF6
LOOP_134            200C40
LOOP_153            200DA4
LOOP_18             20025A
LOOP_20             20028A
LOOP_22             2002D8
LOOP_5              200122
LOOP_93             2008F2
MAIN_LOOP           200170
NULL                0
OK                  200C92
PRINTSTR            20028A
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           587
PRINT_STR           4FF
R                   2002AA
RAM                 200000
RAM_ERROR           200F47
READ                200EFC
READ_CHAR           82E
READ_DATA_TO_POKE   200378
READ_LENGTH         200CE4
RESET               200004
ROM                 0
S                   2003F6
STACK               200000
START               200008
TAB                 9
UNREC               200F1E
V                   200284
VERSION             200E28
W                   200330
WAIT_CHAR           67F
WAIT_FOR_COMPLETE   200DD6
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   200170
WAIT_FOR_READY_100  20095C
WAIT_FOR_READY_102  200990
WAIT_FOR_READY_105  2009C2
WAIT_FOR_READY_106  2009D6
WAIT_FOR_READY_108  200A00
WAIT_FOR_READY_11   200184
WAIT_FOR_READY_110  200A14
WAIT_FOR_READY_111  200A28
WAIT_FOR_READY_113  200A52
WAIT_FOR_READY_115  200A68
WAIT_FOR_READY_116  200A7C
WAIT_FOR_READY_118  200A96
WAIT_FOR_READY_119  200AAA
WAIT_FOR_READY_12   200198
WAIT_FOR_READY_121  200AD4
WAIT_FOR_READY_123  200AF8
WAIT_FOR_READY_125  200B0E
WAIT_FOR_READY_126  200B22
WAIT_FOR_READY_128  200B4C
WAIT_FOR_READY_130  200B62
WAIT_FOR_READY_131  200B76
WAIT_FOR_READY_133  200BFE
WAIT_FOR_READY_135  200C16
WAIT_FOR_READY_136  200C2A
WAIT_FOR_READY_138  200C54
WAIT_FOR_READY_14   2001B2
WAIT_FOR_READY_140  200C6A
WAIT_FOR_READY_141  200C7E
WAIT_FOR_READY_142  200C9E
WAIT_FOR_READY_144  200CB8
WAIT_FOR_READY_146  200CE6
WAIT_FOR_READY_148  200D00
WAIT_FOR_READY_151  200D30
WAIT_FOR_READY_152  200D44
WAIT_FOR_READY_154  200DAC
WAIT_FOR_READY_16   2001FC
WAIT_FOR_READY_17   200210
WAIT_FOR_READY_19   200262
WAIT_FOR_READY_21   200292
WAIT_FOR_READY_23   2002AE
WAIT_FOR_READY_24   2002C2
WAIT_FOR_READY_26   2002EC
WAIT_FOR_READY_28   200302
WAIT_FOR_READY_29   200316
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_30   200332
WAIT_FOR_READY_32   20034C
WAIT_FOR_READY_34   20037A
WAIT_FOR_READY_36   200394
WAIT_FOR_READY_39   2003CA
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_40   2003DE
WAIT_FOR_READY_41   2003FE
WAIT_FOR_READY_43   200438
WAIT_FOR_READY_44   20044E
WAIT_FOR_READY_46   200482
WAIT_FOR_READY_48   2004A6
WAIT_FOR_READY_50   2004DA
WAIT_FOR_READY_53   200514
WAIT_FOR_READY_54   200528
WAIT_FOR_READY_56   200564
WAIT_FOR_READY_58   200598
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   2005D8
WAIT_FOR_READY_63   20060C
WAIT_FOR_READY_66   200656
WAIT_FOR_READY_68   20068A
WAIT_FOR_READY_71   2006DA
WAIT_FOR_READY_73   20070E
WAIT_FOR_READY_76   20076A
WAIT_FOR_READY_78   20079E
WAIT_FOR_READY_8    20013E
WAIT_FOR_READY_81   2007DE
WAIT_FOR_READY_83   200812
WAIT_FOR_READY_86   200852
WAIT_FOR_READY_88   200886
WAIT_FOR_READY_9    200152
WAIT_FOR_READY_91   2008C4
WAIT_FOR_READY_92   2008D8
WAIT_FOR_READY_94   2008FA
WAIT_FOR_READY_95   20090E
WAIT_FOR_READY_97   200920
WAIT_FOR_READY_98   200934
WAIT_FOR_SRECORD    2003FE
Z                   200B96
_00000000           2001D8
_00000001           2001EC
_00000002           200544
_00000003           20094C
_00000004           200552
_00000005           200752
_00000006           2006BC
_00000007           20094C
_00000008           2008C4
_00000009           20094C
_0000000A           200A94
_0000000B           200BF0
_0000000C           200DE0
_10000000           20049C
_10000001           200506
_10000002           20055A
_10000003           2005C4
_10000004           2005CE
_10000005           200638
_10000006           20064C
_10000007           2006B6
_10000008           2006C0
_10000009           200748
_1000000A           2006D0
_1000000B           20073A
_1000000C           200760
_1000000D           2007CA
_1000000E           2007D4
_1000000F           20083E
_10000010           200848
_10000011           2008B2
_10000012           200952
_10000013           2009BC
_10000014           200B9E
_10000015           200BC0
_10000016           200BC8
_10000017           200C98
_10000018           200DC4
_10000019           200DE6
