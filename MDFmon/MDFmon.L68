00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08/04/2021 06:41:54

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; fix the DUART base address, something like C00000
00000000                             9  ; remove X, it's just 0G
00000000                            10  ; tidy up layout (indentation and comments)
00000000                            11  ; tidy up NAND gate invertor and wiring for OE and WE on eeproms
00000000                            12  ; tidy up power loom
00000000                            13  ; add LDS and UDS with an OR gate and test because then I can do byte writes and it will make the download simpler
00000000                            14  ; stop using two registers in download
00000000                            15  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            16  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            17  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            18  
00000000                            19  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            20  ; keep track of highest address hit during srec download
00000000                            21  ; fix the reset vector so that it jumps to the start
00000000                            22  ; Replace JMP -> BRA
00000000                            23  ; implement backspace
00000000                            24  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            25  ; fix being able to enter random chars when W'ing
00000000                            26  ; ram check at startup?  Not sure if this is a good idea!
00000000                            27  
00000000                            28  
00000000                            29      ;ORG  $0
00200000                            30      ORG  $200000
00200000                            31  
00200000  =00000000                 32  DEBUG               EQU 0
00200000                            33  
00200000                            34  
00200000                            35  ; constants
00200000  =00000000                 36  ROM                 EQU $0
00200000  =00200000                 37  RAM                 EQU $200000
00200000                            38     
00200000  =00C00000                 39  DUART_BASE          EQU $C00000
00200000  =00000000                 40  DUART_MRA_          EQU $0
00200000  =00000001                 41  DUART_CSRA_         EQU $1
00200000  =00000001                 42  DUART_SRA_          EQU $1
00200000  =00000002                 43  DUART_CRA_          EQU $2
00200000  =00000003                 44  DUART_TXA_          EQU $3
00200000  =00000003                 45  DUART_RXA_          EQU $3
00200000  =00000004                 46  DUART_ACR_          EQU $4
00200000  =00000005                 47  DUART_IMR_          EQU $5
00200000  =00000008                 48  DUART_MRB_          EQU $8
00200000  =00000009                 49  DUART_CSRB_         EQU $9
00200000  =00000009                 50  DUART_SRB_          EQU $9
00200000  =0000000A                 51  DUART_CRB_          EQU $A
00200000  =0000000B                 52  DUART_TXB_          EQU $B
00200000  =0000000B                 53  DUART_RXB_          EQU $B
00200000  =0000000C                 54  DUART_IVR_          EQU $C
00200000  =0000000D                 55  DUART_OPCR_         EQU $D
00200000  =0000000E                 56  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 57  DUART_RESET_OPR_    EQU $F
00200000                            58  RRRR
00200000  =00C00001                 59  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 60  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 61  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 62  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 63  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 64  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            65  
00200000  =00C00011                 66  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 67  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 68  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 69  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 70  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 71  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            72  
00200000  =00C00009                 73  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 74  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 75  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 76  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 77  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 78  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            79  
00200000  =00E00000                 80  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 81  DISPLAY_            EQU $0
00200000  =00E00001                 82  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            83  
00200000                            84  ; macros
00200000                            85  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            86  ; the input register is changed during the process
00200000                            87  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            88  BIN2HEX MACRO
00200000                            89    LEA BIN2HEX_LUT,\3                ; load the lookup table
00200000                            90    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            91    MOVE.B \1,\2
00200000                            92    ANDI.L #$F,\2
00200000                            93    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00200000                            94    ENDM
00200000                            95  
00200000                            96  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            97  ; the input register is changed during the process
00200000                            98  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            99  HEX2BIN MACRO
00200000                           100    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00200000                           101    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00200000                           102    AND.L #$FF,\1                       ; ignore the top 3 bytes
00200000                           103    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00200000                           104    ENDM
00200000                           105  
00200000                           106  ; send a single char to the serial port
00200000                           107  ; \1 = char to send, \2 = data register to use for status poll
00200000                           108  ; will stamp on D0 and D1 in debug mode
00200000                           109  PRINT_CHAR MACRO
00200000                           110  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           111      IFEQ DEBUG
00200000                           112        MOVE.B DUART_SRA,\2           ; read status register
00200000                           113        BTST #2,\2                    ; check for space to send
00200000                           114        BEQ WAIT_FOR_READY\@          ; no space, check again
00200000                           115        MOVE.B \1,DUART_TXA           ; send the next character
00200000                           116      ENDC
00200000                           117      
00200000                           118      IFNE DEBUG
00200000                           119        MOVE.B \1,D1
00200000                           120        MOVE.L #6,D0   
00200000                           121        TRAP #15                      ; write to terminal in simulator
00200000                           122      ENDC
00200000                           123  
00200000                           124      ENDM
00200000                           125  
00200000                           126  ; send CR,LF to the serial port
00200000                           127  ; \1 = data register to use for status poll
00200000                           128  PRINT_CRLF MACRO                  
00200000                           129      PRINT_CHAR #13,\1             ; CR
00200000                           130      PRINT_CHAR #10,\1             ; LF
00200000                           131      ENDM
00200000                           132  
00200000                           133  ; send C-style, zero terminated string to the serial port
00200000                           134  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           135  PRINT_STR MACRO
00200000                           136  LOOP\@
00200000                           137      CMP.B #0,(\1)                 ; 0 -> done
00200000                           138      BEQ EXIT\@
00200000                           139      PRINT_CHAR (\1)+,\2
00200000                           140      JMP LOOP\@
00200000                           141  EXIT\@
00200000                           142      ENDM
00200000                           143    
00200000                           144  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           145  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           146  PRINT_REG MACRO
00200000                           147      PRINT_CHAR #'0',\2          ;0x header
00200000                           148      PRINT_CHAR #'x',\2
00200000                           149      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00200000                           150  LOOP\@
00200000                           151      BIN2HEX \1,\3,\5
00200000                           152      PRINT_CHAR \3,\2
00200000                           153      DBEQ \4,LOOP\@
00200000                           154      ENDM
00200000                           155    
00200000                           156  ; wait for a char from the serial port
00200000                           157  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           158  ; will stamp on D0 and D1 in debug mode
00200000                           159  WAIT_CHAR MACRO
00200000                           160  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           161  
00200000                           162      IFEQ DEBUG
00200000                           163        MOVE.B DUART_SRA,\2         ; read status register
00200000                           164        BTST #0,\2                    ; check for character
00200000                           165        BEQ WAIT_FOR_READY\@          ; nothing, check again
00200000                           166      ENDC
00200000                           167      
00200000                           168      READ_CHAR \1
00200000                           169  
00200000                           170      IFEQ DEBUG
00200000                           171        PRINT_CHAR \1,\2            ; echo it back
00200000                           172      ENDC
00200000                           173      ENDM
00200000                           174      
00200000                           175  ; read a char from the serial port - assumes that there is one!
00200000                           176  ; \ 1= data register for read char
00200000                           177  ; will stamp on D0 and D1 in debug mode
00200000                           178  READ_CHAR MACRO
00200000                           179      IFEQ DEBUG
00200000                           180        MOVE.B DUART_RXA,\1         ; got a character, read it
00200000                           181      ENDC
00200000                           182      IFNE DEBUG
00200000                           183        MOVE.L #5,D0    
00200000                           184        TRAP #15                    ; read from keyboard in simulator
00200000                           185        MOVE.L D1,\1
00200000                           186      ENDC
00200000                           187       
00200000                           188      CMP.B #$1B,\1                 ; check for escape and go to start
00200000                           189      BEQ START
00200000                           190      ENDM
00200000                           191      
00200000                           192      
00200000                           193  ; read data from the download serial port
00200000                           194  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           195  DOWNLOAD MACRO
00200000                           196  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           197  
00200000                           198      MOVE.B DUART_SRA,\2           ; check for command
00200000                           199      BTST #0,\2                    ; check for character
00200000                           200      BEQ CONTINUE\@                ; nothing, continue
00200000                           201   
00200000                           202      READ_CHAR \1
00200000                           203  CONTINUE\@
00200000                           204      MOVE.B DUART_SRB,\2         ; read status register
00200000                           205      BTST #0,\2                  ; check for character
00200000                           206      BEQ WAIT_FOR_READY\@        ; nothing, check again
00200000                           207      
00200000                           208      MOVE.B DUART_RXB,\1         ; got a character, read it
00200000                           209      MOVE.B \1,DISPLAY           ; echo to the display
00200000                           210      
00200000                           211      ENDM
00200000                           212  
00200000                           213  
00200000                           214  ; register catalogue
00200000                           215  ; D0 - used for simulator I/O
00200000                           216  ; D1 - used for simulator I/O
00200000                           217  ; D2 - read character
00200000                           218  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           219  ; D4 - count of S records read
00200000                           220  ; D5 - data to write / data read / byte count for S record load
00200000                           221  ; D6 - working register used in R/W and download
00200000                           222  ; D7 - address accumulator / reset by download
00200000                           223  ; A0 - address of string to print 
00200000                           224  
00200000                           225  ; start vector
00200000= 00000000                 226  STACK    DC.L $00000000              ; STACK
00200004= 00200008                 227  RESET    DC.L START                  ; RESET
00200008                           228      
00200008                           229  ; start of program  
00200008                           230  START
00200008  13FC 0000 00E00001       231      MOVE.B #0,DISPLAY
00200010                           232  
00200010                           233  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       234      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00200018  13FC 0050 00C00005       235      MOVE.B #$50,DUART_CRA           ; reset everyting
00200020  4E71                     236      NOP
00200022  13FC 0040 00C00005       237      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     238      NOP
0020002C  13FC 0030 00C00005       239      MOVE.B #$30,DUART_CRA
00200034  4E71                     240      NOP
00200036  13FC 0020 00C00005       241      MOVE.B #$20,DUART_CRA
0020003E  4E71                     242      NOP
00200040  13FC 0010 00C00005       243      MOVE.B #$10,DUART_CRA   
00200048                           244  
00200048  13FC 000A 00C00015       245      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00200050  13FC 0050 00C00015       246      MOVE.B #$50,DUART_CRB           ; reset everyting
00200058  4E71                     247      NOP
0020005A  13FC 0040 00C00015       248      MOVE.B #$40,DUART_CRB           
00200062  4E71                     249      NOP
00200064  13FC 0030 00C00015       250      MOVE.B #$30,DUART_CRB
0020006C  4E71                     251      NOP
0020006E  13FC 0020 00C00015       252      MOVE.B #$20,DUART_CRB
00200076  4E71                     253      NOP
00200078  13FC 0010 00C00015       254      MOVE.B #$10,DUART_CRB   
00200080                           255  
00200080                           256  ;initialise UART
00200080  13FC 0000 00C00009       257      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       258      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00200090  13FC 0000 00C0001B       259      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00200098                           260  
00200098                           261  ; channel A
00200098  13FC 0013 00C00001       262      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       263      MOVE.B #$07,DUART_MRA           ; 1 stop bit
002000A8  13FC 00BB 00C00003       264      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
002000B0  13FC 0005 00C00005       265      MOVE.B #$5,DUART_CRA            ; enable rx & tx
002000B8                           266  
002000B8                           267  ; channel B
002000B8  13FC 0013 00C00011       268      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       269      MOVE.B #$07,DUART_MRB           ; 1 stop bit
002000C8  13FC 00BB 00C00013       270      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
002000D0  13FC 0005 00C00015       271      MOVE.B #$5,DUART_CRB            ; enable rx & tx
002000D8                           272  
002000D8                           273m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
002000D8                           274m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      275m     IFEQ DEBUG
002000D8  1639 00C00003            276m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000DE  0803 0002                277m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000E2  67F4                     278m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       279m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
002000EC                           280m     ENDC
002000EC                           281m     
002000EC                 FALSE     282m     IFNE DEBUG
002000EC                           283m     ENDC
002000EC                           284m 
002000EC                           285m     ENDM
002000EC                           286  
002000EC  13FC 0001 00E00001       287      MOVE.B #1,DISPLAY
002000F4                           288         
002000F4                           289m     PRINT_CRLF D3
002000F4                           290mm     PRINT_CHAR #13,D3             ; CR
002000F4                           291mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      292mm     IFEQ DEBUG
002000F4  1639 00C00003            293mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000FA  0803 0002                294mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000FE  67F4                     295mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       296mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200108                           297mm     ENDC
00200108                           298mm     
00200108                 FALSE     299mm     IFNE DEBUG
00200108                           300mm     ENDC
00200108                           301mm 
00200108                           302mm     ENDM
00200108                           303mm     PRINT_CHAR #10,D3             ; LF
00200108                           304mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      305mm     IFEQ DEBUG
00200108  1639 00C00003            306mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020010E  0803 0002                307mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200112  67F4                     308mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       309mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020011C                           310mm     ENDC
0020011C                           311mm     
0020011C                 FALSE     312mm     IFNE DEBUG
0020011C                           313mm     ENDC
0020011C                           314mm 
0020011C                           315mm     ENDM
0020011C                           316m     ENDM
0020011C                           317  
0020011C  41F9 002019E2            318      LEA VERSION,A0
00200122                           319m     PRINT_STR A0,D3
00200122                           320m LOOP_5
00200122  0C10 0000                321m     CMP.B #0,(A0)                 ; 0 -> DONE
00200126  6700 001A                322m     BEQ EXIT_5
0020012A                           323mm     PRINT_CHAR (A0)+,D3
0020012A                           324mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      325mm     IFEQ DEBUG
0020012A  1639 00C00003            326mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200130  0803 0002                327mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200134  67F4                     328mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            329mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020013C                           330mm     ENDC
0020013C                           331mm     
0020013C                 FALSE     332mm     IFNE DEBUG
0020013C                           333mm     ENDC
0020013C                           334mm 
0020013C                           335mm     ENDM
0020013C  4EF9 00200122            336m     JMP LOOP_5
00200142                           337m EXIT_5
00200142                           338m     ENDM
00200142                           339m     PRINT_CRLF D3
00200142                           340mm     PRINT_CHAR #13,D3             ; CR
00200142                           341mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      342mm     IFEQ DEBUG
00200142  1639 00C00003            343mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200148  0803 0002                344mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020014C  67F4                     345mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       346mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200156                           347mm     ENDC
00200156                           348mm     
00200156                 FALSE     349mm     IFNE DEBUG
00200156                           350mm     ENDC
00200156                           351mm 
00200156                           352mm     ENDM
00200156                           353mm     PRINT_CHAR #10,D3             ; LF
00200156                           354mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      355mm     IFEQ DEBUG
00200156  1639 00C00003            356mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020015C  0803 0002                357mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200160  67F4                     358mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       359mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020016A                           360mm     ENDC
0020016A                           361mm     
0020016A                 FALSE     362mm     IFNE DEBUG
0020016A                           363mm     ENDC
0020016A                           364mm 
0020016A                           365mm     ENDM
0020016A                           366m     ENDM
0020016A                           367m     PRINT_CHAR #7,D3
0020016A                           368m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      369m     IFEQ DEBUG
0020016A  1639 00C00003            370m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200170  0803 0002                371m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200174  67F4                     372m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       373m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020017E                           374m     ENDC
0020017E                           375m     
0020017E                 FALSE     376m     IFNE DEBUG
0020017E                           377m     ENDC
0020017E                           378m 
0020017E                           379m     ENDM
0020017E                           380  
0020017E  7E00                     381      MOVE.L #0,D7                    ; address accumulator
00200180                           382  
00200180  13FC 0002 00E00001       383      MOVE.B #2,DISPLAY
00200188                           384  MAIN_LOOP
00200188                           385m     PRINT_CHAR #'>',D3               ; prompt
00200188                           386m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      387m     IFEQ DEBUG
00200188  1639 00C00003            388m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020018E  0803 0002                389m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200192  67F4                     390m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       391m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0020019C                           392m     ENDC
0020019C                           393m     
0020019C                 FALSE     394m     IFNE DEBUG
0020019C                           395m     ENDC
0020019C                           396m 
0020019C                           397m     ENDM
0020019C                           398m     PRINT_CHAR #32,D3                ; space
0020019C                           399m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      400m     IFEQ DEBUG
0020019C  1639 00C00003            401m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001A2  0803 0002                402m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001A6  67F4                     403m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       404m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
002001B0                           405m     ENDC
002001B0                           406m     
002001B0                 FALSE     407m     IFNE DEBUG
002001B0                           408m     ENDC
002001B0                           409m 
002001B0                           410m     ENDM
002001B0                           411      
002001B0                           412  GET_INPUT
002001B0                           413m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
002001B0                           414m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           415m 
002001B0                 TRUE      416m     IFEQ DEBUG
002001B0  1639 00C00003            417m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002001B6  0803 0000                418m       BTST #0,D3                    ; CHECK FOR CHARACTER
002001BA  67F4                     419m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
002001BC                           420m     ENDC
002001BC                           421m     
002001BC                           422mm     READ_CHAR D2
002001BC                 TRUE      423mm     IFEQ DEBUG
002001BC  1439 00C00007            424mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002001C2                           425mm     ENDC
002001C2                 FALSE     426mm     IFNE DEBUG
002001C2                           427mm     ENDC
002001C2                           428mm      
002001C2  B43C 001B                429mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                430mm     BEQ START
002001CA                           431mm     ENDM
002001CA                           432m 
002001CA                 TRUE      433m     IFEQ DEBUG
002001CA                           434mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002001CA                           435mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      436mm     IFEQ DEBUG
002001CA  1639 00C00003            437mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001D0  0803 0002                438mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001D4  67F4                     439mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            440mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002001DC                           441mm     ENDC
002001DC                           442mm     
002001DC                 FALSE     443mm     IFNE DEBUG
002001DC                           444mm     ENDC
002001DC                           445mm 
002001DC                           446mm     ENDM
002001DC                           447m     ENDC
002001DC                           448m     ENDM
002001DC                           449      
002001DC  B43C 0030                450      CMP.B #'0',D2
002001E0  6700 17DE                451      BEQ HEX_DIGIT
002001E4  B43C 0031                452      CMP.B #'1',D2
002001E8  6700 17D6                453      BEQ HEX_DIGIT
002001EC  B43C 0032                454      CMP.B #'2',D2
002001F0  6700 17CE                455      BEQ HEX_DIGIT
002001F4  B43C 0033                456      CMP.B #'3',D2
002001F8  6700 17C6                457      BEQ HEX_DIGIT
002001FC  B43C 0034                458      CMP.B #'4',D2
00200200  6700 17BE                459      BEQ HEX_DIGIT
00200204  B43C 0035                460      CMP.B #'5',D2
00200208  6700 17B6                461      BEQ HEX_DIGIT
0020020C  B43C 0036                462      CMP.B #'6',D2
00200210  6700 17AE                463      BEQ HEX_DIGIT
00200214  B43C 0037                464      CMP.B #'7',D2
00200218  6700 17A6                465      BEQ HEX_DIGIT
0020021C  B43C 0038                466      CMP.B #'8',D2
00200220  6700 179E                467      BEQ HEX_DIGIT
00200224  B43C 0039                468      CMP.B #'9',D2
00200228  6700 1796                469      BEQ HEX_DIGIT
0020022C  B43C 0041                470      CMP.B #'A',D2
00200230  6700 178E                471      BEQ HEX_DIGIT
00200234  B43C 0042                472      CMP.B #'B',D2
00200238  6700 1786                473      BEQ HEX_DIGIT
0020023C  B43C 0043                474      CMP.B #'C',D2
00200240  6700 177E                475      BEQ HEX_DIGIT
00200244  B43C 0044                476      CMP.B #'D',D2
00200248  6700 1776                477      BEQ HEX_DIGIT
0020024C  B43C 0045                478      CMP.B #'E',D2
00200250  6700 176E                479      BEQ HEX_DIGIT
00200254  B43C 0046                480      CMP.B #'F',D2
00200258  6700 1766                481      BEQ HEX_DIGIT
0020025C                           482      
0020025C  B43C 0057                483      CMP.B #'W',D2
00200260  6700 016E                484      BEQ W
00200264                           485      
00200264  B43C 004C                486      CMP.B #'L',D2
00200268  6700 15E0                487      BEQ L 
0020026C                           488  
0020026C                           489m     PRINT_CRLF D3
0020026C                           490mm     PRINT_CHAR #13,D3             ; CR
0020026C                           491mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      492mm     IFEQ DEBUG
0020026C  1639 00C00003            493mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200272  0803 0002                494mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200276  67F4                     495mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       496mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200280                           497mm     ENDC
00200280                           498mm     
00200280                 FALSE     499mm     IFNE DEBUG
00200280                           500mm     ENDC
00200280                           501mm 
00200280                           502mm     ENDM
00200280                           503mm     PRINT_CHAR #10,D3             ; LF
00200280                           504mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      505mm     IFEQ DEBUG
00200280  1639 00C00003            506mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200286  0803 0002                507mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020028A  67F4                     508mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       509mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200294                           510mm     ENDC
00200294                           511mm     
00200294                 FALSE     512mm     IFNE DEBUG
00200294                           513mm     ENDC
00200294                           514mm 
00200294                           515mm     ENDM
00200294                           516m     ENDM
00200294                           517   
00200294  B43C 003F                518      CMP.B #'?',D2
00200298  6700 0056                519      BEQ H
0020029C                           520  
0020029C  B43C 0056                521      CMP.B #'V',D2
002002A0  6700 007A                522      BEQ V
002002A4                           523      
002002A4  B43C 0052                524      CMP.B #'R',D2
002002A8  6700 009E                525      BEQ R
002002AC                           526  
002002AC  B43C 0053                527      CMP.B #'S',D2
002002B0  6700 01E6                528      BEQ S
002002B4                           529  
002002B4  B43C 0047                530      CMP.B #'G',D2
002002B8  6700 147C                531      BEQ G   
002002BC                           532  
002002BC  B43C 005A                533      CMP.B #'Z',D2
002002C0  6700 147C                534      BEQ Z   
002002C4                           535  
002002C4  41F9 00201A96            536      LEA HUH,A0
002002CA                           537m     PRINT_STR A0,D3
002002CA                           538m LOOP_19
002002CA  0C10 0000                539m     CMP.B #0,(A0)                 ; 0 -> DONE
002002CE  6700 001A                540m     BEQ EXIT_19
002002D2                           541mm     PRINT_CHAR (A0)+,D3
002002D2                           542mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      543mm     IFEQ DEBUG
002002D2  1639 00C00003            544mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002002D8  0803 0002                545mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002002DC  67F4                     546mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            547mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002002E4                           548mm     ENDC
002002E4                           549mm     
002002E4                 FALSE     550mm     IFNE DEBUG
002002E4                           551mm     ENDC
002002E4                           552mm 
002002E4                           553mm     ENDM
002002E4  4EF9 002002CA            554m     JMP LOOP_19
002002EA                           555m EXIT_19
002002EA                           556m     ENDM
002002EA                           557                         
002002EA  4EF9 00200188            558      JMP MAIN_LOOP
002002F0                           559      
002002F0                           560  ; commands
002002F0  41F9 002019FF            561  H   LEA HELP,A0
002002F6                           562m     PRINT_STR A0,D3
002002F6                           563m LOOP_21
002002F6  0C10 0000                564m     CMP.B #0,(A0)                 ; 0 -> DONE
002002FA  6700 001A                565m     BEQ EXIT_21
002002FE                           566mm     PRINT_CHAR (A0)+,D3
002002FE                           567mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      568mm     IFEQ DEBUG
002002FE  1639 00C00003            569mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200304  0803 0002                570mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200308  67F4                     571mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            572mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200310                           573mm     ENDC
00200310                           574mm     
00200310                 FALSE     575mm     IFNE DEBUG
00200310                           576mm     ENDC
00200310                           577mm 
00200310                           578mm     ENDM
00200310  4EF9 002002F6            579m     JMP LOOP_21
00200316                           580m EXIT_21
00200316                           581m     ENDM
00200316  4EF9 00200188            582      JMP MAIN_LOOP
0020031C                           583  
0020031C  41F9 002019E2            584  V   LEA VERSION,A0
00200322                           585m     PRINT_STR A0,D3       
00200322                           586m LOOP_23
00200322  0C10 0000                587m     CMP.B #0,(A0)                 ; 0 -> DONE
00200326  6700 001A                588m     BEQ EXIT_23
0020032A                           589mm     PRINT_CHAR (A0)+,D3
0020032A                           590mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      591mm     IFEQ DEBUG
0020032A  1639 00C00003            592mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200330  0803 0002                593mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200334  67F4                     594mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            595mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020033C                           596mm     ENDC
0020033C                           597mm     
0020033C                 FALSE     598mm     IFNE DEBUG
0020033C                           599mm     ENDC
0020033C                           600mm 
0020033C                           601mm     ENDM
0020033C  4EF9 00200322            602m     JMP LOOP_23
00200342                           603m EXIT_23
00200342                           604m     ENDM
00200342  4EF9 00200188            605      JMP MAIN_LOOP
00200348                           606      
00200348                           607  R   
00200348  2047                     608      MOVE.L D7,A0                    ; address accumulator -> address register
0020034A  2A10                     609      MOVE.L (A0),D5                  ; read the memory and print it
0020034C                           610m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           611mm     PRINT_CHAR #'0',D3          ;0X HEADER
0020034C                           612mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      613mm     IFEQ DEBUG
0020034C  1639 00C00003            614mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200352  0803 0002                615mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200356  67F4                     616mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       617mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00200360                           618mm     ENDC
00200360                           619mm     
00200360                 FALSE     620mm     IFNE DEBUG
00200360                           621mm     ENDC
00200360                           622mm 
00200360                           623mm     ENDM
00200360                           624mm     PRINT_CHAR #'x',D3
00200360                           625mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      626mm     IFEQ DEBUG
00200360  1639 00C00003            627mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200366  0803 0002                628mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020036A  67F4                     629mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       630mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00200374                           631mm     ENDC
00200374                           632mm     
00200374                 FALSE     633mm     IFNE DEBUG
00200374                           634mm     ENDC
00200374                           635mm 
00200374                           636mm     ENDM
00200374  7C07                     637m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           638m LOOP_25
00200376                           639mm     BIN2HEX D5,D7,A0
00200376  41F9 00201B33            640mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
0020037C  E99D                     641mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     642mm   MOVE.B D5,D7
00200380  0287 0000000F            643mm   ANDI.L #$F,D7
00200386  1E30 7000                644mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           645mm   ENDM
0020038A                           646mm     PRINT_CHAR D7,D3
0020038A                           647mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      648mm     IFEQ DEBUG
0020038A  1639 00C00003            649mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200390  0803 0002                650mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200394  67F4                     651mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            652mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020039C                           653mm     ENDC
0020039C                           654mm     
0020039C                 FALSE     655mm     IFNE DEBUG
0020039C                           656mm     ENDC
0020039C                           657mm 
0020039C                           658mm     ENDM
0020039C  57CE FFD8                659m     DBEQ D6,LOOP_25
002003A0                           660m     ENDM
002003A0                           661m     PRINT_CRLF D3
002003A0                           662mm     PRINT_CHAR #13,D3             ; CR
002003A0                           663mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      664mm     IFEQ DEBUG
002003A0  1639 00C00003            665mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003A6  0803 0002                666mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003AA  67F4                     667mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       668mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002003B4                           669mm     ENDC
002003B4                           670mm     
002003B4                 FALSE     671mm     IFNE DEBUG
002003B4                           672mm     ENDC
002003B4                           673mm 
002003B4                           674mm     ENDM
002003B4                           675mm     PRINT_CHAR #10,D3             ; LF
002003B4                           676mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      677mm     IFEQ DEBUG
002003B4  1639 00C00003            678mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003BA  0803 0002                679mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003BE  67F4                     680mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       681mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002003C8                           682mm     ENDC
002003C8                           683mm     
002003C8                 FALSE     684mm     IFNE DEBUG
002003C8                           685mm     ENDC
002003C8                           686mm 
002003C8                           687mm     ENDM
002003C8                           688m     ENDM
002003C8  7E00                     689      MOVE.L #0,D7                    ; clear the now used address accumulator
002003CA  4EF9 00200188            690      JMP MAIN_LOOP
002003D0                           691  
002003D0  7A00                     692  W   MOVE.L #0,D5                    ; D5 will be the value to write            
002003D2                           693  
002003D2                           694m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
002003D2                           695m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           696m 
002003D2                 TRUE      697m     IFEQ DEBUG
002003D2  1639 00C00003            698m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002003D8  0803 0000                699m       BTST #0,D3                    ; CHECK FOR CHARACTER
002003DC  67F4                     700m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
002003DE                           701m     ENDC
002003DE                           702m     
002003DE                           703mm     READ_CHAR D2
002003DE                 TRUE      704mm     IFEQ DEBUG
002003DE  1439 00C00007            705mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002003E4                           706mm     ENDC
002003E4                 FALSE     707mm     IFNE DEBUG
002003E4                           708mm     ENDC
002003E4                           709mm      
002003E4  B43C 001B                710mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                711mm     BEQ START
002003EC                           712mm     ENDM
002003EC                           713m 
002003EC                 TRUE      714m     IFEQ DEBUG
002003EC                           715mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002003EC                           716mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      717mm     IFEQ DEBUG
002003EC  1639 00C00003            718mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003F2  0803 0002                719mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003F6  67F4                     720mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            721mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002003FE                           722mm     ENDC
002003FE                           723mm     
002003FE                 FALSE     724mm     IFNE DEBUG
002003FE                           725mm     ENDC
002003FE                           726mm 
002003FE                           727mm     ENDM
002003FE                           728m     ENDC
002003FE                           729m     ENDM
002003FE                           730m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002003FE  41F9 00201B43            731m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200404  0402 0030                732m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            733m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                734m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           735m   ENDM
00200412  1A02                     736      MOVE.B D2,D5                    ; put at bottom of D5
00200414                           737  
00200414  3C3C 0006                738      MOVE #6,D6                      ; 7 bytes left to read
00200418                           739      
00200418                           740  READ_DATA_TO_POKE
00200418  E98D                     741      LSL.L #4,D5                     ; make what we have so far more significant
0020041A                           742m     WAIT_CHAR D2,D3                 ; next character -> D2
0020041A                           743m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           744m 
0020041A                 TRUE      745m     IFEQ DEBUG
0020041A  1639 00C00003            746m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00200420  0803 0000                747m       BTST #0,D3                    ; CHECK FOR CHARACTER
00200424  67F4                     748m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
00200426                           749m     ENDC
00200426                           750m     
00200426                           751mm     READ_CHAR D2
00200426                 TRUE      752mm     IFEQ DEBUG
00200426  1439 00C00007            753mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020042C                           754mm     ENDC
0020042C                 FALSE     755mm     IFNE DEBUG
0020042C                           756mm     ENDC
0020042C                           757mm      
0020042C  B43C 001B                758mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                759mm     BEQ START
00200434                           760mm     ENDM
00200434                           761m 
00200434                 TRUE      762m     IFEQ DEBUG
00200434                           763mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
00200434                           764mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      765mm     IFEQ DEBUG
00200434  1639 00C00003            766mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020043A  0803 0002                767mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020043E  67F4                     768mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            769mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200446                           770mm     ENDC
00200446                           771mm     
00200446                 FALSE     772mm     IFNE DEBUG
00200446                           773mm     ENDC
00200446                           774mm 
00200446                           775mm     ENDM
00200446                           776m     ENDC
00200446                           777m     ENDM
00200446                           778m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00200446  41F9 00201B43            779m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                780m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            781m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                782m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           783m   ENDM
0020045A  8A02                     784      OR.B D2,D5
0020045C  023C 00FB                785      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                786      DBEQ D6,READ_DATA_TO_POKE
00200464                           787      
00200464  2047                     788      MOVE.L D7,A0                    ; address accumulator -> address register
00200466  7E00                     789      MOVE.L #0,D7                    ; clear the now used address accumulator
00200468                           790      
00200468  2085                     791      MOVE.L D5,(A0)                  ; write the data
0020046A                           792  
0020046A                           793m     PRINT_CRLF D3
0020046A                           794mm     PRINT_CHAR #13,D3             ; CR
0020046A                           795mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      796mm     IFEQ DEBUG
0020046A  1639 00C00003            797mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200470  0803 0002                798mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200474  67F4                     799mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       800mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020047E                           801mm     ENDC
0020047E                           802mm     
0020047E                 FALSE     803mm     IFNE DEBUG
0020047E                           804mm     ENDC
0020047E                           805mm 
0020047E                           806mm     ENDM
0020047E                           807mm     PRINT_CHAR #10,D3             ; LF
0020047E                           808mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      809mm     IFEQ DEBUG
0020047E  1639 00C00003            810mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200484  0803 0002                811mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200488  67F4                     812mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       813mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200492                           814mm     ENDC
00200492                           815mm     
00200492                 FALSE     816mm     IFNE DEBUG
00200492                           817mm     ENDC
00200492                           818mm 
00200492                           819mm     ENDM
00200492                           820m     ENDM
00200492  4EF9 00200188            821      JMP MAIN_LOOP
00200498                           822  
00200498                           823          
00200498  2647                     824  S   MOVE.L D7,A3                    ; grab the address accumulator
0020049A  7800                     825      MOVE.L #0,D4                    ; count of records read -> D4
0020049C  2478 0000                826      MOVE.L 0,A2                     ; start address -> A2
002004A0                           827      
002004A0                           828  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
002004A0                           829m     DOWNLOAD D2,D3                  
002004A0                           830m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           831m 
002004A0  1639 00C00003            832m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004A6  0803 0000                833m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004AA  6700 0010                834m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
002004AE                           835m  
002004AE                           836mm     READ_CHAR D2
002004AE                 TRUE      837mm     IFEQ DEBUG
002004AE  1439 00C00007            838mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002004B4                           839mm     ENDC
002004B4                 FALSE     840mm     IFNE DEBUG
002004B4                           841mm     ENDC
002004B4                           842mm      
002004B4  B43C 001B                843mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                844mm     BEQ START
002004BC                           845mm     ENDM
002004BC                           846m CONTINUE_44
002004BC  1639 00C00013            847m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004C2  0803 0000                848m     BTST #0,D3                  ; CHECK FOR CHARACTER
002004C6  67D8                     849m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
002004C8                           850m     
002004C8  1439 00C00017            851m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            852m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002004D4                           853m     
002004D4                           854m     ENDM
002004D4  B43C 0053                855      CMP.B #'S',D2                   ; found S?    
002004D8  66C6                     856      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
002004DA                           857      
002004DA  5284                     858      ADD.L #1,D4                     ; read another S record, increment count
002004DC                           859      
002004DC                           860m     DOWNLOAD D7,D3                  ; read the record digit
002004DC                           861m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DC                           862m 
002004DC  1639 00C00003            863m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004E2  0803 0000                864m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004E6  6700 0010                865m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
002004EA                           866m  
002004EA                           867mm     READ_CHAR D7
002004EA                 TRUE      868mm     IFEQ DEBUG
002004EA  1E39 00C00007            869mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
002004F0                           870mm     ENDC
002004F0                 FALSE     871mm     IFNE DEBUG
002004F0                           872mm     ENDC
002004F0                           873mm      
002004F0  BE3C 001B                874mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
002004F4  6700 FB12                875mm     BEQ START
002004F8                           876mm     ENDM
002004F8                           877m CONTINUE_46
002004F8  1639 00C00013            878m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004FE  0803 0000                879m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200502  67D8                     880m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
00200504                           881m     
00200504  1E39 00C00017            882m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
0020050A  13C7 00E00001            883m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
00200510                           884m     
00200510                           885m     ENDM
00200510                           886  
00200510  7C00                     887      MOVE.L #0,D6                    ; checksum
00200512                           888  
00200512  7A00                     889      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
00200514                           890m     DOWNLOAD D2,D3              
00200514                           891m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                           892m 
00200514  1639 00C00003            893m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020051A  0803 0000                894m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020051E  6700 0010                895m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00200522                           896m  
00200522                           897mm     READ_CHAR D2
00200522                 TRUE      898mm     IFEQ DEBUG
00200522  1439 00C00007            899mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200528                           900mm     ENDC
00200528                 FALSE     901mm     IFNE DEBUG
00200528                           902mm     ENDC
00200528                           903mm      
00200528  B43C 001B                904mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020052C  6700 FADA                905mm     BEQ START
00200530                           906mm     ENDM
00200530                           907m CONTINUE_48
00200530  1639 00C00013            908m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200536  0803 0000                909m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020053A  67D8                     910m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
0020053C                           911m     
0020053C  1439 00C00017            912m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200542  13C2 00E00001            913m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200548                           914m     
00200548                           915m     ENDM
00200548                           916m     HEX2BIN D2,D2,A0
00200548  41F9 00201B43            917m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020054E  0402 0030                918m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200552  C4BC 000000FF            919m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200558  1430 2000                920m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020055C                           921m   ENDM
0020055C  8A82                     922      OR.L D2,D5
0020055E  E98D                     923      LSL.L #4,D5    
00200560                           924m     DOWNLOAD D2,D3
00200560                           925m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200560                           926m 
00200560  1639 00C00003            927m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200566  0803 0000                928m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020056A  6700 0010                929m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
0020056E                           930m  
0020056E                           931mm     READ_CHAR D2
0020056E                 TRUE      932mm     IFEQ DEBUG
0020056E  1439 00C00007            933mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200574                           934mm     ENDC
00200574                 FALSE     935mm     IFNE DEBUG
00200574                           936mm     ENDC
00200574                           937mm      
00200574  B43C 001B                938mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200578  6700 FA8E                939mm     BEQ START
0020057C                           940mm     ENDM
0020057C                           941m CONTINUE_51
0020057C  1639 00C00013            942m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200582  0803 0000                943m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200586  67D8                     944m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
00200588                           945m     
00200588  1439 00C00017            946m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020058E  13C2 00E00001            947m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200594                           948m     
00200594                           949m     ENDM
00200594                           950m     HEX2BIN D2,D2,A0  
00200594  41F9 00201B43            951m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020059A  0402 0030                952m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020059E  C4BC 000000FF            953m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005A4  1430 2000                954m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005A8                           955m   ENDM
002005A8  8A82                     956      OR.L D2,D5
002005AA                           957                  
002005AA  DC85                     958      ADD.L D5,D6                     ; add byte count into checksum
002005AC                           959  
002005AC                           960      IF.B D7 <EQ> #'0' THEN.L        ; header
002005AC  BE3C 0030                961s     CMP.B   #'0',D7
002005B0  6600 022A                962s     BNE.L   _00000000
002005B4  7E00                     963          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
002005B6                           964m         DOWNLOAD D2,D3              ; top byte
002005B6                           965m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B6                           966m 
002005B6  1639 00C00003            967m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002005BC  0803 0000                968m     BTST #0,D3                    ; CHECK FOR CHARACTER
002005C0  6700 0010                969m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
002005C4                           970m  
002005C4                           971mm     READ_CHAR D2
002005C4                 TRUE      972mm     IFEQ DEBUG
002005C4  1439 00C00007            973mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002005CA                           974mm     ENDC
002005CA                 FALSE     975mm     IFNE DEBUG
002005CA                           976mm     ENDC
002005CA                           977mm      
002005CA  B43C 001B                978mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002005CE  6700 FA38                979mm     BEQ START
002005D2                           980mm     ENDM
002005D2                           981m CONTINUE_54
002005D2  1639 00C00013            982m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002005D8  0803 0000                983m     BTST #0,D3                  ; CHECK FOR CHARACTER
002005DC  67D8                     984m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
002005DE                           985m     
002005DE  1439 00C00017            986m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002005E4  13C2 00E00001            987m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002005EA                           988m     
002005EA                           989m     ENDM
002005EA                           990m         HEX2BIN D2,D2,A0
002005EA  41F9 00201B43            991m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002005F0  0402 0030                992m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005F4  C4BC 000000FF            993m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005FA  1430 2000                994m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005FE                           995m   ENDM
002005FE  8E82                     996          OR.L D2,D7
00200600  E98F                     997          LSL.L #4,D7
00200602                           998m         DOWNLOAD D2,D3         
00200602                           999m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200602                          1000m 
00200602  1639 00C00003           1001m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200608  0803 0000               1002m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020060C  6700 0010               1003m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
00200610                          1004m  
00200610                          1005mm     READ_CHAR D2
00200610                 TRUE     1006mm     IFEQ DEBUG
00200610  1439 00C00007           1007mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200616                          1008mm     ENDC
00200616                 FALSE    1009mm     IFNE DEBUG
00200616                          1010mm     ENDC
00200616                          1011mm      
00200616  B43C 001B               1012mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020061A  6700 F9EC               1013mm     BEQ START
0020061E                          1014mm     ENDM
0020061E                          1015m CONTINUE_57
0020061E  1639 00C00013           1016m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200624  0803 0000               1017m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200628  67D8                    1018m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
0020062A                          1019m     
0020062A  1439 00C00017           1020m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200630  13C2 00E00001           1021m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200636                          1022m     
00200636                          1023m     ENDM
00200636                          1024m         HEX2BIN D2,D2,A0
00200636  41F9 00201B43           1025m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020063C  0402 0030               1026m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200640  C4BC 000000FF           1027m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200646  1430 2000               1028m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020064A                          1029m   ENDM
0020064A  8E82                    1030          OR.L D2,D7
0020064C                          1031          
0020064C  DC87                    1032          ADD.L D7,D6                 ; add top byte of address into checksum
0020064E                          1033  
0020064E  E98F                    1034          LSL.L #4,D7                 ; bottom byte
00200650                          1035m         DOWNLOAD D2,D3
00200650                          1036m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200650                          1037m 
00200650  1639 00C00003           1038m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200656  0803 0000               1039m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020065A  6700 0010               1040m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
0020065E                          1041m  
0020065E                          1042mm     READ_CHAR D2
0020065E                 TRUE     1043mm     IFEQ DEBUG
0020065E  1439 00C00007           1044mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200664                          1045mm     ENDC
00200664                 FALSE    1046mm     IFNE DEBUG
00200664                          1047mm     ENDC
00200664                          1048mm      
00200664  B43C 001B               1049mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200668  6700 F99E               1050mm     BEQ START
0020066C                          1051mm     ENDM
0020066C                          1052m CONTINUE_60
0020066C  1639 00C00013           1053m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200672  0803 0000               1054m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200676  67D8                    1055m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
00200678                          1056m     
00200678  1439 00C00017           1057m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020067E  13C2 00E00001           1058m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200684                          1059m     
00200684                          1060m     ENDM
00200684                          1061m         HEX2BIN D2,D2,A0
00200684  41F9 00201B43           1062m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020068A  0402 0030               1063m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020068E  C4BC 000000FF           1064m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200694  1430 2000               1065m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200698                          1066m   ENDM
00200698  8E82                    1067          OR.L D2,D7
0020069A  E98F                    1068          LSL.L #4,D7        
0020069C                          1069m         DOWNLOAD D2,D3
0020069C                          1070m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020069C                          1071m 
0020069C  1639 00C00003           1072m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002006A2  0803 0000               1073m     BTST #0,D3                    ; CHECK FOR CHARACTER
002006A6  6700 0010               1074m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
002006AA                          1075m  
002006AA                          1076mm     READ_CHAR D2
002006AA                 TRUE     1077mm     IFEQ DEBUG
002006AA  1439 00C00007           1078mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002006B0                          1079mm     ENDC
002006B0                 FALSE    1080mm     IFNE DEBUG
002006B0                          1081mm     ENDC
002006B0                          1082mm      
002006B0  B43C 001B               1083mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002006B4  6700 F952               1084mm     BEQ START
002006B8                          1085mm     ENDM
002006B8                          1086m CONTINUE_63
002006B8  1639 00C00013           1087m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002006BE  0803 0000               1088m     BTST #0,D3                  ; CHECK FOR CHARACTER
002006C2  67D8                    1089m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
002006C4                          1090m     
002006C4  1439 00C00017           1091m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002006CA  13C2 00E00001           1092m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002006D0                          1093m     
002006D0                          1094m     ENDM
002006D0                          1095m         HEX2BIN D2,D2,A0
002006D0  41F9 00201B43           1096m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002006D6  0402 0030               1097m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006DA  C4BC 000000FF           1098m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002006E0  1430 2000               1099m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002006E4                          1100m   ENDM
002006E4  8E82                    1101          OR.L D2,D7
002006E6                          1102          
002006E6  7400                    1103          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
002006E8  1407                    1104          MOVE.B D7,D2
002006EA  DC82                    1105          ADD.L D2,D6
002006EC                          1106          
002006EC  5785                    1107          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
002006EE                          1108          WHILE.L D5 <GT> #0 DO       ; read the data bytes
002006EE                          1109s _10000000
002006EE  BABC 00000000           1110s     CMP.L   #0,D5
002006F4  6F00 00B4               1111s     BLE _10000001
002006F8  5385                    1112            SUB.L #1,D5
002006FA                          1113              
002006FA  7E00                    1114            MOVE.L #0,D7              ; D7 holds the byte
002006FC                          1115              
002006FC                          1116m           DOWNLOAD D2,D3            ; MS 4 bits
002006FC                          1117m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006FC                          1118m 
002006FC  1639 00C00003           1119m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200702  0803 0000               1120m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200706  6700 0010               1121m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
0020070A                          1122m  
0020070A                          1123mm     READ_CHAR D2
0020070A                 TRUE     1124mm     IFEQ DEBUG
0020070A  1439 00C00007           1125mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200710                          1126mm     ENDC
00200710                 FALSE    1127mm     IFNE DEBUG
00200710                          1128mm     ENDC
00200710                          1129mm      
00200710  B43C 001B               1130mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200714  6700 F8F2               1131mm     BEQ START
00200718                          1132mm     ENDM
00200718                          1133m CONTINUE_66
00200718  1639 00C00013           1134m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020071E  0803 0000               1135m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200722  67D8                    1136m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
00200724                          1137m     
00200724  1439 00C00017           1138m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020072A  13C2 00E00001           1139m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200730                          1140m     
00200730                          1141m     ENDM
00200730                          1142m           HEX2BIN D2,D2,A0
00200730  41F9 00201B43           1143m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200736  0402 0030               1144m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020073A  C4BC 000000FF           1145m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200740  1430 2000               1146m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200744                          1147m   ENDM
00200744  8E82                    1148            OR.L D2,D7
00200746  E98F                    1149            LSL.L #4,D7
00200748                          1150               
00200748                          1151m           DOWNLOAD D2,D3            ; LS 4 bits    
00200748                          1152m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200748                          1153m 
00200748  1639 00C00003           1154m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020074E  0803 0000               1155m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200752  6700 0010               1156m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
00200756                          1157m  
00200756                          1158mm     READ_CHAR D2
00200756                 TRUE     1159mm     IFEQ DEBUG
00200756  1439 00C00007           1160mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020075C                          1161mm     ENDC
0020075C                 FALSE    1162mm     IFNE DEBUG
0020075C                          1163mm     ENDC
0020075C                          1164mm      
0020075C  B43C 001B               1165mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200760  6700 F8A6               1166mm     BEQ START
00200764                          1167mm     ENDM
00200764                          1168m CONTINUE_69
00200764  1639 00C00013           1169m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020076A  0803 0000               1170m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020076E  67D8                    1171m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00200770                          1172m     
00200770  1439 00C00017           1173m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200776  13C2 00E00001           1174m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020077C                          1175m     
0020077C                          1176m     ENDM
0020077C                          1177m           HEX2BIN D2,D2,A0
0020077C  41F9 00201B43           1178m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200782  0402 0030               1179m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200786  C4BC 000000FF           1180m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020078C  1430 2000               1181m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200790                          1182m   ENDM
00200790  8E82                    1183            OR.L D2,D7
00200792                          1184              
00200792  DC87                    1185            ADD.L D7,D6               ; add into checksum
00200794                          1186            
00200794                          1187m           PRINT_CHAR D7,D3          ; assume ASCII and print it
00200794                          1188m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200794                 TRUE     1189m     IFEQ DEBUG
00200794  1639 00C00003           1190m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020079A  0803 0002               1191m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020079E  67F4                    1192m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
002007A0  13C7 00C00007           1193m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002007A6                          1194m     ENDC
002007A6                          1195m     
002007A6                 FALSE    1196m     IFNE DEBUG
002007A6                          1197m     ENDC
002007A6                          1198m 
002007A6                          1199m     ENDM
002007A6                          1200          ENDW
002007A6  6000 FF46               1201s     BRA _10000000
002007AA                          1202s _10000001
002007AA                          1203m         PRINT_CRLF D3
002007AA                          1204mm     PRINT_CHAR #13,D3             ; CR
002007AA                          1205mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007AA                 TRUE     1206mm     IFEQ DEBUG
002007AA  1639 00C00003           1207mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007B0  0803 0002               1208mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007B4  67F4                    1209mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
002007B6  13FC 000D 00C00007      1210mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002007BE                          1211mm     ENDC
002007BE                          1212mm     
002007BE                 FALSE    1213mm     IFNE DEBUG
002007BE                          1214mm     ENDC
002007BE                          1215mm 
002007BE                          1216mm     ENDM
002007BE                          1217mm     PRINT_CHAR #10,D3             ; LF
002007BE                          1218mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007BE                 TRUE     1219mm     IFEQ DEBUG
002007BE  1639 00C00003           1220mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007C4  0803 0002               1221mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007C8  67F4                    1222mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
002007CA  13FC 000A 00C00007      1223mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002007D2                          1224mm     ENDC
002007D2                          1225mm     
002007D2                 FALSE    1226mm     IFNE DEBUG
002007D2                          1227mm     ENDC
002007D2                          1228mm 
002007D2                          1229mm     ENDM
002007D2                          1230m     ENDM
002007D2  43F9 002004A0           1231         LEA WAIT_FOR_SRECORD,A1            
002007D8                          1232      ELSE
002007D8  6000 0D0E               1233s     BRA _00000001
002007DC                          1234s _00000000
002007DC                          1235        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
002007DC  BE3C 0031               1236s     CMP.B   #'1',D7
002007E0  6600 04F6               1237s     BNE.L   _00000002
002007E4  7E00                    1238          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007E6                          1239m         DOWNLOAD D2,D3              ; top byte
002007E6                          1240m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007E6                          1241m 
002007E6  1639 00C00003           1242m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002007EC  0803 0000               1243m     BTST #0,D3                    ; CHECK FOR CHARACTER
002007F0  6700 0010               1244m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
002007F4                          1245m  
002007F4                          1246mm     READ_CHAR D2
002007F4                 TRUE     1247mm     IFEQ DEBUG
002007F4  1439 00C00007           1248mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002007FA                          1249mm     ENDC
002007FA                 FALSE    1250mm     IFNE DEBUG
002007FA                          1251mm     ENDC
002007FA                          1252mm      
002007FA  B43C 001B               1253mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002007FE  6700 F808               1254mm     BEQ START
00200802                          1255mm     ENDM
00200802                          1256m CONTINUE_76
00200802  1639 00C00013           1257m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200808  0803 0000               1258m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020080C  67D8                    1259m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
0020080E                          1260m     
0020080E  1439 00C00017           1261m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200814  13C2 00E00001           1262m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020081A                          1263m     
0020081A                          1264m     ENDM
0020081A                          1265m         PRINT_CHAR D2,D3
0020081A                          1266m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020081A                 TRUE     1267m     IFEQ DEBUG
0020081A  1639 00C00003           1268m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200820  0803 0002               1269m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200824  67F4                    1270m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
00200826  13C2 00C00007           1271m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020082C                          1272m     ENDC
0020082C                          1273m     
0020082C                 FALSE    1274m     IFNE DEBUG
0020082C                          1275m     ENDC
0020082C                          1276m 
0020082C                          1277m     ENDM
0020082C                          1278m         HEX2BIN D2,D2,A0
0020082C  41F9 00201B43           1279m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200832  0402 0030               1280m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200836  C4BC 000000FF           1281m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020083C  1430 2000               1282m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200840                          1283m   ENDM
00200840  8E82                    1284          OR.L D2,D7
00200842  E98F                    1285          LSL.L #4,D7
00200844                          1286m         DOWNLOAD D2,D3         
00200844                          1287m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200844                          1288m 
00200844  1639 00C00003           1289m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020084A  0803 0000               1290m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020084E  6700 0010               1291m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00200852                          1292m  
00200852                          1293mm     READ_CHAR D2
00200852                 TRUE     1294mm     IFEQ DEBUG
00200852  1439 00C00007           1295mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200858                          1296mm     ENDC
00200858                 FALSE    1297mm     IFNE DEBUG
00200858                          1298mm     ENDC
00200858                          1299mm      
00200858  B43C 001B               1300mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020085C  6700 F7AA               1301mm     BEQ START
00200860                          1302mm     ENDM
00200860                          1303m CONTINUE_80
00200860  1639 00C00013           1304m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200866  0803 0000               1305m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020086A  67D8                    1306m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
0020086C                          1307m     
0020086C  1439 00C00017           1308m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200872  13C2 00E00001           1309m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200878                          1310m     
00200878                          1311m     ENDM
00200878                          1312m         PRINT_CHAR D2,D3
00200878                          1313m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1314m     IFEQ DEBUG
00200878  1639 00C00003           1315m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020087E  0803 0002               1316m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200882  67F4                    1317m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00200884  13C2 00C00007           1318m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020088A                          1319m     ENDC
0020088A                          1320m     
0020088A                 FALSE    1321m     IFNE DEBUG
0020088A                          1322m     ENDC
0020088A                          1323m 
0020088A                          1324m     ENDM
0020088A                          1325m         HEX2BIN D2,D2,A0
0020088A  41F9 00201B43           1326m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200890  0402 0030               1327m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200894  C4BC 000000FF           1328m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020089A  1430 2000               1329m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020089E                          1330m   ENDM
0020089E  8E82                    1331          OR.L D2,D7
002008A0                          1332          
002008A0  DC87                    1333          ADD.L D7,D6                 ; add top byte of address into checksum
002008A2                          1334  
002008A2  E98F                    1335          LSL.L #4,D7                 ; bottom byte
002008A4                          1336m         DOWNLOAD D2,D3
002008A4                          1337m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A4                          1338m 
002008A4  1639 00C00003           1339m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002008AA  0803 0000               1340m     BTST #0,D3                    ; CHECK FOR CHARACTER
002008AE  6700 0010               1341m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
002008B2                          1342m  
002008B2                          1343mm     READ_CHAR D2
002008B2                 TRUE     1344mm     IFEQ DEBUG
002008B2  1439 00C00007           1345mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002008B8                          1346mm     ENDC
002008B8                 FALSE    1347mm     IFNE DEBUG
002008B8                          1348mm     ENDC
002008B8                          1349mm      
002008B8  B43C 001B               1350mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002008BC  6700 F74A               1351mm     BEQ START
002008C0                          1352mm     ENDM
002008C0                          1353m CONTINUE_84
002008C0  1639 00C00013           1354m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002008C6  0803 0000               1355m     BTST #0,D3                  ; CHECK FOR CHARACTER
002008CA  67D8                    1356m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
002008CC                          1357m     
002008CC  1439 00C00017           1358m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002008D2  13C2 00E00001           1359m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002008D8                          1360m     
002008D8                          1361m     ENDM
002008D8                          1362m         PRINT_CHAR D2,D3
002008D8                          1363m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1364m     IFEQ DEBUG
002008D8  1639 00C00003           1365m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002008DE  0803 0002               1366m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1367m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
002008E4  13C2 00C00007           1368m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002008EA                          1369m     ENDC
002008EA                          1370m     
002008EA                 FALSE    1371m     IFNE DEBUG
002008EA                          1372m     ENDC
002008EA                          1373m 
002008EA                          1374m     ENDM
002008EA                          1375m         HEX2BIN D2,D2,A0
002008EA  41F9 00201B43           1376m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002008F0  0402 0030               1377m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F4  C4BC 000000FF           1378m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002008FA  1430 2000               1379m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002008FE                          1380m   ENDM
002008FE  8E82                    1381          OR.L D2,D7
00200900  E98F                    1382          LSL.L #4,D7        
00200902                          1383m         DOWNLOAD D2,D3
00200902                          1384m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200902                          1385m 
00200902  1639 00C00003           1386m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200908  0803 0000               1387m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020090C  6700 0010               1388m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
00200910                          1389m  
00200910                          1390mm     READ_CHAR D2
00200910                 TRUE     1391mm     IFEQ DEBUG
00200910  1439 00C00007           1392mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200916                          1393mm     ENDC
00200916                 FALSE    1394mm     IFNE DEBUG
00200916                          1395mm     ENDC
00200916                          1396mm      
00200916  B43C 001B               1397mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020091A  6700 F6EC               1398mm     BEQ START
0020091E                          1399mm     ENDM
0020091E                          1400m CONTINUE_88
0020091E  1639 00C00013           1401m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200924  0803 0000               1402m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200928  67D8                    1403m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
0020092A                          1404m     
0020092A  1439 00C00017           1405m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200930  13C2 00E00001           1406m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200936                          1407m     
00200936                          1408m     ENDM
00200936                          1409m         PRINT_CHAR D2,D3
00200936                          1410m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200936                 TRUE     1411m     IFEQ DEBUG
00200936  1639 00C00003           1412m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020093C  0803 0002               1413m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200940  67F4                    1414m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00200942  13C2 00C00007           1415m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200948                          1416m     ENDC
00200948                          1417m     
00200948                 FALSE    1418m     IFNE DEBUG
00200948                          1419m     ENDC
00200948                          1420m 
00200948                          1421m     ENDM
00200948                          1422m         HEX2BIN D2,D2,A0
00200948  41F9 00201B43           1423m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020094E  0402 0030               1424m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200952  C4BC 000000FF           1425m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200958  1430 2000               1426m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020095C                          1427m   ENDM
0020095C  8E82                    1428          OR.L D2,D7
0020095E                          1429          
0020095E  7400                    1430          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200960  1407                    1431          MOVE.B D7,D2
00200962  DC82                    1432          ADD.L D2,D6
00200964                          1433          
00200964  DE8B                    1434          ADD.L A3,D7                 ; add in the offset
00200966                          1435          
00200966  5785                    1436          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
00200968                          1437          
00200968  0807 0000               1438          BTST #0,D7                  ; deal with odd addresses
0020096C                          1439  
0020096C  2247                    1440          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
0020096E  6700 00D0               1441          BEQ EVEN
00200972                          1442                  
00200972  5385                    1443          SUB.L #1,D5
00200974  5389                    1444          SUB.L #1,A1
00200976                          1445          
00200976  7E00                    1446          MOVE.L #0,D7
00200978                          1447m         DOWNLOAD D2,D3            ; MS 4 bits
00200978                          1448m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200978                          1449m 
00200978  1639 00C00003           1450m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020097E  0803 0000               1451m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200982  6700 0010               1452m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
00200986                          1453m  
00200986                          1454mm     READ_CHAR D2
00200986                 TRUE     1455mm     IFEQ DEBUG
00200986  1439 00C00007           1456mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020098C                          1457mm     ENDC
0020098C                 FALSE    1458mm     IFNE DEBUG
0020098C                          1459mm     ENDC
0020098C                          1460mm      
0020098C  B43C 001B               1461mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200990  6700 F676               1462mm     BEQ START
00200994                          1463mm     ENDM
00200994                          1464m CONTINUE_92
00200994  1639 00C00013           1465m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020099A  0803 0000               1466m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020099E  67D8                    1467m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
002009A0                          1468m     
002009A0  1439 00C00017           1469m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002009A6  13C2 00E00001           1470m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002009AC                          1471m     
002009AC                          1472m     ENDM
002009AC                          1473m         PRINT_CHAR D2,D3
002009AC                          1474m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009AC                 TRUE     1475m     IFEQ DEBUG
002009AC  1639 00C00003           1476m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002009B2  0803 0002               1477m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002009B6  67F4                    1478m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
002009B8  13C2 00C00007           1479m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002009BE                          1480m     ENDC
002009BE                          1481m     
002009BE                 FALSE    1482m     IFNE DEBUG
002009BE                          1483m     ENDC
002009BE                          1484m 
002009BE                          1485m     ENDM
002009BE                          1486m         HEX2BIN D2,D2,A0
002009BE  41F9 00201B43           1487m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002009C4  0402 0030               1488m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009C8  C4BC 000000FF           1489m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002009CE  1430 2000               1490m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002009D2                          1491m   ENDM
002009D2  8E82                    1492          OR.L D2,D7
002009D4  E98F                    1493          LSL.L #4,D7
002009D6                          1494               
002009D6                          1495m         DOWNLOAD D2,D3            ; LS 4 bits    
002009D6                          1496m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                          1497m 
002009D6  1639 00C00003           1498m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002009DC  0803 0000               1499m     BTST #0,D3                    ; CHECK FOR CHARACTER
002009E0  6700 0010               1500m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
002009E4                          1501m  
002009E4                          1502mm     READ_CHAR D2
002009E4                 TRUE     1503mm     IFEQ DEBUG
002009E4  1439 00C00007           1504mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002009EA                          1505mm     ENDC
002009EA                 FALSE    1506mm     IFNE DEBUG
002009EA                          1507mm     ENDC
002009EA                          1508mm      
002009EA  B43C 001B               1509mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002009EE  6700 F618               1510mm     BEQ START
002009F2                          1511mm     ENDM
002009F2                          1512m CONTINUE_96
002009F2  1639 00C00013           1513m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002009F8  0803 0000               1514m     BTST #0,D3                  ; CHECK FOR CHARACTER
002009FC  67D8                    1515m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
002009FE                          1516m     
002009FE  1439 00C00017           1517m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A04  13C2 00E00001           1518m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A0A                          1519m     
00200A0A                          1520m     ENDM
00200A0A                          1521m         PRINT_CHAR D2,D3
00200A0A                          1522m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A0A                 TRUE     1523m     IFEQ DEBUG
00200A0A  1639 00C00003           1524m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A10  0803 0002               1525m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A14  67F4                    1526m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
00200A16  13C2 00C00007           1527m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A1C                          1528m     ENDC
00200A1C                          1529m     
00200A1C                 FALSE    1530m     IFNE DEBUG
00200A1C                          1531m     ENDC
00200A1C                          1532m 
00200A1C                          1533m     ENDM
00200A1C                          1534m         HEX2BIN D2,D2,A0
00200A1C  41F9 00201B43           1535m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A22  0402 0030               1536m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A26  C4BC 000000FF           1537m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200A2C  1430 2000               1538m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200A30                          1539m   ENDM
00200A30  8E82                    1540          OR.L D2,D7
00200A32                          1541                          
00200A32  DC87                    1542          ADD.L D7,D6               ; add into checksum
00200A34                          1543                        
00200A34  3611                    1544          MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200A36                          1545          
00200A36  0243 FF00               1546          ANDI.W #$FF00,D3
00200A3A  8647                    1547          OR.W D7,D3
00200A3C                          1548          
00200A3C  3283                    1549          MOVE.W D3,(A1)           ; store it!
00200A3E  5489                    1550          ADD.L #2,A1
00200A40                          1551  EVEN        
00200A40                          1552          WHILE.L D5 <GE> #2 DO       ; read the data bytes
00200A40                          1553s _10000002
00200A40  BABC 00000002           1554s     CMP.L   #2,D5
00200A46  6D00 018A               1555s     BLT _10000003
00200A4A  5585                    1556              SUB.L #2,D5
00200A4C  7E00                    1557              MOVE.L #0,D7              ; D7 holds the word
00200A4E                          1558              
00200A4E                          1559m             DOWNLOAD D2,D3            ; MS 4 bits
00200A4E                          1560m WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4E                          1561m 
00200A4E  1639 00C00003           1562m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200A54  0803 0000               1563m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200A58  6700 0010               1564m     BEQ CONTINUE_100                ; NOTHING, CONTINUE
00200A5C                          1565m  
00200A5C                          1566mm     READ_CHAR D2
00200A5C                 TRUE     1567mm     IFEQ DEBUG
00200A5C  1439 00C00007           1568mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200A62                          1569mm     ENDC
00200A62                 FALSE    1570mm     IFNE DEBUG
00200A62                          1571mm     ENDC
00200A62                          1572mm      
00200A62  B43C 001B               1573mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200A66  6700 F5A0               1574mm     BEQ START
00200A6A                          1575mm     ENDM
00200A6A                          1576m CONTINUE_100
00200A6A  1639 00C00013           1577m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200A70  0803 0000               1578m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200A74  67D8                    1579m     BEQ WAIT_FOR_READY_100        ; NOTHING, CHECK AGAIN
00200A76                          1580m     
00200A76  1439 00C00017           1581m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A7C  13C2 00E00001           1582m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A82                          1583m     
00200A82                          1584m     ENDM
00200A82                          1585m             PRINT_CHAR D2,D3
00200A82                          1586m WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A82                 TRUE     1587m     IFEQ DEBUG
00200A82  1639 00C00003           1588m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A88  0803 0002               1589m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A8C  67F4                    1590m       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00200A8E  13C2 00C00007           1591m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A94                          1592m     ENDC
00200A94                          1593m     
00200A94                 FALSE    1594m     IFNE DEBUG
00200A94                          1595m     ENDC
00200A94                          1596m 
00200A94                          1597m     ENDM
00200A94                          1598m             HEX2BIN D2,D2,A0
00200A94  41F9 00201B43           1599m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A9A  0402 0030               1600m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A9E  C4BC 000000FF           1601m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200AA4  1430 2000               1602m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200AA8                          1603m   ENDM
00200AA8  8E82                    1604              OR.L D2,D7
00200AAA  E98F                    1605              LSL.L #4,D7
00200AAC                          1606               
00200AAC                          1607m             DOWNLOAD D2,D3            ; LS 4 bits    
00200AAC                          1608m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAC                          1609m 
00200AAC  1639 00C00003           1610m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200AB2  0803 0000               1611m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200AB6  6700 0010               1612m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00200ABA                          1613m  
00200ABA                          1614mm     READ_CHAR D2
00200ABA                 TRUE     1615mm     IFEQ DEBUG
00200ABA  1439 00C00007           1616mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200AC0                          1617mm     ENDC
00200AC0                 FALSE    1618mm     IFNE DEBUG
00200AC0                          1619mm     ENDC
00200AC0                          1620mm      
00200AC0  B43C 001B               1621mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200AC4  6700 F542               1622mm     BEQ START
00200AC8                          1623mm     ENDM
00200AC8                          1624m CONTINUE_104
00200AC8  1639 00C00013           1625m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200ACE  0803 0000               1626m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200AD2  67D8                    1627m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00200AD4                          1628m     
00200AD4  1439 00C00017           1629m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200ADA  13C2 00E00001           1630m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200AE0                          1631m     
00200AE0                          1632m     ENDM
00200AE0                          1633m             PRINT_CHAR D2,D3
00200AE0                          1634m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1635m     IFEQ DEBUG
00200AE0  1639 00C00003           1636m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200AE6  0803 0002               1637m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1638m       BEQ WAIT_FOR_READY_106          ; NO SPACE, CHECK AGAIN
00200AEC  13C2 00C00007           1639m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200AF2                          1640m     ENDC
00200AF2                          1641m     
00200AF2                 FALSE    1642m     IFNE DEBUG
00200AF2                          1643m     ENDC
00200AF2                          1644m 
00200AF2                          1645m     ENDM
00200AF2                          1646m             HEX2BIN D2,D2,A0
00200AF2  41F9 00201B43           1647m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200AF8  0402 0030               1648m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AFC  C4BC 000000FF           1649m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B02  1430 2000               1650m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B06                          1651m   ENDM
00200B06  8E82                    1652              OR.L D2,D7
00200B08                          1653                          
00200B08  DC87                    1654              ADD.L D7,D6               ; add into checksum
00200B0A                          1655              
00200B0A  E98F                    1656              LSL.L #4,D7
00200B0C                          1657m             DOWNLOAD D2,D3            ; MS 4 bits
00200B0C                          1658m WAIT_FOR_READY_108                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0C                          1659m 
00200B0C  1639 00C00003           1660m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B12  0803 0000               1661m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B16  6700 0010               1662m     BEQ CONTINUE_108                ; NOTHING, CONTINUE
00200B1A                          1663m  
00200B1A                          1664mm     READ_CHAR D2
00200B1A                 TRUE     1665mm     IFEQ DEBUG
00200B1A  1439 00C00007           1666mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B20                          1667mm     ENDC
00200B20                 FALSE    1668mm     IFNE DEBUG
00200B20                          1669mm     ENDC
00200B20                          1670mm      
00200B20  B43C 001B               1671mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B24  6700 F4E2               1672mm     BEQ START
00200B28                          1673mm     ENDM
00200B28                          1674m CONTINUE_108
00200B28  1639 00C00013           1675m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B2E  0803 0000               1676m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B32  67D8                    1677m     BEQ WAIT_FOR_READY_108        ; NOTHING, CHECK AGAIN
00200B34                          1678m     
00200B34  1439 00C00017           1679m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B3A  13C2 00E00001           1680m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B40                          1681m     
00200B40                          1682m     ENDM
00200B40                          1683m             PRINT_CHAR D2,D3
00200B40                          1684m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B40                 TRUE     1685m     IFEQ DEBUG
00200B40  1639 00C00003           1686m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200B46  0803 0002               1687m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200B4A  67F4                    1688m       BEQ WAIT_FOR_READY_110          ; NO SPACE, CHECK AGAIN
00200B4C  13C2 00C00007           1689m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200B52                          1690m     ENDC
00200B52                          1691m     
00200B52                 FALSE    1692m     IFNE DEBUG
00200B52                          1693m     ENDC
00200B52                          1694m 
00200B52                          1695m     ENDM
00200B52                          1696m             HEX2BIN D2,D2,A0
00200B52  41F9 00201B43           1697m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B58  0402 0030               1698m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B5C  C4BC 000000FF           1699m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B62  1430 2000               1700m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B66                          1701m   ENDM
00200B66  8E82                    1702              OR.L D2,D7
00200B68                          1703               
00200B68  E98F                    1704              LSL.L #4,D7
00200B6A                          1705m             DOWNLOAD D2,D3            ; LS 4 bits    
00200B6A                          1706m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B6A                          1707m 
00200B6A  1639 00C00003           1708m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B70  0803 0000               1709m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B74  6700 0010               1710m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00200B78                          1711m  
00200B78                          1712mm     READ_CHAR D2
00200B78                 TRUE     1713mm     IFEQ DEBUG
00200B78  1439 00C00007           1714mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B7E                          1715mm     ENDC
00200B7E                 FALSE    1716mm     IFNE DEBUG
00200B7E                          1717mm     ENDC
00200B7E                          1718mm      
00200B7E  B43C 001B               1719mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B82  6700 F484               1720mm     BEQ START
00200B86                          1721mm     ENDM
00200B86                          1722m CONTINUE_112
00200B86  1639 00C00013           1723m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B8C  0803 0000               1724m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B90  67D8                    1725m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00200B92                          1726m     
00200B92  1439 00C00017           1727m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B98  13C2 00E00001           1728m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B9E                          1729m     
00200B9E                          1730m     ENDM
00200B9E                          1731m             PRINT_CHAR D2,D3
00200B9E                          1732m WAIT_FOR_READY_114                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B9E                 TRUE     1733m     IFEQ DEBUG
00200B9E  1639 00C00003           1734m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200BA4  0803 0002               1735m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200BA8  67F4                    1736m       BEQ WAIT_FOR_READY_114          ; NO SPACE, CHECK AGAIN
00200BAA  13C2 00C00007           1737m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200BB0                          1738m     ENDC
00200BB0                          1739m     
00200BB0                 FALSE    1740m     IFNE DEBUG
00200BB0                          1741m     ENDC
00200BB0                          1742m 
00200BB0                          1743m     ENDM
00200BB0                          1744m             HEX2BIN D2,D2,A0
00200BB0  41F9 00201B43           1745m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200BB6  0402 0030               1746m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BBA  C4BC 000000FF           1747m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200BC0  1430 2000               1748m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200BC4                          1749m   ENDM
00200BC4  8E82                    1750              OR.L D2,D7
00200BC6                          1751              
00200BC6  7400                    1752              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00200BC8  1407                    1753              MOVE.B D7,D2
00200BCA  DC82                    1754              ADD.L D2,D6
00200BCC                          1755              
00200BCC  32C7                    1756              MOVE.W D7,(A1)+          ; store it!
00200BCE                          1757          ENDW
00200BCE  6000 FE70               1758s     BRA _10000002
00200BD2                          1759s _10000003
00200BD2                          1760          
00200BD2                          1761          IF D5 <EQ> #1 THEN
00200BD2  BA7C 0001               1762s     CMP.W   #1,D5
00200BD6  6600 00CE               1763s     BNE _00000003
00200BDA  7E00                    1764              MOVE.L #0,D7              ; D7 holds the word
00200BDC                          1765                      
00200BDC                          1766m             DOWNLOAD D2,D3            ; MS 4 bits
00200BDC                          1767m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BDC                          1768m 
00200BDC  1639 00C00003           1769m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200BE2  0803 0000               1770m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200BE6  6700 0010               1771m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00200BEA                          1772m  
00200BEA                          1773mm     READ_CHAR D2
00200BEA                 TRUE     1774mm     IFEQ DEBUG
00200BEA  1439 00C00007           1775mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200BF0                          1776mm     ENDC
00200BF0                 FALSE    1777mm     IFNE DEBUG
00200BF0                          1778mm     ENDC
00200BF0                          1779mm      
00200BF0  B43C 001B               1780mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200BF4  6700 F412               1781mm     BEQ START
00200BF8                          1782mm     ENDM
00200BF8                          1783m CONTINUE_116
00200BF8  1639 00C00013           1784m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200BFE  0803 0000               1785m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C02  67D8                    1786m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00200C04                          1787m     
00200C04  1439 00C00017           1788m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C0A  13C2 00E00001           1789m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C10                          1790m     
00200C10                          1791m     ENDM
00200C10                          1792m             PRINT_CHAR D2,D3
00200C10                          1793m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C10                 TRUE     1794m     IFEQ DEBUG
00200C10  1639 00C00003           1795m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C16  0803 0002               1796m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C1A  67F4                    1797m       BEQ WAIT_FOR_READY_118          ; NO SPACE, CHECK AGAIN
00200C1C  13C2 00C00007           1798m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C22                          1799m     ENDC
00200C22                          1800m     
00200C22                 FALSE    1801m     IFNE DEBUG
00200C22                          1802m     ENDC
00200C22                          1803m 
00200C22                          1804m     ENDM
00200C22                          1805m             HEX2BIN D2,D2,A0
00200C22  41F9 00201B43           1806m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C28  0402 0030               1807m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C2C  C4BC 000000FF           1808m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C32  1430 2000               1809m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C36                          1810m   ENDM
00200C36  8E82                    1811              OR.L D2,D7
00200C38  E98F                    1812              LSL.L #4,D7
00200C3A                          1813               
00200C3A                          1814m             DOWNLOAD D2,D3            ; LS 4 bits    
00200C3A                          1815m WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C3A                          1816m 
00200C3A  1639 00C00003           1817m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200C40  0803 0000               1818m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200C44  6700 0010               1819m     BEQ CONTINUE_120                ; NOTHING, CONTINUE
00200C48                          1820m  
00200C48                          1821mm     READ_CHAR D2
00200C48                 TRUE     1822mm     IFEQ DEBUG
00200C48  1439 00C00007           1823mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200C4E                          1824mm     ENDC
00200C4E                 FALSE    1825mm     IFNE DEBUG
00200C4E                          1826mm     ENDC
00200C4E                          1827mm      
00200C4E  B43C 001B               1828mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200C52  6700 F3B4               1829mm     BEQ START
00200C56                          1830mm     ENDM
00200C56                          1831m CONTINUE_120
00200C56  1639 00C00013           1832m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C5C  0803 0000               1833m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C60  67D8                    1834m     BEQ WAIT_FOR_READY_120        ; NOTHING, CHECK AGAIN
00200C62                          1835m     
00200C62  1439 00C00017           1836m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C68  13C2 00E00001           1837m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C6E                          1838m     
00200C6E                          1839m     ENDM
00200C6E                          1840m             PRINT_CHAR D2,D3
00200C6E                          1841m WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6E                 TRUE     1842m     IFEQ DEBUG
00200C6E  1639 00C00003           1843m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C74  0803 0002               1844m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C78  67F4                    1845m       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00200C7A  13C2 00C00007           1846m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C80                          1847m     ENDC
00200C80                          1848m     
00200C80                 FALSE    1849m     IFNE DEBUG
00200C80                          1850m     ENDC
00200C80                          1851m 
00200C80                          1852m     ENDM
00200C80                          1853m             HEX2BIN D2,D2,A0
00200C80  41F9 00201B43           1854m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C86  0402 0030               1855m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C8A  C4BC 000000FF           1856m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C90  1430 2000               1857m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C94                          1858m   ENDM
00200C94  8E82                    1859              OR.L D2,D7
00200C96                          1860                          
00200C96  DC87                    1861              ADD.L D7,D6               ; add into checksum
00200C98                          1862              
00200C98  3611                    1863              MOVE.W (A1),D3            ; get the current data and replace the top byte
00200C9A  E18F                    1864              LSL.L #8,D7
00200C9C  C6BC 000000FF           1865              AND.L #$00FF,D3
00200CA2  8687                    1866              OR.L D7,D3
00200CA4                          1867  
00200CA4  32C3                    1868              MOVE.W D3,(A1)+          ; store it!
00200CA6                          1869          ENDI
00200CA6                          1870s _00000003
00200CA6                          1871    
00200CA6                          1872m         PRINT_CRLF D3
00200CA6                          1873mm     PRINT_CHAR #13,D3             ; CR
00200CA6                          1874mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CA6                 TRUE     1875mm     IFEQ DEBUG
00200CA6  1639 00C00003           1876mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CAC  0803 0002               1877mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CB0  67F4                    1878mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00200CB2  13FC 000D 00C00007      1879mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CBA                          1880mm     ENDC
00200CBA                          1881mm     
00200CBA                 FALSE    1882mm     IFNE DEBUG
00200CBA                          1883mm     ENDC
00200CBA                          1884mm 
00200CBA                          1885mm     ENDM
00200CBA                          1886mm     PRINT_CHAR #10,D3             ; LF
00200CBA                          1887mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBA                 TRUE     1888mm     IFEQ DEBUG
00200CBA  1639 00C00003           1889mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CC0  0803 0002               1890mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CC4  67F4                    1891mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00200CC6  13FC 000A 00C00007      1892mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CCE                          1893mm     ENDC
00200CCE                          1894mm     
00200CCE                 FALSE    1895mm     IFNE DEBUG
00200CCE                          1896mm     ENDC
00200CCE                          1897mm 
00200CCE                          1898mm     ENDM
00200CCE                          1899m     ENDM
00200CCE  43F9 002004A0           1900          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00200CD4                          1901        ELSE
00200CD4  6000 0812               1902s     BRA _00000004
00200CD8                          1903s _00000002
00200CD8                          1904          IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00200CD8  BE3C 0032               1905s     CMP.B   #'2',D7
00200CDC  6600 05BA               1906s     BNE.L   _00000005
00200CE0  7E00                    1907            MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200CE2                          1908m           DOWNLOAD D2,D3              ; top byte
00200CE2                          1909m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE2                          1910m 
00200CE2  1639 00C00003           1911m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200CE8  0803 0000               1912m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200CEC  6700 0010               1913m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00200CF0                          1914m  
00200CF0                          1915mm     READ_CHAR D2
00200CF0                 TRUE     1916mm     IFEQ DEBUG
00200CF0  1439 00C00007           1917mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200CF6                          1918mm     ENDC
00200CF6                 FALSE    1919mm     IFNE DEBUG
00200CF6                          1920mm     ENDC
00200CF6                          1921mm      
00200CF6  B43C 001B               1922mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200CFA  6700 F30C               1923mm     BEQ START
00200CFE                          1924mm     ENDM
00200CFE                          1925m CONTINUE_127
00200CFE  1639 00C00013           1926m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D04  0803 0000               1927m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D08  67D8                    1928m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00200D0A                          1929m     
00200D0A  1439 00C00017           1930m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D10  13C2 00E00001           1931m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D16                          1932m     
00200D16                          1933m     ENDM
00200D16                          1934m           PRINT_CHAR D2,D3
00200D16                          1935m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D16                 TRUE     1936m     IFEQ DEBUG
00200D16  1639 00C00003           1937m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D1C  0803 0002               1938m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D20  67F4                    1939m       BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00200D22  13C2 00C00007           1940m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D28                          1941m     ENDC
00200D28                          1942m     
00200D28                 FALSE    1943m     IFNE DEBUG
00200D28                          1944m     ENDC
00200D28                          1945m 
00200D28                          1946m     ENDM
00200D28                          1947m           HEX2BIN D2,D2,A0
00200D28  41F9 00201B43           1948m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D2E  0402 0030               1949m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D32  C4BC 000000FF           1950m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D38  1430 2000               1951m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D3C                          1952m   ENDM
00200D3C  8E82                    1953            OR.L D2,D7
00200D3E  E98F                    1954            LSL.L #4,D7
00200D40                          1955m           DOWNLOAD D2,D3         
00200D40                          1956m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D40                          1957m 
00200D40  1639 00C00003           1958m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200D46  0803 0000               1959m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200D4A  6700 0010               1960m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00200D4E                          1961m  
00200D4E                          1962mm     READ_CHAR D2
00200D4E                 TRUE     1963mm     IFEQ DEBUG
00200D4E  1439 00C00007           1964mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200D54                          1965mm     ENDC
00200D54                 FALSE    1966mm     IFNE DEBUG
00200D54                          1967mm     ENDC
00200D54                          1968mm      
00200D54  B43C 001B               1969mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D58  6700 F2AE               1970mm     BEQ START
00200D5C                          1971mm     ENDM
00200D5C                          1972m CONTINUE_131
00200D5C  1639 00C00013           1973m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D62  0803 0000               1974m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D66  67D8                    1975m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00200D68                          1976m     
00200D68  1439 00C00017           1977m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D6E  13C2 00E00001           1978m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D74                          1979m     
00200D74                          1980m     ENDM
00200D74                          1981m           PRINT_CHAR D2,D3
00200D74                          1982m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D74                 TRUE     1983m     IFEQ DEBUG
00200D74  1639 00C00003           1984m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D7A  0803 0002               1985m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D7E  67F4                    1986m       BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00200D80  13C2 00C00007           1987m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D86                          1988m     ENDC
00200D86                          1989m     
00200D86                 FALSE    1990m     IFNE DEBUG
00200D86                          1991m     ENDC
00200D86                          1992m 
00200D86                          1993m     ENDM
00200D86                          1994m           HEX2BIN D2,D2,A0
00200D86  41F9 00201B43           1995m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D8C  0402 0030               1996m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D90  C4BC 000000FF           1997m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D96  1430 2000               1998m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D9A                          1999m   ENDM
00200D9A  8E82                    2000            OR.L D2,D7
00200D9C                          2001          
00200D9C  DC87                    2002            ADD.L D7,D6                 ; add top byte of address into checksum
00200D9E                          2003  
00200D9E  E98F                    2004            LSL.L #4,D7                 ; middle byte
00200DA0                          2005m           DOWNLOAD D2,D3
00200DA0                          2006m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA0                          2007m 
00200DA0  1639 00C00003           2008m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200DA6  0803 0000               2009m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200DAA  6700 0010               2010m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00200DAE                          2011m  
00200DAE                          2012mm     READ_CHAR D2
00200DAE                 TRUE     2013mm     IFEQ DEBUG
00200DAE  1439 00C00007           2014mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200DB4                          2015mm     ENDC
00200DB4                 FALSE    2016mm     IFNE DEBUG
00200DB4                          2017mm     ENDC
00200DB4                          2018mm      
00200DB4  B43C 001B               2019mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200DB8  6700 F24E               2020mm     BEQ START
00200DBC                          2021mm     ENDM
00200DBC                          2022m CONTINUE_135
00200DBC  1639 00C00013           2023m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200DC2  0803 0000               2024m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200DC6  67D8                    2025m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00200DC8                          2026m     
00200DC8  1439 00C00017           2027m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200DCE  13C2 00E00001           2028m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200DD4                          2029m     
00200DD4                          2030m     ENDM
00200DD4                          2031m           PRINT_CHAR D2,D3
00200DD4                          2032m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DD4                 TRUE     2033m     IFEQ DEBUG
00200DD4  1639 00C00003           2034m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200DDA  0803 0002               2035m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200DDE  67F4                    2036m       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00200DE0  13C2 00C00007           2037m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200DE6                          2038m     ENDC
00200DE6                          2039m     
00200DE6                 FALSE    2040m     IFNE DEBUG
00200DE6                          2041m     ENDC
00200DE6                          2042m 
00200DE6                          2043m     ENDM
00200DE6                          2044m           HEX2BIN D2,D2,A0
00200DE6  41F9 00201B43           2045m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200DEC  0402 0030               2046m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF0  C4BC 000000FF           2047m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200DF6  1430 2000               2048m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200DFA                          2049m   ENDM
00200DFA  8E82                    2050            OR.L D2,D7
00200DFC  E98F                    2051            LSL.L #4,D7        
00200DFE                          2052m           DOWNLOAD D2,D3
00200DFE                          2053m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DFE                          2054m 
00200DFE  1639 00C00003           2055m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E04  0803 0000               2056m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E08  6700 0010               2057m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00200E0C                          2058m  
00200E0C                          2059mm     READ_CHAR D2
00200E0C                 TRUE     2060mm     IFEQ DEBUG
00200E0C  1439 00C00007           2061mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E12                          2062mm     ENDC
00200E12                 FALSE    2063mm     IFNE DEBUG
00200E12                          2064mm     ENDC
00200E12                          2065mm      
00200E12  B43C 001B               2066mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E16  6700 F1F0               2067mm     BEQ START
00200E1A                          2068mm     ENDM
00200E1A                          2069m CONTINUE_139
00200E1A  1639 00C00013           2070m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E20  0803 0000               2071m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E24  67D8                    2072m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00200E26                          2073m     
00200E26  1439 00C00017           2074m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E2C  13C2 00E00001           2075m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E32                          2076m     
00200E32                          2077m     ENDM
00200E32                          2078m           PRINT_CHAR D2,D3
00200E32                          2079m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E32                 TRUE     2080m     IFEQ DEBUG
00200E32  1639 00C00003           2081m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E38  0803 0002               2082m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E3C  67F4                    2083m       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00200E3E  13C2 00C00007           2084m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E44                          2085m     ENDC
00200E44                          2086m     
00200E44                 FALSE    2087m     IFNE DEBUG
00200E44                          2088m     ENDC
00200E44                          2089m 
00200E44                          2090m     ENDM
00200E44                          2091m           HEX2BIN D2,D2,A0
00200E44  41F9 00201B43           2092m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200E4A  0402 0030               2093m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E4E  C4BC 000000FF           2094m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200E54  1430 2000               2095m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200E58                          2096m   ENDM
00200E58  8E82                    2097            OR.L D2,D7
00200E5A                          2098          
00200E5A  7400                    2099            MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00200E5C  1407                    2100            MOVE.B D7,D2
00200E5E  DC82                    2101            ADD.L D2,D6
00200E60                          2102            
00200E60  E98F                    2103            LSL.L #4,D7                 ; bottom byte
00200E62                          2104m           DOWNLOAD D2,D3
00200E62                          2105m WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                          2106m 
00200E62  1639 00C00003           2107m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E68  0803 0000               2108m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E6C  6700 0010               2109m     BEQ CONTINUE_143                ; NOTHING, CONTINUE
00200E70                          2110m  
00200E70                          2111mm     READ_CHAR D2
00200E70                 TRUE     2112mm     IFEQ DEBUG
00200E70  1439 00C00007           2113mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E76                          2114mm     ENDC
00200E76                 FALSE    2115mm     IFNE DEBUG
00200E76                          2116mm     ENDC
00200E76                          2117mm      
00200E76  B43C 001B               2118mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E7A  6700 F18C               2119mm     BEQ START
00200E7E                          2120mm     ENDM
00200E7E                          2121m CONTINUE_143
00200E7E  1639 00C00013           2122m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E84  0803 0000               2123m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E88  67D8                    2124m     BEQ WAIT_FOR_READY_143        ; NOTHING, CHECK AGAIN
00200E8A                          2125m     
00200E8A  1439 00C00017           2126m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E90  13C2 00E00001           2127m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E96                          2128m     
00200E96                          2129m     ENDM
00200E96                          2130m           PRINT_CHAR D2,D3
00200E96                          2131m WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E96                 TRUE     2132m     IFEQ DEBUG
00200E96  1639 00C00003           2133m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E9C  0803 0002               2134m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200EA0  67F4                    2135m       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00200EA2  13C2 00C00007           2136m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200EA8                          2137m     ENDC
00200EA8                          2138m     
00200EA8                 FALSE    2139m     IFNE DEBUG
00200EA8                          2140m     ENDC
00200EA8                          2141m 
00200EA8                          2142m     ENDM
00200EA8                          2143m           HEX2BIN D2,D2,A0
00200EA8  41F9 00201B43           2144m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200EAE  0402 0030               2145m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EB2  C4BC 000000FF           2146m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200EB8  1430 2000               2147m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200EBC                          2148m   ENDM
00200EBC  8E82                    2149            OR.L D2,D7
00200EBE  E98F                    2150            LSL.L #4,D7        
00200EC0                          2151m           DOWNLOAD D2,D3
00200EC0                          2152m WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC0                          2153m 
00200EC0  1639 00C00003           2154m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200EC6  0803 0000               2155m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200ECA  6700 0010               2156m     BEQ CONTINUE_147                ; NOTHING, CONTINUE
00200ECE                          2157m  
00200ECE                          2158mm     READ_CHAR D2
00200ECE                 TRUE     2159mm     IFEQ DEBUG
00200ECE  1439 00C00007           2160mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200ED4                          2161mm     ENDC
00200ED4                 FALSE    2162mm     IFNE DEBUG
00200ED4                          2163mm     ENDC
00200ED4                          2164mm      
00200ED4  B43C 001B               2165mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200ED8  6700 F12E               2166mm     BEQ START
00200EDC                          2167mm     ENDM
00200EDC                          2168m CONTINUE_147
00200EDC  1639 00C00013           2169m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200EE2  0803 0000               2170m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200EE6  67D8                    2171m     BEQ WAIT_FOR_READY_147        ; NOTHING, CHECK AGAIN
00200EE8                          2172m     
00200EE8  1439 00C00017           2173m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200EEE  13C2 00E00001           2174m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200EF4                          2175m     
00200EF4                          2176m     ENDM
00200EF4                          2177m           PRINT_CHAR D2,D3
00200EF4                          2178m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EF4                 TRUE     2179m     IFEQ DEBUG
00200EF4  1639 00C00003           2180m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200EFA  0803 0002               2181m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200EFE  67F4                    2182m       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00200F00  13C2 00C00007           2183m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F06                          2184m     ENDC
00200F06                          2185m     
00200F06                 FALSE    2186m     IFNE DEBUG
00200F06                          2187m     ENDC
00200F06                          2188m 
00200F06                          2189m     ENDM
00200F06                          2190m           HEX2BIN D2,D2,A0
00200F06  41F9 00201B43           2191m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F0C  0402 0030               2192m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F10  C4BC 000000FF           2193m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F16  1430 2000               2194m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F1A                          2195m   ENDM
00200F1A  8E82                    2196            OR.L D2,D7
00200F1C                          2197          
00200F1C  7400                    2198            MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200F1E  1407                    2199            MOVE.B D7,D2
00200F20  DC82                    2200            ADD.L D2,D6
00200F22                          2201          
00200F22  2247                    2202            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F24  D3CB                    2203            ADD.L A3,A1                 ; add in the offset
00200F26                          2204            
00200F26  0807 0000               2205            BTST #0,D7                  ; deal with odd addresses
00200F2A                          2206  
00200F2A  2247                    2207            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F2C  6700 00D0               2208            BEQ EVEN2
00200F30                          2209                  
00200F30  5385                    2210            SUB.L #1,D5
00200F32  5389                    2211            SUB.L #1,A1
00200F34                          2212          
00200F34  7E00                    2213            MOVE.L #0,D7
00200F36                          2214m           DOWNLOAD D2,D3            ; MS 4 bits
00200F36                          2215m WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F36                          2216m 
00200F36  1639 00C00003           2217m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F3C  0803 0000               2218m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F40  6700 0010               2219m     BEQ CONTINUE_151                ; NOTHING, CONTINUE
00200F44                          2220m  
00200F44                          2221mm     READ_CHAR D2
00200F44                 TRUE     2222mm     IFEQ DEBUG
00200F44  1439 00C00007           2223mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200F4A                          2224mm     ENDC
00200F4A                 FALSE    2225mm     IFNE DEBUG
00200F4A                          2226mm     ENDC
00200F4A                          2227mm      
00200F4A  B43C 001B               2228mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200F4E  6700 F0B8               2229mm     BEQ START
00200F52                          2230mm     ENDM
00200F52                          2231m CONTINUE_151
00200F52  1639 00C00013           2232m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200F58  0803 0000               2233m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200F5C  67D8                    2234m     BEQ WAIT_FOR_READY_151        ; NOTHING, CHECK AGAIN
00200F5E                          2235m     
00200F5E  1439 00C00017           2236m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200F64  13C2 00E00001           2237m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200F6A                          2238m     
00200F6A                          2239m     ENDM
00200F6A                          2240m           PRINT_CHAR D2,D3
00200F6A                          2241m WAIT_FOR_READY_153                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F6A                 TRUE     2242m     IFEQ DEBUG
00200F6A  1639 00C00003           2243m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200F70  0803 0002               2244m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200F74  67F4                    2245m       BEQ WAIT_FOR_READY_153          ; NO SPACE, CHECK AGAIN
00200F76  13C2 00C00007           2246m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F7C                          2247m     ENDC
00200F7C                          2248m     
00200F7C                 FALSE    2249m     IFNE DEBUG
00200F7C                          2250m     ENDC
00200F7C                          2251m 
00200F7C                          2252m     ENDM
00200F7C                          2253m           HEX2BIN D2,D2,A0
00200F7C  41F9 00201B43           2254m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F82  0402 0030               2255m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F86  C4BC 000000FF           2256m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F8C  1430 2000               2257m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F90                          2258m   ENDM
00200F90  8E82                    2259            OR.L D2,D7
00200F92  E98F                    2260            LSL.L #4,D7
00200F94                          2261               
00200F94                          2262m           DOWNLOAD D2,D3            ; LS 4 bits    
00200F94                          2263m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                          2264m 
00200F94  1639 00C00003           2265m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F9A  0803 0000               2266m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F9E  6700 0010               2267m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00200FA2                          2268m  
00200FA2                          2269mm     READ_CHAR D2
00200FA2                 TRUE     2270mm     IFEQ DEBUG
00200FA2  1439 00C00007           2271mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200FA8                          2272mm     ENDC
00200FA8                 FALSE    2273mm     IFNE DEBUG
00200FA8                          2274mm     ENDC
00200FA8                          2275mm      
00200FA8  B43C 001B               2276mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200FAC  6700 F05A               2277mm     BEQ START
00200FB0                          2278mm     ENDM
00200FB0                          2279m CONTINUE_155
00200FB0  1639 00C00013           2280m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200FB6  0803 0000               2281m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200FBA  67D8                    2282m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00200FBC                          2283m     
00200FBC  1439 00C00017           2284m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200FC2  13C2 00E00001           2285m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200FC8                          2286m     
00200FC8                          2287m     ENDM
00200FC8                          2288m           PRINT_CHAR D2,D3
00200FC8                          2289m WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FC8                 TRUE     2290m     IFEQ DEBUG
00200FC8  1639 00C00003           2291m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200FCE  0803 0002               2292m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200FD2  67F4                    2293m       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00200FD4  13C2 00C00007           2294m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200FDA                          2295m     ENDC
00200FDA                          2296m     
00200FDA                 FALSE    2297m     IFNE DEBUG
00200FDA                          2298m     ENDC
00200FDA                          2299m 
00200FDA                          2300m     ENDM
00200FDA                          2301m           HEX2BIN D2,D2,A0
00200FDA  41F9 00201B43           2302m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200FE0  0402 0030               2303m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FE4  C4BC 000000FF           2304m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200FEA  1430 2000               2305m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200FEE                          2306m   ENDM
00200FEE  8E82                    2307            OR.L D2,D7
00200FF0                          2308                          
00200FF0  DC87                    2309            ADD.L D7,D6               ; add into checksum
00200FF2                          2310                        
00200FF2  3611                    2311            MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200FF4                          2312          
00200FF4  0243 FF00               2313            ANDI.W #$FF00,D3
00200FF8  8647                    2314            OR.W D7,D3
00200FFA                          2315          
00200FFA  3283                    2316            MOVE.W D3,(A1)           ; store it!
00200FFC  5489                    2317            ADD.L #2,A1
00200FFE                          2318  EVEN2
00200FFE  5985                    2319            SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00201000                          2320            WHILE.L D5 <GE> #2 DO       ; read the data bytes
00201000                          2321s _10000004
00201000  BABC 00000002           2322s     CMP.L   #2,D5
00201006  6D00 018A               2323s     BLT _10000005
0020100A  5585                    2324              SUB.L #2,D5
0020100C                          2325              
0020100C  7E00                    2326              MOVE.L #0,D7              ; D7 holds the word
0020100E                          2327              
0020100E                          2328m             DOWNLOAD D2,D3            ; MS 4 bits
0020100E                          2329m WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020100E                          2330m 
0020100E  1639 00C00003           2331m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201014  0803 0000               2332m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201018  6700 0010               2333m     BEQ CONTINUE_159                ; NOTHING, CONTINUE
0020101C                          2334m  
0020101C                          2335mm     READ_CHAR D2
0020101C                 TRUE     2336mm     IFEQ DEBUG
0020101C  1439 00C00007           2337mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201022                          2338mm     ENDC
00201022                 FALSE    2339mm     IFNE DEBUG
00201022                          2340mm     ENDC
00201022                          2341mm      
00201022  B43C 001B               2342mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201026  6700 EFE0               2343mm     BEQ START
0020102A                          2344mm     ENDM
0020102A                          2345m CONTINUE_159
0020102A  1639 00C00013           2346m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201030  0803 0000               2347m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201034  67D8                    2348m     BEQ WAIT_FOR_READY_159        ; NOTHING, CHECK AGAIN
00201036                          2349m     
00201036  1439 00C00017           2350m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020103C  13C2 00E00001           2351m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201042                          2352m     
00201042                          2353m     ENDM
00201042                          2354m             PRINT_CHAR D2,D3
00201042                          2355m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201042                 TRUE     2356m     IFEQ DEBUG
00201042  1639 00C00003           2357m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201048  0803 0002               2358m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020104C  67F4                    2359m       BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
0020104E  13C2 00C00007           2360m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201054                          2361m     ENDC
00201054                          2362m     
00201054                 FALSE    2363m     IFNE DEBUG
00201054                          2364m     ENDC
00201054                          2365m 
00201054                          2366m     ENDM
00201054                          2367m             HEX2BIN D2,D2,A0
00201054  41F9 00201B43           2368m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020105A  0402 0030               2369m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020105E  C4BC 000000FF           2370m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201064  1430 2000               2371m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201068                          2372m   ENDM
00201068  8E82                    2373              OR.L D2,D7
0020106A  E98F                    2374              LSL.L #4,D7
0020106C                          2375               
0020106C                          2376m             DOWNLOAD D2,D3            ; LS 4 bits    
0020106C                          2377m WAIT_FOR_READY_163                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020106C                          2378m 
0020106C  1639 00C00003           2379m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201072  0803 0000               2380m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201076  6700 0010               2381m     BEQ CONTINUE_163                ; NOTHING, CONTINUE
0020107A                          2382m  
0020107A                          2383mm     READ_CHAR D2
0020107A                 TRUE     2384mm     IFEQ DEBUG
0020107A  1439 00C00007           2385mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201080                          2386mm     ENDC
00201080                 FALSE    2387mm     IFNE DEBUG
00201080                          2388mm     ENDC
00201080                          2389mm      
00201080  B43C 001B               2390mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201084  6700 EF82               2391mm     BEQ START
00201088                          2392mm     ENDM
00201088                          2393m CONTINUE_163
00201088  1639 00C00013           2394m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020108E  0803 0000               2395m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201092  67D8                    2396m     BEQ WAIT_FOR_READY_163        ; NOTHING, CHECK AGAIN
00201094                          2397m     
00201094  1439 00C00017           2398m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020109A  13C2 00E00001           2399m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002010A0                          2400m     
002010A0                          2401m     ENDM
002010A0                          2402m             PRINT_CHAR D2,D3
002010A0                          2403m WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A0                 TRUE     2404m     IFEQ DEBUG
002010A0  1639 00C00003           2405m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002010A6  0803 0002               2406m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002010AA  67F4                    2407m       BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
002010AC  13C2 00C00007           2408m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002010B2                          2409m     ENDC
002010B2                          2410m     
002010B2                 FALSE    2411m     IFNE DEBUG
002010B2                          2412m     ENDC
002010B2                          2413m 
002010B2                          2414m     ENDM
002010B2                          2415m             HEX2BIN D2,D2,A0
002010B2  41F9 00201B43           2416m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002010B8  0402 0030               2417m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002010BC  C4BC 000000FF           2418m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002010C2  1430 2000               2419m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002010C6                          2420m   ENDM
002010C6  8E82                    2421              OR.L D2,D7
002010C8                          2422                          
002010C8  DC87                    2423              ADD.L D7,D6               ; add into checksum
002010CA                          2424              
002010CA  E98F                    2425              LSL.L #4,D7
002010CC                          2426m             DOWNLOAD D2,D3            ; MS 4 bits
002010CC                          2427m WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010CC                          2428m 
002010CC  1639 00C00003           2429m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002010D2  0803 0000               2430m     BTST #0,D3                    ; CHECK FOR CHARACTER
002010D6  6700 0010               2431m     BEQ CONTINUE_167                ; NOTHING, CONTINUE
002010DA                          2432m  
002010DA                          2433mm     READ_CHAR D2
002010DA                 TRUE     2434mm     IFEQ DEBUG
002010DA  1439 00C00007           2435mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002010E0                          2436mm     ENDC
002010E0                 FALSE    2437mm     IFNE DEBUG
002010E0                          2438mm     ENDC
002010E0                          2439mm      
002010E0  B43C 001B               2440mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002010E4  6700 EF22               2441mm     BEQ START
002010E8                          2442mm     ENDM
002010E8                          2443m CONTINUE_167
002010E8  1639 00C00013           2444m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002010EE  0803 0000               2445m     BTST #0,D3                  ; CHECK FOR CHARACTER
002010F2  67D8                    2446m     BEQ WAIT_FOR_READY_167        ; NOTHING, CHECK AGAIN
002010F4                          2447m     
002010F4  1439 00C00017           2448m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002010FA  13C2 00E00001           2449m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201100                          2450m     
00201100                          2451m     ENDM
00201100                          2452m             PRINT_CHAR D2,D3
00201100                          2453m WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201100                 TRUE     2454m     IFEQ DEBUG
00201100  1639 00C00003           2455m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201106  0803 0002               2456m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020110A  67F4                    2457m       BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
0020110C  13C2 00C00007           2458m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201112                          2459m     ENDC
00201112                          2460m     
00201112                 FALSE    2461m     IFNE DEBUG
00201112                          2462m     ENDC
00201112                          2463m 
00201112                          2464m     ENDM
00201112                          2465m             HEX2BIN D2,D2,A0
00201112  41F9 00201B43           2466m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201118  0402 0030               2467m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020111C  C4BC 000000FF           2468m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201122  1430 2000               2469m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201126                          2470m   ENDM
00201126  8E82                    2471              OR.L D2,D7
00201128                          2472               
00201128  E98F                    2473              LSL.L #4,D7
0020112A                          2474m             DOWNLOAD D2,D3            ; LS 4 bits    
0020112A                          2475m WAIT_FOR_READY_171                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020112A                          2476m 
0020112A  1639 00C00003           2477m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201130  0803 0000               2478m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201134  6700 0010               2479m     BEQ CONTINUE_171                ; NOTHING, CONTINUE
00201138                          2480m  
00201138                          2481mm     READ_CHAR D2
00201138                 TRUE     2482mm     IFEQ DEBUG
00201138  1439 00C00007           2483mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020113E                          2484mm     ENDC
0020113E                 FALSE    2485mm     IFNE DEBUG
0020113E                          2486mm     ENDC
0020113E                          2487mm      
0020113E  B43C 001B               2488mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201142  6700 EEC4               2489mm     BEQ START
00201146                          2490mm     ENDM
00201146                          2491m CONTINUE_171
00201146  1639 00C00013           2492m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020114C  0803 0000               2493m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201150  67D8                    2494m     BEQ WAIT_FOR_READY_171        ; NOTHING, CHECK AGAIN
00201152                          2495m     
00201152  1439 00C00017           2496m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201158  13C2 00E00001           2497m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020115E                          2498m     
0020115E                          2499m     ENDM
0020115E                          2500m             PRINT_CHAR D2,D3
0020115E                          2501m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020115E                 TRUE     2502m     IFEQ DEBUG
0020115E  1639 00C00003           2503m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201164  0803 0002               2504m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201168  67F4                    2505m       BEQ WAIT_FOR_READY_173          ; NO SPACE, CHECK AGAIN
0020116A  13C2 00C00007           2506m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201170                          2507m     ENDC
00201170                          2508m     
00201170                 FALSE    2509m     IFNE DEBUG
00201170                          2510m     ENDC
00201170                          2511m 
00201170                          2512m     ENDM
00201170                          2513m             HEX2BIN D2,D2,A0
00201170  41F9 00201B43           2514m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201176  0402 0030               2515m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020117A  C4BC 000000FF           2516m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201180  1430 2000               2517m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201184                          2518m   ENDM
00201184  8E82                    2519              OR.L D2,D7
00201186                          2520              
00201186  7400                    2521              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00201188  1407                    2522              MOVE.B D7,D2
0020118A  DC82                    2523              ADD.L D2,D6
0020118C                          2524              
0020118C  32C7                    2525              MOVE.W D7,(A1)+             ; store it!
0020118E                          2526              
0020118E                          2527            ENDW
0020118E  6000 FE70               2528s     BRA _10000004
00201192                          2529s _10000005
00201192                          2530              
00201192                          2531            IF D5 <EQ> #1 THEN
00201192  BA7C 0001               2532s     CMP.W   #1,D5
00201196  6600 00CE               2533s     BNE _00000006
0020119A  7E00                    2534              MOVE.L #0,D7              ; D7 holds the word
0020119C                          2535                      
0020119C                          2536m             DOWNLOAD D2,D3            ; MS 4 bits
0020119C                          2537m WAIT_FOR_READY_175                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020119C                          2538m 
0020119C  1639 00C00003           2539m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002011A2  0803 0000               2540m     BTST #0,D3                    ; CHECK FOR CHARACTER
002011A6  6700 0010               2541m     BEQ CONTINUE_175                ; NOTHING, CONTINUE
002011AA                          2542m  
002011AA                          2543mm     READ_CHAR D2
002011AA                 TRUE     2544mm     IFEQ DEBUG
002011AA  1439 00C00007           2545mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002011B0                          2546mm     ENDC
002011B0                 FALSE    2547mm     IFNE DEBUG
002011B0                          2548mm     ENDC
002011B0                          2549mm      
002011B0  B43C 001B               2550mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002011B4  6700 EE52               2551mm     BEQ START
002011B8                          2552mm     ENDM
002011B8                          2553m CONTINUE_175
002011B8  1639 00C00013           2554m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002011BE  0803 0000               2555m     BTST #0,D3                  ; CHECK FOR CHARACTER
002011C2  67D8                    2556m     BEQ WAIT_FOR_READY_175        ; NOTHING, CHECK AGAIN
002011C4                          2557m     
002011C4  1439 00C00017           2558m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002011CA  13C2 00E00001           2559m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002011D0                          2560m     
002011D0                          2561m     ENDM
002011D0                          2562m             PRINT_CHAR D2,D3
002011D0                          2563m WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011D0                 TRUE     2564m     IFEQ DEBUG
002011D0  1639 00C00003           2565m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011D6  0803 0002               2566m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011DA  67F4                    2567m       BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
002011DC  13C2 00C00007           2568m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002011E2                          2569m     ENDC
002011E2                          2570m     
002011E2                 FALSE    2571m     IFNE DEBUG
002011E2                          2572m     ENDC
002011E2                          2573m 
002011E2                          2574m     ENDM
002011E2                          2575m             HEX2BIN D2,D2,A0
002011E2  41F9 00201B43           2576m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002011E8  0402 0030               2577m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002011EC  C4BC 000000FF           2578m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002011F2  1430 2000               2579m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002011F6                          2580m   ENDM
002011F6  8E82                    2581              OR.L D2,D7
002011F8  E98F                    2582              LSL.L #4,D7
002011FA                          2583               
002011FA                          2584m             DOWNLOAD D2,D3            ; LS 4 bits    
002011FA                          2585m WAIT_FOR_READY_179                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011FA                          2586m 
002011FA  1639 00C00003           2587m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201200  0803 0000               2588m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201204  6700 0010               2589m     BEQ CONTINUE_179                ; NOTHING, CONTINUE
00201208                          2590m  
00201208                          2591mm     READ_CHAR D2
00201208                 TRUE     2592mm     IFEQ DEBUG
00201208  1439 00C00007           2593mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020120E                          2594mm     ENDC
0020120E                 FALSE    2595mm     IFNE DEBUG
0020120E                          2596mm     ENDC
0020120E                          2597mm      
0020120E  B43C 001B               2598mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201212  6700 EDF4               2599mm     BEQ START
00201216                          2600mm     ENDM
00201216                          2601m CONTINUE_179
00201216  1639 00C00013           2602m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020121C  0803 0000               2603m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201220  67D8                    2604m     BEQ WAIT_FOR_READY_179        ; NOTHING, CHECK AGAIN
00201222                          2605m     
00201222  1439 00C00017           2606m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201228  13C2 00E00001           2607m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020122E                          2608m     
0020122E                          2609m     ENDM
0020122E                          2610m             PRINT_CHAR D2,D3
0020122E                          2611m WAIT_FOR_READY_181                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122E                 TRUE     2612m     IFEQ DEBUG
0020122E  1639 00C00003           2613m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201234  0803 0002               2614m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201238  67F4                    2615m       BEQ WAIT_FOR_READY_181          ; NO SPACE, CHECK AGAIN
0020123A  13C2 00C00007           2616m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201240                          2617m     ENDC
00201240                          2618m     
00201240                 FALSE    2619m     IFNE DEBUG
00201240                          2620m     ENDC
00201240                          2621m 
00201240                          2622m     ENDM
00201240                          2623m             HEX2BIN D2,D2,A0
00201240  41F9 00201B43           2624m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201246  0402 0030               2625m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020124A  C4BC 000000FF           2626m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201250  1430 2000               2627m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201254                          2628m   ENDM
00201254  8E82                    2629              OR.L D2,D7
00201256                          2630                          
00201256  DC87                    2631              ADD.L D7,D6               ; add into checksum
00201258                          2632              
00201258  3611                    2633              MOVE.W (A1),D3            ; get the current data and replace the top byte
0020125A  E18F                    2634              LSL.L #8,D7
0020125C  C6BC 000000FF           2635              AND.L #$00FF,D3
00201262  8687                    2636              OR.L D7,D3
00201264                          2637  
00201264  32C3                    2638              MOVE.W D3,(A1)+          ; store it!
00201266                          2639            ENDI
00201266                          2640s _00000006
00201266                          2641m           PRINT_CRLF D3
00201266                          2642mm     PRINT_CHAR #13,D3             ; CR
00201266                          2643mm WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201266                 TRUE     2644mm     IFEQ DEBUG
00201266  1639 00C00003           2645mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020126C  0803 0002               2646mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201270  67F4                    2647mm       BEQ WAIT_FOR_READY_184          ; NO SPACE, CHECK AGAIN
00201272  13FC 000D 00C00007      2648mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020127A                          2649mm     ENDC
0020127A                          2650mm     
0020127A                 FALSE    2651mm     IFNE DEBUG
0020127A                          2652mm     ENDC
0020127A                          2653mm 
0020127A                          2654mm     ENDM
0020127A                          2655mm     PRINT_CHAR #10,D3             ; LF
0020127A                          2656mm WAIT_FOR_READY_185                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020127A                 TRUE     2657mm     IFEQ DEBUG
0020127A  1639 00C00003           2658mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201280  0803 0002               2659mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201284  67F4                    2660mm       BEQ WAIT_FOR_READY_185          ; NO SPACE, CHECK AGAIN
00201286  13FC 000A 00C00007      2661mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020128E                          2662mm     ENDC
0020128E                          2663mm     
0020128E                 FALSE    2664mm     IFNE DEBUG
0020128E                          2665mm     ENDC
0020128E                          2666mm 
0020128E                          2667mm     ENDM
0020128E                          2668m     ENDM
0020128E  43F9 002004A0           2669            LEA WAIT_FOR_SRECORD,A1     ; next place to go
00201294                          2670          ELSE
00201294  6000 0252               2671s     BRA _00000007
00201298                          2672s _00000005
00201298                          2673            IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00201298  BE3C 0038               2674s     CMP.B   #'8',D7
0020129C  6600 01E4               2675s     BNE.L   _00000008
002012A0  7E00                    2676              MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002012A2                          2677m             DOWNLOAD D2,D3            ; top byte
002012A2                          2678m WAIT_FOR_READY_186                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012A2                          2679m 
002012A2  1639 00C00003           2680m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012A8  0803 0000               2681m     BTST #0,D3                    ; CHECK FOR CHARACTER
002012AC  6700 0010               2682m     BEQ CONTINUE_186                ; NOTHING, CONTINUE
002012B0                          2683m  
002012B0                          2684mm     READ_CHAR D2
002012B0                 TRUE     2685mm     IFEQ DEBUG
002012B0  1439 00C00007           2686mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002012B6                          2687mm     ENDC
002012B6                 FALSE    2688mm     IFNE DEBUG
002012B6                          2689mm     ENDC
002012B6                          2690mm      
002012B6  B43C 001B               2691mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002012BA  6700 ED4C               2692mm     BEQ START
002012BE                          2693mm     ENDM
002012BE                          2694m CONTINUE_186
002012BE  1639 00C00013           2695m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002012C4  0803 0000               2696m     BTST #0,D3                  ; CHECK FOR CHARACTER
002012C8  67D8                    2697m     BEQ WAIT_FOR_READY_186        ; NOTHING, CHECK AGAIN
002012CA                          2698m     
002012CA  1439 00C00017           2699m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002012D0  13C2 00E00001           2700m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002012D6                          2701m     
002012D6                          2702m     ENDM
002012D6                          2703m             HEX2BIN D2,D2,A0
002012D6  41F9 00201B43           2704m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002012DC  0402 0030               2705m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012E0  C4BC 000000FF           2706m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002012E6  1430 2000               2707m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002012EA                          2708m   ENDM
002012EA  8E82                    2709              OR.L D2,D7
002012EC  E98F                    2710              LSL.L #4,D7
002012EE                          2711m             DOWNLOAD D2,D3         
002012EE                          2712m WAIT_FOR_READY_189                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012EE                          2713m 
002012EE  1639 00C00003           2714m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012F4  0803 0000               2715m     BTST #0,D3                    ; CHECK FOR CHARACTER
002012F8  6700 0010               2716m     BEQ CONTINUE_189                ; NOTHING, CONTINUE
002012FC                          2717m  
002012FC                          2718mm     READ_CHAR D2
002012FC                 TRUE     2719mm     IFEQ DEBUG
002012FC  1439 00C00007           2720mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201302                          2721mm     ENDC
00201302                 FALSE    2722mm     IFNE DEBUG
00201302                          2723mm     ENDC
00201302                          2724mm      
00201302  B43C 001B               2725mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201306  6700 ED00               2726mm     BEQ START
0020130A                          2727mm     ENDM
0020130A                          2728m CONTINUE_189
0020130A  1639 00C00013           2729m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201310  0803 0000               2730m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201314  67D8                    2731m     BEQ WAIT_FOR_READY_189        ; NOTHING, CHECK AGAIN
00201316                          2732m     
00201316  1439 00C00017           2733m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020131C  13C2 00E00001           2734m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201322                          2735m     
00201322                          2736m     ENDM
00201322                          2737m             HEX2BIN D2,D2,A0
00201322  41F9 00201B43           2738m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201328  0402 0030               2739m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020132C  C4BC 000000FF           2740m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201332  1430 2000               2741m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201336                          2742m   ENDM
00201336  8E82                    2743              OR.L D2,D7
00201338                          2744          
00201338  DC87                    2745              ADD.L D7,D6               ; add top byte of address into checksum
0020133A                          2746  
0020133A  E98F                    2747              LSL.L #4,D7               ; middle byte
0020133C                          2748m             DOWNLOAD D2,D3
0020133C                          2749m WAIT_FOR_READY_192                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133C                          2750m 
0020133C  1639 00C00003           2751m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201342  0803 0000               2752m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201346  6700 0010               2753m     BEQ CONTINUE_192                ; NOTHING, CONTINUE
0020134A                          2754m  
0020134A                          2755mm     READ_CHAR D2
0020134A                 TRUE     2756mm     IFEQ DEBUG
0020134A  1439 00C00007           2757mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201350                          2758mm     ENDC
00201350                 FALSE    2759mm     IFNE DEBUG
00201350                          2760mm     ENDC
00201350                          2761mm      
00201350  B43C 001B               2762mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201354  6700 ECB2               2763mm     BEQ START
00201358                          2764mm     ENDM
00201358                          2765m CONTINUE_192
00201358  1639 00C00013           2766m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020135E  0803 0000               2767m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201362  67D8                    2768m     BEQ WAIT_FOR_READY_192        ; NOTHING, CHECK AGAIN
00201364                          2769m     
00201364  1439 00C00017           2770m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020136A  13C2 00E00001           2771m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201370                          2772m     
00201370                          2773m     ENDM
00201370                          2774m             HEX2BIN D2,D2,A0
00201370  41F9 00201B43           2775m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201376  0402 0030               2776m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020137A  C4BC 000000FF           2777m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201380  1430 2000               2778m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201384                          2779m   ENDM
00201384  8E82                    2780              OR.L D2,D7
00201386  E98F                    2781              LSL.L #4,D7        
00201388                          2782m             DOWNLOAD D2,D3
00201388                          2783m WAIT_FOR_READY_195                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201388                          2784m 
00201388  1639 00C00003           2785m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020138E  0803 0000               2786m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201392  6700 0010               2787m     BEQ CONTINUE_195                ; NOTHING, CONTINUE
00201396                          2788m  
00201396                          2789mm     READ_CHAR D2
00201396                 TRUE     2790mm     IFEQ DEBUG
00201396  1439 00C00007           2791mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020139C                          2792mm     ENDC
0020139C                 FALSE    2793mm     IFNE DEBUG
0020139C                          2794mm     ENDC
0020139C                          2795mm      
0020139C  B43C 001B               2796mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013A0  6700 EC66               2797mm     BEQ START
002013A4                          2798mm     ENDM
002013A4                          2799m CONTINUE_195
002013A4  1639 00C00013           2800m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002013AA  0803 0000               2801m     BTST #0,D3                  ; CHECK FOR CHARACTER
002013AE  67D8                    2802m     BEQ WAIT_FOR_READY_195        ; NOTHING, CHECK AGAIN
002013B0                          2803m     
002013B0  1439 00C00017           2804m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002013B6  13C2 00E00001           2805m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002013BC                          2806m     
002013BC                          2807m     ENDM
002013BC                          2808m             HEX2BIN D2,D2,A0
002013BC  41F9 00201B43           2809m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002013C2  0402 0030               2810m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013C6  C4BC 000000FF           2811m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002013CC  1430 2000               2812m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002013D0                          2813m   ENDM
002013D0  8E82                    2814              OR.L D2,D7
002013D2                          2815          
002013D2  7400                    2816              MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
002013D4  1407                    2817              MOVE.B D7,D2
002013D6  DC82                    2818              ADD.L D2,D6
002013D8                          2819            
002013D8  E98F                    2820              LSL.L #4,D7               ; bottom byte
002013DA                          2821m             DOWNLOAD D2,D3
002013DA                          2822m WAIT_FOR_READY_198                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013DA                          2823m 
002013DA  1639 00C00003           2824m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002013E0  0803 0000               2825m     BTST #0,D3                    ; CHECK FOR CHARACTER
002013E4  6700 0010               2826m     BEQ CONTINUE_198                ; NOTHING, CONTINUE
002013E8                          2827m  
002013E8                          2828mm     READ_CHAR D2
002013E8                 TRUE     2829mm     IFEQ DEBUG
002013E8  1439 00C00007           2830mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002013EE                          2831mm     ENDC
002013EE                 FALSE    2832mm     IFNE DEBUG
002013EE                          2833mm     ENDC
002013EE                          2834mm      
002013EE  B43C 001B               2835mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013F2  6700 EC14               2836mm     BEQ START
002013F6                          2837mm     ENDM
002013F6                          2838m CONTINUE_198
002013F6  1639 00C00013           2839m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002013FC  0803 0000               2840m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201400  67D8                    2841m     BEQ WAIT_FOR_READY_198        ; NOTHING, CHECK AGAIN
00201402                          2842m     
00201402  1439 00C00017           2843m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201408  13C2 00E00001           2844m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020140E                          2845m     
0020140E                          2846m     ENDM
0020140E                          2847m             HEX2BIN D2,D2,A0
0020140E  41F9 00201B43           2848m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201414  0402 0030               2849m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201418  C4BC 000000FF           2850m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020141E  1430 2000               2851m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201422                          2852m   ENDM
00201422  8E82                    2853              OR.L D2,D7
00201424  E98F                    2854              LSL.L #4,D7        
00201426                          2855m             DOWNLOAD D2,D3
00201426                          2856m WAIT_FOR_READY_201                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201426                          2857m 
00201426  1639 00C00003           2858m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020142C  0803 0000               2859m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201430  6700 0010               2860m     BEQ CONTINUE_201                ; NOTHING, CONTINUE
00201434                          2861m  
00201434                          2862mm     READ_CHAR D2
00201434                 TRUE     2863mm     IFEQ DEBUG
00201434  1439 00C00007           2864mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020143A                          2865mm     ENDC
0020143A                 FALSE    2866mm     IFNE DEBUG
0020143A                          2867mm     ENDC
0020143A                          2868mm      
0020143A  B43C 001B               2869mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020143E  6700 EBC8               2870mm     BEQ START
00201442                          2871mm     ENDM
00201442                          2872m CONTINUE_201
00201442  1639 00C00013           2873m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201448  0803 0000               2874m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020144C  67D8                    2875m     BEQ WAIT_FOR_READY_201        ; NOTHING, CHECK AGAIN
0020144E                          2876m     
0020144E  1439 00C00017           2877m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201454  13C2 00E00001           2878m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020145A                          2879m     
0020145A                          2880m     ENDM
0020145A                          2881m             HEX2BIN D2,D2,A0
0020145A  41F9 00201B43           2882m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201460  0402 0030               2883m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201464  C4BC 000000FF           2884m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020146A  1430 2000               2885m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020146E                          2886m   ENDM
0020146E  8E82                    2887              OR.L D2,D7
00201470                          2888          
00201470  7400                    2889              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00201472  1407                    2890              MOVE.B D7,D2
00201474  DC82                    2891              ADD.L D2,D6
00201476                          2892            
00201476  2447                    2893              MOVE.L D7,A2              ; start address -> A2
00201478                          2894          
00201478  43F9 00201638           2895              LEA DOWNLOAD_DONE,A1      ; next place to go
0020147E                          2896            ELSE
0020147E  6000 0068               2897s     BRA _00000009
00201482                          2898s _00000008
00201482  41F9 00201ACF           2899              LEA UNREC,A0              ; warn for unrecognised type
00201488                          2900m             PRINT_STR A0,D3
00201488                          2901m LOOP_204
00201488  0C10 0000               2902m     CMP.B #0,(A0)                 ; 0 -> DONE
0020148C  6700 001A               2903m     BEQ EXIT_204
00201490                          2904mm     PRINT_CHAR (A0)+,D3
00201490                          2905mm WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201490                 TRUE     2906mm     IFEQ DEBUG
00201490  1639 00C00003           2907mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201496  0803 0002               2908mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020149A  67F4                    2909mm       BEQ WAIT_FOR_READY_205          ; NO SPACE, CHECK AGAIN
0020149C  13D8 00C00007           2910mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002014A2                          2911mm     ENDC
002014A2                          2912mm     
002014A2                 FALSE    2913mm     IFNE DEBUG
002014A2                          2914mm     ENDC
002014A2                          2915mm 
002014A2                          2916mm     ENDM
002014A2  4EF9 00201488           2917m     JMP LOOP_204
002014A8                          2918m EXIT_204
002014A8                          2919m     ENDM
002014A8                          2920m             PRINT_CHAR D7,D3
002014A8                          2921m WAIT_FOR_READY_206                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014A8                 TRUE     2922m     IFEQ DEBUG
002014A8  1639 00C00003           2923m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014AE  0803 0002               2924m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014B2  67F4                    2925m       BEQ WAIT_FOR_READY_206          ; NO SPACE, CHECK AGAIN
002014B4  13C7 00C00007           2926m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002014BA                          2927m     ENDC
002014BA                          2928m     
002014BA                 FALSE    2929m     IFNE DEBUG
002014BA                          2930m     ENDC
002014BA                          2931m 
002014BA                          2932m     ENDM
002014BA                          2933m             PRINT_CRLF D3
002014BA                          2934mm     PRINT_CHAR #13,D3             ; CR
002014BA                          2935mm WAIT_FOR_READY_208                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014BA                 TRUE     2936mm     IFEQ DEBUG
002014BA  1639 00C00003           2937mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014C0  0803 0002               2938mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014C4  67F4                    2939mm       BEQ WAIT_FOR_READY_208          ; NO SPACE, CHECK AGAIN
002014C6  13FC 000D 00C00007      2940mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002014CE                          2941mm     ENDC
002014CE                          2942mm     
002014CE                 FALSE    2943mm     IFNE DEBUG
002014CE                          2944mm     ENDC
002014CE                          2945mm 
002014CE                          2946mm     ENDM
002014CE                          2947mm     PRINT_CHAR #10,D3             ; LF
002014CE                          2948mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014CE                 TRUE     2949mm     IFEQ DEBUG
002014CE  1639 00C00003           2950mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014D4  0803 0002               2951mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014D8  67F4                    2952mm       BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
002014DA  13FC 000A 00C00007      2953mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002014E2                          2954mm     ENDC
002014E2                          2955mm     
002014E2                 FALSE    2956mm     IFNE DEBUG
002014E2                          2957mm     ENDC
002014E2                          2958mm 
002014E2                          2959mm     ENDM
002014E2                          2960m     ENDM
002014E2                          2961      
002014E2  4EF9 002004A0           2962              JMP WAIT_FOR_SRECORD      ; ignore any other type    
002014E8                          2963            ENDI
002014E8                          2964s _00000009
002014E8                          2965          ENDI
002014E8                          2966s _00000007
002014E8                          2967        ENDI
002014E8                          2968s _00000004
002014E8                          2969      ENDI
002014E8                          2970s _00000001
002014E8                          2971      
002014E8  4686                    2972      NOT.L D6                        ; ones complement the checksum
002014EA  0286 000000FF           2973      ANDI.L #$FF,D6                  ; and take the LSByte
002014F0                          2974          
002014F0  7E00                    2975      MOVE.L #0,D7                    ; read the checksum from the data stream
002014F2                          2976m     DOWNLOAD D2,D3                  ; top byte
002014F2                          2977m WAIT_FOR_READY_210                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014F2                          2978m 
002014F2  1639 00C00003           2979m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002014F8  0803 0000               2980m     BTST #0,D3                    ; CHECK FOR CHARACTER
002014FC  6700 0010               2981m     BEQ CONTINUE_210                ; NOTHING, CONTINUE
00201500                          2982m  
00201500                          2983mm     READ_CHAR D2
00201500                 TRUE     2984mm     IFEQ DEBUG
00201500  1439 00C00007           2985mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201506                          2986mm     ENDC
00201506                 FALSE    2987mm     IFNE DEBUG
00201506                          2988mm     ENDC
00201506                          2989mm      
00201506  B43C 001B               2990mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020150A  6700 EAFC               2991mm     BEQ START
0020150E                          2992mm     ENDM
0020150E                          2993m CONTINUE_210
0020150E  1639 00C00013           2994m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201514  0803 0000               2995m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201518  67D8                    2996m     BEQ WAIT_FOR_READY_210        ; NOTHING, CHECK AGAIN
0020151A                          2997m     
0020151A  1439 00C00017           2998m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201520  13C2 00E00001           2999m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201526                          3000m     
00201526                          3001m     ENDM
00201526                          3002m     HEX2BIN D2,D2,A0
00201526  41F9 00201B43           3003m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020152C  0402 0030               3004m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201530  C4BC 000000FF           3005m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201536  1430 2000               3006m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020153A                          3007m   ENDM
0020153A  8E82                    3008      OR.L D2,D7
0020153C  E98F                    3009      LSL.L #4,D7
0020153E                          3010m     DOWNLOAD D2,D3                  ; bottom byte
0020153E                          3011m WAIT_FOR_READY_213                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020153E                          3012m 
0020153E  1639 00C00003           3013m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201544  0803 0000               3014m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201548  6700 0010               3015m     BEQ CONTINUE_213                ; NOTHING, CONTINUE
0020154C                          3016m  
0020154C                          3017mm     READ_CHAR D2
0020154C                 TRUE     3018mm     IFEQ DEBUG
0020154C  1439 00C00007           3019mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201552                          3020mm     ENDC
00201552                 FALSE    3021mm     IFNE DEBUG
00201552                          3022mm     ENDC
00201552                          3023mm      
00201552  B43C 001B               3024mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201556  6700 EAB0               3025mm     BEQ START
0020155A                          3026mm     ENDM
0020155A                          3027m CONTINUE_213
0020155A  1639 00C00013           3028m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201560  0803 0000               3029m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201564  67D8                    3030m     BEQ WAIT_FOR_READY_213        ; NOTHING, CHECK AGAIN
00201566                          3031m     
00201566  1439 00C00017           3032m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020156C  13C2 00E00001           3033m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201572                          3034m     
00201572                          3035m     ENDM
00201572                          3036m     HEX2BIN D2,D2,A0
00201572  41F9 00201B43           3037m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201578  0402 0030               3038m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020157C  C4BC 000000FF           3039m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201582  1430 2000               3040m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201586                          3041m   ENDM
00201586  8E82                    3042      OR.L D2,D7
00201588                          3043                  
00201588                          3044      IF.B D7 <NE> D6 THEN.L
00201588  BE06                    3045s     CMP.B   D6,D7
0020158A  6700 00AA               3046s     BEQ.L   _0000000A
0020158E  41F9 00201AF5           3047        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00201594                          3048m       PRINT_STR A0,D3
00201594                          3049m LOOP_216
00201594  0C10 0000               3050m     CMP.B #0,(A0)                 ; 0 -> DONE
00201598  6700 001A               3051m     BEQ EXIT_216
0020159C                          3052mm     PRINT_CHAR (A0)+,D3
0020159C                          3053mm WAIT_FOR_READY_217                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020159C                 TRUE     3054mm     IFEQ DEBUG
0020159C  1639 00C00003           3055mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015A2  0803 0002               3056mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015A6  67F4                    3057mm       BEQ WAIT_FOR_READY_217          ; NO SPACE, CHECK AGAIN
002015A8  13D8 00C00007           3058mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002015AE                          3059mm     ENDC
002015AE                          3060mm     
002015AE                 FALSE    3061mm     IFNE DEBUG
002015AE                          3062mm     ENDC
002015AE                          3063mm 
002015AE                          3064mm     ENDM
002015AE  4EF9 00201594           3065m     JMP LOOP_216
002015B4                          3066m EXIT_216
002015B4                          3067m     ENDM
002015B4                          3068m       PRINT_REG D4,D3,D6,D7,A0
002015B4                          3069mm     PRINT_CHAR #'0',D3          ;0X HEADER
002015B4                          3070mm WAIT_FOR_READY_219                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015B4                 TRUE     3071mm     IFEQ DEBUG
002015B4  1639 00C00003           3072mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015BA  0803 0002               3073mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015BE  67F4                    3074mm       BEQ WAIT_FOR_READY_219          ; NO SPACE, CHECK AGAIN
002015C0  13FC 0030 00C00007      3075mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002015C8                          3076mm     ENDC
002015C8                          3077mm     
002015C8                 FALSE    3078mm     IFNE DEBUG
002015C8                          3079mm     ENDC
002015C8                          3080mm 
002015C8                          3081mm     ENDM
002015C8                          3082mm     PRINT_CHAR #'x',D3
002015C8                          3083mm WAIT_FOR_READY_220                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015C8                 TRUE     3084mm     IFEQ DEBUG
002015C8  1639 00C00003           3085mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015CE  0803 0002               3086mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015D2  67F4                    3087mm       BEQ WAIT_FOR_READY_220          ; NO SPACE, CHECK AGAIN
002015D4  13FC 0078 00C00007      3088mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002015DC                          3089mm     ENDC
002015DC                          3090mm     
002015DC                 FALSE    3091mm     IFNE DEBUG
002015DC                          3092mm     ENDC
002015DC                          3093mm 
002015DC                          3094mm     ENDM
002015DC  7E07                    3095m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002015DE                          3096m LOOP_218
002015DE                          3097mm     BIN2HEX D4,D6,A0
002015DE  41F9 00201B33           3098mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002015E4  E99C                    3099mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002015E6  1C04                    3100mm   MOVE.B D4,D6
002015E8  0286 0000000F           3101mm   ANDI.L #$F,D6
002015EE  1C30 6000               3102mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
002015F2                          3103mm   ENDM
002015F2                          3104mm     PRINT_CHAR D6,D3
002015F2                          3105mm WAIT_FOR_READY_222                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015F2                 TRUE     3106mm     IFEQ DEBUG
002015F2  1639 00C00003           3107mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015F8  0803 0002               3108mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015FC  67F4                    3109mm       BEQ WAIT_FOR_READY_222          ; NO SPACE, CHECK AGAIN
002015FE  13C6 00C00007           3110mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00201604                          3111mm     ENDC
00201604                          3112mm     
00201604                 FALSE    3113mm     IFNE DEBUG
00201604                          3114mm     ENDC
00201604                          3115mm 
00201604                          3116mm     ENDM
00201604  57CF FFD8               3117m     DBEQ D7,LOOP_218
00201608                          3118m     ENDM
00201608                          3119m       PRINT_CRLF D3
00201608                          3120mm     PRINT_CHAR #13,D3             ; CR
00201608                          3121mm WAIT_FOR_READY_224                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201608                 TRUE     3122mm     IFEQ DEBUG
00201608  1639 00C00003           3123mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020160E  0803 0002               3124mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201612  67F4                    3125mm       BEQ WAIT_FOR_READY_224          ; NO SPACE, CHECK AGAIN
00201614  13FC 000D 00C00007      3126mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020161C                          3127mm     ENDC
0020161C                          3128mm     
0020161C                 FALSE    3129mm     IFNE DEBUG
0020161C                          3130mm     ENDC
0020161C                          3131mm 
0020161C                          3132mm     ENDM
0020161C                          3133mm     PRINT_CHAR #10,D3             ; LF
0020161C                          3134mm WAIT_FOR_READY_225                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020161C                 TRUE     3135mm     IFEQ DEBUG
0020161C  1639 00C00003           3136mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201622  0803 0002               3137mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201626  67F4                    3138mm       BEQ WAIT_FOR_READY_225          ; NO SPACE, CHECK AGAIN
00201628  13FC 000A 00C00007      3139mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201630                          3140mm     ENDC
00201630                          3141mm     
00201630                 FALSE    3142mm     IFNE DEBUG
00201630                          3143mm     ENDC
00201630                          3144mm 
00201630                          3145mm     ENDM
00201630                          3146m     ENDM
00201630  4EF9 00200188           3147        JMP MAIN_LOOP
00201636                          3148      ENDI
00201636                          3149s _0000000A
00201636                          3150      
00201636  4ED1                    3151      JMP (A1)
00201638                          3152  DOWNLOAD_DONE
00201638                          3153m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00201638                          3154mm     PRINT_CHAR #'0',D3          ;0X HEADER
00201638                          3155mm WAIT_FOR_READY_227                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201638                 TRUE     3156mm     IFEQ DEBUG
00201638  1639 00C00003           3157mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020163E  0803 0002               3158mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201642  67F4                    3159mm       BEQ WAIT_FOR_READY_227          ; NO SPACE, CHECK AGAIN
00201644  13FC 0030 00C00007      3160mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0020164C                          3161mm     ENDC
0020164C                          3162mm     
0020164C                 FALSE    3163mm     IFNE DEBUG
0020164C                          3164mm     ENDC
0020164C                          3165mm 
0020164C                          3166mm     ENDM
0020164C                          3167mm     PRINT_CHAR #'x',D3
0020164C                          3168mm WAIT_FOR_READY_228                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020164C                 TRUE     3169mm     IFEQ DEBUG
0020164C  1639 00C00003           3170mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201652  0803 0002               3171mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201656  67F4                    3172mm       BEQ WAIT_FOR_READY_228          ; NO SPACE, CHECK AGAIN
00201658  13FC 0078 00C00007      3173mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00201660                          3174mm     ENDC
00201660                          3175mm     
00201660                 FALSE    3176mm     IFNE DEBUG
00201660                          3177mm     ENDC
00201660                          3178mm 
00201660                          3179mm     ENDM
00201660  7C07                    3180m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201662                          3181m LOOP_226
00201662                          3182mm     BIN2HEX D4,D7,A0
00201662  41F9 00201B33           3183mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00201668  E99C                    3184mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020166A  1E04                    3185mm   MOVE.B D4,D7
0020166C  0287 0000000F           3186mm   ANDI.L #$F,D7
00201672  1E30 7000               3187mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00201676                          3188mm   ENDM
00201676                          3189mm     PRINT_CHAR D7,D3
00201676                          3190mm WAIT_FOR_READY_230                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201676                 TRUE     3191mm     IFEQ DEBUG
00201676  1639 00C00003           3192mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020167C  0803 0002               3193mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201680  67F4                    3194mm       BEQ WAIT_FOR_READY_230          ; NO SPACE, CHECK AGAIN
00201682  13C7 00C00007           3195mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00201688                          3196mm     ENDC
00201688                          3197mm     
00201688                 FALSE    3198mm     IFNE DEBUG
00201688                          3199mm     ENDC
00201688                          3200mm 
00201688                          3201mm     ENDM
00201688  57CE FFD8               3202m     DBEQ D6,LOOP_226
0020168C                          3203m     ENDM
0020168C  41F9 00201AAD           3204      LEA READ,A0
00201692                          3205m     PRINT_STR A0,D3
00201692                          3206m LOOP_231
00201692  0C10 0000               3207m     CMP.B #0,(A0)                 ; 0 -> DONE
00201696  6700 001A               3208m     BEQ EXIT_231
0020169A                          3209mm     PRINT_CHAR (A0)+,D3
0020169A                          3210mm WAIT_FOR_READY_232                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020169A                 TRUE     3211mm     IFEQ DEBUG
0020169A  1639 00C00003           3212mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016A0  0803 0002               3213mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016A4  67F4                    3214mm       BEQ WAIT_FOR_READY_232          ; NO SPACE, CHECK AGAIN
002016A6  13D8 00C00007           3215mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002016AC                          3216mm     ENDC
002016AC                          3217mm     
002016AC                 FALSE    3218mm     IFNE DEBUG
002016AC                          3219mm     ENDC
002016AC                          3220mm 
002016AC                          3221mm     ENDM
002016AC  4EF9 00201692           3222m     JMP LOOP_231
002016B2                          3223m EXIT_231
002016B2                          3224m     ENDM
002016B2  2E0A                    3225      MOVE.L A2,D7                    ; set address accumulator to start address
002016B4                          3226m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
002016B4                          3227mm     PRINT_CHAR #'0',D3          ;0X HEADER
002016B4                          3228mm WAIT_FOR_READY_234                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016B4                 TRUE     3229mm     IFEQ DEBUG
002016B4  1639 00C00003           3230mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016BA  0803 0002               3231mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016BE  67F4                    3232mm       BEQ WAIT_FOR_READY_234          ; NO SPACE, CHECK AGAIN
002016C0  13FC 0030 00C00007      3233mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002016C8                          3234mm     ENDC
002016C8                          3235mm     
002016C8                 FALSE    3236mm     IFNE DEBUG
002016C8                          3237mm     ENDC
002016C8                          3238mm 
002016C8                          3239mm     ENDM
002016C8                          3240mm     PRINT_CHAR #'x',D3
002016C8                          3241mm WAIT_FOR_READY_235                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016C8                 TRUE     3242mm     IFEQ DEBUG
002016C8  1639 00C00003           3243mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016CE  0803 0002               3244mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016D2  67F4                    3245mm       BEQ WAIT_FOR_READY_235          ; NO SPACE, CHECK AGAIN
002016D4  13FC 0078 00C00007      3246mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002016DC                          3247mm     ENDC
002016DC                          3248mm     
002016DC                 FALSE    3249mm     IFNE DEBUG
002016DC                          3250mm     ENDC
002016DC                          3251mm 
002016DC                          3252mm     ENDM
002016DC  7C07                    3253m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002016DE                          3254m LOOP_233
002016DE                          3255mm     BIN2HEX D7,D2,A0
002016DE  41F9 00201B33           3256mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002016E4  E99F                    3257mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002016E6  1407                    3258mm   MOVE.B D7,D2
002016E8  0282 0000000F           3259mm   ANDI.L #$F,D2
002016EE  1430 2000               3260mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
002016F2                          3261mm   ENDM
002016F2                          3262mm     PRINT_CHAR D2,D3
002016F2                          3263mm WAIT_FOR_READY_237                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016F2                 TRUE     3264mm     IFEQ DEBUG
002016F2  1639 00C00003           3265mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016F8  0803 0002               3266mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016FC  67F4                    3267mm       BEQ WAIT_FOR_READY_237          ; NO SPACE, CHECK AGAIN
002016FE  13C2 00C00007           3268mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201704                          3269mm     ENDC
00201704                          3270mm     
00201704                 FALSE    3271mm     IFNE DEBUG
00201704                          3272mm     ENDC
00201704                          3273mm 
00201704                          3274mm     ENDM
00201704  57CE FFD8               3275m     DBEQ D6,LOOP_233
00201708                          3276m     ENDM
00201708                          3277m     PRINT_CRLF D3     
00201708                          3278mm     PRINT_CHAR #13,D3             ; CR
00201708                          3279mm WAIT_FOR_READY_239                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201708                 TRUE     3280mm     IFEQ DEBUG
00201708  1639 00C00003           3281mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020170E  0803 0002               3282mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201712  67F4                    3283mm       BEQ WAIT_FOR_READY_239          ; NO SPACE, CHECK AGAIN
00201714  13FC 000D 00C00007      3284mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020171C                          3285mm     ENDC
0020171C                          3286mm     
0020171C                 FALSE    3287mm     IFNE DEBUG
0020171C                          3288mm     ENDC
0020171C                          3289mm 
0020171C                          3290mm     ENDM
0020171C                          3291mm     PRINT_CHAR #10,D3             ; LF
0020171C                          3292mm WAIT_FOR_READY_240                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020171C                 TRUE     3293mm     IFEQ DEBUG
0020171C  1639 00C00003           3294mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201722  0803 0002               3295mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201726  67F4                    3296mm       BEQ WAIT_FOR_READY_240          ; NO SPACE, CHECK AGAIN
00201728  13FC 000A 00C00007      3297mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201730                          3298mm     ENDC
00201730                          3299mm     
00201730                 FALSE    3300mm     IFNE DEBUG
00201730                          3301mm     ENDC
00201730                          3302mm 
00201730                          3303mm     ENDM
00201730                          3304m     ENDM
00201730                          3305          
00201730  4EF9 00200188           3306      JMP MAIN_LOOP
00201736                          3307      
00201736  2047                    3308  G   MOVE.L D7,A0                    ; address accumulator -> address register
00201738  3E3C 0000               3309      MOVE #0,D7                      ; clear the now used address accumulator
0020173C  4ED0                    3310      JMP (A0)                        ; jump to it!
0020173E                          3311      
0020173E  207C 00200000           3312  Z   MOVE.L #RAM,A0                  ; address of RAM
00201744  7000                    3313      MOVE.L #0,D0                    ; number of bytes
00201746                          3314     
00201746                          3315      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
00201746                          3316s _10000006
00201746  B0BC 00040000           3317s     CMP.L   #$40000,D0
0020174C  6E00 001A               3318s     BGT _10000007
00201750                          3319         
00201750  2200                    3320        MOVE.L D0,D1                  ; progress update
00201752  E089                    3321        LSR.L #8,D1 
00201754  E089                    3322        LSR.L #8,D1
00201756  0281 0000000F           3323        ANDI.L #$F,D1
0020175C  13C1 00E00001           3324        MOVE.B D1,DISPLAY
00201762                          3325  
00201762  20C0                    3326        MOVE.L D0,(A0)+ 
00201764  5880                    3327        ADD.L #4,D0
00201766                          3328      ENDW
00201766  60DE                    3329s     BRA _10000006
00201768                          3330s _10000007
00201768                          3331   
00201768  207C 00200000           3332      MOVE.L #RAM,A0              ; address of RAM
0020176E  7000                    3333      MOVE.L #0,D0                ; number of bytes
00201770                          3334     
00201770                          3335      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00201770                          3336s _10000008
00201770  B0BC 00040000           3337s     CMP.L   #$40000,D0
00201776  6E00 00CC               3338s     BGT _10000009
0020177A                          3339  
0020177A  2200                    3340        MOVE.L D0,D1              ; progress update
0020177C  E089                    3341        LSR.L #8,D1
0020177E  E089                    3342        LSR.L #8,D1
00201780  0281 0000000F           3343        ANDI.L #$F,D1
00201786  13C1 00E00001           3344        MOVE.B D1,DISPLAY
0020178C                          3345  
0020178C  2218                    3346        MOVE.L (A0)+,D1
0020178E                          3347        
0020178E                          3348        IF.L D0 <EQ> D1 THEN
0020178E  B081                    3349s     CMP.L   D1,D0
00201790  6600 0006               3350s     BNE _0000000B
00201794  6000 00A8               3351          BRA OK
00201798                          3352        ENDI 
00201798                          3353s _0000000B
00201798                          3354        
00201798  43F9 00201B1B           3355        LEA RAM_ERROR,A1
0020179E                          3356m       PRINT_STR A1,D1
0020179E                          3357m LOOP_241
0020179E  0C11 0000               3358m     CMP.B #0,(A1)                 ; 0 -> DONE
002017A2  6700 001A               3359m     BEQ EXIT_241
002017A6                          3360mm     PRINT_CHAR (A1)+,D1
002017A6                          3361mm WAIT_FOR_READY_242                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017A6                 TRUE     3362mm     IFEQ DEBUG
002017A6  1239 00C00003           3363mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
002017AC  0801 0002               3364mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
002017B0  67F4                    3365mm       BEQ WAIT_FOR_READY_242          ; NO SPACE, CHECK AGAIN
002017B2  13D9 00C00007           3366mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002017B8                          3367mm     ENDC
002017B8                          3368mm     
002017B8                 FALSE    3369mm     IFNE DEBUG
002017B8                          3370mm     ENDC
002017B8                          3371mm 
002017B8                          3372mm     ENDM
002017B8  4EF9 0020179E           3373m     JMP LOOP_241
002017BE                          3374m EXIT_241
002017BE                          3375m     ENDM
002017BE  2208                    3376        MOVE.L A0,D1
002017C0  5981                    3377        SUB.L #4,D1
002017C2                          3378m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
002017C2                          3379mm     PRINT_CHAR #'0',D3          ;0X HEADER
002017C2                          3380mm WAIT_FOR_READY_244                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017C2                 TRUE     3381mm     IFEQ DEBUG
002017C2  1639 00C00003           3382mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017C8  0803 0002               3383mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017CC  67F4                    3384mm       BEQ WAIT_FOR_READY_244          ; NO SPACE, CHECK AGAIN
002017CE  13FC 0030 00C00007      3385mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002017D6                          3386mm     ENDC
002017D6                          3387mm     
002017D6                 FALSE    3388mm     IFNE DEBUG
002017D6                          3389mm     ENDC
002017D6                          3390mm 
002017D6                          3391mm     ENDM
002017D6                          3392mm     PRINT_CHAR #'x',D3
002017D6                          3393mm WAIT_FOR_READY_245                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017D6                 TRUE     3394mm     IFEQ DEBUG
002017D6  1639 00C00003           3395mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017DC  0803 0002               3396mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017E0  67F4                    3397mm       BEQ WAIT_FOR_READY_245          ; NO SPACE, CHECK AGAIN
002017E2  13FC 0078 00C00007      3398mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002017EA                          3399mm     ENDC
002017EA                          3400mm     
002017EA                 FALSE    3401mm     IFNE DEBUG
002017EA                          3402mm     ENDC
002017EA                          3403mm 
002017EA                          3404mm     ENDM
002017EA  7C07                    3405m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002017EC                          3406m LOOP_243
002017EC                          3407mm     BIN2HEX D1,D2,A1
002017EC  43F9 00201B33           3408mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
002017F2  E999                    3409mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002017F4  1401                    3410mm   MOVE.B D1,D2
002017F6  0282 0000000F           3411mm   ANDI.L #$F,D2
002017FC  1431 2000               3412mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00201800                          3413mm   ENDM
00201800                          3414mm     PRINT_CHAR D2,D3
00201800                          3415mm WAIT_FOR_READY_247                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201800                 TRUE     3416mm     IFEQ DEBUG
00201800  1639 00C00003           3417mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201806  0803 0002               3418mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020180A  67F4                    3419mm       BEQ WAIT_FOR_READY_247          ; NO SPACE, CHECK AGAIN
0020180C  13C2 00C00007           3420mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201812                          3421mm     ENDC
00201812                          3422mm     
00201812                 FALSE    3423mm     IFNE DEBUG
00201812                          3424mm     ENDC
00201812                          3425mm 
00201812                          3426mm     ENDM
00201812  57CE FFD8               3427m     DBEQ D6,LOOP_243
00201816                          3428m     ENDM
00201816                          3429m       PRINT_CRLF D3
00201816                          3430mm     PRINT_CHAR #13,D3             ; CR
00201816                          3431mm WAIT_FOR_READY_249                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201816                 TRUE     3432mm     IFEQ DEBUG
00201816  1639 00C00003           3433mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020181C  0803 0002               3434mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201820  67F4                    3435mm       BEQ WAIT_FOR_READY_249          ; NO SPACE, CHECK AGAIN
00201822  13FC 000D 00C00007      3436mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020182A                          3437mm     ENDC
0020182A                          3438mm     
0020182A                 FALSE    3439mm     IFNE DEBUG
0020182A                          3440mm     ENDC
0020182A                          3441mm 
0020182A                          3442mm     ENDM
0020182A                          3443mm     PRINT_CHAR #10,D3             ; LF
0020182A                          3444mm WAIT_FOR_READY_250                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020182A                 TRUE     3445mm     IFEQ DEBUG
0020182A  1639 00C00003           3446mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201830  0803 0002               3447mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201834  67F4                    3448mm       BEQ WAIT_FOR_READY_250          ; NO SPACE, CHECK AGAIN
00201836  13FC 000A 00C00007      3449mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020183E                          3450mm     ENDC
0020183E                          3451mm     
0020183E                 FALSE    3452mm     IFNE DEBUG
0020183E                          3453mm     ENDC
0020183E                          3454mm 
0020183E                          3455mm     ENDM
0020183E                          3456m     ENDM
0020183E                          3457  OK    
0020183E  5880                    3458        ADD.L #4,D0
00201840                          3459      ENDW
00201840  6000 FF2E               3460s     BRA _10000008
00201844                          3461s _10000009
00201844                          3462      
00201844  4EF9 00200188           3463      JMP MAIN_LOOP
0020184A                          3464    
0020184A  7A00                    3465  L   MOVE.L #0,D5                    ; D5 will be the length  to write            
0020184C                          3466  
0020184C                          3467m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
0020184C                          3468m WAIT_FOR_READY_251                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020184C                          3469m 
0020184C                 TRUE     3470m     IFEQ DEBUG
0020184C  1639 00C00003           3471m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00201852  0803 0000               3472m       BTST #0,D3                    ; CHECK FOR CHARACTER
00201856  67F4                    3473m       BEQ WAIT_FOR_READY_251          ; NOTHING, CHECK AGAIN
00201858                          3474m     ENDC
00201858                          3475m     
00201858                          3476mm     READ_CHAR D2
00201858                 TRUE     3477mm     IFEQ DEBUG
00201858  1439 00C00007           3478mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020185E                          3479mm     ENDC
0020185E                 FALSE    3480mm     IFNE DEBUG
0020185E                          3481mm     ENDC
0020185E                          3482mm      
0020185E  B43C 001B               3483mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201862  6700 E7A4               3484mm     BEQ START
00201866                          3485mm     ENDM
00201866                          3486m 
00201866                 TRUE     3487m     IFEQ DEBUG
00201866                          3488mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
00201866                          3489mm WAIT_FOR_READY_253                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201866                 TRUE     3490mm     IFEQ DEBUG
00201866  1639 00C00003           3491mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020186C  0803 0002               3492mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201870  67F4                    3493mm       BEQ WAIT_FOR_READY_253          ; NO SPACE, CHECK AGAIN
00201872  13C2 00C00007           3494mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201878                          3495mm     ENDC
00201878                          3496mm     
00201878                 FALSE    3497mm     IFNE DEBUG
00201878                          3498mm     ENDC
00201878                          3499mm 
00201878                          3500mm     ENDM
00201878                          3501m     ENDC
00201878                          3502m     ENDM
00201878                          3503m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00201878  41F9 00201B43           3504m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020187E  0402 0030               3505m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201882  C4BC 000000FF           3506m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201888  1430 2000               3507m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020188C                          3508m   ENDM
0020188C  1A02                    3509      MOVE.B D2,D5                    ; put at bottom of D5
0020188E                          3510  
0020188E  3C3C 0002               3511      MOVE #2,D6                      ; 3 bytes left to read
00201892                          3512      
00201892                          3513  READ_LENGTH
00201892  E98D                    3514      LSL.L #4,D5                     ; make what we have so far more significant
00201894                          3515m     WAIT_CHAR D2,D3                 ; next character -> D2
00201894                          3516m WAIT_FOR_READY_255                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201894                          3517m 
00201894                 TRUE     3518m     IFEQ DEBUG
00201894  1639 00C00003           3519m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
0020189A  0803 0000               3520m       BTST #0,D3                    ; CHECK FOR CHARACTER
0020189E  67F4                    3521m       BEQ WAIT_FOR_READY_255          ; NOTHING, CHECK AGAIN
002018A0                          3522m     ENDC
002018A0                          3523m     
002018A0                          3524mm     READ_CHAR D2
002018A0                 TRUE     3525mm     IFEQ DEBUG
002018A0  1439 00C00007           3526mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002018A6                          3527mm     ENDC
002018A6                 FALSE    3528mm     IFNE DEBUG
002018A6                          3529mm     ENDC
002018A6                          3530mm      
002018A6  B43C 001B               3531mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002018AA  6700 E75C               3532mm     BEQ START
002018AE                          3533mm     ENDM
002018AE                          3534m 
002018AE                 TRUE     3535m     IFEQ DEBUG
002018AE                          3536mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002018AE                          3537mm WAIT_FOR_READY_257                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018AE                 TRUE     3538mm     IFEQ DEBUG
002018AE  1639 00C00003           3539mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018B4  0803 0002               3540mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018B8  67F4                    3541mm       BEQ WAIT_FOR_READY_257          ; NO SPACE, CHECK AGAIN
002018BA  13C2 00C00007           3542mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002018C0                          3543mm     ENDC
002018C0                          3544mm     
002018C0                 FALSE    3545mm     IFNE DEBUG
002018C0                          3546mm     ENDC
002018C0                          3547mm 
002018C0                          3548mm     ENDM
002018C0                          3549m     ENDC
002018C0                          3550m     ENDM
002018C0                          3551m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002018C0  41F9 00201B43           3552m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002018C6  0402 0030               3553m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002018CA  C4BC 000000FF           3554m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002018D0  1430 2000               3555m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002018D4                          3556m   ENDM
002018D4  8A02                    3557      OR.B D2,D5
002018D6  023C 00FB               3558      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
002018DA  57CE FFB6               3559      DBEQ D6,READ_LENGTH
002018DE                          3560          
002018DE                          3561m     PRINT_CRLF D3
002018DE                          3562mm     PRINT_CHAR #13,D3             ; CR
002018DE                          3563mm WAIT_FOR_READY_260                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018DE                 TRUE     3564mm     IFEQ DEBUG
002018DE  1639 00C00003           3565mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018E4  0803 0002               3566mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018E8  67F4                    3567mm       BEQ WAIT_FOR_READY_260          ; NO SPACE, CHECK AGAIN
002018EA  13FC 000D 00C00007      3568mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002018F2                          3569mm     ENDC
002018F2                          3570mm     
002018F2                 FALSE    3571mm     IFNE DEBUG
002018F2                          3572mm     ENDC
002018F2                          3573mm 
002018F2                          3574mm     ENDM
002018F2                          3575mm     PRINT_CHAR #10,D3             ; LF
002018F2                          3576mm WAIT_FOR_READY_261                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018F2                 TRUE     3577mm     IFEQ DEBUG
002018F2  1639 00C00003           3578mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018F8  0803 0002               3579mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018FC  67F4                    3580mm       BEQ WAIT_FOR_READY_261          ; NO SPACE, CHECK AGAIN
002018FE  13FC 000A 00C00007      3581mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201906                          3582mm     ENDC
00201906                          3583mm     
00201906                 FALSE    3584mm     IFNE DEBUG
00201906                          3585mm     ENDC
00201906                          3586mm 
00201906                          3587mm     ENDM
00201906                          3588m     ENDM
00201906                          3589  
00201906  207C 00000000           3590      MOVE.L #ROM,A0                  ; start of ROM
0020190C                          3591      
0020190C  2247                    3592      MOVE.L D7,A1                    ; address accumulator -> address register
0020190E  7E00                    3593      MOVE.L #0,D7                    ; clear the now used address accumulator
00201910                          3594      
00201910  267C 00002AAA           3595      MOVE.L #$2AAA,A3
00201916  36BC AAAA               3596      MOVE.W #$AAAA,(A3)
0020191A  267C 00001554           3597      MOVE.L #$1554,A3
00201920  36BC 5555               3598      MOVE.W #$5555,(A3)
00201924  267C 00002AAA           3599      MOVE.L #$2AAA,A3
0020192A  36BC 8080               3600      MOVE.W #$8080,(A3)
0020192E  267C 00002AAA           3601      MOVE.L #$2AAA,A3
00201934  36BC AAAA               3602      MOVE.W #$AAAA,(A3)
00201938  267C 00001554           3603      MOVE.L #$1554,A3
0020193E  36BC 5555               3604      MOVE.W #$5555,(A3)
00201942  267C 00002AAA           3605      MOVE.L #$2AAA,A3
00201948  36BC 2020               3606      MOVE.W #$2020,(A3)
0020194C                          3607      
0020194C  45F9 00201B5A           3608      LEA LOADING,A2                ; important for timing
00201952                          3609m     PRINT_STR A2,D3
00201952                          3610m LOOP_262
00201952  0C12 0000               3611m     CMP.B #0,(A2)                 ; 0 -> DONE
00201956  6700 001A               3612m     BEQ EXIT_262
0020195A                          3613mm     PRINT_CHAR (A2)+,D3
0020195A                          3614mm WAIT_FOR_READY_263                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020195A                 TRUE     3615mm     IFEQ DEBUG
0020195A  1639 00C00003           3616mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201960  0803 0002               3617mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201964  67F4                    3618mm       BEQ WAIT_FOR_READY_263          ; NO SPACE, CHECK AGAIN
00201966  13DA 00C00007           3619mm       MOVE.B (A2)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020196C                          3620mm     ENDC
0020196C                          3621mm     
0020196C                 FALSE    3622mm     IFNE DEBUG
0020196C                          3623mm     ENDC
0020196C                          3624mm 
0020196C                          3625mm     ENDM
0020196C  4EF9 00201952           3626m     JMP LOOP_262
00201972                          3627m EXIT_262
00201972                          3628m     ENDM
00201972                          3629  
00201972  023C 00FB               3630      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00201976                          3631      ;MOVE.L #0,D1
00201976                          3632      
00201976                          3633      WHILE D5 <GT> #0 DO
00201976                          3634s _1000000A
00201976  BA7C 0000               3635s     CMP.W   #0,D5
0020197A  6F00 0020               3636s     BLE _1000000B
0020197E  5585                    3637        SUB.L #2,D5
00201980                          3638        
00201980  13D1 00E00001           3639        MOVE.B (A1),DISPLAY
00201986  3091                    3640        MOVE.W (A1),(A0)            ; write the data
00201988                          3641  
00201988                          3642        ;PRINT_CHAR #'W',D3
00201988                          3643        ;MOVE.L #0,D3
00201988                          3644        ;MOVE.W (A1),D3
00201988                          3645        ;PRINT_REG D3,D4,D7,D6,A2
00201988                          3646        ;PRINT_CRLF D3      
00201988                          3647        
00201988                          3648    WAIT_FOR_COMPLETE:
00201988                          3649        ;PRINT_CHAR #'R',D2
00201988  3410                    3650        MOVE.W (A0),D2
0020198A                          3651  
0020198A                          3652        ;PRINT_REG D2,D3,D7,D6,A2
0020198A                          3653        ;PRINT_CRLF D3      
0020198A                          3654        
0020198A                          3655        IF D2 <NE> (A1) THEN
0020198A  B451                    3656s     CMP.W   (A1),D2
0020198C  6700 0008               3657s     BEQ _0000000C
00201990                          3658  
00201990                          3659          ;PRINT_CHAR #'.',D2
00201990                          3660          
00201990  4EF9 00201988           3661          JMP WAIT_FOR_COMPLETE
00201996                          3662        ENDI
00201996                          3663s _0000000C
00201996                          3664  
00201996                          3665        ;PRINT_CHAR #'c',D2
00201996                          3666        ;PRINT_CRLF D3      
00201996                          3667        
00201996  5488                    3668        ADD.L #2,A0
00201998  5489                    3669        ADD.L #2,A1
0020199A                          3670  
0020199A                          3671        ;ADD.L #1,D1
0020199A                          3672        ;IF D1 <EQ> #64 THEN
0020199A                          3673   
0020199A                          3674          ;PRINT_CHAR #'A',D2
0020199A                          3675          ;MOVE.L A0,D0
0020199A                          3676          ;PRINT_REG D0,D3,D7,D6,A2
0020199A                          3677          ;PRINT_CRLF D3      
0020199A                          3678        ;ENDI
0020199A                          3679      ENDW  
0020199A  60DA                    3680s     BRA _1000000A
0020199C                          3681s _1000000B
0020199C                          3682      
0020199C  267C 00002AAA           3683      MOVE.L #$2AAA,A3
002019A2  36BC AAAA               3684      MOVE.W #$AAAA,(A3)
002019A6  267C 00001554           3685      MOVE.L #$1554,A3
002019AC  36BC 5555               3686      MOVE.W #$5555,(A3)
002019B0  267C 00002AAA           3687      MOVE.L #$2AAA,A3
002019B6  36BC A0A0               3688      MOVE.W #$A0A0,(A3)
002019BA                          3689              
002019BA  4EF9 00200188           3690      JMP MAIN_LOOP
002019C0                          3691          
002019C0                          3692  HEX_DIGIT
002019C0  E98F                    3693      LSL.L #4,D7                    ; add the next digit in the next 4 bits
002019C2                          3694m     HEX2BIN D2,D2,A0
002019C2  41F9 00201B43           3695m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002019C8  0402 0030               3696m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002019CC  C4BC 000000FF           3697m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002019D2  1430 2000               3698m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002019D6                          3699m   ENDM
002019D6  8E02                    3700      OR.B D2,D7  
002019D8  4EF9 002001B0           3701      JMP GET_INPUT
002019DE                          3702  
002019DE  FFFF FFFF               3703      SIMHALT                         ; halt simulator
002019E2                          3704  
002019E2                          3705  ; strings
002019E2= 4D 44 46 2D 6D 6F ...   3706  VERSION DC.B 'MDF-mon V1.30 (07/04/2021)',13,10,0
002019FF= 3F 20 48 65 6C 70 ...   3707  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201A96= 48 75 68 3F 0D 0A 00    3708  HUH     DC.B 'Huh?',13,10,0
00201A9D= 55 6E 69 6D 70 6C ...   3709  UNIMP   DC.B 'Unimplemented',13,10,0
00201AAD= 20 53 20 72 65 63 ...   3710  READ    DC.B ' S records read, start address = ',0
00201ACF= 57 41 52 4E 49 4E ...   3711  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00201AF5= 57 41 52 4E 49 4E ...   3712  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00201B1B= 57 41 52 4E 49 4E ...   3713  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
00201B33= 30 31 32 33 34 35 ...   3714  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201B43= 00 01 02 03 04 05 ...   3715  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201B5A= 4C 6F 61 64 69 6E ...   3716  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201B6E                          3717      
00201B6E                          3718      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201B33
CONTINUE_100        200A6A
CONTINUE_104        200AC8
CONTINUE_108        200B28
CONTINUE_112        200B86
CONTINUE_116        200BF8
CONTINUE_120        200C56
CONTINUE_127        200CFE
CONTINUE_131        200D5C
CONTINUE_135        200DBC
CONTINUE_139        200E1A
CONTINUE_143        200E7E
CONTINUE_147        200EDC
CONTINUE_151        200F52
CONTINUE_155        200FB0
CONTINUE_159        20102A
CONTINUE_163        201088
CONTINUE_167        2010E8
CONTINUE_171        201146
CONTINUE_175        2011B8
CONTINUE_179        201216
CONTINUE_186        2012BE
CONTINUE_189        20130A
CONTINUE_192        201358
CONTINUE_195        2013A4
CONTINUE_198        2013F6
CONTINUE_201        201442
CONTINUE_210        20150E
CONTINUE_213        20155A
CONTINUE_44         2004BC
CONTINUE_46         2004F8
CONTINUE_48         200530
CONTINUE_51         20057C
CONTINUE_54         2005D2
CONTINUE_57         20061E
CONTINUE_60         20066C
CONTINUE_63         2006B8
CONTINUE_66         200718
CONTINUE_69         200764
CONTINUE_76         200802
CONTINUE_80         200860
CONTINUE_84         2008C0
CONTINUE_88         20091E
CONTINUE_92         200994
CONTINUE_96         2009F2
CS_FAILURE          201AF5
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       201638
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EVEN                200A40
EVEN2               200FFE
EXIT_19             2002EA
EXIT_204            2014A8
EXIT_21             200316
EXIT_216            2015B4
EXIT_23             200342
EXIT_231            2016B2
EXIT_241            2017BE
EXIT_262            201972
EXIT_5              200142
G                   201736
GET_INPUT           2001B0
H                   2002F0
HELP                2019FF
HEX2BIN             12B
HEX2BIN_LUT         201B43
HEX_DIGIT           2019C0
HUH                 201A96
L                   20184A
LOADING             201B5A
LOOP_19             2002CA
LOOP_204            201488
LOOP_21             2002F6
LOOP_216            201594
LOOP_218            2015DE
LOOP_226            201662
LOOP_23             200322
LOOP_231            201692
LOOP_233            2016DE
LOOP_241            20179E
LOOP_243            2017EC
LOOP_25             200376
LOOP_262            201952
LOOP_5              200122
MAIN_LOOP           200188
OK                  20183E
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   200348
RAM                 200000
RAM_ERROR           201B1B
READ                201AAD
READ_CHAR           79D
READ_DATA_TO_POKE   200418
READ_LENGTH         201892
RESET               200004
ROM                 0
RRRR                200000
S                   200498
STACK               200000
START               200008
UNIMP               201A9D
UNREC               201ACF
V                   20031C
VERSION             2019E2
W                   2003D0
WAIT_CHAR           615
WAIT_FOR_COMPLETE   201988
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  200A4E
WAIT_FOR_READY_102  200A82
WAIT_FOR_READY_104  200AAC
WAIT_FOR_READY_106  200AE0
WAIT_FOR_READY_108  200B0C
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200B40
WAIT_FOR_READY_112  200B6A
WAIT_FOR_READY_114  200B9E
WAIT_FOR_READY_116  200BDC
WAIT_FOR_READY_118  200C10
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_120  200C3A
WAIT_FOR_READY_122  200C6E
WAIT_FOR_READY_125  200CA6
WAIT_FOR_READY_126  200CBA
WAIT_FOR_READY_127  200CE2
WAIT_FOR_READY_129  200D16
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D40
WAIT_FOR_READY_133  200D74
WAIT_FOR_READY_135  200DA0
WAIT_FOR_READY_137  200DD4
WAIT_FOR_READY_139  200DFE
WAIT_FOR_READY_141  200E32
WAIT_FOR_READY_143  200E62
WAIT_FOR_READY_145  200E96
WAIT_FOR_READY_147  200EC0
WAIT_FOR_READY_149  200EF4
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200F36
WAIT_FOR_READY_153  200F6A
WAIT_FOR_READY_155  200F94
WAIT_FOR_READY_157  200FC8
WAIT_FOR_READY_159  20100E
WAIT_FOR_READY_161  201042
WAIT_FOR_READY_163  20106C
WAIT_FOR_READY_165  2010A0
WAIT_FOR_READY_167  2010CC
WAIT_FOR_READY_169  201100
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  20112A
WAIT_FOR_READY_173  20115E
WAIT_FOR_READY_175  20119C
WAIT_FOR_READY_177  2011D0
WAIT_FOR_READY_179  2011FA
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  20122E
WAIT_FOR_READY_184  201266
WAIT_FOR_READY_185  20127A
WAIT_FOR_READY_186  2012A2
WAIT_FOR_READY_189  2012EE
WAIT_FOR_READY_192  20133C
WAIT_FOR_READY_195  201388
WAIT_FOR_READY_198  2013DA
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  201426
WAIT_FOR_READY_205  201490
WAIT_FOR_READY_206  2014A8
WAIT_FOR_READY_208  2014BA
WAIT_FOR_READY_209  2014CE
WAIT_FOR_READY_210  2014F2
WAIT_FOR_READY_213  20153E
WAIT_FOR_READY_217  20159C
WAIT_FOR_READY_219  2015B4
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_220  2015C8
WAIT_FOR_READY_222  2015F2
WAIT_FOR_READY_224  201608
WAIT_FOR_READY_225  20161C
WAIT_FOR_READY_227  201638
WAIT_FOR_READY_228  20164C
WAIT_FOR_READY_230  201676
WAIT_FOR_READY_232  20169A
WAIT_FOR_READY_234  2016B4
WAIT_FOR_READY_235  2016C8
WAIT_FOR_READY_237  2016F2
WAIT_FOR_READY_239  201708
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_240  20171C
WAIT_FOR_READY_242  2017A6
WAIT_FOR_READY_244  2017C2
WAIT_FOR_READY_245  2017D6
WAIT_FOR_READY_247  201800
WAIT_FOR_READY_249  201816
WAIT_FOR_READY_250  20182A
WAIT_FOR_READY_251  20184C
WAIT_FOR_READY_253  201866
WAIT_FOR_READY_255  201894
WAIT_FOR_READY_257  2018AE
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_260  2018DE
WAIT_FOR_READY_261  2018F2
WAIT_FOR_READY_263  20195A
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DC
WAIT_FOR_READY_48   200514
WAIT_FOR_READY_51   200560
WAIT_FOR_READY_54   2005B6
WAIT_FOR_READY_57   200602
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200650
WAIT_FOR_READY_63   20069C
WAIT_FOR_READY_66   2006FC
WAIT_FOR_READY_69   200748
WAIT_FOR_READY_72   200794
WAIT_FOR_READY_74   2007AA
WAIT_FOR_READY_75   2007BE
WAIT_FOR_READY_76   2007E6
WAIT_FOR_READY_78   20081A
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   200844
WAIT_FOR_READY_82   200878
WAIT_FOR_READY_84   2008A4
WAIT_FOR_READY_86   2008D8
WAIT_FOR_READY_88   200902
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   200936
WAIT_FOR_READY_92   200978
WAIT_FOR_READY_94   2009AC
WAIT_FOR_READY_96   2009D6
WAIT_FOR_READY_98   200A0A
WAIT_FOR_SRECORD    2004A0
Z                   20173E
_00000000           2007DC
_00000001           2014E8
_00000002           200CD8
_00000003           200CA6
_00000004           2014E8
_00000005           201298
_00000006           201266
_00000007           2014E8
_00000008           201482
_00000009           2014E8
_0000000A           201636
_0000000B           201798
_0000000C           201996
_10000000           2006EE
_10000001           2007AA
_10000002           200A40
_10000003           200BD2
_10000004           201000
_10000005           201192
_10000006           201746
_10000007           201768
_10000008           201770
_10000009           201844
_1000000A           201976
_1000000B           20199C
