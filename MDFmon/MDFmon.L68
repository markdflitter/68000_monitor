00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 07/04/2021 19:33:40

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; fix the DUART base address
00000000                             9  ; tidy up layout (indentation and comments)
00000000                            10  ; tidy up NAND gate invertor and wiring for OE and WE on eeproms
00000000                            11  ; tidy up power loom
00000000                            12  ; add LDS and UDS with an OR gate and test
00000000                            13  ; add simpler .W and .B variants of PRINT_REG
00000000                            14  ; stop using two registers in download
00000000                            15  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            16  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            17  
00000000                            18  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            19  ; keep track of highest address hit during srec download
00000000                            20  ; fix the reset vector so that it jumps to the start
00000000                            21  ; Replace JMP -> BRA
00000000                            22  ; implement backspace
00000000                            23  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            24  ; fix being able to enter random chars when W'ing
00000000                            25  ; ram check at startup?  Not sure if this is a good idea!
00000000                            26  
00000000                            27  
00000000                            28      ;ORG  $0
00200000                            29      ORG  $200000
00200000                            30  
00200000  =00000000                 31  DEBUG               EQU 0
00200000                            32  
00200000                            33  
00200000                            34  ; constants
00200000  =00000000                 35  ROM                 EQU $0
00200000  =00200000                 36  RAM                 EQU $200000
00200000                            37  
00200000  =00E00000                 38  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 39  DISPLAY_            EQU $0
00200000  =00E00001                 40  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            41     
00200000  =00D30000                 42  DUART_BASE          EQU $D30000
00200000  =00000000                 43  DUART_MRA_          EQU $0
00200000  =00000001                 44  DUART_CSRA_         EQU $1
00200000  =00000001                 45  DUART_SRA_          EQU $1
00200000  =00000002                 46  DUART_CRA_          EQU $2
00200000  =00000003                 47  DUART_TXA_          EQU $3
00200000  =00000003                 48  DUART_RXA_          EQU $3
00200000  =00000004                 49  DUART_ACR_          EQU $4
00200000  =00000005                 50  DUART_IMR_          EQU $5
00200000  =00000008                 51  DUART_MRB_          EQU $8
00200000  =00000009                 52  DUART_CSRB_         EQU $9
00200000  =00000009                 53  DUART_SRB_          EQU $9
00200000  =0000000A                 54  DUART_CRB_          EQU $A
00200000  =0000000B                 55  DUART_TXB_          EQU $B
00200000  =0000000B                 56  DUART_RXB_          EQU $B
00200000  =0000000C                 57  DUART_IVR_          EQU $C
00200000  =0000000D                 58  DUART_OPCR_         EQU $D
00200000  =0000000E                 59  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 60  DUART_RESET_OPR_    EQU $F
00200000                            61  RRRR
00200000  =00D30001                 62  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00D30003                 63  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00D30003                 64  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00D30005                 65  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00D30007                 66  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00D30007                 67  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            68  
00200000  =00D30011                 69  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00D30013                 70  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00D30013                 71  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00D30015                 72  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00D30017                 73  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00D30017                 74  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            75  
00200000  =00D30009                 76  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00D3000B                 77  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00D30019                 78  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00D3001B                 79  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00D3001D                 80  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00D3001F                 81  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            82  
00200000                            83  ; macros
00200000                            84  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            85  ; the input register is changed during the process
00200000                            86  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            87  BIN2HEX MACRO
00200000                            88    LEA BIN2HEX_LUT,\3                ; load the lookup table
00200000                            89    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            90    MOVE.B \1,\2
00200000                            91    ANDI.L #$F,\2
00200000                            92    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00200000                            93    ENDM
00200000                            94  
00200000                            95  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            96  ; the input register is changed during the process
00200000                            97  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            98  HEX2BIN MACRO
00200000                            99    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00200000                           100    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00200000                           101    AND.L #$FF,\1                       ; ignore the top 3 bytes
00200000                           102    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00200000                           103    ENDM
00200000                           104  
00200000                           105  ; send a single char to the serial port
00200000                           106  ; \1 = char to send, \2 = data register to use for status poll
00200000                           107  ; will stamp on D0 and D1 in debug mode
00200000                           108  PRINT_CHAR MACRO
00200000                           109  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           110      IFEQ DEBUG
00200000                           111        MOVE.B DUART_SRA,\2           ; read status register
00200000                           112        BTST #2,\2                    ; check for space to send
00200000                           113        BEQ WAIT_FOR_READY\@          ; no space, check again
00200000                           114        MOVE.B \1,DUART_TXA           ; send the next character
00200000                           115      ENDC
00200000                           116      
00200000                           117      IFNE DEBUG
00200000                           118        MOVE.B \1,D1
00200000                           119        MOVE.L #6,D0   
00200000                           120        TRAP #15                      ; write to terminal in simulator
00200000                           121      ENDC
00200000                           122  
00200000                           123      ENDM
00200000                           124  
00200000                           125  ; send CR,LF to the serial port
00200000                           126  ; \1 = data register to use for status poll
00200000                           127  PRINT_CRLF MACRO                  
00200000                           128      PRINT_CHAR #13,\1             ; CR
00200000                           129      PRINT_CHAR #10,\1             ; LF
00200000                           130      ENDM
00200000                           131  
00200000                           132  ; send C-style, zero terminated string to the serial port
00200000                           133  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           134  PRINT_STR MACRO
00200000                           135  LOOP\@
00200000                           136      CMP.B #0,(\1)                 ; 0 -> done
00200000                           137      BEQ EXIT\@
00200000                           138      PRINT_CHAR (\1)+,\2
00200000                           139      JMP LOOP\@
00200000                           140  EXIT\@
00200000                           141      ENDM
00200000                           142    
00200000                           143  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           144  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           145  PRINT_REG MACRO
00200000                           146      PRINT_CHAR #'0',\2          ;0x header
00200000                           147      PRINT_CHAR #'x',\2
00200000                           148      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00200000                           149  LOOP\@
00200000                           150      BIN2HEX \1,\3,\5
00200000                           151      PRINT_CHAR \3,\2
00200000                           152      DBEQ \4,LOOP\@
00200000                           153      ENDM
00200000                           154    
00200000                           155  ; wait for a char from the serial port
00200000                           156  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           157  ; will stamp on D0 and D1 in debug mode
00200000                           158  WAIT_CHAR MACRO
00200000                           159  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           160  
00200000                           161      IFEQ DEBUG
00200000                           162        MOVE.B DUART_SRA,\2         ; read status register
00200000                           163        BTST #0,\2                    ; check for character
00200000                           164        BEQ WAIT_FOR_READY\@          ; nothing, check again
00200000                           165      ENDC
00200000                           166      
00200000                           167      READ_CHAR \1
00200000                           168  
00200000                           169      IFEQ DEBUG
00200000                           170        PRINT_CHAR \1,\2            ; echo it back
00200000                           171      ENDC
00200000                           172      ENDM
00200000                           173      
00200000                           174  ; read a char from the serial port - assumes that there is one!
00200000                           175  ; \ 1= data register for read char
00200000                           176  ; will stamp on D0 and D1 in debug mode
00200000                           177  READ_CHAR MACRO
00200000                           178      IFEQ DEBUG
00200000                           179        MOVE.B DUART_RXA,\1         ; got a character, read it
00200000                           180      ENDC
00200000                           181      IFNE DEBUG
00200000                           182        MOVE.L #5,D0    
00200000                           183        TRAP #15                    ; read from keyboard in simulator
00200000                           184        MOVE.L D1,\1
00200000                           185      ENDC
00200000                           186       
00200000                           187      CMP.B #$1B,\1                 ; check for escape and go to start
00200000                           188      BEQ START
00200000                           189      ENDM
00200000                           190      
00200000                           191      
00200000                           192  ; read data from the download serial port
00200000                           193  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           194  DOWNLOAD MACRO
00200000                           195  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           196  
00200000                           197      MOVE.B DUART_SRA,\2           ; check for command
00200000                           198      BTST #0,\2                    ; check for character
00200000                           199      BEQ CONTINUE\@                ; nothing, continue
00200000                           200   
00200000                           201      READ_CHAR \1
00200000                           202  CONTINUE\@
00200000                           203      MOVE.B DUART_SRB,\2         ; read status register
00200000                           204      BTST #0,\2                  ; check for character
00200000                           205      BEQ WAIT_FOR_READY\@        ; nothing, check again
00200000                           206      
00200000                           207      MOVE.B DUART_RXB,\1         ; got a character, read it
00200000                           208      MOVE.B \1,DISPLAY           ; echo to the display
00200000                           209      
00200000                           210      ENDM
00200000                           211  
00200000                           212  
00200000                           213  ; register catalogue
00200000                           214  ; D0 - used for simulator I/O
00200000                           215  ; D1 - used for simulator I/O
00200000                           216  ; D2 - read character
00200000                           217  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           218  ; D4 - count of S records read
00200000                           219  ; D5 - data to write / data read / byte count for S record load
00200000                           220  ; D6 - working register used in R/W and download
00200000                           221  ; D7 - address accumulator / reset by download
00200000                           222  ; A0 - address of string to print 
00200000                           223  
00200000                           224  ; start vector
00200000= 00000000                 225  STACK    DC.L $00000000              ; STACK
00200004= 00200008                 226  RESET    DC.L START                  ; RESET
00200008                           227      
00200008                           228  ; start of program  
00200008                           229  START
00200008  13FC 0000 00E00001       230      MOVE.B #0,DISPLAY
00200010                           231  
00200010                           232  ; reset the UART in case of warm start
00200010  13FC 000A 00D30005       233      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00200018  13FC 0050 00D30005       234      MOVE.B #$50,DUART_CRA           ; reset everyting
00200020  4E71                     235      NOP
00200022  13FC 0040 00D30005       236      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     237      NOP
0020002C  13FC 0030 00D30005       238      MOVE.B #$30,DUART_CRA
00200034  4E71                     239      NOP
00200036  13FC 0020 00D30005       240      MOVE.B #$20,DUART_CRA
0020003E  4E71                     241      NOP
00200040  13FC 0010 00D30005       242      MOVE.B #$10,DUART_CRA   
00200048                           243  
00200048  13FC 000A 00D30015       244      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00200050  13FC 0050 00D30015       245      MOVE.B #$50,DUART_CRB           ; reset everyting
00200058  4E71                     246      NOP
0020005A  13FC 0040 00D30015       247      MOVE.B #$40,DUART_CRB           
00200062  4E71                     248      NOP
00200064  13FC 0030 00D30015       249      MOVE.B #$30,DUART_CRB
0020006C  4E71                     250      NOP
0020006E  13FC 0020 00D30015       251      MOVE.B #$20,DUART_CRB
00200076  4E71                     252      NOP
00200078  13FC 0010 00D30015       253      MOVE.B #$10,DUART_CRB   
00200080                           254  
00200080                           255  ;initialise UART
00200080  13FC 0000 00D30009       256      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00D3000B       257      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00200090  13FC 0000 00D3001B       258      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00200098                           259  
00200098                           260  ; channel A
00200098  13FC 0013 00D30001       261      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00D30001       262      MOVE.B #$07,DUART_MRA           ; 1 stop bit
002000A8  13FC 00BB 00D30003       263      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
002000B0  13FC 0005 00D30005       264      MOVE.B #$5,DUART_CRA            ; enable rx & tx
002000B8                           265  
002000B8                           266  ; channel B
002000B8  13FC 0013 00D30011       267      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00D30011       268      MOVE.B #$07,DUART_MRB           ; 1 stop bit
002000C8  13FC 00BB 00D30013       269      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
002000D0  13FC 0005 00D30015       270      MOVE.B #$5,DUART_CRB            ; enable rx & tx
002000D8                           271  
002000D8                           272m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
002000D8                           273m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      274m     IFEQ DEBUG
002000D8  1639 00D30003            275m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000DE  0803 0002                276m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000E2  67F4                     277m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00D30007       278m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
002000EC                           279m     ENDC
002000EC                           280m     
002000EC                 FALSE     281m     IFNE DEBUG
002000EC                           282m     ENDC
002000EC                           283m 
002000EC                           284m     ENDM
002000EC                           285  
002000EC  13FC 0001 00E00001       286      MOVE.B #1,DISPLAY
002000F4                           287         
002000F4                           288m     PRINT_CRLF D3
002000F4                           289mm     PRINT_CHAR #13,D3             ; CR
002000F4                           290mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      291mm     IFEQ DEBUG
002000F4  1639 00D30003            292mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000FA  0803 0002                293mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000FE  67F4                     294mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00D30007       295mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200108                           296mm     ENDC
00200108                           297mm     
00200108                 FALSE     298mm     IFNE DEBUG
00200108                           299mm     ENDC
00200108                           300mm 
00200108                           301mm     ENDM
00200108                           302mm     PRINT_CHAR #10,D3             ; LF
00200108                           303mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      304mm     IFEQ DEBUG
00200108  1639 00D30003            305mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020010E  0803 0002                306mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200112  67F4                     307mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00D30007       308mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020011C                           309mm     ENDC
0020011C                           310mm     
0020011C                 FALSE     311mm     IFNE DEBUG
0020011C                           312mm     ENDC
0020011C                           313mm 
0020011C                           314mm     ENDM
0020011C                           315m     ENDM
0020011C                           316  
0020011C  41F9 002019F2            317      LEA VERSION,A0
00200122                           318m     PRINT_STR A0,D3
00200122                           319m LOOP_5
00200122  0C10 0000                320m     CMP.B #0,(A0)                 ; 0 -> DONE
00200126  6700 001A                321m     BEQ EXIT_5
0020012A                           322mm     PRINT_CHAR (A0)+,D3
0020012A                           323mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      324mm     IFEQ DEBUG
0020012A  1639 00D30003            325mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200130  0803 0002                326mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200134  67F4                     327mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00200136  13D8 00D30007            328mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020013C                           329mm     ENDC
0020013C                           330mm     
0020013C                 FALSE     331mm     IFNE DEBUG
0020013C                           332mm     ENDC
0020013C                           333mm 
0020013C                           334mm     ENDM
0020013C  4EF9 00200122            335m     JMP LOOP_5
00200142                           336m EXIT_5
00200142                           337m     ENDM
00200142                           338m     PRINT_CRLF D3
00200142                           339mm     PRINT_CHAR #13,D3             ; CR
00200142                           340mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      341mm     IFEQ DEBUG
00200142  1639 00D30003            342mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200148  0803 0002                343mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020014C  67F4                     344mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00D30007       345mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200156                           346mm     ENDC
00200156                           347mm     
00200156                 FALSE     348mm     IFNE DEBUG
00200156                           349mm     ENDC
00200156                           350mm 
00200156                           351mm     ENDM
00200156                           352mm     PRINT_CHAR #10,D3             ; LF
00200156                           353mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      354mm     IFEQ DEBUG
00200156  1639 00D30003            355mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020015C  0803 0002                356mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200160  67F4                     357mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00D30007       358mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020016A                           359mm     ENDC
0020016A                           360mm     
0020016A                 FALSE     361mm     IFNE DEBUG
0020016A                           362mm     ENDC
0020016A                           363mm 
0020016A                           364mm     ENDM
0020016A                           365m     ENDM
0020016A                           366m     PRINT_CHAR #7,D3
0020016A                           367m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      368m     IFEQ DEBUG
0020016A  1639 00D30003            369m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200170  0803 0002                370m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200174  67F4                     371m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00D30007       372m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020017E                           373m     ENDC
0020017E                           374m     
0020017E                 FALSE     375m     IFNE DEBUG
0020017E                           376m     ENDC
0020017E                           377m 
0020017E                           378m     ENDM
0020017E                           379  
0020017E  7E00                     380      MOVE.L #0,D7                    ; address accumulator
00200180                           381  
00200180  13FC 0002 00E00001       382      MOVE.B #2,DISPLAY
00200188                           383  MAIN_LOOP
00200188                           384m     PRINT_CHAR #'>',D3               ; prompt
00200188                           385m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      386m     IFEQ DEBUG
00200188  1639 00D30003            387m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020018E  0803 0002                388m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200192  67F4                     389m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00D30007       390m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0020019C                           391m     ENDC
0020019C                           392m     
0020019C                 FALSE     393m     IFNE DEBUG
0020019C                           394m     ENDC
0020019C                           395m 
0020019C                           396m     ENDM
0020019C                           397m     PRINT_CHAR #32,D3                ; space
0020019C                           398m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      399m     IFEQ DEBUG
0020019C  1639 00D30003            400m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001A2  0803 0002                401m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001A6  67F4                     402m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00D30007       403m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
002001B0                           404m     ENDC
002001B0                           405m     
002001B0                 FALSE     406m     IFNE DEBUG
002001B0                           407m     ENDC
002001B0                           408m 
002001B0                           409m     ENDM
002001B0                           410      
002001B0                           411  GET_INPUT
002001B0                           412m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
002001B0                           413m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           414m 
002001B0                 TRUE      415m     IFEQ DEBUG
002001B0  1639 00D30003            416m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002001B6  0803 0000                417m       BTST #0,D3                    ; CHECK FOR CHARACTER
002001BA  67F4                     418m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
002001BC                           419m     ENDC
002001BC                           420m     
002001BC                           421mm     READ_CHAR D2
002001BC                 TRUE      422mm     IFEQ DEBUG
002001BC  1439 00D30007            423mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002001C2                           424mm     ENDC
002001C2                 FALSE     425mm     IFNE DEBUG
002001C2                           426mm     ENDC
002001C2                           427mm      
002001C2  B43C 001B                428mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                429mm     BEQ START
002001CA                           430mm     ENDM
002001CA                           431m 
002001CA                 TRUE      432m     IFEQ DEBUG
002001CA                           433mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002001CA                           434mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      435mm     IFEQ DEBUG
002001CA  1639 00D30003            436mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001D0  0803 0002                437mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001D4  67F4                     438mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
002001D6  13C2 00D30007            439mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002001DC                           440mm     ENDC
002001DC                           441mm     
002001DC                 FALSE     442mm     IFNE DEBUG
002001DC                           443mm     ENDC
002001DC                           444mm 
002001DC                           445mm     ENDM
002001DC                           446m     ENDC
002001DC                           447m     ENDM
002001DC                           448      
002001DC  B43C 0030                449      CMP.B #'0',D2
002001E0  6700 17EE                450      BEQ HEX_DIGIT
002001E4  B43C 0031                451      CMP.B #'1',D2
002001E8  6700 17E6                452      BEQ HEX_DIGIT
002001EC  B43C 0032                453      CMP.B #'2',D2
002001F0  6700 17DE                454      BEQ HEX_DIGIT
002001F4  B43C 0033                455      CMP.B #'3',D2
002001F8  6700 17D6                456      BEQ HEX_DIGIT
002001FC  B43C 0034                457      CMP.B #'4',D2
00200200  6700 17CE                458      BEQ HEX_DIGIT
00200204  B43C 0035                459      CMP.B #'5',D2
00200208  6700 17C6                460      BEQ HEX_DIGIT
0020020C  B43C 0036                461      CMP.B #'6',D2
00200210  6700 17BE                462      BEQ HEX_DIGIT
00200214  B43C 0037                463      CMP.B #'7',D2
00200218  6700 17B6                464      BEQ HEX_DIGIT
0020021C  B43C 0038                465      CMP.B #'8',D2
00200220  6700 17AE                466      BEQ HEX_DIGIT
00200224  B43C 0039                467      CMP.B #'9',D2
00200228  6700 17A6                468      BEQ HEX_DIGIT
0020022C  B43C 0041                469      CMP.B #'A',D2
00200230  6700 179E                470      BEQ HEX_DIGIT
00200234  B43C 0042                471      CMP.B #'B',D2
00200238  6700 1796                472      BEQ HEX_DIGIT
0020023C  B43C 0043                473      CMP.B #'C',D2
00200240  6700 178E                474      BEQ HEX_DIGIT
00200244  B43C 0044                475      CMP.B #'D',D2
00200248  6700 1786                476      BEQ HEX_DIGIT
0020024C  B43C 0045                477      CMP.B #'E',D2
00200250  6700 177E                478      BEQ HEX_DIGIT
00200254  B43C 0046                479      CMP.B #'F',D2
00200258  6700 1776                480      BEQ HEX_DIGIT
0020025C                           481      
0020025C  B43C 0057                482      CMP.B #'W',D2
00200260  6700 0176                483      BEQ W
00200264                           484      
00200264  B43C 004C                485      CMP.B #'L',D2
00200268  6700 15E8                486      BEQ L 
0020026C                           487  
0020026C                           488m     PRINT_CRLF D3
0020026C                           489mm     PRINT_CHAR #13,D3             ; CR
0020026C                           490mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      491mm     IFEQ DEBUG
0020026C  1639 00D30003            492mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200272  0803 0002                493mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200276  67F4                     494mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00D30007       495mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200280                           496mm     ENDC
00200280                           497mm     
00200280                 FALSE     498mm     IFNE DEBUG
00200280                           499mm     ENDC
00200280                           500mm 
00200280                           501mm     ENDM
00200280                           502mm     PRINT_CHAR #10,D3             ; LF
00200280                           503mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      504mm     IFEQ DEBUG
00200280  1639 00D30003            505mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200286  0803 0002                506mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020028A  67F4                     507mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00D30007       508mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200294                           509mm     ENDC
00200294                           510mm     
00200294                 FALSE     511mm     IFNE DEBUG
00200294                           512mm     ENDC
00200294                           513mm 
00200294                           514mm     ENDM
00200294                           515m     ENDM
00200294                           516   
00200294  B43C 003F                517      CMP.B #'?',D2
00200298  6700 005E                518      BEQ H
0020029C                           519  
0020029C  B43C 0056                520      CMP.B #'V',D2
002002A0  6700 0082                521      BEQ V
002002A4                           522      
002002A4  B43C 0052                523      CMP.B #'R',D2
002002A8  6700 00A6                524      BEQ R
002002AC                           525  
002002AC  B43C 0053                526      CMP.B #'S',D2
002002B0  6700 01EE                527      BEQ S
002002B4                           528  
002002B4  B43C 0047                529      CMP.B #'G',D2
002002B8  6700 1484                530      BEQ G   
002002BC                           531  
002002BC  B43C 005A                532      CMP.B #'Z',D2
002002C0  6700 1484                533      BEQ Z   
002002C4                           534  
002002C4  B43C 0058                535      CMP.B #'X',D2
002002C8  6700 16FE                536      BEQ X
002002CC                           537  
002002CC  41F9 00201AB5            538      LEA HUH,A0
002002D2                           539m     PRINT_STR A0,D3
002002D2                           540m LOOP_19
002002D2  0C10 0000                541m     CMP.B #0,(A0)                 ; 0 -> DONE
002002D6  6700 001A                542m     BEQ EXIT_19
002002DA                           543mm     PRINT_CHAR (A0)+,D3
002002DA                           544mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002DA                 TRUE      545mm     IFEQ DEBUG
002002DA  1639 00D30003            546mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002002E0  0803 0002                547mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002002E4  67F4                     548mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
002002E6  13D8 00D30007            549mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002002EC                           550mm     ENDC
002002EC                           551mm     
002002EC                 FALSE     552mm     IFNE DEBUG
002002EC                           553mm     ENDC
002002EC                           554mm 
002002EC                           555mm     ENDM
002002EC  4EF9 002002D2            556m     JMP LOOP_19
002002F2                           557m EXIT_19
002002F2                           558m     ENDM
002002F2                           559                         
002002F2  4EF9 00200188            560      JMP MAIN_LOOP
002002F8                           561      
002002F8                           562  ; commands
002002F8  41F9 00201A0F            563  H   LEA HELP,A0
002002FE                           564m     PRINT_STR A0,D3
002002FE                           565m LOOP_21
002002FE  0C10 0000                566m     CMP.B #0,(A0)                 ; 0 -> DONE
00200302  6700 001A                567m     BEQ EXIT_21
00200306                           568mm     PRINT_CHAR (A0)+,D3
00200306                           569mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200306                 TRUE      570mm     IFEQ DEBUG
00200306  1639 00D30003            571mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020030C  0803 0002                572mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200310  67F4                     573mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
00200312  13D8 00D30007            574mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200318                           575mm     ENDC
00200318                           576mm     
00200318                 FALSE     577mm     IFNE DEBUG
00200318                           578mm     ENDC
00200318                           579mm 
00200318                           580mm     ENDM
00200318  4EF9 002002FE            581m     JMP LOOP_21
0020031E                           582m EXIT_21
0020031E                           583m     ENDM
0020031E  4EF9 00200188            584      JMP MAIN_LOOP
00200324                           585  
00200324  41F9 002019F2            586  V   LEA VERSION,A0
0020032A                           587m     PRINT_STR A0,D3       
0020032A                           588m LOOP_23
0020032A  0C10 0000                589m     CMP.B #0,(A0)                 ; 0 -> DONE
0020032E  6700 001A                590m     BEQ EXIT_23
00200332                           591mm     PRINT_CHAR (A0)+,D3
00200332                           592mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200332                 TRUE      593mm     IFEQ DEBUG
00200332  1639 00D30003            594mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200338  0803 0002                595mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020033C  67F4                     596mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0020033E  13D8 00D30007            597mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200344                           598mm     ENDC
00200344                           599mm     
00200344                 FALSE     600mm     IFNE DEBUG
00200344                           601mm     ENDC
00200344                           602mm 
00200344                           603mm     ENDM
00200344  4EF9 0020032A            604m     JMP LOOP_23
0020034A                           605m EXIT_23
0020034A                           606m     ENDM
0020034A  4EF9 00200188            607      JMP MAIN_LOOP
00200350                           608      
00200350                           609  R   
00200350  2047                     610      MOVE.L D7,A0                    ; address accumulator -> address register
00200352  2A10                     611      MOVE.L (A0),D5                  ; read the memory and print it
00200354                           612m     PRINT_REG D5,D3,D7,D6,A0
00200354                           613mm     PRINT_CHAR #'0',D3          ;0X HEADER
00200354                           614mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200354                 TRUE      615mm     IFEQ DEBUG
00200354  1639 00D30003            616mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020035A  0803 0002                617mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020035E  67F4                     618mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00200360  13FC 0030 00D30007       619mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00200368                           620mm     ENDC
00200368                           621mm     
00200368                 FALSE     622mm     IFNE DEBUG
00200368                           623mm     ENDC
00200368                           624mm 
00200368                           625mm     ENDM
00200368                           626mm     PRINT_CHAR #'x',D3
00200368                           627mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200368                 TRUE      628mm     IFEQ DEBUG
00200368  1639 00D30003            629mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020036E  0803 0002                630mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200372  67F4                     631mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00200374  13FC 0078 00D30007       632mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0020037C                           633mm     ENDC
0020037C                           634mm     
0020037C                 FALSE     635mm     IFNE DEBUG
0020037C                           636mm     ENDC
0020037C                           637mm 
0020037C                           638mm     ENDM
0020037C  7C07                     639m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0020037E                           640m LOOP_25
0020037E                           641mm     BIN2HEX D5,D7,A0
0020037E  41F9 00201B52            642mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00200384  E99D                     643mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200386  1E05                     644mm   MOVE.B D5,D7
00200388  0287 0000000F            645mm   ANDI.L #$F,D7
0020038E  1E30 7000                646mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00200392                           647mm   ENDM
00200392                           648mm     PRINT_CHAR D7,D3
00200392                           649mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200392                 TRUE      650mm     IFEQ DEBUG
00200392  1639 00D30003            651mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200398  0803 0002                652mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020039C  67F4                     653mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
0020039E  13C7 00D30007            654mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002003A4                           655mm     ENDC
002003A4                           656mm     
002003A4                 FALSE     657mm     IFNE DEBUG
002003A4                           658mm     ENDC
002003A4                           659mm 
002003A4                           660mm     ENDM
002003A4  57CE FFD8                661m     DBEQ D6,LOOP_25
002003A8                           662m     ENDM
002003A8                           663m     PRINT_CRLF D3
002003A8                           664mm     PRINT_CHAR #13,D3             ; CR
002003A8                           665mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A8                 TRUE      666mm     IFEQ DEBUG
002003A8  1639 00D30003            667mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003AE  0803 0002                668mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003B2  67F4                     669mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
002003B4  13FC 000D 00D30007       670mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002003BC                           671mm     ENDC
002003BC                           672mm     
002003BC                 FALSE     673mm     IFNE DEBUG
002003BC                           674mm     ENDC
002003BC                           675mm 
002003BC                           676mm     ENDM
002003BC                           677mm     PRINT_CHAR #10,D3             ; LF
002003BC                           678mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003BC                 TRUE      679mm     IFEQ DEBUG
002003BC  1639 00D30003            680mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003C2  0803 0002                681mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003C6  67F4                     682mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
002003C8  13FC 000A 00D30007       683mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002003D0                           684mm     ENDC
002003D0                           685mm     
002003D0                 FALSE     686mm     IFNE DEBUG
002003D0                           687mm     ENDC
002003D0                           688mm 
002003D0                           689mm     ENDM
002003D0                           690m     ENDM
002003D0  7E00                     691      MOVE.L #0,D7                    ; clear the now used address accumulator
002003D2  4EF9 00200188            692      JMP MAIN_LOOP
002003D8                           693  
002003D8  7A00                     694  W   MOVE.L #0,D5                    ; D5 will be the value to write            
002003DA                           695  
002003DA                           696m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
002003DA                           697m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003DA                           698m 
002003DA                 TRUE      699m     IFEQ DEBUG
002003DA  1639 00D30003            700m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002003E0  0803 0000                701m       BTST #0,D3                    ; CHECK FOR CHARACTER
002003E4  67F4                     702m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
002003E6                           703m     ENDC
002003E6                           704m     
002003E6                           705mm     READ_CHAR D2
002003E6                 TRUE      706mm     IFEQ DEBUG
002003E6  1439 00D30007            707mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002003EC                           708mm     ENDC
002003EC                 FALSE     709mm     IFNE DEBUG
002003EC                           710mm     ENDC
002003EC                           711mm      
002003EC  B43C 001B                712mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002003F0  6700 FC16                713mm     BEQ START
002003F4                           714mm     ENDM
002003F4                           715m 
002003F4                 TRUE      716m     IFEQ DEBUG
002003F4                           717mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002003F4                           718mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003F4                 TRUE      719mm     IFEQ DEBUG
002003F4  1639 00D30003            720mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003FA  0803 0002                721mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003FE  67F4                     722mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
00200400  13C2 00D30007            723mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200406                           724mm     ENDC
00200406                           725mm     
00200406                 FALSE     726mm     IFNE DEBUG
00200406                           727mm     ENDC
00200406                           728mm 
00200406                           729mm     ENDM
00200406                           730m     ENDC
00200406                           731m     ENDM
00200406                           732m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00200406  41F9 00201B62            733m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020040C  0402 0030                734m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200410  C4BC 000000FF            735m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200416  1430 2000                736m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020041A                           737m   ENDM
0020041A  1A02                     738      MOVE.B D2,D5                    ; put at bottom of D5
0020041C                           739  
0020041C  3C3C 0006                740      MOVE #6,D6                      ; 7 bytes left to read
00200420                           741      
00200420                           742  READ_DATA_TO_POKE
00200420  E98D                     743      LSL.L #4,D5                     ; make what we have so far more significant
00200422                           744m     WAIT_CHAR D2,D3                 ; next character -> D2
00200422                           745m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200422                           746m 
00200422                 TRUE      747m     IFEQ DEBUG
00200422  1639 00D30003            748m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00200428  0803 0000                749m       BTST #0,D3                    ; CHECK FOR CHARACTER
0020042C  67F4                     750m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
0020042E                           751m     ENDC
0020042E                           752m     
0020042E                           753mm     READ_CHAR D2
0020042E                 TRUE      754mm     IFEQ DEBUG
0020042E  1439 00D30007            755mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200434                           756mm     ENDC
00200434                 FALSE     757mm     IFNE DEBUG
00200434                           758mm     ENDC
00200434                           759mm      
00200434  B43C 001B                760mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200438  6700 FBCE                761mm     BEQ START
0020043C                           762mm     ENDM
0020043C                           763m 
0020043C                 TRUE      764m     IFEQ DEBUG
0020043C                           765mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0020043C                           766mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020043C                 TRUE      767mm     IFEQ DEBUG
0020043C  1639 00D30003            768mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200442  0803 0002                769mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200446  67F4                     770mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00200448  13C2 00D30007            771mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020044E                           772mm     ENDC
0020044E                           773mm     
0020044E                 FALSE     774mm     IFNE DEBUG
0020044E                           775mm     ENDC
0020044E                           776mm 
0020044E                           777mm     ENDM
0020044E                           778m     ENDC
0020044E                           779m     ENDM
0020044E                           780m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
0020044E  41F9 00201B62            781m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200454  0402 0030                782m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200458  C4BC 000000FF            783m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020045E  1430 2000                784m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200462                           785m   ENDM
00200462  8A02                     786      OR.B D2,D5
00200464  023C 00FB                787      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00200468  57CE FFB6                788      DBEQ D6,READ_DATA_TO_POKE
0020046C                           789      
0020046C  2047                     790      MOVE.L D7,A0                    ; address accumulator -> address register
0020046E  7E00                     791      MOVE.L #0,D7                    ; clear the now used address accumulator
00200470                           792      
00200470  2085                     793      MOVE.L D5,(A0)                  ; write the data
00200472                           794  
00200472                           795m     PRINT_CRLF D3
00200472                           796mm     PRINT_CHAR #13,D3             ; CR
00200472                           797mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200472                 TRUE      798mm     IFEQ DEBUG
00200472  1639 00D30003            799mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200478  0803 0002                800mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020047C  67F4                     801mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
0020047E  13FC 000D 00D30007       802mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200486                           803mm     ENDC
00200486                           804mm     
00200486                 FALSE     805mm     IFNE DEBUG
00200486                           806mm     ENDC
00200486                           807mm 
00200486                           808mm     ENDM
00200486                           809mm     PRINT_CHAR #10,D3             ; LF
00200486                           810mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200486                 TRUE      811mm     IFEQ DEBUG
00200486  1639 00D30003            812mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020048C  0803 0002                813mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200490  67F4                     814mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
00200492  13FC 000A 00D30007       815mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020049A                           816mm     ENDC
0020049A                           817mm     
0020049A                 FALSE     818mm     IFNE DEBUG
0020049A                           819mm     ENDC
0020049A                           820mm 
0020049A                           821mm     ENDM
0020049A                           822m     ENDM
0020049A  4EF9 00200188            823      JMP MAIN_LOOP
002004A0                           824  
002004A0                           825          
002004A0  2647                     826  S   MOVE.L D7,A3                    ; grab the address accumulator
002004A2  7800                     827      MOVE.L #0,D4                    ; count of records read -> D4
002004A4  2478 0000                828      MOVE.L 0,A2                     ; start address -> A2
002004A8                           829      
002004A8                           830  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
002004A8                           831m     DOWNLOAD D2,D3                  
002004A8                           832m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A8                           833m 
002004A8  1639 00D30003            834m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004AE  0803 0000                835m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004B2  6700 0010                836m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
002004B6                           837m  
002004B6                           838mm     READ_CHAR D2
002004B6                 TRUE      839mm     IFEQ DEBUG
002004B6  1439 00D30007            840mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002004BC                           841mm     ENDC
002004BC                 FALSE     842mm     IFNE DEBUG
002004BC                           843mm     ENDC
002004BC                           844mm      
002004BC  B43C 001B                845mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002004C0  6700 FB46                846mm     BEQ START
002004C4                           847mm     ENDM
002004C4                           848m CONTINUE_44
002004C4  1639 00D30013            849m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004CA  0803 0000                850m     BTST #0,D3                  ; CHECK FOR CHARACTER
002004CE  67D8                     851m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
002004D0                           852m     
002004D0  1439 00D30017            853m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002004D6  13C2 00E00001            854m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002004DC                           855m     
002004DC                           856m     ENDM
002004DC  B43C 0053                857      CMP.B #'S',D2                   ; found S?    
002004E0  66C6                     858      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
002004E2                           859      
002004E2  5284                     860      ADD.L #1,D4                     ; read another S record, increment count
002004E4                           861      
002004E4                           862m     DOWNLOAD D7,D3                  ; read the record digit
002004E4                           863m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004E4                           864m 
002004E4  1639 00D30003            865m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004EA  0803 0000                866m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004EE  6700 0010                867m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
002004F2                           868m  
002004F2                           869mm     READ_CHAR D7
002004F2                 TRUE      870mm     IFEQ DEBUG
002004F2  1E39 00D30007            871mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
002004F8                           872mm     ENDC
002004F8                 FALSE     873mm     IFNE DEBUG
002004F8                           874mm     ENDC
002004F8                           875mm      
002004F8  BE3C 001B                876mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
002004FC  6700 FB0A                877mm     BEQ START
00200500                           878mm     ENDM
00200500                           879m CONTINUE_46
00200500  1639 00D30013            880m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200506  0803 0000                881m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020050A  67D8                     882m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
0020050C                           883m     
0020050C  1E39 00D30017            884m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
00200512  13C7 00E00001            885m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
00200518                           886m     
00200518                           887m     ENDM
00200518                           888  
00200518  7C00                     889      MOVE.L #0,D6                    ; checksum
0020051A                           890  
0020051A  7A00                     891      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
0020051C                           892m     DOWNLOAD D2,D3              
0020051C                           893m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020051C                           894m 
0020051C  1639 00D30003            895m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200522  0803 0000                896m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200526  6700 0010                897m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
0020052A                           898m  
0020052A                           899mm     READ_CHAR D2
0020052A                 TRUE      900mm     IFEQ DEBUG
0020052A  1439 00D30007            901mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200530                           902mm     ENDC
00200530                 FALSE     903mm     IFNE DEBUG
00200530                           904mm     ENDC
00200530                           905mm      
00200530  B43C 001B                906mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200534  6700 FAD2                907mm     BEQ START
00200538                           908mm     ENDM
00200538                           909m CONTINUE_48
00200538  1639 00D30013            910m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020053E  0803 0000                911m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200542  67D8                     912m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00200544                           913m     
00200544  1439 00D30017            914m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020054A  13C2 00E00001            915m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200550                           916m     
00200550                           917m     ENDM
00200550                           918m     HEX2BIN D2,D2,A0
00200550  41F9 00201B62            919m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200556  0402 0030                920m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020055A  C4BC 000000FF            921m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200560  1430 2000                922m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200564                           923m   ENDM
00200564  8A82                     924      OR.L D2,D5
00200566  E98D                     925      LSL.L #4,D5    
00200568                           926m     DOWNLOAD D2,D3
00200568                           927m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200568                           928m 
00200568  1639 00D30003            929m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020056E  0803 0000                930m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200572  6700 0010                931m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
00200576                           932m  
00200576                           933mm     READ_CHAR D2
00200576                 TRUE      934mm     IFEQ DEBUG
00200576  1439 00D30007            935mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020057C                           936mm     ENDC
0020057C                 FALSE     937mm     IFNE DEBUG
0020057C                           938mm     ENDC
0020057C                           939mm      
0020057C  B43C 001B                940mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200580  6700 FA86                941mm     BEQ START
00200584                           942mm     ENDM
00200584                           943m CONTINUE_51
00200584  1639 00D30013            944m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020058A  0803 0000                945m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020058E  67D8                     946m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
00200590                           947m     
00200590  1439 00D30017            948m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200596  13C2 00E00001            949m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020059C                           950m     
0020059C                           951m     ENDM
0020059C                           952m     HEX2BIN D2,D2,A0  
0020059C  41F9 00201B62            953m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002005A2  0402 0030                954m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005A6  C4BC 000000FF            955m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005AC  1430 2000                956m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005B0                           957m   ENDM
002005B0  8A82                     958      OR.L D2,D5
002005B2                           959                  
002005B2  DC85                     960      ADD.L D5,D6                     ; add byte count into checksum
002005B4                           961  
002005B4                           962      IF.B D7 <EQ> #'0' THEN.L        ; header
002005B4  BE3C 0030                963s     CMP.B   #'0',D7
002005B8  6600 022A                964s     BNE.L   _00000000
002005BC  7E00                     965          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
002005BE                           966m         DOWNLOAD D2,D3              ; top byte
002005BE                           967m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005BE                           968m 
002005BE  1639 00D30003            969m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002005C4  0803 0000                970m     BTST #0,D3                    ; CHECK FOR CHARACTER
002005C8  6700 0010                971m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
002005CC                           972m  
002005CC                           973mm     READ_CHAR D2
002005CC                 TRUE      974mm     IFEQ DEBUG
002005CC  1439 00D30007            975mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002005D2                           976mm     ENDC
002005D2                 FALSE     977mm     IFNE DEBUG
002005D2                           978mm     ENDC
002005D2                           979mm      
002005D2  B43C 001B                980mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002005D6  6700 FA30                981mm     BEQ START
002005DA                           982mm     ENDM
002005DA                           983m CONTINUE_54
002005DA  1639 00D30013            984m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002005E0  0803 0000                985m     BTST #0,D3                  ; CHECK FOR CHARACTER
002005E4  67D8                     986m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
002005E6                           987m     
002005E6  1439 00D30017            988m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002005EC  13C2 00E00001            989m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002005F2                           990m     
002005F2                           991m     ENDM
002005F2                           992m         HEX2BIN D2,D2,A0
002005F2  41F9 00201B62            993m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002005F8  0402 0030                994m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005FC  C4BC 000000FF            995m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200602  1430 2000                996m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200606                           997m   ENDM
00200606  8E82                     998          OR.L D2,D7
00200608  E98F                     999          LSL.L #4,D7
0020060A                          1000m         DOWNLOAD D2,D3         
0020060A                          1001m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020060A                          1002m 
0020060A  1639 00D30003           1003m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200610  0803 0000               1004m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200614  6700 0010               1005m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
00200618                          1006m  
00200618                          1007mm     READ_CHAR D2
00200618                 TRUE     1008mm     IFEQ DEBUG
00200618  1439 00D30007           1009mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020061E                          1010mm     ENDC
0020061E                 FALSE    1011mm     IFNE DEBUG
0020061E                          1012mm     ENDC
0020061E                          1013mm      
0020061E  B43C 001B               1014mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200622  6700 F9E4               1015mm     BEQ START
00200626                          1016mm     ENDM
00200626                          1017m CONTINUE_57
00200626  1639 00D30013           1018m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020062C  0803 0000               1019m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200630  67D8                    1020m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
00200632                          1021m     
00200632  1439 00D30017           1022m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200638  13C2 00E00001           1023m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020063E                          1024m     
0020063E                          1025m     ENDM
0020063E                          1026m         HEX2BIN D2,D2,A0
0020063E  41F9 00201B62           1027m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200644  0402 0030               1028m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200648  C4BC 000000FF           1029m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020064E  1430 2000               1030m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200652                          1031m   ENDM
00200652  8E82                    1032          OR.L D2,D7
00200654                          1033          
00200654  DC87                    1034          ADD.L D7,D6                 ; add top byte of address into checksum
00200656                          1035  
00200656  E98F                    1036          LSL.L #4,D7                 ; bottom byte
00200658                          1037m         DOWNLOAD D2,D3
00200658                          1038m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200658                          1039m 
00200658  1639 00D30003           1040m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020065E  0803 0000               1041m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200662  6700 0010               1042m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
00200666                          1043m  
00200666                          1044mm     READ_CHAR D2
00200666                 TRUE     1045mm     IFEQ DEBUG
00200666  1439 00D30007           1046mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020066C                          1047mm     ENDC
0020066C                 FALSE    1048mm     IFNE DEBUG
0020066C                          1049mm     ENDC
0020066C                          1050mm      
0020066C  B43C 001B               1051mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200670  6700 F996               1052mm     BEQ START
00200674                          1053mm     ENDM
00200674                          1054m CONTINUE_60
00200674  1639 00D30013           1055m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020067A  0803 0000               1056m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020067E  67D8                    1057m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
00200680                          1058m     
00200680  1439 00D30017           1059m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200686  13C2 00E00001           1060m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020068C                          1061m     
0020068C                          1062m     ENDM
0020068C                          1063m         HEX2BIN D2,D2,A0
0020068C  41F9 00201B62           1064m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200692  0402 0030               1065m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200696  C4BC 000000FF           1066m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020069C  1430 2000               1067m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002006A0                          1068m   ENDM
002006A0  8E82                    1069          OR.L D2,D7
002006A2  E98F                    1070          LSL.L #4,D7        
002006A4                          1071m         DOWNLOAD D2,D3
002006A4                          1072m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006A4                          1073m 
002006A4  1639 00D30003           1074m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002006AA  0803 0000               1075m     BTST #0,D3                    ; CHECK FOR CHARACTER
002006AE  6700 0010               1076m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
002006B2                          1077m  
002006B2                          1078mm     READ_CHAR D2
002006B2                 TRUE     1079mm     IFEQ DEBUG
002006B2  1439 00D30007           1080mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002006B8                          1081mm     ENDC
002006B8                 FALSE    1082mm     IFNE DEBUG
002006B8                          1083mm     ENDC
002006B8                          1084mm      
002006B8  B43C 001B               1085mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002006BC  6700 F94A               1086mm     BEQ START
002006C0                          1087mm     ENDM
002006C0                          1088m CONTINUE_63
002006C0  1639 00D30013           1089m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002006C6  0803 0000               1090m     BTST #0,D3                  ; CHECK FOR CHARACTER
002006CA  67D8                    1091m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
002006CC                          1092m     
002006CC  1439 00D30017           1093m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002006D2  13C2 00E00001           1094m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002006D8                          1095m     
002006D8                          1096m     ENDM
002006D8                          1097m         HEX2BIN D2,D2,A0
002006D8  41F9 00201B62           1098m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002006DE  0402 0030               1099m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006E2  C4BC 000000FF           1100m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002006E8  1430 2000               1101m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002006EC                          1102m   ENDM
002006EC  8E82                    1103          OR.L D2,D7
002006EE                          1104          
002006EE  7400                    1105          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
002006F0  1407                    1106          MOVE.B D7,D2
002006F2  DC82                    1107          ADD.L D2,D6
002006F4                          1108          
002006F4  5785                    1109          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
002006F6                          1110          WHILE.L D5 <GT> #0 DO       ; read the data bytes
002006F6                          1111s _10000000
002006F6  BABC 00000000           1112s     CMP.L   #0,D5
002006FC  6F00 00B4               1113s     BLE _10000001
00200700  5385                    1114            SUB.L #1,D5
00200702                          1115              
00200702  7E00                    1116            MOVE.L #0,D7              ; D7 holds the byte
00200704                          1117              
00200704                          1118m           DOWNLOAD D2,D3            ; MS 4 bits
00200704                          1119m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200704                          1120m 
00200704  1639 00D30003           1121m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020070A  0803 0000               1122m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020070E  6700 0010               1123m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
00200712                          1124m  
00200712                          1125mm     READ_CHAR D2
00200712                 TRUE     1126mm     IFEQ DEBUG
00200712  1439 00D30007           1127mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200718                          1128mm     ENDC
00200718                 FALSE    1129mm     IFNE DEBUG
00200718                          1130mm     ENDC
00200718                          1131mm      
00200718  B43C 001B               1132mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020071C  6700 F8EA               1133mm     BEQ START
00200720                          1134mm     ENDM
00200720                          1135m CONTINUE_66
00200720  1639 00D30013           1136m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200726  0803 0000               1137m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020072A  67D8                    1138m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
0020072C                          1139m     
0020072C  1439 00D30017           1140m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200732  13C2 00E00001           1141m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200738                          1142m     
00200738                          1143m     ENDM
00200738                          1144m           HEX2BIN D2,D2,A0
00200738  41F9 00201B62           1145m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020073E  0402 0030               1146m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200742  C4BC 000000FF           1147m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200748  1430 2000               1148m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020074C                          1149m   ENDM
0020074C  8E82                    1150            OR.L D2,D7
0020074E  E98F                    1151            LSL.L #4,D7
00200750                          1152               
00200750                          1153m           DOWNLOAD D2,D3            ; LS 4 bits    
00200750                          1154m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200750                          1155m 
00200750  1639 00D30003           1156m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200756  0803 0000               1157m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020075A  6700 0010               1158m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
0020075E                          1159m  
0020075E                          1160mm     READ_CHAR D2
0020075E                 TRUE     1161mm     IFEQ DEBUG
0020075E  1439 00D30007           1162mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200764                          1163mm     ENDC
00200764                 FALSE    1164mm     IFNE DEBUG
00200764                          1165mm     ENDC
00200764                          1166mm      
00200764  B43C 001B               1167mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200768  6700 F89E               1168mm     BEQ START
0020076C                          1169mm     ENDM
0020076C                          1170m CONTINUE_69
0020076C  1639 00D30013           1171m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200772  0803 0000               1172m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200776  67D8                    1173m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00200778                          1174m     
00200778  1439 00D30017           1175m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020077E  13C2 00E00001           1176m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200784                          1177m     
00200784                          1178m     ENDM
00200784                          1179m           HEX2BIN D2,D2,A0
00200784  41F9 00201B62           1180m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020078A  0402 0030               1181m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020078E  C4BC 000000FF           1182m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200794  1430 2000               1183m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200798                          1184m   ENDM
00200798  8E82                    1185            OR.L D2,D7
0020079A                          1186              
0020079A  DC87                    1187            ADD.L D7,D6               ; add into checksum
0020079C                          1188            
0020079C                          1189m           PRINT_CHAR D7,D3          ; assume ASCII and print it
0020079C                          1190m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020079C                 TRUE     1191m     IFEQ DEBUG
0020079C  1639 00D30003           1192m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007A2  0803 0002               1193m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007A6  67F4                    1194m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
002007A8  13C7 00D30007           1195m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002007AE                          1196m     ENDC
002007AE                          1197m     
002007AE                 FALSE    1198m     IFNE DEBUG
002007AE                          1199m     ENDC
002007AE                          1200m 
002007AE                          1201m     ENDM
002007AE                          1202          ENDW
002007AE  6000 FF46               1203s     BRA _10000000
002007B2                          1204s _10000001
002007B2                          1205m         PRINT_CRLF D3
002007B2                          1206mm     PRINT_CHAR #13,D3             ; CR
002007B2                          1207mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007B2                 TRUE     1208mm     IFEQ DEBUG
002007B2  1639 00D30003           1209mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007B8  0803 0002               1210mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007BC  67F4                    1211mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
002007BE  13FC 000D 00D30007      1212mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002007C6                          1213mm     ENDC
002007C6                          1214mm     
002007C6                 FALSE    1215mm     IFNE DEBUG
002007C6                          1216mm     ENDC
002007C6                          1217mm 
002007C6                          1218mm     ENDM
002007C6                          1219mm     PRINT_CHAR #10,D3             ; LF
002007C6                          1220mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007C6                 TRUE     1221mm     IFEQ DEBUG
002007C6  1639 00D30003           1222mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007CC  0803 0002               1223mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007D0  67F4                    1224mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
002007D2  13FC 000A 00D30007      1225mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002007DA                          1226mm     ENDC
002007DA                          1227mm     
002007DA                 FALSE    1228mm     IFNE DEBUG
002007DA                          1229mm     ENDC
002007DA                          1230mm 
002007DA                          1231mm     ENDM
002007DA                          1232m     ENDM
002007DA  43F9 002004A8           1233         LEA WAIT_FOR_SRECORD,A1            
002007E0                          1234      ELSE
002007E0  6000 0D0E               1235s     BRA _00000001
002007E4                          1236s _00000000
002007E4                          1237        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
002007E4  BE3C 0031               1238s     CMP.B   #'1',D7
002007E8  6600 04F6               1239s     BNE.L   _00000002
002007EC  7E00                    1240          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007EE                          1241m         DOWNLOAD D2,D3              ; top byte
002007EE                          1242m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007EE                          1243m 
002007EE  1639 00D30003           1244m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002007F4  0803 0000               1245m     BTST #0,D3                    ; CHECK FOR CHARACTER
002007F8  6700 0010               1246m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
002007FC                          1247m  
002007FC                          1248mm     READ_CHAR D2
002007FC                 TRUE     1249mm     IFEQ DEBUG
002007FC  1439 00D30007           1250mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200802                          1251mm     ENDC
00200802                 FALSE    1252mm     IFNE DEBUG
00200802                          1253mm     ENDC
00200802                          1254mm      
00200802  B43C 001B               1255mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200806  6700 F800               1256mm     BEQ START
0020080A                          1257mm     ENDM
0020080A                          1258m CONTINUE_76
0020080A  1639 00D30013           1259m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200810  0803 0000               1260m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200814  67D8                    1261m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
00200816                          1262m     
00200816  1439 00D30017           1263m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020081C  13C2 00E00001           1264m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200822                          1265m     
00200822                          1266m     ENDM
00200822                          1267m         PRINT_CHAR D2,D3
00200822                          1268m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200822                 TRUE     1269m     IFEQ DEBUG
00200822  1639 00D30003           1270m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200828  0803 0002               1271m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020082C  67F4                    1272m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
0020082E  13C2 00D30007           1273m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200834                          1274m     ENDC
00200834                          1275m     
00200834                 FALSE    1276m     IFNE DEBUG
00200834                          1277m     ENDC
00200834                          1278m 
00200834                          1279m     ENDM
00200834                          1280m         HEX2BIN D2,D2,A0
00200834  41F9 00201B62           1281m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020083A  0402 0030               1282m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020083E  C4BC 000000FF           1283m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200844  1430 2000               1284m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200848                          1285m   ENDM
00200848  8E82                    1286          OR.L D2,D7
0020084A  E98F                    1287          LSL.L #4,D7
0020084C                          1288m         DOWNLOAD D2,D3         
0020084C                          1289m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020084C                          1290m 
0020084C  1639 00D30003           1291m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200852  0803 0000               1292m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200856  6700 0010               1293m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
0020085A                          1294m  
0020085A                          1295mm     READ_CHAR D2
0020085A                 TRUE     1296mm     IFEQ DEBUG
0020085A  1439 00D30007           1297mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200860                          1298mm     ENDC
00200860                 FALSE    1299mm     IFNE DEBUG
00200860                          1300mm     ENDC
00200860                          1301mm      
00200860  B43C 001B               1302mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200864  6700 F7A2               1303mm     BEQ START
00200868                          1304mm     ENDM
00200868                          1305m CONTINUE_80
00200868  1639 00D30013           1306m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020086E  0803 0000               1307m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200872  67D8                    1308m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
00200874                          1309m     
00200874  1439 00D30017           1310m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020087A  13C2 00E00001           1311m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200880                          1312m     
00200880                          1313m     ENDM
00200880                          1314m         PRINT_CHAR D2,D3
00200880                          1315m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200880                 TRUE     1316m     IFEQ DEBUG
00200880  1639 00D30003           1317m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200886  0803 0002               1318m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020088A  67F4                    1319m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
0020088C  13C2 00D30007           1320m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200892                          1321m     ENDC
00200892                          1322m     
00200892                 FALSE    1323m     IFNE DEBUG
00200892                          1324m     ENDC
00200892                          1325m 
00200892                          1326m     ENDM
00200892                          1327m         HEX2BIN D2,D2,A0
00200892  41F9 00201B62           1328m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200898  0402 0030               1329m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020089C  C4BC 000000FF           1330m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002008A2  1430 2000               1331m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002008A6                          1332m   ENDM
002008A6  8E82                    1333          OR.L D2,D7
002008A8                          1334          
002008A8  DC87                    1335          ADD.L D7,D6                 ; add top byte of address into checksum
002008AA                          1336  
002008AA  E98F                    1337          LSL.L #4,D7                 ; bottom byte
002008AC                          1338m         DOWNLOAD D2,D3
002008AC                          1339m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008AC                          1340m 
002008AC  1639 00D30003           1341m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002008B2  0803 0000               1342m     BTST #0,D3                    ; CHECK FOR CHARACTER
002008B6  6700 0010               1343m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
002008BA                          1344m  
002008BA                          1345mm     READ_CHAR D2
002008BA                 TRUE     1346mm     IFEQ DEBUG
002008BA  1439 00D30007           1347mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002008C0                          1348mm     ENDC
002008C0                 FALSE    1349mm     IFNE DEBUG
002008C0                          1350mm     ENDC
002008C0                          1351mm      
002008C0  B43C 001B               1352mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002008C4  6700 F742               1353mm     BEQ START
002008C8                          1354mm     ENDM
002008C8                          1355m CONTINUE_84
002008C8  1639 00D30013           1356m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002008CE  0803 0000               1357m     BTST #0,D3                  ; CHECK FOR CHARACTER
002008D2  67D8                    1358m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
002008D4                          1359m     
002008D4  1439 00D30017           1360m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002008DA  13C2 00E00001           1361m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002008E0                          1362m     
002008E0                          1363m     ENDM
002008E0                          1364m         PRINT_CHAR D2,D3
002008E0                          1365m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008E0                 TRUE     1366m     IFEQ DEBUG
002008E0  1639 00D30003           1367m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002008E6  0803 0002               1368m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002008EA  67F4                    1369m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
002008EC  13C2 00D30007           1370m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002008F2                          1371m     ENDC
002008F2                          1372m     
002008F2                 FALSE    1373m     IFNE DEBUG
002008F2                          1374m     ENDC
002008F2                          1375m 
002008F2                          1376m     ENDM
002008F2                          1377m         HEX2BIN D2,D2,A0
002008F2  41F9 00201B62           1378m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002008F8  0402 0030               1379m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008FC  C4BC 000000FF           1380m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200902  1430 2000               1381m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200906                          1382m   ENDM
00200906  8E82                    1383          OR.L D2,D7
00200908  E98F                    1384          LSL.L #4,D7        
0020090A                          1385m         DOWNLOAD D2,D3
0020090A                          1386m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020090A                          1387m 
0020090A  1639 00D30003           1388m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200910  0803 0000               1389m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200914  6700 0010               1390m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
00200918                          1391m  
00200918                          1392mm     READ_CHAR D2
00200918                 TRUE     1393mm     IFEQ DEBUG
00200918  1439 00D30007           1394mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020091E                          1395mm     ENDC
0020091E                 FALSE    1396mm     IFNE DEBUG
0020091E                          1397mm     ENDC
0020091E                          1398mm      
0020091E  B43C 001B               1399mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200922  6700 F6E4               1400mm     BEQ START
00200926                          1401mm     ENDM
00200926                          1402m CONTINUE_88
00200926  1639 00D30013           1403m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020092C  0803 0000               1404m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200930  67D8                    1405m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
00200932                          1406m     
00200932  1439 00D30017           1407m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200938  13C2 00E00001           1408m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020093E                          1409m     
0020093E                          1410m     ENDM
0020093E                          1411m         PRINT_CHAR D2,D3
0020093E                          1412m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020093E                 TRUE     1413m     IFEQ DEBUG
0020093E  1639 00D30003           1414m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200944  0803 0002               1415m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200948  67F4                    1416m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
0020094A  13C2 00D30007           1417m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200950                          1418m     ENDC
00200950                          1419m     
00200950                 FALSE    1420m     IFNE DEBUG
00200950                          1421m     ENDC
00200950                          1422m 
00200950                          1423m     ENDM
00200950                          1424m         HEX2BIN D2,D2,A0
00200950  41F9 00201B62           1425m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200956  0402 0030               1426m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020095A  C4BC 000000FF           1427m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200960  1430 2000               1428m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200964                          1429m   ENDM
00200964  8E82                    1430          OR.L D2,D7
00200966                          1431          
00200966  7400                    1432          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200968  1407                    1433          MOVE.B D7,D2
0020096A  DC82                    1434          ADD.L D2,D6
0020096C                          1435          
0020096C  DE8B                    1436          ADD.L A3,D7                 ; add in the offset
0020096E                          1437          
0020096E  5785                    1438          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
00200970                          1439          
00200970  0807 0000               1440          BTST #0,D7                  ; deal with odd addresses
00200974                          1441  
00200974  2247                    1442          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200976  6700 00D0               1443          BEQ EVEN
0020097A                          1444                  
0020097A  5385                    1445          SUB.L #1,D5
0020097C  5389                    1446          SUB.L #1,A1
0020097E                          1447          
0020097E  7E00                    1448          MOVE.L #0,D7
00200980                          1449m         DOWNLOAD D2,D3            ; MS 4 bits
00200980                          1450m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200980                          1451m 
00200980  1639 00D30003           1452m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200986  0803 0000               1453m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020098A  6700 0010               1454m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
0020098E                          1455m  
0020098E                          1456mm     READ_CHAR D2
0020098E                 TRUE     1457mm     IFEQ DEBUG
0020098E  1439 00D30007           1458mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200994                          1459mm     ENDC
00200994                 FALSE    1460mm     IFNE DEBUG
00200994                          1461mm     ENDC
00200994                          1462mm      
00200994  B43C 001B               1463mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200998  6700 F66E               1464mm     BEQ START
0020099C                          1465mm     ENDM
0020099C                          1466m CONTINUE_92
0020099C  1639 00D30013           1467m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002009A2  0803 0000               1468m     BTST #0,D3                  ; CHECK FOR CHARACTER
002009A6  67D8                    1469m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
002009A8                          1470m     
002009A8  1439 00D30017           1471m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002009AE  13C2 00E00001           1472m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002009B4                          1473m     
002009B4                          1474m     ENDM
002009B4                          1475m         PRINT_CHAR D2,D3
002009B4                          1476m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009B4                 TRUE     1477m     IFEQ DEBUG
002009B4  1639 00D30003           1478m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002009BA  0803 0002               1479m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002009BE  67F4                    1480m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
002009C0  13C2 00D30007           1481m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002009C6                          1482m     ENDC
002009C6                          1483m     
002009C6                 FALSE    1484m     IFNE DEBUG
002009C6                          1485m     ENDC
002009C6                          1486m 
002009C6                          1487m     ENDM
002009C6                          1488m         HEX2BIN D2,D2,A0
002009C6  41F9 00201B62           1489m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002009CC  0402 0030               1490m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009D0  C4BC 000000FF           1491m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002009D6  1430 2000               1492m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002009DA                          1493m   ENDM
002009DA  8E82                    1494          OR.L D2,D7
002009DC  E98F                    1495          LSL.L #4,D7
002009DE                          1496               
002009DE                          1497m         DOWNLOAD D2,D3            ; LS 4 bits    
002009DE                          1498m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009DE                          1499m 
002009DE  1639 00D30003           1500m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002009E4  0803 0000               1501m     BTST #0,D3                    ; CHECK FOR CHARACTER
002009E8  6700 0010               1502m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
002009EC                          1503m  
002009EC                          1504mm     READ_CHAR D2
002009EC                 TRUE     1505mm     IFEQ DEBUG
002009EC  1439 00D30007           1506mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002009F2                          1507mm     ENDC
002009F2                 FALSE    1508mm     IFNE DEBUG
002009F2                          1509mm     ENDC
002009F2                          1510mm      
002009F2  B43C 001B               1511mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002009F6  6700 F610               1512mm     BEQ START
002009FA                          1513mm     ENDM
002009FA                          1514m CONTINUE_96
002009FA  1639 00D30013           1515m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200A00  0803 0000               1516m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200A04  67D8                    1517m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
00200A06                          1518m     
00200A06  1439 00D30017           1519m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A0C  13C2 00E00001           1520m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A12                          1521m     
00200A12                          1522m     ENDM
00200A12                          1523m         PRINT_CHAR D2,D3
00200A12                          1524m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A12                 TRUE     1525m     IFEQ DEBUG
00200A12  1639 00D30003           1526m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A18  0803 0002               1527m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A1C  67F4                    1528m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
00200A1E  13C2 00D30007           1529m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A24                          1530m     ENDC
00200A24                          1531m     
00200A24                 FALSE    1532m     IFNE DEBUG
00200A24                          1533m     ENDC
00200A24                          1534m 
00200A24                          1535m     ENDM
00200A24                          1536m         HEX2BIN D2,D2,A0
00200A24  41F9 00201B62           1537m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A2A  0402 0030               1538m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A2E  C4BC 000000FF           1539m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200A34  1430 2000               1540m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200A38                          1541m   ENDM
00200A38  8E82                    1542          OR.L D2,D7
00200A3A                          1543                          
00200A3A  DC87                    1544          ADD.L D7,D6               ; add into checksum
00200A3C                          1545                        
00200A3C  3611                    1546          MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200A3E                          1547          
00200A3E  0243 FF00               1548          ANDI.W #$FF00,D3
00200A42  8647                    1549          OR.W D7,D3
00200A44                          1550          
00200A44  3283                    1551          MOVE.W D3,(A1)           ; store it!
00200A46  5489                    1552          ADD.L #2,A1
00200A48                          1553  EVEN        
00200A48                          1554          WHILE.L D5 <GE> #2 DO       ; read the data bytes
00200A48                          1555s _10000002
00200A48  BABC 00000002           1556s     CMP.L   #2,D5
00200A4E  6D00 018A               1557s     BLT _10000003
00200A52  5585                    1558              SUB.L #2,D5
00200A54  7E00                    1559              MOVE.L #0,D7              ; D7 holds the word
00200A56                          1560              
00200A56                          1561m             DOWNLOAD D2,D3            ; MS 4 bits
00200A56                          1562m WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A56                          1563m 
00200A56  1639 00D30003           1564m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200A5C  0803 0000               1565m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200A60  6700 0010               1566m     BEQ CONTINUE_100                ; NOTHING, CONTINUE
00200A64                          1567m  
00200A64                          1568mm     READ_CHAR D2
00200A64                 TRUE     1569mm     IFEQ DEBUG
00200A64  1439 00D30007           1570mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200A6A                          1571mm     ENDC
00200A6A                 FALSE    1572mm     IFNE DEBUG
00200A6A                          1573mm     ENDC
00200A6A                          1574mm      
00200A6A  B43C 001B               1575mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200A6E  6700 F598               1576mm     BEQ START
00200A72                          1577mm     ENDM
00200A72                          1578m CONTINUE_100
00200A72  1639 00D30013           1579m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200A78  0803 0000               1580m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200A7C  67D8                    1581m     BEQ WAIT_FOR_READY_100        ; NOTHING, CHECK AGAIN
00200A7E                          1582m     
00200A7E  1439 00D30017           1583m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A84  13C2 00E00001           1584m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A8A                          1585m     
00200A8A                          1586m     ENDM
00200A8A                          1587m             PRINT_CHAR D2,D3
00200A8A                          1588m WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A8A                 TRUE     1589m     IFEQ DEBUG
00200A8A  1639 00D30003           1590m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A90  0803 0002               1591m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A94  67F4                    1592m       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00200A96  13C2 00D30007           1593m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A9C                          1594m     ENDC
00200A9C                          1595m     
00200A9C                 FALSE    1596m     IFNE DEBUG
00200A9C                          1597m     ENDC
00200A9C                          1598m 
00200A9C                          1599m     ENDM
00200A9C                          1600m             HEX2BIN D2,D2,A0
00200A9C  41F9 00201B62           1601m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200AA2  0402 0030               1602m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AA6  C4BC 000000FF           1603m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200AAC  1430 2000               1604m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200AB0                          1605m   ENDM
00200AB0  8E82                    1606              OR.L D2,D7
00200AB2  E98F                    1607              LSL.L #4,D7
00200AB4                          1608               
00200AB4                          1609m             DOWNLOAD D2,D3            ; LS 4 bits    
00200AB4                          1610m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB4                          1611m 
00200AB4  1639 00D30003           1612m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200ABA  0803 0000               1613m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200ABE  6700 0010               1614m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00200AC2                          1615m  
00200AC2                          1616mm     READ_CHAR D2
00200AC2                 TRUE     1617mm     IFEQ DEBUG
00200AC2  1439 00D30007           1618mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200AC8                          1619mm     ENDC
00200AC8                 FALSE    1620mm     IFNE DEBUG
00200AC8                          1621mm     ENDC
00200AC8                          1622mm      
00200AC8  B43C 001B               1623mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200ACC  6700 F53A               1624mm     BEQ START
00200AD0                          1625mm     ENDM
00200AD0                          1626m CONTINUE_104
00200AD0  1639 00D30013           1627m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200AD6  0803 0000               1628m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200ADA  67D8                    1629m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00200ADC                          1630m     
00200ADC  1439 00D30017           1631m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200AE2  13C2 00E00001           1632m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200AE8                          1633m     
00200AE8                          1634m     ENDM
00200AE8                          1635m             PRINT_CHAR D2,D3
00200AE8                          1636m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE8                 TRUE     1637m     IFEQ DEBUG
00200AE8  1639 00D30003           1638m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200AEE  0803 0002               1639m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200AF2  67F4                    1640m       BEQ WAIT_FOR_READY_106          ; NO SPACE, CHECK AGAIN
00200AF4  13C2 00D30007           1641m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200AFA                          1642m     ENDC
00200AFA                          1643m     
00200AFA                 FALSE    1644m     IFNE DEBUG
00200AFA                          1645m     ENDC
00200AFA                          1646m 
00200AFA                          1647m     ENDM
00200AFA                          1648m             HEX2BIN D2,D2,A0
00200AFA  41F9 00201B62           1649m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B00  0402 0030               1650m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B04  C4BC 000000FF           1651m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B0A  1430 2000               1652m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B0E                          1653m   ENDM
00200B0E  8E82                    1654              OR.L D2,D7
00200B10                          1655                          
00200B10  DC87                    1656              ADD.L D7,D6               ; add into checksum
00200B12                          1657              
00200B12  E98F                    1658              LSL.L #4,D7
00200B14                          1659m             DOWNLOAD D2,D3            ; MS 4 bits
00200B14                          1660m WAIT_FOR_READY_108                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B14                          1661m 
00200B14  1639 00D30003           1662m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B1A  0803 0000               1663m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B1E  6700 0010               1664m     BEQ CONTINUE_108                ; NOTHING, CONTINUE
00200B22                          1665m  
00200B22                          1666mm     READ_CHAR D2
00200B22                 TRUE     1667mm     IFEQ DEBUG
00200B22  1439 00D30007           1668mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B28                          1669mm     ENDC
00200B28                 FALSE    1670mm     IFNE DEBUG
00200B28                          1671mm     ENDC
00200B28                          1672mm      
00200B28  B43C 001B               1673mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B2C  6700 F4DA               1674mm     BEQ START
00200B30                          1675mm     ENDM
00200B30                          1676m CONTINUE_108
00200B30  1639 00D30013           1677m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B36  0803 0000               1678m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B3A  67D8                    1679m     BEQ WAIT_FOR_READY_108        ; NOTHING, CHECK AGAIN
00200B3C                          1680m     
00200B3C  1439 00D30017           1681m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B42  13C2 00E00001           1682m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B48                          1683m     
00200B48                          1684m     ENDM
00200B48                          1685m             PRINT_CHAR D2,D3
00200B48                          1686m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B48                 TRUE     1687m     IFEQ DEBUG
00200B48  1639 00D30003           1688m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200B4E  0803 0002               1689m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200B52  67F4                    1690m       BEQ WAIT_FOR_READY_110          ; NO SPACE, CHECK AGAIN
00200B54  13C2 00D30007           1691m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200B5A                          1692m     ENDC
00200B5A                          1693m     
00200B5A                 FALSE    1694m     IFNE DEBUG
00200B5A                          1695m     ENDC
00200B5A                          1696m 
00200B5A                          1697m     ENDM
00200B5A                          1698m             HEX2BIN D2,D2,A0
00200B5A  41F9 00201B62           1699m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B60  0402 0030               1700m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B64  C4BC 000000FF           1701m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B6A  1430 2000               1702m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B6E                          1703m   ENDM
00200B6E  8E82                    1704              OR.L D2,D7
00200B70                          1705               
00200B70  E98F                    1706              LSL.L #4,D7
00200B72                          1707m             DOWNLOAD D2,D3            ; LS 4 bits    
00200B72                          1708m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B72                          1709m 
00200B72  1639 00D30003           1710m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B78  0803 0000               1711m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B7C  6700 0010               1712m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00200B80                          1713m  
00200B80                          1714mm     READ_CHAR D2
00200B80                 TRUE     1715mm     IFEQ DEBUG
00200B80  1439 00D30007           1716mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B86                          1717mm     ENDC
00200B86                 FALSE    1718mm     IFNE DEBUG
00200B86                          1719mm     ENDC
00200B86                          1720mm      
00200B86  B43C 001B               1721mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B8A  6700 F47C               1722mm     BEQ START
00200B8E                          1723mm     ENDM
00200B8E                          1724m CONTINUE_112
00200B8E  1639 00D30013           1725m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B94  0803 0000               1726m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B98  67D8                    1727m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00200B9A                          1728m     
00200B9A  1439 00D30017           1729m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200BA0  13C2 00E00001           1730m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200BA6                          1731m     
00200BA6                          1732m     ENDM
00200BA6                          1733m             PRINT_CHAR D2,D3
00200BA6                          1734m WAIT_FOR_READY_114                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BA6                 TRUE     1735m     IFEQ DEBUG
00200BA6  1639 00D30003           1736m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200BAC  0803 0002               1737m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200BB0  67F4                    1738m       BEQ WAIT_FOR_READY_114          ; NO SPACE, CHECK AGAIN
00200BB2  13C2 00D30007           1739m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200BB8                          1740m     ENDC
00200BB8                          1741m     
00200BB8                 FALSE    1742m     IFNE DEBUG
00200BB8                          1743m     ENDC
00200BB8                          1744m 
00200BB8                          1745m     ENDM
00200BB8                          1746m             HEX2BIN D2,D2,A0
00200BB8  41F9 00201B62           1747m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200BBE  0402 0030               1748m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BC2  C4BC 000000FF           1749m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200BC8  1430 2000               1750m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200BCC                          1751m   ENDM
00200BCC  8E82                    1752              OR.L D2,D7
00200BCE                          1753              
00200BCE  7400                    1754              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00200BD0  1407                    1755              MOVE.B D7,D2
00200BD2  DC82                    1756              ADD.L D2,D6
00200BD4                          1757              
00200BD4  32C7                    1758              MOVE.W D7,(A1)+          ; store it!
00200BD6                          1759          ENDW
00200BD6  6000 FE70               1760s     BRA _10000002
00200BDA                          1761s _10000003
00200BDA                          1762          
00200BDA                          1763          IF D5 <EQ> #1 THEN
00200BDA  BA7C 0001               1764s     CMP.W   #1,D5
00200BDE  6600 00CE               1765s     BNE _00000003
00200BE2  7E00                    1766              MOVE.L #0,D7              ; D7 holds the word
00200BE4                          1767                      
00200BE4                          1768m             DOWNLOAD D2,D3            ; MS 4 bits
00200BE4                          1769m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BE4                          1770m 
00200BE4  1639 00D30003           1771m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200BEA  0803 0000               1772m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200BEE  6700 0010               1773m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00200BF2                          1774m  
00200BF2                          1775mm     READ_CHAR D2
00200BF2                 TRUE     1776mm     IFEQ DEBUG
00200BF2  1439 00D30007           1777mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200BF8                          1778mm     ENDC
00200BF8                 FALSE    1779mm     IFNE DEBUG
00200BF8                          1780mm     ENDC
00200BF8                          1781mm      
00200BF8  B43C 001B               1782mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200BFC  6700 F40A               1783mm     BEQ START
00200C00                          1784mm     ENDM
00200C00                          1785m CONTINUE_116
00200C00  1639 00D30013           1786m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C06  0803 0000               1787m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C0A  67D8                    1788m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00200C0C                          1789m     
00200C0C  1439 00D30017           1790m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C12  13C2 00E00001           1791m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C18                          1792m     
00200C18                          1793m     ENDM
00200C18                          1794m             PRINT_CHAR D2,D3
00200C18                          1795m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C18                 TRUE     1796m     IFEQ DEBUG
00200C18  1639 00D30003           1797m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C1E  0803 0002               1798m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C22  67F4                    1799m       BEQ WAIT_FOR_READY_118          ; NO SPACE, CHECK AGAIN
00200C24  13C2 00D30007           1800m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C2A                          1801m     ENDC
00200C2A                          1802m     
00200C2A                 FALSE    1803m     IFNE DEBUG
00200C2A                          1804m     ENDC
00200C2A                          1805m 
00200C2A                          1806m     ENDM
00200C2A                          1807m             HEX2BIN D2,D2,A0
00200C2A  41F9 00201B62           1808m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C30  0402 0030               1809m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C34  C4BC 000000FF           1810m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C3A  1430 2000               1811m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C3E                          1812m   ENDM
00200C3E  8E82                    1813              OR.L D2,D7
00200C40  E98F                    1814              LSL.L #4,D7
00200C42                          1815               
00200C42                          1816m             DOWNLOAD D2,D3            ; LS 4 bits    
00200C42                          1817m WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C42                          1818m 
00200C42  1639 00D30003           1819m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200C48  0803 0000               1820m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200C4C  6700 0010               1821m     BEQ CONTINUE_120                ; NOTHING, CONTINUE
00200C50                          1822m  
00200C50                          1823mm     READ_CHAR D2
00200C50                 TRUE     1824mm     IFEQ DEBUG
00200C50  1439 00D30007           1825mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200C56                          1826mm     ENDC
00200C56                 FALSE    1827mm     IFNE DEBUG
00200C56                          1828mm     ENDC
00200C56                          1829mm      
00200C56  B43C 001B               1830mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200C5A  6700 F3AC               1831mm     BEQ START
00200C5E                          1832mm     ENDM
00200C5E                          1833m CONTINUE_120
00200C5E  1639 00D30013           1834m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C64  0803 0000               1835m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C68  67D8                    1836m     BEQ WAIT_FOR_READY_120        ; NOTHING, CHECK AGAIN
00200C6A                          1837m     
00200C6A  1439 00D30017           1838m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C70  13C2 00E00001           1839m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C76                          1840m     
00200C76                          1841m     ENDM
00200C76                          1842m             PRINT_CHAR D2,D3
00200C76                          1843m WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C76                 TRUE     1844m     IFEQ DEBUG
00200C76  1639 00D30003           1845m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C7C  0803 0002               1846m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C80  67F4                    1847m       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00200C82  13C2 00D30007           1848m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C88                          1849m     ENDC
00200C88                          1850m     
00200C88                 FALSE    1851m     IFNE DEBUG
00200C88                          1852m     ENDC
00200C88                          1853m 
00200C88                          1854m     ENDM
00200C88                          1855m             HEX2BIN D2,D2,A0
00200C88  41F9 00201B62           1856m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C8E  0402 0030               1857m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C92  C4BC 000000FF           1858m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C98  1430 2000               1859m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C9C                          1860m   ENDM
00200C9C  8E82                    1861              OR.L D2,D7
00200C9E                          1862                          
00200C9E  DC87                    1863              ADD.L D7,D6               ; add into checksum
00200CA0                          1864              
00200CA0  3611                    1865              MOVE.W (A1),D3            ; get the current data and replace the top byte
00200CA2  E18F                    1866              LSL.L #8,D7
00200CA4  C6BC 000000FF           1867              AND.L #$00FF,D3
00200CAA  8687                    1868              OR.L D7,D3
00200CAC                          1869  
00200CAC  32C3                    1870              MOVE.W D3,(A1)+          ; store it!
00200CAE                          1871          ENDI
00200CAE                          1872s _00000003
00200CAE                          1873    
00200CAE                          1874m         PRINT_CRLF D3
00200CAE                          1875mm     PRINT_CHAR #13,D3             ; CR
00200CAE                          1876mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CAE                 TRUE     1877mm     IFEQ DEBUG
00200CAE  1639 00D30003           1878mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CB4  0803 0002               1879mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CB8  67F4                    1880mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00200CBA  13FC 000D 00D30007      1881mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CC2                          1882mm     ENDC
00200CC2                          1883mm     
00200CC2                 FALSE    1884mm     IFNE DEBUG
00200CC2                          1885mm     ENDC
00200CC2                          1886mm 
00200CC2                          1887mm     ENDM
00200CC2                          1888mm     PRINT_CHAR #10,D3             ; LF
00200CC2                          1889mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CC2                 TRUE     1890mm     IFEQ DEBUG
00200CC2  1639 00D30003           1891mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CC8  0803 0002               1892mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CCC  67F4                    1893mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00200CCE  13FC 000A 00D30007      1894mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CD6                          1895mm     ENDC
00200CD6                          1896mm     
00200CD6                 FALSE    1897mm     IFNE DEBUG
00200CD6                          1898mm     ENDC
00200CD6                          1899mm 
00200CD6                          1900mm     ENDM
00200CD6                          1901m     ENDM
00200CD6  43F9 002004A8           1902          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00200CDC                          1903        ELSE
00200CDC  6000 0812               1904s     BRA _00000004
00200CE0                          1905s _00000002
00200CE0                          1906          IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00200CE0  BE3C 0032               1907s     CMP.B   #'2',D7
00200CE4  6600 05BA               1908s     BNE.L   _00000005
00200CE8  7E00                    1909            MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200CEA                          1910m           DOWNLOAD D2,D3              ; top byte
00200CEA                          1911m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CEA                          1912m 
00200CEA  1639 00D30003           1913m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200CF0  0803 0000               1914m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200CF4  6700 0010               1915m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00200CF8                          1916m  
00200CF8                          1917mm     READ_CHAR D2
00200CF8                 TRUE     1918mm     IFEQ DEBUG
00200CF8  1439 00D30007           1919mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200CFE                          1920mm     ENDC
00200CFE                 FALSE    1921mm     IFNE DEBUG
00200CFE                          1922mm     ENDC
00200CFE                          1923mm      
00200CFE  B43C 001B               1924mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D02  6700 F304               1925mm     BEQ START
00200D06                          1926mm     ENDM
00200D06                          1927m CONTINUE_127
00200D06  1639 00D30013           1928m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D0C  0803 0000               1929m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D10  67D8                    1930m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00200D12                          1931m     
00200D12  1439 00D30017           1932m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D18  13C2 00E00001           1933m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D1E                          1934m     
00200D1E                          1935m     ENDM
00200D1E                          1936m           PRINT_CHAR D2,D3
00200D1E                          1937m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D1E                 TRUE     1938m     IFEQ DEBUG
00200D1E  1639 00D30003           1939m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D24  0803 0002               1940m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D28  67F4                    1941m       BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00200D2A  13C2 00D30007           1942m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D30                          1943m     ENDC
00200D30                          1944m     
00200D30                 FALSE    1945m     IFNE DEBUG
00200D30                          1946m     ENDC
00200D30                          1947m 
00200D30                          1948m     ENDM
00200D30                          1949m           HEX2BIN D2,D2,A0
00200D30  41F9 00201B62           1950m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D36  0402 0030               1951m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D3A  C4BC 000000FF           1952m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D40  1430 2000               1953m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D44                          1954m   ENDM
00200D44  8E82                    1955            OR.L D2,D7
00200D46  E98F                    1956            LSL.L #4,D7
00200D48                          1957m           DOWNLOAD D2,D3         
00200D48                          1958m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D48                          1959m 
00200D48  1639 00D30003           1960m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200D4E  0803 0000               1961m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200D52  6700 0010               1962m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00200D56                          1963m  
00200D56                          1964mm     READ_CHAR D2
00200D56                 TRUE     1965mm     IFEQ DEBUG
00200D56  1439 00D30007           1966mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200D5C                          1967mm     ENDC
00200D5C                 FALSE    1968mm     IFNE DEBUG
00200D5C                          1969mm     ENDC
00200D5C                          1970mm      
00200D5C  B43C 001B               1971mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D60  6700 F2A6               1972mm     BEQ START
00200D64                          1973mm     ENDM
00200D64                          1974m CONTINUE_131
00200D64  1639 00D30013           1975m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D6A  0803 0000               1976m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D6E  67D8                    1977m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00200D70                          1978m     
00200D70  1439 00D30017           1979m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D76  13C2 00E00001           1980m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D7C                          1981m     
00200D7C                          1982m     ENDM
00200D7C                          1983m           PRINT_CHAR D2,D3
00200D7C                          1984m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D7C                 TRUE     1985m     IFEQ DEBUG
00200D7C  1639 00D30003           1986m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D82  0803 0002               1987m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D86  67F4                    1988m       BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00200D88  13C2 00D30007           1989m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D8E                          1990m     ENDC
00200D8E                          1991m     
00200D8E                 FALSE    1992m     IFNE DEBUG
00200D8E                          1993m     ENDC
00200D8E                          1994m 
00200D8E                          1995m     ENDM
00200D8E                          1996m           HEX2BIN D2,D2,A0
00200D8E  41F9 00201B62           1997m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D94  0402 0030               1998m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D98  C4BC 000000FF           1999m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D9E  1430 2000               2000m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200DA2                          2001m   ENDM
00200DA2  8E82                    2002            OR.L D2,D7
00200DA4                          2003          
00200DA4  DC87                    2004            ADD.L D7,D6                 ; add top byte of address into checksum
00200DA6                          2005  
00200DA6  E98F                    2006            LSL.L #4,D7                 ; middle byte
00200DA8                          2007m           DOWNLOAD D2,D3
00200DA8                          2008m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA8                          2009m 
00200DA8  1639 00D30003           2010m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200DAE  0803 0000               2011m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200DB2  6700 0010               2012m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00200DB6                          2013m  
00200DB6                          2014mm     READ_CHAR D2
00200DB6                 TRUE     2015mm     IFEQ DEBUG
00200DB6  1439 00D30007           2016mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200DBC                          2017mm     ENDC
00200DBC                 FALSE    2018mm     IFNE DEBUG
00200DBC                          2019mm     ENDC
00200DBC                          2020mm      
00200DBC  B43C 001B               2021mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200DC0  6700 F246               2022mm     BEQ START
00200DC4                          2023mm     ENDM
00200DC4                          2024m CONTINUE_135
00200DC4  1639 00D30013           2025m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200DCA  0803 0000               2026m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200DCE  67D8                    2027m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00200DD0                          2028m     
00200DD0  1439 00D30017           2029m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200DD6  13C2 00E00001           2030m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200DDC                          2031m     
00200DDC                          2032m     ENDM
00200DDC                          2033m           PRINT_CHAR D2,D3
00200DDC                          2034m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DDC                 TRUE     2035m     IFEQ DEBUG
00200DDC  1639 00D30003           2036m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200DE2  0803 0002               2037m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200DE6  67F4                    2038m       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00200DE8  13C2 00D30007           2039m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200DEE                          2040m     ENDC
00200DEE                          2041m     
00200DEE                 FALSE    2042m     IFNE DEBUG
00200DEE                          2043m     ENDC
00200DEE                          2044m 
00200DEE                          2045m     ENDM
00200DEE                          2046m           HEX2BIN D2,D2,A0
00200DEE  41F9 00201B62           2047m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200DF4  0402 0030               2048m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF8  C4BC 000000FF           2049m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200DFE  1430 2000               2050m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200E02                          2051m   ENDM
00200E02  8E82                    2052            OR.L D2,D7
00200E04  E98F                    2053            LSL.L #4,D7        
00200E06                          2054m           DOWNLOAD D2,D3
00200E06                          2055m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E06                          2056m 
00200E06  1639 00D30003           2057m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E0C  0803 0000               2058m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E10  6700 0010               2059m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00200E14                          2060m  
00200E14                          2061mm     READ_CHAR D2
00200E14                 TRUE     2062mm     IFEQ DEBUG
00200E14  1439 00D30007           2063mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E1A                          2064mm     ENDC
00200E1A                 FALSE    2065mm     IFNE DEBUG
00200E1A                          2066mm     ENDC
00200E1A                          2067mm      
00200E1A  B43C 001B               2068mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E1E  6700 F1E8               2069mm     BEQ START
00200E22                          2070mm     ENDM
00200E22                          2071m CONTINUE_139
00200E22  1639 00D30013           2072m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E28  0803 0000               2073m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E2C  67D8                    2074m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00200E2E                          2075m     
00200E2E  1439 00D30017           2076m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E34  13C2 00E00001           2077m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E3A                          2078m     
00200E3A                          2079m     ENDM
00200E3A                          2080m           PRINT_CHAR D2,D3
00200E3A                          2081m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E3A                 TRUE     2082m     IFEQ DEBUG
00200E3A  1639 00D30003           2083m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E40  0803 0002               2084m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E44  67F4                    2085m       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00200E46  13C2 00D30007           2086m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E4C                          2087m     ENDC
00200E4C                          2088m     
00200E4C                 FALSE    2089m     IFNE DEBUG
00200E4C                          2090m     ENDC
00200E4C                          2091m 
00200E4C                          2092m     ENDM
00200E4C                          2093m           HEX2BIN D2,D2,A0
00200E4C  41F9 00201B62           2094m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200E52  0402 0030               2095m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E56  C4BC 000000FF           2096m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200E5C  1430 2000               2097m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200E60                          2098m   ENDM
00200E60  8E82                    2099            OR.L D2,D7
00200E62                          2100          
00200E62  7400                    2101            MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00200E64  1407                    2102            MOVE.B D7,D2
00200E66  DC82                    2103            ADD.L D2,D6
00200E68                          2104            
00200E68  E98F                    2105            LSL.L #4,D7                 ; bottom byte
00200E6A                          2106m           DOWNLOAD D2,D3
00200E6A                          2107m WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E6A                          2108m 
00200E6A  1639 00D30003           2109m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E70  0803 0000               2110m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E74  6700 0010               2111m     BEQ CONTINUE_143                ; NOTHING, CONTINUE
00200E78                          2112m  
00200E78                          2113mm     READ_CHAR D2
00200E78                 TRUE     2114mm     IFEQ DEBUG
00200E78  1439 00D30007           2115mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E7E                          2116mm     ENDC
00200E7E                 FALSE    2117mm     IFNE DEBUG
00200E7E                          2118mm     ENDC
00200E7E                          2119mm      
00200E7E  B43C 001B               2120mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E82  6700 F184               2121mm     BEQ START
00200E86                          2122mm     ENDM
00200E86                          2123m CONTINUE_143
00200E86  1639 00D30013           2124m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E8C  0803 0000               2125m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E90  67D8                    2126m     BEQ WAIT_FOR_READY_143        ; NOTHING, CHECK AGAIN
00200E92                          2127m     
00200E92  1439 00D30017           2128m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E98  13C2 00E00001           2129m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E9E                          2130m     
00200E9E                          2131m     ENDM
00200E9E                          2132m           PRINT_CHAR D2,D3
00200E9E                          2133m WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E9E                 TRUE     2134m     IFEQ DEBUG
00200E9E  1639 00D30003           2135m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200EA4  0803 0002               2136m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200EA8  67F4                    2137m       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00200EAA  13C2 00D30007           2138m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200EB0                          2139m     ENDC
00200EB0                          2140m     
00200EB0                 FALSE    2141m     IFNE DEBUG
00200EB0                          2142m     ENDC
00200EB0                          2143m 
00200EB0                          2144m     ENDM
00200EB0                          2145m           HEX2BIN D2,D2,A0
00200EB0  41F9 00201B62           2146m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200EB6  0402 0030               2147m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EBA  C4BC 000000FF           2148m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200EC0  1430 2000               2149m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200EC4                          2150m   ENDM
00200EC4  8E82                    2151            OR.L D2,D7
00200EC6  E98F                    2152            LSL.L #4,D7        
00200EC8                          2153m           DOWNLOAD D2,D3
00200EC8                          2154m WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC8                          2155m 
00200EC8  1639 00D30003           2156m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200ECE  0803 0000               2157m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200ED2  6700 0010               2158m     BEQ CONTINUE_147                ; NOTHING, CONTINUE
00200ED6                          2159m  
00200ED6                          2160mm     READ_CHAR D2
00200ED6                 TRUE     2161mm     IFEQ DEBUG
00200ED6  1439 00D30007           2162mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200EDC                          2163mm     ENDC
00200EDC                 FALSE    2164mm     IFNE DEBUG
00200EDC                          2165mm     ENDC
00200EDC                          2166mm      
00200EDC  B43C 001B               2167mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200EE0  6700 F126               2168mm     BEQ START
00200EE4                          2169mm     ENDM
00200EE4                          2170m CONTINUE_147
00200EE4  1639 00D30013           2171m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200EEA  0803 0000               2172m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200EEE  67D8                    2173m     BEQ WAIT_FOR_READY_147        ; NOTHING, CHECK AGAIN
00200EF0                          2174m     
00200EF0  1439 00D30017           2175m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200EF6  13C2 00E00001           2176m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200EFC                          2177m     
00200EFC                          2178m     ENDM
00200EFC                          2179m           PRINT_CHAR D2,D3
00200EFC                          2180m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EFC                 TRUE     2181m     IFEQ DEBUG
00200EFC  1639 00D30003           2182m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200F02  0803 0002               2183m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200F06  67F4                    2184m       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00200F08  13C2 00D30007           2185m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F0E                          2186m     ENDC
00200F0E                          2187m     
00200F0E                 FALSE    2188m     IFNE DEBUG
00200F0E                          2189m     ENDC
00200F0E                          2190m 
00200F0E                          2191m     ENDM
00200F0E                          2192m           HEX2BIN D2,D2,A0
00200F0E  41F9 00201B62           2193m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F14  0402 0030               2194m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F18  C4BC 000000FF           2195m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F1E  1430 2000               2196m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F22                          2197m   ENDM
00200F22  8E82                    2198            OR.L D2,D7
00200F24                          2199          
00200F24  7400                    2200            MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200F26  1407                    2201            MOVE.B D7,D2
00200F28  DC82                    2202            ADD.L D2,D6
00200F2A                          2203          
00200F2A  2247                    2204            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F2C  D3CB                    2205            ADD.L A3,A1                 ; add in the offset
00200F2E                          2206            
00200F2E  0807 0000               2207            BTST #0,D7                  ; deal with odd addresses
00200F32                          2208  
00200F32  2247                    2209            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F34  6700 00D0               2210            BEQ EVEN2
00200F38                          2211                  
00200F38  5385                    2212            SUB.L #1,D5
00200F3A  5389                    2213            SUB.L #1,A1
00200F3C                          2214          
00200F3C  7E00                    2215            MOVE.L #0,D7
00200F3E                          2216m           DOWNLOAD D2,D3            ; MS 4 bits
00200F3E                          2217m WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F3E                          2218m 
00200F3E  1639 00D30003           2219m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F44  0803 0000               2220m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F48  6700 0010               2221m     BEQ CONTINUE_151                ; NOTHING, CONTINUE
00200F4C                          2222m  
00200F4C                          2223mm     READ_CHAR D2
00200F4C                 TRUE     2224mm     IFEQ DEBUG
00200F4C  1439 00D30007           2225mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200F52                          2226mm     ENDC
00200F52                 FALSE    2227mm     IFNE DEBUG
00200F52                          2228mm     ENDC
00200F52                          2229mm      
00200F52  B43C 001B               2230mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200F56  6700 F0B0               2231mm     BEQ START
00200F5A                          2232mm     ENDM
00200F5A                          2233m CONTINUE_151
00200F5A  1639 00D30013           2234m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200F60  0803 0000               2235m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200F64  67D8                    2236m     BEQ WAIT_FOR_READY_151        ; NOTHING, CHECK AGAIN
00200F66                          2237m     
00200F66  1439 00D30017           2238m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200F6C  13C2 00E00001           2239m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200F72                          2240m     
00200F72                          2241m     ENDM
00200F72                          2242m           PRINT_CHAR D2,D3
00200F72                          2243m WAIT_FOR_READY_153                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F72                 TRUE     2244m     IFEQ DEBUG
00200F72  1639 00D30003           2245m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200F78  0803 0002               2246m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200F7C  67F4                    2247m       BEQ WAIT_FOR_READY_153          ; NO SPACE, CHECK AGAIN
00200F7E  13C2 00D30007           2248m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F84                          2249m     ENDC
00200F84                          2250m     
00200F84                 FALSE    2251m     IFNE DEBUG
00200F84                          2252m     ENDC
00200F84                          2253m 
00200F84                          2254m     ENDM
00200F84                          2255m           HEX2BIN D2,D2,A0
00200F84  41F9 00201B62           2256m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F8A  0402 0030               2257m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F8E  C4BC 000000FF           2258m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F94  1430 2000               2259m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F98                          2260m   ENDM
00200F98  8E82                    2261            OR.L D2,D7
00200F9A  E98F                    2262            LSL.L #4,D7
00200F9C                          2263               
00200F9C                          2264m           DOWNLOAD D2,D3            ; LS 4 bits    
00200F9C                          2265m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F9C                          2266m 
00200F9C  1639 00D30003           2267m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200FA2  0803 0000               2268m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200FA6  6700 0010               2269m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00200FAA                          2270m  
00200FAA                          2271mm     READ_CHAR D2
00200FAA                 TRUE     2272mm     IFEQ DEBUG
00200FAA  1439 00D30007           2273mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200FB0                          2274mm     ENDC
00200FB0                 FALSE    2275mm     IFNE DEBUG
00200FB0                          2276mm     ENDC
00200FB0                          2277mm      
00200FB0  B43C 001B               2278mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200FB4  6700 F052               2279mm     BEQ START
00200FB8                          2280mm     ENDM
00200FB8                          2281m CONTINUE_155
00200FB8  1639 00D30013           2282m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200FBE  0803 0000               2283m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200FC2  67D8                    2284m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00200FC4                          2285m     
00200FC4  1439 00D30017           2286m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200FCA  13C2 00E00001           2287m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200FD0                          2288m     
00200FD0                          2289m     ENDM
00200FD0                          2290m           PRINT_CHAR D2,D3
00200FD0                          2291m WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FD0                 TRUE     2292m     IFEQ DEBUG
00200FD0  1639 00D30003           2293m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200FD6  0803 0002               2294m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200FDA  67F4                    2295m       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00200FDC  13C2 00D30007           2296m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200FE2                          2297m     ENDC
00200FE2                          2298m     
00200FE2                 FALSE    2299m     IFNE DEBUG
00200FE2                          2300m     ENDC
00200FE2                          2301m 
00200FE2                          2302m     ENDM
00200FE2                          2303m           HEX2BIN D2,D2,A0
00200FE2  41F9 00201B62           2304m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200FE8  0402 0030               2305m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FEC  C4BC 000000FF           2306m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200FF2  1430 2000               2307m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200FF6                          2308m   ENDM
00200FF6  8E82                    2309            OR.L D2,D7
00200FF8                          2310                          
00200FF8  DC87                    2311            ADD.L D7,D6               ; add into checksum
00200FFA                          2312                        
00200FFA  3611                    2313            MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200FFC                          2314          
00200FFC  0243 FF00               2315            ANDI.W #$FF00,D3
00201000  8647                    2316            OR.W D7,D3
00201002                          2317          
00201002  3283                    2318            MOVE.W D3,(A1)           ; store it!
00201004  5489                    2319            ADD.L #2,A1
00201006                          2320  EVEN2
00201006  5985                    2321            SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00201008                          2322            WHILE.L D5 <GE> #2 DO       ; read the data bytes
00201008                          2323s _10000004
00201008  BABC 00000002           2324s     CMP.L   #2,D5
0020100E  6D00 018A               2325s     BLT _10000005
00201012  5585                    2326              SUB.L #2,D5
00201014                          2327              
00201014  7E00                    2328              MOVE.L #0,D7              ; D7 holds the word
00201016                          2329              
00201016                          2330m             DOWNLOAD D2,D3            ; MS 4 bits
00201016                          2331m WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201016                          2332m 
00201016  1639 00D30003           2333m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020101C  0803 0000               2334m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201020  6700 0010               2335m     BEQ CONTINUE_159                ; NOTHING, CONTINUE
00201024                          2336m  
00201024                          2337mm     READ_CHAR D2
00201024                 TRUE     2338mm     IFEQ DEBUG
00201024  1439 00D30007           2339mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020102A                          2340mm     ENDC
0020102A                 FALSE    2341mm     IFNE DEBUG
0020102A                          2342mm     ENDC
0020102A                          2343mm      
0020102A  B43C 001B               2344mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020102E  6700 EFD8               2345mm     BEQ START
00201032                          2346mm     ENDM
00201032                          2347m CONTINUE_159
00201032  1639 00D30013           2348m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201038  0803 0000               2349m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020103C  67D8                    2350m     BEQ WAIT_FOR_READY_159        ; NOTHING, CHECK AGAIN
0020103E                          2351m     
0020103E  1439 00D30017           2352m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201044  13C2 00E00001           2353m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020104A                          2354m     
0020104A                          2355m     ENDM
0020104A                          2356m             PRINT_CHAR D2,D3
0020104A                          2357m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020104A                 TRUE     2358m     IFEQ DEBUG
0020104A  1639 00D30003           2359m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201050  0803 0002               2360m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201054  67F4                    2361m       BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
00201056  13C2 00D30007           2362m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020105C                          2363m     ENDC
0020105C                          2364m     
0020105C                 FALSE    2365m     IFNE DEBUG
0020105C                          2366m     ENDC
0020105C                          2367m 
0020105C                          2368m     ENDM
0020105C                          2369m             HEX2BIN D2,D2,A0
0020105C  41F9 00201B62           2370m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201062  0402 0030               2371m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201066  C4BC 000000FF           2372m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020106C  1430 2000               2373m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201070                          2374m   ENDM
00201070  8E82                    2375              OR.L D2,D7
00201072  E98F                    2376              LSL.L #4,D7
00201074                          2377               
00201074                          2378m             DOWNLOAD D2,D3            ; LS 4 bits    
00201074                          2379m WAIT_FOR_READY_163                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201074                          2380m 
00201074  1639 00D30003           2381m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020107A  0803 0000               2382m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020107E  6700 0010               2383m     BEQ CONTINUE_163                ; NOTHING, CONTINUE
00201082                          2384m  
00201082                          2385mm     READ_CHAR D2
00201082                 TRUE     2386mm     IFEQ DEBUG
00201082  1439 00D30007           2387mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201088                          2388mm     ENDC
00201088                 FALSE    2389mm     IFNE DEBUG
00201088                          2390mm     ENDC
00201088                          2391mm      
00201088  B43C 001B               2392mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020108C  6700 EF7A               2393mm     BEQ START
00201090                          2394mm     ENDM
00201090                          2395m CONTINUE_163
00201090  1639 00D30013           2396m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201096  0803 0000               2397m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020109A  67D8                    2398m     BEQ WAIT_FOR_READY_163        ; NOTHING, CHECK AGAIN
0020109C                          2399m     
0020109C  1439 00D30017           2400m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002010A2  13C2 00E00001           2401m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002010A8                          2402m     
002010A8                          2403m     ENDM
002010A8                          2404m             PRINT_CHAR D2,D3
002010A8                          2405m WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A8                 TRUE     2406m     IFEQ DEBUG
002010A8  1639 00D30003           2407m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002010AE  0803 0002               2408m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002010B2  67F4                    2409m       BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
002010B4  13C2 00D30007           2410m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002010BA                          2411m     ENDC
002010BA                          2412m     
002010BA                 FALSE    2413m     IFNE DEBUG
002010BA                          2414m     ENDC
002010BA                          2415m 
002010BA                          2416m     ENDM
002010BA                          2417m             HEX2BIN D2,D2,A0
002010BA  41F9 00201B62           2418m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002010C0  0402 0030               2419m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002010C4  C4BC 000000FF           2420m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002010CA  1430 2000               2421m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002010CE                          2422m   ENDM
002010CE  8E82                    2423              OR.L D2,D7
002010D0                          2424                          
002010D0  DC87                    2425              ADD.L D7,D6               ; add into checksum
002010D2                          2426              
002010D2  E98F                    2427              LSL.L #4,D7
002010D4                          2428m             DOWNLOAD D2,D3            ; MS 4 bits
002010D4                          2429m WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010D4                          2430m 
002010D4  1639 00D30003           2431m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002010DA  0803 0000               2432m     BTST #0,D3                    ; CHECK FOR CHARACTER
002010DE  6700 0010               2433m     BEQ CONTINUE_167                ; NOTHING, CONTINUE
002010E2                          2434m  
002010E2                          2435mm     READ_CHAR D2
002010E2                 TRUE     2436mm     IFEQ DEBUG
002010E2  1439 00D30007           2437mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002010E8                          2438mm     ENDC
002010E8                 FALSE    2439mm     IFNE DEBUG
002010E8                          2440mm     ENDC
002010E8                          2441mm      
002010E8  B43C 001B               2442mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002010EC  6700 EF1A               2443mm     BEQ START
002010F0                          2444mm     ENDM
002010F0                          2445m CONTINUE_167
002010F0  1639 00D30013           2446m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002010F6  0803 0000               2447m     BTST #0,D3                  ; CHECK FOR CHARACTER
002010FA  67D8                    2448m     BEQ WAIT_FOR_READY_167        ; NOTHING, CHECK AGAIN
002010FC                          2449m     
002010FC  1439 00D30017           2450m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201102  13C2 00E00001           2451m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201108                          2452m     
00201108                          2453m     ENDM
00201108                          2454m             PRINT_CHAR D2,D3
00201108                          2455m WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201108                 TRUE     2456m     IFEQ DEBUG
00201108  1639 00D30003           2457m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020110E  0803 0002               2458m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201112  67F4                    2459m       BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
00201114  13C2 00D30007           2460m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020111A                          2461m     ENDC
0020111A                          2462m     
0020111A                 FALSE    2463m     IFNE DEBUG
0020111A                          2464m     ENDC
0020111A                          2465m 
0020111A                          2466m     ENDM
0020111A                          2467m             HEX2BIN D2,D2,A0
0020111A  41F9 00201B62           2468m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201120  0402 0030               2469m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201124  C4BC 000000FF           2470m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020112A  1430 2000               2471m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020112E                          2472m   ENDM
0020112E  8E82                    2473              OR.L D2,D7
00201130                          2474               
00201130  E98F                    2475              LSL.L #4,D7
00201132                          2476m             DOWNLOAD D2,D3            ; LS 4 bits    
00201132                          2477m WAIT_FOR_READY_171                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201132                          2478m 
00201132  1639 00D30003           2479m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201138  0803 0000               2480m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020113C  6700 0010               2481m     BEQ CONTINUE_171                ; NOTHING, CONTINUE
00201140                          2482m  
00201140                          2483mm     READ_CHAR D2
00201140                 TRUE     2484mm     IFEQ DEBUG
00201140  1439 00D30007           2485mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201146                          2486mm     ENDC
00201146                 FALSE    2487mm     IFNE DEBUG
00201146                          2488mm     ENDC
00201146                          2489mm      
00201146  B43C 001B               2490mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020114A  6700 EEBC               2491mm     BEQ START
0020114E                          2492mm     ENDM
0020114E                          2493m CONTINUE_171
0020114E  1639 00D30013           2494m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201154  0803 0000               2495m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201158  67D8                    2496m     BEQ WAIT_FOR_READY_171        ; NOTHING, CHECK AGAIN
0020115A                          2497m     
0020115A  1439 00D30017           2498m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201160  13C2 00E00001           2499m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201166                          2500m     
00201166                          2501m     ENDM
00201166                          2502m             PRINT_CHAR D2,D3
00201166                          2503m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201166                 TRUE     2504m     IFEQ DEBUG
00201166  1639 00D30003           2505m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020116C  0803 0002               2506m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201170  67F4                    2507m       BEQ WAIT_FOR_READY_173          ; NO SPACE, CHECK AGAIN
00201172  13C2 00D30007           2508m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201178                          2509m     ENDC
00201178                          2510m     
00201178                 FALSE    2511m     IFNE DEBUG
00201178                          2512m     ENDC
00201178                          2513m 
00201178                          2514m     ENDM
00201178                          2515m             HEX2BIN D2,D2,A0
00201178  41F9 00201B62           2516m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020117E  0402 0030               2517m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201182  C4BC 000000FF           2518m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201188  1430 2000               2519m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020118C                          2520m   ENDM
0020118C  8E82                    2521              OR.L D2,D7
0020118E                          2522              
0020118E  7400                    2523              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00201190  1407                    2524              MOVE.B D7,D2
00201192  DC82                    2525              ADD.L D2,D6
00201194                          2526              
00201194  32C7                    2527              MOVE.W D7,(A1)+             ; store it!
00201196                          2528              
00201196                          2529            ENDW
00201196  6000 FE70               2530s     BRA _10000004
0020119A                          2531s _10000005
0020119A                          2532              
0020119A                          2533            IF D5 <EQ> #1 THEN
0020119A  BA7C 0001               2534s     CMP.W   #1,D5
0020119E  6600 00CE               2535s     BNE _00000006
002011A2  7E00                    2536              MOVE.L #0,D7              ; D7 holds the word
002011A4                          2537                      
002011A4                          2538m             DOWNLOAD D2,D3            ; MS 4 bits
002011A4                          2539m WAIT_FOR_READY_175                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011A4                          2540m 
002011A4  1639 00D30003           2541m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002011AA  0803 0000               2542m     BTST #0,D3                    ; CHECK FOR CHARACTER
002011AE  6700 0010               2543m     BEQ CONTINUE_175                ; NOTHING, CONTINUE
002011B2                          2544m  
002011B2                          2545mm     READ_CHAR D2
002011B2                 TRUE     2546mm     IFEQ DEBUG
002011B2  1439 00D30007           2547mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002011B8                          2548mm     ENDC
002011B8                 FALSE    2549mm     IFNE DEBUG
002011B8                          2550mm     ENDC
002011B8                          2551mm      
002011B8  B43C 001B               2552mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002011BC  6700 EE4A               2553mm     BEQ START
002011C0                          2554mm     ENDM
002011C0                          2555m CONTINUE_175
002011C0  1639 00D30013           2556m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002011C6  0803 0000               2557m     BTST #0,D3                  ; CHECK FOR CHARACTER
002011CA  67D8                    2558m     BEQ WAIT_FOR_READY_175        ; NOTHING, CHECK AGAIN
002011CC                          2559m     
002011CC  1439 00D30017           2560m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002011D2  13C2 00E00001           2561m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002011D8                          2562m     
002011D8                          2563m     ENDM
002011D8                          2564m             PRINT_CHAR D2,D3
002011D8                          2565m WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011D8                 TRUE     2566m     IFEQ DEBUG
002011D8  1639 00D30003           2567m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011DE  0803 0002               2568m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011E2  67F4                    2569m       BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
002011E4  13C2 00D30007           2570m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002011EA                          2571m     ENDC
002011EA                          2572m     
002011EA                 FALSE    2573m     IFNE DEBUG
002011EA                          2574m     ENDC
002011EA                          2575m 
002011EA                          2576m     ENDM
002011EA                          2577m             HEX2BIN D2,D2,A0
002011EA  41F9 00201B62           2578m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002011F0  0402 0030               2579m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002011F4  C4BC 000000FF           2580m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002011FA  1430 2000               2581m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002011FE                          2582m   ENDM
002011FE  8E82                    2583              OR.L D2,D7
00201200  E98F                    2584              LSL.L #4,D7
00201202                          2585               
00201202                          2586m             DOWNLOAD D2,D3            ; LS 4 bits    
00201202                          2587m WAIT_FOR_READY_179                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201202                          2588m 
00201202  1639 00D30003           2589m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201208  0803 0000               2590m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020120C  6700 0010               2591m     BEQ CONTINUE_179                ; NOTHING, CONTINUE
00201210                          2592m  
00201210                          2593mm     READ_CHAR D2
00201210                 TRUE     2594mm     IFEQ DEBUG
00201210  1439 00D30007           2595mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201216                          2596mm     ENDC
00201216                 FALSE    2597mm     IFNE DEBUG
00201216                          2598mm     ENDC
00201216                          2599mm      
00201216  B43C 001B               2600mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020121A  6700 EDEC               2601mm     BEQ START
0020121E                          2602mm     ENDM
0020121E                          2603m CONTINUE_179
0020121E  1639 00D30013           2604m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201224  0803 0000               2605m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201228  67D8                    2606m     BEQ WAIT_FOR_READY_179        ; NOTHING, CHECK AGAIN
0020122A                          2607m     
0020122A  1439 00D30017           2608m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201230  13C2 00E00001           2609m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201236                          2610m     
00201236                          2611m     ENDM
00201236                          2612m             PRINT_CHAR D2,D3
00201236                          2613m WAIT_FOR_READY_181                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201236                 TRUE     2614m     IFEQ DEBUG
00201236  1639 00D30003           2615m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020123C  0803 0002               2616m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201240  67F4                    2617m       BEQ WAIT_FOR_READY_181          ; NO SPACE, CHECK AGAIN
00201242  13C2 00D30007           2618m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201248                          2619m     ENDC
00201248                          2620m     
00201248                 FALSE    2621m     IFNE DEBUG
00201248                          2622m     ENDC
00201248                          2623m 
00201248                          2624m     ENDM
00201248                          2625m             HEX2BIN D2,D2,A0
00201248  41F9 00201B62           2626m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020124E  0402 0030               2627m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201252  C4BC 000000FF           2628m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201258  1430 2000               2629m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020125C                          2630m   ENDM
0020125C  8E82                    2631              OR.L D2,D7
0020125E                          2632                          
0020125E  DC87                    2633              ADD.L D7,D6               ; add into checksum
00201260                          2634              
00201260  3611                    2635              MOVE.W (A1),D3            ; get the current data and replace the top byte
00201262  E18F                    2636              LSL.L #8,D7
00201264  C6BC 000000FF           2637              AND.L #$00FF,D3
0020126A  8687                    2638              OR.L D7,D3
0020126C                          2639  
0020126C  32C3                    2640              MOVE.W D3,(A1)+          ; store it!
0020126E                          2641            ENDI
0020126E                          2642s _00000006
0020126E                          2643m           PRINT_CRLF D3
0020126E                          2644mm     PRINT_CHAR #13,D3             ; CR
0020126E                          2645mm WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020126E                 TRUE     2646mm     IFEQ DEBUG
0020126E  1639 00D30003           2647mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201274  0803 0002               2648mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201278  67F4                    2649mm       BEQ WAIT_FOR_READY_184          ; NO SPACE, CHECK AGAIN
0020127A  13FC 000D 00D30007      2650mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00201282                          2651mm     ENDC
00201282                          2652mm     
00201282                 FALSE    2653mm     IFNE DEBUG
00201282                          2654mm     ENDC
00201282                          2655mm 
00201282                          2656mm     ENDM
00201282                          2657mm     PRINT_CHAR #10,D3             ; LF
00201282                          2658mm WAIT_FOR_READY_185                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201282                 TRUE     2659mm     IFEQ DEBUG
00201282  1639 00D30003           2660mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201288  0803 0002               2661mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020128C  67F4                    2662mm       BEQ WAIT_FOR_READY_185          ; NO SPACE, CHECK AGAIN
0020128E  13FC 000A 00D30007      2663mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201296                          2664mm     ENDC
00201296                          2665mm     
00201296                 FALSE    2666mm     IFNE DEBUG
00201296                          2667mm     ENDC
00201296                          2668mm 
00201296                          2669mm     ENDM
00201296                          2670m     ENDM
00201296  43F9 002004A8           2671            LEA WAIT_FOR_SRECORD,A1     ; next place to go
0020129C                          2672          ELSE
0020129C  6000 0252               2673s     BRA _00000007
002012A0                          2674s _00000005
002012A0                          2675            IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
002012A0  BE3C 0038               2676s     CMP.B   #'8',D7
002012A4  6600 01E4               2677s     BNE.L   _00000008
002012A8  7E00                    2678              MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002012AA                          2679m             DOWNLOAD D2,D3            ; top byte
002012AA                          2680m WAIT_FOR_READY_186                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012AA                          2681m 
002012AA  1639 00D30003           2682m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012B0  0803 0000               2683m     BTST #0,D3                    ; CHECK FOR CHARACTER
002012B4  6700 0010               2684m     BEQ CONTINUE_186                ; NOTHING, CONTINUE
002012B8                          2685m  
002012B8                          2686mm     READ_CHAR D2
002012B8                 TRUE     2687mm     IFEQ DEBUG
002012B8  1439 00D30007           2688mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002012BE                          2689mm     ENDC
002012BE                 FALSE    2690mm     IFNE DEBUG
002012BE                          2691mm     ENDC
002012BE                          2692mm      
002012BE  B43C 001B               2693mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002012C2  6700 ED44               2694mm     BEQ START
002012C6                          2695mm     ENDM
002012C6                          2696m CONTINUE_186
002012C6  1639 00D30013           2697m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002012CC  0803 0000               2698m     BTST #0,D3                  ; CHECK FOR CHARACTER
002012D0  67D8                    2699m     BEQ WAIT_FOR_READY_186        ; NOTHING, CHECK AGAIN
002012D2                          2700m     
002012D2  1439 00D30017           2701m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002012D8  13C2 00E00001           2702m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002012DE                          2703m     
002012DE                          2704m     ENDM
002012DE                          2705m             HEX2BIN D2,D2,A0
002012DE  41F9 00201B62           2706m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002012E4  0402 0030               2707m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012E8  C4BC 000000FF           2708m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002012EE  1430 2000               2709m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002012F2                          2710m   ENDM
002012F2  8E82                    2711              OR.L D2,D7
002012F4  E98F                    2712              LSL.L #4,D7
002012F6                          2713m             DOWNLOAD D2,D3         
002012F6                          2714m WAIT_FOR_READY_189                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012F6                          2715m 
002012F6  1639 00D30003           2716m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012FC  0803 0000               2717m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201300  6700 0010               2718m     BEQ CONTINUE_189                ; NOTHING, CONTINUE
00201304                          2719m  
00201304                          2720mm     READ_CHAR D2
00201304                 TRUE     2721mm     IFEQ DEBUG
00201304  1439 00D30007           2722mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020130A                          2723mm     ENDC
0020130A                 FALSE    2724mm     IFNE DEBUG
0020130A                          2725mm     ENDC
0020130A                          2726mm      
0020130A  B43C 001B               2727mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020130E  6700 ECF8               2728mm     BEQ START
00201312                          2729mm     ENDM
00201312                          2730m CONTINUE_189
00201312  1639 00D30013           2731m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201318  0803 0000               2732m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020131C  67D8                    2733m     BEQ WAIT_FOR_READY_189        ; NOTHING, CHECK AGAIN
0020131E                          2734m     
0020131E  1439 00D30017           2735m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201324  13C2 00E00001           2736m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020132A                          2737m     
0020132A                          2738m     ENDM
0020132A                          2739m             HEX2BIN D2,D2,A0
0020132A  41F9 00201B62           2740m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201330  0402 0030               2741m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201334  C4BC 000000FF           2742m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020133A  1430 2000               2743m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020133E                          2744m   ENDM
0020133E  8E82                    2745              OR.L D2,D7
00201340                          2746          
00201340  DC87                    2747              ADD.L D7,D6               ; add top byte of address into checksum
00201342                          2748  
00201342  E98F                    2749              LSL.L #4,D7               ; middle byte
00201344                          2750m             DOWNLOAD D2,D3
00201344                          2751m WAIT_FOR_READY_192                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201344                          2752m 
00201344  1639 00D30003           2753m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020134A  0803 0000               2754m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020134E  6700 0010               2755m     BEQ CONTINUE_192                ; NOTHING, CONTINUE
00201352                          2756m  
00201352                          2757mm     READ_CHAR D2
00201352                 TRUE     2758mm     IFEQ DEBUG
00201352  1439 00D30007           2759mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201358                          2760mm     ENDC
00201358                 FALSE    2761mm     IFNE DEBUG
00201358                          2762mm     ENDC
00201358                          2763mm      
00201358  B43C 001B               2764mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020135C  6700 ECAA               2765mm     BEQ START
00201360                          2766mm     ENDM
00201360                          2767m CONTINUE_192
00201360  1639 00D30013           2768m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201366  0803 0000               2769m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020136A  67D8                    2770m     BEQ WAIT_FOR_READY_192        ; NOTHING, CHECK AGAIN
0020136C                          2771m     
0020136C  1439 00D30017           2772m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201372  13C2 00E00001           2773m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201378                          2774m     
00201378                          2775m     ENDM
00201378                          2776m             HEX2BIN D2,D2,A0
00201378  41F9 00201B62           2777m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020137E  0402 0030               2778m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201382  C4BC 000000FF           2779m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201388  1430 2000               2780m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020138C                          2781m   ENDM
0020138C  8E82                    2782              OR.L D2,D7
0020138E  E98F                    2783              LSL.L #4,D7        
00201390                          2784m             DOWNLOAD D2,D3
00201390                          2785m WAIT_FOR_READY_195                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201390                          2786m 
00201390  1639 00D30003           2787m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201396  0803 0000               2788m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020139A  6700 0010               2789m     BEQ CONTINUE_195                ; NOTHING, CONTINUE
0020139E                          2790m  
0020139E                          2791mm     READ_CHAR D2
0020139E                 TRUE     2792mm     IFEQ DEBUG
0020139E  1439 00D30007           2793mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002013A4                          2794mm     ENDC
002013A4                 FALSE    2795mm     IFNE DEBUG
002013A4                          2796mm     ENDC
002013A4                          2797mm      
002013A4  B43C 001B               2798mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013A8  6700 EC5E               2799mm     BEQ START
002013AC                          2800mm     ENDM
002013AC                          2801m CONTINUE_195
002013AC  1639 00D30013           2802m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002013B2  0803 0000               2803m     BTST #0,D3                  ; CHECK FOR CHARACTER
002013B6  67D8                    2804m     BEQ WAIT_FOR_READY_195        ; NOTHING, CHECK AGAIN
002013B8                          2805m     
002013B8  1439 00D30017           2806m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002013BE  13C2 00E00001           2807m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002013C4                          2808m     
002013C4                          2809m     ENDM
002013C4                          2810m             HEX2BIN D2,D2,A0
002013C4  41F9 00201B62           2811m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002013CA  0402 0030               2812m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013CE  C4BC 000000FF           2813m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002013D4  1430 2000               2814m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002013D8                          2815m   ENDM
002013D8  8E82                    2816              OR.L D2,D7
002013DA                          2817          
002013DA  7400                    2818              MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
002013DC  1407                    2819              MOVE.B D7,D2
002013DE  DC82                    2820              ADD.L D2,D6
002013E0                          2821            
002013E0  E98F                    2822              LSL.L #4,D7               ; bottom byte
002013E2                          2823m             DOWNLOAD D2,D3
002013E2                          2824m WAIT_FOR_READY_198                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013E2                          2825m 
002013E2  1639 00D30003           2826m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002013E8  0803 0000               2827m     BTST #0,D3                    ; CHECK FOR CHARACTER
002013EC  6700 0010               2828m     BEQ CONTINUE_198                ; NOTHING, CONTINUE
002013F0                          2829m  
002013F0                          2830mm     READ_CHAR D2
002013F0                 TRUE     2831mm     IFEQ DEBUG
002013F0  1439 00D30007           2832mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002013F6                          2833mm     ENDC
002013F6                 FALSE    2834mm     IFNE DEBUG
002013F6                          2835mm     ENDC
002013F6                          2836mm      
002013F6  B43C 001B               2837mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013FA  6700 EC0C               2838mm     BEQ START
002013FE                          2839mm     ENDM
002013FE                          2840m CONTINUE_198
002013FE  1639 00D30013           2841m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201404  0803 0000               2842m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201408  67D8                    2843m     BEQ WAIT_FOR_READY_198        ; NOTHING, CHECK AGAIN
0020140A                          2844m     
0020140A  1439 00D30017           2845m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201410  13C2 00E00001           2846m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201416                          2847m     
00201416                          2848m     ENDM
00201416                          2849m             HEX2BIN D2,D2,A0
00201416  41F9 00201B62           2850m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020141C  0402 0030               2851m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201420  C4BC 000000FF           2852m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201426  1430 2000               2853m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020142A                          2854m   ENDM
0020142A  8E82                    2855              OR.L D2,D7
0020142C  E98F                    2856              LSL.L #4,D7        
0020142E                          2857m             DOWNLOAD D2,D3
0020142E                          2858m WAIT_FOR_READY_201                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020142E                          2859m 
0020142E  1639 00D30003           2860m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201434  0803 0000               2861m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201438  6700 0010               2862m     BEQ CONTINUE_201                ; NOTHING, CONTINUE
0020143C                          2863m  
0020143C                          2864mm     READ_CHAR D2
0020143C                 TRUE     2865mm     IFEQ DEBUG
0020143C  1439 00D30007           2866mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201442                          2867mm     ENDC
00201442                 FALSE    2868mm     IFNE DEBUG
00201442                          2869mm     ENDC
00201442                          2870mm      
00201442  B43C 001B               2871mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201446  6700 EBC0               2872mm     BEQ START
0020144A                          2873mm     ENDM
0020144A                          2874m CONTINUE_201
0020144A  1639 00D30013           2875m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201450  0803 0000               2876m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201454  67D8                    2877m     BEQ WAIT_FOR_READY_201        ; NOTHING, CHECK AGAIN
00201456                          2878m     
00201456  1439 00D30017           2879m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020145C  13C2 00E00001           2880m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201462                          2881m     
00201462                          2882m     ENDM
00201462                          2883m             HEX2BIN D2,D2,A0
00201462  41F9 00201B62           2884m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201468  0402 0030               2885m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020146C  C4BC 000000FF           2886m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201472  1430 2000               2887m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201476                          2888m   ENDM
00201476  8E82                    2889              OR.L D2,D7
00201478                          2890          
00201478  7400                    2891              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
0020147A  1407                    2892              MOVE.B D7,D2
0020147C  DC82                    2893              ADD.L D2,D6
0020147E                          2894            
0020147E  2447                    2895              MOVE.L D7,A2              ; start address -> A2
00201480                          2896          
00201480  43F9 00201640           2897              LEA DOWNLOAD_DONE,A1      ; next place to go
00201486                          2898            ELSE
00201486  6000 0068               2899s     BRA _00000009
0020148A                          2900s _00000008
0020148A  41F9 00201AEE           2901              LEA UNREC,A0              ; warn for unrecognised type
00201490                          2902m             PRINT_STR A0,D3
00201490                          2903m LOOP_204
00201490  0C10 0000               2904m     CMP.B #0,(A0)                 ; 0 -> DONE
00201494  6700 001A               2905m     BEQ EXIT_204
00201498                          2906mm     PRINT_CHAR (A0)+,D3
00201498                          2907mm WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201498                 TRUE     2908mm     IFEQ DEBUG
00201498  1639 00D30003           2909mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020149E  0803 0002               2910mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014A2  67F4                    2911mm       BEQ WAIT_FOR_READY_205          ; NO SPACE, CHECK AGAIN
002014A4  13D8 00D30007           2912mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002014AA                          2913mm     ENDC
002014AA                          2914mm     
002014AA                 FALSE    2915mm     IFNE DEBUG
002014AA                          2916mm     ENDC
002014AA                          2917mm 
002014AA                          2918mm     ENDM
002014AA  4EF9 00201490           2919m     JMP LOOP_204
002014B0                          2920m EXIT_204
002014B0                          2921m     ENDM
002014B0                          2922m             PRINT_CHAR D7,D3
002014B0                          2923m WAIT_FOR_READY_206                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014B0                 TRUE     2924m     IFEQ DEBUG
002014B0  1639 00D30003           2925m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014B6  0803 0002               2926m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014BA  67F4                    2927m       BEQ WAIT_FOR_READY_206          ; NO SPACE, CHECK AGAIN
002014BC  13C7 00D30007           2928m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002014C2                          2929m     ENDC
002014C2                          2930m     
002014C2                 FALSE    2931m     IFNE DEBUG
002014C2                          2932m     ENDC
002014C2                          2933m 
002014C2                          2934m     ENDM
002014C2                          2935m             PRINT_CRLF D3
002014C2                          2936mm     PRINT_CHAR #13,D3             ; CR
002014C2                          2937mm WAIT_FOR_READY_208                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014C2                 TRUE     2938mm     IFEQ DEBUG
002014C2  1639 00D30003           2939mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014C8  0803 0002               2940mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014CC  67F4                    2941mm       BEQ WAIT_FOR_READY_208          ; NO SPACE, CHECK AGAIN
002014CE  13FC 000D 00D30007      2942mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002014D6                          2943mm     ENDC
002014D6                          2944mm     
002014D6                 FALSE    2945mm     IFNE DEBUG
002014D6                          2946mm     ENDC
002014D6                          2947mm 
002014D6                          2948mm     ENDM
002014D6                          2949mm     PRINT_CHAR #10,D3             ; LF
002014D6                          2950mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014D6                 TRUE     2951mm     IFEQ DEBUG
002014D6  1639 00D30003           2952mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014DC  0803 0002               2953mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014E0  67F4                    2954mm       BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
002014E2  13FC 000A 00D30007      2955mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002014EA                          2956mm     ENDC
002014EA                          2957mm     
002014EA                 FALSE    2958mm     IFNE DEBUG
002014EA                          2959mm     ENDC
002014EA                          2960mm 
002014EA                          2961mm     ENDM
002014EA                          2962m     ENDM
002014EA                          2963      
002014EA  4EF9 002004A8           2964              JMP WAIT_FOR_SRECORD      ; ignore any other type    
002014F0                          2965            ENDI
002014F0                          2966s _00000009
002014F0                          2967          ENDI
002014F0                          2968s _00000007
002014F0                          2969        ENDI
002014F0                          2970s _00000004
002014F0                          2971      ENDI
002014F0                          2972s _00000001
002014F0                          2973      
002014F0  4686                    2974      NOT.L D6                        ; ones complement the checksum
002014F2  0286 000000FF           2975      ANDI.L #$FF,D6                  ; and take the LSByte
002014F8                          2976          
002014F8  7E00                    2977      MOVE.L #0,D7                    ; read the checksum from the data stream
002014FA                          2978m     DOWNLOAD D2,D3                  ; top byte
002014FA                          2979m WAIT_FOR_READY_210                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014FA                          2980m 
002014FA  1639 00D30003           2981m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201500  0803 0000               2982m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201504  6700 0010               2983m     BEQ CONTINUE_210                ; NOTHING, CONTINUE
00201508                          2984m  
00201508                          2985mm     READ_CHAR D2
00201508                 TRUE     2986mm     IFEQ DEBUG
00201508  1439 00D30007           2987mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020150E                          2988mm     ENDC
0020150E                 FALSE    2989mm     IFNE DEBUG
0020150E                          2990mm     ENDC
0020150E                          2991mm      
0020150E  B43C 001B               2992mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201512  6700 EAF4               2993mm     BEQ START
00201516                          2994mm     ENDM
00201516                          2995m CONTINUE_210
00201516  1639 00D30013           2996m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020151C  0803 0000               2997m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201520  67D8                    2998m     BEQ WAIT_FOR_READY_210        ; NOTHING, CHECK AGAIN
00201522                          2999m     
00201522  1439 00D30017           3000m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201528  13C2 00E00001           3001m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020152E                          3002m     
0020152E                          3003m     ENDM
0020152E                          3004m     HEX2BIN D2,D2,A0
0020152E  41F9 00201B62           3005m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201534  0402 0030               3006m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201538  C4BC 000000FF           3007m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020153E  1430 2000               3008m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201542                          3009m   ENDM
00201542  8E82                    3010      OR.L D2,D7
00201544  E98F                    3011      LSL.L #4,D7
00201546                          3012m     DOWNLOAD D2,D3                  ; bottom byte
00201546                          3013m WAIT_FOR_READY_213                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201546                          3014m 
00201546  1639 00D30003           3015m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020154C  0803 0000               3016m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201550  6700 0010               3017m     BEQ CONTINUE_213                ; NOTHING, CONTINUE
00201554                          3018m  
00201554                          3019mm     READ_CHAR D2
00201554                 TRUE     3020mm     IFEQ DEBUG
00201554  1439 00D30007           3021mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020155A                          3022mm     ENDC
0020155A                 FALSE    3023mm     IFNE DEBUG
0020155A                          3024mm     ENDC
0020155A                          3025mm      
0020155A  B43C 001B               3026mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020155E  6700 EAA8               3027mm     BEQ START
00201562                          3028mm     ENDM
00201562                          3029m CONTINUE_213
00201562  1639 00D30013           3030m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201568  0803 0000               3031m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020156C  67D8                    3032m     BEQ WAIT_FOR_READY_213        ; NOTHING, CHECK AGAIN
0020156E                          3033m     
0020156E  1439 00D30017           3034m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201574  13C2 00E00001           3035m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020157A                          3036m     
0020157A                          3037m     ENDM
0020157A                          3038m     HEX2BIN D2,D2,A0
0020157A  41F9 00201B62           3039m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201580  0402 0030               3040m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201584  C4BC 000000FF           3041m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020158A  1430 2000               3042m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020158E                          3043m   ENDM
0020158E  8E82                    3044      OR.L D2,D7
00201590                          3045                  
00201590                          3046      IF.B D7 <NE> D6 THEN.L
00201590  BE06                    3047s     CMP.B   D6,D7
00201592  6700 00AA               3048s     BEQ.L   _0000000A
00201596  41F9 00201B14           3049        LEA CS_FAILURE,A0             ; warn for mismatched checksum
0020159C                          3050m       PRINT_STR A0,D3
0020159C                          3051m LOOP_216
0020159C  0C10 0000               3052m     CMP.B #0,(A0)                 ; 0 -> DONE
002015A0  6700 001A               3053m     BEQ EXIT_216
002015A4                          3054mm     PRINT_CHAR (A0)+,D3
002015A4                          3055mm WAIT_FOR_READY_217                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015A4                 TRUE     3056mm     IFEQ DEBUG
002015A4  1639 00D30003           3057mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015AA  0803 0002               3058mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015AE  67F4                    3059mm       BEQ WAIT_FOR_READY_217          ; NO SPACE, CHECK AGAIN
002015B0  13D8 00D30007           3060mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002015B6                          3061mm     ENDC
002015B6                          3062mm     
002015B6                 FALSE    3063mm     IFNE DEBUG
002015B6                          3064mm     ENDC
002015B6                          3065mm 
002015B6                          3066mm     ENDM
002015B6  4EF9 0020159C           3067m     JMP LOOP_216
002015BC                          3068m EXIT_216
002015BC                          3069m     ENDM
002015BC                          3070m       PRINT_REG D4,D3,D6,D7,A0
002015BC                          3071mm     PRINT_CHAR #'0',D3          ;0X HEADER
002015BC                          3072mm WAIT_FOR_READY_219                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015BC                 TRUE     3073mm     IFEQ DEBUG
002015BC  1639 00D30003           3074mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015C2  0803 0002               3075mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015C6  67F4                    3076mm       BEQ WAIT_FOR_READY_219          ; NO SPACE, CHECK AGAIN
002015C8  13FC 0030 00D30007      3077mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002015D0                          3078mm     ENDC
002015D0                          3079mm     
002015D0                 FALSE    3080mm     IFNE DEBUG
002015D0                          3081mm     ENDC
002015D0                          3082mm 
002015D0                          3083mm     ENDM
002015D0                          3084mm     PRINT_CHAR #'x',D3
002015D0                          3085mm WAIT_FOR_READY_220                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015D0                 TRUE     3086mm     IFEQ DEBUG
002015D0  1639 00D30003           3087mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015D6  0803 0002               3088mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015DA  67F4                    3089mm       BEQ WAIT_FOR_READY_220          ; NO SPACE, CHECK AGAIN
002015DC  13FC 0078 00D30007      3090mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002015E4                          3091mm     ENDC
002015E4                          3092mm     
002015E4                 FALSE    3093mm     IFNE DEBUG
002015E4                          3094mm     ENDC
002015E4                          3095mm 
002015E4                          3096mm     ENDM
002015E4  7E07                    3097m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002015E6                          3098m LOOP_218
002015E6                          3099mm     BIN2HEX D4,D6,A0
002015E6  41F9 00201B52           3100mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002015EC  E99C                    3101mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002015EE  1C04                    3102mm   MOVE.B D4,D6
002015F0  0286 0000000F           3103mm   ANDI.L #$F,D6
002015F6  1C30 6000               3104mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
002015FA                          3105mm   ENDM
002015FA                          3106mm     PRINT_CHAR D6,D3
002015FA                          3107mm WAIT_FOR_READY_222                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015FA                 TRUE     3108mm     IFEQ DEBUG
002015FA  1639 00D30003           3109mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201600  0803 0002               3110mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201604  67F4                    3111mm       BEQ WAIT_FOR_READY_222          ; NO SPACE, CHECK AGAIN
00201606  13C6 00D30007           3112mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
0020160C                          3113mm     ENDC
0020160C                          3114mm     
0020160C                 FALSE    3115mm     IFNE DEBUG
0020160C                          3116mm     ENDC
0020160C                          3117mm 
0020160C                          3118mm     ENDM
0020160C  57CF FFD8               3119m     DBEQ D7,LOOP_218
00201610                          3120m     ENDM
00201610                          3121m       PRINT_CRLF D3
00201610                          3122mm     PRINT_CHAR #13,D3             ; CR
00201610                          3123mm WAIT_FOR_READY_224                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201610                 TRUE     3124mm     IFEQ DEBUG
00201610  1639 00D30003           3125mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201616  0803 0002               3126mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020161A  67F4                    3127mm       BEQ WAIT_FOR_READY_224          ; NO SPACE, CHECK AGAIN
0020161C  13FC 000D 00D30007      3128mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00201624                          3129mm     ENDC
00201624                          3130mm     
00201624                 FALSE    3131mm     IFNE DEBUG
00201624                          3132mm     ENDC
00201624                          3133mm 
00201624                          3134mm     ENDM
00201624                          3135mm     PRINT_CHAR #10,D3             ; LF
00201624                          3136mm WAIT_FOR_READY_225                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201624                 TRUE     3137mm     IFEQ DEBUG
00201624  1639 00D30003           3138mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020162A  0803 0002               3139mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020162E  67F4                    3140mm       BEQ WAIT_FOR_READY_225          ; NO SPACE, CHECK AGAIN
00201630  13FC 000A 00D30007      3141mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201638                          3142mm     ENDC
00201638                          3143mm     
00201638                 FALSE    3144mm     IFNE DEBUG
00201638                          3145mm     ENDC
00201638                          3146mm 
00201638                          3147mm     ENDM
00201638                          3148m     ENDM
00201638  4EF9 00200188           3149        JMP MAIN_LOOP
0020163E                          3150      ENDI
0020163E                          3151s _0000000A
0020163E                          3152      
0020163E  4ED1                    3153      JMP (A1)
00201640                          3154  DOWNLOAD_DONE
00201640                          3155m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00201640                          3156mm     PRINT_CHAR #'0',D3          ;0X HEADER
00201640                          3157mm WAIT_FOR_READY_227                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201640                 TRUE     3158mm     IFEQ DEBUG
00201640  1639 00D30003           3159mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201646  0803 0002               3160mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020164A  67F4                    3161mm       BEQ WAIT_FOR_READY_227          ; NO SPACE, CHECK AGAIN
0020164C  13FC 0030 00D30007      3162mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00201654                          3163mm     ENDC
00201654                          3164mm     
00201654                 FALSE    3165mm     IFNE DEBUG
00201654                          3166mm     ENDC
00201654                          3167mm 
00201654                          3168mm     ENDM
00201654                          3169mm     PRINT_CHAR #'x',D3
00201654                          3170mm WAIT_FOR_READY_228                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201654                 TRUE     3171mm     IFEQ DEBUG
00201654  1639 00D30003           3172mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020165A  0803 0002               3173mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020165E  67F4                    3174mm       BEQ WAIT_FOR_READY_228          ; NO SPACE, CHECK AGAIN
00201660  13FC 0078 00D30007      3175mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00201668                          3176mm     ENDC
00201668                          3177mm     
00201668                 FALSE    3178mm     IFNE DEBUG
00201668                          3179mm     ENDC
00201668                          3180mm 
00201668                          3181mm     ENDM
00201668  7C07                    3182m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0020166A                          3183m LOOP_226
0020166A                          3184mm     BIN2HEX D4,D7,A0
0020166A  41F9 00201B52           3185mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00201670  E99C                    3186mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00201672  1E04                    3187mm   MOVE.B D4,D7
00201674  0287 0000000F           3188mm   ANDI.L #$F,D7
0020167A  1E30 7000               3189mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0020167E                          3190mm   ENDM
0020167E                          3191mm     PRINT_CHAR D7,D3
0020167E                          3192mm WAIT_FOR_READY_230                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020167E                 TRUE     3193mm     IFEQ DEBUG
0020167E  1639 00D30003           3194mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201684  0803 0002               3195mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201688  67F4                    3196mm       BEQ WAIT_FOR_READY_230          ; NO SPACE, CHECK AGAIN
0020168A  13C7 00D30007           3197mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00201690                          3198mm     ENDC
00201690                          3199mm     
00201690                 FALSE    3200mm     IFNE DEBUG
00201690                          3201mm     ENDC
00201690                          3202mm 
00201690                          3203mm     ENDM
00201690  57CE FFD8               3204m     DBEQ D6,LOOP_226
00201694                          3205m     ENDM
00201694  41F9 00201ACC           3206      LEA READ,A0
0020169A                          3207m     PRINT_STR A0,D3
0020169A                          3208m LOOP_231
0020169A  0C10 0000               3209m     CMP.B #0,(A0)                 ; 0 -> DONE
0020169E  6700 001A               3210m     BEQ EXIT_231
002016A2                          3211mm     PRINT_CHAR (A0)+,D3
002016A2                          3212mm WAIT_FOR_READY_232                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016A2                 TRUE     3213mm     IFEQ DEBUG
002016A2  1639 00D30003           3214mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016A8  0803 0002               3215mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016AC  67F4                    3216mm       BEQ WAIT_FOR_READY_232          ; NO SPACE, CHECK AGAIN
002016AE  13D8 00D30007           3217mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002016B4                          3218mm     ENDC
002016B4                          3219mm     
002016B4                 FALSE    3220mm     IFNE DEBUG
002016B4                          3221mm     ENDC
002016B4                          3222mm 
002016B4                          3223mm     ENDM
002016B4  4EF9 0020169A           3224m     JMP LOOP_231
002016BA                          3225m EXIT_231
002016BA                          3226m     ENDM
002016BA  2E0A                    3227      MOVE.L A2,D7                    ; set address accumulator to start address
002016BC                          3228m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
002016BC                          3229mm     PRINT_CHAR #'0',D3          ;0X HEADER
002016BC                          3230mm WAIT_FOR_READY_234                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016BC                 TRUE     3231mm     IFEQ DEBUG
002016BC  1639 00D30003           3232mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016C2  0803 0002               3233mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016C6  67F4                    3234mm       BEQ WAIT_FOR_READY_234          ; NO SPACE, CHECK AGAIN
002016C8  13FC 0030 00D30007      3235mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002016D0                          3236mm     ENDC
002016D0                          3237mm     
002016D0                 FALSE    3238mm     IFNE DEBUG
002016D0                          3239mm     ENDC
002016D0                          3240mm 
002016D0                          3241mm     ENDM
002016D0                          3242mm     PRINT_CHAR #'x',D3
002016D0                          3243mm WAIT_FOR_READY_235                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016D0                 TRUE     3244mm     IFEQ DEBUG
002016D0  1639 00D30003           3245mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016D6  0803 0002               3246mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016DA  67F4                    3247mm       BEQ WAIT_FOR_READY_235          ; NO SPACE, CHECK AGAIN
002016DC  13FC 0078 00D30007      3248mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002016E4                          3249mm     ENDC
002016E4                          3250mm     
002016E4                 FALSE    3251mm     IFNE DEBUG
002016E4                          3252mm     ENDC
002016E4                          3253mm 
002016E4                          3254mm     ENDM
002016E4  7C07                    3255m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002016E6                          3256m LOOP_233
002016E6                          3257mm     BIN2HEX D7,D2,A0
002016E6  41F9 00201B52           3258mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002016EC  E99F                    3259mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002016EE  1407                    3260mm   MOVE.B D7,D2
002016F0  0282 0000000F           3261mm   ANDI.L #$F,D2
002016F6  1430 2000               3262mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
002016FA                          3263mm   ENDM
002016FA                          3264mm     PRINT_CHAR D2,D3
002016FA                          3265mm WAIT_FOR_READY_237                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016FA                 TRUE     3266mm     IFEQ DEBUG
002016FA  1639 00D30003           3267mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201700  0803 0002               3268mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201704  67F4                    3269mm       BEQ WAIT_FOR_READY_237          ; NO SPACE, CHECK AGAIN
00201706  13C2 00D30007           3270mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020170C                          3271mm     ENDC
0020170C                          3272mm     
0020170C                 FALSE    3273mm     IFNE DEBUG
0020170C                          3274mm     ENDC
0020170C                          3275mm 
0020170C                          3276mm     ENDM
0020170C  57CE FFD8               3277m     DBEQ D6,LOOP_233
00201710                          3278m     ENDM
00201710                          3279m     PRINT_CRLF D3     
00201710                          3280mm     PRINT_CHAR #13,D3             ; CR
00201710                          3281mm WAIT_FOR_READY_239                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201710                 TRUE     3282mm     IFEQ DEBUG
00201710  1639 00D30003           3283mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201716  0803 0002               3284mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020171A  67F4                    3285mm       BEQ WAIT_FOR_READY_239          ; NO SPACE, CHECK AGAIN
0020171C  13FC 000D 00D30007      3286mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00201724                          3287mm     ENDC
00201724                          3288mm     
00201724                 FALSE    3289mm     IFNE DEBUG
00201724                          3290mm     ENDC
00201724                          3291mm 
00201724                          3292mm     ENDM
00201724                          3293mm     PRINT_CHAR #10,D3             ; LF
00201724                          3294mm WAIT_FOR_READY_240                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201724                 TRUE     3295mm     IFEQ DEBUG
00201724  1639 00D30003           3296mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020172A  0803 0002               3297mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020172E  67F4                    3298mm       BEQ WAIT_FOR_READY_240          ; NO SPACE, CHECK AGAIN
00201730  13FC 000A 00D30007      3299mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201738                          3300mm     ENDC
00201738                          3301mm     
00201738                 FALSE    3302mm     IFNE DEBUG
00201738                          3303mm     ENDC
00201738                          3304mm 
00201738                          3305mm     ENDM
00201738                          3306m     ENDM
00201738                          3307          
00201738  4EF9 00200188           3308      JMP MAIN_LOOP
0020173E                          3309      
0020173E  2047                    3310  G   MOVE.L D7,A0                    ; address accumulator -> address register
00201740  3E3C 0000               3311      MOVE #0,D7                      ; clear the now used address accumulator
00201744  4ED0                    3312      JMP (A0)                        ; jump to it!
00201746                          3313      
00201746  207C 00200000           3314  Z   MOVE.L #RAM,A0                  ; address of RAM
0020174C  7000                    3315      MOVE.L #0,D0                    ; number of bytes
0020174E                          3316     
0020174E                          3317      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
0020174E                          3318s _10000006
0020174E  B0BC 00040000           3319s     CMP.L   #$40000,D0
00201754  6E00 001A               3320s     BGT _10000007
00201758                          3321         
00201758  2200                    3322        MOVE.L D0,D1                  ; progress update
0020175A  E089                    3323        LSR.L #8,D1 
0020175C  E089                    3324        LSR.L #8,D1
0020175E  0281 0000000F           3325        ANDI.L #$F,D1
00201764  13C1 00E00001           3326        MOVE.B D1,DISPLAY
0020176A                          3327  
0020176A  20C0                    3328        MOVE.L D0,(A0)+ 
0020176C  5880                    3329        ADD.L #4,D0
0020176E                          3330      ENDW
0020176E  60DE                    3331s     BRA _10000006
00201770                          3332s _10000007
00201770                          3333   
00201770  207C 00200000           3334      MOVE.L #RAM,A0              ; address of RAM
00201776  7000                    3335      MOVE.L #0,D0                ; number of bytes
00201778                          3336     
00201778                          3337      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00201778                          3338s _10000008
00201778  B0BC 00040000           3339s     CMP.L   #$40000,D0
0020177E  6E00 00CC               3340s     BGT _10000009
00201782                          3341  
00201782  2200                    3342        MOVE.L D0,D1              ; progress update
00201784  E089                    3343        LSR.L #8,D1
00201786  E089                    3344        LSR.L #8,D1
00201788  0281 0000000F           3345        ANDI.L #$F,D1
0020178E  13C1 00E00001           3346        MOVE.B D1,DISPLAY
00201794                          3347  
00201794  2218                    3348        MOVE.L (A0)+,D1
00201796                          3349        
00201796                          3350        IF.L D0 <EQ> D1 THEN
00201796  B081                    3351s     CMP.L   D1,D0
00201798  6600 0006               3352s     BNE _0000000B
0020179C  6000 00A8               3353          BRA OK
002017A0                          3354        ENDI 
002017A0                          3355s _0000000B
002017A0                          3356        
002017A0  43F9 00201B3A           3357        LEA RAM_ERROR,A1
002017A6                          3358m       PRINT_STR A1,D1
002017A6                          3359m LOOP_241
002017A6  0C11 0000               3360m     CMP.B #0,(A1)                 ; 0 -> DONE
002017AA  6700 001A               3361m     BEQ EXIT_241
002017AE                          3362mm     PRINT_CHAR (A1)+,D1
002017AE                          3363mm WAIT_FOR_READY_242                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017AE                 TRUE     3364mm     IFEQ DEBUG
002017AE  1239 00D30003           3365mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
002017B4  0801 0002               3366mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
002017B8  67F4                    3367mm       BEQ WAIT_FOR_READY_242          ; NO SPACE, CHECK AGAIN
002017BA  13D9 00D30007           3368mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002017C0                          3369mm     ENDC
002017C0                          3370mm     
002017C0                 FALSE    3371mm     IFNE DEBUG
002017C0                          3372mm     ENDC
002017C0                          3373mm 
002017C0                          3374mm     ENDM
002017C0  4EF9 002017A6           3375m     JMP LOOP_241
002017C6                          3376m EXIT_241
002017C6                          3377m     ENDM
002017C6  2208                    3378        MOVE.L A0,D1
002017C8  5981                    3379        SUB.L #4,D1
002017CA                          3380m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
002017CA                          3381mm     PRINT_CHAR #'0',D3          ;0X HEADER
002017CA                          3382mm WAIT_FOR_READY_244                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017CA                 TRUE     3383mm     IFEQ DEBUG
002017CA  1639 00D30003           3384mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017D0  0803 0002               3385mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017D4  67F4                    3386mm       BEQ WAIT_FOR_READY_244          ; NO SPACE, CHECK AGAIN
002017D6  13FC 0030 00D30007      3387mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002017DE                          3388mm     ENDC
002017DE                          3389mm     
002017DE                 FALSE    3390mm     IFNE DEBUG
002017DE                          3391mm     ENDC
002017DE                          3392mm 
002017DE                          3393mm     ENDM
002017DE                          3394mm     PRINT_CHAR #'x',D3
002017DE                          3395mm WAIT_FOR_READY_245                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017DE                 TRUE     3396mm     IFEQ DEBUG
002017DE  1639 00D30003           3397mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017E4  0803 0002               3398mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017E8  67F4                    3399mm       BEQ WAIT_FOR_READY_245          ; NO SPACE, CHECK AGAIN
002017EA  13FC 0078 00D30007      3400mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002017F2                          3401mm     ENDC
002017F2                          3402mm     
002017F2                 FALSE    3403mm     IFNE DEBUG
002017F2                          3404mm     ENDC
002017F2                          3405mm 
002017F2                          3406mm     ENDM
002017F2  7C07                    3407m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002017F4                          3408m LOOP_243
002017F4                          3409mm     BIN2HEX D1,D2,A1
002017F4  43F9 00201B52           3410mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
002017FA  E999                    3411mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002017FC  1401                    3412mm   MOVE.B D1,D2
002017FE  0282 0000000F           3413mm   ANDI.L #$F,D2
00201804  1431 2000               3414mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00201808                          3415mm   ENDM
00201808                          3416mm     PRINT_CHAR D2,D3
00201808                          3417mm WAIT_FOR_READY_247                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201808                 TRUE     3418mm     IFEQ DEBUG
00201808  1639 00D30003           3419mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020180E  0803 0002               3420mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201812  67F4                    3421mm       BEQ WAIT_FOR_READY_247          ; NO SPACE, CHECK AGAIN
00201814  13C2 00D30007           3422mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020181A                          3423mm     ENDC
0020181A                          3424mm     
0020181A                 FALSE    3425mm     IFNE DEBUG
0020181A                          3426mm     ENDC
0020181A                          3427mm 
0020181A                          3428mm     ENDM
0020181A  57CE FFD8               3429m     DBEQ D6,LOOP_243
0020181E                          3430m     ENDM
0020181E                          3431m       PRINT_CRLF D3
0020181E                          3432mm     PRINT_CHAR #13,D3             ; CR
0020181E                          3433mm WAIT_FOR_READY_249                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020181E                 TRUE     3434mm     IFEQ DEBUG
0020181E  1639 00D30003           3435mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201824  0803 0002               3436mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201828  67F4                    3437mm       BEQ WAIT_FOR_READY_249          ; NO SPACE, CHECK AGAIN
0020182A  13FC 000D 00D30007      3438mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00201832                          3439mm     ENDC
00201832                          3440mm     
00201832                 FALSE    3441mm     IFNE DEBUG
00201832                          3442mm     ENDC
00201832                          3443mm 
00201832                          3444mm     ENDM
00201832                          3445mm     PRINT_CHAR #10,D3             ; LF
00201832                          3446mm WAIT_FOR_READY_250                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201832                 TRUE     3447mm     IFEQ DEBUG
00201832  1639 00D30003           3448mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201838  0803 0002               3449mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020183C  67F4                    3450mm       BEQ WAIT_FOR_READY_250          ; NO SPACE, CHECK AGAIN
0020183E  13FC 000A 00D30007      3451mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201846                          3452mm     ENDC
00201846                          3453mm     
00201846                 FALSE    3454mm     IFNE DEBUG
00201846                          3455mm     ENDC
00201846                          3456mm 
00201846                          3457mm     ENDM
00201846                          3458m     ENDM
00201846                          3459  OK    
00201846  5880                    3460        ADD.L #4,D0
00201848                          3461      ENDW
00201848  6000 FF2E               3462s     BRA _10000008
0020184C                          3463s _10000009
0020184C                          3464      
0020184C  4EF9 00200188           3465      JMP MAIN_LOOP
00201852                          3466    
00201852  7A00                    3467  L   MOVE.L #0,D5                    ; D5 will be the length  to write            
00201854                          3468  
00201854                          3469m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
00201854                          3470m WAIT_FOR_READY_251                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201854                          3471m 
00201854                 TRUE     3472m     IFEQ DEBUG
00201854  1639 00D30003           3473m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
0020185A  0803 0000               3474m       BTST #0,D3                    ; CHECK FOR CHARACTER
0020185E  67F4                    3475m       BEQ WAIT_FOR_READY_251          ; NOTHING, CHECK AGAIN
00201860                          3476m     ENDC
00201860                          3477m     
00201860                          3478mm     READ_CHAR D2
00201860                 TRUE     3479mm     IFEQ DEBUG
00201860  1439 00D30007           3480mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201866                          3481mm     ENDC
00201866                 FALSE    3482mm     IFNE DEBUG
00201866                          3483mm     ENDC
00201866                          3484mm      
00201866  B43C 001B               3485mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020186A  6700 E79C               3486mm     BEQ START
0020186E                          3487mm     ENDM
0020186E                          3488m 
0020186E                 TRUE     3489m     IFEQ DEBUG
0020186E                          3490mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0020186E                          3491mm WAIT_FOR_READY_253                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020186E                 TRUE     3492mm     IFEQ DEBUG
0020186E  1639 00D30003           3493mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201874  0803 0002               3494mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201878  67F4                    3495mm       BEQ WAIT_FOR_READY_253          ; NO SPACE, CHECK AGAIN
0020187A  13C2 00D30007           3496mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201880                          3497mm     ENDC
00201880                          3498mm     
00201880                 FALSE    3499mm     IFNE DEBUG
00201880                          3500mm     ENDC
00201880                          3501mm 
00201880                          3502mm     ENDM
00201880                          3503m     ENDC
00201880                          3504m     ENDM
00201880                          3505m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00201880  41F9 00201B62           3506m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201886  0402 0030               3507m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020188A  C4BC 000000FF           3508m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201890  1430 2000               3509m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201894                          3510m   ENDM
00201894  1A02                    3511      MOVE.B D2,D5                    ; put at bottom of D5
00201896                          3512  
00201896  3C3C 0002               3513      MOVE #2,D6                      ; 3 bytes left to read
0020189A                          3514      
0020189A                          3515  READ_LENGTH
0020189A  E98D                    3516      LSL.L #4,D5                     ; make what we have so far more significant
0020189C                          3517m     WAIT_CHAR D2,D3                 ; next character -> D2
0020189C                          3518m WAIT_FOR_READY_255                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020189C                          3519m 
0020189C                 TRUE     3520m     IFEQ DEBUG
0020189C  1639 00D30003           3521m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002018A2  0803 0000               3522m       BTST #0,D3                    ; CHECK FOR CHARACTER
002018A6  67F4                    3523m       BEQ WAIT_FOR_READY_255          ; NOTHING, CHECK AGAIN
002018A8                          3524m     ENDC
002018A8                          3525m     
002018A8                          3526mm     READ_CHAR D2
002018A8                 TRUE     3527mm     IFEQ DEBUG
002018A8  1439 00D30007           3528mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002018AE                          3529mm     ENDC
002018AE                 FALSE    3530mm     IFNE DEBUG
002018AE                          3531mm     ENDC
002018AE                          3532mm      
002018AE  B43C 001B               3533mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002018B2  6700 E754               3534mm     BEQ START
002018B6                          3535mm     ENDM
002018B6                          3536m 
002018B6                 TRUE     3537m     IFEQ DEBUG
002018B6                          3538mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002018B6                          3539mm WAIT_FOR_READY_257                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018B6                 TRUE     3540mm     IFEQ DEBUG
002018B6  1639 00D30003           3541mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018BC  0803 0002               3542mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018C0  67F4                    3543mm       BEQ WAIT_FOR_READY_257          ; NO SPACE, CHECK AGAIN
002018C2  13C2 00D30007           3544mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002018C8                          3545mm     ENDC
002018C8                          3546mm     
002018C8                 FALSE    3547mm     IFNE DEBUG
002018C8                          3548mm     ENDC
002018C8                          3549mm 
002018C8                          3550mm     ENDM
002018C8                          3551m     ENDC
002018C8                          3552m     ENDM
002018C8                          3553m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002018C8  41F9 00201B62           3554m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002018CE  0402 0030               3555m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002018D2  C4BC 000000FF           3556m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002018D8  1430 2000               3557m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002018DC                          3558m   ENDM
002018DC  8A02                    3559      OR.B D2,D5
002018DE  023C 00FB               3560      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
002018E2  57CE FFB6               3561      DBEQ D6,READ_LENGTH
002018E6                          3562          
002018E6                          3563m     PRINT_CRLF D3
002018E6                          3564mm     PRINT_CHAR #13,D3             ; CR
002018E6                          3565mm WAIT_FOR_READY_260                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018E6                 TRUE     3566mm     IFEQ DEBUG
002018E6  1639 00D30003           3567mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018EC  0803 0002               3568mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018F0  67F4                    3569mm       BEQ WAIT_FOR_READY_260          ; NO SPACE, CHECK AGAIN
002018F2  13FC 000D 00D30007      3570mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002018FA                          3571mm     ENDC
002018FA                          3572mm     
002018FA                 FALSE    3573mm     IFNE DEBUG
002018FA                          3574mm     ENDC
002018FA                          3575mm 
002018FA                          3576mm     ENDM
002018FA                          3577mm     PRINT_CHAR #10,D3             ; LF
002018FA                          3578mm WAIT_FOR_READY_261                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018FA                 TRUE     3579mm     IFEQ DEBUG
002018FA  1639 00D30003           3580mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201900  0803 0002               3581mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201904  67F4                    3582mm       BEQ WAIT_FOR_READY_261          ; NO SPACE, CHECK AGAIN
00201906  13FC 000A 00D30007      3583mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020190E                          3584mm     ENDC
0020190E                          3585mm     
0020190E                 FALSE    3586mm     IFNE DEBUG
0020190E                          3587mm     ENDC
0020190E                          3588mm 
0020190E                          3589mm     ENDM
0020190E                          3590m     ENDM
0020190E                          3591  
0020190E  207C 00000000           3592      MOVE.L #ROM,A0                  ; start of ROM
00201914                          3593      
00201914  2247                    3594      MOVE.L D7,A1                    ; address accumulator -> address register
00201916  7E00                    3595      MOVE.L #0,D7                    ; clear the now used address accumulator
00201918                          3596      
00201918  267C 00002AAA           3597      MOVE.L #$2AAA,A3
0020191E  36BC AAAA               3598      MOVE.W #$AAAA,(A3)
00201922  267C 00001554           3599      MOVE.L #$1554,A3
00201928  36BC 5555               3600      MOVE.W #$5555,(A3)
0020192C  267C 00002AAA           3601      MOVE.L #$2AAA,A3
00201932  36BC 8080               3602      MOVE.W #$8080,(A3)
00201936  267C 00002AAA           3603      MOVE.L #$2AAA,A3
0020193C  36BC AAAA               3604      MOVE.W #$AAAA,(A3)
00201940  267C 00001554           3605      MOVE.L #$1554,A3
00201946  36BC 5555               3606      MOVE.W #$5555,(A3)
0020194A  267C 00002AAA           3607      MOVE.L #$2AAA,A3
00201950  36BC 2020               3608      MOVE.W #$2020,(A3)
00201954                          3609      
00201954  45F9 00201B79           3610      LEA LOADING,A2                ; important for timing
0020195A                          3611m     PRINT_STR A2,D3
0020195A                          3612m LOOP_262
0020195A  0C12 0000               3613m     CMP.B #0,(A2)                 ; 0 -> DONE
0020195E  6700 001A               3614m     BEQ EXIT_262
00201962                          3615mm     PRINT_CHAR (A2)+,D3
00201962                          3616mm WAIT_FOR_READY_263                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201962                 TRUE     3617mm     IFEQ DEBUG
00201962  1639 00D30003           3618mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201968  0803 0002               3619mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020196C  67F4                    3620mm       BEQ WAIT_FOR_READY_263          ; NO SPACE, CHECK AGAIN
0020196E  13DA 00D30007           3621mm       MOVE.B (A2)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00201974                          3622mm     ENDC
00201974                          3623mm     
00201974                 FALSE    3624mm     IFNE DEBUG
00201974                          3625mm     ENDC
00201974                          3626mm 
00201974                          3627mm     ENDM
00201974  4EF9 0020195A           3628m     JMP LOOP_262
0020197A                          3629m EXIT_262
0020197A                          3630m     ENDM
0020197A                          3631  
0020197A  023C 00FB               3632      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
0020197E                          3633      ;MOVE.L #0,D1
0020197E                          3634      
0020197E                          3635      WHILE D5 <GT> #0 DO
0020197E                          3636s _1000000A
0020197E  BA7C 0000               3637s     CMP.W   #0,D5
00201982  6F00 0020               3638s     BLE _1000000B
00201986  5585                    3639        SUB.L #2,D5
00201988                          3640        
00201988  13D1 00E00001           3641        MOVE.B (A1),DISPLAY
0020198E  3091                    3642        MOVE.W (A1),(A0)            ; write the data
00201990                          3643  
00201990                          3644        ;PRINT_CHAR #'W',D3
00201990                          3645        ;MOVE.L #0,D3
00201990                          3646        ;MOVE.W (A1),D3
00201990                          3647        ;PRINT_REG D3,D4,D7,D6,A2
00201990                          3648        ;PRINT_CRLF D3      
00201990                          3649        
00201990                          3650    WAIT_FOR_COMPLETE:
00201990                          3651        ;PRINT_CHAR #'R',D2
00201990  3410                    3652        MOVE.W (A0),D2
00201992                          3653  
00201992                          3654        ;PRINT_REG D2,D3,D7,D6,A2
00201992                          3655        ;PRINT_CRLF D3      
00201992                          3656        
00201992                          3657        IF D2 <NE> (A1) THEN
00201992  B451                    3658s     CMP.W   (A1),D2
00201994  6700 0008               3659s     BEQ _0000000C
00201998                          3660  
00201998                          3661          ;PRINT_CHAR #'.',D2
00201998                          3662          
00201998  4EF9 00201990           3663          JMP WAIT_FOR_COMPLETE
0020199E                          3664        ENDI
0020199E                          3665s _0000000C
0020199E                          3666  
0020199E                          3667        ;PRINT_CHAR #'c',D2
0020199E                          3668        ;PRINT_CRLF D3      
0020199E                          3669        
0020199E  5488                    3670        ADD.L #2,A0
002019A0  5489                    3671        ADD.L #2,A1
002019A2                          3672  
002019A2                          3673        ;ADD.L #1,D1
002019A2                          3674        ;IF D1 <EQ> #64 THEN
002019A2                          3675   
002019A2                          3676          ;PRINT_CHAR #'A',D2
002019A2                          3677          ;MOVE.L A0,D0
002019A2                          3678          ;PRINT_REG D0,D3,D7,D6,A2
002019A2                          3679          ;PRINT_CRLF D3      
002019A2                          3680        ;ENDI
002019A2                          3681      ENDW  
002019A2  60DA                    3682s     BRA _1000000A
002019A4                          3683s _1000000B
002019A4                          3684      
002019A4  267C 00002AAA           3685      MOVE.L #$2AAA,A3
002019AA  36BC AAAA               3686      MOVE.W #$AAAA,(A3)
002019AE  267C 00001554           3687      MOVE.L #$1554,A3
002019B4  36BC 5555               3688      MOVE.W #$5555,(A3)
002019B8  267C 00002AAA           3689      MOVE.L #$2AAA,A3
002019BE  36BC A0A0               3690      MOVE.W #$A0A0,(A3)
002019C2                          3691              
002019C2  4EF9 00200188           3692      JMP MAIN_LOOP
002019C8                          3693          
002019C8  207C 00000000           3694  X   MOVE.L #0,A0
002019CE  4ED0                    3695      JMP (A0)
002019D0                          3696  
002019D0                          3697  HEX_DIGIT
002019D0  E98F                    3698      LSL.L #4,D7                    ; add the next digit in the next 4 bits
002019D2                          3699m     HEX2BIN D2,D2,A0
002019D2  41F9 00201B62           3700m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002019D8  0402 0030               3701m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002019DC  C4BC 000000FF           3702m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002019E2  1430 2000               3703m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002019E6                          3704m   ENDM
002019E6  8E02                    3705      OR.B D2,D7  
002019E8  4EF9 002001B0           3706      JMP GET_INPUT
002019EE                          3707  
002019EE  FFFF FFFF               3708      SIMHALT                         ; halt simulator
002019F2                          3709  
002019F2                          3710  ; strings
002019F2= 4D 44 46 2D 6D 6F ...   3711  VERSION DC.B 'MDF-mon V1.30 (07/04/2021)',13,10,0
00201A0F= 3F 20 48 65 6C 70 ...   3712  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,'X exit to ROM',13,10,0
00201AB5= 48 75 68 3F 0D 0A 00    3713  HUH     DC.B 'Huh?',13,10,0
00201ABC= 55 6E 69 6D 70 6C ...   3714  UNIMP   DC.B 'Unimplemented',13,10,0
00201ACC= 20 53 20 72 65 63 ...   3715  READ    DC.B ' S records read, start address = ',0
00201AEE= 57 41 52 4E 49 4E ...   3716  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00201B14= 57 41 52 4E 49 4E ...   3717  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00201B3A= 57 41 52 4E 49 4E ...   3718  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
00201B52= 30 31 32 33 34 35 ...   3719  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201B62= 00 01 02 03 04 05 ...   3720  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201B79= 4C 6F 61 64 69 6E ...   3721  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201B8D                          3722      
00201B8D                          3723      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201B52
CONTINUE_100        200A72
CONTINUE_104        200AD0
CONTINUE_108        200B30
CONTINUE_112        200B8E
CONTINUE_116        200C00
CONTINUE_120        200C5E
CONTINUE_127        200D06
CONTINUE_131        200D64
CONTINUE_135        200DC4
CONTINUE_139        200E22
CONTINUE_143        200E86
CONTINUE_147        200EE4
CONTINUE_151        200F5A
CONTINUE_155        200FB8
CONTINUE_159        201032
CONTINUE_163        201090
CONTINUE_167        2010F0
CONTINUE_171        20114E
CONTINUE_175        2011C0
CONTINUE_179        20121E
CONTINUE_186        2012C6
CONTINUE_189        201312
CONTINUE_192        201360
CONTINUE_195        2013AC
CONTINUE_198        2013FE
CONTINUE_201        20144A
CONTINUE_210        201516
CONTINUE_213        201562
CONTINUE_44         2004C4
CONTINUE_46         200500
CONTINUE_48         200538
CONTINUE_51         200584
CONTINUE_54         2005DA
CONTINUE_57         200626
CONTINUE_60         200674
CONTINUE_63         2006C0
CONTINUE_66         200720
CONTINUE_69         20076C
CONTINUE_76         20080A
CONTINUE_80         200868
CONTINUE_84         2008C8
CONTINUE_88         200926
CONTINUE_92         20099C
CONTINUE_96         2009FA
CS_FAILURE          201B14
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       201640
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EVEN                200A48
EVEN2               201006
EXIT_19             2002F2
EXIT_204            2014B0
EXIT_21             20031E
EXIT_216            2015BC
EXIT_23             20034A
EXIT_231            2016BA
EXIT_241            2017C6
EXIT_262            20197A
EXIT_5              200142
G                   20173E
GET_INPUT           2001B0
H                   2002F8
HELP                201A0F
HEX2BIN             12B
HEX2BIN_LUT         201B62
HEX_DIGIT           2019D0
HUH                 201AB5
L                   201852
LOADING             201B79
LOOP_19             2002D2
LOOP_204            201490
LOOP_21             2002FE
LOOP_216            20159C
LOOP_218            2015E6
LOOP_226            20166A
LOOP_23             20032A
LOOP_231            20169A
LOOP_233            2016E6
LOOP_241            2017A6
LOOP_243            2017F4
LOOP_25             20037E
LOOP_262            20195A
LOOP_5              200122
MAIN_LOOP           200188
OK                  201846
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   200350
RAM                 200000
RAM_ERROR           201B3A
READ                201ACC
READ_CHAR           79D
READ_DATA_TO_POKE   200420
READ_LENGTH         20189A
RESET               200004
ROM                 0
RRRR                200000
S                   2004A0
STACK               200000
START               200008
UNIMP               201ABC
UNREC               201AEE
V                   200324
VERSION             2019F2
W                   2003D8
WAIT_CHAR           615
WAIT_FOR_COMPLETE   201990
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  200A56
WAIT_FOR_READY_102  200A8A
WAIT_FOR_READY_104  200AB4
WAIT_FOR_READY_106  200AE8
WAIT_FOR_READY_108  200B14
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200B48
WAIT_FOR_READY_112  200B72
WAIT_FOR_READY_114  200BA6
WAIT_FOR_READY_116  200BE4
WAIT_FOR_READY_118  200C18
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_120  200C42
WAIT_FOR_READY_122  200C76
WAIT_FOR_READY_125  200CAE
WAIT_FOR_READY_126  200CC2
WAIT_FOR_READY_127  200CEA
WAIT_FOR_READY_129  200D1E
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D48
WAIT_FOR_READY_133  200D7C
WAIT_FOR_READY_135  200DA8
WAIT_FOR_READY_137  200DDC
WAIT_FOR_READY_139  200E06
WAIT_FOR_READY_141  200E3A
WAIT_FOR_READY_143  200E6A
WAIT_FOR_READY_145  200E9E
WAIT_FOR_READY_147  200EC8
WAIT_FOR_READY_149  200EFC
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200F3E
WAIT_FOR_READY_153  200F72
WAIT_FOR_READY_155  200F9C
WAIT_FOR_READY_157  200FD0
WAIT_FOR_READY_159  201016
WAIT_FOR_READY_161  20104A
WAIT_FOR_READY_163  201074
WAIT_FOR_READY_165  2010A8
WAIT_FOR_READY_167  2010D4
WAIT_FOR_READY_169  201108
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  201132
WAIT_FOR_READY_173  201166
WAIT_FOR_READY_175  2011A4
WAIT_FOR_READY_177  2011D8
WAIT_FOR_READY_179  201202
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  201236
WAIT_FOR_READY_184  20126E
WAIT_FOR_READY_185  201282
WAIT_FOR_READY_186  2012AA
WAIT_FOR_READY_189  2012F6
WAIT_FOR_READY_192  201344
WAIT_FOR_READY_195  201390
WAIT_FOR_READY_198  2013E2
WAIT_FOR_READY_20   2002DA
WAIT_FOR_READY_201  20142E
WAIT_FOR_READY_205  201498
WAIT_FOR_READY_206  2014B0
WAIT_FOR_READY_208  2014C2
WAIT_FOR_READY_209  2014D6
WAIT_FOR_READY_210  2014FA
WAIT_FOR_READY_213  201546
WAIT_FOR_READY_217  2015A4
WAIT_FOR_READY_219  2015BC
WAIT_FOR_READY_22   200306
WAIT_FOR_READY_220  2015D0
WAIT_FOR_READY_222  2015FA
WAIT_FOR_READY_224  201610
WAIT_FOR_READY_225  201624
WAIT_FOR_READY_227  201640
WAIT_FOR_READY_228  201654
WAIT_FOR_READY_230  20167E
WAIT_FOR_READY_232  2016A2
WAIT_FOR_READY_234  2016BC
WAIT_FOR_READY_235  2016D0
WAIT_FOR_READY_237  2016FA
WAIT_FOR_READY_239  201710
WAIT_FOR_READY_24   200332
WAIT_FOR_READY_240  201724
WAIT_FOR_READY_242  2017AE
WAIT_FOR_READY_244  2017CA
WAIT_FOR_READY_245  2017DE
WAIT_FOR_READY_247  201808
WAIT_FOR_READY_249  20181E
WAIT_FOR_READY_250  201832
WAIT_FOR_READY_251  201854
WAIT_FOR_READY_253  20186E
WAIT_FOR_READY_255  20189C
WAIT_FOR_READY_257  2018B6
WAIT_FOR_READY_26   200354
WAIT_FOR_READY_260  2018E6
WAIT_FOR_READY_261  2018FA
WAIT_FOR_READY_263  201962
WAIT_FOR_READY_27   200368
WAIT_FOR_READY_29   200392
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A8
WAIT_FOR_READY_32   2003BC
WAIT_FOR_READY_33   2003DA
WAIT_FOR_READY_35   2003F4
WAIT_FOR_READY_37   200422
WAIT_FOR_READY_39   20043C
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   200472
WAIT_FOR_READY_43   200486
WAIT_FOR_READY_44   2004A8
WAIT_FOR_READY_46   2004E4
WAIT_FOR_READY_48   20051C
WAIT_FOR_READY_51   200568
WAIT_FOR_READY_54   2005BE
WAIT_FOR_READY_57   20060A
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200658
WAIT_FOR_READY_63   2006A4
WAIT_FOR_READY_66   200704
WAIT_FOR_READY_69   200750
WAIT_FOR_READY_72   20079C
WAIT_FOR_READY_74   2007B2
WAIT_FOR_READY_75   2007C6
WAIT_FOR_READY_76   2007EE
WAIT_FOR_READY_78   200822
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   20084C
WAIT_FOR_READY_82   200880
WAIT_FOR_READY_84   2008AC
WAIT_FOR_READY_86   2008E0
WAIT_FOR_READY_88   20090A
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   20093E
WAIT_FOR_READY_92   200980
WAIT_FOR_READY_94   2009B4
WAIT_FOR_READY_96   2009DE
WAIT_FOR_READY_98   200A12
WAIT_FOR_SRECORD    2004A8
X                   2019C8
Z                   201746
_00000000           2007E4
_00000001           2014F0
_00000002           200CE0
_00000003           200CAE
_00000004           2014F0
_00000005           2012A0
_00000006           20126E
_00000007           2014F0
_00000008           20148A
_00000009           2014F0
_0000000A           20163E
_0000000B           2017A0
_0000000C           20199E
_10000000           2006F6
_10000001           2007B2
_10000002           200A48
_10000003           200BDA
_10000004           201008
_10000005           20119A
_10000006           20174E
_10000007           201770
_10000008           201778
_10000009           20184C
_1000000A           20197E
_1000000B           2019A4
