00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/03/2021 19:55:20

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; WRITE doesn't seem to work for reals - it writes to the correct place, but the wrong data
00000000                             9  ; can do WWWWW in the input loop - it doesn't validate
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00E00000                 14  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 15  DISPLAY_            EQU $0
00000000  =00E00000                 16  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_
00000000                            17  
00000000  =00D30000                 18  DUART_BASE          EQU $D30000
00000000  =00000000                 19  DUART_MRA_          EQU $0
00000000  =00000001                 20  DUART_CSRA_         EQU $1
00000000  =00000001                 21  DUART_SRA_          EQU $1
00000000  =00000002                 22  DUART_CRA_          EQU $2
00000000  =00000003                 23  DUART_TXA_          EQU $3
00000000  =00000003                 24  DUART_RXA_          EQU $3
00000000  =00000004                 25  DUART_ACR_          EQU $4
00000000  =00000005                 26  DUART_IMR_          EQU $5
00000000  =00000008                 27  DUART_MRB_          EQU $8
00000000  =00000009                 28  DUART_CSRB_         EQU $9
00000000  =00000009                 29  DUART_SRB_          EQU $9
00000000  =0000000A                 30  DUART_CRB_          EQU $A
00000000  =0000000B                 31  DUART_TXB_          EQU $B
00000000  =0000000B                 32  DUART_RXB_          EQU $B
00000000  =0000000C                 33  DUART_IVR_          EQU $C
00000000  =0000000D                 34  DUART_OPCR_         EQU $D
00000000  =0000000E                 35  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 36  DUART_RESET_OPR_    EQU $F
00000000                            37  
00000000  =00D30001                 38  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 39  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 40  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 41  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 42  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 43  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            44  
00000000  =00D30011                 45  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 46  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 47  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 48  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 49  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 50  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            51  
00000000  =00D30009                 52  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 53  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 54  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 55  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 56  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 57  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            58  
00000000                            59  ; macros
00000000                            60  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            61  ; the input register is changed during the process
00000000                            62  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            63  BIN2HEX MACRO
00000000                            64    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            65    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            66    MOVE.B \1,\2
00000000                            67    ANDI.B #$F,\2
00000000                            68    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            69    ENDM
00000000                            70  
00000000                            71  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            72  ; the input register is changed during the process
00000000                            73  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            74  HEX2BIN MACRO
00000000                            75    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            76    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            77    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            78    ENDM
00000000                            79  
00000000                            80  ; send a single char to the serial port
00000000                            81  ; \1 = char to send, \2 = data register to use for status poll
00000000                            82  ; will stamp on D3 and D2 in debug mode
00000000                            83  PRINT_CHAR MACRO
00000000                            84  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            85      IFEQ DEBUG
00000000                            86        MOVE.B DUART_SRA,\2           ; read status register
00000000                            87        BTST #2,\2                    ; check for space to send
00000000                            88        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            89        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            90      ENDC
00000000                            91      
00000000                            92      IFNE DEBUG
00000000                            93        MOVE.B \1,D1
00000000                            94        MOVE.L #6,D0   
00000000                            95        TRAP #15                      ; write to terminal in simulator
00000000                            96      ENDC
00000000                            97  
00000000                            98      ENDM
00000000                            99  
00000000                           100  ; send CR,LF to the serial port
00000000                           101  ; \1 = data register to use for status poll
00000000                           102  PRINT_CRLF MACRO                  
00000000                           103      PRINT_CHAR #13,\1             ; CR
00000000                           104      PRINT_CHAR #10,\1             ; LF
00000000                           105      ENDM
00000000                           106  
00000000                           107  ; send C-style, zero terminated string to the serial port
00000000                           108  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           109  PRINT_STR MACRO
00000000                           110  LOOP\@
00000000                           111      CMP.B #0,(\1)                 ; 0 -> done
00000000                           112      BEQ EXIT\@
00000000                           113      PRINT_CHAR (\1)+,\2
00000000                           114      JMP LOOP\@
00000000                           115  EXIT\@
00000000                           116      ENDM
00000000                           117    
00000000                           118  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           119  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           120  PRINT_REG MACRO
00000000                           121      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           122  LOOP\@
00000000                           123      BIN2HEX \1,\3,\5
00000000                           124      PRINT_CHAR \3,\2
00000000                           125      DBEQ \4,LOOP\@
00000000                           126      ENDM
00000000                           127    
00000000                           128  ; read a char from the serial port
00000000                           129  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           130  ; will stamp on D3 and D2 in debug mode
00000000                           131  READ_CHAR MACRO
00000000                           132  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           133  
00000000                           134      IFEQ DEBUG
00000000                           135        MOVE.B DUART_SRA,\2         ; read status register
00000000                           136        BTST #0,\2                    ; check for character
00000000                           137        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           138      ENDC
00000000                           139  
00000000                           140      IFEQ DEBUG
00000000                           141        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           142      ENDC
00000000                           143      IFNE DEBUG
00000000                           144        MOVE.L #5,D0    
00000000                           145        TRAP #15                    ; read from keyboard in simulator
00000000                           146        MOVE.L D1,\1
00000000                           147      ENDC
00000000                           148       
00000000                           149      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           150      BEQ RESTART
00000000                           151  
00000000                           152      IFEQ DEBUG
00000000                           153        PRINT_CHAR \1,\2            ; echo it back
00000000                           154      ENDC
00000000                           155      ENDM
00000000                           156  
00000000                           157  ; register catalogue
00000000                           158  ; D0 - used for simulator I/O
00000000                           159  ; D1 - used for simulator I/O
00000000                           160  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           161  ; D4 - read character
00000000                           162  ; D5 - byte to W
00000000                           163  ; D6 - working register used in R/W
00000000                           164  ; D7 - address accumulator
00000000                           165  ; A0 - address of string to print / address for R or W
00000000                           166  
00000000                           167  ; start vector
00000000                           168      ORG  $0
00000000= 00000000                 169      DC.L $00000000              ; PC
00000004= 00000000                 170      DC.L $00000000              ; SP
00000008                           171      
00000008                           172  ; start of program  
00000008                           173  START
00000008  13FC 0000 00E00000       174      MOVE.B #0,DISPLAY
00000010                           175     
00000010                           176  ;initialise UART
00000010  13FC 0000 00D30009       177      MOVE.B #$0,DUART_ACR            
00000018  13FC 0000 00D3000B       178      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000020  13FC 0000 00D3001B       179      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000028                           180  
00000028                           181  ; channel A
00000028  13FC 0003 00D30001       182      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000030  13FC 0007 00D30001       183      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000038  13FC 00BB 00D30003       184      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
00000040  13FC 0005 00D30005       185      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000048                           186  
00000048                           187  ; channel B
00000048  13FC 0003 00D30011       188      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
00000050  13FC 0047 00D30011       189      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
00000058  13FC 00BB 00D30013       190      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
00000060  13FC 0005 00D30015       191      MOVE.B #$5,DUART_CRB            ; enable rx & tx
00000068                           192  
00000068                           193  WARM_START
00000068  13FC 0001 00E00000       194      MOVE.B #1,DISPLAY
00000070                           195         
00000070  41F9 00000412            196      LEA VERSION,A0
00000076                           197m     PRINT_STR A0,D3
00000094                           198m     PRINT_CRLF D3
000000BC                           199m     PRINT_CHAR #7,D3
000000D0                           200  
000000D0  7E00                     201      MOVE.L #0,D7                    ; address accumulator
000000D2                           202  
000000D2  13FC 0002 00E00000       203      MOVE.B #2,DISPLAY
000000DA                           204  MAIN_LOOP
000000DA                           205m     PRINT_CHAR #'>',D3               ; prompt
000000EE                           206m     PRINT_CHAR #32,D3                ; space
00000102                           207      
00000102                           208  GET_INPUT
00000102                           209m     READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000012E                           210      
0000012E  B83C 0030                211      CMP.B #'0',D4
00000132  6700 02C4                212      BEQ HEX_DIGIT
00000136  B83C 0031                213      CMP.B #'1',D4
0000013A  6700 02BC                214      BEQ HEX_DIGIT
0000013E  B83C 0032                215      CMP.B #'2',D4
00000142  6700 02B4                216      BEQ HEX_DIGIT
00000146  B83C 0033                217      CMP.B #'3',D4
0000014A  6700 02AC                218      BEQ HEX_DIGIT
0000014E  B83C 0034                219      CMP.B #'4',D4
00000152  6700 02A4                220      BEQ HEX_DIGIT
00000156  B83C 0035                221      CMP.B #'5',D4
0000015A  6700 029C                222      BEQ HEX_DIGIT
0000015E  B83C 0036                223      CMP.B #'6',D4
00000162  6700 0294                224      BEQ HEX_DIGIT
00000166  B83C 0037                225      CMP.B #'7',D4
0000016A  6700 028C                226      BEQ HEX_DIGIT
0000016E  B83C 0038                227      CMP.B #'8',D4
00000172  6700 0284                228      BEQ HEX_DIGIT
00000176  B83C 0039                229      CMP.B #'9',D4
0000017A  6700 027C                230      BEQ HEX_DIGIT
0000017E  B83C 0041                231      CMP.B #'A',D4
00000182  6700 0274                232      BEQ HEX_DIGIT
00000186  B83C 0042                233      CMP.B #'B',D4
0000018A  6700 026C                234      BEQ HEX_DIGIT
0000018E  B83C 0043                235      CMP.B #'C',D4
00000192  6700 0264                236      BEQ HEX_DIGIT
00000196  B83C 0044                237      CMP.B #'D',D4
0000019A  6700 025C                238      BEQ HEX_DIGIT
0000019E  B83C 0045                239      CMP.B #'E',D4
000001A2  6700 0254                240      BEQ HEX_DIGIT
000001A6  B83C 0046                241      CMP.B #'F',D4
000001AA  6700 024C                242      BEQ HEX_DIGIT
000001AE                           243      
000001AE  B83C 0057                244      CMP.B #'W',D4
000001B2  6700 0152                245      BEQ W
000001B6                           246  
000001B6                           247m     PRINT_CRLF D3
000001DE                           248   
000001DE  B83C 003F                249      CMP.B #'?',D4
000001E2  6700 0076                250      BEQ H
000001E6                           251  
000001E6  B83C 0056                252      CMP.B #'V',D4
000001EA  6700 0096                253      BEQ V
000001EE                           254      
000001EE  B83C 0052                255      CMP.B #'R',D4
000001F2  6700 00B6                256      BEQ R
000001F6                           257  
000001F6  B83C 0053                258      CMP.B #'S',D4
000001FA  6700 01C4                259      BEQ S
000001FE                           260  
000001FE  B83C 0047                261      CMP.B #'G',D4
00000202  6700 01EC                262      BEQ G   
00000206                           263  
00000206  41F9 00000489            264      LEA HUH,A0
0000020C                           265m     PRINT_STR A0,D3
0000022A                           266                         
0000022A  4EF8 00DA                267      JMP MAIN_LOOP
0000022E                           268  
0000022E                           269  RESTART
0000022E                           270m     PRINT_CRLF D3
00000256  4EF8 0068                271      JMP WARM_START
0000025A                           272  
0000025A                           273  ; commands
0000025A  41F9 0000042E            274  H   LEA HELP,A0
00000260                           275m     PRINT_STR A0,D3
0000027E  4EF8 00DA                276      JMP MAIN_LOOP
00000282                           277  
00000282  41F9 00000412            278  V   LEA VERSION,A0
00000288                           279m     PRINT_STR A0,D3       
000002A6  4EF8 00DA                280      JMP MAIN_LOOP
000002AA                           281      
000002AA  2047                     282  R   MOVE.L D7,A0                    ; address accumulator -> address register
000002AC  2810                     283      MOVE.L (A0),D4                  ; read the memory and print it
000002AE                           284m     PRINT_REG D4,D3,D7,D6,A0
000002D8                           285m     PRINT_CRLF D3
00000300  7E00                     286      MOVE.L #0,D7                    ; clear the now used address accumulator
00000302  4EF8 00DA                287      JMP MAIN_LOOP
00000306                           288  
00000306  7A00                     289  W   MOVE.L #0,D5                    ; D5 will be the value to write            
00000308                           290  
00000308                           291m     READ_CHAR D4,D3                 ; read most significant character -> D4
00000334                           292m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000342  1A04                     293      MOVE.B D4,D5                    ; put at bottom of D5
00000344                           294  
00000344  3C3C 0006                295      MOVE #6,D6                      ; 7 bytes left to read
00000348                           296      
00000348                           297  READ_DATA
00000348  E98D                     298      LSL.L #4,D5                     ; make what we have so far more significant
0000034A                           299m     READ_CHAR D4,D3                 ; next character -> D4
00000376                           300m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000384  8A04                     301      OR.B D4,D5
00000386  023C 00FB                302      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
0000038A  57CE FFBC                303      DBEQ D6,READ_DATA
0000038E                           304      
0000038E  2047                     305      MOVE.L D7,A0                    ; address accumulator -> address register
00000390  7E00                     306      MOVE.L #0,D7                    ; clear the now used address accumulator
00000392  2085                     307      MOVE.L D5,(A0)                  ; write the data
00000394                           308  
00000394                           309m     PRINT_CRLF D3
000003BC  4EF8 00DA                310      JMP MAIN_LOOP
000003C0                           311  
000003C0                           312m S   READ_CHAR D4,D3                  ; fetch character from serial port -> D4
000003EC  4EF8 03C0                313      JMP S
000003F0                           314  
000003F0  2047                     315  G   MOVE.L D7,A0                    ; address accumulator -> address register
000003F2  3E3C 0000                316      MOVE #0,D7                      ; clear the now used address accumulator
000003F6  4ED0                     317      JMP (A0)                        ; jump to it!
000003F8                           318          
000003F8                           319  HEX_DIGIT
000003F8  E98F                     320      LSL.L #4,D7                    ; add the next digit in the next 4 bits
000003FA                           321m     HEX2BIN D4,D4,A0
00000408  8E84                     322      OR.L D4,D7
0000040A  4EF8 0102                323      JMP GET_INPUT
0000040E                           324  
0000040E  FFFF FFFF                325      SIMHALT                         ; halt simulator
00000412                           326  
00000412                           327  ; strings
00000412= 4D 44 46 2D 6D 6F ...    328  VERSION DC.B 'MDF-mon V1.4 (30/03/2021)',13,10,0
0000042E= 3F 20 48 65 6C 70 ...    329  HELP    DC.B '? Help',13,10,'V Version',13,10,'nnnnnnnnR Read',13,10,'nnnnnnnnWnn Write',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
00000489= 48 75 68 3F 0D 0A 00     330  HUH     DC.B 'Huh?',13,10,0
00000490= 55 6E 69 6D 70 6C ...    331  UNIMP   DC.B 'Unimplemented',13,10,0
000004A0= 30 31 32 33 34 35 ...    332  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000004B0= 00 01 02 03 04 05 ...    333  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000004C7                           334      
000004C7                           335      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         4A0
DEBUG               0
DISPLAY             E00000
DISPLAY_            0
DISPLAY_BASE        E00000
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_1              94
EXIT_14             22A
EXIT_19             27E
EXIT_21             2A6
G                   3F0
GET_INPUT           102
H                   25A
HELP                42E
HEX2BIN             12B
HEX2BIN_LUT         4B0
HEX_DIGIT           3F8
HUH                 489
LOOP_1              76
LOOP_14             20C
LOOP_19             260
LOOP_21             288
LOOP_23             2B0
MAIN_LOOP           DA
PRINT_CHAR          218
PRINT_CRLF          411
PRINT_REG           4ED
PRINT_STR           46B
R                   2AA
READ_CHAR           591
READ_DATA           348
RESTART             22E
S                   3C0
START               8
UNIMP               490
V                   282
VERSION             412
W                   306
WAIT_FOR_READY_10   11C
WAIT_FOR_READY_12   1B6
WAIT_FOR_READY_13   1CA
WAIT_FOR_READY_15   214
WAIT_FOR_READY_17   22E
WAIT_FOR_READY_18   242
WAIT_FOR_READY_2    7E
WAIT_FOR_READY_20   268
WAIT_FOR_READY_22   290
WAIT_FOR_READY_25   2C2
WAIT_FOR_READY_27   2D8
WAIT_FOR_READY_28   2EC
WAIT_FOR_READY_29   308
WAIT_FOR_READY_30   322
WAIT_FOR_READY_32   34A
WAIT_FOR_READY_33   364
WAIT_FOR_READY_36   394
WAIT_FOR_READY_37   3A8
WAIT_FOR_READY_38   3C0
WAIT_FOR_READY_39   3DA
WAIT_FOR_READY_4    94
WAIT_FOR_READY_5    A8
WAIT_FOR_READY_6    BC
WAIT_FOR_READY_7    DA
WAIT_FOR_READY_8    EE
WAIT_FOR_READY_9    102
WARM_START          68
