00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 07:11:44

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                             9  ; give DOWNLOAD_BYTE a loop to remove loop unrolling and doubling of code
00000000                            10  ; include the checksum in download_byte
00000000                            11  ; stop using two registers in download
00000000                            12  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            13  ; Review for any other savings
00000000                            14  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            15  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            16  
00000000                            17  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; fix the reset vector so that it jumps to the start
00000000                            20  ; Replace JMP -> BRA
00000000                            21  ; implement backspace
00000000                            22  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            23  ; fix being able to enter random chars when W'ing
00000000                            24  ; ram check at startup?  Not sure if this is a good idea!
00000000                            25  ; byte W?
00000000                            26  
00000000                            27      ;ORG  $0
00200000                            28      ORG  $200000
00200000                            29  
00200000  =00000000                 30  DEBUG               EQU 0
00200000                            31  
00200000                            32  ; constants
00200000  =00000000                 33  ROM                 EQU $0
00200000  =00200000                 34  RAM                 EQU $200000
00200000                            35     
00200000  =00C00000                 36  DUART_BASE          EQU $C00000
00200000  =00000000                 37  DUART_MRA_          EQU $0
00200000  =00000001                 38  DUART_CSRA_         EQU $1
00200000  =00000001                 39  DUART_SRA_          EQU $1
00200000  =00000002                 40  DUART_CRA_          EQU $2
00200000  =00000003                 41  DUART_TXA_          EQU $3
00200000  =00000003                 42  DUART_RXA_          EQU $3
00200000  =00000004                 43  DUART_ACR_          EQU $4
00200000  =00000005                 44  DUART_IMR_          EQU $5
00200000  =00000008                 45  DUART_MRB_          EQU $8
00200000  =00000009                 46  DUART_CSRB_         EQU $9
00200000  =00000009                 47  DUART_SRB_          EQU $9
00200000  =0000000A                 48  DUART_CRB_          EQU $A
00200000  =0000000B                 49  DUART_TXB_          EQU $B
00200000  =0000000B                 50  DUART_RXB_          EQU $B
00200000  =0000000C                 51  DUART_IVR_          EQU $C
00200000  =0000000D                 52  DUART_OPCR_         EQU $D
00200000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00200000                            55  
00200000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            62  
00200000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            69  
00200000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            76  
00200000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 78  DISPLAY_            EQU $0
00200000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            80  
00200000                            81  ; macros
00200000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            83  ; the input register is changed during the process
00200000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            85  BIN2HEX MACRO
00200000                            86      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            88      MOVE.B \1,\2
00200000                            89      ANDI.L #$F,\2
00200000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            91      ENDM
00200000                            92  
00200000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            94  ; the input register is changed during the process
00200000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            96  HEX2BIN MACRO
00200000                            97      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            98      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                            99      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                           100      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           101      ENDM
00200000                           102  
00200000                           103  ; send a single char to the serial port
00200000                           104  ; \1 = char to send, \2 = data register to use for status poll
00200000                           105  ; will stamp on D0 and D1 in debug mode
00200000                           106  PRINT_CHAR MACRO
00200000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           108      IFEQ DEBUG
00200000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           110          BTST #2,\2                              ; check for space to send
00200000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           113      ENDC
00200000                           114      
00200000                           115      IFNE DEBUG
00200000                           116          MOVE.B \1,D1
00200000                           117          MOVE.L #6,D0   
00200000                           118          TRAP #15                                ; write to terminal in simulator
00200000                           119      ENDC
00200000                           120  
00200000                           121      ENDM
00200000                           122  
00200000                           123  ; send CR,LF to the serial port
00200000                           124  ; \1 = data register to use for status poll
00200000                           125  PRINT_CRLF MACRO
00200000                           126      PRINT_CHAR #13,\1                           ; CR
00200000                           127      PRINT_CHAR #10,\1                           ; LF
00200000                           128      ENDM
00200000                           129  
00200000                           130  ; send C-style, zero terminated string to the serial port
00200000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           132  PRINT_STR MACRO
00200000                           133  LOOP\@
00200000                           134      CMP.B #0,(\1)                               ; 0 -> done
00200000                           135      BEQ EXIT\@
00200000                           136      PRINT_CHAR (\1)+,\2
00200000                           137      JMP LOOP\@
00200000                           138  EXIT\@
00200000                           139      ENDM
00200000                           140    
00200000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           143  PRINT_REG MACRO
00200000                           144      PRINT_CHAR #'0',\2                          ;0x header
00200000                           145      PRINT_CHAR #'x',\2
00200000                           146      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           147  LOOP\@
00200000                           148      BIN2HEX \1,\3,\5
00200000                           149      PRINT_CHAR \3,\2
00200000                           150      DBEQ \4,LOOP\@
00200000                           151      ENDM
00200000                           152    
00200000                           153  ; wait for a char from the serial port
00200000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           155  ; will stamp on D0 and D1 in debug mode
00200000                           156  WAIT_CHAR MACRO
00200000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           158  
00200000                           159      IFEQ DEBUG
00200000                           160          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           161          BTST #0,\2                              ; check for character
00200000                           162          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           163      ENDC
00200000                           164      
00200000                           165      READ_CHAR \1
00200000                           166  
00200000                           167      IFEQ DEBUG
00200000                           168          PRINT_CHAR \1,\2                        ; echo it back
00200000                           169      ENDC
00200000                           170      ENDM
00200000                           171      
00200000                           172  ; read a char from the serial port - assumes that there is one!
00200000                           173  ; \ 1= data register for read char
00200000                           174  ; will stamp on D0 and D1 in debug mode
00200000                           175  READ_CHAR MACRO
00200000                           176      IFEQ DEBUG
00200000                           177          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           178      ENDC
00200000                           179      IFNE DEBUG
00200000                           180          MOVE.L #5,D0    
00200000                           181          TRAP #15                                ; read from keyboard in simulator
00200000                           182          MOVE.L D1,\1
00200000                           183      ENDC
00200000                           184       
00200000                           185      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           186      BEQ START
00200000                           187      ENDM
00200000                           188      
00200000                           189      
00200000                           190  ; read data from the download serial port
00200000                           191  ; \ 1= data register for read char
00200000                           192  DOWNLOAD MACRO
00200000                           193  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           194  
00200000                           195      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           196      BTST #0,\1                                  ; check for character
00200000                           197      BEQ CONTINUE\@                              ; nothing, continue
00200000                           198   
00200000                           199      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           200  CONTINUE\@
00200000                           201      MOVE.B DUART_SRB,\1                         ; read download status register
00200000                           202      BTST #0,\1                                  ; check for character
00200000                           203      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           204      
00200000                           205      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           206      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           207      
00200000                           208      ENDM
00200000                           209      
00200000                           210  ; read two hex digits from the download serial port and convert to a byte
00200000                           211  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working address register, 
00200000                           212  DOWNLOAD_BYTE MACRO
00200000                           213      DOWNLOAD \1                                ; read first (most significant) char, convert to 4 bits and shift to top
00200000                           214      PRINT_CHAR \1,\3
00200000                           215      HEX2BIN \1,\1,\4
00200000                           216      OR.B \1,\2
00200000                           217      LSL.L #4,\2
00200000                           218          
00200000                           219      DOWNLOAD \1                                ; now the second (least significant) char, convert to binary
00200000                           220      PRINT_CHAR \1,\3
00200000                           221      HEX2BIN \1,\1,\4
00200000                           222      OR.B \1,\2    
00200000                           223      ENDM
00200000                           224      
00200000                           225  
00200000                           226  ; register catalogue
00200000                           227  ; D0 - used for simulator I/O
00200000                           228  ; D1 - used for simulator I/O
00200000                           229  ; D2 - read character
00200000                           230  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           231  ; D4 - count of S records read
00200000                           232  ; D5 - data to write / data read / byte count for S record load
00200000                           233  ; D6 - working register used in R/W and download
00200000                           234  ; D7 - address accumulator / reset by download
00200000                           235  ; A0 - address of string to print 
00200000                           236  
00200000                           237  ; start vector
00200000= 00000000                 238  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 239  RESET    DC.L START                             ; RESET
00200008                           240      
00200008                           241  ; start of program  
00200008                           242  START
00200008  13FC 0000 00E00001       243      MOVE.B #0,DISPLAY
00200010                           244  
00200010                           245  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       246      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       247      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     248      NOP
00200022  13FC 0040 00C00005       249      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     250      NOP
0020002C  13FC 0030 00C00005       251      MOVE.B #$30,DUART_CRA
00200034  4E71                     252      NOP
00200036  13FC 0020 00C00005       253      MOVE.B #$20,DUART_CRA
0020003E  4E71                     254      NOP
00200040  13FC 0010 00C00005       255      MOVE.B #$10,DUART_CRA   
00200048                           256  
00200048  13FC 000A 00C00015       257      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       258      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     259      NOP
0020005A  13FC 0040 00C00015       260      MOVE.B #$40,DUART_CRB           
00200062  4E71                     261      NOP
00200064  13FC 0030 00C00015       262      MOVE.B #$30,DUART_CRB
0020006C  4E71                     263      NOP
0020006E  13FC 0020 00C00015       264      MOVE.B #$20,DUART_CRB
00200076  4E71                     265      NOP
00200078  13FC 0010 00C00015       266      MOVE.B #$10,DUART_CRB   
00200080                           267  
00200080                           268  ;initialise UART
00200080  13FC 0000 00C00009       269      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       270      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       271      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           272  
00200098                           273  ; channel A
00200098  13FC 0013 00C00001       274      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       275      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       276      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       277      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           278  
002000B8                           279  ; channel B
002000B8  13FC 0013 00C00011       280      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       281      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       282      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       283      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           284  
002000D8                           285m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           286m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      287m     IFEQ DEBUG
002000D8  1639 00C00003            288m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                289m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     290m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       291m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           292m     ENDC
002000EC                           293m     
002000EC                 FALSE     294m     IFNE DEBUG
002000EC                           295m     ENDC
002000EC                           296m 
002000EC                           297m     ENDM
002000EC                           298  
002000EC  13FC 0001 00E00001       299      MOVE.B #1,DISPLAY
002000F4                           300         
002000F4                           301m     PRINT_CRLF D3
002000F4                           302mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           303mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      304mm     IFEQ DEBUG
002000F4  1639 00C00003            305mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                306mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     307mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       308mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           309mm     ENDC
00200108                           310mm     
00200108                 FALSE     311mm     IFNE DEBUG
00200108                           312mm     ENDC
00200108                           313mm 
00200108                           314mm     ENDM
00200108                           315mm     PRINT_CHAR #10,D3                           ; LF
00200108                           316mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      317mm     IFEQ DEBUG
00200108  1639 00C00003            318mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                319mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     320mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       321mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           322mm     ENDC
0020011C                           323mm     
0020011C                 FALSE     324mm     IFNE DEBUG
0020011C                           325mm     ENDC
0020011C                           326mm 
0020011C                           327mm     ENDM
0020011C                           328m     ENDM
0020011C                           329  
0020011C  41F9 002013C2            330      LEA VERSION,A0
00200122                           331m     PRINT_STR A0,D3
00200122                           332m LOOP_5
00200122  0C10 0000                333m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                334m     BEQ EXIT_5
0020012A                           335mm     PRINT_CHAR (A0)+,D3
0020012A                           336mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      337mm     IFEQ DEBUG
0020012A  1639 00C00003            338mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                339mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     340mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            341mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           342mm     ENDC
0020013C                           343mm     
0020013C                 FALSE     344mm     IFNE DEBUG
0020013C                           345mm     ENDC
0020013C                           346mm 
0020013C                           347mm     ENDM
0020013C  4EF9 00200122            348m     JMP LOOP_5
00200142                           349m EXIT_5
00200142                           350m     ENDM
00200142                           351m     PRINT_CRLF D3
00200142                           352mm     PRINT_CHAR #13,D3                           ; CR
00200142                           353mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      354mm     IFEQ DEBUG
00200142  1639 00C00003            355mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                356mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     357mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       358mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           359mm     ENDC
00200156                           360mm     
00200156                 FALSE     361mm     IFNE DEBUG
00200156                           362mm     ENDC
00200156                           363mm 
00200156                           364mm     ENDM
00200156                           365mm     PRINT_CHAR #10,D3                           ; LF
00200156                           366mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      367mm     IFEQ DEBUG
00200156  1639 00C00003            368mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                369mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     370mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       371mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           372mm     ENDC
0020016A                           373mm     
0020016A                 FALSE     374mm     IFNE DEBUG
0020016A                           375mm     ENDC
0020016A                           376mm 
0020016A                           377mm     ENDM
0020016A                           378m     ENDM
0020016A                           379m     PRINT_CHAR #7,D3
0020016A                           380m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      381m     IFEQ DEBUG
0020016A  1639 00C00003            382m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                383m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     384m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       385m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           386m     ENDC
0020017E                           387m     
0020017E                 FALSE     388m     IFNE DEBUG
0020017E                           389m     ENDC
0020017E                           390m 
0020017E                           391m     ENDM
0020017E                           392  
0020017E  7E00                     393      MOVE.L #0,D7                                ; address accumulator
00200180                           394  
00200180  13FC 0002 00E00001       395      MOVE.B #2,DISPLAY
00200188                           396  MAIN_LOOP
00200188                           397m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           398m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      399m     IFEQ DEBUG
00200188  1639 00C00003            400m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                401m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     402m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       403m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           404m     ENDC
0020019C                           405m     
0020019C                 FALSE     406m     IFNE DEBUG
0020019C                           407m     ENDC
0020019C                           408m 
0020019C                           409m     ENDM
0020019C                           410m     PRINT_CHAR #32,D3                           ; space
0020019C                           411m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      412m     IFEQ DEBUG
0020019C  1639 00C00003            413m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                414m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     415m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       416m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           417m     ENDC
002001B0                           418m     
002001B0                 FALSE     419m     IFNE DEBUG
002001B0                           420m     ENDC
002001B0                           421m 
002001B0                           422m     ENDM
002001B0                           423      
002001B0                           424  GET_INPUT
002001B0                           425m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           426m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           427m 
002001B0                 TRUE      428m     IFEQ DEBUG
002001B0  1639 00C00003            429m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                430m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     431m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           432m     ENDC
002001BC                           433m     
002001BC                           434mm     READ_CHAR D2
002001BC                 TRUE      435mm     IFEQ DEBUG
002001BC  1439 00C00007            436mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           437mm     ENDC
002001C2                 FALSE     438mm     IFNE DEBUG
002001C2                           439mm     ENDC
002001C2                           440mm      
002001C2  B43C 001B                441mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                442mm     BEQ START
002001CA                           443mm     ENDM
002001CA                           444m 
002001CA                 TRUE      445m     IFEQ DEBUG
002001CA                           446mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           447mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      448mm     IFEQ DEBUG
002001CA  1639 00C00003            449mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                450mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     451mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            452mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           453mm     ENDC
002001DC                           454mm     
002001DC                 FALSE     455mm     IFNE DEBUG
002001DC                           456mm     ENDC
002001DC                           457mm 
002001DC                           458mm     ENDM
002001DC                           459m     ENDC
002001DC                           460m     ENDM
002001DC                           461      
002001DC  B43C 0030                462      CMP.B #'0',D2
002001E0  6700 11BE                463      BEQ HEX_DIGIT
002001E4  B43C 0031                464      CMP.B #'1',D2
002001E8  6700 11B6                465      BEQ HEX_DIGIT
002001EC  B43C 0032                466      CMP.B #'2',D2
002001F0  6700 11AE                467      BEQ HEX_DIGIT
002001F4  B43C 0033                468      CMP.B #'3',D2
002001F8  6700 11A6                469      BEQ HEX_DIGIT
002001FC  B43C 0034                470      CMP.B #'4',D2
00200200  6700 119E                471      BEQ HEX_DIGIT
00200204  B43C 0035                472      CMP.B #'5',D2
00200208  6700 1196                473      BEQ HEX_DIGIT
0020020C  B43C 0036                474      CMP.B #'6',D2
00200210  6700 118E                475      BEQ HEX_DIGIT
00200214  B43C 0037                476      CMP.B #'7',D2
00200218  6700 1186                477      BEQ HEX_DIGIT
0020021C  B43C 0038                478      CMP.B #'8',D2
00200220  6700 117E                479      BEQ HEX_DIGIT
00200224  B43C 0039                480      CMP.B #'9',D2
00200228  6700 1176                481      BEQ HEX_DIGIT
0020022C  B43C 0041                482      CMP.B #'A',D2
00200230  6700 116E                483      BEQ HEX_DIGIT
00200234  B43C 0042                484      CMP.B #'B',D2
00200238  6700 1166                485      BEQ HEX_DIGIT
0020023C  B43C 0043                486      CMP.B #'C',D2
00200240  6700 115E                487      BEQ HEX_DIGIT
00200244  B43C 0044                488      CMP.B #'D',D2
00200248  6700 1156                489      BEQ HEX_DIGIT
0020024C  B43C 0045                490      CMP.B #'E',D2
00200250  6700 114E                491      BEQ HEX_DIGIT
00200254  B43C 0046                492      CMP.B #'F',D2
00200258  6700 1146                493      BEQ HEX_DIGIT
0020025C                           494      
0020025C  B43C 0057                495      CMP.B #'W',D2
00200260  6700 016E                496      BEQ W
00200264                           497      
00200264  B43C 004C                498      CMP.B #'L',D2
00200268  6700 0FC0                499      BEQ L 
0020026C                           500  
0020026C                           501m     PRINT_CRLF D3
0020026C                           502mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           503mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      504mm     IFEQ DEBUG
0020026C  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                506mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     507mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       508mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           509mm     ENDC
00200280                           510mm     
00200280                 FALSE     511mm     IFNE DEBUG
00200280                           512mm     ENDC
00200280                           513mm 
00200280                           514mm     ENDM
00200280                           515mm     PRINT_CHAR #10,D3                           ; LF
00200280                           516mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      517mm     IFEQ DEBUG
00200280  1639 00C00003            518mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                519mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     520mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       521mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           522mm     ENDC
00200294                           523mm     
00200294                 FALSE     524mm     IFNE DEBUG
00200294                           525mm     ENDC
00200294                           526mm 
00200294                           527mm     ENDM
00200294                           528m     ENDM
00200294                           529   
00200294  B43C 003F                530      CMP.B #'?',D2
00200298  6700 0056                531      BEQ H
0020029C                           532  
0020029C  B43C 0056                533      CMP.B #'V',D2
002002A0  6700 007A                534      BEQ V
002002A4                           535      
002002A4  B43C 0052                536      CMP.B #'R',D2
002002A8  6700 009E                537      BEQ R
002002AC                           538  
002002AC  B43C 0053                539      CMP.B #'S',D2
002002B0  6700 01E6                540      BEQ S
002002B4                           541  
002002B4  B43C 0047                542      CMP.B #'G',D2
002002B8  6700 0E5C                543      BEQ G   
002002BC                           544  
002002BC  B43C 005A                545      CMP.B #'Z',D2
002002C0  6700 0E5C                546      BEQ Z   
002002C4                           547  
002002C4  41F9 00201476            548      LEA HUH,A0
002002CA                           549m     PRINT_STR A0,D3
002002CA                           550m LOOP_19
002002CA  0C10 0000                551m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                552m     BEQ EXIT_19
002002D2                           553mm     PRINT_CHAR (A0)+,D3
002002D2                           554mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      555mm     IFEQ DEBUG
002002D2  1639 00C00003            556mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                557mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     558mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            559mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           560mm     ENDC
002002E4                           561mm     
002002E4                 FALSE     562mm     IFNE DEBUG
002002E4                           563mm     ENDC
002002E4                           564mm 
002002E4                           565mm     ENDM
002002E4  4EF9 002002CA            566m     JMP LOOP_19
002002EA                           567m EXIT_19
002002EA                           568m     ENDM
002002EA                           569                         
002002EA  4EF9 00200188            570      JMP MAIN_LOOP
002002F0                           571      
002002F0                           572  ; commands
002002F0                           573  H   
002002F0  41F9 002013DF            574      LEA HELP,A0
002002F6                           575m     PRINT_STR A0,D3
002002F6                           576m LOOP_21
002002F6  0C10 0000                577m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                578m     BEQ EXIT_21
002002FE                           579mm     PRINT_CHAR (A0)+,D3
002002FE                           580mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      581mm     IFEQ DEBUG
002002FE  1639 00C00003            582mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                583mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     584mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            585mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           586mm     ENDC
00200310                           587mm     
00200310                 FALSE     588mm     IFNE DEBUG
00200310                           589mm     ENDC
00200310                           590mm 
00200310                           591mm     ENDM
00200310  4EF9 002002F6            592m     JMP LOOP_21
00200316                           593m EXIT_21
00200316                           594m     ENDM
00200316  4EF9 00200188            595      JMP MAIN_LOOP
0020031C                           596  
0020031C                           597  V   
0020031C  41F9 002013C2            598      LEA VERSION,A0
00200322                           599m     PRINT_STR A0,D3       
00200322                           600m LOOP_23
00200322  0C10 0000                601m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                602m     BEQ EXIT_23
0020032A                           603mm     PRINT_CHAR (A0)+,D3
0020032A                           604mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      605mm     IFEQ DEBUG
0020032A  1639 00C00003            606mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                607mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     608mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            609mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           610mm     ENDC
0020033C                           611mm     
0020033C                 FALSE     612mm     IFNE DEBUG
0020033C                           613mm     ENDC
0020033C                           614mm 
0020033C                           615mm     ENDM
0020033C  4EF9 00200322            616m     JMP LOOP_23
00200342                           617m EXIT_23
00200342                           618m     ENDM
00200342  4EF9 00200188            619      JMP MAIN_LOOP
00200348                           620      
00200348                           621  R   
00200348  2047                     622      MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     623      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           624m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           625mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           626mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      627mm     IFEQ DEBUG
0020034C  1639 00C00003            628mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                629mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     630mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       631mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           632mm     ENDC
00200360                           633mm     
00200360                 FALSE     634mm     IFNE DEBUG
00200360                           635mm     ENDC
00200360                           636mm 
00200360                           637mm     ENDM
00200360                           638mm     PRINT_CHAR #'x',D3
00200360                           639mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      640mm     IFEQ DEBUG
00200360  1639 00C00003            641mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                642mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     643mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       644mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           645mm     ENDC
00200374                           646mm     
00200374                 FALSE     647mm     IFNE DEBUG
00200374                           648mm     ENDC
00200374                           649mm 
00200374                           650mm     ENDM
00200374  7C07                     651m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           652m LOOP_25
00200376                           653mm     BIN2HEX D5,D7,A0
00200376  41F9 002014DA            654mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     655mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     656mm     MOVE.B D5,D7
00200380  0287 0000000F            657mm     ANDI.L #$F,D7
00200386  1E30 7000                658mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           659mm     ENDM
0020038A                           660mm     PRINT_CHAR D7,D3
0020038A                           661mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      662mm     IFEQ DEBUG
0020038A  1639 00C00003            663mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                664mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     665mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            666mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           667mm     ENDC
0020039C                           668mm     
0020039C                 FALSE     669mm     IFNE DEBUG
0020039C                           670mm     ENDC
0020039C                           671mm 
0020039C                           672mm     ENDM
0020039C  57CE FFD8                673m     DBEQ D6,LOOP_25
002003A0                           674m     ENDM
002003A0                           675m     PRINT_CRLF D3
002003A0                           676mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           677mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      678mm     IFEQ DEBUG
002003A0  1639 00C00003            679mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                680mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     681mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       682mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           683mm     ENDC
002003B4                           684mm     
002003B4                 FALSE     685mm     IFNE DEBUG
002003B4                           686mm     ENDC
002003B4                           687mm 
002003B4                           688mm     ENDM
002003B4                           689mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           690mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      691mm     IFEQ DEBUG
002003B4  1639 00C00003            692mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                693mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     694mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       695mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           696mm     ENDC
002003C8                           697mm     
002003C8                 FALSE     698mm     IFNE DEBUG
002003C8                           699mm     ENDC
002003C8                           700mm 
002003C8                           701mm     ENDM
002003C8                           702m     ENDM
002003C8  7E00                     703      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            704      JMP MAIN_LOOP
002003D0                           705  
002003D0                           706  W
002003D0  7A00                     707      MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           708  
002003D2                           709m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           710m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           711m 
002003D2                 TRUE      712m     IFEQ DEBUG
002003D2  1639 00C00003            713m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                714m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     715m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           716m     ENDC
002003DE                           717m     
002003DE                           718mm     READ_CHAR D2
002003DE                 TRUE      719mm     IFEQ DEBUG
002003DE  1439 00C00007            720mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           721mm     ENDC
002003E4                 FALSE     722mm     IFNE DEBUG
002003E4                           723mm     ENDC
002003E4                           724mm      
002003E4  B43C 001B                725mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                726mm     BEQ START
002003EC                           727mm     ENDM
002003EC                           728m 
002003EC                 TRUE      729m     IFEQ DEBUG
002003EC                           730mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           731mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      732mm     IFEQ DEBUG
002003EC  1639 00C00003            733mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                734mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     735mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            736mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           737mm     ENDC
002003FE                           738mm     
002003FE                 FALSE     739mm     IFNE DEBUG
002003FE                           740mm     ENDC
002003FE                           741mm 
002003FE                           742mm     ENDM
002003FE                           743m     ENDC
002003FE                           744m     ENDM
002003FE                           745m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 002014EA            746m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                747m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            748m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                749m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           750m     ENDM
00200412  1A02                     751      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           752  
00200414  3C3C 0006                753      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           754      
00200418                           755  READ_DATA_TO_POKE
00200418  E98D                     756      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           757m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           758m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           759m 
0020041A                 TRUE      760m     IFEQ DEBUG
0020041A  1639 00C00003            761m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                762m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     763m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           764m     ENDC
00200426                           765m     
00200426                           766mm     READ_CHAR D2
00200426                 TRUE      767mm     IFEQ DEBUG
00200426  1439 00C00007            768mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           769mm     ENDC
0020042C                 FALSE     770mm     IFNE DEBUG
0020042C                           771mm     ENDC
0020042C                           772mm      
0020042C  B43C 001B                773mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                774mm     BEQ START
00200434                           775mm     ENDM
00200434                           776m 
00200434                 TRUE      777m     IFEQ DEBUG
00200434                           778mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           779mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      780mm     IFEQ DEBUG
00200434  1639 00C00003            781mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                782mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     783mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            784mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           785mm     ENDC
00200446                           786mm     
00200446                 FALSE     787mm     IFNE DEBUG
00200446                           788mm     ENDC
00200446                           789mm 
00200446                           790mm     ENDM
00200446                           791m     ENDC
00200446                           792m     ENDM
00200446                           793m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 002014EA            794m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                795m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            796m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                797m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           798m     ENDM
0020045A  8A02                     799      OR.B D2,D5
0020045C  023C 00FB                800      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                801      DBEQ D6,READ_DATA_TO_POKE
00200464                           802      
00200464  2047                     803      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     804      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           805      
00200468  2085                     806      MOVE.L D5,(A0)                              ; write the data
0020046A                           807  
0020046A                           808m     PRINT_CRLF D3
0020046A                           809mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           810mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      811mm     IFEQ DEBUG
0020046A  1639 00C00003            812mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                813mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     814mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       815mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           816mm     ENDC
0020047E                           817mm     
0020047E                 FALSE     818mm     IFNE DEBUG
0020047E                           819mm     ENDC
0020047E                           820mm 
0020047E                           821mm     ENDM
0020047E                           822mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           823mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      824mm     IFEQ DEBUG
0020047E  1639 00C00003            825mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                826mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     827mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       828mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           829mm     ENDC
00200492                           830mm     
00200492                 FALSE     831mm     IFNE DEBUG
00200492                           832mm     ENDC
00200492                           833mm 
00200492                           834mm     ENDM
00200492                           835m     ENDM
00200492  4EF9 00200188            836      JMP MAIN_LOOP
00200498                           837  
00200498                           838          
00200498                           839  S
00200498  2647                     840      MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     841      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                842      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           843      
002004A0                           844  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           845m     DOWNLOAD D2                 
002004A0                           846m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           847m 
002004A0  1439 00C00003            848m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002004A6  0802 0000                849m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                850m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           851m  
002004AE                           852mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002004AE                 TRUE      853mm     IFEQ DEBUG
002004AE  1439 00C00007            854mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           855mm     ENDC
002004B4                 FALSE     856mm     IFNE DEBUG
002004B4                           857mm     ENDC
002004B4                           858mm      
002004B4  B43C 001B                859mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                860mm     BEQ START
002004BC                           861mm     ENDM
002004BC                           862m CONTINUE_44
002004BC  1439 00C00013            863m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002004C2  0802 0000                864m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004C6  67D8                     865m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           866m     
002004C8  1439 00C00017            867m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            868m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           869m     
002004D4                           870m     ENDM
002004D4  B43C 0053                871      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     872      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           873      
002004DA                           874m     PRINT_CHAR #'S',D3                            ; print it
002004DA                           875m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      876m     IFEQ DEBUG
002004DA  1639 00C00003            877m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002004E0  0803 0002                878m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     879m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004E6  13FC 0053 00C00007       880m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004EE                           881m     ENDC
002004EE                           882m     
002004EE                 FALSE     883m     IFNE DEBUG
002004EE                           884m     ENDC
002004EE                           885m 
002004EE                           886m     ENDM
002004EE  5284                     887      ADD.L #1,D4                                 ; read another S record, increment count
002004F0                           888      
002004F0                           889m     DOWNLOAD D7                                 ; read the record identifier
002004F0                           890m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004F0                           891m 
002004F0  1E39 00C00003            892m     MOVE.B DUART_SRA,D7                         ; CHECK FOR COMMAND
002004F6  0807 0000                893m     BTST #0,D7                                  ; CHECK FOR CHARACTER
002004FA  6700 0010                894m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004FE                           895m  
002004FE                           896mm     READ_CHAR D7                                ; WE're not going to do anything with it, just check for escape
002004FE                 TRUE      897mm     IFEQ DEBUG
002004FE  1E39 00C00007            898mm         MOVE.B DUART_RXA,D7                     ; GOT A CHARACTER, READ IT
00200504                           899mm     ENDC
00200504                 FALSE     900mm     IFNE DEBUG
00200504                           901mm     ENDC
00200504                           902mm      
00200504  BE3C 001B                903mm     CMP.B #$1B,D7                               ; CHECK FOR ESCAPE AND GO TO START
00200508  6700 FAFE                904mm     BEQ START
0020050C                           905mm     ENDM
0020050C                           906m CONTINUE_47
0020050C  1E39 00C00013            907m     MOVE.B DUART_SRB,D7                         ; READ DOWNLOAD STATUS REGISTER
00200512  0807 0000                908m     BTST #0,D7                                  ; CHECK FOR CHARACTER
00200516  67D8                     909m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00200518                           910m     
00200518  1E39 00C00017            911m     MOVE.B DUART_RXB,D7                         ; GOT A CHARACTER, READ IT
0020051E  13C7 00E00001            912m     MOVE.B D7,DISPLAY                           ; ECHO TO THE DISPLAY
00200524                           913m     
00200524                           914m     ENDM
00200524                           915m     PRINT_CHAR D7,D3                            ; print it
00200524                           916m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200524                 TRUE      917m     IFEQ DEBUG
00200524  1639 00C00003            918m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020052A  0803 0002                919m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020052E  67F4                     920m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200530  13C7 00C00007            921m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200536                           922m     ENDC
00200536                           923m     
00200536                 FALSE     924m     IFNE DEBUG
00200536                           925m     ENDC
00200536                           926m 
00200536                           927m     ENDM
00200536                           928  
00200536  7C00                     929      MOVE.L #0,D6                                ; clear the checksum
00200538                           930  
00200538  7A00                     931      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
0020053A                           932m     DOWNLOAD_BYTE D2,D5,D3,A0                               
0020053A                           933mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
0020053A                           934mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020053A                           935mm 
0020053A  1439 00C00003            936mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200540  0802 0000                937mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200544  6700 0010                938mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
00200548                           939mm  
00200548                           940mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200548                 TRUE      941mmm     IFEQ DEBUG
00200548  1439 00C00007            942mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020054E                           943mmm     ENDC
0020054E                 FALSE     944mmm     IFNE DEBUG
0020054E                           945mmm     ENDC
0020054E                           946mmm      
0020054E  B43C 001B                947mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200552  6700 FAB4                948mmm     BEQ START
00200556                           949mmm     ENDM
00200556                           950mm CONTINUE_51
00200556  1439 00C00013            951mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020055C  0802 0000                952mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200560  67D8                     953mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200562                           954mm     
00200562  1439 00C00017            955mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200568  13C2 00E00001            956mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020056E                           957mm     
0020056E                           958mm     ENDM
0020056E                           959mm     PRINT_CHAR D2,D3
0020056E                           960mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020056E                 TRUE      961mm     IFEQ DEBUG
0020056E  1639 00C00003            962mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200574  0803 0002                963mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200578  67F4                     964mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0020057A  13C2 00C00007            965mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200580                           966mm     ENDC
00200580                           967mm     
00200580                 FALSE     968mm     IFNE DEBUG
00200580                           969mm     ENDC
00200580                           970mm 
00200580                           971mm     ENDM
00200580                           972mm     HEX2BIN D2,D2,A0
00200580  41F9 002014EA            973mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200586  0402 0030                974mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020058A  C4BC 000000FF            975mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200590  1430 2000                976mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200594                           977mm     ENDM
00200594  8A02                     978m     OR.B D2,D5
00200596  E98D                     979m     LSL.L #4,D5
00200598                           980m         
00200598                           981mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200598                           982mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200598                           983mm 
00200598  1439 00C00003            984mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020059E  0802 0000                985mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002005A2  6700 0010                986mm     BEQ CONTINUE_55                             ; NOTHING, CONTINUE
002005A6                           987mm  
002005A6                           988mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002005A6                 TRUE      989mmm     IFEQ DEBUG
002005A6  1439 00C00007            990mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002005AC                           991mmm     ENDC
002005AC                 FALSE     992mmm     IFNE DEBUG
002005AC                           993mmm     ENDC
002005AC                           994mmm      
002005AC  B43C 001B                995mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002005B0  6700 FA56                996mmm     BEQ START
002005B4                           997mmm     ENDM
002005B4                           998mm CONTINUE_55
002005B4  1439 00C00013            999mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002005BA  0802 0000               1000mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002005BE  67D8                    1001mm     BEQ WAIT_FOR_READY_55                       ; NOTHING, CHECK AGAIN
002005C0                          1002mm     
002005C0  1439 00C00017           1003mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002005C6  13C2 00E00001           1004mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002005CC                          1005mm     
002005CC                          1006mm     ENDM
002005CC                          1007mm     PRINT_CHAR D2,D3
002005CC                          1008mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005CC                 TRUE     1009mm     IFEQ DEBUG
002005CC  1639 00C00003           1010mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005D2  0803 0002               1011mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005D6  67F4                    1012mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005D8  13C2 00C00007           1013mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002005DE                          1014mm     ENDC
002005DE                          1015mm     
002005DE                 FALSE    1016mm     IFNE DEBUG
002005DE                          1017mm     ENDC
002005DE                          1018mm 
002005DE                          1019mm     ENDM
002005DE                          1020mm     HEX2BIN D2,D2,A0
002005DE  41F9 002014EA           1021mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002005E4  0402 0030               1022mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005E8  C4BC 000000FF           1023mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005EE  1430 2000               1024mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005F2                          1025mm     ENDM
002005F2  8A02                    1026m     OR.B D2,D5    
002005F4                          1027m     ENDM
002005F4  DC85                    1028      ADD.L D5,D6                                 ; add to checksum
002005F6                          1029  
002005F6                          1030      IF.B D7 <EQ> #'0' THEN.L                    ; header, just ignore it
002005F6  BE3C 0030               1031s     CMP.B   #'0',D7
002005FA  6600 000A               1032s     BNE.L   _00000000
002005FE  6000 FEA0               1033          BRA WAIT_FOR_SRECORD
00200602                          1034      ELSE
00200602  6000 0878               1035s     BRA _00000001
00200606                          1036s _00000000
00200606                          1037          IF.B D7 <EQ> #'1' THEN.L                ; 16 bit address data record
00200606  BE3C 0031               1038s     CMP.B   #'1',D7
0020060A  6600 028A               1039s     BNE.L   _00000002
0020060E  7E00                    1040              MOVE.L #0,D7                        ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200610                          1041m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte                           
00200610                          1042mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200610                          1043mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200610                          1044mm 
00200610  1439 00C00003           1045mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200616  0802 0000               1046mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020061A  6700 0010               1047mm     BEQ CONTINUE_60                             ; NOTHING, CONTINUE
0020061E                          1048mm  
0020061E                          1049mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020061E                 TRUE     1050mmm     IFEQ DEBUG
0020061E  1439 00C00007           1051mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200624                          1052mmm     ENDC
00200624                 FALSE    1053mmm     IFNE DEBUG
00200624                          1054mmm     ENDC
00200624                          1055mmm      
00200624  B43C 001B               1056mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200628  6700 F9DE               1057mmm     BEQ START
0020062C                          1058mmm     ENDM
0020062C                          1059mm CONTINUE_60
0020062C  1439 00C00013           1060mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200632  0802 0000               1061mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200636  67D8                    1062mm     BEQ WAIT_FOR_READY_60                       ; NOTHING, CHECK AGAIN
00200638                          1063mm     
00200638  1439 00C00017           1064mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020063E  13C2 00E00001           1065mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200644                          1066mm     
00200644                          1067mm     ENDM
00200644                          1068mm     PRINT_CHAR D2,D3
00200644                          1069mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200644                 TRUE     1070mm     IFEQ DEBUG
00200644  1639 00C00003           1071mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020064A  0803 0002               1072mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020064E  67F4                    1073mm         BEQ WAIT_FOR_READY_62                   ; NO SPACE, CHECK AGAIN
00200650  13C2 00C00007           1074mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200656                          1075mm     ENDC
00200656                          1076mm     
00200656                 FALSE    1077mm     IFNE DEBUG
00200656                          1078mm     ENDC
00200656                          1079mm 
00200656                          1080mm     ENDM
00200656                          1081mm     HEX2BIN D2,D2,A0
00200656  41F9 002014EA           1082mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020065C  0402 0030               1083mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200660  C4BC 000000FF           1084mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200666  1430 2000               1085mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020066A                          1086mm     ENDM
0020066A  8E02                    1087m     OR.B D2,D7
0020066C  E98F                    1088m     LSL.L #4,D7
0020066E                          1089m         
0020066E                          1090mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
0020066E                          1091mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020066E                          1092mm 
0020066E  1439 00C00003           1093mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200674  0802 0000               1094mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200678  6700 0010               1095mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0020067C                          1096mm  
0020067C                          1097mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020067C                 TRUE     1098mmm     IFEQ DEBUG
0020067C  1439 00C00007           1099mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200682                          1100mmm     ENDC
00200682                 FALSE    1101mmm     IFNE DEBUG
00200682                          1102mmm     ENDC
00200682                          1103mmm      
00200682  B43C 001B               1104mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200686  6700 F980               1105mmm     BEQ START
0020068A                          1106mmm     ENDM
0020068A                          1107mm CONTINUE_64
0020068A  1439 00C00013           1108mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200690  0802 0000               1109mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200694  67D8                    1110mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00200696                          1111mm     
00200696  1439 00C00017           1112mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020069C  13C2 00E00001           1113mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006A2                          1114mm     
002006A2                          1115mm     ENDM
002006A2                          1116mm     PRINT_CHAR D2,D3
002006A2                          1117mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006A2                 TRUE     1118mm     IFEQ DEBUG
002006A2  1639 00C00003           1119mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002006A8  0803 0002               1120mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002006AC  67F4                    1121mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006AE  13C2 00C00007           1122mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006B4                          1123mm     ENDC
002006B4                          1124mm     
002006B4                 FALSE    1125mm     IFNE DEBUG
002006B4                          1126mm     ENDC
002006B4                          1127mm 
002006B4                          1128mm     ENDM
002006B4                          1129mm     HEX2BIN D2,D2,A0
002006B4  41F9 002014EA           1130mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006BA  0402 0030               1131mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006BE  C4BC 000000FF           1132mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006C4  1430 2000               1133mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006C8                          1134mm     ENDM
002006C8  8E02                    1135m     OR.B D2,D7    
002006CA                          1136m     ENDM
002006CA  DC87                    1137              ADD.L D7,D6                         ; add into checksum
002006CC                          1138  
002006CC  E98F                    1139              LSL.L #4,D7                         ; bottom byte
002006CE                          1140m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte       
002006CE                          1141mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002006CE                          1142mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006CE                          1143mm 
002006CE  1439 00C00003           1144mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002006D4  0802 0000               1145mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002006D8  6700 0010               1146mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
002006DC                          1147mm  
002006DC                          1148mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002006DC                 TRUE     1149mmm     IFEQ DEBUG
002006DC  1439 00C00007           1150mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002006E2                          1151mmm     ENDC
002006E2                 FALSE    1152mmm     IFNE DEBUG
002006E2                          1153mmm     ENDC
002006E2                          1154mmm      
002006E2  B43C 001B               1155mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002006E6  6700 F920               1156mmm     BEQ START
002006EA                          1157mmm     ENDM
002006EA                          1158mm CONTINUE_69
002006EA  1439 00C00013           1159mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002006F0  0802 0000               1160mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002006F4  67D8                    1161mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
002006F6                          1162mm     
002006F6  1439 00C00017           1163mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006FC  13C2 00E00001           1164mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200702                          1165mm     
00200702                          1166mm     ENDM
00200702                          1167mm     PRINT_CHAR D2,D3
00200702                          1168mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200702                 TRUE     1169mm     IFEQ DEBUG
00200702  1639 00C00003           1170mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200708  0803 0002               1171mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020070C  67F4                    1172mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0020070E  13C2 00C00007           1173mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200714                          1174mm     ENDC
00200714                          1175mm     
00200714                 FALSE    1176mm     IFNE DEBUG
00200714                          1177mm     ENDC
00200714                          1178mm 
00200714                          1179mm     ENDM
00200714                          1180mm     HEX2BIN D2,D2,A0
00200714  41F9 002014EA           1181mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020071A  0402 0030               1182mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020071E  C4BC 000000FF           1183mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200724  1430 2000               1184mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200728                          1185mm     ENDM
00200728  8E02                    1186m     OR.B D2,D7
0020072A  E98F                    1187m     LSL.L #4,D7
0020072C                          1188m         
0020072C                          1189mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
0020072C                          1190mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020072C                          1191mm 
0020072C  1439 00C00003           1192mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200732  0802 0000               1193mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200736  6700 0010               1194mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
0020073A                          1195mm  
0020073A                          1196mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020073A                 TRUE     1197mmm     IFEQ DEBUG
0020073A  1439 00C00007           1198mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200740                          1199mmm     ENDC
00200740                 FALSE    1200mmm     IFNE DEBUG
00200740                          1201mmm     ENDC
00200740                          1202mmm      
00200740  B43C 001B               1203mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200744  6700 F8C2               1204mmm     BEQ START
00200748                          1205mmm     ENDM
00200748                          1206mm CONTINUE_73
00200748  1439 00C00013           1207mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020074E  0802 0000               1208mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200752  67D8                    1209mm     BEQ WAIT_FOR_READY_73                       ; NOTHING, CHECK AGAIN
00200754                          1210mm     
00200754  1439 00C00017           1211mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020075A  13C2 00E00001           1212mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200760                          1213mm     
00200760                          1214mm     ENDM
00200760                          1215mm     PRINT_CHAR D2,D3
00200760                          1216mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200760                 TRUE     1217mm     IFEQ DEBUG
00200760  1639 00C00003           1218mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200766  0803 0002               1219mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020076A  67F4                    1220mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
0020076C  13C2 00C00007           1221mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200772                          1222mm     ENDC
00200772                          1223mm     
00200772                 FALSE    1224mm     IFNE DEBUG
00200772                          1225mm     ENDC
00200772                          1226mm 
00200772                          1227mm     ENDM
00200772                          1228mm     HEX2BIN D2,D2,A0
00200772  41F9 002014EA           1229mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200778  0402 0030               1230mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020077C  C4BC 000000FF           1231mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200782  1430 2000               1232mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200786                          1233mm     ENDM
00200786  8E02                    1234m     OR.B D2,D7    
00200788                          1235m     ENDM
00200788  7400                    1236              MOVE.L #0,D2                        ; rextract bottom byte of address and add into checksum
0020078A  1407                    1237              MOVE.B D7,D2
0020078C  DC82                    1238              ADD.L D2,D6
0020078E                          1239          
0020078E  2247                    1240              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00200790  D3CB                    1241              ADD.L A3,A1                         ; add in the offset
00200792                          1242          
00200792  5785                    1243              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
00200794                          1244          
00200794                          1245              WHILE.L D5 <GT> #0 DO               ; read the data bytes
00200794                          1246s _10000000
00200794  BABC 00000000           1247s     CMP.L   #0,D5
0020079A  6F00 00C8               1248s     BLE _10000001
0020079E  7E00                    1249                  MOVE.L #0,D7                    ; D7 holds the byte
002007A0                          1250m                 DOWNLOAD_BYTE D2,D7,D3,A0       ; read it                               
002007A0                          1251mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002007A0                          1252mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007A0                          1253mm 
002007A0  1439 00C00003           1254mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002007A6  0802 0000               1255mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002007AA  6700 0010               1256mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
002007AE                          1257mm  
002007AE                          1258mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002007AE                 TRUE     1259mmm     IFEQ DEBUG
002007AE  1439 00C00007           1260mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002007B4                          1261mmm     ENDC
002007B4                 FALSE    1262mmm     IFNE DEBUG
002007B4                          1263mmm     ENDC
002007B4                          1264mmm      
002007B4  B43C 001B               1265mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002007B8  6700 F84E               1266mmm     BEQ START
002007BC                          1267mmm     ENDM
002007BC                          1268mm CONTINUE_78
002007BC  1439 00C00013           1269mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002007C2  0802 0000               1270mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002007C6  67D8                    1271mm     BEQ WAIT_FOR_READY_78                       ; NOTHING, CHECK AGAIN
002007C8                          1272mm     
002007C8  1439 00C00017           1273mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002007CE  13C2 00E00001           1274mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002007D4                          1275mm     
002007D4                          1276mm     ENDM
002007D4                          1277mm     PRINT_CHAR D2,D3
002007D4                          1278mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007D4                 TRUE     1279mm     IFEQ DEBUG
002007D4  1639 00C00003           1280mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007DA  0803 0002               1281mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007DE  67F4                    1282mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
002007E0  13C2 00C00007           1283mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007E6                          1284mm     ENDC
002007E6                          1285mm     
002007E6                 FALSE    1286mm     IFNE DEBUG
002007E6                          1287mm     ENDC
002007E6                          1288mm 
002007E6                          1289mm     ENDM
002007E6                          1290mm     HEX2BIN D2,D2,A0
002007E6  41F9 002014EA           1291mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002007EC  0402 0030               1292mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007F0  C4BC 000000FF           1293mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002007F6  1430 2000               1294mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002007FA                          1295mm     ENDM
002007FA  8E02                    1296m     OR.B D2,D7
002007FC  E98F                    1297m     LSL.L #4,D7
002007FE                          1298m         
002007FE                          1299mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002007FE                          1300mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007FE                          1301mm 
002007FE  1439 00C00003           1302mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200804  0802 0000               1303mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200808  6700 0010               1304mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
0020080C                          1305mm  
0020080C                          1306mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020080C                 TRUE     1307mmm     IFEQ DEBUG
0020080C  1439 00C00007           1308mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200812                          1309mmm     ENDC
00200812                 FALSE    1310mmm     IFNE DEBUG
00200812                          1311mmm     ENDC
00200812                          1312mmm      
00200812  B43C 001B               1313mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200816  6700 F7F0               1314mmm     BEQ START
0020081A                          1315mmm     ENDM
0020081A                          1316mm CONTINUE_82
0020081A  1439 00C00013           1317mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200820  0802 0000               1318mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200824  67D8                    1319mm     BEQ WAIT_FOR_READY_82                       ; NOTHING, CHECK AGAIN
00200826                          1320mm     
00200826  1439 00C00017           1321mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020082C  13C2 00E00001           1322mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200832                          1323mm     
00200832                          1324mm     ENDM
00200832                          1325mm     PRINT_CHAR D2,D3
00200832                          1326mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200832                 TRUE     1327mm     IFEQ DEBUG
00200832  1639 00C00003           1328mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200838  0803 0002               1329mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020083C  67F4                    1330mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
0020083E  13C2 00C00007           1331mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200844                          1332mm     ENDC
00200844                          1333mm     
00200844                 FALSE    1334mm     IFNE DEBUG
00200844                          1335mm     ENDC
00200844                          1336mm 
00200844                          1337mm     ENDM
00200844                          1338mm     HEX2BIN D2,D2,A0
00200844  41F9 002014EA           1339mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020084A  0402 0030               1340mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020084E  C4BC 000000FF           1341mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200854  1430 2000               1342mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200858                          1343mm     ENDM
00200858  8E02                    1344m     OR.B D2,D7    
0020085A                          1345m     ENDM
0020085A  DC87                    1346                  ADD.L D7,D6                     ; add into checksum
0020085C                          1347                          
0020085C  12C7                    1348                  MOVE.B D7,(A1)+                 ; store it!
0020085E                          1349  
0020085E  5385                    1350                  SUB.L #1,D5                     ; 1 less byte to go
00200860                          1351              ENDW
00200860  6000 FF32               1352s     BRA _10000000
00200864                          1353s _10000001
00200864                          1354          
00200864                          1355m             PRINT_CRLF D3
00200864                          1356mm     PRINT_CHAR #13,D3                           ; CR
00200864                          1357mm WAIT_FOR_READY_87                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200864                 TRUE     1358mm     IFEQ DEBUG
00200864  1639 00C00003           1359mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020086A  0803 0002               1360mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020086E  67F4                    1361mm         BEQ WAIT_FOR_READY_87                   ; NO SPACE, CHECK AGAIN
00200870  13FC 000D 00C00007      1362mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200878                          1363mm     ENDC
00200878                          1364mm     
00200878                 FALSE    1365mm     IFNE DEBUG
00200878                          1366mm     ENDC
00200878                          1367mm 
00200878                          1368mm     ENDM
00200878                          1369mm     PRINT_CHAR #10,D3                           ; LF
00200878                          1370mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1371mm     IFEQ DEBUG
00200878  1639 00C00003           1372mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020087E  0803 0002               1373mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200882  67F4                    1374mm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00200884  13FC 000A 00C00007      1375mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020088C                          1376mm     ENDC
0020088C                          1377mm     
0020088C                 FALSE    1378mm     IFNE DEBUG
0020088C                          1379mm     ENDC
0020088C                          1380mm 
0020088C                          1381mm     ENDM
0020088C                          1382m     ENDM
0020088C  43F9 002004A0           1383              LEA WAIT_FOR_SRECORD,A1             ; next place to go
00200892                          1384        ELSE
00200892  6000 05E8               1385s     BRA _00000003
00200896                          1386s _00000002
00200896                          1387              IF.B D7 <EQ> #'2' THEN.L            ; 24 bit address data record
00200896  BE3C 0032               1388s     CMP.B   #'2',D7
0020089A  6600 0324               1389s     BNE.L   _00000004
0020089E  7E00                    1390                  MOVE.L #0,D7                    ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002008A0                          1391m                 DOWNLOAD_BYTE D2,D7,D3,A0               
002008A0                          1392mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002008A0                          1393mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A0                          1394mm 
002008A0  1439 00C00003           1395mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002008A6  0802 0000               1396mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008AA  6700 0010               1397mm     BEQ CONTINUE_90                             ; NOTHING, CONTINUE
002008AE                          1398mm  
002008AE                          1399mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002008AE                 TRUE     1400mmm     IFEQ DEBUG
002008AE  1439 00C00007           1401mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008B4                          1402mmm     ENDC
002008B4                 FALSE    1403mmm     IFNE DEBUG
002008B4                          1404mmm     ENDC
002008B4                          1405mmm      
002008B4  B43C 001B               1406mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002008B8  6700 F74E               1407mmm     BEQ START
002008BC                          1408mmm     ENDM
002008BC                          1409mm CONTINUE_90
002008BC  1439 00C00013           1410mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002008C2  0802 0000               1411mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008C6  67D8                    1412mm     BEQ WAIT_FOR_READY_90                       ; NOTHING, CHECK AGAIN
002008C8                          1413mm     
002008C8  1439 00C00017           1414mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008CE  13C2 00E00001           1415mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008D4                          1416mm     
002008D4                          1417mm     ENDM
002008D4                          1418mm     PRINT_CHAR D2,D3
002008D4                          1419mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D4                 TRUE     1420mm     IFEQ DEBUG
002008D4  1639 00C00003           1421mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008DA  0803 0002               1422mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008DE  67F4                    1423mm         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
002008E0  13C2 00C00007           1424mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008E6                          1425mm     ENDC
002008E6                          1426mm     
002008E6                 FALSE    1427mm     IFNE DEBUG
002008E6                          1428mm     ENDC
002008E6                          1429mm 
002008E6                          1430mm     ENDM
002008E6                          1431mm     HEX2BIN D2,D2,A0
002008E6  41F9 002014EA           1432mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008EC  0402 0030               1433mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F0  C4BC 000000FF           1434mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008F6  1430 2000               1435mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008FA                          1436mm     ENDM
002008FA  8E02                    1437m     OR.B D2,D7
002008FC  E98F                    1438m     LSL.L #4,D7
002008FE                          1439m         
002008FE                          1440mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002008FE                          1441mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008FE                          1442mm 
002008FE  1439 00C00003           1443mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200904  0802 0000               1444mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200908  6700 0010               1445mm     BEQ CONTINUE_94                             ; NOTHING, CONTINUE
0020090C                          1446mm  
0020090C                          1447mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020090C                 TRUE     1448mmm     IFEQ DEBUG
0020090C  1439 00C00007           1449mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200912                          1450mmm     ENDC
00200912                 FALSE    1451mmm     IFNE DEBUG
00200912                          1452mmm     ENDC
00200912                          1453mmm      
00200912  B43C 001B               1454mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200916  6700 F6F0               1455mmm     BEQ START
0020091A                          1456mmm     ENDM
0020091A                          1457mm CONTINUE_94
0020091A  1439 00C00013           1458mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200920  0802 0000               1459mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200924  67D8                    1460mm     BEQ WAIT_FOR_READY_94                       ; NOTHING, CHECK AGAIN
00200926                          1461mm     
00200926  1439 00C00017           1462mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020092C  13C2 00E00001           1463mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200932                          1464mm     
00200932                          1465mm     ENDM
00200932                          1466mm     PRINT_CHAR D2,D3
00200932                          1467mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200932                 TRUE     1468mm     IFEQ DEBUG
00200932  1639 00C00003           1469mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200938  0803 0002               1470mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020093C  67F4                    1471mm         BEQ WAIT_FOR_READY_96                   ; NO SPACE, CHECK AGAIN
0020093E  13C2 00C00007           1472mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200944                          1473mm     ENDC
00200944                          1474mm     
00200944                 FALSE    1475mm     IFNE DEBUG
00200944                          1476mm     ENDC
00200944                          1477mm 
00200944                          1478mm     ENDM
00200944                          1479mm     HEX2BIN D2,D2,A0
00200944  41F9 002014EA           1480mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020094A  0402 0030               1481mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020094E  C4BC 000000FF           1482mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200954  1430 2000               1483mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200958                          1484mm     ENDM
00200958  8E02                    1485m     OR.B D2,D7    
0020095A                          1486m     ENDM
0020095A  DC87                    1487                  ADD.L D7,D6                     ; add into checksum
0020095C                          1488  
0020095C  E98F                    1489                  LSL.L #4,D7                     ; middle byte
0020095E                          1490m                 DOWNLOAD_BYTE D2,D7,D3,A0               
0020095E                          1491mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
0020095E                          1492mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020095E                          1493mm 
0020095E  1439 00C00003           1494mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200964  0802 0000               1495mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200968  6700 0010               1496mm     BEQ CONTINUE_99                             ; NOTHING, CONTINUE
0020096C                          1497mm  
0020096C                          1498mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020096C                 TRUE     1499mmm     IFEQ DEBUG
0020096C  1439 00C00007           1500mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200972                          1501mmm     ENDC
00200972                 FALSE    1502mmm     IFNE DEBUG
00200972                          1503mmm     ENDC
00200972                          1504mmm      
00200972  B43C 001B               1505mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200976  6700 F690               1506mmm     BEQ START
0020097A                          1507mmm     ENDM
0020097A                          1508mm CONTINUE_99
0020097A  1439 00C00013           1509mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200980  0802 0000               1510mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200984  67D8                    1511mm     BEQ WAIT_FOR_READY_99                       ; NOTHING, CHECK AGAIN
00200986                          1512mm     
00200986  1439 00C00017           1513mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020098C  13C2 00E00001           1514mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200992                          1515mm     
00200992                          1516mm     ENDM
00200992                          1517mm     PRINT_CHAR D2,D3
00200992                          1518mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200992                 TRUE     1519mm     IFEQ DEBUG
00200992  1639 00C00003           1520mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200998  0803 0002               1521mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020099C  67F4                    1522mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0020099E  13C2 00C00007           1523mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A4                          1524mm     ENDC
002009A4                          1525mm     
002009A4                 FALSE    1526mm     IFNE DEBUG
002009A4                          1527mm     ENDC
002009A4                          1528mm 
002009A4                          1529mm     ENDM
002009A4                          1530mm     HEX2BIN D2,D2,A0
002009A4  41F9 002014EA           1531mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002009AA  0402 0030               1532mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009AE  C4BC 000000FF           1533mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002009B4  1430 2000               1534mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002009B8                          1535mm     ENDM
002009B8  8E02                    1536m     OR.B D2,D7
002009BA  E98F                    1537m     LSL.L #4,D7
002009BC                          1538m         
002009BC                          1539mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002009BC                          1540mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BC                          1541mm 
002009BC  1439 00C00003           1542mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002009C2  0802 0000               1543mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002009C6  6700 0010               1544mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
002009CA                          1545mm  
002009CA                          1546mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002009CA                 TRUE     1547mmm     IFEQ DEBUG
002009CA  1439 00C00007           1548mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002009D0                          1549mmm     ENDC
002009D0                 FALSE    1550mmm     IFNE DEBUG
002009D0                          1551mmm     ENDC
002009D0                          1552mmm      
002009D0  B43C 001B               1553mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002009D4  6700 F632               1554mmm     BEQ START
002009D8                          1555mmm     ENDM
002009D8                          1556mm CONTINUE_103
002009D8  1439 00C00013           1557mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002009DE  0802 0000               1558mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002009E2  67D8                    1559mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
002009E4                          1560mm     
002009E4  1439 00C00017           1561mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002009EA  13C2 00E00001           1562mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002009F0                          1563mm     
002009F0                          1564mm     ENDM
002009F0                          1565mm     PRINT_CHAR D2,D3
002009F0                          1566mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009F0                 TRUE     1567mm     IFEQ DEBUG
002009F0  1639 00C00003           1568mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009F6  0803 0002               1569mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009FA  67F4                    1570mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
002009FC  13C2 00C00007           1571mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A02                          1572mm     ENDC
00200A02                          1573mm     
00200A02                 FALSE    1574mm     IFNE DEBUG
00200A02                          1575mm     ENDC
00200A02                          1576mm 
00200A02                          1577mm     ENDM
00200A02                          1578mm     HEX2BIN D2,D2,A0
00200A02  41F9 002014EA           1579mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A08  0402 0030               1580mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A0C  C4BC 000000FF           1581mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A12  1430 2000               1582mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A16                          1583mm     ENDM
00200A16  8E02                    1584m     OR.B D2,D7    
00200A18                          1585m     ENDM
00200A18  7400                    1586                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
00200A1A  1407                    1587                  MOVE.B D7,D2
00200A1C  DC82                    1588                  ADD.L D2,D6
00200A1E                          1589            
00200A1E  E98F                    1590                  LSL.L #4,D7                     ; bottom byte
00200A20                          1591m                 DOWNLOAD_BYTE D2,D7,D3,A0                       
00200A20                          1592mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200A20                          1593mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A20                          1594mm 
00200A20  1439 00C00003           1595mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200A26  0802 0000               1596mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A2A  6700 0010               1597mm     BEQ CONTINUE_108                                ; NOTHING, CONTINUE
00200A2E                          1598mm  
00200A2E                          1599mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200A2E                 TRUE     1600mmm     IFEQ DEBUG
00200A2E  1439 00C00007           1601mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A34                          1602mmm     ENDC
00200A34                 FALSE    1603mmm     IFNE DEBUG
00200A34                          1604mmm     ENDC
00200A34                          1605mmm      
00200A34  B43C 001B               1606mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A38  6700 F5CE               1607mmm     BEQ START
00200A3C                          1608mmm     ENDM
00200A3C                          1609mm CONTINUE_108
00200A3C  1439 00C00013           1610mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200A42  0802 0000               1611mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A46  67D8                    1612mm     BEQ WAIT_FOR_READY_108                      ; NOTHING, CHECK AGAIN
00200A48                          1613mm     
00200A48  1439 00C00017           1614mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A4E  13C2 00E00001           1615mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A54                          1616mm     
00200A54                          1617mm     ENDM
00200A54                          1618mm     PRINT_CHAR D2,D3
00200A54                          1619mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A54                 TRUE     1620mm     IFEQ DEBUG
00200A54  1639 00C00003           1621mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A5A  0803 0002               1622mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A5E  67F4                    1623mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200A60  13C2 00C00007           1624mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A66                          1625mm     ENDC
00200A66                          1626mm     
00200A66                 FALSE    1627mm     IFNE DEBUG
00200A66                          1628mm     ENDC
00200A66                          1629mm 
00200A66                          1630mm     ENDM
00200A66                          1631mm     HEX2BIN D2,D2,A0
00200A66  41F9 002014EA           1632mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A6C  0402 0030               1633mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A70  C4BC 000000FF           1634mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A76  1430 2000               1635mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A7A                          1636mm     ENDM
00200A7A  8E02                    1637m     OR.B D2,D7
00200A7C  E98F                    1638m     LSL.L #4,D7
00200A7E                          1639m         
00200A7E                          1640mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200A7E                          1641mm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A7E                          1642mm 
00200A7E  1439 00C00003           1643mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200A84  0802 0000               1644mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A88  6700 0010               1645mm     BEQ CONTINUE_112                                ; NOTHING, CONTINUE
00200A8C                          1646mm  
00200A8C                          1647mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200A8C                 TRUE     1648mmm     IFEQ DEBUG
00200A8C  1439 00C00007           1649mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A92                          1650mmm     ENDC
00200A92                 FALSE    1651mmm     IFNE DEBUG
00200A92                          1652mmm     ENDC
00200A92                          1653mmm      
00200A92  B43C 001B               1654mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A96  6700 F570               1655mmm     BEQ START
00200A9A                          1656mmm     ENDM
00200A9A                          1657mm CONTINUE_112
00200A9A  1439 00C00013           1658mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200AA0  0802 0000               1659mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200AA4  67D8                    1660mm     BEQ WAIT_FOR_READY_112                      ; NOTHING, CHECK AGAIN
00200AA6                          1661mm     
00200AA6  1439 00C00017           1662mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200AAC  13C2 00E00001           1663mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200AB2                          1664mm     
00200AB2                          1665mm     ENDM
00200AB2                          1666mm     PRINT_CHAR D2,D3
00200AB2                          1667mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB2                 TRUE     1668mm     IFEQ DEBUG
00200AB2  1639 00C00003           1669mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AB8  0803 0002               1670mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200ABC  67F4                    1671mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200ABE  13C2 00C00007           1672mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AC4                          1673mm     ENDC
00200AC4                          1674mm     
00200AC4                 FALSE    1675mm     IFNE DEBUG
00200AC4                          1676mm     ENDC
00200AC4                          1677mm 
00200AC4                          1678mm     ENDM
00200AC4                          1679mm     HEX2BIN D2,D2,A0
00200AC4  41F9 002014EA           1680mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ACA  0402 0030               1681mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200ACE  C4BC 000000FF           1682mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200AD4  1430 2000               1683mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200AD8                          1684mm     ENDM
00200AD8  8E02                    1685m     OR.B D2,D7    
00200ADA                          1686m     ENDM
00200ADA  7400                    1687                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200ADC  1407                    1688                  MOVE.B D7,D2
00200ADE  DC82                    1689                  ADD.L D2,D6
00200AE0                          1690                  
00200AE0  2247                    1691                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200AE2  D3CB                    1692                  ADD.L A3,A1                     ; add in the offset
00200AE4                          1693          
00200AE4  5985                    1694                  SUB.L #4,D5                     ; subtract four bytes for 24 bit address and 1 byte checksum
00200AE6                          1695                  WHILE.L D5 <GT> #0 DO           ; read the data bytes                   
00200AE6                          1696s _10000002
00200AE6  BABC 00000000           1697s     CMP.L   #0,D5
00200AEC  6F00 00C8               1698s     BLE _10000003
00200AF0  7E00                    1699                      MOVE.L #0,D7                ; D7 holds the byte
00200AF2                          1700m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                        
00200AF2                          1701mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200AF2                          1702mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF2                          1703mm 
00200AF2  1439 00C00003           1704mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200AF8  0802 0000               1705mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200AFC  6700 0010               1706mm     BEQ CONTINUE_117                                ; NOTHING, CONTINUE
00200B00                          1707mm  
00200B00                          1708mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200B00                 TRUE     1709mmm     IFEQ DEBUG
00200B00  1439 00C00007           1710mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B06                          1711mmm     ENDC
00200B06                 FALSE    1712mmm     IFNE DEBUG
00200B06                          1713mmm     ENDC
00200B06                          1714mmm      
00200B06  B43C 001B               1715mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B0A  6700 F4FC               1716mmm     BEQ START
00200B0E                          1717mmm     ENDM
00200B0E                          1718mm CONTINUE_117
00200B0E  1439 00C00013           1719mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200B14  0802 0000               1720mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200B18  67D8                    1721mm     BEQ WAIT_FOR_READY_117                      ; NOTHING, CHECK AGAIN
00200B1A                          1722mm     
00200B1A  1439 00C00017           1723mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B20  13C2 00E00001           1724mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B26                          1725mm     
00200B26                          1726mm     ENDM
00200B26                          1727mm     PRINT_CHAR D2,D3
00200B26                          1728mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B26                 TRUE     1729mm     IFEQ DEBUG
00200B26  1639 00C00003           1730mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B2C  0803 0002               1731mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B30  67F4                    1732mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B32  13C2 00C00007           1733mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B38                          1734mm     ENDC
00200B38                          1735mm     
00200B38                 FALSE    1736mm     IFNE DEBUG
00200B38                          1737mm     ENDC
00200B38                          1738mm 
00200B38                          1739mm     ENDM
00200B38                          1740mm     HEX2BIN D2,D2,A0
00200B38  41F9 002014EA           1741mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B3E  0402 0030               1742mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B42  C4BC 000000FF           1743mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B48  1430 2000               1744mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B4C                          1745mm     ENDM
00200B4C  8E02                    1746m     OR.B D2,D7
00200B4E  E98F                    1747m     LSL.L #4,D7
00200B50                          1748m         
00200B50                          1749mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200B50                          1750mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B50                          1751mm 
00200B50  1439 00C00003           1752mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200B56  0802 0000               1753mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200B5A  6700 0010               1754mm     BEQ CONTINUE_121                                ; NOTHING, CONTINUE
00200B5E                          1755mm  
00200B5E                          1756mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200B5E                 TRUE     1757mmm     IFEQ DEBUG
00200B5E  1439 00C00007           1758mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B64                          1759mmm     ENDC
00200B64                 FALSE    1760mmm     IFNE DEBUG
00200B64                          1761mmm     ENDC
00200B64                          1762mmm      
00200B64  B43C 001B               1763mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B68  6700 F49E               1764mmm     BEQ START
00200B6C                          1765mmm     ENDM
00200B6C                          1766mm CONTINUE_121
00200B6C  1439 00C00013           1767mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200B72  0802 0000               1768mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200B76  67D8                    1769mm     BEQ WAIT_FOR_READY_121                      ; NOTHING, CHECK AGAIN
00200B78                          1770mm     
00200B78  1439 00C00017           1771mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B7E  13C2 00E00001           1772mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B84                          1773mm     
00200B84                          1774mm     ENDM
00200B84                          1775mm     PRINT_CHAR D2,D3
00200B84                          1776mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B84                 TRUE     1777mm     IFEQ DEBUG
00200B84  1639 00C00003           1778mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B8A  0803 0002               1779mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B8E  67F4                    1780mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00200B90  13C2 00C00007           1781mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B96                          1782mm     ENDC
00200B96                          1783mm     
00200B96                 FALSE    1784mm     IFNE DEBUG
00200B96                          1785mm     ENDC
00200B96                          1786mm 
00200B96                          1787mm     ENDM
00200B96                          1788mm     HEX2BIN D2,D2,A0
00200B96  41F9 002014EA           1789mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B9C  0402 0030               1790mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BA0  C4BC 000000FF           1791mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200BA6  1430 2000               1792mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200BAA                          1793mm     ENDM
00200BAA  8E02                    1794m     OR.B D2,D7    
00200BAC                          1795m     ENDM
00200BAC  DC87                    1796                      ADD.L D7,D6                 ; add into checksum
00200BAE                          1797                      
00200BAE  12C7                    1798                      MOVE.B D7,(A1)+             ; store it!
00200BB0                          1799  
00200BB0  5385                    1800                      SUB.L #1,D5                 ; 1 less byte to go
00200BB2                          1801                  ENDW
00200BB2  6000 FF32               1802s     BRA _10000002
00200BB6                          1803s _10000003
00200BB6                          1804              
00200BB6  43F9 002004A0           1805                  LEA WAIT_FOR_SRECORD,A1         ; next place to go
00200BBC                          1806              ELSE
00200BBC  6000 02BE               1807s     BRA _00000005
00200BC0                          1808s _00000004
00200BC0                          1809                  IF.B D7 <EQ> #'8' THEN.L        ; termination record, exit
00200BC0  BE3C 0038               1810s     CMP.B   #'8',D7
00200BC4  6600 0250               1811s     BNE.L   _00000006
00200BC8  7E00                    1812                      MOVE.L #0,D7                ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200BCA                          1813m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00200BCA                          1814mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200BCA                          1815mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BCA                          1816mm 
00200BCA  1439 00C00003           1817mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200BD0  0802 0000               1818mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200BD4  6700 0010               1819mm     BEQ CONTINUE_126                                ; NOTHING, CONTINUE
00200BD8                          1820mm  
00200BD8                          1821mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200BD8                 TRUE     1822mmm     IFEQ DEBUG
00200BD8  1439 00C00007           1823mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200BDE                          1824mmm     ENDC
00200BDE                 FALSE    1825mmm     IFNE DEBUG
00200BDE                          1826mmm     ENDC
00200BDE                          1827mmm      
00200BDE  B43C 001B               1828mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200BE2  6700 F424               1829mmm     BEQ START
00200BE6                          1830mmm     ENDM
00200BE6                          1831mm CONTINUE_126
00200BE6  1439 00C00013           1832mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200BEC  0802 0000               1833mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200BF0  67D8                    1834mm     BEQ WAIT_FOR_READY_126                      ; NOTHING, CHECK AGAIN
00200BF2                          1835mm     
00200BF2  1439 00C00017           1836mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200BF8  13C2 00E00001           1837mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200BFE                          1838mm     
00200BFE                          1839mm     ENDM
00200BFE                          1840mm     PRINT_CHAR D2,D3
00200BFE                          1841mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1842mm     IFEQ DEBUG
00200BFE  1639 00C00003           1843mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C04  0803 0002               1844mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1845mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200C0A  13C2 00C00007           1846mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C10                          1847mm     ENDC
00200C10                          1848mm     
00200C10                 FALSE    1849mm     IFNE DEBUG
00200C10                          1850mm     ENDC
00200C10                          1851mm 
00200C10                          1852mm     ENDM
00200C10                          1853mm     HEX2BIN D2,D2,A0
00200C10  41F9 002014EA           1854mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C16  0402 0030               1855mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C1A  C4BC 000000FF           1856mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C20  1430 2000               1857mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C24                          1858mm     ENDM
00200C24  8E02                    1859m     OR.B D2,D7
00200C26  E98F                    1860m     LSL.L #4,D7
00200C28                          1861m         
00200C28                          1862mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200C28                          1863mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C28                          1864mm 
00200C28  1439 00C00003           1865mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200C2E  0802 0000               1866mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200C32  6700 0010               1867mm     BEQ CONTINUE_130                                ; NOTHING, CONTINUE
00200C36                          1868mm  
00200C36                          1869mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200C36                 TRUE     1870mmm     IFEQ DEBUG
00200C36  1439 00C00007           1871mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C3C                          1872mmm     ENDC
00200C3C                 FALSE    1873mmm     IFNE DEBUG
00200C3C                          1874mmm     ENDC
00200C3C                          1875mmm      
00200C3C  B43C 001B               1876mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200C40  6700 F3C6               1877mmm     BEQ START
00200C44                          1878mmm     ENDM
00200C44                          1879mm CONTINUE_130
00200C44  1439 00C00013           1880mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200C4A  0802 0000               1881mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200C4E  67D8                    1882mm     BEQ WAIT_FOR_READY_130                      ; NOTHING, CHECK AGAIN
00200C50                          1883mm     
00200C50  1439 00C00017           1884mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C56  13C2 00E00001           1885mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C5C                          1886mm     
00200C5C                          1887mm     ENDM
00200C5C                          1888mm     PRINT_CHAR D2,D3
00200C5C                          1889mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C5C                 TRUE     1890mm     IFEQ DEBUG
00200C5C  1639 00C00003           1891mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C62  0803 0002               1892mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C66  67F4                    1893mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00200C68  13C2 00C00007           1894mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C6E                          1895mm     ENDC
00200C6E                          1896mm     
00200C6E                 FALSE    1897mm     IFNE DEBUG
00200C6E                          1898mm     ENDC
00200C6E                          1899mm 
00200C6E                          1900mm     ENDM
00200C6E                          1901mm     HEX2BIN D2,D2,A0
00200C6E  41F9 002014EA           1902mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C74  0402 0030               1903mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C78  C4BC 000000FF           1904mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C7E  1430 2000               1905mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C82                          1906mm     ENDM
00200C82  8E02                    1907m     OR.B D2,D7    
00200C84                          1908m     ENDM
00200C84  DC87                    1909                      ADD.L D7,D6                 ; add top byte of address into checksum
00200C86                          1910  
00200C86  E98F                    1911                      LSL.L #4,D7                 ; middle byte
00200C88                          1912m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00200C88                          1913mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200C88                          1914mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C88                          1915mm 
00200C88  1439 00C00003           1916mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200C8E  0802 0000               1917mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200C92  6700 0010               1918mm     BEQ CONTINUE_135                                ; NOTHING, CONTINUE
00200C96                          1919mm  
00200C96                          1920mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200C96                 TRUE     1921mmm     IFEQ DEBUG
00200C96  1439 00C00007           1922mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C9C                          1923mmm     ENDC
00200C9C                 FALSE    1924mmm     IFNE DEBUG
00200C9C                          1925mmm     ENDC
00200C9C                          1926mmm      
00200C9C  B43C 001B               1927mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CA0  6700 F366               1928mmm     BEQ START
00200CA4                          1929mmm     ENDM
00200CA4                          1930mm CONTINUE_135
00200CA4  1439 00C00013           1931mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200CAA  0802 0000               1932mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200CAE  67D8                    1933mm     BEQ WAIT_FOR_READY_135                      ; NOTHING, CHECK AGAIN
00200CB0                          1934mm     
00200CB0  1439 00C00017           1935mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200CB6  13C2 00E00001           1936mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200CBC                          1937mm     
00200CBC                          1938mm     ENDM
00200CBC                          1939mm     PRINT_CHAR D2,D3
00200CBC                          1940mm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBC                 TRUE     1941mm     IFEQ DEBUG
00200CBC  1639 00C00003           1942mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CC2  0803 0002               1943mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC6  67F4                    1944mm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00200CC8  13C2 00C00007           1945mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CCE                          1946mm     ENDC
00200CCE                          1947mm     
00200CCE                 FALSE    1948mm     IFNE DEBUG
00200CCE                          1949mm     ENDC
00200CCE                          1950mm 
00200CCE                          1951mm     ENDM
00200CCE                          1952mm     HEX2BIN D2,D2,A0
00200CCE  41F9 002014EA           1953mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200CD4  0402 0030               1954mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200CD8  C4BC 000000FF           1955mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200CDE  1430 2000               1956mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200CE2                          1957mm     ENDM
00200CE2  8E02                    1958m     OR.B D2,D7
00200CE4  E98F                    1959m     LSL.L #4,D7
00200CE6                          1960m         
00200CE6                          1961mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200CE6                          1962mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE6                          1963mm 
00200CE6  1439 00C00003           1964mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200CEC  0802 0000               1965mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200CF0  6700 0010               1966mm     BEQ CONTINUE_139                                ; NOTHING, CONTINUE
00200CF4                          1967mm  
00200CF4                          1968mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200CF4                 TRUE     1969mmm     IFEQ DEBUG
00200CF4  1439 00C00007           1970mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200CFA                          1971mmm     ENDC
00200CFA                 FALSE    1972mmm     IFNE DEBUG
00200CFA                          1973mmm     ENDC
00200CFA                          1974mmm      
00200CFA  B43C 001B               1975mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFE  6700 F308               1976mmm     BEQ START
00200D02                          1977mmm     ENDM
00200D02                          1978mm CONTINUE_139
00200D02  1439 00C00013           1979mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200D08  0802 0000               1980mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200D0C  67D8                    1981mm     BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00200D0E                          1982mm     
00200D0E  1439 00C00017           1983mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D14  13C2 00E00001           1984mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D1A                          1985mm     
00200D1A                          1986mm     ENDM
00200D1A                          1987mm     PRINT_CHAR D2,D3
00200D1A                          1988mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D1A                 TRUE     1989mm     IFEQ DEBUG
00200D1A  1639 00C00003           1990mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D20  0803 0002               1991mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D24  67F4                    1992mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200D26  13C2 00C00007           1993mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D2C                          1994mm     ENDC
00200D2C                          1995mm     
00200D2C                 FALSE    1996mm     IFNE DEBUG
00200D2C                          1997mm     ENDC
00200D2C                          1998mm 
00200D2C                          1999mm     ENDM
00200D2C                          2000mm     HEX2BIN D2,D2,A0
00200D2C  41F9 002014EA           2001mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D32  0402 0030               2002mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D36  C4BC 000000FF           2003mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D3C  1430 2000               2004mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D40                          2005mm     ENDM
00200D40  8E02                    2006m     OR.B D2,D7    
00200D42                          2007m     ENDM
00200D42  7400                    2008                      MOVE.L #0,D2                ; rextract middle byte of address and add into checksum
00200D44  1407                    2009                      MOVE.B D7,D2
00200D46  DC82                    2010                      ADD.L D2,D6
00200D48                          2011                    
00200D48  E98F                    2012                      LSL.L #4,D7                 ; bottom byte
00200D4A                          2013m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                             
00200D4A                          2014mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200D4A                          2015mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D4A                          2016mm 
00200D4A  1439 00C00003           2017mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200D50  0802 0000               2018mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200D54  6700 0010               2019mm     BEQ CONTINUE_144                                ; NOTHING, CONTINUE
00200D58                          2020mm  
00200D58                          2021mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200D58                 TRUE     2022mmm     IFEQ DEBUG
00200D58  1439 00C00007           2023mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D5E                          2024mmm     ENDC
00200D5E                 FALSE    2025mmm     IFNE DEBUG
00200D5E                          2026mmm     ENDC
00200D5E                          2027mmm      
00200D5E  B43C 001B               2028mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D62  6700 F2A4               2029mmm     BEQ START
00200D66                          2030mmm     ENDM
00200D66                          2031mm CONTINUE_144
00200D66  1439 00C00013           2032mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200D6C  0802 0000               2033mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200D70  67D8                    2034mm     BEQ WAIT_FOR_READY_144                      ; NOTHING, CHECK AGAIN
00200D72                          2035mm     
00200D72  1439 00C00017           2036mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D78  13C2 00E00001           2037mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D7E                          2038mm     
00200D7E                          2039mm     ENDM
00200D7E                          2040mm     PRINT_CHAR D2,D3
00200D7E                          2041mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D7E                 TRUE     2042mm     IFEQ DEBUG
00200D7E  1639 00C00003           2043mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D84  0803 0002               2044mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D88  67F4                    2045mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00200D8A  13C2 00C00007           2046mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D90                          2047mm     ENDC
00200D90                          2048mm     
00200D90                 FALSE    2049mm     IFNE DEBUG
00200D90                          2050mm     ENDC
00200D90                          2051mm 
00200D90                          2052mm     ENDM
00200D90                          2053mm     HEX2BIN D2,D2,A0
00200D90  41F9 002014EA           2054mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D96  0402 0030               2055mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D9A  C4BC 000000FF           2056mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DA0  1430 2000               2057mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DA4                          2058mm     ENDM
00200DA4  8E02                    2059m     OR.B D2,D7
00200DA6  E98F                    2060m     LSL.L #4,D7
00200DA8                          2061m         
00200DA8                          2062mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200DA8                          2063mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA8                          2064mm 
00200DA8  1439 00C00003           2065mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200DAE  0802 0000               2066mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200DB2  6700 0010               2067mm     BEQ CONTINUE_148                                ; NOTHING, CONTINUE
00200DB6                          2068mm  
00200DB6                          2069mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200DB6                 TRUE     2070mmm     IFEQ DEBUG
00200DB6  1439 00C00007           2071mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DBC                          2072mmm     ENDC
00200DBC                 FALSE    2073mmm     IFNE DEBUG
00200DBC                          2074mmm     ENDC
00200DBC                          2075mmm      
00200DBC  B43C 001B               2076mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DC0  6700 F246               2077mmm     BEQ START
00200DC4                          2078mmm     ENDM
00200DC4                          2079mm CONTINUE_148
00200DC4  1439 00C00013           2080mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200DCA  0802 0000               2081mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200DCE  67D8                    2082mm     BEQ WAIT_FOR_READY_148                      ; NOTHING, CHECK AGAIN
00200DD0                          2083mm     
00200DD0  1439 00C00017           2084mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200DD6  13C2 00E00001           2085mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200DDC                          2086mm     
00200DDC                          2087mm     ENDM
00200DDC                          2088mm     PRINT_CHAR D2,D3
00200DDC                          2089mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DDC                 TRUE     2090mm     IFEQ DEBUG
00200DDC  1639 00C00003           2091mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DE2  0803 0002               2092mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DE6  67F4                    2093mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00200DE8  13C2 00C00007           2094mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DEE                          2095mm     ENDC
00200DEE                          2096mm     
00200DEE                 FALSE    2097mm     IFNE DEBUG
00200DEE                          2098mm     ENDC
00200DEE                          2099mm 
00200DEE                          2100mm     ENDM
00200DEE                          2101mm     HEX2BIN D2,D2,A0
00200DEE  41F9 002014EA           2102mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DF4  0402 0030               2103mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF8  C4BC 000000FF           2104mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DFE  1430 2000               2105mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200E02                          2106mm     ENDM
00200E02  8E02                    2107m     OR.B D2,D7    
00200E04                          2108m     ENDM
00200E04  7400                    2109                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00200E06  1407                    2110                      MOVE.B D7,D2
00200E08  DC82                    2111                      ADD.L D2,D6
00200E0A                          2112                    
00200E0A  2447                    2113                      MOVE.L D7,A2                ; start address -> A2
00200E0C                          2114                      
00200E0C  43F9 00201018           2115                      LEA DOWNLOAD_DONE,A1        ; next place to go
00200E12                          2116                  ELSE
00200E12  6000 0068               2117s     BRA _00000007
00200E16                          2118s _00000006
00200E16  41F9 0020149F           2119                      LEA UNREC,A0                ; warn for unrecognised type
00200E1C                          2120m                     PRINT_STR A0,D3
00200E1C                          2121m LOOP_152
00200E1C  0C10 0000               2122m     CMP.B #0,(A0)                               ; 0 -> DONE
00200E20  6700 001A               2123m     BEQ EXIT_152
00200E24                          2124mm     PRINT_CHAR (A0)+,D3
00200E24                          2125mm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E24                 TRUE     2126mm     IFEQ DEBUG
00200E24  1639 00C00003           2127mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E2A  0803 0002               2128mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E2E  67F4                    2129mm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00200E30  13D8 00C00007           2130mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200E36                          2131mm     ENDC
00200E36                          2132mm     
00200E36                 FALSE    2133mm     IFNE DEBUG
00200E36                          2134mm     ENDC
00200E36                          2135mm 
00200E36                          2136mm     ENDM
00200E36  4EF9 00200E1C           2137m     JMP LOOP_152
00200E3C                          2138m EXIT_152
00200E3C                          2139m     ENDM
00200E3C                          2140m                     PRINT_CHAR D7,D3
00200E3C                          2141m WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E3C                 TRUE     2142m     IFEQ DEBUG
00200E3C  1639 00C00003           2143m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E42  0803 0002               2144m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E46  67F4                    2145m         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200E48  13C7 00C00007           2146m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200E4E                          2147m     ENDC
00200E4E                          2148m     
00200E4E                 FALSE    2149m     IFNE DEBUG
00200E4E                          2150m     ENDC
00200E4E                          2151m 
00200E4E                          2152m     ENDM
00200E4E                          2153m                     PRINT_CRLF D3
00200E4E                          2154mm     PRINT_CHAR #13,D3                           ; CR
00200E4E                          2155mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E4E                 TRUE     2156mm     IFEQ DEBUG
00200E4E  1639 00C00003           2157mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E54  0803 0002               2158mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E58  67F4                    2159mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00200E5A  13FC 000D 00C00007      2160mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E62                          2161mm     ENDC
00200E62                          2162mm     
00200E62                 FALSE    2163mm     IFNE DEBUG
00200E62                          2164mm     ENDC
00200E62                          2165mm 
00200E62                          2166mm     ENDM
00200E62                          2167mm     PRINT_CHAR #10,D3                           ; LF
00200E62                          2168mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                 TRUE     2169mm     IFEQ DEBUG
00200E62  1639 00C00003           2170mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E68  0803 0002               2171mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E6C  67F4                    2172mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200E6E  13FC 000A 00C00007      2173mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E76                          2174mm     ENDC
00200E76                          2175mm     
00200E76                 FALSE    2176mm     IFNE DEBUG
00200E76                          2177mm     ENDC
00200E76                          2178mm 
00200E76                          2179mm     ENDM
00200E76                          2180m     ENDM
00200E76                          2181              
00200E76  4EF9 002004A0           2182                      JMP WAIT_FOR_SRECORD        ; ignore any other type    
00200E7C                          2183                  ENDI
00200E7C                          2184s _00000007
00200E7C                          2185              ENDI
00200E7C                          2186s _00000005
00200E7C                          2187          ENDI
00200E7C                          2188s _00000003
00200E7C                          2189      ENDI
00200E7C                          2190s _00000001
00200E7C                          2191      
00200E7C  4686                    2192      NOT.L D6                                    ; ones complement the checksum
00200E7E  0286 000000FF           2193      ANDI.L #$FF,D6                              ; and take the LSByte
00200E84                          2194          
00200E84  7E00                    2195      MOVE.L #0,D7                                ; read the checksum from the data stream
00200E86                          2196m     DOWNLOAD_BYTE D2,D7,D3,A0                           
00200E86                          2197mm     DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200E86                          2198mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E86                          2199mm 
00200E86  1439 00C00003           2200mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200E8C  0802 0000               2201mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200E90  6700 0010               2202mm     BEQ CONTINUE_159                                ; NOTHING, CONTINUE
00200E94                          2203mm  
00200E94                          2204mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200E94                 TRUE     2205mmm     IFEQ DEBUG
00200E94  1439 00C00007           2206mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E9A                          2207mmm     ENDC
00200E9A                 FALSE    2208mmm     IFNE DEBUG
00200E9A                          2209mmm     ENDC
00200E9A                          2210mmm      
00200E9A  B43C 001B               2211mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E9E  6700 F168               2212mmm     BEQ START
00200EA2                          2213mmm     ENDM
00200EA2                          2214mm CONTINUE_159
00200EA2  1439 00C00013           2215mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200EA8  0802 0000               2216mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200EAC  67D8                    2217mm     BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00200EAE                          2218mm     
00200EAE  1439 00C00017           2219mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200EB4  13C2 00E00001           2220mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200EBA                          2221mm     
00200EBA                          2222mm     ENDM
00200EBA                          2223mm     PRINT_CHAR D2,D3
00200EBA                          2224mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EBA                 TRUE     2225mm     IFEQ DEBUG
00200EBA  1639 00C00003           2226mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200EC0  0803 0002               2227mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EC4  67F4                    2228mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00200EC6  13C2 00C00007           2229mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200ECC                          2230mm     ENDC
00200ECC                          2231mm     
00200ECC                 FALSE    2232mm     IFNE DEBUG
00200ECC                          2233mm     ENDC
00200ECC                          2234mm 
00200ECC                          2235mm     ENDM
00200ECC                          2236mm     HEX2BIN D2,D2,A0
00200ECC  41F9 002014EA           2237mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ED2  0402 0030               2238mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200ED6  C4BC 000000FF           2239mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EDC  1430 2000               2240mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EE0                          2241mm     ENDM
00200EE0  8E02                    2242m     OR.B D2,D7
00200EE2  E98F                    2243m     LSL.L #4,D7
00200EE4                          2244m         
00200EE4                          2245mm     DOWNLOAD D2                                ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200EE4                          2246mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EE4                          2247mm 
00200EE4  1439 00C00003           2248mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200EEA  0802 0000               2249mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200EEE  6700 0010               2250mm     BEQ CONTINUE_163                                ; NOTHING, CONTINUE
00200EF2                          2251mm  
00200EF2                          2252mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200EF2                 TRUE     2253mmm     IFEQ DEBUG
00200EF2  1439 00C00007           2254mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200EF8                          2255mmm     ENDC
00200EF8                 FALSE    2256mmm     IFNE DEBUG
00200EF8                          2257mmm     ENDC
00200EF8                          2258mmm      
00200EF8  B43C 001B               2259mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200EFC  6700 F10A               2260mmm     BEQ START
00200F00                          2261mmm     ENDM
00200F00                          2262mm CONTINUE_163
00200F00  1439 00C00013           2263mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200F06  0802 0000               2264mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200F0A  67D8                    2265mm     BEQ WAIT_FOR_READY_163                      ; NOTHING, CHECK AGAIN
00200F0C                          2266mm     
00200F0C  1439 00C00017           2267mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200F12  13C2 00E00001           2268mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200F18                          2269mm     
00200F18                          2270mm     ENDM
00200F18                          2271mm     PRINT_CHAR D2,D3
00200F18                          2272mm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F18                 TRUE     2273mm     IFEQ DEBUG
00200F18  1639 00C00003           2274mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F1E  0803 0002               2275mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F22  67F4                    2276mm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
00200F24  13C2 00C00007           2277mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F2A                          2278mm     ENDC
00200F2A                          2279mm     
00200F2A                 FALSE    2280mm     IFNE DEBUG
00200F2A                          2281mm     ENDC
00200F2A                          2282mm 
00200F2A                          2283mm     ENDM
00200F2A                          2284mm     HEX2BIN D2,D2,A0
00200F2A  41F9 002014EA           2285mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F30  0402 0030               2286mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F34  C4BC 000000FF           2287mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F3A  1430 2000               2288mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F3E                          2289mm     ENDM
00200F3E  8E02                    2290m     OR.B D2,D7    
00200F40                          2291m     ENDM
00200F40                          2292m     PRINT_CRLF D3
00200F40                          2293mm     PRINT_CHAR #13,D3                           ; CR
00200F40                          2294mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F40                 TRUE     2295mm     IFEQ DEBUG
00200F40  1639 00C00003           2296mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F46  0803 0002               2297mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F4A  67F4                    2298mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00200F4C  13FC 000D 00C00007      2299mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200F54                          2300mm     ENDC
00200F54                          2301mm     
00200F54                 FALSE    2302mm     IFNE DEBUG
00200F54                          2303mm     ENDC
00200F54                          2304mm 
00200F54                          2305mm     ENDM
00200F54                          2306mm     PRINT_CHAR #10,D3                           ; LF
00200F54                          2307mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F54                 TRUE     2308mm     IFEQ DEBUG
00200F54  1639 00C00003           2309mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F5A  0803 0002               2310mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F5E  67F4                    2311mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00200F60  13FC 000A 00C00007      2312mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200F68                          2313mm     ENDC
00200F68                          2314mm     
00200F68                 FALSE    2315mm     IFNE DEBUG
00200F68                          2316mm     ENDC
00200F68                          2317mm 
00200F68                          2318mm     ENDM
00200F68                          2319m     ENDM
00200F68                          2320  
00200F68                          2321      IF.B D7 <NE> D6 THEN.L
00200F68  BE06                    2322s     CMP.B   D6,D7
00200F6A  6700 00AA               2323s     BEQ.L   _00000008
00200F6E  41F9 002014B6           2324          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00200F74                          2325m         PRINT_STR A0,D3
00200F74                          2326m LOOP_170
00200F74  0C10 0000               2327m     CMP.B #0,(A0)                               ; 0 -> DONE
00200F78  6700 001A               2328m     BEQ EXIT_170
00200F7C                          2329mm     PRINT_CHAR (A0)+,D3
00200F7C                          2330mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F7C                 TRUE     2331mm     IFEQ DEBUG
00200F7C  1639 00C00003           2332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F82  0803 0002               2333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F86  67F4                    2334mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00200F88  13D8 00C00007           2335mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200F8E                          2336mm     ENDC
00200F8E                          2337mm     
00200F8E                 FALSE    2338mm     IFNE DEBUG
00200F8E                          2339mm     ENDC
00200F8E                          2340mm 
00200F8E                          2341mm     ENDM
00200F8E  4EF9 00200F74           2342m     JMP LOOP_170
00200F94                          2343m EXIT_170
00200F94                          2344m     ENDM
00200F94                          2345m         PRINT_REG D4,D3,D6,D7,A0
00200F94                          2346mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200F94                          2347mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                 TRUE     2348mm     IFEQ DEBUG
00200F94  1639 00C00003           2349mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F9A  0803 0002               2350mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F9E  67F4                    2351mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00200FA0  13FC 0030 00C00007      2352mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200FA8                          2353mm     ENDC
00200FA8                          2354mm     
00200FA8                 FALSE    2355mm     IFNE DEBUG
00200FA8                          2356mm     ENDC
00200FA8                          2357mm 
00200FA8                          2358mm     ENDM
00200FA8                          2359mm     PRINT_CHAR #'x',D3
00200FA8                          2360mm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FA8                 TRUE     2361mm     IFEQ DEBUG
00200FA8  1639 00C00003           2362mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FAE  0803 0002               2363mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FB2  67F4                    2364mm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00200FB4  13FC 0078 00C00007      2365mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200FBC                          2366mm     ENDC
00200FBC                          2367mm     
00200FBC                 FALSE    2368mm     IFNE DEBUG
00200FBC                          2369mm     ENDC
00200FBC                          2370mm 
00200FBC                          2371mm     ENDM
00200FBC  7E07                    2372m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200FBE                          2373m LOOP_172
00200FBE                          2374mm     BIN2HEX D4,D6,A0
00200FBE  41F9 002014DA           2375mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200FC4  E99C                    2376mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200FC6  1C04                    2377mm     MOVE.B D4,D6
00200FC8  0286 0000000F           2378mm     ANDI.L #$F,D6
00200FCE  1C30 6000               2379mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200FD2                          2380mm     ENDM
00200FD2                          2381mm     PRINT_CHAR D6,D3
00200FD2                          2382mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FD2                 TRUE     2383mm     IFEQ DEBUG
00200FD2  1639 00C00003           2384mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FD8  0803 0002               2385mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FDC  67F4                    2386mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00200FDE  13C6 00C00007           2387mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200FE4                          2388mm     ENDC
00200FE4                          2389mm     
00200FE4                 FALSE    2390mm     IFNE DEBUG
00200FE4                          2391mm     ENDC
00200FE4                          2392mm 
00200FE4                          2393mm     ENDM
00200FE4  57CF FFD8               2394m     DBEQ D7,LOOP_172
00200FE8                          2395m     ENDM
00200FE8                          2396m         PRINT_CRLF D3
00200FE8                          2397mm     PRINT_CHAR #13,D3                           ; CR
00200FE8                          2398mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FE8                 TRUE     2399mm     IFEQ DEBUG
00200FE8  1639 00C00003           2400mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FEE  0803 0002               2401mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FF2  67F4                    2402mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00200FF4  13FC 000D 00C00007      2403mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200FFC                          2404mm     ENDC
00200FFC                          2405mm     
00200FFC                 FALSE    2406mm     IFNE DEBUG
00200FFC                          2407mm     ENDC
00200FFC                          2408mm 
00200FFC                          2409mm     ENDM
00200FFC                          2410mm     PRINT_CHAR #10,D3                           ; LF
00200FFC                          2411mm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FFC                 TRUE     2412mm     IFEQ DEBUG
00200FFC  1639 00C00003           2413mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201002  0803 0002               2414mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201006  67F4                    2415mm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00201008  13FC 000A 00C00007      2416mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201010                          2417mm     ENDC
00201010                          2418mm     
00201010                 FALSE    2419mm     IFNE DEBUG
00201010                          2420mm     ENDC
00201010                          2421mm 
00201010                          2422mm     ENDM
00201010                          2423m     ENDM
00201010  4EF9 00200188           2424          JMP MAIN_LOOP
00201016                          2425      ENDI
00201016                          2426s _00000008
00201016                          2427      
00201016  4ED1                    2428      JMP (A1)
00201018                          2429  DOWNLOAD_DONE
00201018                          2430m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00201018                          2431mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201018                          2432mm WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201018                 TRUE     2433mm     IFEQ DEBUG
00201018  1639 00C00003           2434mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020101E  0803 0002               2435mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201022  67F4                    2436mm         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
00201024  13FC 0030 00C00007      2437mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020102C                          2438mm     ENDC
0020102C                          2439mm     
0020102C                 FALSE    2440mm     IFNE DEBUG
0020102C                          2441mm     ENDC
0020102C                          2442mm 
0020102C                          2443mm     ENDM
0020102C                          2444mm     PRINT_CHAR #'x',D3
0020102C                          2445mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020102C                 TRUE     2446mm     IFEQ DEBUG
0020102C  1639 00C00003           2447mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201032  0803 0002               2448mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201036  67F4                    2449mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00201038  13FC 0078 00C00007      2450mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00201040                          2451mm     ENDC
00201040                          2452mm     
00201040                 FALSE    2453mm     IFNE DEBUG
00201040                          2454mm     ENDC
00201040                          2455mm 
00201040                          2456mm     ENDM
00201040  7C07                    2457m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201042                          2458m LOOP_180
00201042                          2459mm     BIN2HEX D4,D7,A0
00201042  41F9 002014DA           2460mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201048  E99C                    2461mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020104A  1E04                    2462mm     MOVE.B D4,D7
0020104C  0287 0000000F           2463mm     ANDI.L #$F,D7
00201052  1E30 7000               2464mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00201056                          2465mm     ENDM
00201056                          2466mm     PRINT_CHAR D7,D3
00201056                          2467mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201056                 TRUE     2468mm     IFEQ DEBUG
00201056  1639 00C00003           2469mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020105C  0803 0002               2470mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201060  67F4                    2471mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00201062  13C7 00C00007           2472mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201068                          2473mm     ENDC
00201068                          2474mm     
00201068                 FALSE    2475mm     IFNE DEBUG
00201068                          2476mm     ENDC
00201068                          2477mm 
00201068                          2478mm     ENDM
00201068  57CE FFD8               2479m     DBEQ D6,LOOP_180
0020106C                          2480m     ENDM
0020106C  41F9 0020147D           2481      LEA READ,A0
00201072                          2482m     PRINT_STR A0,D3
00201072                          2483m LOOP_185
00201072  0C10 0000               2484m     CMP.B #0,(A0)                               ; 0 -> DONE
00201076  6700 001A               2485m     BEQ EXIT_185
0020107A                          2486mm     PRINT_CHAR (A0)+,D3
0020107A                          2487mm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020107A                 TRUE     2488mm     IFEQ DEBUG
0020107A  1639 00C00003           2489mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201080  0803 0002               2490mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201084  67F4                    2491mm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00201086  13D8 00C00007           2492mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020108C                          2493mm     ENDC
0020108C                          2494mm     
0020108C                 FALSE    2495mm     IFNE DEBUG
0020108C                          2496mm     ENDC
0020108C                          2497mm 
0020108C                          2498mm     ENDM
0020108C  4EF9 00201072           2499m     JMP LOOP_185
00201092                          2500m EXIT_185
00201092                          2501m     ENDM
00201092  2E0A                    2502      MOVE.L A2,D7                                ; set address accumulator to start address
00201094                          2503m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00201094                          2504mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201094                          2505mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201094                 TRUE     2506mm     IFEQ DEBUG
00201094  1639 00C00003           2507mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020109A  0803 0002               2508mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020109E  67F4                    2509mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
002010A0  13FC 0030 00C00007      2510mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002010A8                          2511mm     ENDC
002010A8                          2512mm     
002010A8                 FALSE    2513mm     IFNE DEBUG
002010A8                          2514mm     ENDC
002010A8                          2515mm 
002010A8                          2516mm     ENDM
002010A8                          2517mm     PRINT_CHAR #'x',D3
002010A8                          2518mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A8                 TRUE     2519mm     IFEQ DEBUG
002010A8  1639 00C00003           2520mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010AE  0803 0002               2521mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010B2  67F4                    2522mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
002010B4  13FC 0078 00C00007      2523mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002010BC                          2524mm     ENDC
002010BC                          2525mm     
002010BC                 FALSE    2526mm     IFNE DEBUG
002010BC                          2527mm     ENDC
002010BC                          2528mm 
002010BC                          2529mm     ENDM
002010BC  7C07                    2530m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002010BE                          2531m LOOP_187
002010BE                          2532mm     BIN2HEX D7,D2,A0
002010BE  41F9 002014DA           2533mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002010C4  E99F                    2534mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002010C6  1407                    2535mm     MOVE.B D7,D2
002010C8  0282 0000000F           2536mm     ANDI.L #$F,D2
002010CE  1430 2000               2537mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002010D2                          2538mm     ENDM
002010D2                          2539mm     PRINT_CHAR D2,D3
002010D2                          2540mm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010D2                 TRUE     2541mm     IFEQ DEBUG
002010D2  1639 00C00003           2542mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010D8  0803 0002               2543mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010DC  67F4                    2544mm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
002010DE  13C2 00C00007           2545mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002010E4                          2546mm     ENDC
002010E4                          2547mm     
002010E4                 FALSE    2548mm     IFNE DEBUG
002010E4                          2549mm     ENDC
002010E4                          2550mm 
002010E4                          2551mm     ENDM
002010E4  57CE FFD8               2552m     DBEQ D6,LOOP_187
002010E8                          2553m     ENDM
002010E8                          2554m     PRINT_CRLF D3     
002010E8                          2555mm     PRINT_CHAR #13,D3                           ; CR
002010E8                          2556mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010E8                 TRUE     2557mm     IFEQ DEBUG
002010E8  1639 00C00003           2558mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010EE  0803 0002               2559mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010F2  67F4                    2560mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
002010F4  13FC 000D 00C00007      2561mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002010FC                          2562mm     ENDC
002010FC                          2563mm     
002010FC                 FALSE    2564mm     IFNE DEBUG
002010FC                          2565mm     ENDC
002010FC                          2566mm 
002010FC                          2567mm     ENDM
002010FC                          2568mm     PRINT_CHAR #10,D3                           ; LF
002010FC                          2569mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010FC                 TRUE     2570mm     IFEQ DEBUG
002010FC  1639 00C00003           2571mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201102  0803 0002               2572mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201106  67F4                    2573mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00201108  13FC 000A 00C00007      2574mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201110                          2575mm     ENDC
00201110                          2576mm     
00201110                 FALSE    2577mm     IFNE DEBUG
00201110                          2578mm     ENDC
00201110                          2579mm 
00201110                          2580mm     ENDM
00201110                          2581m     ENDM
00201110                          2582          
00201110  4EF9 00200188           2583      JMP MAIN_LOOP
00201116                          2584      
00201116                          2585  G
00201116  2047                    2586      MOVE.L D7,A0                                ; address accumulator -> address register
00201118  3E3C 0000               2587      MOVE #0,D7                                  ; clear the now used address accumulator
0020111C  4ED0                    2588      JMP (A0)                                    ; jump to it!
0020111E                          2589      
0020111E                          2590  Z
0020111E  207C 00200000           2591      MOVE.L #RAM,A0                              ; address of RAM
00201124  7000                    2592      MOVE.L #0,D0                                ; number of bytes
00201126                          2593     
00201126                          2594      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201126                          2595s _10000004
00201126  B0BC 00040000           2596s     CMP.L   #$40000,D0
0020112C  6E00 001A               2597s     BGT _10000005
00201130  2200                    2598          MOVE.L D0,D1                            ; progress update
00201132  E089                    2599          LSR.L #8,D1 
00201134  E089                    2600          LSR.L #8,D1
00201136  0281 0000000F           2601          ANDI.L #$F,D1
0020113C  13C1 00E00001           2602          MOVE.B D1,DISPLAY
00201142                          2603  
00201142  20C0                    2604          MOVE.L D0,(A0)+ 
00201144  5880                    2605          ADD.L #4,D0
00201146                          2606      ENDW
00201146  60DE                    2607s     BRA _10000004
00201148                          2608s _10000005
00201148                          2609   
00201148  207C 00200000           2610      MOVE.L #RAM,A0                              ; address of RAM
0020114E  7000                    2611      MOVE.L #0,D0                                ; number of bytes
00201150                          2612     
00201150                          2613      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201150                          2614s _10000006
00201150  B0BC 00040000           2615s     CMP.L   #$40000,D0
00201156  6E00 00CC               2616s     BGT _10000007
0020115A  2200                    2617          MOVE.L D0,D1                            ; progress update
0020115C  E089                    2618          LSR.L #8,D1
0020115E  E089                    2619          LSR.L #8,D1
00201160  0281 0000000F           2620          ANDI.L #$F,D1
00201166  13C1 00E00001           2621          MOVE.B D1,DISPLAY
0020116C                          2622  
0020116C  2218                    2623          MOVE.L (A0)+,D1
0020116E                          2624            
0020116E                          2625          IF.L D0 <EQ> D1 THEN
0020116E  B081                    2626s     CMP.L   D1,D0
00201170  6600 0006               2627s     BNE _00000009
00201174  6000 00A8               2628              BRA OK
00201178                          2629          ENDI 
00201178                          2630s _00000009
00201178                          2631            
00201178  43F9 002014C8           2632          LEA RAM_ERROR,A1
0020117E                          2633m         PRINT_STR A1,D1
0020117E                          2634m LOOP_195
0020117E  0C11 0000               2635m     CMP.B #0,(A1)                               ; 0 -> DONE
00201182  6700 001A               2636m     BEQ EXIT_195
00201186                          2637mm     PRINT_CHAR (A1)+,D1
00201186                          2638mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201186                 TRUE     2639mm     IFEQ DEBUG
00201186  1239 00C00003           2640mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
0020118C  0801 0002               2641mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00201190  67F4                    2642mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00201192  13D9 00C00007           2643mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00201198                          2644mm     ENDC
00201198                          2645mm     
00201198                 FALSE    2646mm     IFNE DEBUG
00201198                          2647mm     ENDC
00201198                          2648mm 
00201198                          2649mm     ENDM
00201198  4EF9 0020117E           2650m     JMP LOOP_195
0020119E                          2651m EXIT_195
0020119E                          2652m     ENDM
0020119E  2208                    2653          MOVE.L A0,D1
002011A0  5981                    2654          SUB.L #4,D1
002011A2                          2655m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
002011A2                          2656mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002011A2                          2657mm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011A2                 TRUE     2658mm     IFEQ DEBUG
002011A2  1639 00C00003           2659mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011A8  0803 0002               2660mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011AC  67F4                    2661mm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
002011AE  13FC 0030 00C00007      2662mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002011B6                          2663mm     ENDC
002011B6                          2664mm     
002011B6                 FALSE    2665mm     IFNE DEBUG
002011B6                          2666mm     ENDC
002011B6                          2667mm 
002011B6                          2668mm     ENDM
002011B6                          2669mm     PRINT_CHAR #'x',D3
002011B6                          2670mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011B6                 TRUE     2671mm     IFEQ DEBUG
002011B6  1639 00C00003           2672mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011BC  0803 0002               2673mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011C0  67F4                    2674mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
002011C2  13FC 0078 00C00007      2675mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002011CA                          2676mm     ENDC
002011CA                          2677mm     
002011CA                 FALSE    2678mm     IFNE DEBUG
002011CA                          2679mm     ENDC
002011CA                          2680mm 
002011CA                          2681mm     ENDM
002011CA  7C07                    2682m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002011CC                          2683m LOOP_197
002011CC                          2684mm     BIN2HEX D1,D2,A1
002011CC  43F9 002014DA           2685mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
002011D2  E999                    2686mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002011D4  1401                    2687mm     MOVE.B D1,D2
002011D6  0282 0000000F           2688mm     ANDI.L #$F,D2
002011DC  1431 2000               2689mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002011E0                          2690mm     ENDM
002011E0                          2691mm     PRINT_CHAR D2,D3
002011E0                          2692mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011E0                 TRUE     2693mm     IFEQ DEBUG
002011E0  1639 00C00003           2694mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011E6  0803 0002               2695mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011EA  67F4                    2696mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
002011EC  13C2 00C00007           2697mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002011F2                          2698mm     ENDC
002011F2                          2699mm     
002011F2                 FALSE    2700mm     IFNE DEBUG
002011F2                          2701mm     ENDC
002011F2                          2702mm 
002011F2                          2703mm     ENDM
002011F2  57CE FFD8               2704m     DBEQ D6,LOOP_197
002011F6                          2705m     ENDM
002011F6                          2706m         PRINT_CRLF D3
002011F6                          2707mm     PRINT_CHAR #13,D3                           ; CR
002011F6                          2708mm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011F6                 TRUE     2709mm     IFEQ DEBUG
002011F6  1639 00C00003           2710mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011FC  0803 0002               2711mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201200  67F4                    2712mm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00201202  13FC 000D 00C00007      2713mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020120A                          2714mm     ENDC
0020120A                          2715mm     
0020120A                 FALSE    2716mm     IFNE DEBUG
0020120A                          2717mm     ENDC
0020120A                          2718mm 
0020120A                          2719mm     ENDM
0020120A                          2720mm     PRINT_CHAR #10,D3                           ; LF
0020120A                          2721mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020120A                 TRUE     2722mm     IFEQ DEBUG
0020120A  1639 00C00003           2723mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201210  0803 0002               2724mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201214  67F4                    2725mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00201216  13FC 000A 00C00007      2726mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020121E                          2727mm     ENDC
0020121E                          2728mm     
0020121E                 FALSE    2729mm     IFNE DEBUG
0020121E                          2730mm     ENDC
0020121E                          2731mm 
0020121E                          2732mm     ENDM
0020121E                          2733m     ENDM
0020121E                          2734  OK    
0020121E  5880                    2735          ADD.L #4,D0
00201220                          2736      ENDW
00201220  6000 FF2E               2737s     BRA _10000006
00201224                          2738s _10000007
00201224                          2739      
00201224  4EF9 00200188           2740      JMP MAIN_LOOP
0020122A                          2741    
0020122A                          2742  L
0020122A  7A00                    2743      MOVE.L #0,D5                                ; D5 will be the length  to write            
0020122C                          2744  
0020122C                          2745m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
0020122C                          2746m WAIT_FOR_READY_205                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122C                          2747m 
0020122C                 TRUE     2748m     IFEQ DEBUG
0020122C  1639 00C00003           2749m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201232  0803 0000               2750m         BTST #0,D3                              ; CHECK FOR CHARACTER
00201236  67F4                    2751m         BEQ WAIT_FOR_READY_205                      ; NOTHING, CHECK AGAIN
00201238                          2752m     ENDC
00201238                          2753m     
00201238                          2754mm     READ_CHAR D2
00201238                 TRUE     2755mm     IFEQ DEBUG
00201238  1439 00C00007           2756mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020123E                          2757mm     ENDC
0020123E                 FALSE    2758mm     IFNE DEBUG
0020123E                          2759mm     ENDC
0020123E                          2760mm      
0020123E  B43C 001B               2761mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201242  6700 EDC4               2762mm     BEQ START
00201246                          2763mm     ENDM
00201246                          2764m 
00201246                 TRUE     2765m     IFEQ DEBUG
00201246                          2766mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00201246                          2767mm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201246                 TRUE     2768mm     IFEQ DEBUG
00201246  1639 00C00003           2769mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020124C  0803 0002               2770mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201250  67F4                    2771mm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
00201252  13C2 00C00007           2772mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201258                          2773mm     ENDC
00201258                          2774mm     
00201258                 FALSE    2775mm     IFNE DEBUG
00201258                          2776mm     ENDC
00201258                          2777mm 
00201258                          2778mm     ENDM
00201258                          2779m     ENDC
00201258                          2780m     ENDM
00201258                          2781m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00201258  41F9 002014EA           2782m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020125E  0402 0030               2783m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201262  C4BC 000000FF           2784m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201268  1430 2000               2785m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020126C                          2786m     ENDM
0020126C  1A02                    2787      MOVE.B D2,D5                                ; put at bottom of D5
0020126E                          2788  
0020126E  3C3C 0002               2789      MOVE #2,D6                                  ; 3 bytes left to read
00201272                          2790      
00201272                          2791  READ_LENGTH
00201272  E98D                    2792      LSL.L #4,D5                                 ; make what we have so far more significant
00201274                          2793m     WAIT_CHAR D2,D3                             ; next character -> D2
00201274                          2794m WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201274                          2795m 
00201274                 TRUE     2796m     IFEQ DEBUG
00201274  1639 00C00003           2797m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020127A  0803 0000               2798m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020127E  67F4                    2799m         BEQ WAIT_FOR_READY_209                      ; NOTHING, CHECK AGAIN
00201280                          2800m     ENDC
00201280                          2801m     
00201280                          2802mm     READ_CHAR D2
00201280                 TRUE     2803mm     IFEQ DEBUG
00201280  1439 00C00007           2804mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201286                          2805mm     ENDC
00201286                 FALSE    2806mm     IFNE DEBUG
00201286                          2807mm     ENDC
00201286                          2808mm      
00201286  B43C 001B               2809mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020128A  6700 ED7C               2810mm     BEQ START
0020128E                          2811mm     ENDM
0020128E                          2812m 
0020128E                 TRUE     2813m     IFEQ DEBUG
0020128E                          2814mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0020128E                          2815mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020128E                 TRUE     2816mm     IFEQ DEBUG
0020128E  1639 00C00003           2817mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201294  0803 0002               2818mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201298  67F4                    2819mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0020129A  13C2 00C00007           2820mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002012A0                          2821mm     ENDC
002012A0                          2822mm     
002012A0                 FALSE    2823mm     IFNE DEBUG
002012A0                          2824mm     ENDC
002012A0                          2825mm 
002012A0                          2826mm     ENDM
002012A0                          2827m     ENDC
002012A0                          2828m     ENDM
002012A0                          2829m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002012A0  41F9 002014EA           2830m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002012A6  0402 0030               2831m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012AA  C4BC 000000FF           2832m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002012B0  1430 2000               2833m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002012B4                          2834m     ENDM
002012B4  8A02                    2835      OR.B D2,D5
002012B6  023C 00FB               2836      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
002012BA  57CE FFB6               2837      DBEQ D6,READ_LENGTH
002012BE                          2838          
002012BE                          2839m     PRINT_CRLF D3
002012BE                          2840mm     PRINT_CHAR #13,D3                           ; CR
002012BE                          2841mm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012BE                 TRUE     2842mm     IFEQ DEBUG
002012BE  1639 00C00003           2843mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002012C4  0803 0002               2844mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002012C8  67F4                    2845mm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
002012CA  13FC 000D 00C00007      2846mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002012D2                          2847mm     ENDC
002012D2                          2848mm     
002012D2                 FALSE    2849mm     IFNE DEBUG
002012D2                          2850mm     ENDC
002012D2                          2851mm 
002012D2                          2852mm     ENDM
002012D2                          2853mm     PRINT_CHAR #10,D3                           ; LF
002012D2                          2854mm WAIT_FOR_READY_215                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012D2                 TRUE     2855mm     IFEQ DEBUG
002012D2  1639 00C00003           2856mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002012D8  0803 0002               2857mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002012DC  67F4                    2858mm         BEQ WAIT_FOR_READY_215                      ; NO SPACE, CHECK AGAIN
002012DE  13FC 000A 00C00007      2859mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002012E6                          2860mm     ENDC
002012E6                          2861mm     
002012E6                 FALSE    2862mm     IFNE DEBUG
002012E6                          2863mm     ENDC
002012E6                          2864mm 
002012E6                          2865mm     ENDM
002012E6                          2866m     ENDM
002012E6                          2867  
002012E6  207C 00000000           2868      MOVE.L #ROM,A0                              ; start of ROM
002012EC                          2869      
002012EC  2247                    2870      MOVE.L D7,A1                                ; address accumulator -> address register
002012EE  7E00                    2871      MOVE.L #0,D7                                ; clear the now used address accumulator
002012F0                          2872      
002012F0  267C 00002AAA           2873      MOVE.L #$2AAA,A3
002012F6  36BC AAAA               2874      MOVE.W #$AAAA,(A3)
002012FA  267C 00001554           2875      MOVE.L #$1554,A3
00201300  36BC 5555               2876      MOVE.W #$5555,(A3)
00201304  267C 00002AAA           2877      MOVE.L #$2AAA,A3
0020130A  36BC 8080               2878      MOVE.W #$8080,(A3)
0020130E  267C 00002AAA           2879      MOVE.L #$2AAA,A3
00201314  36BC AAAA               2880      MOVE.W #$AAAA,(A3)
00201318  267C 00001554           2881      MOVE.L #$1554,A3
0020131E  36BC 5555               2882      MOVE.W #$5555,(A3)
00201322  267C 00002AAA           2883      MOVE.L #$2AAA,A3
00201328  36BC 2020               2884      MOVE.W #$2020,(A3)
0020132C                          2885      
0020132C  45F9 00201501           2886      LEA LOADING,A2                              ; important for timing
00201332                          2887m     PRINT_STR A2,D3
00201332                          2888m LOOP_216
00201332  0C12 0000               2889m     CMP.B #0,(A2)                               ; 0 -> DONE
00201336  6700 001A               2890m     BEQ EXIT_216
0020133A                          2891mm     PRINT_CHAR (A2)+,D3
0020133A                          2892mm WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133A                 TRUE     2893mm     IFEQ DEBUG
0020133A  1639 00C00003           2894mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201340  0803 0002               2895mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201344  67F4                    2896mm         BEQ WAIT_FOR_READY_217                      ; NO SPACE, CHECK AGAIN
00201346  13DA 00C00007           2897mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020134C                          2898mm     ENDC
0020134C                          2899mm     
0020134C                 FALSE    2900mm     IFNE DEBUG
0020134C                          2901mm     ENDC
0020134C                          2902mm 
0020134C                          2903mm     ENDM
0020134C  4EF9 00201332           2904m     JMP LOOP_216
00201352                          2905m EXIT_216
00201352                          2906m     ENDM
00201352                          2907  
00201352  023C 00FB               2908      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00201356                          2909      
00201356                          2910      WHILE D5 <GT> #0 DO
00201356                          2911s _10000008
00201356  BA7C 0000               2912s     CMP.W   #0,D5
0020135A  6F00 0020               2913s     BLE _10000009
0020135E  5585                    2914          SUB.L #2,D5
00201360                          2915            
00201360  13D1 00E00001           2916          MOVE.B (A1),DISPLAY
00201366  3091                    2917          MOVE.W (A1),(A0)                        ; write the data
00201368                          2918        
00201368                          2919  WAIT_FOR_COMPLETE
00201368  3410                    2920          MOVE.W (A0),D2
0020136A                          2921  
0020136A                          2922          IF D2 <NE> (A1) THEN
0020136A  B451                    2923s     CMP.W   (A1),D2
0020136C  6700 0008               2924s     BEQ _0000000A
00201370  4EF9 00201368           2925              JMP WAIT_FOR_COMPLETE
00201376                          2926          ENDI
00201376                          2927s _0000000A
00201376                          2928        
00201376  5488                    2929          ADD.L #2,A0
00201378  5489                    2930          ADD.L #2,A1
0020137A                          2931      ENDW  
0020137A  60DA                    2932s     BRA _10000008
0020137C                          2933s _10000009
0020137C                          2934      
0020137C  267C 00002AAA           2935      MOVE.L #$2AAA,A3
00201382  36BC AAAA               2936      MOVE.W #$AAAA,(A3)
00201386  267C 00001554           2937      MOVE.L #$1554,A3
0020138C  36BC 5555               2938      MOVE.W #$5555,(A3)
00201390  267C 00002AAA           2939      MOVE.L #$2AAA,A3
00201396  36BC A0A0               2940      MOVE.W #$A0A0,(A3)
0020139A                          2941              
0020139A  4EF9 00200188           2942      JMP MAIN_LOOP
002013A0                          2943          
002013A0                          2944  HEX_DIGIT
002013A0  E98F                    2945      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
002013A2                          2946m     HEX2BIN D2,D2,A0
002013A2  41F9 002014EA           2947m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002013A8  0402 0030               2948m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013AC  C4BC 000000FF           2949m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002013B2  1430 2000               2950m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002013B6                          2951m     ENDM
002013B6  8E02                    2952      OR.B D2,D7  
002013B8  4EF9 002001B0           2953      JMP GET_INPUT
002013BE                          2954  
002013BE  FFFF FFFF               2955      SIMHALT                                     ; halt simulator
002013C2                          2956  
002013C2                          2957  ; strings
002013C2= 4D 44 46 2D 6D 6F ...   2958  VERSION DC.B 'MDF-mon V1.45 (10/04/2021)',13,10,0
002013DF= 3F 20 48 65 6C 70 ...   2959  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201476= 48 75 68 3F 0D 0A 00    2960  HUH     DC.B 'Huh?',13,10,0
0020147D= 20 53 20 72 65 63 ...   2961  READ    DC.B ' S records read, start address = ',0
0020149F= 57 3A 20 55 6E 6B ...   2962  UNREC   DC.B 'W: Unknown Srec type: ',0
002014B6= 57 3A 20 43 53 20 ...   2963  CS_FAILURE   DC.B 'W: CS failure at ',0
002014C8= 57 3A 20 52 41 4D ...   2964  RAM_ERROR DC.B 'W: RAM error at: ',0
002014DA= 30 31 32 33 34 35 ...   2965  BIN2HEX_LUT DC.B '0123456789ABCDEF'
002014EA= 00 01 02 03 04 05 ...   2966  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201501= 4C 6F 61 64 69 6E ...   2967  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201515                          2968      
00201515                          2969      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         2014DA
CONTINUE_103        2009D8
CONTINUE_108        200A3C
CONTINUE_112        200A9A
CONTINUE_117        200B0E
CONTINUE_121        200B6C
CONTINUE_126        200BE6
CONTINUE_130        200C44
CONTINUE_135        200CA4
CONTINUE_139        200D02
CONTINUE_144        200D66
CONTINUE_148        200DC4
CONTINUE_159        200EA2
CONTINUE_163        200F00
CONTINUE_44         2004BC
CONTINUE_47         20050C
CONTINUE_51         200556
CONTINUE_55         2005B4
CONTINUE_60         20062C
CONTINUE_64         20068A
CONTINUE_69         2006EA
CONTINUE_73         200748
CONTINUE_78         2007BC
CONTINUE_82         20081A
CONTINUE_90         2008BC
CONTINUE_94         20091A
CONTINUE_99         20097A
CS_FAILURE          2014B6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       201018
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_152            200E3C
EXIT_170            200F94
EXIT_185            201092
EXIT_19             2002EA
EXIT_195            20119E
EXIT_21             200316
EXIT_216            201352
EXIT_23             200342
EXIT_5              200142
G                   201116
GET_INPUT           2001B0
H                   2002F0
HELP                2013DF
HEX2BIN             134
HEX2BIN_LUT         2014EA
HEX_DIGIT           2013A0
HUH                 201476
L                   20122A
LOADING             201501
LOOP_152            200E1C
LOOP_170            200F74
LOOP_172            200FBE
LOOP_180            201042
LOOP_185            201072
LOOP_187            2010BE
LOOP_19             2002CA
LOOP_195            20117E
LOOP_197            2011CC
LOOP_21             2002F6
LOOP_216            201332
LOOP_23             200322
LOOP_25             200376
LOOP_5              200122
MAIN_LOOP           200188
OK                  20121E
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           2014C8
READ                20147D
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         201272
RESET               200004
ROM                 0
S                   200498
STACK               200000
START               200008
UNREC               20149F
V                   20031C
VERSION             2013C2
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   201368
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_101  200992
WAIT_FOR_READY_103  2009BC
WAIT_FOR_READY_105  2009F0
WAIT_FOR_READY_108  200A20
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200A54
WAIT_FOR_READY_112  200A7E
WAIT_FOR_READY_114  200AB2
WAIT_FOR_READY_117  200AF2
WAIT_FOR_READY_119  200B26
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_121  200B50
WAIT_FOR_READY_123  200B84
WAIT_FOR_READY_126  200BCA
WAIT_FOR_READY_128  200BFE
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_130  200C28
WAIT_FOR_READY_132  200C5C
WAIT_FOR_READY_135  200C88
WAIT_FOR_READY_137  200CBC
WAIT_FOR_READY_139  200CE6
WAIT_FOR_READY_141  200D1A
WAIT_FOR_READY_144  200D4A
WAIT_FOR_READY_146  200D7E
WAIT_FOR_READY_148  200DA8
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_150  200DDC
WAIT_FOR_READY_153  200E24
WAIT_FOR_READY_154  200E3C
WAIT_FOR_READY_156  200E4E
WAIT_FOR_READY_157  200E62
WAIT_FOR_READY_159  200E86
WAIT_FOR_READY_161  200EBA
WAIT_FOR_READY_163  200EE4
WAIT_FOR_READY_165  200F18
WAIT_FOR_READY_168  200F40
WAIT_FOR_READY_169  200F54
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  200F7C
WAIT_FOR_READY_173  200F94
WAIT_FOR_READY_174  200FA8
WAIT_FOR_READY_176  200FD2
WAIT_FOR_READY_178  200FE8
WAIT_FOR_READY_179  200FFC
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  201018
WAIT_FOR_READY_182  20102C
WAIT_FOR_READY_184  201056
WAIT_FOR_READY_186  20107A
WAIT_FOR_READY_188  201094
WAIT_FOR_READY_189  2010A8
WAIT_FOR_READY_191  2010D2
WAIT_FOR_READY_193  2010E8
WAIT_FOR_READY_194  2010FC
WAIT_FOR_READY_196  201186
WAIT_FOR_READY_198  2011A2
WAIT_FOR_READY_199  2011B6
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  2011E0
WAIT_FOR_READY_203  2011F6
WAIT_FOR_READY_204  20120A
WAIT_FOR_READY_205  20122C
WAIT_FOR_READY_207  201246
WAIT_FOR_READY_209  201274
WAIT_FOR_READY_211  20128E
WAIT_FOR_READY_214  2012BE
WAIT_FOR_READY_215  2012D2
WAIT_FOR_READY_217  20133A
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DA
WAIT_FOR_READY_47   2004F0
WAIT_FOR_READY_49   200524
WAIT_FOR_READY_51   20053A
WAIT_FOR_READY_53   20056E
WAIT_FOR_READY_55   200598
WAIT_FOR_READY_57   2005CC
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200610
WAIT_FOR_READY_62   200644
WAIT_FOR_READY_64   20066E
WAIT_FOR_READY_66   2006A2
WAIT_FOR_READY_69   2006CE
WAIT_FOR_READY_71   200702
WAIT_FOR_READY_73   20072C
WAIT_FOR_READY_75   200760
WAIT_FOR_READY_78   2007A0
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   2007D4
WAIT_FOR_READY_82   2007FE
WAIT_FOR_READY_84   200832
WAIT_FOR_READY_87   200864
WAIT_FOR_READY_88   200878
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   2008A0
WAIT_FOR_READY_92   2008D4
WAIT_FOR_READY_94   2008FE
WAIT_FOR_READY_96   200932
WAIT_FOR_READY_99   20095E
WAIT_FOR_SRECORD    2004A0
Z                   20111E
_00000000           200606
_00000001           200E7C
_00000002           200896
_00000003           200E7C
_00000004           200BC0
_00000005           200E7C
_00000006           200E16
_00000007           200E7C
_00000008           201016
_00000009           201178
_0000000A           201376
_10000000           200794
_10000001           200864
_10000002           200AE6
_10000003           200BB6
_10000004           201126
_10000005           201148
_10000006           201150
_10000007           201224
_10000008           201356
_10000009           20137C
