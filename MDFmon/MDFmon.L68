00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 18:23:06

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; fix read
00000000                             9  ; Review for any other savings
00000000                            10  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            11  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            12  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            13  
00000000                            14  
00000000                            15  ; keep track of highest address hit during srec download
00000000                            16  ; implement backspace
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  ; fix being able to enter random chars when W'ing
00000000                            19  ; ram check at startup?  Not sure if this is a good idea!
00000000                            20  
00000000                            21      ORG  $0
00000000                            22      ;ORG  $200000
00000000                            23  
00000000  =00000000                 24  DEBUG               EQU 0
00000000                            25  
00000000                            26  ; constants
00000000  =00000000                 27  NULL                EQU 0
00000000  =00000009                 28  TAB                 EQU 9
00000000  =0000000D                 29  CR                  EQU 13
00000000  =0000000A                 30  LF                  EQU 10
00000000                            31  
00000000  =00000000                 32  ROM                 EQU $0
00000000  =00200000                 33  RAM                 EQU $200000
00000000                            34     
00000000  =00C00000                 35  DUART_BASE          EQU $C00000
00000000  =00000000                 36  DUART_MRA_          EQU $0
00000000  =00000001                 37  DUART_CSRA_         EQU $1
00000000  =00000001                 38  DUART_SRA_          EQU $1
00000000  =00000002                 39  DUART_CRA_          EQU $2
00000000  =00000003                 40  DUART_TXA_          EQU $3
00000000  =00000003                 41  DUART_RXA_          EQU $3
00000000  =00000004                 42  DUART_ACR_          EQU $4
00000000  =00000005                 43  DUART_IMR_          EQU $5
00000000  =00000008                 44  DUART_MRB_          EQU $8
00000000  =00000009                 45  DUART_CSRB_         EQU $9
00000000  =00000009                 46  DUART_SRB_          EQU $9
00000000  =0000000A                 47  DUART_CRB_          EQU $A
00000000  =0000000B                 48  DUART_TXB_          EQU $B
00000000  =0000000B                 49  DUART_RXB_          EQU $B
00000000  =0000000C                 50  DUART_IVR_          EQU $C
00000000  =0000000D                 51  DUART_OPCR_         EQU $D
00000000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00000000                            54  
00000000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            61  
00000000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            68  
00000000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            75  
00000000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 77  DISPLAY_            EQU $0
00000000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            79  
00000000                            80  ; macros
00000000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            82  ; the input register is changed during the process
00000000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            84  BIN2HEX MACRO
00000000                            85      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            86      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            87      MOVE.B \1,\2
00000000                            88      ANDI.L #$F,\2
00000000                            89      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            90      ENDM
00000000                            91  
00000000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            93  ; the input register is changed during the process
00000000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            95  HEX2BIN MACRO
00000000                            96      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            97      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            98      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            99      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                           100      ENDM
00000000                           101  
00000000                           102  ; send a single char to the serial port
00000000                           103  ; \1 = char to send, \2 = data register to use for status poll
00000000                           104  ; will stamp on D0 and D1 in debug mode
00000000                           105  PRINT_CHAR MACRO
00000000                           106  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           107      IFEQ DEBUG
00000000                           108          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           109          BTST #2,\2                              ; check for space to send
00000000                           110          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           111          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           112      ENDC
00000000                           113      
00000000                           114      IFNE DEBUG
00000000                           115          MOVE.B \1,D1
00000000                           116          MOVE.L #6,D0   
00000000                           117          TRAP #15                                ; write to terminal in simulator
00000000                           118      ENDC
00000000                           119  
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send CR,LF to the serial port
00000000                           123  ; \1 = data register to use for status poll, /2 = working address register
00000000                           124  PRINT_CRLF MACRO
00000000                           125      LEA CRLF,\2
00000000                           126      PRINT_STR \2,\1
00000000                           127      ENDM
00000000                           128  
00000000                           129  ; send C-style, zero terminated string to the serial port
00000000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           131  PRINT_STR MACRO
00000000                           132  LOOP\@
00000000                           133      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           134      BEQ EXIT\@
00000000                           135      PRINT_CHAR (\1)+,\2
00000000                           136      BRA LOOP\@
00000000                           137  EXIT\@
00000000                           138      ENDM
00000000                           139    
00000000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           142  PRINT_REG MACRO
00000000                           143      LEA ox,\5
00000000                           144      PRINT_STR \5,\2
00000000                           145      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           146  LOOP\@
00000000                           147      BIN2HEX \1,\3,\5
00000000                           148      PRINT_CHAR \3,\2
00000000                           149      DBEQ \4,LOOP\@
00000000                           150      ENDM
00000000                           151      
00000000                           152  ; wait for a char from the serial port
00000000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           154  ; will stamp on D0 and D1 in debug mode
00000000                           155  WAIT_CHAR MACRO
00000000                           156  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           157      IFEQ DEBUG
00000000                           158          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           159          BTST #0,\2                              ; check for character
00000000                           160          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           161      ENDC
00000000                           162      
00000000                           163      READ_CHAR \1
00000000                           164  
00000000                           165      IFEQ DEBUG
00000000                           166          PRINT_CHAR \1,\2                            ; echo it back
00000000                           167      ENDC
00000000                           168      ENDM
00000000                           169      
00000000                           170  ; read a char from the serial port - assumes that there is one!
00000000                           171  ; \ 1= data register for read char
00000000                           172  ; will stamp on D0 and D1 in debug mode
00000000                           173  READ_CHAR MACRO
00000000                           174      IFEQ DEBUG
00000000                           175          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           176      ENDC
00000000                           177      IFNE DEBUG
00000000                           178          MOVE.L #5,D0    
00000000                           179          TRAP #15                                    ; read from keyboard in simulator
00000000                           180          MOVE.L D1,\1
00000000                           181      ENDC
00000000                           182       
00000000                           183      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           184      BEQ START
00000000                           185      ENDM
00000000                           186      
00000000                           187      
00000000                           188  ; read data from the download serial port
00000000                           189  ; \ 1= data register for read char
00000000                           190  DOWNLOAD MACRO
00000000                           191  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           192  
00000000                           193      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           194      BTST #0,\1                                  ; check for character
00000000                           195      BEQ CONTINUE\@                              ; nothing, continue
00000000                           196   
00000000                           197      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           198  CONTINUE\@
00000000                           199      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           200      BTST #0,\1                                      ; check for character
00000000                           201      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           202      
00000000                           203      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           204      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           205      
00000000                           206      ENDM
00000000                           207      
00000000                           208  ; read two hex digits from the download serial port and convert to a byte
00000000                           209  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           210  DOWNLOAD_BYTE MACRO
00000000                           211      MOVE.B #2,\4
00000000                           212      WHILE.B \4 <GT> 0 DO
00000000                           213          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           214          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           215          PRINT_CHAR \2,\3
00000000                           216          HEX2BIN \2,\2,\6
00000000                           217          OR.B \2,\1
00000000                           218          SUB.B #1,\4
00000000                           219      ENDW
00000000                           220      
00000000                           221      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           222      MOVE.B \1,\2
00000000                           223      ADD.L \1,\5
00000000                           224  
00000000                           225      ENDM
00000000                           226      
00000000                           227  
00000000                           228  ; register catalogue
00000000                           229  ; D0 - used for simulator I/O
00000000                           230  ; D1 - used for simulator I/O
00000000                           231  ; D2 - read character
00000000                           232  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           233  ; D6 - working register used in R/W
00000000                           234  ; D7 - address accumulator, reset by download
00000000                           235  ; A0 - address of string to print 
00000000                           236  
00000000                           237  ; start vector
00000000= 00000000                 238  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 239  RESET    DC.L START                             ; RESET
00000008                           240      
00000008                           241  ; start of program  
00000008                           242  START
00000008  13FC 0000 00E00001       243      MOVE.B #0,DISPLAY
00000010                           244  
00000010                           245  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       246      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       247      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           248      
00000020                           249      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                250s     MOVE.W  #$50,D1
00000024  6000 000E                251s     BRA _20000001
00000028                           252s _20000000
00000028  13C1 00C00005            253          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     254          NOP
00000030                           255      ENDF
00000030  0441 0010                256s     SUB.W   #$10,D1
00000034                           257s _20000001
00000034  B27C 0010                258s     CMP.W   #$10,D1
00000038  6CEE                     259s     BGE _20000000
0000003A                           260  
0000003A                           261      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                262s     MOVE.W  #$50,D1
0000003E  6000 000E                263s     BRA _20000003
00000042                           264s _20000002
00000042  13C1 00C00015            265          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     266          NOP
0000004A                           267      ENDF
0000004A  0441 0010                268s     SUB.W   #$10,D1
0000004E                           269s _20000003
0000004E  B27C 0010                270s     CMP.W   #$10,D1
00000052  6CEE                     271s     BGE _20000002
00000054                           272    
00000054                           273  ;initialise UART
00000054  13FC 0000 00C00009       274      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       275      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       276      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           277  
0000006C                           278  ; channel A
0000006C  13FC 0013 00C00001       279      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       280      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       281      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       282      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           283  
0000008C                           284  ; channel B
0000008C  13FC 0013 00C00011       285      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       286      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       287      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       288      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           289  
000000AC                           290m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000AC                           291m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      292m     IFEQ DEBUG
000000AC  1639 00C00003            293m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000B2  0803 0002                294m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000B6  67F4                     295m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000B8  13F8 002E 00C00007       296m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000C0                           297m     ENDC
000000C0                           298m     
000000C0                 FALSE     299m     IFNE DEBUG
000000C0                           300m     ENDC
000000C0                           301m 
000000C0                           302m     ENDM
000000C0                           303  
000000C0  13FC 0001 00E00001       304      MOVE.B #1,DISPLAY
000000C8                           305         
000000C8                           306m     PRINT_CRLF D3,A0
000000C8  41F9 00000E2E            307m     LEA CRLF,A0
000000CE                           308mm     PRINT_STR A0,D3
000000CE                           309mm LOOP_3
000000CE  0C10 0000                310mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000D2  6700 0016                311mm     BEQ EXIT_3
000000D6                           312mmm     PRINT_CHAR (A0)+,D3
000000D6                           313mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D6                 TRUE      314mmm     IFEQ DEBUG
000000D6  1639 00C00003            315mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DC  0803 0002                316mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E0  67F4                     317mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
000000E2  13D8 00C00007            318mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000E8                           319mmm     ENDC
000000E8                           320mmm     
000000E8                 FALSE     321mmm     IFNE DEBUG
000000E8                           322mmm     ENDC
000000E8                           323mmm 
000000E8                           324mmm     ENDM
000000E8  60E4                     325mm     BRA LOOP_3
000000EA                           326mm EXIT_3
000000EA                           327mm     ENDM
000000EA                           328m     ENDM
000000EA                           329  
000000EA  41F9 00000CC2            330      LEA VERSION,A0
000000F0                           331m     PRINT_STR A0,D3
000000F0                           332m LOOP_5
000000F0  0C10 0000                333m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000F4  6700 0016                334m     BEQ EXIT_5
000000F8                           335mm     PRINT_CHAR (A0)+,D3
000000F8                           336mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F8                 TRUE      337mm     IFEQ DEBUG
000000F8  1639 00C00003            338mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FE  0803 0002                339mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000102  67F4                     340mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000104  13D8 00C00007            341mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000010A                           342mm     ENDC
0000010A                           343mm     
0000010A                 FALSE     344mm     IFNE DEBUG
0000010A                           345mm     ENDC
0000010A                           346mm 
0000010A                           347mm     ENDM
0000010A  60E4                     348m     BRA LOOP_5
0000010C                           349m EXIT_5
0000010C                           350m     ENDM
0000010C                           351m     PRINT_CRLF D3,A0
0000010C  41F9 00000E2E            352m     LEA CRLF,A0
00000112                           353mm     PRINT_STR A0,D3
00000112                           354mm LOOP_8
00000112  0C10 0000                355mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000116  6700 0016                356mm     BEQ EXIT_8
0000011A                           357mmm     PRINT_CHAR (A0)+,D3
0000011A                           358mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011A                 TRUE      359mmm     IFEQ DEBUG
0000011A  1639 00C00003            360mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000120  0803 0002                361mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000124  67F4                     362mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000126  13D8 00C00007            363mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000012C                           364mmm     ENDC
0000012C                           365mmm     
0000012C                 FALSE     366mmm     IFNE DEBUG
0000012C                           367mmm     ENDC
0000012C                           368mmm 
0000012C                           369mmm     ENDM
0000012C  60E4                     370mm     BRA LOOP_8
0000012E                           371mm EXIT_8
0000012E                           372mm     ENDM
0000012E                           373m     ENDM
0000012E                           374  
0000012E  7E00                     375      MOVE.L #0,D7                                    ; address accumulator
00000130                           376  
00000130  13FC 0002 00E00001       377      MOVE.B #2,DISPLAY
00000138                           378  MAIN_LOOP
00000138  41F9 00000E31            379      LEA PROMPT,A0
0000013E                           380m     PRINT_STR A0,D3
0000013E                           381m LOOP_10
0000013E  0C10 0000                382m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                383m     BEQ EXIT_10
00000146                           384mm     PRINT_CHAR (A0)+,D3
00000146                           385mm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      386mm     IFEQ DEBUG
00000146  1639 00C00003            387mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                388mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     389mm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            390mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           391mm     ENDC
00000158                           392mm     
00000158                 FALSE     393mm     IFNE DEBUG
00000158                           394mm     ENDC
00000158                           395mm 
00000158                           396mm     ENDM
00000158  60E4                     397m     BRA LOOP_10
0000015A                           398m EXIT_10
0000015A                           399m     ENDM
0000015A                           400      
0000015A                           401  GET_INPUT
0000015A                           402m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015A                           403m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015A                 TRUE      404m     IFEQ DEBUG
0000015A  1639 00C00003            405m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000160  0803 0000                406m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000164  67F4                     407m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000166                           408m     ENDC
00000166                           409m     
00000166                           410mm     READ_CHAR D2
00000166                 TRUE      411mm     IFEQ DEBUG
00000166  1439 00C00007            412mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000016C                           413mm     ENDC
0000016C                 FALSE     414mm     IFNE DEBUG
0000016C                           415mm     ENDC
0000016C                           416mm      
0000016C  B43C 001B                417mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000170  6700 FE96                418mm     BEQ START
00000174                           419mm     ENDM
00000174                           420m 
00000174                 TRUE      421m     IFEQ DEBUG
00000174                           422mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000174                           423mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000174                 TRUE      424mm     IFEQ DEBUG
00000174  1639 00C00003            425mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017A  0803 0002                426mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000017E  67F4                     427mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
00000180  13C2 00C00007            428mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000186                           429mm     ENDC
00000186                           430mm     
00000186                 FALSE     431mm     IFNE DEBUG
00000186                           432mm     ENDC
00000186                           433mm 
00000186                           434mm     ENDM
00000186                           435m     ENDC
00000186                           436m     ENDM
00000186                           437      
00000186                           438      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000186  B43C 0030                439s     CMP.B   #'0',D2
0000018A  6D00 000E                440s     BLT _00000000
0000018E  B43C 0039                441s     CMP.B   #'9',D2
00000192  6E00 0006                442s     BGT _00000000
00000196  6000 0B0A                443          BRA HEX_DIGIT
0000019A                           444      ENDI
0000019A                           445s _00000000
0000019A                           446      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019A  B43C 0041                447s     CMP.B   #'A',D2
0000019E  6D00 000E                448s     BLT _00000001
000001A2  B43C 0046                449s     CMP.B   #'F',D2
000001A6  6E00 0006                450s     BGT _00000001
000001AA  6000 0AF6                451          BRA HEX_DIGIT
000001AE                           452      ENDI
000001AE                           453s _00000001
000001AE                           454          
000001AE  B43C 0077                455      CMP.B #'w',D2
000001B2  6700 012C                456      BEQ W
000001B6                           457      
000001B6  B43C 006C                458      CMP.B #'l',D2
000001BA  6700 09E6                459      BEQ L 
000001BE                           460  
000001BE                           461m     PRINT_CRLF D3,A0
000001BE  41F9 00000E2E            462m     LEA CRLF,A0
000001C4                           463mm     PRINT_STR A0,D3
000001C4                           464mm LOOP_16
000001C4  0C10 0000                465mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001C8  6700 0016                466mm     BEQ EXIT_16
000001CC                           467mmm     PRINT_CHAR (A0)+,D3
000001CC                           468mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CC                 TRUE      469mmm     IFEQ DEBUG
000001CC  1639 00C00003            470mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001D2  0803 0002                471mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D6  67F4                     472mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
000001D8  13D8 00C00007            473mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001DE                           474mmm     ENDC
000001DE                           475mmm     
000001DE                 FALSE     476mmm     IFNE DEBUG
000001DE                           477mmm     ENDC
000001DE                           478mmm 
000001DE                           479mmm     ENDM
000001DE  60E4                     480mm     BRA LOOP_16
000001E0                           481mm EXIT_16
000001E0                           482mm     ENDM
000001E0                           483m     ENDM
000001E0                           484   
000001E0  B43C 003F                485      CMP.B #'?',D2
000001E4  6700 0050                486      BEQ H
000001E8                           487   
000001E8  B43C 0076                488      CMP.B #'v',D2
000001EC  6700 0052                489      BEQ V
000001F0                           490      
000001F0  B43C 0072                491      CMP.B #'r',D2
000001F4  6700 0070                492      BEQ R
000001F8                           493  
000001F8  B43C 0073                494      CMP.B #'s',D2
000001FC  6700 015A                495      BEQ S
00000200                           496  
00000200  B43C 0067                497      CMP.B #'g',D2
00000204  6700 08AA                498      BEQ G   
00000208                           499  
00000208  B43C 007A                500      CMP.B #'z',D2
0000020C  6700 08AA                501      BEQ Z   
00000210                           502  
00000210  41F9 00000D8F            503      LEA HUH,A0
00000216                           504m     PRINT_STR A0,D3
00000216                           505m LOOP_18
00000216  0C10 0000                506m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000021A  6700 0016                507m     BEQ EXIT_18
0000021E                           508mm     PRINT_CHAR (A0)+,D3
0000021E                           509mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021E                 TRUE      510mm     IFEQ DEBUG
0000021E  1639 00C00003            511mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000224  0803 0002                512mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000228  67F4                     513mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000022A  13D8 00C00007            514mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000230                           515mm     ENDC
00000230                           516mm     
00000230                 FALSE     517mm     IFNE DEBUG
00000230                           518mm     ENDC
00000230                           519mm 
00000230                           520mm     ENDM
00000230  60E4                     521m     BRA LOOP_18
00000232                           522m EXIT_18
00000232                           523m     ENDM
00000232                           524                         
00000232  6000 FF04                525      BRA MAIN_LOOP
00000236                           526      
00000236                           527  ; commands
00000236                           528  H   
00000236  41F9 00000CDF            529      LEA HELP,A0
0000023C  6000 0008                530      BRA PRINTSTR
00000240                           531  
00000240                           532  V   
00000240  41F9 00000CC2            533      LEA VERSION,A0
00000246                           534  PRINTSTR
00000246                           535m     PRINT_STR A0,D3       
00000246                           536m LOOP_20
00000246  0C10 0000                537m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024A  6700 0016                538m     BEQ EXIT_20
0000024E                           539mm     PRINT_CHAR (A0)+,D3
0000024E                           540mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024E                 TRUE      541mm     IFEQ DEBUG
0000024E  1639 00C00003            542mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000254  0803 0002                543mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000258  67F4                     544mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000025A  13D8 00C00007            545mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000260                           546mm     ENDC
00000260                           547mm     
00000260                 FALSE     548mm     IFNE DEBUG
00000260                           549mm     ENDC
00000260                           550mm 
00000260                           551mm     ENDM
00000260  60E4                     552m     BRA LOOP_20
00000262                           553m EXIT_20
00000262                           554m     ENDM
00000262  6000 FED4                555      BRA MAIN_LOOP
00000266                           556      
00000266                           557  R   
00000266  2047                     558      MOVE.L D7,A0                                    ; address accumulator -> address register
00000268  7E00                     559      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000026A  2A10                     560      MOVE.L (A0),D5                                  ; read the memory and print it
0000026C                           561m     PRINT_REG D5,D3,D7,D6,A0
0000026C  41F9 00000E34            562m     LEA OX,A0
00000272                           563mm     PRINT_STR A0,D3
00000272                           564mm LOOP_23
00000272  0C10 0000                565mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000276  6700 0016                566mm     BEQ EXIT_23
0000027A                           567mmm     PRINT_CHAR (A0)+,D3
0000027A                           568mmm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027A                 TRUE      569mmm     IFEQ DEBUG
0000027A  1639 00C00003            570mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000280  0803 0002                571mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000284  67F4                     572mmm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000286  13D8 00C00007            573mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028C                           574mmm     ENDC
0000028C                           575mmm     
0000028C                 FALSE     576mmm     IFNE DEBUG
0000028C                           577mmm     ENDC
0000028C                           578mmm 
0000028C                           579mmm     ENDM
0000028C  60E4                     580mm     BRA LOOP_23
0000028E                           581mm EXIT_23
0000028E                           582mm     ENDM
0000028E  7C07                     583m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000290                           584m LOOP_22
00000290                           585mm     BIN2HEX D5,D7,A0
00000290  41F9 00000DF3            586mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000296  E99D                     587mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000298  1E05                     588mm     MOVE.B D5,D7
0000029A  0287 0000000F            589mm     ANDI.L #$F,D7
000002A0  1E30 7000                590mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
000002A4                           591mm     ENDM
000002A4                           592mm     PRINT_CHAR D7,D3
000002A4                           593mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002A4                 TRUE      594mm     IFEQ DEBUG
000002A4  1639 00C00003            595mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002AA  0803 0002                596mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002AE  67F4                     597mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002B0  13C7 00C00007            598mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002B6                           599mm     ENDC
000002B6                           600mm     
000002B6                 FALSE     601mm     IFNE DEBUG
000002B6                           602mm     ENDC
000002B6                           603mm 
000002B6                           604mm     ENDM
000002B6  57CE FFD8                605m     DBEQ D6,LOOP_22
000002BA                           606m     ENDM
000002BA                           607m     PRINT_CRLF D3,A0
000002BA  41F9 00000E2E            608m     LEA CRLF,A0
000002C0                           609mm     PRINT_STR A0,D3
000002C0                           610mm LOOP_28
000002C0  0C10 0000                611mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002C4  6700 0016                612mm     BEQ EXIT_28
000002C8                           613mmm     PRINT_CHAR (A0)+,D3
000002C8                           614mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      615mmm     IFEQ DEBUG
000002C8  1639 00C00003            616mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002CE  0803 0002                617mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D2  67F4                     618mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            619mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002DA                           620mmm     ENDC
000002DA                           621mmm     
000002DA                 FALSE     622mmm     IFNE DEBUG
000002DA                           623mmm     ENDC
000002DA                           624mmm 
000002DA                           625mmm     ENDM
000002DA  60E4                     626mm     BRA LOOP_28
000002DC                           627mm EXIT_28
000002DC                           628mm     ENDM
000002DC                           629m     ENDM
000002DC  6000 FE5A                630      BRA MAIN_LOOP
000002E0                           631  
000002E0                           632  W
000002E0  3C3C 0007                633      MOVE #7,D6                                      ; 7 bytes left to read
000002E4                           634      
000002E4                           635  READ_DATA_TO_POKE
000002E4  E98D                     636      LSL.L #4,D5                                     ; make what we have so far more significant
000002E6                           637m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002E6                           638m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E6                 TRUE      639m     IFEQ DEBUG
000002E6  1639 00C00003            640m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EC  0803 0000                641m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002F0  67F4                     642m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
000002F2                           643m     ENDC
000002F2                           644m     
000002F2                           645mm     READ_CHAR D2
000002F2                 TRUE      646mm     IFEQ DEBUG
000002F2  1439 00C00007            647mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002F8                           648mm     ENDC
000002F8                 FALSE     649mm     IFNE DEBUG
000002F8                           650mm     ENDC
000002F8                           651mm      
000002F8  B43C 001B                652mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002FC  6700 FD0A                653mm     BEQ START
00000300                           654mm     ENDM
00000300                           655m 
00000300                 TRUE      656m     IFEQ DEBUG
00000300                           657mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000300                           658mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000300                 TRUE      659mm     IFEQ DEBUG
00000300  1639 00C00003            660mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000306  0803 0002                661mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000030A  67F4                     662mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
0000030C  13C2 00C00007            663mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000312                           664mm     ENDC
00000312                           665mm     
00000312                 FALSE     666mm     IFNE DEBUG
00000312                           667mm     ENDC
00000312                           668mm 
00000312                           669mm     ENDM
00000312                           670m     ENDC
00000312                           671m     ENDM
00000312                           672m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000312  41F9 00000E03            673m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000318  0402 0030                674m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000031C  C4BC 000000FF            675m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000322  1430 2000                676m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000326                           677m     ENDM
00000326  8A02                     678      OR.B D2,D5
00000328  57CE FFBA                679      DBEQ D6,READ_DATA_TO_POKE
0000032C                           680      
0000032C  2047                     681      MOVE.L D7,A0                                    ; address accumulator -> address register
0000032E  7E00                     682      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000330                           683      
00000330  2085                     684      MOVE.L D5,(A0)                                  ; write the data
00000332                           685  
00000332                           686m     PRINT_CRLF D3,A0
00000332  41F9 00000E2E            687m     LEA CRLF,A0
00000338                           688mm     PRINT_STR A0,D3
00000338                           689mm LOOP_35
00000338  0C10 0000                690mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000033C  6700 0016                691mm     BEQ EXIT_35
00000340                           692mmm     PRINT_CHAR (A0)+,D3
00000340                           693mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000340                 TRUE      694mmm     IFEQ DEBUG
00000340  1639 00C00003            695mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000346  0803 0002                696mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000034A  67F4                     697mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0000034C  13D8 00C00007            698mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000352                           699mmm     ENDC
00000352                           700mmm     
00000352                 FALSE     701mmm     IFNE DEBUG
00000352                           702mmm     ENDC
00000352                           703mmm 
00000352                           704mmm     ENDM
00000352  60E4                     705mm     BRA LOOP_35
00000354                           706mm EXIT_35
00000354                           707mm     ENDM
00000354                           708m     ENDM
00000354  6000 FDE2                709      BRA MAIN_LOOP
00000358                           710  
00000358                           711  ; register map for S
00000358                           712  ; A0 - start address
00000358                           713  ; A1 - offset
00000358                           714  ; A2 - next address to write
00000358                           715  ; A3 - next location (jmp)
00000358                           716  ; A4 - Working Address Register
00000358                           717  ; D0 - record count
00000358                           718  ; D1 - 'S', record type, data byte
00000358                           719  ; D2 - checksum
00000358                           720  ; D3 - data byte count
00000358                           721  ; D4 - read address, moved into A2
00000358                           722  ; D5 - temp
00000358                           723  ; D6 - temp
00000358                           724  ; D7 - temp
00000358                           725  S
00000358  2078 0000                726      MOVE.L 0,A0                                     ; start address -> A0
0000035C  2247                     727      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000035E                           728      
0000035E  7000                     729      MOVE.L #0,D0                                    ; count of records read -> D0
00000360                           730          
00000360                           731  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000360                           732m     DOWNLOAD D1                 
00000360                           733m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000360                           734m 
00000360  1239 00C00003            735m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000366  0801 0000                736m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000036A  6700 0010                737m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
0000036E                           738m  
0000036E                           739mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000036E                 TRUE      740mm     IFEQ DEBUG
0000036E  1239 00C00007            741mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000374                           742mm     ENDC
00000374                 FALSE     743mm     IFNE DEBUG
00000374                           744mm     ENDC
00000374                           745mm      
00000374  B23C 001B                746mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000378  6700 FC8E                747mm     BEQ START
0000037C                           748mm     ENDM
0000037C                           749m CONTINUE_37
0000037C  1239 00C00013            750m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000382  0801 0000                751m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000386  67D8                     752m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
00000388                           753m     
00000388  1239 00C00017            754m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000038E  13C1 00E00001            755m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000394                           756m     
00000394                           757m     ENDM
00000394  B23C 0053                758      CMP.B #'S',D1                                   ; found S?    
00000398  66C6                     759      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000039A                           760      
0000039A                           761m     PRINT_CHAR #'S',D5                            ; print the S
0000039A                           762m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039A                 TRUE      763m     IFEQ DEBUG
0000039A  1A39 00C00003            764m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003A0  0805 0002                765m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003A4  67F4                     766m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003A6  13FC 0053 00C00007       767m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003AE                           768m     ENDC
000003AE                           769m     
000003AE                 FALSE     770m     IFNE DEBUG
000003AE                           771m     ENDC
000003AE                           772m 
000003AE                           773m     ENDM
000003AE  5280                     774      ADD.L #1,D0                                     ; read another S record, increment count
000003B0                           775      
000003B0                           776m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003B0                           777m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B0                           778m 
000003B0  1239 00C00003            779m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003B6  0801 0000                780m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003BA  6700 0010                781m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003BE                           782m  
000003BE                           783mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003BE                 TRUE      784mm     IFEQ DEBUG
000003BE  1239 00C00007            785mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003C4                           786mm     ENDC
000003C4                 FALSE     787mm     IFNE DEBUG
000003C4                           788mm     ENDC
000003C4                           789mm      
000003C4  B23C 001B                790mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003C8  6700 FC3E                791mm     BEQ START
000003CC                           792mm     ENDM
000003CC                           793m CONTINUE_40
000003CC  1239 00C00013            794m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003D2  0801 0000                795m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003D6  67D8                     796m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
000003D8                           797m     
000003D8  1239 00C00017            798m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003DE  13C1 00E00001            799m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003E4                           800m     
000003E4                           801m     ENDM
000003E4                           802m     PRINT_CHAR D1,D5
000003E4                           803m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E4                 TRUE      804m     IFEQ DEBUG
000003E4  1A39 00C00003            805m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003EA  0805 0002                806m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003EE  67F4                     807m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
000003F0  13C1 00C00007            808m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003F6                           809m     ENDC
000003F6                           810m     
000003F6                 FALSE     811m     IFNE DEBUG
000003F6                           812m     ENDC
000003F6                           813m 
000003F6                           814m     ENDM
000003F6                           815  
000003F6  7400                     816      MOVE.L #0,D2                                    ; clear the checksum
000003F8                           817  
000003F8                           818m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003F8  1E3C 0002                819m     MOVE.B #2,D7
000003FC                           820m     WHILE.B D7 <GT> 0 DO
000003FC                           821ms _10000000
000003FC  BE38 0000                822ms     CMP.B   0,D7
00000400  6F00 0064                823ms     BLE _10000001
00000404  E98B                     824m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000406                           825mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000406                           826mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000406                           827mm 
00000406  1A39 00C00003            828mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000040C  0805 0000                829mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000410  6700 0010                830mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000414                           831mm  
00000414                           832mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000414                 TRUE      833mmm     IFEQ DEBUG
00000414  1A39 00C00007            834mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000041A                           835mmm     ENDC
0000041A                 FALSE     836mmm     IFNE DEBUG
0000041A                           837mmm     ENDC
0000041A                           838mmm      
0000041A  BA3C 001B                839mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000041E  6700 FBE8                840mmm     BEQ START
00000422                           841mmm     ENDM
00000422                           842mm CONTINUE_44
00000422  1A39 00C00013            843mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000428  0805 0000                844mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000042C  67D8                     845mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0000042E                           846mm     
0000042E  1A39 00C00017            847mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000434  13C5 00E00001            848mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000043A                           849mm     
0000043A                           850mm     ENDM
0000043A                           851mm         PRINT_CHAR D5,D6
0000043A                           852mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043A                 TRUE      853mm     IFEQ DEBUG
0000043A  1C39 00C00003            854mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000440  0806 0002                855mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000444  67F4                     856mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000446  13C5 00C00007            857mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000044C                           858mm     ENDC
0000044C                           859mm     
0000044C                 FALSE     860mm     IFNE DEBUG
0000044C                           861mm     ENDC
0000044C                           862mm 
0000044C                           863mm     ENDM
0000044C                           864mm         HEX2BIN D5,D5,A4
0000044C  49F9 00000E03            865mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000452  0405 0030                866mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000456  CABC 000000FF            867mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000045C  1A34 5000                868mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000460                           869mm     ENDM
00000460  8605                     870m         OR.B D5,D3
00000462  5307                     871m         SUB.B #1,D7
00000464                           872m     ENDW
00000464  6096                     873ms     BRA _10000000
00000466                           874ms _10000001
00000466                           875m     
00000466  7A00                     876m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000468  1A03                     877m     MOVE.B D3,D5
0000046A  D483                     878m     ADD.L D3,D2
0000046C                           879m 
0000046C                           880m     ENDM
0000046C                           881  
0000046C                           882      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000046C  B23C 0030                883s     CMP.B   #'0',D1
00000470  6600 002C                884s     BNE.L   _00000002
00000474                           885m         PRINT_CRLF D5,A4
00000474  49F9 00000E2E            886m     LEA CRLF,A4
0000047A                           887mm     PRINT_STR A4,D5
0000047A                           888mm LOOP_49
0000047A  0C14 0000                889mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000047E  6700 0016                890mm     BEQ EXIT_49
00000482                           891mmm     PRINT_CHAR (A4)+,D5
00000482                           892mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000482                 TRUE      893mmm     IFEQ DEBUG
00000482  1A39 00C00003            894mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000488  0805 0002                895mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000048C  67F4                     896mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
0000048E  13DC 00C00007            897mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000494                           898mmm     ENDC
00000494                           899mmm     
00000494                 FALSE     900mmm     IFNE DEBUG
00000494                           901mmm     ENDC
00000494                           902mmm 
00000494                           903mmm     ENDM
00000494  60E4                     904mm     BRA LOOP_49
00000496                           905mm EXIT_49
00000496                           906mm     ENDM
00000496                           907m     ENDM
00000496  6000 FEC8                908          BRA WAIT_FOR_SRECORD
0000049A                           909      ELSE
0000049A  6000 03F8                910s     BRA _00000003
0000049E                           911s _00000002
0000049E                           912          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
0000049E  B23C 0031                913s     CMP.B   #'1',D1
000004A2  6708                     914s     BEQ.S   _00000004
000004A4  B23C 0032                915s     CMP.B   #'2',D1
000004A8  6600 01FC                916s     BNE.L   _00000005
000004AC                           917s _00000004
000004AC  5783                     918              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004AE                           919      
000004AE  7800                     920              MOVE.L #0,D4                            ; read two bytes of address
000004B0                           921m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004B0  1E3C 0002                922m     MOVE.B #2,D7
000004B4                           923m     WHILE.B D7 <GT> 0 DO
000004B4                           924ms _10000002
000004B4  BE38 0000                925ms     CMP.B   0,D7
000004B8  6F00 0064                926ms     BLE _10000003
000004BC  E98C                     927m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004BE                           928mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004BE                           929mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                           930mm 
000004BE  1A39 00C00003            931mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004C4  0805 0000                932mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004C8  6700 0010                933mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
000004CC                           934mm  
000004CC                           935mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004CC                 TRUE      936mmm     IFEQ DEBUG
000004CC  1A39 00C00007            937mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004D2                           938mmm     ENDC
000004D2                 FALSE     939mmm     IFNE DEBUG
000004D2                           940mmm     ENDC
000004D2                           941mmm      
000004D2  BA3C 001B                942mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004D6  6700 FB30                943mmm     BEQ START
000004DA                           944mmm     ENDM
000004DA                           945mm CONTINUE_52
000004DA  1A39 00C00013            946mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004E0  0805 0000                947mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004E4  67D8                     948mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
000004E6                           949mm     
000004E6  1A39 00C00017            950mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004EC  13C5 00E00001            951mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004F2                           952mm     
000004F2                           953mm     ENDM
000004F2                           954mm         PRINT_CHAR D5,D6
000004F2                           955mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      956mm     IFEQ DEBUG
000004F2  1C39 00C00003            957mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004F8  0806 0002                958mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004FC  67F4                     959mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
000004FE  13C5 00C00007            960mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000504                           961mm     ENDC
00000504                           962mm     
00000504                 FALSE     963mm     IFNE DEBUG
00000504                           964mm     ENDC
00000504                           965mm 
00000504                           966mm     ENDM
00000504                           967mm         HEX2BIN D5,D5,A4
00000504  49F9 00000E03            968mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000050A  0405 0030                969mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000050E  CABC 000000FF            970mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000514  1A34 5000                971mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000518                           972mm     ENDM
00000518  8805                     973m         OR.B D5,D4
0000051A  5307                     974m         SUB.B #1,D7
0000051C                           975m     ENDW
0000051C  6096                     976ms     BRA _10000002
0000051E                           977ms _10000003
0000051E                           978m     
0000051E  7A00                     979m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000520  1A04                     980m     MOVE.B D4,D5
00000522  D484                     981m     ADD.L D4,D2
00000524                           982m 
00000524                           983m     ENDM
00000524                           984m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000524  1E3C 0002                985m     MOVE.B #2,D7
00000528                           986m     WHILE.B D7 <GT> 0 DO
00000528                           987ms _10000004
00000528  BE38 0000                988ms     CMP.B   0,D7
0000052C  6F00 0064                989ms     BLE _10000005
00000530  E98C                     990m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000532                           991mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000532                           992mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000532                           993mm 
00000532  1A39 00C00003            994mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000538  0805 0000                995mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000053C  6700 0010                996mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000540                           997mm  
00000540                           998mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000540                 TRUE      999mmm     IFEQ DEBUG
00000540  1A39 00C00007           1000mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000546                          1001mmm     ENDC
00000546                 FALSE    1002mmm     IFNE DEBUG
00000546                          1003mmm     ENDC
00000546                          1004mmm      
00000546  BA3C 001B               1005mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000054A  6700 FABC               1006mmm     BEQ START
0000054E                          1007mmm     ENDM
0000054E                          1008mm CONTINUE_57
0000054E  1A39 00C00013           1009mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000554  0805 0000               1010mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000558  67D8                    1011mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000055A                          1012mm     
0000055A  1A39 00C00017           1013mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000560  13C5 00E00001           1014mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000566                          1015mm     
00000566                          1016mm     ENDM
00000566                          1017mm         PRINT_CHAR D5,D6
00000566                          1018mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000566                 TRUE     1019mm     IFEQ DEBUG
00000566  1C39 00C00003           1020mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000056C  0806 0002               1021mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000570  67F4                    1022mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
00000572  13C5 00C00007           1023mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000578                          1024mm     ENDC
00000578                          1025mm     
00000578                 FALSE    1026mm     IFNE DEBUG
00000578                          1027mm     ENDC
00000578                          1028mm 
00000578                          1029mm     ENDM
00000578                          1030mm         HEX2BIN D5,D5,A4
00000578  49F9 00000E03           1031mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000057E  0405 0030               1032mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000582  CABC 000000FF           1033mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000588  1A34 5000               1034mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000058C                          1035mm     ENDM
0000058C  8805                    1036m         OR.B D5,D4
0000058E  5307                    1037m         SUB.B #1,D7
00000590                          1038m     ENDW
00000590  6096                    1039ms     BRA _10000004
00000592                          1040ms _10000005
00000592                          1041m     
00000592  7A00                    1042m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000594  1A04                    1043m     MOVE.B D4,D5
00000596  D484                    1044m     ADD.L D4,D2
00000598                          1045m 
00000598                          1046m     ENDM
00000598                          1047              
00000598                          1048              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000598  B23C 0032               1049s     CMP.B   #'2',D1
0000059C  6600 0078               1050s     BNE.L   _00000006
000005A0  5383                    1051                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005A2                          1052m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005A2  1E3C 0002               1053m     MOVE.B #2,D7
000005A6                          1054m     WHILE.B D7 <GT> 0 DO
000005A6                          1055ms _10000006
000005A6  BE38 0000               1056ms     CMP.B   0,D7
000005AA  6F00 0064               1057ms     BLE _10000007
000005AE  E98C                    1058m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005B0                          1059mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005B0                          1060mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                          1061mm 
000005B0  1A39 00C00003           1062mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005B6  0805 0000               1063mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005BA  6700 0010               1064mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005BE                          1065mm  
000005BE                          1066mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005BE                 TRUE     1067mmm     IFEQ DEBUG
000005BE  1A39 00C00007           1068mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005C4                          1069mmm     ENDC
000005C4                 FALSE    1070mmm     IFNE DEBUG
000005C4                          1071mmm     ENDC
000005C4                          1072mmm      
000005C4  BA3C 001B               1073mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005C8  6700 FA3E               1074mmm     BEQ START
000005CC                          1075mmm     ENDM
000005CC                          1076mm CONTINUE_62
000005CC  1A39 00C00013           1077mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005D2  0805 0000               1078mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D6  67D8                    1079mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
000005D8                          1080mm     
000005D8  1A39 00C00017           1081mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005DE  13C5 00E00001           1082mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005E4                          1083mm     
000005E4                          1084mm     ENDM
000005E4                          1085mm         PRINT_CHAR D5,D6
000005E4                          1086mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E4                 TRUE     1087mm     IFEQ DEBUG
000005E4  1C39 00C00003           1088mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005EA  0806 0002               1089mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005EE  67F4                    1090mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
000005F0  13C5 00C00007           1091mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005F6                          1092mm     ENDC
000005F6                          1093mm     
000005F6                 FALSE    1094mm     IFNE DEBUG
000005F6                          1095mm     ENDC
000005F6                          1096mm 
000005F6                          1097mm     ENDM
000005F6                          1098mm         HEX2BIN D5,D5,A4
000005F6  49F9 00000E03           1099mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005FC  0405 0030               1100mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000600  CABC 000000FF           1101mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000606  1A34 5000               1102mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000060A                          1103mm     ENDM
0000060A  8805                    1104m         OR.B D5,D4
0000060C  5307                    1105m         SUB.B #1,D7
0000060E                          1106m     ENDW
0000060E  6096                    1107ms     BRA _10000006
00000610                          1108ms _10000007
00000610                          1109m     
00000610  7A00                    1110m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000612  1A04                    1111m     MOVE.B D4,D5
00000614  D484                    1112m     ADD.L D4,D2
00000616                          1113m 
00000616                          1114m     ENDM
00000616                          1115              ENDI
00000616                          1116s _00000006
00000616                          1117              
00000616  2444                    1118                  MOVE.L D4,A2                            ; put the address in an address register
00000618  D5C9                    1119              ADD.L A1,A2                             ; add in the offset
0000061A                          1120  
0000061A                          1121              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000061A                          1122s _10000008
0000061A  B63C 0000               1123s     CMP.B   #0,D3
0000061E  6F00 007E               1124s     BLE _10000009
00000622                          1125m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000622  1E3C 0002               1126m     MOVE.B #2,D7
00000626                          1127m     WHILE.B D7 <GT> 0 DO
00000626                          1128ms _1000000A
00000626  BE38 0000               1129ms     CMP.B   0,D7
0000062A  6F00 0064               1130ms     BLE _1000000B
0000062E  E989                    1131m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000630                          1132mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000630                          1133mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000630                          1134mm 
00000630  1A39 00C00003           1135mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000636  0805 0000               1136mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000063A  6700 0010               1137mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
0000063E                          1138mm  
0000063E                          1139mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000063E                 TRUE     1140mmm     IFEQ DEBUG
0000063E  1A39 00C00007           1141mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000644                          1142mmm     ENDC
00000644                 FALSE    1143mmm     IFNE DEBUG
00000644                          1144mmm     ENDC
00000644                          1145mmm      
00000644  BA3C 001B               1146mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000648  6700 F9BE               1147mmm     BEQ START
0000064C                          1148mmm     ENDM
0000064C                          1149mm CONTINUE_67
0000064C  1A39 00C00013           1150mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000652  0805 0000               1151mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000656  67D8                    1152mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000658                          1153mm     
00000658  1A39 00C00017           1154mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000065E  13C5 00E00001           1155mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000664                          1156mm     
00000664                          1157mm     ENDM
00000664                          1158mm         PRINT_CHAR D5,D6
00000664                          1159mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000664                 TRUE     1160mm     IFEQ DEBUG
00000664  1C39 00C00003           1161mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000066A  0806 0002               1162mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000066E  67F4                    1163mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
00000670  13C5 00C00007           1164mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000676                          1165mm     ENDC
00000676                          1166mm     
00000676                 FALSE    1167mm     IFNE DEBUG
00000676                          1168mm     ENDC
00000676                          1169mm 
00000676                          1170mm     ENDM
00000676                          1171mm         HEX2BIN D5,D5,A4
00000676  49F9 00000E03           1172mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000067C  0405 0030               1173mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000680  CABC 000000FF           1174mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000686  1A34 5000               1175mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000068A                          1176mm     ENDM
0000068A  8205                    1177m         OR.B D5,D1
0000068C  5307                    1178m         SUB.B #1,D7
0000068E                          1179m     ENDW
0000068E  6096                    1180ms     BRA _1000000A
00000690                          1181ms _1000000B
00000690                          1182m     
00000690  7A00                    1183m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000692  1A01                    1184m     MOVE.B D1,D5
00000694  D481                    1185m     ADD.L D1,D2
00000696                          1186m 
00000696                          1187m     ENDM
00000696                          1188                          
00000696  14C1                    1189                  MOVE.B D1,(A2)+                     ; store it!
00000698                          1190  
00000698  5303                    1191                  SUB.B #1,D3                     ; 1 less byte to go
0000069A                          1192              ENDW
0000069A  6000 FF7E               1193s     BRA _10000008
0000069E                          1194s _10000009
0000069E                          1195          
0000069E  47F8 0360               1196              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006A2                          1197          ELSE
000006A2  6000 01F0               1198s     BRA _00000007
000006A6                          1199s _00000005
000006A6                          1200              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006A6  B23C 0038               1201s     CMP.B   #'8',D1
000006AA  6600 016C               1202s     BNE.L   _00000008
000006AE  7800                    1203                  MOVE.L #0,D4                    ; read the 24 bit start address
000006B0                          1204m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006B0  1E3C 0002               1205m     MOVE.B #2,D7
000006B4                          1206m     WHILE.B D7 <GT> 0 DO
000006B4                          1207ms _1000000C
000006B4  BE38 0000               1208ms     CMP.B   0,D7
000006B8  6F00 0064               1209ms     BLE _1000000D
000006BC  E98C                    1210m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006BE                          1211mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006BE                          1212mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BE                          1213mm 
000006BE  1A39 00C00003           1214mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006C4  0805 0000               1215mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006C8  6700 0010               1216mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
000006CC                          1217mm  
000006CC                          1218mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006CC                 TRUE     1219mmm     IFEQ DEBUG
000006CC  1A39 00C00007           1220mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006D2                          1221mmm     ENDC
000006D2                 FALSE    1222mmm     IFNE DEBUG
000006D2                          1223mmm     ENDC
000006D2                          1224mmm      
000006D2  BA3C 001B               1225mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006D6  6700 F930               1226mmm     BEQ START
000006DA                          1227mmm     ENDM
000006DA                          1228mm CONTINUE_72
000006DA  1A39 00C00013           1229mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006E0  0805 0000               1230mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006E4  67D8                    1231mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
000006E6                          1232mm     
000006E6  1A39 00C00017           1233mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006EC  13C5 00E00001           1234mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006F2                          1235mm     
000006F2                          1236mm     ENDM
000006F2                          1237mm         PRINT_CHAR D5,D6
000006F2                          1238mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F2                 TRUE     1239mm     IFEQ DEBUG
000006F2  1C39 00C00003           1240mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006F8  0806 0002               1241mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006FC  67F4                    1242mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
000006FE  13C5 00C00007           1243mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000704                          1244mm     ENDC
00000704                          1245mm     
00000704                 FALSE    1246mm     IFNE DEBUG
00000704                          1247mm     ENDC
00000704                          1248mm 
00000704                          1249mm     ENDM
00000704                          1250mm         HEX2BIN D5,D5,A4
00000704  49F9 00000E03           1251mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000070A  0405 0030               1252mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070E  CABC 000000FF           1253mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000714  1A34 5000               1254mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000718                          1255mm     ENDM
00000718  8805                    1256m         OR.B D5,D4
0000071A  5307                    1257m         SUB.B #1,D7
0000071C                          1258m     ENDW
0000071C  6096                    1259ms     BRA _1000000C
0000071E                          1260ms _1000000D
0000071E                          1261m     
0000071E  7A00                    1262m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000720  1A04                    1263m     MOVE.B D4,D5
00000722  D484                    1264m     ADD.L D4,D2
00000724                          1265m 
00000724                          1266m     ENDM
00000724                          1267m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000724  1E3C 0002               1268m     MOVE.B #2,D7
00000728                          1269m     WHILE.B D7 <GT> 0 DO
00000728                          1270ms _1000000E
00000728  BE38 0000               1271ms     CMP.B   0,D7
0000072C  6F00 0064               1272ms     BLE _1000000F
00000730  E98C                    1273m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000732                          1274mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000732                          1275mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000732                          1276mm 
00000732  1A39 00C00003           1277mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000738  0805 0000               1278mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000073C  6700 0010               1279mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000740                          1280mm  
00000740                          1281mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000740                 TRUE     1282mmm     IFEQ DEBUG
00000740  1A39 00C00007           1283mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000746                          1284mmm     ENDC
00000746                 FALSE    1285mmm     IFNE DEBUG
00000746                          1286mmm     ENDC
00000746                          1287mmm      
00000746  BA3C 001B               1288mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000074A  6700 F8BC               1289mmm     BEQ START
0000074E                          1290mmm     ENDM
0000074E                          1291mm CONTINUE_77
0000074E  1A39 00C00013           1292mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000754  0805 0000               1293mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  67D8                    1294mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000075A                          1295mm     
0000075A  1A39 00C00017           1296mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000760  13C5 00E00001           1297mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000766                          1298mm     
00000766                          1299mm     ENDM
00000766                          1300mm         PRINT_CHAR D5,D6
00000766                          1301mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000766                 TRUE     1302mm     IFEQ DEBUG
00000766  1C39 00C00003           1303mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000076C  0806 0002               1304mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000770  67F4                    1305mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
00000772  13C5 00C00007           1306mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000778                          1307mm     ENDC
00000778                          1308mm     
00000778                 FALSE    1309mm     IFNE DEBUG
00000778                          1310mm     ENDC
00000778                          1311mm 
00000778                          1312mm     ENDM
00000778                          1313mm         HEX2BIN D5,D5,A4
00000778  49F9 00000E03           1314mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000077E  0405 0030               1315mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000782  CABC 000000FF           1316mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000788  1A34 5000               1317mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000078C                          1318mm     ENDM
0000078C  8805                    1319m         OR.B D5,D4
0000078E  5307                    1320m         SUB.B #1,D7
00000790                          1321m     ENDW
00000790  6096                    1322ms     BRA _1000000E
00000792                          1323ms _1000000F
00000792                          1324m     
00000792  7A00                    1325m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000794  1A04                    1326m     MOVE.B D4,D5
00000796  D484                    1327m     ADD.L D4,D2
00000798                          1328m 
00000798                          1329m     ENDM
00000798                          1330m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000798  1E3C 0002               1331m     MOVE.B #2,D7
0000079C                          1332m     WHILE.B D7 <GT> 0 DO
0000079C                          1333ms _10000010
0000079C  BE38 0000               1334ms     CMP.B   0,D7
000007A0  6F00 0064               1335ms     BLE _10000011
000007A4  E98C                    1336m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007A6                          1337mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007A6                          1338mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A6                          1339mm 
000007A6  1A39 00C00003           1340mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007AC  0805 0000               1341mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007B0  6700 0010               1342mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007B4                          1343mm  
000007B4                          1344mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007B4                 TRUE     1345mmm     IFEQ DEBUG
000007B4  1A39 00C00007           1346mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007BA                          1347mmm     ENDC
000007BA                 FALSE    1348mmm     IFNE DEBUG
000007BA                          1349mmm     ENDC
000007BA                          1350mmm      
000007BA  BA3C 001B               1351mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007BE  6700 F848               1352mmm     BEQ START
000007C2                          1353mmm     ENDM
000007C2                          1354mm CONTINUE_82
000007C2  1A39 00C00013           1355mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007C8  0805 0000               1356mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CC  67D8                    1357mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
000007CE                          1358mm     
000007CE  1A39 00C00017           1359mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007D4  13C5 00E00001           1360mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007DA                          1361mm     
000007DA                          1362mm     ENDM
000007DA                          1363mm         PRINT_CHAR D5,D6
000007DA                          1364mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DA                 TRUE     1365mm     IFEQ DEBUG
000007DA  1C39 00C00003           1366mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007E0  0806 0002               1367mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007E4  67F4                    1368mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
000007E6  13C5 00C00007           1369mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007EC                          1370mm     ENDC
000007EC                          1371mm     
000007EC                 FALSE    1372mm     IFNE DEBUG
000007EC                          1373mm     ENDC
000007EC                          1374mm 
000007EC                          1375mm     ENDM
000007EC                          1376mm         HEX2BIN D5,D5,A4
000007EC  49F9 00000E03           1377mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007F2  0405 0030               1378mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007F6  CABC 000000FF           1379mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007FC  1A34 5000               1380mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000800                          1381mm     ENDM
00000800  8805                    1382m         OR.B D5,D4
00000802  5307                    1383m         SUB.B #1,D7
00000804                          1384m     ENDW
00000804  6096                    1385ms     BRA _10000010
00000806                          1386ms _10000011
00000806                          1387m     
00000806  7A00                    1388m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000808  1A04                    1389m     MOVE.B D4,D5
0000080A  D484                    1390m     ADD.L D4,D2
0000080C                          1391m 
0000080C                          1392m     ENDM
0000080C                          1393                    
0000080C  2044                    1394                  MOVE.L D4,A0                    ; start address -> A0
0000080E                          1395                  
0000080E  47F9 000009CA           1396                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000814                          1397              ELSE
00000814  6000 007E               1398s     BRA _00000009
00000818                          1399s _00000008
00000818                          1400m                 PRINT_CRLF D5,A4
00000818  49F9 00000E2E           1401m     LEA CRLF,A4
0000081E                          1402mm     PRINT_STR A4,D5
0000081E                          1403mm LOOP_87
0000081E  0C14 0000               1404mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000822  6700 0016               1405mm     BEQ EXIT_87
00000826                          1406mmm     PRINT_CHAR (A4)+,D5
00000826                          1407mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1408mmm     IFEQ DEBUG
00000826  1A39 00C00003           1409mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1410mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1411mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00000832  13DC 00C00007           1412mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000838                          1413mmm     ENDC
00000838                          1414mmm     
00000838                 FALSE    1415mmm     IFNE DEBUG
00000838                          1416mmm     ENDC
00000838                          1417mmm 
00000838                          1418mmm     ENDM
00000838  60E4                    1419mm     BRA LOOP_87
0000083A                          1420mm EXIT_87
0000083A                          1421mm     ENDM
0000083A                          1422m     ENDM
0000083A                          1423              
0000083A  49F9 00000DB8           1424                  LEA UNREC,A4                    ; warn for unrecognised type
00000840                          1425m                 PRINT_STR A4,D5
00000840                          1426m LOOP_89
00000840  0C14 0000               1427m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000844  6700 0016               1428m     BEQ EXIT_89
00000848                          1429mm     PRINT_CHAR (A4)+,D5
00000848                          1430mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000848                 TRUE     1431mm     IFEQ DEBUG
00000848  1A39 00C00003           1432mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000084E  0805 0002               1433mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000852  67F4                    1434mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00000854  13DC 00C00007           1435mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000085A                          1436mm     ENDC
0000085A                          1437mm     
0000085A                 FALSE    1438mm     IFNE DEBUG
0000085A                          1439mm     ENDC
0000085A                          1440mm 
0000085A                          1441mm     ENDM
0000085A  60E4                    1442m     BRA LOOP_89
0000085C                          1443m EXIT_89
0000085C                          1444m     ENDM
0000085C                          1445m                 PRINT_CHAR D1,D5
0000085C                          1446m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085C                 TRUE     1447m     IFEQ DEBUG
0000085C  1A39 00C00003           1448m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000862  0805 0002               1449m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000866  67F4                    1450m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000868  13C1 00C00007           1451m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000086E                          1452m     ENDC
0000086E                          1453m     
0000086E                 FALSE    1454m     IFNE DEBUG
0000086E                          1455m     ENDC
0000086E                          1456m 
0000086E                          1457m     ENDM
0000086E                          1458m                 PRINT_CRLF D5,A4
0000086E  49F9 00000E2E           1459m     LEA CRLF,A4
00000874                          1460mm     PRINT_STR A4,D5
00000874                          1461mm LOOP_93
00000874  0C14 0000               1462mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000878  6700 0016               1463mm     BEQ EXIT_93
0000087C                          1464mmm     PRINT_CHAR (A4)+,D5
0000087C                          1465mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087C                 TRUE     1466mmm     IFEQ DEBUG
0000087C  1A39 00C00003           1467mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000882  0805 0002               1468mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000886  67F4                    1469mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000888  13DC 00C00007           1470mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000088E                          1471mmm     ENDC
0000088E                          1472mmm     
0000088E                 FALSE    1473mmm     IFNE DEBUG
0000088E                          1474mmm     ENDC
0000088E                          1475mmm 
0000088E                          1476mmm     ENDM
0000088E  60E4                    1477mm     BRA LOOP_93
00000890                          1478mm EXIT_93
00000890                          1479mm     ENDM
00000890                          1480m     ENDM
00000890                          1481              
00000890  6000 FACE               1482                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000894                          1483              ENDI
00000894                          1484s _00000009
00000894                          1485          ENDI
00000894                          1486s _00000007
00000894                          1487      ENDI
00000894                          1488s _00000003
00000894                          1489      
00000894                          1490m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000894  1E3C 0002               1491m     MOVE.B #2,D7
00000898                          1492m     WHILE.B D7 <GT> 0 DO
00000898                          1493ms _10000012
00000898  BE38 0000               1494ms     CMP.B   0,D7
0000089C  6F00 0064               1495ms     BLE _10000013
000008A0  E98C                    1496m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008A2                          1497mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008A2                          1498mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A2                          1499mm 
000008A2  1A39 00C00003           1500mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008A8  0805 0000               1501mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008AC  6700 0010               1502mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008B0                          1503mm  
000008B0                          1504mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008B0                 TRUE     1505mmm     IFEQ DEBUG
000008B0  1A39 00C00007           1506mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008B6                          1507mmm     ENDC
000008B6                 FALSE    1508mmm     IFNE DEBUG
000008B6                          1509mmm     ENDC
000008B6                          1510mmm      
000008B6  BA3C 001B               1511mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008BA  6700 F74C               1512mmm     BEQ START
000008BE                          1513mmm     ENDM
000008BE                          1514mm CONTINUE_96
000008BE  1A39 00C00013           1515mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008C4  0805 0000               1516mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C8  67D8                    1517mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
000008CA                          1518mm     
000008CA  1A39 00C00017           1519mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008D0  13C5 00E00001           1520mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008D6                          1521mm     
000008D6                          1522mm     ENDM
000008D6                          1523mm         PRINT_CHAR D5,D6
000008D6                          1524mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                 TRUE     1525mm     IFEQ DEBUG
000008D6  1C39 00C00003           1526mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008DC  0806 0002               1527mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008E0  67F4                    1528mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000008E2  13C5 00C00007           1529mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008E8                          1530mm     ENDC
000008E8                          1531mm     
000008E8                 FALSE    1532mm     IFNE DEBUG
000008E8                          1533mm     ENDC
000008E8                          1534mm 
000008E8                          1535mm     ENDM
000008E8                          1536mm         HEX2BIN D5,D5,A4
000008E8  49F9 00000E03           1537mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000008EE  0405 0030               1538mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008F2  CABC 000000FF           1539mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008F8  1A34 5000               1540mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008FC                          1541mm     ENDM
000008FC  8805                    1542m         OR.B D5,D4
000008FE  5307                    1543m         SUB.B #1,D7
00000900                          1544m     ENDW
00000900  6096                    1545ms     BRA _10000012
00000902                          1546ms _10000013
00000902                          1547m     
00000902  7A00                    1548m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000904  1A04                    1549m     MOVE.B D4,D5
00000906  D484                    1550m     ADD.L D4,D2
00000908                          1551m 
00000908                          1552m     ENDM
00000908                          1553m     PRINT_CRLF D5,A4
00000908  49F9 00000E2E           1554m     LEA CRLF,A4
0000090E                          1555mm     PRINT_STR A4,D5
0000090E                          1556mm LOOP_101
0000090E  0C14 0000               1557mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000912  6700 0016               1558mm     BEQ EXIT_101
00000916                          1559mmm     PRINT_CHAR (A4)+,D5
00000916                          1560mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                 TRUE     1561mmm     IFEQ DEBUG
00000916  1A39 00C00003           1562mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000091C  0805 0002               1563mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000920  67F4                    1564mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000922  13DC 00C00007           1565mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000928                          1566mmm     ENDC
00000928                          1567mmm     
00000928                 FALSE    1568mmm     IFNE DEBUG
00000928                          1569mmm     ENDC
00000928                          1570mmm 
00000928                          1571mmm     ENDM
00000928  60E4                    1572mm     BRA LOOP_101
0000092A                          1573mm EXIT_101
0000092A                          1574mm     ENDM
0000092A                          1575m     ENDM
0000092A                          1576          
0000092A                          1577      IF.B D2 <NE> #$FF THEN.L
0000092A  B43C 00FF               1578s     CMP.B   #$FF,D2
0000092E  6700 0098               1579s     BEQ.L   _0000000A
00000932  49F9 00000DCF           1580          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000938                          1581m         PRINT_STR A4,D5
00000938                          1582m LOOP_103
00000938  0C14 0000               1583m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000093C  6700 0016               1584m     BEQ EXIT_103
00000940                          1585mm     PRINT_CHAR (A4)+,D5
00000940                          1586mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000940                 TRUE     1587mm     IFEQ DEBUG
00000940  1A39 00C00003           1588mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000946  0805 0002               1589mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000094A  67F4                    1590mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000094C  13DC 00C00007           1591mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000952                          1592mm     ENDC
00000952                          1593mm     
00000952                 FALSE    1594mm     IFNE DEBUG
00000952                          1595mm     ENDC
00000952                          1596mm 
00000952                          1597mm     ENDM
00000952  60E4                    1598m     BRA LOOP_103
00000954                          1599m EXIT_103
00000954                          1600m     ENDM
00000954                          1601m         PRINT_REG D0,D5,D2,D6,A4
00000954  49F9 00000E34           1602m     LEA OX,A4
0000095A                          1603mm     PRINT_STR A4,D5
0000095A                          1604mm LOOP_106
0000095A  0C14 0000               1605mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000095E  6700 0016               1606mm     BEQ EXIT_106
00000962                          1607mmm     PRINT_CHAR (A4)+,D5
00000962                          1608mmm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1609mmm     IFEQ DEBUG
00000962  1A39 00C00003           1610mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000968  0805 0002               1611mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1612mmm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096E  13DC 00C00007           1613mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000974                          1614mmm     ENDC
00000974                          1615mmm     
00000974                 FALSE    1616mmm     IFNE DEBUG
00000974                          1617mmm     ENDC
00000974                          1618mmm 
00000974                          1619mmm     ENDM
00000974  60E4                    1620mm     BRA LOOP_106
00000976                          1621mm EXIT_106
00000976                          1622mm     ENDM
00000976  7C07                    1623m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000978                          1624m LOOP_105
00000978                          1625mm     BIN2HEX D0,D2,A4
00000978  49F9 00000DF3           1626mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000097E  E998                    1627mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000980  1400                    1628mm     MOVE.B D0,D2
00000982  0282 0000000F           1629mm     ANDI.L #$F,D2
00000988  1434 2000               1630mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000098C                          1631mm     ENDM
0000098C                          1632mm     PRINT_CHAR D2,D5
0000098C                          1633mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1634mm     IFEQ DEBUG
0000098C  1A39 00C00003           1635mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000992  0805 0002               1636mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000996  67F4                    1637mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000998  13C2 00C00007           1638mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000099E                          1639mm     ENDC
0000099E                          1640mm     
0000099E                 FALSE    1641mm     IFNE DEBUG
0000099E                          1642mm     ENDC
0000099E                          1643mm 
0000099E                          1644mm     ENDM
0000099E  57CE FFD8               1645m     DBEQ D6,LOOP_105
000009A2                          1646m     ENDM
000009A2                          1647m         PRINT_CRLF D5,A4
000009A2  49F9 00000E2E           1648m     LEA CRLF,A4
000009A8                          1649mm     PRINT_STR A4,D5
000009A8                          1650mm LOOP_111
000009A8  0C14 0000               1651mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009AC  6700 0016               1652mm     BEQ EXIT_111
000009B0                          1653mmm     PRINT_CHAR (A4)+,D5
000009B0                          1654mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1655mmm     IFEQ DEBUG
000009B0  1A39 00C00003           1656mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B6  0805 0002               1657mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1658mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
000009BC  13DC 00C00007           1659mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009C2                          1660mmm     ENDC
000009C2                          1661mmm     
000009C2                 FALSE    1662mmm     IFNE DEBUG
000009C2                          1663mmm     ENDC
000009C2                          1664mmm 
000009C2                          1665mmm     ENDM
000009C2  60E4                    1666mm     BRA LOOP_111
000009C4                          1667mm EXIT_111
000009C4                          1668mm     ENDM
000009C4                          1669m     ENDM
000009C4  6000 F772               1670          BRA MAIN_LOOP
000009C8                          1671      ENDI
000009C8                          1672s _0000000A
000009C8                          1673      
000009C8  4ED3                    1674      JMP (A3)
000009CA                          1675  DOWNLOAD_DONE
000009CA                          1676m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009CA  43F9 00000E34           1677m     LEA OX,A1
000009D0                          1678mm     PRINT_STR A1,D5
000009D0                          1679mm LOOP_114
000009D0  0C11 0000               1680mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009D4  6700 0016               1681mm     BEQ EXIT_114
000009D8                          1682mmm     PRINT_CHAR (A1)+,D5
000009D8                          1683mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1684mmm     IFEQ DEBUG
000009D8  1A39 00C00003           1685mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1686mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1687mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009E4  13D9 00C00007           1688mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009EA                          1689mmm     ENDC
000009EA                          1690mmm     
000009EA                 FALSE    1691mmm     IFNE DEBUG
000009EA                          1692mmm     ENDC
000009EA                          1693mmm 
000009EA                          1694mmm     ENDM
000009EA  60E4                    1695mm     BRA LOOP_114
000009EC                          1696mm EXIT_114
000009EC                          1697mm     ENDM
000009EC  7407                    1698m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009EE                          1699m LOOP_113
000009EE                          1700mm     BIN2HEX D0,D6,A1
000009EE  43F9 00000DF3           1701mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
000009F4  E998                    1702mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009F6  1C00                    1703mm     MOVE.B D0,D6
000009F8  0286 0000000F           1704mm     ANDI.L #$F,D6
000009FE  1C31 6000               1705mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A02                          1706mm     ENDM
00000A02                          1707mm     PRINT_CHAR D6,D5
00000A02                          1708mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A02                 TRUE     1709mm     IFEQ DEBUG
00000A02  1A39 00C00003           1710mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A08  0805 0002               1711mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0C  67F4                    1712mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A0E  13C6 00C00007           1713mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A14                          1714mm     ENDC
00000A14                          1715mm     
00000A14                 FALSE    1716mm     IFNE DEBUG
00000A14                          1717mm     ENDC
00000A14                          1718mm 
00000A14                          1719mm     ENDM
00000A14  57CA FFD8               1720m     DBEQ D2,LOOP_113
00000A18                          1721m     ENDM
00000A18  43F9 00000D96           1722      LEA READ,A1
00000A1E                          1723m     PRINT_STR A1,D5
00000A1E                          1724m LOOP_118
00000A1E  0C11 0000               1725m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A22  6700 0016               1726m     BEQ EXIT_118
00000A26                          1727mm     PRINT_CHAR (A1)+,D5
00000A26                          1728mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1729mm     IFEQ DEBUG
00000A26  1A39 00C00003           1730mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A2C  0805 0002               1731mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1732mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A32  13D9 00C00007           1733mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A38                          1734mm     ENDC
00000A38                          1735mm     
00000A38                 FALSE    1736mm     IFNE DEBUG
00000A38                          1737mm     ENDC
00000A38                          1738mm 
00000A38                          1739mm     ENDM
00000A38  60E4                    1740m     BRA LOOP_118
00000A3A                          1741m EXIT_118
00000A3A                          1742m     ENDM
00000A3A  2E08                    1743      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A3C                          1744m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A3C  43F9 00000E34           1745m     LEA OX,A1
00000A42                          1746mm     PRINT_STR A1,D5
00000A42                          1747mm LOOP_121
00000A42  0C11 0000               1748mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A46  6700 0016               1749mm     BEQ EXIT_121
00000A4A                          1750mmm     PRINT_CHAR (A1)+,D5
00000A4A                          1751mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4A                 TRUE     1752mmm     IFEQ DEBUG
00000A4A  1A39 00C00003           1753mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A50  0805 0002               1754mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A54  67F4                    1755mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000A56  13D9 00C00007           1756mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A5C                          1757mmm     ENDC
00000A5C                          1758mmm     
00000A5C                 FALSE    1759mmm     IFNE DEBUG
00000A5C                          1760mmm     ENDC
00000A5C                          1761mmm 
00000A5C                          1762mmm     ENDM
00000A5C  60E4                    1763mm     BRA LOOP_121
00000A5E                          1764mm EXIT_121
00000A5E                          1765mm     ENDM
00000A5E  7407                    1766m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A60                          1767m LOOP_120
00000A60                          1768mm     BIN2HEX D7,D6,A1
00000A60  43F9 00000DF3           1769mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A66  E99F                    1770mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A68  1C07                    1771mm     MOVE.B D7,D6
00000A6A  0286 0000000F           1772mm     ANDI.L #$F,D6
00000A70  1C31 6000               1773mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A74                          1774mm     ENDM
00000A74                          1775mm     PRINT_CHAR D6,D5
00000A74                          1776mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A74                 TRUE     1777mm     IFEQ DEBUG
00000A74  1A39 00C00003           1778mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A7A  0805 0002               1779mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A7E  67F4                    1780mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A80  13C6 00C00007           1781mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A86                          1782mm     ENDC
00000A86                          1783mm     
00000A86                 FALSE    1784mm     IFNE DEBUG
00000A86                          1785mm     ENDC
00000A86                          1786mm 
00000A86                          1787mm     ENDM
00000A86  57CA FFD8               1788m     DBEQ D2,LOOP_120
00000A8A                          1789m     ENDM
00000A8A                          1790m     PRINT_CRLF D5,A4     
00000A8A  49F9 00000E2E           1791m     LEA CRLF,A4
00000A90                          1792mm     PRINT_STR A4,D5
00000A90                          1793mm LOOP_126
00000A90  0C14 0000               1794mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A94  6700 0016               1795mm     BEQ EXIT_126
00000A98                          1796mmm     PRINT_CHAR (A4)+,D5
00000A98                          1797mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A98                 TRUE     1798mmm     IFEQ DEBUG
00000A98  1A39 00C00003           1799mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9E  0805 0002               1800mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA2  67F4                    1801mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AA4  13DC 00C00007           1802mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AAA                          1803mmm     ENDC
00000AAA                          1804mmm     
00000AAA                 FALSE    1805mmm     IFNE DEBUG
00000AAA                          1806mmm     ENDC
00000AAA                          1807mmm 
00000AAA                          1808mmm     ENDM
00000AAA  60E4                    1809mm     BRA LOOP_126
00000AAC                          1810mm EXIT_126
00000AAC                          1811mm     ENDM
00000AAC                          1812m     ENDM
00000AAC                          1813          
00000AAC  6000 F68A               1814      BRA MAIN_LOOP
00000AB0                          1815      
00000AB0                          1816  G
00000AB0  2047                    1817      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AB2  3E3C 0000               1818      MOVE #0,D7                                      ; clear the now used address accumulator
00000AB6  4ED0                    1819      JMP (A0)                                        ; jump to it!
00000AB8                          1820      
00000AB8                          1821  Z
00000AB8  207C 00200000           1822      MOVE.L #RAM,A0                                  ; address of RAM
00000ABE                          1823      
00000ABE                          1824      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000ABE  7000                    1825s     MOVE.L  #0,D0
00000AC0  6000 0012               1826s     BRA _20000005
00000AC4                          1827s _20000004
00000AC4  2200                    1828              MOVE.L D0,D1                              ; progress update
00000AC6  E089                    1829          LSR.L #8,D1 
00000AC8  E089                    1830          LSR.L #8,D1
00000ACA  13C1 00E00001           1831          MOVE.B D1,DISPLAY
00000AD0                          1832  
00000AD0  20C0                    1833          MOVE.L D0,(A0)+
00000AD2                          1834      ENDF
00000AD2  5880                    1835s     ADD.L   #4,D0
00000AD4                          1836s _20000005
00000AD4  B0BC 00040000           1837s     CMP.L   #$40000,D0
00000ADA  6FE8                    1838s     BLE _20000004
00000ADC                          1839   
00000ADC  207C 00200000           1840      MOVE.L #RAM,A0                                    ; address of RAM
00000AE2                          1841     
00000AE2                          1842      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AE2  7000                    1843s     MOVE.L  #0,D0
00000AE4  6000 00AE               1844s     BRA _20000007
00000AE8                          1845s _20000006
00000AE8  2200                    1846          MOVE.L D0,D1                              ; progress update
00000AEA  E089                    1847          LSR.L #8,D1
00000AEC  E089                    1848          LSR.L #8,D1
00000AEE  13C1 00E00001           1849          MOVE.B D1,DISPLAY
00000AF4                          1850  
00000AF4  2218                    1851          MOVE.L (A0)+,D1
00000AF6                          1852            
00000AF6                          1853          IF.L D0 <NE> D1 THEN      
00000AF6  B081                    1854s     CMP.L   D1,D0
00000AF8  6700 0098               1855s     BEQ _0000000B
00000AFC  43F9 00000DE1           1856              LEA RAM_ERROR,A1
00000B02                          1857m             PRINT_STR A1,D1
00000B02                          1858m LOOP_128
00000B02  0C11 0000               1859m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B06  6700 0016               1860m     BEQ EXIT_128
00000B0A                          1861mm     PRINT_CHAR (A1)+,D1
00000B0A                          1862mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0A                 TRUE     1863mm     IFEQ DEBUG
00000B0A  1239 00C00003           1864mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B10  0801 0002               1865mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B14  67F4                    1866mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B16  13D9 00C00007           1867mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B1C                          1868mm     ENDC
00000B1C                          1869mm     
00000B1C                 FALSE    1870mm     IFNE DEBUG
00000B1C                          1871mm     ENDC
00000B1C                          1872mm 
00000B1C                          1873mm     ENDM
00000B1C  60E4                    1874m     BRA LOOP_128
00000B1E                          1875m EXIT_128
00000B1E                          1876m     ENDM
00000B1E  2208                    1877              MOVE.L A0,D1
00000B20  5981                    1878              SUB.L #4,D1
00000B22                          1879m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B22  43F9 00000E34           1880m     LEA OX,A1
00000B28                          1881mm     PRINT_STR A1,D3
00000B28                          1882mm LOOP_131
00000B28  0C11 0000               1883mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B2C  6700 0016               1884mm     BEQ EXIT_131
00000B30                          1885mmm     PRINT_CHAR (A1)+,D3
00000B30                          1886mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1887mmm     IFEQ DEBUG
00000B30  1639 00C00003           1888mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1889mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1890mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000B3C  13D9 00C00007           1891mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B42                          1892mmm     ENDC
00000B42                          1893mmm     
00000B42                 FALSE    1894mmm     IFNE DEBUG
00000B42                          1895mmm     ENDC
00000B42                          1896mmm 
00000B42                          1897mmm     ENDM
00000B42  60E4                    1898mm     BRA LOOP_131
00000B44                          1899mm EXIT_131
00000B44                          1900mm     ENDM
00000B44  7C07                    1901m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1902m LOOP_130
00000B46                          1903mm     BIN2HEX D1,D2,A1
00000B46  43F9 00000DF3           1904mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B4C  E999                    1905mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1401                    1906mm     MOVE.B D1,D2
00000B50  0282 0000000F           1907mm     ANDI.L #$F,D2
00000B56  1431 2000               1908mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1909mm     ENDM
00000B5A                          1910mm     PRINT_CHAR D2,D3
00000B5A                          1911mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1912mm     IFEQ DEBUG
00000B5A  1639 00C00003           1913mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B60  0803 0002               1914mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1915mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B66  13C2 00C00007           1916mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1917mm     ENDC
00000B6C                          1918mm     
00000B6C                 FALSE    1919mm     IFNE DEBUG
00000B6C                          1920mm     ENDC
00000B6C                          1921mm 
00000B6C                          1922mm     ENDM
00000B6C  57CE FFD8               1923m     DBEQ D6,LOOP_130
00000B70                          1924m     ENDM
00000B70                          1925m             PRINT_CRLF D3,A1
00000B70  43F9 00000E2E           1926m     LEA CRLF,A1
00000B76                          1927mm     PRINT_STR A1,D3
00000B76                          1928mm LOOP_136
00000B76  0C11 0000               1929mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B7A  6700 0016               1930mm     BEQ EXIT_136
00000B7E                          1931mmm     PRINT_CHAR (A1)+,D3
00000B7E                          1932mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1933mmm     IFEQ DEBUG
00000B7E  1639 00C00003           1934mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B84  0803 0002               1935mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1936mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000B8A  13D9 00C00007           1937mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1938mmm     ENDC
00000B90                          1939mmm     
00000B90                 FALSE    1940mmm     IFNE DEBUG
00000B90                          1941mmm     ENDC
00000B90                          1942mmm 
00000B90                          1943mmm     ENDM
00000B90  60E4                    1944mm     BRA LOOP_136
00000B92                          1945mm EXIT_136
00000B92                          1946mm     ENDM
00000B92                          1947m     ENDM
00000B92                          1948          ENDI 
00000B92                          1949s _0000000B
00000B92                          1950      ENDF
00000B92  5880                    1951s     ADD.L   #4,D0
00000B94                          1952s _20000007
00000B94  B0BC 00040000           1953s     CMP.L   #$40000,D0
00000B9A  6F00 FF4C               1954s     BLE _20000006
00000B9E                          1955      
00000B9E  6000 F598               1956      BRA MAIN_LOOP
00000BA2                          1957    
00000BA2                          1958  L
00000BA2  7A00                    1959      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000BA4                          1960  
00000BA4                          1961      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000BA4  3C3C 0000               1962s     MOVE.W  #0,D6
00000BA8  6000 0048               1963s     BRA _20000009
00000BAC                          1964s _20000008
00000BAC  E98D                    1965          LSL.L #4,D5                                 ; make what we have so far more significant
00000BAE                          1966m         WAIT_CHAR D2,D3                             ; next character -> D2
00000BAE                          1967m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAE                 TRUE     1968m     IFEQ DEBUG
00000BAE  1639 00C00003           1969m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BB4  0803 0000               1970m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000BB8  67F4                    1971m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000BBA                          1972m     ENDC
00000BBA                          1973m     
00000BBA                          1974mm     READ_CHAR D2
00000BBA                 TRUE     1975mm     IFEQ DEBUG
00000BBA  1439 00C00007           1976mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000BC0                          1977mm     ENDC
00000BC0                 FALSE    1978mm     IFNE DEBUG
00000BC0                          1979mm     ENDC
00000BC0                          1980mm      
00000BC0  B43C 001B               1981mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000BC4  6700 F442               1982mm     BEQ START
00000BC8                          1983mm     ENDM
00000BC8                          1984m 
00000BC8                 TRUE     1985m     IFEQ DEBUG
00000BC8                          1986mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000BC8                          1987mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1988mm     IFEQ DEBUG
00000BC8  1639 00C00003           1989mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BCE  0803 0002               1990mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1991mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000BD4  13C2 00C00007           1992mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BDA                          1993mm     ENDC
00000BDA                          1994mm     
00000BDA                 FALSE    1995mm     IFNE DEBUG
00000BDA                          1996mm     ENDC
00000BDA                          1997mm 
00000BDA                          1998mm     ENDM
00000BDA                          1999m     ENDC
00000BDA                          2000m     ENDM
00000BDA                          2001m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000BDA  41F9 00000E03           2002m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000BE0  0402 0030               2003m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BE4  C4BC 000000FF           2004m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000BEA  1430 2000               2005m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BEE                          2006m     ENDM
00000BEE  8A02                    2007          OR.B D2,D5
00000BF0                          2008      ENDF
00000BF0  5246                    2009s     ADD.W   #1,D6
00000BF2                          2010s _20000009
00000BF2  BC7C 0003               2011s     CMP.W   #3,D6
00000BF6  6FB4                    2012s     BLE _20000008
00000BF8                          2013            
00000BF8                          2014m     PRINT_CRLF D3,A0
00000BF8  41F9 00000E2E           2015m     LEA CRLF,A0
00000BFE                          2016mm     PRINT_STR A0,D3
00000BFE                          2017mm LOOP_143
00000BFE  0C10 0000               2018mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C02  6700 0016               2019mm     BEQ EXIT_143
00000C06                          2020mmm     PRINT_CHAR (A0)+,D3
00000C06                          2021mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     2022mmm     IFEQ DEBUG
00000C06  1639 00C00003           2023mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C0C  0803 0002               2024mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C10  67F4                    2025mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C12  13D8 00C00007           2026mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C18                          2027mmm     ENDC
00000C18                          2028mmm     
00000C18                 FALSE    2029mmm     IFNE DEBUG
00000C18                          2030mmm     ENDC
00000C18                          2031mmm 
00000C18                          2032mmm     ENDM
00000C18  60E4                    2033mm     BRA LOOP_143
00000C1A                          2034mm EXIT_143
00000C1A                          2035mm     ENDM
00000C1A                          2036m     ENDM
00000C1A                          2037  
00000C1A  207C 00000000           2038      MOVE.L #ROM,A0                                  ; start of ROM
00000C20                          2039      
00000C20  2247                    2040      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C22  7E00                    2041      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C24                          2042      
00000C24  31FC AAAA 2AAA          2043      MOVE.W #$AAAA,$2AAA
00000C2A  31FC 5555 1554          2044      MOVE.W #$5555,$1554
00000C30  31FC 8080 2AAA          2045      MOVE.W #$8080,$2AAA
00000C36  31FC AAAA 2AAA          2046      MOVE.W #$AAAA,$2AAA
00000C3C  31FC 5555 1554          2047      MOVE.W #$5555,$1554
00000C42  31FC 2020 2AAA          2048      MOVE.W #$2020,$2AAA
00000C48                          2049      
00000C48  45F9 00000E1A           2050      LEA LOADING,A2                              ; important for timing
00000C4E                          2051m     PRINT_STR A2,D3
00000C4E                          2052m LOOP_145
00000C4E  0C12 0000               2053m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C52  6700 0016               2054m     BEQ EXIT_145
00000C56                          2055mm     PRINT_CHAR (A2)+,D3
00000C56                          2056mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C56                 TRUE     2057mm     IFEQ DEBUG
00000C56  1639 00C00003           2058mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5C  0803 0002               2059mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C60  67F4                    2060mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C62  13DA 00C00007           2061mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C68                          2062mm     ENDC
00000C68                          2063mm     
00000C68                 FALSE    2064mm     IFNE DEBUG
00000C68                          2065mm     ENDC
00000C68                          2066mm 
00000C68                          2067mm     ENDM
00000C68  60E4                    2068m     BRA LOOP_145
00000C6A                          2069m EXIT_145
00000C6A                          2070m     ENDM
00000C6A                          2071      
00000C6A                          2072      WHILE D5 <GT> #0 DO
00000C6A                          2073s _10000014
00000C6A  BA7C 0000               2074s     CMP.W   #0,D5
00000C6E  6F00 001C               2075s     BLE _10000015
00000C72  5585                    2076          SUB.L #2,D5
00000C74                          2077            
00000C74  13D1 00E00001           2078          MOVE.B (A1),DISPLAY
00000C7A  3091                    2079          MOVE.W (A1),(A0)                            ; write the data
00000C7C                          2080        
00000C7C                          2081  WAIT_FOR_COMPLETE
00000C7C  3410                    2082          MOVE.W (A0),D2
00000C7E                          2083  
00000C7E                          2084          IF D2 <NE> (A1) THEN
00000C7E  B451                    2085s     CMP.W   (A1),D2
00000C80  6700 0004               2086s     BEQ _0000000C
00000C84  60F6                    2087              BRA WAIT_FOR_COMPLETE
00000C86                          2088          ENDI
00000C86                          2089s _0000000C
00000C86                          2090        
00000C86  5488                    2091          ADD.L #2,A0
00000C88  5489                    2092          ADD.L #2,A1
00000C8A                          2093       ENDW    
00000C8A  60DE                    2094s     BRA _10000014
00000C8C                          2095s _10000015
00000C8C                          2096      
00000C8C  31FC AAAA 2AAA          2097      MOVE.W #$AAAA,$2AAA
00000C92  31FC 5555 1554          2098      MOVE.W #$5555,$1554
00000C98  31FC A0A0 2AAA          2099      MOVE.W #$A0A0,$2AAA
00000C9E                          2100              
00000C9E  6000 F498               2101      BRA MAIN_LOOP
00000CA2                          2102          
00000CA2                          2103  HEX_DIGIT
00000CA2  E98F                    2104      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000CA4                          2105m     HEX2BIN D2,D2,A0
00000CA4  41F9 00000E03           2106m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000CAA  0402 0030               2107m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CAE  C4BC 000000FF           2108m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000CB4  1430 2000               2109m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000CB8                          2110m     ENDM
00000CB8  8E02                    2111      OR.B D2,D7  
00000CBA  6000 F49E               2112      BRA GET_INPUT
00000CBE                          2113  
00000CBE  FFFF FFFF               2114      SIMHALT                                         ; halt simulator
00000CC2                          2115  
00000CC2                          2116  ; strings
00000CC2= 4D 44 46 2D 6D 6F ...   2117  VERSION DC.B 'MDF-mon V1.54 (10/04/2021)',CR,LF,NULL
00000CDF= 3F 09 09 09 68 65 ...   2118  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000CE9= 5B 76 5D 09 09 09 ...   2119          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000CF8= 78 78 78 78 78 78 ...   2120          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D10= 78 78 78 78 78 78 ...   2121          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D30= 5B 73 5D 09 09 09 ...   2122          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000D4A= 78 78 78 78 78 78 ...   2123          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000D5B= 5B 7A 5D 09 09 09 ...   2124          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000D6D= 78 78 78 78 78 78 ...   2125          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000D8F= 48 75 68 3F 0D 0A 00    2126  HUH     DC.B 'Huh?',CR,LF,NULL
00000D96= 20 53 20 72 65 63 ...   2127  READ    DC.B ' S records read, start address = ',NULL
00000DB8= 57 3A 20 55 6E 6B ...   2128  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000DCF= 57 3A 20 43 53 20 ...   2129  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000DE1= 57 3A 20 52 41 4D ...   2130  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000DF3= 30 31 32 33 34 35 ...   2131  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E03= 00 01 02 03 04 05 ...   2132  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E1A= 4C 6F 61 64 69 6E ...   2133  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E2E= 0D 0A 00                2134  CRLF    DC.B CR,LF,NULL
00000E31= 3E 20 00                2135  PROMPT  DC.B '> ',NULL
00000E34= 30 78 00                2136  ox      DC.B '0x',NULL
00000E37                          2137      
00000E37                          2138      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         DF3
CONTINUE_37         37C
CONTINUE_40         3CC
CONTINUE_44         422
CONTINUE_52         4DA
CONTINUE_57         54E
CONTINUE_62         5CC
CONTINUE_67         64C
CONTINUE_72         6DA
CONTINUE_77         74E
CONTINUE_82         7C2
CONTINUE_96         8BE
CR                  D
CRLF                E2E
CS_FAILURE          DCF
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            93A
DOWNLOAD_BYTE       C1F
DOWNLOAD_DONE       9CA
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             15A
EXIT_101            92A
EXIT_103            954
EXIT_106            976
EXIT_111            9C4
EXIT_114            9EC
EXIT_118            A3A
EXIT_121            A5E
EXIT_126            AAC
EXIT_128            B1E
EXIT_131            B44
EXIT_136            B92
EXIT_143            C1A
EXIT_145            C6A
EXIT_16             1E0
EXIT_18             232
EXIT_20             262
EXIT_23             28E
EXIT_28             2DC
EXIT_3              EA
EXIT_35             354
EXIT_49             496
EXIT_5              10C
EXIT_8              12E
EXIT_87             83A
EXIT_89             85C
EXIT_93             890
G                   AB0
GET_INPUT           15A
H                   236
HELP                CDF
HEX2BIN             134
HEX2BIN_LUT         E03
HEX_DIGIT           CA2
HUH                 D8F
L                   BA2
LF                  A
LOADING             E1A
LOOP_10             13E
LOOP_101            90E
LOOP_103            938
LOOP_105            978
LOOP_106            95A
LOOP_111            9A8
LOOP_113            9EE
LOOP_114            9D0
LOOP_118            A1E
LOOP_120            A60
LOOP_121            A42
LOOP_126            A90
LOOP_128            B02
LOOP_130            B46
LOOP_131            B28
LOOP_136            B76
LOOP_143            BFE
LOOP_145            C4E
LOOP_16             1C4
LOOP_18             216
LOOP_20             246
LOOP_22             290
LOOP_23             272
LOOP_28             2C0
LOOP_3              CE
LOOP_35             338
LOOP_49             47A
LOOP_5              F0
LOOP_8              112
LOOP_87             81E
LOOP_89             840
LOOP_93             874
MAIN_LOOP           138
NULL                0
OX                  E34
PRINTSTR            246
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
PROMPT              E31
R                   266
RAM                 200000
RAM_ERROR           DE1
READ                D96
READ_CHAR           7D4
READ_DATA_TO_POKE   2E4
RESET               4
ROM                 0
S                   358
STACK               0
START               8
TAB                 9
UNREC               DB8
V                   240
VERSION             CC2
W                   2E0
WAIT_CHAR           625
WAIT_FOR_COMPLETE   C7C
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_102  916
WAIT_FOR_READY_104  940
WAIT_FOR_READY_107  962
WAIT_FOR_READY_109  98C
WAIT_FOR_READY_11   146
WAIT_FOR_READY_112  9B0
WAIT_FOR_READY_115  9D8
WAIT_FOR_READY_117  A02
WAIT_FOR_READY_119  A26
WAIT_FOR_READY_12   15A
WAIT_FOR_READY_122  A4A
WAIT_FOR_READY_124  A74
WAIT_FOR_READY_127  A98
WAIT_FOR_READY_129  B0A
WAIT_FOR_READY_132  B30
WAIT_FOR_READY_134  B5A
WAIT_FOR_READY_137  B7E
WAIT_FOR_READY_138  BAE
WAIT_FOR_READY_14   174
WAIT_FOR_READY_140  BC8
WAIT_FOR_READY_144  C06
WAIT_FOR_READY_146  C56
WAIT_FOR_READY_17   1CC
WAIT_FOR_READY_19   21E
WAIT_FOR_READY_21   24E
WAIT_FOR_READY_24   27A
WAIT_FOR_READY_26   2A4
WAIT_FOR_READY_29   2C8
WAIT_FOR_READY_30   2E6
WAIT_FOR_READY_32   300
WAIT_FOR_READY_36   340
WAIT_FOR_READY_37   360
WAIT_FOR_READY_39   39A
WAIT_FOR_READY_4    D6
WAIT_FOR_READY_40   3B0
WAIT_FOR_READY_42   3E4
WAIT_FOR_READY_44   406
WAIT_FOR_READY_46   43A
WAIT_FOR_READY_50   482
WAIT_FOR_READY_52   4BE
WAIT_FOR_READY_54   4F2
WAIT_FOR_READY_57   532
WAIT_FOR_READY_59   566
WAIT_FOR_READY_6    F8
WAIT_FOR_READY_62   5B0
WAIT_FOR_READY_64   5E4
WAIT_FOR_READY_67   630
WAIT_FOR_READY_69   664
WAIT_FOR_READY_72   6BE
WAIT_FOR_READY_74   6F2
WAIT_FOR_READY_77   732
WAIT_FOR_READY_79   766
WAIT_FOR_READY_82   7A6
WAIT_FOR_READY_84   7DA
WAIT_FOR_READY_88   826
WAIT_FOR_READY_9    11A
WAIT_FOR_READY_90   848
WAIT_FOR_READY_91   85C
WAIT_FOR_READY_94   87C
WAIT_FOR_READY_96   8A2
WAIT_FOR_READY_98   8D6
WAIT_FOR_SRECORD    360
Z                   AB8
_00000000           19A
_00000001           1AE
_00000002           49E
_00000003           894
_00000004           4AC
_00000005           6A6
_00000006           616
_00000007           894
_00000008           818
_00000009           894
_0000000A           9C8
_0000000B           B92
_0000000C           C86
_10000000           3FC
_10000001           466
_10000002           4B4
_10000003           51E
_10000004           528
_10000005           592
_10000006           5A6
_10000007           610
_10000008           61A
_10000009           69E
_1000000A           626
_1000000B           690
_1000000C           6B4
_1000000D           71E
_1000000E           728
_1000000F           792
_10000010           79C
_10000011           806
_10000012           898
_10000013           902
_10000014           C6A
_10000015           C8C
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           AC4
_20000005           AD4
_20000006           AE8
_20000007           B94
_20000008           BAC
_20000009           BF2
