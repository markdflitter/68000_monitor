00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 04/04/2021 19:27:56

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; need to think about byte writes / word writes - I can only write whole words...
00000000                             9  ; implement write to RAM for S1 record
00000000                            10  ; try running the monitor in RAM, grr, suddenly uses S2 records
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  ; burn the monitor into eeprom from code
00000000                            13  ;ram CHECK AT STARTUP??? WIOLL PREVEWNT RUNNIG CODE FROM RAM THOUGH, SO need cold/warm start
00000000                            14  ; check for escape during Z
00000000                            15  ; fix the DUART base address
00000000                            16  ; tidy up layout (indentation and comments)
00000000                            17  ; stop using two registers in download
00000000                            18  ; add a .W and .B variants of PRINT_REG
00000000                            19  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            20  ; fix being able to enter random chars when W'ing
00000000                            21  ;JMP -> BRA
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00E00000                 26  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 27  DISPLAY_            EQU $0
00000000  =00E00001                 28  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            29  
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00D30000                 32  DUART_BASE          EQU $D30000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  RRRR
00000000  =00D30001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00D30011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00D30009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000                            73  ; macros
00000000                            74  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            75  ; the input register is changed during the process
00000000                            76  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            77  BIN2HEX MACRO
00000000                            78    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            79    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            80    MOVE.B \1,\2
00000000                            81    ANDI.L #$F,\2
00000000                            82    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            83    ENDM
00000000                            84  
00000000                            85  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            86  ; the input register is changed during the process
00000000                            87  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            88  HEX2BIN MACRO
00000000                            89    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            90    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            91    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            92    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            93    ENDM
00000000                            94  
00000000                            95  ; send a single char to the serial port
00000000                            96  ; \1 = char to send, \2 = data register to use for status poll
00000000                            97  ; will stamp on D0 and D1 in debug mode
00000000                            98  PRINT_CHAR MACRO
00000000                            99  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           100      IFEQ DEBUG
00000000                           101        MOVE.B DUART_SRA,\2           ; read status register
00000000                           102        BTST #2,\2                    ; check for space to send
00000000                           103        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                           104        MOVE.B \1,DUART_TXA           ; send the next character
00000000                           105      ENDC
00000000                           106      
00000000                           107      IFNE DEBUG
00000000                           108        MOVE.B \1,D1
00000000                           109        MOVE.L #6,D0   
00000000                           110        TRAP #15                      ; write to terminal in simulator
00000000                           111      ENDC
00000000                           112  
00000000                           113      ENDM
00000000                           114  
00000000                           115  ; send CR,LF to the serial port
00000000                           116  ; \1 = data register to use for status poll
00000000                           117  PRINT_CRLF MACRO                  
00000000                           118      PRINT_CHAR #13,\1             ; CR
00000000                           119      PRINT_CHAR #10,\1             ; LF
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send C-style, zero terminated string to the serial port
00000000                           123  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           124  PRINT_STR MACRO
00000000                           125  LOOP\@
00000000                           126      CMP.B #0,(\1)                 ; 0 -> done
00000000                           127      BEQ EXIT\@
00000000                           128      PRINT_CHAR (\1)+,\2
00000000                           129      JMP LOOP\@
00000000                           130  EXIT\@
00000000                           131      ENDM
00000000                           132    
00000000                           133  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           134  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           135  PRINT_REG MACRO
00000000                           136      PRINT_CHAR #'0',\2          ;0x header
00000000                           137      PRINT_CHAR #'x',\2
00000000                           138      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           139  LOOP\@
00000000                           140      BIN2HEX \1,\3,\5
00000000                           141      PRINT_CHAR \3,\2
00000000                           142      DBEQ \4,LOOP\@
00000000                           143      ENDM
00000000                           144    
00000000                           145  ; wait for a char from the serial port
00000000                           146  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           147  ; will stamp on D0 and D1 in debug mode
00000000                           148  WAIT_CHAR MACRO
00000000                           149  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           150  
00000000                           151      IFEQ DEBUG
00000000                           152        MOVE.B DUART_SRA,\2         ; read status register
00000000                           153        BTST #0,\2                    ; check for character
00000000                           154        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           155      ENDC
00000000                           156      
00000000                           157      READ_CHAR \1
00000000                           158  
00000000                           159      IFEQ DEBUG
00000000                           160        PRINT_CHAR \1,\2            ; echo it back
00000000                           161      ENDC
00000000                           162      ENDM
00000000                           163      
00000000                           164  ; read a char from the serial port - assumes that there is one!
00000000                           165  ; \ 1= data register for read char
00000000                           166  ; will stamp on D0 and D1 in debug mode
00000000                           167  READ_CHAR MACRO
00000000                           168      IFEQ DEBUG
00000000                           169        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           170      ENDC
00000000                           171      IFNE DEBUG
00000000                           172        MOVE.L #5,D0    
00000000                           173        TRAP #15                    ; read from keyboard in simulator
00000000                           174        MOVE.L D1,\1
00000000                           175      ENDC
00000000                           176       
00000000                           177      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           178      BEQ START
00000000                           179      ENDM
00000000                           180      
00000000                           181      
00000000                           182  ; read data from the download serial port
00000000                           183  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           184  DOWNLOAD MACRO
00000000                           185  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           186  
00000000                           187      MOVE.B DUART_SRA,\2           ; check for command
00000000                           188      BTST #0,\2                    ; check for character
00000000                           189      BEQ CONTINUE\@                ; nothing, continue
00000000                           190   
00000000                           191      READ_CHAR \1
00000000                           192  CONTINUE\@
00000000                           193      MOVE.B DUART_SRB,\2         ; read status register
00000000                           194      BTST #0,\2                  ; check for character
00000000                           195      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           196      
00000000                           197      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           198      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           199      
00000000                           200      ENDM
00000000                           201  
00000000                           202  
00000000                           203  ; register catalogue
00000000                           204  ; D0 - used for simulator I/O
00000000                           205  ; D1 - used for simulator I/O
00000000                           206  ; D2 - read character
00000000                           207  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           208  ; D4 - count of S records read
00000000                           209  ; D5 - data to write / data read / byte count for S record load
00000000                           210  ; D6 - working register used in R/W and download
00000000                           211  ; D7 - address accumulator / reset by download
00000000                           212  ; A0 - address of string to print 
00000000                           213  
00000000                           214  ; start vector
00000000                           215      ;ORG  $0
00200000                           216      ORG  $200000
00200000= 00000000                 217      DC.L $00000000              ; PC
00200004= 00000000                 218      DC.L $00000000              ; SP
00200008                           219      
00200008                           220  ; start of program  
00200008                           221  START
00200008  13FC 0000 00E00001       222      MOVE.B #0,DISPLAY
00200010                           223  
00200010                           224  ; reset the UART in case of warm start
00200010  13FC 000A 00D30005       225      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00200018  13FC 0050 00D30005       226      MOVE.B #$50,DUART_CRA           ; reset everyting
00200020  4E71                     227      NOP
00200022  13FC 0040 00D30005       228      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     229      NOP
0020002C  13FC 0030 00D30005       230      MOVE.B #$30,DUART_CRA
00200034  4E71                     231      NOP
00200036  13FC 0020 00D30005       232      MOVE.B #$20,DUART_CRA
0020003E  4E71                     233      NOP
00200040  13FC 0010 00D30005       234      MOVE.B #$10,DUART_CRA   
00200048                           235  
00200048  13FC 000A 00D30015       236      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00200050  13FC 0050 00D30015       237      MOVE.B #$50,DUART_CRB           ; reset everyting
00200058  4E71                     238      NOP
0020005A  13FC 0040 00D30015       239      MOVE.B #$40,DUART_CRB           
00200062  4E71                     240      NOP
00200064  13FC 0030 00D30015       241      MOVE.B #$30,DUART_CRB
0020006C  4E71                     242      NOP
0020006E  13FC 0020 00D30015       243      MOVE.B #$20,DUART_CRB
00200076  4E71                     244      NOP
00200078  13FC 0010 00D30015       245      MOVE.B #$10,DUART_CRB   
00200080                           246  
00200080                           247  ;initialise UART
00200080  13FC 0000 00D30009       248      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00D3000B       249      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00200090  13FC 0000 00D3001B       250      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00200098                           251  
00200098                           252  ; channel A
00200098  13FC 0013 00D30001       253      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00D30001       254      MOVE.B #$07,DUART_MRA           ; 1 stop bit
002000A8  13FC 00BB 00D30003       255      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
002000B0  13FC 0005 00D30005       256      MOVE.B #$5,DUART_CRA            ; enable rx & tx
002000B8                           257  
002000B8                           258  ; channel B
002000B8  13FC 0013 00D30011       259      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00D30011       260      MOVE.B #$07,DUART_MRB           ; 1 stop bit
002000C8  13FC 00BB 00D30013       261      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
002000D0  13FC 0005 00D30015       262      MOVE.B #$5,DUART_CRB            ; enable rx & tx
002000D8                           263  
002000D8                           264m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
002000D8                           265m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      266m     IFEQ DEBUG
002000D8  1639 00D30003            267m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000DE  0803 0002                268m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000E2  67F4                     269m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00D30007       270m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
002000EC                           271m     ENDC
002000EC                           272m     
002000EC                 FALSE     273m     IFNE DEBUG
002000EC                           274m     ENDC
002000EC                           275m 
002000EC                           276m     ENDM
002000EC                           277  
002000EC  13FC 0001 00E00001       278      MOVE.B #1,DISPLAY
002000F4                           279         
002000F4                           280m     PRINT_CRLF D3
002000F4                           281mm     PRINT_CHAR #13,D3             ; CR
002000F4                           282mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      283mm     IFEQ DEBUG
002000F4  1639 00D30003            284mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000FA  0803 0002                285mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000FE  67F4                     286mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00D30007       287mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200108                           288mm     ENDC
00200108                           289mm     
00200108                 FALSE     290mm     IFNE DEBUG
00200108                           291mm     ENDC
00200108                           292mm 
00200108                           293mm     ENDM
00200108                           294mm     PRINT_CHAR #10,D3             ; LF
00200108                           295mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      296mm     IFEQ DEBUG
00200108  1639 00D30003            297mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020010E  0803 0002                298mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200112  67F4                     299mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00D30007       300mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020011C                           301mm     ENDC
0020011C                           302mm     
0020011C                 FALSE     303mm     IFNE DEBUG
0020011C                           304mm     ENDC
0020011C                           305mm 
0020011C                           306mm     ENDM
0020011C                           307m     ENDM
0020011C                           308  
0020011C  41F9 00201440            309      LEA VERSION,A0
00200122                           310m     PRINT_STR A0,D3
00200122                           311m LOOP_5
00200122  0C10 0000                312m     CMP.B #0,(A0)                 ; 0 -> DONE
00200126  6700 001A                313m     BEQ EXIT_5
0020012A                           314mm     PRINT_CHAR (A0)+,D3
0020012A                           315mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      316mm     IFEQ DEBUG
0020012A  1639 00D30003            317mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200130  0803 0002                318mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200134  67F4                     319mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00200136  13D8 00D30007            320mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020013C                           321mm     ENDC
0020013C                           322mm     
0020013C                 FALSE     323mm     IFNE DEBUG
0020013C                           324mm     ENDC
0020013C                           325mm 
0020013C                           326mm     ENDM
0020013C  4EF9 00200122            327m     JMP LOOP_5
00200142                           328m EXIT_5
00200142                           329m     ENDM
00200142                           330m     PRINT_CRLF D3
00200142                           331mm     PRINT_CHAR #13,D3             ; CR
00200142                           332mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      333mm     IFEQ DEBUG
00200142  1639 00D30003            334mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200148  0803 0002                335mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020014C  67F4                     336mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00D30007       337mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200156                           338mm     ENDC
00200156                           339mm     
00200156                 FALSE     340mm     IFNE DEBUG
00200156                           341mm     ENDC
00200156                           342mm 
00200156                           343mm     ENDM
00200156                           344mm     PRINT_CHAR #10,D3             ; LF
00200156                           345mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      346mm     IFEQ DEBUG
00200156  1639 00D30003            347mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020015C  0803 0002                348mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200160  67F4                     349mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00D30007       350mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020016A                           351mm     ENDC
0020016A                           352mm     
0020016A                 FALSE     353mm     IFNE DEBUG
0020016A                           354mm     ENDC
0020016A                           355mm 
0020016A                           356mm     ENDM
0020016A                           357m     ENDM
0020016A                           358m     PRINT_CHAR #7,D3
0020016A                           359m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      360m     IFEQ DEBUG
0020016A  1639 00D30003            361m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200170  0803 0002                362m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200174  67F4                     363m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00D30007       364m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020017E                           365m     ENDC
0020017E                           366m     
0020017E                 FALSE     367m     IFNE DEBUG
0020017E                           368m     ENDC
0020017E                           369m 
0020017E                           370m     ENDM
0020017E                           371  
0020017E  7E00                     372      MOVE.L #0,D7                    ; address accumulator
00200180                           373  
00200180  13FC 0002 00E00001       374      MOVE.B #2,DISPLAY
00200188                           375  MAIN_LOOP
00200188                           376m     PRINT_CHAR #'>',D3               ; prompt
00200188                           377m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      378m     IFEQ DEBUG
00200188  1639 00D30003            379m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020018E  0803 0002                380m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200192  67F4                     381m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00D30007       382m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0020019C                           383m     ENDC
0020019C                           384m     
0020019C                 FALSE     385m     IFNE DEBUG
0020019C                           386m     ENDC
0020019C                           387m 
0020019C                           388m     ENDM
0020019C                           389m     PRINT_CHAR #32,D3                ; space
0020019C                           390m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      391m     IFEQ DEBUG
0020019C  1639 00D30003            392m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001A2  0803 0002                393m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001A6  67F4                     394m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00D30007       395m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
002001B0                           396m     ENDC
002001B0                           397m     
002001B0                 FALSE     398m     IFNE DEBUG
002001B0                           399m     ENDC
002001B0                           400m 
002001B0                           401m     ENDM
002001B0                           402      
002001B0                           403  GET_INPUT
002001B0                           404m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
002001B0                           405m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           406m 
002001B0                 TRUE      407m     IFEQ DEBUG
002001B0  1639 00D30003            408m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002001B6  0803 0000                409m       BTST #0,D3                    ; CHECK FOR CHARACTER
002001BA  67F4                     410m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
002001BC                           411m     ENDC
002001BC                           412m     
002001BC                           413mm     READ_CHAR D2
002001BC                 TRUE      414mm     IFEQ DEBUG
002001BC  1439 00D30007            415mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002001C2                           416mm     ENDC
002001C2                 FALSE     417mm     IFNE DEBUG
002001C2                           418mm     ENDC
002001C2                           419mm      
002001C2  B43C 001B                420mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                421mm     BEQ START
002001CA                           422mm     ENDM
002001CA                           423m 
002001CA                 TRUE      424m     IFEQ DEBUG
002001CA                           425mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002001CA                           426mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      427mm     IFEQ DEBUG
002001CA  1639 00D30003            428mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001D0  0803 0002                429mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001D4  67F4                     430mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
002001D6  13C2 00D30007            431mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002001DC                           432mm     ENDC
002001DC                           433mm     
002001DC                 FALSE     434mm     IFNE DEBUG
002001DC                           435mm     ENDC
002001DC                           436mm 
002001DC                           437mm     ENDM
002001DC                           438m     ENDC
002001DC                           439m     ENDM
002001DC                           440      
002001DC  B43C 0030                441      CMP.B #'0',D2
002001E0  6700 123C                442      BEQ HEX_DIGIT
002001E4  B43C 0031                443      CMP.B #'1',D2
002001E8  6700 1234                444      BEQ HEX_DIGIT
002001EC  B43C 0032                445      CMP.B #'2',D2
002001F0  6700 122C                446      BEQ HEX_DIGIT
002001F4  B43C 0033                447      CMP.B #'3',D2
002001F8  6700 1224                448      BEQ HEX_DIGIT
002001FC  B43C 0034                449      CMP.B #'4',D2
00200200  6700 121C                450      BEQ HEX_DIGIT
00200204  B43C 0035                451      CMP.B #'5',D2
00200208  6700 1214                452      BEQ HEX_DIGIT
0020020C  B43C 0036                453      CMP.B #'6',D2
00200210  6700 120C                454      BEQ HEX_DIGIT
00200214  B43C 0037                455      CMP.B #'7',D2
00200218  6700 1204                456      BEQ HEX_DIGIT
0020021C  B43C 0038                457      CMP.B #'8',D2
00200220  6700 11FC                458      BEQ HEX_DIGIT
00200224  B43C 0039                459      CMP.B #'9',D2
00200228  6700 11F4                460      BEQ HEX_DIGIT
0020022C  B43C 0041                461      CMP.B #'A',D2
00200230  6700 11EC                462      BEQ HEX_DIGIT
00200234  B43C 0042                463      CMP.B #'B',D2
00200238  6700 11E4                464      BEQ HEX_DIGIT
0020023C  B43C 0043                465      CMP.B #'C',D2
00200240  6700 11DC                466      BEQ HEX_DIGIT
00200244  B43C 0044                467      CMP.B #'D',D2
00200248  6700 11D4                468      BEQ HEX_DIGIT
0020024C  B43C 0045                469      CMP.B #'E',D2
00200250  6700 11CC                470      BEQ HEX_DIGIT
00200254  B43C 0046                471      CMP.B #'F',D2
00200258  6700 11C4                472      BEQ HEX_DIGIT
0020025C                           473      
0020025C  B43C 0057                474      CMP.B #'W',D2
00200260  6700 0166                475      BEQ W
00200264                           476  
00200264                           477m     PRINT_CRLF D3
00200264                           478mm     PRINT_CHAR #13,D3             ; CR
00200264                           479mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200264                 TRUE      480mm     IFEQ DEBUG
00200264  1639 00D30003            481mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020026A  0803 0002                482mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020026E  67F4                     483mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
00200270  13FC 000D 00D30007       484mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200278                           485mm     ENDC
00200278                           486mm     
00200278                 FALSE     487mm     IFNE DEBUG
00200278                           488mm     ENDC
00200278                           489mm 
00200278                           490mm     ENDM
00200278                           491mm     PRINT_CHAR #10,D3             ; LF
00200278                           492mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200278                 TRUE      493mm     IFEQ DEBUG
00200278  1639 00D30003            494mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020027E  0803 0002                495mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200282  67F4                     496mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00200284  13FC 000A 00D30007       497mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020028C                           498mm     ENDC
0020028C                           499mm     
0020028C                 FALSE     500mm     IFNE DEBUG
0020028C                           501mm     ENDC
0020028C                           502mm 
0020028C                           503mm     ENDM
0020028C                           504m     ENDM
0020028C                           505   
0020028C  B43C 003F                506      CMP.B #'?',D2
00200290  6700 0056                507      BEQ H
00200294                           508  
00200294  B43C 0056                509      CMP.B #'V',D2
00200298  6700 007A                510      BEQ V
0020029C                           511      
0020029C  B43C 0052                512      CMP.B #'R',D2
002002A0  6700 009E                513      BEQ R
002002A4                           514  
002002A4  B43C 0053                515      CMP.B #'S',D2
002002A8  6700 01E6                516      BEQ S
002002AC                           517  
002002AC  B43C 0047                518      CMP.B #'G',D2
002002B0  6700 1058                519      BEQ G   
002002B4                           520  
002002B4  B43C 005A                521      CMP.B #'Z',D2
002002B8  6700 1058                522      BEQ Z   
002002BC                           523  
002002BC  41F9 002014D6            524      LEA HUH,A0
002002C2                           525m     PRINT_STR A0,D3
002002C2                           526m LOOP_19
002002C2  0C10 0000                527m     CMP.B #0,(A0)                 ; 0 -> DONE
002002C6  6700 001A                528m     BEQ EXIT_19
002002CA                           529mm     PRINT_CHAR (A0)+,D3
002002CA                           530mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002CA                 TRUE      531mm     IFEQ DEBUG
002002CA  1639 00D30003            532mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002002D0  0803 0002                533mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002002D4  67F4                     534mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
002002D6  13D8 00D30007            535mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002002DC                           536mm     ENDC
002002DC                           537mm     
002002DC                 FALSE     538mm     IFNE DEBUG
002002DC                           539mm     ENDC
002002DC                           540mm 
002002DC                           541mm     ENDM
002002DC  4EF9 002002C2            542m     JMP LOOP_19
002002E2                           543m EXIT_19
002002E2                           544m     ENDM
002002E2                           545                         
002002E2  4EF9 00200188            546      JMP MAIN_LOOP
002002E8                           547      
002002E8                           548  ; commands
002002E8  41F9 0020145D            549  H   LEA HELP,A0
002002EE                           550m     PRINT_STR A0,D3
002002EE                           551m LOOP_21
002002EE  0C10 0000                552m     CMP.B #0,(A0)                 ; 0 -> DONE
002002F2  6700 001A                553m     BEQ EXIT_21
002002F6                           554mm     PRINT_CHAR (A0)+,D3
002002F6                           555mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002F6                 TRUE      556mm     IFEQ DEBUG
002002F6  1639 00D30003            557mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002002FC  0803 0002                558mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200300  67F4                     559mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
00200302  13D8 00D30007            560mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200308                           561mm     ENDC
00200308                           562mm     
00200308                 FALSE     563mm     IFNE DEBUG
00200308                           564mm     ENDC
00200308                           565mm 
00200308                           566mm     ENDM
00200308  4EF9 002002EE            567m     JMP LOOP_21
0020030E                           568m EXIT_21
0020030E                           569m     ENDM
0020030E  4EF9 00200188            570      JMP MAIN_LOOP
00200314                           571  
00200314  41F9 00201440            572  V   LEA VERSION,A0
0020031A                           573m     PRINT_STR A0,D3       
0020031A                           574m LOOP_23
0020031A  0C10 0000                575m     CMP.B #0,(A0)                 ; 0 -> DONE
0020031E  6700 001A                576m     BEQ EXIT_23
00200322                           577mm     PRINT_CHAR (A0)+,D3
00200322                           578mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200322                 TRUE      579mm     IFEQ DEBUG
00200322  1639 00D30003            580mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200328  0803 0002                581mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020032C  67F4                     582mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0020032E  13D8 00D30007            583mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200334                           584mm     ENDC
00200334                           585mm     
00200334                 FALSE     586mm     IFNE DEBUG
00200334                           587mm     ENDC
00200334                           588mm 
00200334                           589mm     ENDM
00200334  4EF9 0020031A            590m     JMP LOOP_23
0020033A                           591m EXIT_23
0020033A                           592m     ENDM
0020033A  4EF9 00200188            593      JMP MAIN_LOOP
00200340                           594      
00200340                           595  R   
00200340  2047                     596      MOVE.L D7,A0                    ; address accumulator -> address register
00200342  2A10                     597      MOVE.L (A0),D5                  ; read the memory and print it
00200344                           598m     PRINT_REG D5,D3,D7,D6,A0
00200344                           599mm     PRINT_CHAR #'0',D3          ;0X HEADER
00200344                           600mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200344                 TRUE      601mm     IFEQ DEBUG
00200344  1639 00D30003            602mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020034A  0803 0002                603mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020034E  67F4                     604mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00200350  13FC 0030 00D30007       605mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00200358                           606mm     ENDC
00200358                           607mm     
00200358                 FALSE     608mm     IFNE DEBUG
00200358                           609mm     ENDC
00200358                           610mm 
00200358                           611mm     ENDM
00200358                           612mm     PRINT_CHAR #'x',D3
00200358                           613mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200358                 TRUE      614mm     IFEQ DEBUG
00200358  1639 00D30003            615mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020035E  0803 0002                616mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200362  67F4                     617mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00200364  13FC 0078 00D30007       618mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0020036C                           619mm     ENDC
0020036C                           620mm     
0020036C                 FALSE     621mm     IFNE DEBUG
0020036C                           622mm     ENDC
0020036C                           623mm 
0020036C                           624mm     ENDM
0020036C  7C07                     625m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0020036E                           626m LOOP_25
0020036E                           627mm     BIN2HEX D5,D7,A0
0020036E  41F9 00201573            628mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00200374  E99D                     629mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200376  1E05                     630mm   MOVE.B D5,D7
00200378  0287 0000000F            631mm   ANDI.L #$F,D7
0020037E  1E30 7000                632mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00200382                           633mm   ENDM
00200382                           634mm     PRINT_CHAR D7,D3
00200382                           635mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200382                 TRUE      636mm     IFEQ DEBUG
00200382  1639 00D30003            637mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200388  0803 0002                638mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020038C  67F4                     639mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
0020038E  13C7 00D30007            640mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00200394                           641mm     ENDC
00200394                           642mm     
00200394                 FALSE     643mm     IFNE DEBUG
00200394                           644mm     ENDC
00200394                           645mm 
00200394                           646mm     ENDM
00200394  57CE FFD8                647m     DBEQ D6,LOOP_25
00200398                           648m     ENDM
00200398                           649m     PRINT_CRLF D3
00200398                           650mm     PRINT_CHAR #13,D3             ; CR
00200398                           651mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200398                 TRUE      652mm     IFEQ DEBUG
00200398  1639 00D30003            653mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020039E  0803 0002                654mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003A2  67F4                     655mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
002003A4  13FC 000D 00D30007       656mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002003AC                           657mm     ENDC
002003AC                           658mm     
002003AC                 FALSE     659mm     IFNE DEBUG
002003AC                           660mm     ENDC
002003AC                           661mm 
002003AC                           662mm     ENDM
002003AC                           663mm     PRINT_CHAR #10,D3             ; LF
002003AC                           664mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003AC                 TRUE      665mm     IFEQ DEBUG
002003AC  1639 00D30003            666mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003B2  0803 0002                667mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003B6  67F4                     668mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
002003B8  13FC 000A 00D30007       669mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002003C0                           670mm     ENDC
002003C0                           671mm     
002003C0                 FALSE     672mm     IFNE DEBUG
002003C0                           673mm     ENDC
002003C0                           674mm 
002003C0                           675mm     ENDM
002003C0                           676m     ENDM
002003C0  7E00                     677      MOVE.L #0,D7                    ; clear the now used address accumulator
002003C2  4EF9 00200188            678      JMP MAIN_LOOP
002003C8                           679  
002003C8  7A00                     680  W   MOVE.L #0,D5                    ; D5 will be the value to write            
002003CA                           681  
002003CA                           682m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
002003CA                           683m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003CA                           684m 
002003CA                 TRUE      685m     IFEQ DEBUG
002003CA  1639 00D30003            686m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002003D0  0803 0000                687m       BTST #0,D3                    ; CHECK FOR CHARACTER
002003D4  67F4                     688m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
002003D6                           689m     ENDC
002003D6                           690m     
002003D6                           691mm     READ_CHAR D2
002003D6                 TRUE      692mm     IFEQ DEBUG
002003D6  1439 00D30007            693mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002003DC                           694mm     ENDC
002003DC                 FALSE     695mm     IFNE DEBUG
002003DC                           696mm     ENDC
002003DC                           697mm      
002003DC  B43C 001B                698mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002003E0  6700 FC26                699mm     BEQ START
002003E4                           700mm     ENDM
002003E4                           701m 
002003E4                 TRUE      702m     IFEQ DEBUG
002003E4                           703mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
002003E4                           704mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003E4                 TRUE      705mm     IFEQ DEBUG
002003E4  1639 00D30003            706mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003EA  0803 0002                707mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003EE  67F4                     708mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
002003F0  13C2 00D30007            709mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002003F6                           710mm     ENDC
002003F6                           711mm     
002003F6                 FALSE     712mm     IFNE DEBUG
002003F6                           713mm     ENDC
002003F6                           714mm 
002003F6                           715mm     ENDM
002003F6                           716m     ENDC
002003F6                           717m     ENDM
002003F6                           718m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002003F6  41F9 00201583            719m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002003FC  0402 0030                720m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200400  C4BC 000000FF            721m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200406  1430 2000                722m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020040A                           723m   ENDM
0020040A  1A02                     724      MOVE.B D2,D5                    ; put at bottom of D5
0020040C                           725  
0020040C  3C3C 0006                726      MOVE #6,D6                      ; 7 bytes left to read
00200410                           727      
00200410                           728  READ_DATA_TO_POKE
00200410  E98D                     729      LSL.L #4,D5                     ; make what we have so far more significant
00200412                           730m     WAIT_CHAR D2,D3                 ; next character -> D2
00200412                           731m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200412                           732m 
00200412                 TRUE      733m     IFEQ DEBUG
00200412  1639 00D30003            734m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00200418  0803 0000                735m       BTST #0,D3                    ; CHECK FOR CHARACTER
0020041C  67F4                     736m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
0020041E                           737m     ENDC
0020041E                           738m     
0020041E                           739mm     READ_CHAR D2
0020041E                 TRUE      740mm     IFEQ DEBUG
0020041E  1439 00D30007            741mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200424                           742mm     ENDC
00200424                 FALSE     743mm     IFNE DEBUG
00200424                           744mm     ENDC
00200424                           745mm      
00200424  B43C 001B                746mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200428  6700 FBDE                747mm     BEQ START
0020042C                           748mm     ENDM
0020042C                           749m 
0020042C                 TRUE      750m     IFEQ DEBUG
0020042C                           751mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0020042C                           752mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020042C                 TRUE      753mm     IFEQ DEBUG
0020042C  1639 00D30003            754mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200432  0803 0002                755mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200436  67F4                     756mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00200438  13C2 00D30007            757mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020043E                           758mm     ENDC
0020043E                           759mm     
0020043E                 FALSE     760mm     IFNE DEBUG
0020043E                           761mm     ENDC
0020043E                           762mm 
0020043E                           763mm     ENDM
0020043E                           764m     ENDC
0020043E                           765m     ENDM
0020043E                           766m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
0020043E  41F9 00201583            767m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200444  0402 0030                768m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200448  C4BC 000000FF            769m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020044E  1430 2000                770m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200452                           771m   ENDM
00200452  8A02                     772      OR.B D2,D5
00200454  023C 00FB                773      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00200458  57CE FFB6                774      DBEQ D6,READ_DATA_TO_POKE
0020045C                           775      
0020045C  2047                     776      MOVE.L D7,A0                    ; address accumulator -> address register
0020045E  7E00                     777      MOVE.L #0,D7                    ; clear the now used address accumulator
00200460                           778      
00200460  2085                     779      MOVE.L D5,(A0)                  ; write the data
00200462                           780  
00200462                           781m     PRINT_CRLF D3
00200462                           782mm     PRINT_CHAR #13,D3             ; CR
00200462                           783mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200462                 TRUE      784mm     IFEQ DEBUG
00200462  1639 00D30003            785mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200468  0803 0002                786mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020046C  67F4                     787mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
0020046E  13FC 000D 00D30007       788mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200476                           789mm     ENDC
00200476                           790mm     
00200476                 FALSE     791mm     IFNE DEBUG
00200476                           792mm     ENDC
00200476                           793mm 
00200476                           794mm     ENDM
00200476                           795mm     PRINT_CHAR #10,D3             ; LF
00200476                           796mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200476                 TRUE      797mm     IFEQ DEBUG
00200476  1639 00D30003            798mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020047C  0803 0002                799mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200480  67F4                     800mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
00200482  13FC 000A 00D30007       801mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020048A                           802mm     ENDC
0020048A                           803mm     
0020048A                 FALSE     804mm     IFNE DEBUG
0020048A                           805mm     ENDC
0020048A                           806mm 
0020048A                           807mm     ENDM
0020048A                           808m     ENDM
0020048A  4EF9 00200188            809      JMP MAIN_LOOP
00200490                           810  
00200490                           811  
00200490  7800                     812  S   MOVE.L #0,D4                    ; count of records read -> D4
00200492  2478 0000                813      MOVE.L 0,A2                     ; start address -> A2
00200496                           814      
00200496                           815  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00200496                           816m     DOWNLOAD D2,D3                  
00200496                           817m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200496                           818m 
00200496  1639 00D30003            819m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020049C  0803 0000                820m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004A0  6700 0010                821m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
002004A4                           822m  
002004A4                           823mm     READ_CHAR D2
002004A4                 TRUE      824mm     IFEQ DEBUG
002004A4  1439 00D30007            825mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002004AA                           826mm     ENDC
002004AA                 FALSE     827mm     IFNE DEBUG
002004AA                           828mm     ENDC
002004AA                           829mm      
002004AA  B43C 001B                830mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002004AE  6700 FB58                831mm     BEQ START
002004B2                           832mm     ENDM
002004B2                           833m CONTINUE_44
002004B2  1639 00D30013            834m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004B8  0803 0000                835m     BTST #0,D3                  ; CHECK FOR CHARACTER
002004BC  67D8                     836m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
002004BE                           837m     
002004BE  1439 00D30017            838m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002004C4  13C2 00E00001            839m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002004CA                           840m     
002004CA                           841m     ENDM
002004CA  B43C 0053                842      CMP.B #'S',D2                   ; found S?    
002004CE  66C6                     843      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
002004D0                           844      
002004D0  5284                     845      ADD.L #1,D4                     ; read another S record, increment count
002004D2                           846      
002004D2                           847m     DOWNLOAD D7,D3                  ; read the record digit
002004D2                           848m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004D2                           849m 
002004D2  1639 00D30003            850m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004D8  0803 0000                851m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004DC  6700 0010                852m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
002004E0                           853m  
002004E0                           854mm     READ_CHAR D7
002004E0                 TRUE      855mm     IFEQ DEBUG
002004E0  1E39 00D30007            856mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
002004E6                           857mm     ENDC
002004E6                 FALSE     858mm     IFNE DEBUG
002004E6                           859mm     ENDC
002004E6                           860mm      
002004E6  BE3C 001B                861mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
002004EA  6700 FB1C                862mm     BEQ START
002004EE                           863mm     ENDM
002004EE                           864m CONTINUE_46
002004EE  1639 00D30013            865m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004F4  0803 0000                866m     BTST #0,D3                  ; CHECK FOR CHARACTER
002004F8  67D8                     867m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
002004FA                           868m     
002004FA  1E39 00D30017            869m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
00200500  13C7 00E00001            870m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
00200506                           871m     
00200506                           872m     ENDM
00200506                           873  
00200506  7C00                     874      MOVE.L #0,D6                    ; checksum
00200508                           875  
00200508  7A00                     876      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
0020050A                           877m     DOWNLOAD D2,D3              
0020050A                           878m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020050A                           879m 
0020050A  1639 00D30003            880m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200510  0803 0000                881m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200514  6700 0010                882m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00200518                           883m  
00200518                           884mm     READ_CHAR D2
00200518                 TRUE      885mm     IFEQ DEBUG
00200518  1439 00D30007            886mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020051E                           887mm     ENDC
0020051E                 FALSE     888mm     IFNE DEBUG
0020051E                           889mm     ENDC
0020051E                           890mm      
0020051E  B43C 001B                891mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200522  6700 FAE4                892mm     BEQ START
00200526                           893mm     ENDM
00200526                           894m CONTINUE_48
00200526  1639 00D30013            895m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020052C  0803 0000                896m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200530  67D8                     897m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00200532                           898m     
00200532  1439 00D30017            899m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200538  13C2 00E00001            900m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020053E                           901m     
0020053E                           902m     ENDM
0020053E                           903m     HEX2BIN D2,D2,A0
0020053E  41F9 00201583            904m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200544  0402 0030                905m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200548  C4BC 000000FF            906m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020054E  1430 2000                907m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200552                           908m   ENDM
00200552  8A82                     909      OR.L D2,D5
00200554  E98D                     910      LSL.L #4,D5    
00200556                           911m     DOWNLOAD D2,D3
00200556                           912m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200556                           913m 
00200556  1639 00D30003            914m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020055C  0803 0000                915m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200560  6700 0010                916m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
00200564                           917m  
00200564                           918mm     READ_CHAR D2
00200564                 TRUE      919mm     IFEQ DEBUG
00200564  1439 00D30007            920mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020056A                           921mm     ENDC
0020056A                 FALSE     922mm     IFNE DEBUG
0020056A                           923mm     ENDC
0020056A                           924mm      
0020056A  B43C 001B                925mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020056E  6700 FA98                926mm     BEQ START
00200572                           927mm     ENDM
00200572                           928m CONTINUE_51
00200572  1639 00D30013            929m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200578  0803 0000                930m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020057C  67D8                     931m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
0020057E                           932m     
0020057E  1439 00D30017            933m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200584  13C2 00E00001            934m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020058A                           935m     
0020058A                           936m     ENDM
0020058A                           937m     HEX2BIN D2,D2,A0  
0020058A  41F9 00201583            938m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200590  0402 0030                939m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200594  C4BC 000000FF            940m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020059A  1430 2000                941m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020059E                           942m   ENDM
0020059E  8A82                     943      OR.L D2,D5
002005A0                           944                  
002005A0  DC85                     945      ADD.L D5,D6                     ; add byte count into checksum
002005A2                           946  
002005A2                           947      IF.B D7 <EQ> #'0' THEN.L        ; header
002005AA  7E00                     948          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
002005AC                           949m         DOWNLOAD D2,D3              ; top byte
002005AC                           950m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005AC                           951m 
002005AC  1639 00D30003            952m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002005B2  0803 0000                953m     BTST #0,D3                    ; CHECK FOR CHARACTER
002005B6  6700 0010                954m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
002005BA                           955m  
002005BA                           956mm     READ_CHAR D2
002005BA                 TRUE      957mm     IFEQ DEBUG
002005BA  1439 00D30007            958mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002005C0                           959mm     ENDC
002005C0                 FALSE     960mm     IFNE DEBUG
002005C0                           961mm     ENDC
002005C0                           962mm      
002005C0  B43C 001B                963mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002005C4  6700 FA42                964mm     BEQ START
002005C8                           965mm     ENDM
002005C8                           966m CONTINUE_54
002005C8  1639 00D30013            967m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002005CE  0803 0000                968m     BTST #0,D3                  ; CHECK FOR CHARACTER
002005D2  67D8                     969m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
002005D4                           970m     
002005D4  1439 00D30017            971m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002005DA  13C2 00E00001            972m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002005E0                           973m     
002005E0                           974m     ENDM
002005E0                           975m         HEX2BIN D2,D2,A0
002005E0  41F9 00201583            976m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002005E6  0402 0030                977m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005EA  C4BC 000000FF            978m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005F0  1430 2000                979m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005F4                           980m   ENDM
002005F4  8E82                     981          OR.L D2,D7
002005F6  E98F                     982          LSL.L #4,D7
002005F8                           983m         DOWNLOAD D2,D3         
002005F8                           984m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005F8                           985m 
002005F8  1639 00D30003            986m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002005FE  0803 0000                987m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200602  6700 0010                988m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
00200606                           989m  
00200606                           990mm     READ_CHAR D2
00200606                 TRUE      991mm     IFEQ DEBUG
00200606  1439 00D30007            992mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020060C                           993mm     ENDC
0020060C                 FALSE     994mm     IFNE DEBUG
0020060C                           995mm     ENDC
0020060C                           996mm      
0020060C  B43C 001B                997mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200610  6700 F9F6                998mm     BEQ START
00200614                           999mm     ENDM
00200614                          1000m CONTINUE_57
00200614  1639 00D30013           1001m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020061A  0803 0000               1002m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020061E  67D8                    1003m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
00200620                          1004m     
00200620  1439 00D30017           1005m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200626  13C2 00E00001           1006m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020062C                          1007m     
0020062C                          1008m     ENDM
0020062C                          1009m         HEX2BIN D2,D2,A0
0020062C  41F9 00201583           1010m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200632  0402 0030               1011m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200636  C4BC 000000FF           1012m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020063C  1430 2000               1013m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200640                          1014m   ENDM
00200640  8E82                    1015          OR.L D2,D7
00200642                          1016          
00200642  DC87                    1017          ADD.L D7,D6                 ; add top byte of address into checksum
00200644                          1018  
00200644  E98F                    1019          LSL.L #4,D7                 ; bottom byte
00200646                          1020m         DOWNLOAD D2,D3
00200646                          1021m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200646                          1022m 
00200646  1639 00D30003           1023m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020064C  0803 0000               1024m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200650  6700 0010               1025m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
00200654                          1026m  
00200654                          1027mm     READ_CHAR D2
00200654                 TRUE     1028mm     IFEQ DEBUG
00200654  1439 00D30007           1029mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020065A                          1030mm     ENDC
0020065A                 FALSE    1031mm     IFNE DEBUG
0020065A                          1032mm     ENDC
0020065A                          1033mm      
0020065A  B43C 001B               1034mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020065E  6700 F9A8               1035mm     BEQ START
00200662                          1036mm     ENDM
00200662                          1037m CONTINUE_60
00200662  1639 00D30013           1038m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200668  0803 0000               1039m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020066C  67D8                    1040m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
0020066E                          1041m     
0020066E  1439 00D30017           1042m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200674  13C2 00E00001           1043m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020067A                          1044m     
0020067A                          1045m     ENDM
0020067A                          1046m         HEX2BIN D2,D2,A0
0020067A  41F9 00201583           1047m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200680  0402 0030               1048m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200684  C4BC 000000FF           1049m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020068A  1430 2000               1050m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020068E                          1051m   ENDM
0020068E  8E82                    1052          OR.L D2,D7
00200690  E98F                    1053          LSL.L #4,D7        
00200692                          1054m         DOWNLOAD D2,D3
00200692                          1055m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200692                          1056m 
00200692  1639 00D30003           1057m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200698  0803 0000               1058m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020069C  6700 0010               1059m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
002006A0                          1060m  
002006A0                          1061mm     READ_CHAR D2
002006A0                 TRUE     1062mm     IFEQ DEBUG
002006A0  1439 00D30007           1063mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002006A6                          1064mm     ENDC
002006A6                 FALSE    1065mm     IFNE DEBUG
002006A6                          1066mm     ENDC
002006A6                          1067mm      
002006A6  B43C 001B               1068mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002006AA  6700 F95C               1069mm     BEQ START
002006AE                          1070mm     ENDM
002006AE                          1071m CONTINUE_63
002006AE  1639 00D30013           1072m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002006B4  0803 0000               1073m     BTST #0,D3                  ; CHECK FOR CHARACTER
002006B8  67D8                    1074m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
002006BA                          1075m     
002006BA  1439 00D30017           1076m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002006C0  13C2 00E00001           1077m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002006C6                          1078m     
002006C6                          1079m     ENDM
002006C6                          1080m         HEX2BIN D2,D2,A0
002006C6  41F9 00201583           1081m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002006CC  0402 0030               1082m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006D0  C4BC 000000FF           1083m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002006D6  1430 2000               1084m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002006DA                          1085m   ENDM
002006DA  8E82                    1086          OR.L D2,D7
002006DC                          1087          
002006DC  7400                    1088          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
002006DE  1407                    1089          MOVE.B D7,D2
002006E0  DC82                    1090          ADD.L D2,D6
002006E2                          1091          
002006E2  5785                    1092          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
002006E4                          1093          WHILE.L D5 <GT> #0 DO       ; read the data bytes
002006EE  5385                    1094            SUB.L #1,D5
002006F0                          1095              
002006F0  7E00                    1096            MOVE.L #0,D7              ; D7 holds the byte
002006F2                          1097              
002006F2                          1098m           DOWNLOAD D2,D3            ; MS 4 bits
002006F2                          1099m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006F2                          1100m 
002006F2  1639 00D30003           1101m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002006F8  0803 0000               1102m     BTST #0,D3                    ; CHECK FOR CHARACTER
002006FC  6700 0010               1103m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
00200700                          1104m  
00200700                          1105mm     READ_CHAR D2
00200700                 TRUE     1106mm     IFEQ DEBUG
00200700  1439 00D30007           1107mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200706                          1108mm     ENDC
00200706                 FALSE    1109mm     IFNE DEBUG
00200706                          1110mm     ENDC
00200706                          1111mm      
00200706  B43C 001B               1112mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020070A  6700 F8FC               1113mm     BEQ START
0020070E                          1114mm     ENDM
0020070E                          1115m CONTINUE_66
0020070E  1639 00D30013           1116m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200714  0803 0000               1117m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200718  67D8                    1118m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
0020071A                          1119m     
0020071A  1439 00D30017           1120m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200720  13C2 00E00001           1121m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200726                          1122m     
00200726                          1123m     ENDM
00200726                          1124m           HEX2BIN D2,D2,A0
00200726  41F9 00201583           1125m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020072C  0402 0030               1126m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200730  C4BC 000000FF           1127m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200736  1430 2000               1128m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020073A                          1129m   ENDM
0020073A  8E82                    1130            OR.L D2,D7
0020073C  E98F                    1131            LSL.L #4,D7
0020073E                          1132               
0020073E                          1133m           DOWNLOAD D2,D3            ; LS 4 bits    
0020073E                          1134m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020073E                          1135m 
0020073E  1639 00D30003           1136m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200744  0803 0000               1137m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200748  6700 0010               1138m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
0020074C                          1139m  
0020074C                          1140mm     READ_CHAR D2
0020074C                 TRUE     1141mm     IFEQ DEBUG
0020074C  1439 00D30007           1142mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200752                          1143mm     ENDC
00200752                 FALSE    1144mm     IFNE DEBUG
00200752                          1145mm     ENDC
00200752                          1146mm      
00200752  B43C 001B               1147mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200756  6700 F8B0               1148mm     BEQ START
0020075A                          1149mm     ENDM
0020075A                          1150m CONTINUE_69
0020075A  1639 00D30013           1151m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200760  0803 0000               1152m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200764  67D8                    1153m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00200766                          1154m     
00200766  1439 00D30017           1155m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020076C  13C2 00E00001           1156m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200772                          1157m     
00200772                          1158m     ENDM
00200772                          1159m           HEX2BIN D2,D2,A0
00200772  41F9 00201583           1160m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200778  0402 0030               1161m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020077C  C4BC 000000FF           1162m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200782  1430 2000               1163m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200786                          1164m   ENDM
00200786  8E82                    1165            OR.L D2,D7
00200788                          1166              
00200788  DC87                    1167            ADD.L D7,D6               ; add into checksum
0020078A                          1168            
0020078A                          1169m           PRINT_CHAR D7,D3          ; assume ASCII and print it
0020078A                          1170m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020078A                 TRUE     1171m     IFEQ DEBUG
0020078A  1639 00D30003           1172m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200790  0803 0002               1173m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200794  67F4                    1174m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
00200796  13C7 00D30007           1175m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020079C                          1176m     ENDC
0020079C                          1177m     
0020079C                 FALSE    1178m     IFNE DEBUG
0020079C                          1179m     ENDC
0020079C                          1180m 
0020079C                          1181m     ENDM
0020079C                          1182          ENDW
002007A0                          1183m         PRINT_CRLF D3
002007A0                          1184mm     PRINT_CHAR #13,D3             ; CR
002007A0                          1185mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007A0                 TRUE     1186mm     IFEQ DEBUG
002007A0  1639 00D30003           1187mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007A6  0803 0002               1188mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007AA  67F4                    1189mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
002007AC  13FC 000D 00D30007      1190mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002007B4                          1191mm     ENDC
002007B4                          1192mm     
002007B4                 FALSE    1193mm     IFNE DEBUG
002007B4                          1194mm     ENDC
002007B4                          1195mm 
002007B4                          1196mm     ENDM
002007B4                          1197mm     PRINT_CHAR #10,D3             ; LF
002007B4                          1198mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007B4                 TRUE     1199mm     IFEQ DEBUG
002007B4  1639 00D30003           1200mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007BA  0803 0002               1201mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007BE  67F4                    1202mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
002007C0  13FC 000A 00D30007      1203mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002007C8                          1204mm     ENDC
002007C8                          1205mm     
002007C8                 FALSE    1206mm     IFNE DEBUG
002007C8                          1207mm     ENDC
002007C8                          1208mm 
002007C8                          1209mm     ENDM
002007C8                          1210m     ENDM
002007C8  43F9 00200496           1211         LEA WAIT_FOR_SRECORD,A1            
002007CE                          1212      ELSE
002007D2                          1213        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
002007DA  7E00                    1214          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007DC                          1215m         DOWNLOAD D2,D3              ; top byte
002007DC                          1216m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007DC                          1217m 
002007DC  1639 00D30003           1218m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002007E2  0803 0000               1219m     BTST #0,D3                    ; CHECK FOR CHARACTER
002007E6  6700 0010               1220m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
002007EA                          1221m  
002007EA                          1222mm     READ_CHAR D2
002007EA                 TRUE     1223mm     IFEQ DEBUG
002007EA  1439 00D30007           1224mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002007F0                          1225mm     ENDC
002007F0                 FALSE    1226mm     IFNE DEBUG
002007F0                          1227mm     ENDC
002007F0                          1228mm      
002007F0  B43C 001B               1229mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002007F4  6700 F812               1230mm     BEQ START
002007F8                          1231mm     ENDM
002007F8                          1232m CONTINUE_76
002007F8  1639 00D30013           1233m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002007FE  0803 0000               1234m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200802  67D8                    1235m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
00200804                          1236m     
00200804  1439 00D30017           1237m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020080A  13C2 00E00001           1238m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200810                          1239m     
00200810                          1240m     ENDM
00200810                          1241m         PRINT_CHAR D2,D3
00200810                          1242m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200810                 TRUE     1243m     IFEQ DEBUG
00200810  1639 00D30003           1244m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200816  0803 0002               1245m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020081A  67F4                    1246m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
0020081C  13C2 00D30007           1247m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200822                          1248m     ENDC
00200822                          1249m     
00200822                 FALSE    1250m     IFNE DEBUG
00200822                          1251m     ENDC
00200822                          1252m 
00200822                          1253m     ENDM
00200822                          1254m         HEX2BIN D2,D2,A0
00200822  41F9 00201583           1255m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200828  0402 0030               1256m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020082C  C4BC 000000FF           1257m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200832  1430 2000               1258m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200836                          1259m   ENDM
00200836  8E82                    1260          OR.L D2,D7
00200838  E98F                    1261          LSL.L #4,D7
0020083A                          1262m         DOWNLOAD D2,D3         
0020083A                          1263m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020083A                          1264m 
0020083A  1639 00D30003           1265m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200840  0803 0000               1266m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200844  6700 0010               1267m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00200848                          1268m  
00200848                          1269mm     READ_CHAR D2
00200848                 TRUE     1270mm     IFEQ DEBUG
00200848  1439 00D30007           1271mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020084E                          1272mm     ENDC
0020084E                 FALSE    1273mm     IFNE DEBUG
0020084E                          1274mm     ENDC
0020084E                          1275mm      
0020084E  B43C 001B               1276mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200852  6700 F7B4               1277mm     BEQ START
00200856                          1278mm     ENDM
00200856                          1279m CONTINUE_80
00200856  1639 00D30013           1280m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020085C  0803 0000               1281m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200860  67D8                    1282m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
00200862                          1283m     
00200862  1439 00D30017           1284m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200868  13C2 00E00001           1285m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020086E                          1286m     
0020086E                          1287m     ENDM
0020086E                          1288m         PRINT_CHAR D2,D3
0020086E                          1289m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020086E                 TRUE     1290m     IFEQ DEBUG
0020086E  1639 00D30003           1291m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200874  0803 0002               1292m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200878  67F4                    1293m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
0020087A  13C2 00D30007           1294m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200880                          1295m     ENDC
00200880                          1296m     
00200880                 FALSE    1297m     IFNE DEBUG
00200880                          1298m     ENDC
00200880                          1299m 
00200880                          1300m     ENDM
00200880                          1301m         HEX2BIN D2,D2,A0
00200880  41F9 00201583           1302m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200886  0402 0030               1303m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020088A  C4BC 000000FF           1304m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200890  1430 2000               1305m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200894                          1306m   ENDM
00200894  8E82                    1307          OR.L D2,D7
00200896                          1308          
00200896  DC87                    1309          ADD.L D7,D6                 ; add top byte of address into checksum
00200898                          1310  
00200898  E98F                    1311          LSL.L #4,D7                 ; bottom byte
0020089A                          1312m         DOWNLOAD D2,D3
0020089A                          1313m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020089A                          1314m 
0020089A  1639 00D30003           1315m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002008A0  0803 0000               1316m     BTST #0,D3                    ; CHECK FOR CHARACTER
002008A4  6700 0010               1317m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
002008A8                          1318m  
002008A8                          1319mm     READ_CHAR D2
002008A8                 TRUE     1320mm     IFEQ DEBUG
002008A8  1439 00D30007           1321mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002008AE                          1322mm     ENDC
002008AE                 FALSE    1323mm     IFNE DEBUG
002008AE                          1324mm     ENDC
002008AE                          1325mm      
002008AE  B43C 001B               1326mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002008B2  6700 F754               1327mm     BEQ START
002008B6                          1328mm     ENDM
002008B6                          1329m CONTINUE_84
002008B6  1639 00D30013           1330m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002008BC  0803 0000               1331m     BTST #0,D3                  ; CHECK FOR CHARACTER
002008C0  67D8                    1332m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
002008C2                          1333m     
002008C2  1439 00D30017           1334m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002008C8  13C2 00E00001           1335m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002008CE                          1336m     
002008CE                          1337m     ENDM
002008CE                          1338m         PRINT_CHAR D2,D3
002008CE                          1339m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008CE                 TRUE     1340m     IFEQ DEBUG
002008CE  1639 00D30003           1341m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002008D4  0803 0002               1342m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002008D8  67F4                    1343m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
002008DA  13C2 00D30007           1344m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002008E0                          1345m     ENDC
002008E0                          1346m     
002008E0                 FALSE    1347m     IFNE DEBUG
002008E0                          1348m     ENDC
002008E0                          1349m 
002008E0                          1350m     ENDM
002008E0                          1351m         HEX2BIN D2,D2,A0
002008E0  41F9 00201583           1352m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002008E6  0402 0030               1353m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008EA  C4BC 000000FF           1354m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002008F0  1430 2000               1355m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002008F4                          1356m   ENDM
002008F4  8E82                    1357          OR.L D2,D7
002008F6  E98F                    1358          LSL.L #4,D7        
002008F8                          1359m         DOWNLOAD D2,D3
002008F8                          1360m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008F8                          1361m 
002008F8  1639 00D30003           1362m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002008FE  0803 0000               1363m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200902  6700 0010               1364m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
00200906                          1365m  
00200906                          1366mm     READ_CHAR D2
00200906                 TRUE     1367mm     IFEQ DEBUG
00200906  1439 00D30007           1368mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020090C                          1369mm     ENDC
0020090C                 FALSE    1370mm     IFNE DEBUG
0020090C                          1371mm     ENDC
0020090C                          1372mm      
0020090C  B43C 001B               1373mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200910  6700 F6F6               1374mm     BEQ START
00200914                          1375mm     ENDM
00200914                          1376m CONTINUE_88
00200914  1639 00D30013           1377m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020091A  0803 0000               1378m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020091E  67D8                    1379m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
00200920                          1380m     
00200920  1439 00D30017           1381m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200926  13C2 00E00001           1382m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020092C                          1383m     
0020092C                          1384m     ENDM
0020092C                          1385m         PRINT_CHAR D2,D3
0020092C                          1386m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020092C                 TRUE     1387m     IFEQ DEBUG
0020092C  1639 00D30003           1388m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200932  0803 0002               1389m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200936  67F4                    1390m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00200938  13C2 00D30007           1391m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020093E                          1392m     ENDC
0020093E                          1393m     
0020093E                 FALSE    1394m     IFNE DEBUG
0020093E                          1395m     ENDC
0020093E                          1396m 
0020093E                          1397m     ENDM
0020093E                          1398m         HEX2BIN D2,D2,A0
0020093E  41F9 00201583           1399m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200944  0402 0030               1400m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200948  C4BC 000000FF           1401m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020094E  1430 2000               1402m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200952                          1403m   ENDM
00200952  8E82                    1404          OR.L D2,D7
00200954                          1405          
00200954  7400                    1406          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200956  1407                    1407          MOVE.B D7,D2
00200958  DC82                    1408          ADD.L D2,D6
0020095A                          1409          
0020095A  2247                    1410          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
0020095C                          1411                 
0020095C  5785                    1412          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
0020095E                          1413          WHILE.L D5 <GT> #0 DO       ; read the data bytes
00200968  5385                    1414            SUB.L #1,D5
0020096A                          1415              
0020096A  7E00                    1416            MOVE.L #0,D7              ; D7 holds the byte
0020096C                          1417              
0020096C                          1418m           DOWNLOAD D2,D3            ; MS 4 bits
0020096C                          1419m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020096C                          1420m 
0020096C  1639 00D30003           1421m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200972  0803 0000               1422m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200976  6700 0010               1423m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
0020097A                          1424m  
0020097A                          1425mm     READ_CHAR D2
0020097A                 TRUE     1426mm     IFEQ DEBUG
0020097A  1439 00D30007           1427mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200980                          1428mm     ENDC
00200980                 FALSE    1429mm     IFNE DEBUG
00200980                          1430mm     ENDC
00200980                          1431mm      
00200980  B43C 001B               1432mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200984  6700 F682               1433mm     BEQ START
00200988                          1434mm     ENDM
00200988                          1435m CONTINUE_92
00200988  1639 00D30013           1436m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020098E  0803 0000               1437m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200992  67D8                    1438m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
00200994                          1439m     
00200994  1439 00D30017           1440m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020099A  13C2 00E00001           1441m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002009A0                          1442m     
002009A0                          1443m     ENDM
002009A0                          1444m           PRINT_CHAR D2,D3
002009A0                          1445m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009A0                 TRUE     1446m     IFEQ DEBUG
002009A0  1639 00D30003           1447m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002009A6  0803 0002               1448m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002009AA  67F4                    1449m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
002009AC  13C2 00D30007           1450m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002009B2                          1451m     ENDC
002009B2                          1452m     
002009B2                 FALSE    1453m     IFNE DEBUG
002009B2                          1454m     ENDC
002009B2                          1455m 
002009B2                          1456m     ENDM
002009B2                          1457m           HEX2BIN D2,D2,A0
002009B2  41F9 00201583           1458m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002009B8  0402 0030               1459m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009BC  C4BC 000000FF           1460m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002009C2  1430 2000               1461m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002009C6                          1462m   ENDM
002009C6  8E82                    1463            OR.L D2,D7
002009C8  E98F                    1464            LSL.L #4,D7
002009CA                          1465               
002009CA                          1466m           DOWNLOAD D2,D3            ; LS 4 bits    
002009CA                          1467m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009CA                          1468m 
002009CA  1639 00D30003           1469m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002009D0  0803 0000               1470m     BTST #0,D3                    ; CHECK FOR CHARACTER
002009D4  6700 0010               1471m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
002009D8                          1472m  
002009D8                          1473mm     READ_CHAR D2
002009D8                 TRUE     1474mm     IFEQ DEBUG
002009D8  1439 00D30007           1475mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002009DE                          1476mm     ENDC
002009DE                 FALSE    1477mm     IFNE DEBUG
002009DE                          1478mm     ENDC
002009DE                          1479mm      
002009DE  B43C 001B               1480mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002009E2  6700 F624               1481mm     BEQ START
002009E6                          1482mm     ENDM
002009E6                          1483m CONTINUE_96
002009E6  1639 00D30013           1484m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002009EC  0803 0000               1485m     BTST #0,D3                  ; CHECK FOR CHARACTER
002009F0  67D8                    1486m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
002009F2                          1487m     
002009F2  1439 00D30017           1488m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002009F8  13C2 00E00001           1489m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002009FE                          1490m     
002009FE                          1491m     ENDM
002009FE                          1492m           PRINT_CHAR D2,D3
002009FE                          1493m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009FE                 TRUE     1494m     IFEQ DEBUG
002009FE  1639 00D30003           1495m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A04  0803 0002               1496m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A08  67F4                    1497m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
00200A0A  13C2 00D30007           1498m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A10                          1499m     ENDC
00200A10                          1500m     
00200A10                 FALSE    1501m     IFNE DEBUG
00200A10                          1502m     ENDC
00200A10                          1503m 
00200A10                          1504m     ENDM
00200A10                          1505m           HEX2BIN D2,D2,A0
00200A10  41F9 00201583           1506m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A16  0402 0030               1507m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A1A  C4BC 000000FF           1508m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200A20  1430 2000               1509m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200A24                          1510m   ENDM
00200A24  8E82                    1511            OR.L D2,D7
00200A26                          1512              
00200A26  DC87                    1513            ADD.L D7,D6               ; add into checksum            
00200A28                          1514          ENDW
00200A2C                          1515m         PRINT_CRLF D3
00200A2C                          1516mm     PRINT_CHAR #13,D3             ; CR
00200A2C                          1517mm WAIT_FOR_READY_101                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A2C                 TRUE     1518mm     IFEQ DEBUG
00200A2C  1639 00D30003           1519mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A32  0803 0002               1520mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A36  67F4                    1521mm       BEQ WAIT_FOR_READY_101          ; NO SPACE, CHECK AGAIN
00200A38  13FC 000D 00D30007      1522mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A40                          1523mm     ENDC
00200A40                          1524mm     
00200A40                 FALSE    1525mm     IFNE DEBUG
00200A40                          1526mm     ENDC
00200A40                          1527mm 
00200A40                          1528mm     ENDM
00200A40                          1529mm     PRINT_CHAR #10,D3             ; LF
00200A40                          1530mm WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A40                 TRUE     1531mm     IFEQ DEBUG
00200A40  1639 00D30003           1532mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A46  0803 0002               1533mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A4A  67F4                    1534mm       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00200A4C  13FC 000A 00D30007      1535mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A54                          1536mm     ENDC
00200A54                          1537mm     
00200A54                 FALSE    1538mm     IFNE DEBUG
00200A54                          1539mm     ENDC
00200A54                          1540mm 
00200A54                          1541mm     ENDM
00200A54                          1542m     ENDM
00200A54  43F9 00200496           1543          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00200A5A                          1544        ELSE
00200A5E                          1545          IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00200A66  7E00                    1546            MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200A68                          1547m           DOWNLOAD D2,D3              ; top byte
00200A68                          1548m WAIT_FOR_READY_103                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A68                          1549m 
00200A68  1639 00D30003           1550m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200A6E  0803 0000               1551m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200A72  6700 0010               1552m     BEQ CONTINUE_103                ; NOTHING, CONTINUE
00200A76                          1553m  
00200A76                          1554mm     READ_CHAR D2
00200A76                 TRUE     1555mm     IFEQ DEBUG
00200A76  1439 00D30007           1556mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200A7C                          1557mm     ENDC
00200A7C                 FALSE    1558mm     IFNE DEBUG
00200A7C                          1559mm     ENDC
00200A7C                          1560mm      
00200A7C  B43C 001B               1561mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200A80  6700 F586               1562mm     BEQ START
00200A84                          1563mm     ENDM
00200A84                          1564m CONTINUE_103
00200A84  1639 00D30013           1565m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200A8A  0803 0000               1566m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200A8E  67D8                    1567m     BEQ WAIT_FOR_READY_103        ; NOTHING, CHECK AGAIN
00200A90                          1568m     
00200A90  1439 00D30017           1569m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A96  13C2 00E00001           1570m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A9C                          1571m     
00200A9C                          1572m     ENDM
00200A9C                          1573m           PRINT_CHAR D2,D3
00200A9C                          1574m WAIT_FOR_READY_105                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A9C                 TRUE     1575m     IFEQ DEBUG
00200A9C  1639 00D30003           1576m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200AA2  0803 0002               1577m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200AA6  67F4                    1578m       BEQ WAIT_FOR_READY_105          ; NO SPACE, CHECK AGAIN
00200AA8  13C2 00D30007           1579m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200AAE                          1580m     ENDC
00200AAE                          1581m     
00200AAE                 FALSE    1582m     IFNE DEBUG
00200AAE                          1583m     ENDC
00200AAE                          1584m 
00200AAE                          1585m     ENDM
00200AAE                          1586m           HEX2BIN D2,D2,A0
00200AAE  41F9 00201583           1587m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200AB4  0402 0030               1588m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AB8  C4BC 000000FF           1589m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200ABE  1430 2000               1590m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200AC2                          1591m   ENDM
00200AC2  8E82                    1592            OR.L D2,D7
00200AC4  E98F                    1593            LSL.L #4,D7
00200AC6                          1594m           DOWNLOAD D2,D3         
00200AC6                          1595m WAIT_FOR_READY_107                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AC6                          1596m 
00200AC6  1639 00D30003           1597m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200ACC  0803 0000               1598m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200AD0  6700 0010               1599m     BEQ CONTINUE_107                ; NOTHING, CONTINUE
00200AD4                          1600m  
00200AD4                          1601mm     READ_CHAR D2
00200AD4                 TRUE     1602mm     IFEQ DEBUG
00200AD4  1439 00D30007           1603mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200ADA                          1604mm     ENDC
00200ADA                 FALSE    1605mm     IFNE DEBUG
00200ADA                          1606mm     ENDC
00200ADA                          1607mm      
00200ADA  B43C 001B               1608mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200ADE  6700 F528               1609mm     BEQ START
00200AE2                          1610mm     ENDM
00200AE2                          1611m CONTINUE_107
00200AE2  1639 00D30013           1612m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200AE8  0803 0000               1613m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200AEC  67D8                    1614m     BEQ WAIT_FOR_READY_107        ; NOTHING, CHECK AGAIN
00200AEE                          1615m     
00200AEE  1439 00D30017           1616m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200AF4  13C2 00E00001           1617m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200AFA                          1618m     
00200AFA                          1619m     ENDM
00200AFA                          1620m           PRINT_CHAR D2,D3
00200AFA                          1621m WAIT_FOR_READY_109                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AFA                 TRUE     1622m     IFEQ DEBUG
00200AFA  1639 00D30003           1623m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200B00  0803 0002               1624m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200B04  67F4                    1625m       BEQ WAIT_FOR_READY_109          ; NO SPACE, CHECK AGAIN
00200B06  13C2 00D30007           1626m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200B0C                          1627m     ENDC
00200B0C                          1628m     
00200B0C                 FALSE    1629m     IFNE DEBUG
00200B0C                          1630m     ENDC
00200B0C                          1631m 
00200B0C                          1632m     ENDM
00200B0C                          1633m           HEX2BIN D2,D2,A0
00200B0C  41F9 00201583           1634m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B12  0402 0030               1635m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B16  C4BC 000000FF           1636m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B1C  1430 2000               1637m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B20                          1638m   ENDM
00200B20  8E82                    1639            OR.L D2,D7
00200B22                          1640          
00200B22  DC87                    1641            ADD.L D7,D6                 ; add top byte of address into checksum
00200B24                          1642  
00200B24  E98F                    1643            LSL.L #4,D7                 ; middle byte
00200B26                          1644m           DOWNLOAD D2,D3
00200B26                          1645m WAIT_FOR_READY_111                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B26                          1646m 
00200B26  1639 00D30003           1647m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B2C  0803 0000               1648m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B30  6700 0010               1649m     BEQ CONTINUE_111                ; NOTHING, CONTINUE
00200B34                          1650m  
00200B34                          1651mm     READ_CHAR D2
00200B34                 TRUE     1652mm     IFEQ DEBUG
00200B34  1439 00D30007           1653mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B3A                          1654mm     ENDC
00200B3A                 FALSE    1655mm     IFNE DEBUG
00200B3A                          1656mm     ENDC
00200B3A                          1657mm      
00200B3A  B43C 001B               1658mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B3E  6700 F4C8               1659mm     BEQ START
00200B42                          1660mm     ENDM
00200B42                          1661m CONTINUE_111
00200B42  1639 00D30013           1662m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B48  0803 0000               1663m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B4C  67D8                    1664m     BEQ WAIT_FOR_READY_111        ; NOTHING, CHECK AGAIN
00200B4E                          1665m     
00200B4E  1439 00D30017           1666m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B54  13C2 00E00001           1667m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B5A                          1668m     
00200B5A                          1669m     ENDM
00200B5A                          1670m           PRINT_CHAR D2,D3
00200B5A                          1671m WAIT_FOR_READY_113                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B5A                 TRUE     1672m     IFEQ DEBUG
00200B5A  1639 00D30003           1673m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200B60  0803 0002               1674m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200B64  67F4                    1675m       BEQ WAIT_FOR_READY_113          ; NO SPACE, CHECK AGAIN
00200B66  13C2 00D30007           1676m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200B6C                          1677m     ENDC
00200B6C                          1678m     
00200B6C                 FALSE    1679m     IFNE DEBUG
00200B6C                          1680m     ENDC
00200B6C                          1681m 
00200B6C                          1682m     ENDM
00200B6C                          1683m           HEX2BIN D2,D2,A0
00200B6C  41F9 00201583           1684m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B72  0402 0030               1685m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B76  C4BC 000000FF           1686m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B7C  1430 2000               1687m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B80                          1688m   ENDM
00200B80  8E82                    1689            OR.L D2,D7
00200B82  E98F                    1690            LSL.L #4,D7        
00200B84                          1691m           DOWNLOAD D2,D3
00200B84                          1692m WAIT_FOR_READY_115                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B84                          1693m 
00200B84  1639 00D30003           1694m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B8A  0803 0000               1695m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B8E  6700 0010               1696m     BEQ CONTINUE_115                ; NOTHING, CONTINUE
00200B92                          1697m  
00200B92                          1698mm     READ_CHAR D2
00200B92                 TRUE     1699mm     IFEQ DEBUG
00200B92  1439 00D30007           1700mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B98                          1701mm     ENDC
00200B98                 FALSE    1702mm     IFNE DEBUG
00200B98                          1703mm     ENDC
00200B98                          1704mm      
00200B98  B43C 001B               1705mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B9C  6700 F46A               1706mm     BEQ START
00200BA0                          1707mm     ENDM
00200BA0                          1708m CONTINUE_115
00200BA0  1639 00D30013           1709m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200BA6  0803 0000               1710m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200BAA  67D8                    1711m     BEQ WAIT_FOR_READY_115        ; NOTHING, CHECK AGAIN
00200BAC                          1712m     
00200BAC  1439 00D30017           1713m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200BB2  13C2 00E00001           1714m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200BB8                          1715m     
00200BB8                          1716m     ENDM
00200BB8                          1717m           PRINT_CHAR D2,D3
00200BB8                          1718m WAIT_FOR_READY_117                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BB8                 TRUE     1719m     IFEQ DEBUG
00200BB8  1639 00D30003           1720m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200BBE  0803 0002               1721m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200BC2  67F4                    1722m       BEQ WAIT_FOR_READY_117          ; NO SPACE, CHECK AGAIN
00200BC4  13C2 00D30007           1723m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200BCA                          1724m     ENDC
00200BCA                          1725m     
00200BCA                 FALSE    1726m     IFNE DEBUG
00200BCA                          1727m     ENDC
00200BCA                          1728m 
00200BCA                          1729m     ENDM
00200BCA                          1730m           HEX2BIN D2,D2,A0
00200BCA  41F9 00201583           1731m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200BD0  0402 0030               1732m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BD4  C4BC 000000FF           1733m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200BDA  1430 2000               1734m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200BDE                          1735m   ENDM
00200BDE  8E82                    1736            OR.L D2,D7
00200BE0                          1737          
00200BE0  7400                    1738            MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00200BE2  1407                    1739            MOVE.B D7,D2
00200BE4  DC82                    1740            ADD.L D2,D6
00200BE6                          1741            
00200BE6  E98F                    1742            LSL.L #4,D7                 ; bottom byte
00200BE8                          1743m           DOWNLOAD D2,D3
00200BE8                          1744m WAIT_FOR_READY_119                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BE8                          1745m 
00200BE8  1639 00D30003           1746m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200BEE  0803 0000               1747m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200BF2  6700 0010               1748m     BEQ CONTINUE_119                ; NOTHING, CONTINUE
00200BF6                          1749m  
00200BF6                          1750mm     READ_CHAR D2
00200BF6                 TRUE     1751mm     IFEQ DEBUG
00200BF6  1439 00D30007           1752mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200BFC                          1753mm     ENDC
00200BFC                 FALSE    1754mm     IFNE DEBUG
00200BFC                          1755mm     ENDC
00200BFC                          1756mm      
00200BFC  B43C 001B               1757mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200C00  6700 F406               1758mm     BEQ START
00200C04                          1759mm     ENDM
00200C04                          1760m CONTINUE_119
00200C04  1639 00D30013           1761m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C0A  0803 0000               1762m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C0E  67D8                    1763m     BEQ WAIT_FOR_READY_119        ; NOTHING, CHECK AGAIN
00200C10                          1764m     
00200C10  1439 00D30017           1765m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C16  13C2 00E00001           1766m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C1C                          1767m     
00200C1C                          1768m     ENDM
00200C1C                          1769m           PRINT_CHAR D2,D3
00200C1C                          1770m WAIT_FOR_READY_121                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C1C                 TRUE     1771m     IFEQ DEBUG
00200C1C  1639 00D30003           1772m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C22  0803 0002               1773m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C26  67F4                    1774m       BEQ WAIT_FOR_READY_121          ; NO SPACE, CHECK AGAIN
00200C28  13C2 00D30007           1775m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C2E                          1776m     ENDC
00200C2E                          1777m     
00200C2E                 FALSE    1778m     IFNE DEBUG
00200C2E                          1779m     ENDC
00200C2E                          1780m 
00200C2E                          1781m     ENDM
00200C2E                          1782m           HEX2BIN D2,D2,A0
00200C2E  41F9 00201583           1783m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C34  0402 0030               1784m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C38  C4BC 000000FF           1785m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C3E  1430 2000               1786m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C42                          1787m   ENDM
00200C42  8E82                    1788            OR.L D2,D7
00200C44  E98F                    1789            LSL.L #4,D7        
00200C46                          1790m           DOWNLOAD D2,D3
00200C46                          1791m WAIT_FOR_READY_123                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C46                          1792m 
00200C46  1639 00D30003           1793m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200C4C  0803 0000               1794m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200C50  6700 0010               1795m     BEQ CONTINUE_123                ; NOTHING, CONTINUE
00200C54                          1796m  
00200C54                          1797mm     READ_CHAR D2
00200C54                 TRUE     1798mm     IFEQ DEBUG
00200C54  1439 00D30007           1799mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200C5A                          1800mm     ENDC
00200C5A                 FALSE    1801mm     IFNE DEBUG
00200C5A                          1802mm     ENDC
00200C5A                          1803mm      
00200C5A  B43C 001B               1804mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200C5E  6700 F3A8               1805mm     BEQ START
00200C62                          1806mm     ENDM
00200C62                          1807m CONTINUE_123
00200C62  1639 00D30013           1808m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C68  0803 0000               1809m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C6C  67D8                    1810m     BEQ WAIT_FOR_READY_123        ; NOTHING, CHECK AGAIN
00200C6E                          1811m     
00200C6E  1439 00D30017           1812m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C74  13C2 00E00001           1813m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C7A                          1814m     
00200C7A                          1815m     ENDM
00200C7A                          1816m           PRINT_CHAR D2,D3
00200C7A                          1817m WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C7A                 TRUE     1818m     IFEQ DEBUG
00200C7A  1639 00D30003           1819m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C80  0803 0002               1820m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C84  67F4                    1821m       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00200C86  13C2 00D30007           1822m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C8C                          1823m     ENDC
00200C8C                          1824m     
00200C8C                 FALSE    1825m     IFNE DEBUG
00200C8C                          1826m     ENDC
00200C8C                          1827m 
00200C8C                          1828m     ENDM
00200C8C                          1829m           HEX2BIN D2,D2,A0
00200C8C  41F9 00201583           1830m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C92  0402 0030               1831m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C96  C4BC 000000FF           1832m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C9C  1430 2000               1833m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200CA0                          1834m   ENDM
00200CA0  8E82                    1835            OR.L D2,D7
00200CA2                          1836          
00200CA2  7400                    1837            MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200CA4  1407                    1838            MOVE.B D7,D2
00200CA6  DC82                    1839            ADD.L D2,D6
00200CA8                          1840          
00200CA8  2247                    1841            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200CAA                          1842                 
00200CAA  5985                    1843            SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00200CAC  E28D                    1844            LSR.L #1,D5                 ; /2 since we are reading words
00200CAE                          1845            WHILE.L D5 <GT> #0 DO       ; read the data bytes
00200CB8  5385                    1846              SUB.L #1,D5
00200CBA                          1847              
00200CBA  7E00                    1848              MOVE.L #0,D7              ; D7 holds the word
00200CBC                          1849              
00200CBC                          1850m             DOWNLOAD D2,D3            ; MS 4 bits
00200CBC                          1851m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBC                          1852m 
00200CBC  1639 00D30003           1853m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200CC2  0803 0000               1854m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200CC6  6700 0010               1855m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00200CCA                          1856m  
00200CCA                          1857mm     READ_CHAR D2
00200CCA                 TRUE     1858mm     IFEQ DEBUG
00200CCA  1439 00D30007           1859mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200CD0                          1860mm     ENDC
00200CD0                 FALSE    1861mm     IFNE DEBUG
00200CD0                          1862mm     ENDC
00200CD0                          1863mm      
00200CD0  B43C 001B               1864mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200CD4  6700 F332               1865mm     BEQ START
00200CD8                          1866mm     ENDM
00200CD8                          1867m CONTINUE_127
00200CD8  1639 00D30013           1868m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200CDE  0803 0000               1869m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200CE2  67D8                    1870m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00200CE4                          1871m     
00200CE4  1439 00D30017           1872m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200CEA  13C2 00E00001           1873m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200CF0                          1874m     
00200CF0                          1875m     ENDM
00200CF0                          1876m             PRINT_CHAR D2,D3
00200CF0                          1877m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CF0                 TRUE     1878m     IFEQ DEBUG
00200CF0  1639 00D30003           1879m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CF6  0803 0002               1880m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CFA  67F4                    1881m       BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00200CFC  13C2 00D30007           1882m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D02                          1883m     ENDC
00200D02                          1884m     
00200D02                 FALSE    1885m     IFNE DEBUG
00200D02                          1886m     ENDC
00200D02                          1887m 
00200D02                          1888m     ENDM
00200D02                          1889m             HEX2BIN D2,D2,A0
00200D02  41F9 00201583           1890m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D08  0402 0030               1891m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D0C  C4BC 000000FF           1892m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D12  1430 2000               1893m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D16                          1894m   ENDM
00200D16  8E82                    1895              OR.L D2,D7
00200D18  E98F                    1896              LSL.L #4,D7
00200D1A                          1897               
00200D1A                          1898m             DOWNLOAD D2,D3            ; LS 4 bits    
00200D1A                          1899m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D1A                          1900m 
00200D1A  1639 00D30003           1901m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200D20  0803 0000               1902m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200D24  6700 0010               1903m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00200D28                          1904m  
00200D28                          1905mm     READ_CHAR D2
00200D28                 TRUE     1906mm     IFEQ DEBUG
00200D28  1439 00D30007           1907mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200D2E                          1908mm     ENDC
00200D2E                 FALSE    1909mm     IFNE DEBUG
00200D2E                          1910mm     ENDC
00200D2E                          1911mm      
00200D2E  B43C 001B               1912mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D32  6700 F2D4               1913mm     BEQ START
00200D36                          1914mm     ENDM
00200D36                          1915m CONTINUE_131
00200D36  1639 00D30013           1916m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D3C  0803 0000               1917m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D40  67D8                    1918m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00200D42                          1919m     
00200D42  1439 00D30017           1920m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D48  13C2 00E00001           1921m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D4E                          1922m     
00200D4E                          1923m     ENDM
00200D4E                          1924m             PRINT_CHAR D2,D3
00200D4E                          1925m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D4E                 TRUE     1926m     IFEQ DEBUG
00200D4E  1639 00D30003           1927m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D54  0803 0002               1928m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D58  67F4                    1929m       BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00200D5A  13C2 00D30007           1930m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D60                          1931m     ENDC
00200D60                          1932m     
00200D60                 FALSE    1933m     IFNE DEBUG
00200D60                          1934m     ENDC
00200D60                          1935m 
00200D60                          1936m     ENDM
00200D60                          1937m             HEX2BIN D2,D2,A0
00200D60  41F9 00201583           1938m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D66  0402 0030               1939m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D6A  C4BC 000000FF           1940m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D70  1430 2000               1941m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D74                          1942m   ENDM
00200D74  8E82                    1943              OR.L D2,D7
00200D76                          1944                          
00200D76  DC87                    1945              ADD.L D7,D6               ; add into checksum
00200D78                          1946              
00200D78  E98F                    1947              LSL.L #4,D7
00200D7A                          1948m             DOWNLOAD D2,D3            ; MS 4 bits
00200D7A                          1949m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D7A                          1950m 
00200D7A  1639 00D30003           1951m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200D80  0803 0000               1952m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200D84  6700 0010               1953m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00200D88                          1954m  
00200D88                          1955mm     READ_CHAR D2
00200D88                 TRUE     1956mm     IFEQ DEBUG
00200D88  1439 00D30007           1957mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200D8E                          1958mm     ENDC
00200D8E                 FALSE    1959mm     IFNE DEBUG
00200D8E                          1960mm     ENDC
00200D8E                          1961mm      
00200D8E  B43C 001B               1962mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D92  6700 F274               1963mm     BEQ START
00200D96                          1964mm     ENDM
00200D96                          1965m CONTINUE_135
00200D96  1639 00D30013           1966m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D9C  0803 0000               1967m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200DA0  67D8                    1968m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00200DA2                          1969m     
00200DA2  1439 00D30017           1970m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200DA8  13C2 00E00001           1971m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200DAE                          1972m     
00200DAE                          1973m     ENDM
00200DAE                          1974m             PRINT_CHAR D2,D3
00200DAE                          1975m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DAE                 TRUE     1976m     IFEQ DEBUG
00200DAE  1639 00D30003           1977m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200DB4  0803 0002               1978m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200DB8  67F4                    1979m       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00200DBA  13C2 00D30007           1980m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200DC0                          1981m     ENDC
00200DC0                          1982m     
00200DC0                 FALSE    1983m     IFNE DEBUG
00200DC0                          1984m     ENDC
00200DC0                          1985m 
00200DC0                          1986m     ENDM
00200DC0                          1987m             HEX2BIN D2,D2,A0
00200DC0  41F9 00201583           1988m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200DC6  0402 0030               1989m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DCA  C4BC 000000FF           1990m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200DD0  1430 2000               1991m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200DD4                          1992m   ENDM
00200DD4  8E82                    1993              OR.L D2,D7
00200DD6                          1994               
00200DD6  E98F                    1995              LSL.L #4,D7
00200DD8                          1996m             DOWNLOAD D2,D3            ; LS 4 bits    
00200DD8                          1997m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DD8                          1998m 
00200DD8  1639 00D30003           1999m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200DDE  0803 0000               2000m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200DE2  6700 0010               2001m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00200DE6                          2002m  
00200DE6                          2003mm     READ_CHAR D2
00200DE6                 TRUE     2004mm     IFEQ DEBUG
00200DE6  1439 00D30007           2005mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200DEC                          2006mm     ENDC
00200DEC                 FALSE    2007mm     IFNE DEBUG
00200DEC                          2008mm     ENDC
00200DEC                          2009mm      
00200DEC  B43C 001B               2010mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200DF0  6700 F216               2011mm     BEQ START
00200DF4                          2012mm     ENDM
00200DF4                          2013m CONTINUE_139
00200DF4  1639 00D30013           2014m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200DFA  0803 0000               2015m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200DFE  67D8                    2016m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00200E00                          2017m     
00200E00  1439 00D30017           2018m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E06  13C2 00E00001           2019m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E0C                          2020m     
00200E0C                          2021m     ENDM
00200E0C                          2022m             PRINT_CHAR D2,D3
00200E0C                          2023m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E0C                 TRUE     2024m     IFEQ DEBUG
00200E0C  1639 00D30003           2025m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E12  0803 0002               2026m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E16  67F4                    2027m       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00200E18  13C2 00D30007           2028m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E1E                          2029m     ENDC
00200E1E                          2030m     
00200E1E                 FALSE    2031m     IFNE DEBUG
00200E1E                          2032m     ENDC
00200E1E                          2033m 
00200E1E                          2034m     ENDM
00200E1E                          2035m             HEX2BIN D2,D2,A0
00200E1E  41F9 00201583           2036m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200E24  0402 0030               2037m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E28  C4BC 000000FF           2038m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200E2E  1430 2000               2039m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200E32                          2040m   ENDM
00200E32  8E82                    2041              OR.L D2,D7
00200E34                          2042              
00200E34  7400                    2043              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200E36  1407                    2044              MOVE.B D7,D2
00200E38  DC82                    2045              ADD.L D2,D6
00200E3A                          2046              
00200E3A  32C7                    2047              MOVE.W D7,(A1)+             ; store it!
00200E3C                          2048              
00200E3C                          2049            ENDW
00200E40                          2050m           PRINT_CRLF D3
00200E40                          2051mm     PRINT_CHAR #13,D3             ; CR
00200E40                          2052mm WAIT_FOR_READY_144                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E40                 TRUE     2053mm     IFEQ DEBUG
00200E40  1639 00D30003           2054mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E46  0803 0002               2055mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E4A  67F4                    2056mm       BEQ WAIT_FOR_READY_144          ; NO SPACE, CHECK AGAIN
00200E4C  13FC 000D 00D30007      2057mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E54                          2058mm     ENDC
00200E54                          2059mm     
00200E54                 FALSE    2060mm     IFNE DEBUG
00200E54                          2061mm     ENDC
00200E54                          2062mm 
00200E54                          2063mm     ENDM
00200E54                          2064mm     PRINT_CHAR #10,D3             ; LF
00200E54                          2065mm WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E54                 TRUE     2066mm     IFEQ DEBUG
00200E54  1639 00D30003           2067mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E5A  0803 0002               2068mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E5E  67F4                    2069mm       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00200E60  13FC 000A 00D30007      2070mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E68                          2071mm     ENDC
00200E68                          2072mm     
00200E68                 FALSE    2073mm     IFNE DEBUG
00200E68                          2074mm     ENDC
00200E68                          2075mm 
00200E68                          2076mm     ENDM
00200E68                          2077m     ENDM
00200E68  43F9 00200496           2078            LEA WAIT_FOR_SRECORD,A1     ; next place to go
00200E6E                          2079          ELSE
00200E72                          2080            IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00200E7A  7E00                    2081              MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200E7C                          2082m             DOWNLOAD D2,D3            ; top byte
00200E7C                          2083m WAIT_FOR_READY_146                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E7C                          2084m 
00200E7C  1639 00D30003           2085m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E82  0803 0000               2086m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E86  6700 0010               2087m     BEQ CONTINUE_146                ; NOTHING, CONTINUE
00200E8A                          2088m  
00200E8A                          2089mm     READ_CHAR D2
00200E8A                 TRUE     2090mm     IFEQ DEBUG
00200E8A  1439 00D30007           2091mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E90                          2092mm     ENDC
00200E90                 FALSE    2093mm     IFNE DEBUG
00200E90                          2094mm     ENDC
00200E90                          2095mm      
00200E90  B43C 001B               2096mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E94  6700 F172               2097mm     BEQ START
00200E98                          2098mm     ENDM
00200E98                          2099m CONTINUE_146
00200E98  1639 00D30013           2100m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E9E  0803 0000               2101m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200EA2  67D8                    2102m     BEQ WAIT_FOR_READY_146        ; NOTHING, CHECK AGAIN
00200EA4                          2103m     
00200EA4  1439 00D30017           2104m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200EAA  13C2 00E00001           2105m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200EB0                          2106m     
00200EB0                          2107m     ENDM
00200EB0                          2108m             HEX2BIN D2,D2,A0
00200EB0  41F9 00201583           2109m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200EB6  0402 0030               2110m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EBA  C4BC 000000FF           2111m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200EC0  1430 2000               2112m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200EC4                          2113m   ENDM
00200EC4  8E82                    2114              OR.L D2,D7
00200EC6  E98F                    2115              LSL.L #4,D7
00200EC8                          2116m             DOWNLOAD D2,D3         
00200EC8                          2117m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC8                          2118m 
00200EC8  1639 00D30003           2119m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200ECE  0803 0000               2120m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200ED2  6700 0010               2121m     BEQ CONTINUE_149                ; NOTHING, CONTINUE
00200ED6                          2122m  
00200ED6                          2123mm     READ_CHAR D2
00200ED6                 TRUE     2124mm     IFEQ DEBUG
00200ED6  1439 00D30007           2125mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200EDC                          2126mm     ENDC
00200EDC                 FALSE    2127mm     IFNE DEBUG
00200EDC                          2128mm     ENDC
00200EDC                          2129mm      
00200EDC  B43C 001B               2130mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200EE0  6700 F126               2131mm     BEQ START
00200EE4                          2132mm     ENDM
00200EE4                          2133m CONTINUE_149
00200EE4  1639 00D30013           2134m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200EEA  0803 0000               2135m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200EEE  67D8                    2136m     BEQ WAIT_FOR_READY_149        ; NOTHING, CHECK AGAIN
00200EF0                          2137m     
00200EF0  1439 00D30017           2138m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200EF6  13C2 00E00001           2139m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200EFC                          2140m     
00200EFC                          2141m     ENDM
00200EFC                          2142m             HEX2BIN D2,D2,A0
00200EFC  41F9 00201583           2143m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F02  0402 0030               2144m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F06  C4BC 000000FF           2145m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F0C  1430 2000               2146m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F10                          2147m   ENDM
00200F10  8E82                    2148              OR.L D2,D7
00200F12                          2149          
00200F12  DC87                    2150              ADD.L D7,D6               ; add top byte of address into checksum
00200F14                          2151  
00200F14  E98F                    2152              LSL.L #4,D7               ; middle byte
00200F16                          2153m             DOWNLOAD D2,D3
00200F16                          2154m WAIT_FOR_READY_152                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F16                          2155m 
00200F16  1639 00D30003           2156m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F1C  0803 0000               2157m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F20  6700 0010               2158m     BEQ CONTINUE_152                ; NOTHING, CONTINUE
00200F24                          2159m  
00200F24                          2160mm     READ_CHAR D2
00200F24                 TRUE     2161mm     IFEQ DEBUG
00200F24  1439 00D30007           2162mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200F2A                          2163mm     ENDC
00200F2A                 FALSE    2164mm     IFNE DEBUG
00200F2A                          2165mm     ENDC
00200F2A                          2166mm      
00200F2A  B43C 001B               2167mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200F2E  6700 F0D8               2168mm     BEQ START
00200F32                          2169mm     ENDM
00200F32                          2170m CONTINUE_152
00200F32  1639 00D30013           2171m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200F38  0803 0000               2172m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200F3C  67D8                    2173m     BEQ WAIT_FOR_READY_152        ; NOTHING, CHECK AGAIN
00200F3E                          2174m     
00200F3E  1439 00D30017           2175m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200F44  13C2 00E00001           2176m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200F4A                          2177m     
00200F4A                          2178m     ENDM
00200F4A                          2179m             HEX2BIN D2,D2,A0
00200F4A  41F9 00201583           2180m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F50  0402 0030               2181m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F54  C4BC 000000FF           2182m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F5A  1430 2000               2183m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F5E                          2184m   ENDM
00200F5E  8E82                    2185              OR.L D2,D7
00200F60  E98F                    2186              LSL.L #4,D7        
00200F62                          2187m             DOWNLOAD D2,D3
00200F62                          2188m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F62                          2189m 
00200F62  1639 00D30003           2190m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F68  0803 0000               2191m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F6C  6700 0010               2192m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00200F70                          2193m  
00200F70                          2194mm     READ_CHAR D2
00200F70                 TRUE     2195mm     IFEQ DEBUG
00200F70  1439 00D30007           2196mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200F76                          2197mm     ENDC
00200F76                 FALSE    2198mm     IFNE DEBUG
00200F76                          2199mm     ENDC
00200F76                          2200mm      
00200F76  B43C 001B               2201mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200F7A  6700 F08C               2202mm     BEQ START
00200F7E                          2203mm     ENDM
00200F7E                          2204m CONTINUE_155
00200F7E  1639 00D30013           2205m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200F84  0803 0000               2206m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200F88  67D8                    2207m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00200F8A                          2208m     
00200F8A  1439 00D30017           2209m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200F90  13C2 00E00001           2210m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200F96                          2211m     
00200F96                          2212m     ENDM
00200F96                          2213m             HEX2BIN D2,D2,A0
00200F96  41F9 00201583           2214m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F9C  0402 0030               2215m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FA0  C4BC 000000FF           2216m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200FA6  1430 2000               2217m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200FAA                          2218m   ENDM
00200FAA  8E82                    2219              OR.L D2,D7
00200FAC                          2220          
00200FAC  7400                    2221              MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
00200FAE  1407                    2222              MOVE.B D7,D2
00200FB0  DC82                    2223              ADD.L D2,D6
00200FB2                          2224            
00200FB2  E98F                    2225              LSL.L #4,D7               ; bottom byte
00200FB4                          2226m             DOWNLOAD D2,D3
00200FB4                          2227m WAIT_FOR_READY_158                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FB4                          2228m 
00200FB4  1639 00D30003           2229m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200FBA  0803 0000               2230m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200FBE  6700 0010               2231m     BEQ CONTINUE_158                ; NOTHING, CONTINUE
00200FC2                          2232m  
00200FC2                          2233mm     READ_CHAR D2
00200FC2                 TRUE     2234mm     IFEQ DEBUG
00200FC2  1439 00D30007           2235mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200FC8                          2236mm     ENDC
00200FC8                 FALSE    2237mm     IFNE DEBUG
00200FC8                          2238mm     ENDC
00200FC8                          2239mm      
00200FC8  B43C 001B               2240mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200FCC  6700 F03A               2241mm     BEQ START
00200FD0                          2242mm     ENDM
00200FD0                          2243m CONTINUE_158
00200FD0  1639 00D30013           2244m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200FD6  0803 0000               2245m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200FDA  67D8                    2246m     BEQ WAIT_FOR_READY_158        ; NOTHING, CHECK AGAIN
00200FDC                          2247m     
00200FDC  1439 00D30017           2248m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200FE2  13C2 00E00001           2249m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200FE8                          2250m     
00200FE8                          2251m     ENDM
00200FE8                          2252m             HEX2BIN D2,D2,A0
00200FE8  41F9 00201583           2253m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200FEE  0402 0030               2254m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FF2  C4BC 000000FF           2255m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200FF8  1430 2000               2256m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200FFC                          2257m   ENDM
00200FFC  8E82                    2258              OR.L D2,D7
00200FFE  E98F                    2259              LSL.L #4,D7        
00201000                          2260m             DOWNLOAD D2,D3
00201000                          2261m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201000                          2262m 
00201000  1639 00D30003           2263m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201006  0803 0000               2264m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020100A  6700 0010               2265m     BEQ CONTINUE_161                ; NOTHING, CONTINUE
0020100E                          2266m  
0020100E                          2267mm     READ_CHAR D2
0020100E                 TRUE     2268mm     IFEQ DEBUG
0020100E  1439 00D30007           2269mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201014                          2270mm     ENDC
00201014                 FALSE    2271mm     IFNE DEBUG
00201014                          2272mm     ENDC
00201014                          2273mm      
00201014  B43C 001B               2274mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201018  6700 EFEE               2275mm     BEQ START
0020101C                          2276mm     ENDM
0020101C                          2277m CONTINUE_161
0020101C  1639 00D30013           2278m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201022  0803 0000               2279m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201026  67D8                    2280m     BEQ WAIT_FOR_READY_161        ; NOTHING, CHECK AGAIN
00201028                          2281m     
00201028  1439 00D30017           2282m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020102E  13C2 00E00001           2283m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201034                          2284m     
00201034                          2285m     ENDM
00201034                          2286m             HEX2BIN D2,D2,A0
00201034  41F9 00201583           2287m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020103A  0402 0030               2288m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020103E  C4BC 000000FF           2289m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201044  1430 2000               2290m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201048                          2291m   ENDM
00201048  8E82                    2292              OR.L D2,D7
0020104A                          2293          
0020104A  7400                    2294              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
0020104C  1407                    2295              MOVE.B D7,D2
0020104E  DC82                    2296              ADD.L D2,D6
00201050                          2297            
00201050  2447                    2298              MOVE.L D7,A2              ; start address -> A2
00201052                          2299          
00201052  43F9 0020120C           2300              LEA DOWNLOAD_DONE,A1      ; next place to go
00201058                          2301            ELSE
0020105C  41F9 0020150F           2302              LEA UNREC,A0              ; warn for unrecognised type
00201062                          2303m             PRINT_STR A0,D3
00201062                          2304m LOOP_164
00201062  0C10 0000               2305m     CMP.B #0,(A0)                 ; 0 -> DONE
00201066  6700 001A               2306m     BEQ EXIT_164
0020106A                          2307mm     PRINT_CHAR (A0)+,D3
0020106A                          2308mm WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020106A                 TRUE     2309mm     IFEQ DEBUG
0020106A  1639 00D30003           2310mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201070  0803 0002               2311mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201074  67F4                    2312mm       BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
00201076  13D8 00D30007           2313mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020107C                          2314mm     ENDC
0020107C                          2315mm     
0020107C                 FALSE    2316mm     IFNE DEBUG
0020107C                          2317mm     ENDC
0020107C                          2318mm 
0020107C                          2319mm     ENDM
0020107C  4EF9 00201062           2320m     JMP LOOP_164
00201082                          2321m EXIT_164
00201082                          2322m     ENDM
00201082                          2323m             PRINT_CHAR D7,D3
00201082                          2324m WAIT_FOR_READY_166                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201082                 TRUE     2325m     IFEQ DEBUG
00201082  1639 00D30003           2326m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201088  0803 0002               2327m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020108C  67F4                    2328m       BEQ WAIT_FOR_READY_166          ; NO SPACE, CHECK AGAIN
0020108E  13C7 00D30007           2329m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00201094                          2330m     ENDC
00201094                          2331m     
00201094                 FALSE    2332m     IFNE DEBUG
00201094                          2333m     ENDC
00201094                          2334m 
00201094                          2335m     ENDM
00201094                          2336m             PRINT_CRLF D3
00201094                          2337mm     PRINT_CHAR #13,D3             ; CR
00201094                          2338mm WAIT_FOR_READY_168                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201094                 TRUE     2339mm     IFEQ DEBUG
00201094  1639 00D30003           2340mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020109A  0803 0002               2341mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020109E  67F4                    2342mm       BEQ WAIT_FOR_READY_168          ; NO SPACE, CHECK AGAIN
002010A0  13FC 000D 00D30007      2343mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002010A8                          2344mm     ENDC
002010A8                          2345mm     
002010A8                 FALSE    2346mm     IFNE DEBUG
002010A8                          2347mm     ENDC
002010A8                          2348mm 
002010A8                          2349mm     ENDM
002010A8                          2350mm     PRINT_CHAR #10,D3             ; LF
002010A8                          2351mm WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A8                 TRUE     2352mm     IFEQ DEBUG
002010A8  1639 00D30003           2353mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002010AE  0803 0002               2354mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002010B2  67F4                    2355mm       BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
002010B4  13FC 000A 00D30007      2356mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002010BC                          2357mm     ENDC
002010BC                          2358mm     
002010BC                 FALSE    2359mm     IFNE DEBUG
002010BC                          2360mm     ENDC
002010BC                          2361mm 
002010BC                          2362mm     ENDM
002010BC                          2363m     ENDM
002010BC                          2364      
002010BC  4EF9 00200496           2365              JMP WAIT_FOR_SRECORD      ; ignore any other type    
002010C2                          2366            ENDI
002010C2                          2367          ENDI
002010C2                          2368        ENDI
002010C2                          2369      ENDI
002010C2                          2370      
002010C2  4686                    2371      NOT.L D6                        ; ones complement the checksum
002010C4  0286 000000FF           2372      ANDI.L #$FF,D6                  ; and take the LSByte
002010CA                          2373          
002010CA  7E00                    2374      MOVE.L #0,D7                    ; read the checksum from the data stream
002010CC                          2375m     DOWNLOAD D2,D3                  ; top byte
002010CC                          2376m WAIT_FOR_READY_170                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010CC                          2377m 
002010CC  1639 00D30003           2378m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002010D2  0803 0000               2379m     BTST #0,D3                    ; CHECK FOR CHARACTER
002010D6  6700 0010               2380m     BEQ CONTINUE_170                ; NOTHING, CONTINUE
002010DA                          2381m  
002010DA                          2382mm     READ_CHAR D2
002010DA                 TRUE     2383mm     IFEQ DEBUG
002010DA  1439 00D30007           2384mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002010E0                          2385mm     ENDC
002010E0                 FALSE    2386mm     IFNE DEBUG
002010E0                          2387mm     ENDC
002010E0                          2388mm      
002010E0  B43C 001B               2389mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002010E4  6700 EF22               2390mm     BEQ START
002010E8                          2391mm     ENDM
002010E8                          2392m CONTINUE_170
002010E8  1639 00D30013           2393m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002010EE  0803 0000               2394m     BTST #0,D3                  ; CHECK FOR CHARACTER
002010F2  67D8                    2395m     BEQ WAIT_FOR_READY_170        ; NOTHING, CHECK AGAIN
002010F4                          2396m     
002010F4  1439 00D30017           2397m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002010FA  13C2 00E00001           2398m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201100                          2399m     
00201100                          2400m     ENDM
00201100                          2401m     HEX2BIN D2,D2,A0
00201100  41F9 00201583           2402m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201106  0402 0030               2403m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020110A  C4BC 000000FF           2404m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201110  1430 2000               2405m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201114                          2406m   ENDM
00201114  8E82                    2407      OR.L D2,D7
00201116  E98F                    2408      LSL.L #4,D7
00201118                          2409m     DOWNLOAD D2,D3                  ; bottom byte
00201118                          2410m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201118                          2411m 
00201118  1639 00D30003           2412m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020111E  0803 0000               2413m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201122  6700 0010               2414m     BEQ CONTINUE_173                ; NOTHING, CONTINUE
00201126                          2415m  
00201126                          2416mm     READ_CHAR D2
00201126                 TRUE     2417mm     IFEQ DEBUG
00201126  1439 00D30007           2418mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020112C                          2419mm     ENDC
0020112C                 FALSE    2420mm     IFNE DEBUG
0020112C                          2421mm     ENDC
0020112C                          2422mm      
0020112C  B43C 001B               2423mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201130  6700 EED6               2424mm     BEQ START
00201134                          2425mm     ENDM
00201134                          2426m CONTINUE_173
00201134  1639 00D30013           2427m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020113A  0803 0000               2428m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020113E  67D8                    2429m     BEQ WAIT_FOR_READY_173        ; NOTHING, CHECK AGAIN
00201140                          2430m     
00201140  1439 00D30017           2431m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201146  13C2 00E00001           2432m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020114C                          2433m     
0020114C                          2434m     ENDM
0020114C                          2435m     HEX2BIN D2,D2,A0
0020114C  41F9 00201583           2436m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201152  0402 0030               2437m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201156  C4BC 000000FF           2438m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020115C  1430 2000               2439m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201160                          2440m   ENDM
00201160  8E82                    2441      OR.L D2,D7
00201162                          2442                  
00201162                          2443      IF.B D7 <NE> D6 THEN.L
00201168  41F9 00201535           2444        LEA CS_FAILURE,A0             ; warn for mismatched checksum
0020116E                          2445m       PRINT_STR A0,D3
0020116E                          2446m LOOP_176
0020116E  0C10 0000               2447m     CMP.B #0,(A0)                 ; 0 -> DONE
00201172  6700 001A               2448m     BEQ EXIT_176
00201176                          2449mm     PRINT_CHAR (A0)+,D3
00201176                          2450mm WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201176                 TRUE     2451mm     IFEQ DEBUG
00201176  1639 00D30003           2452mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020117C  0803 0002               2453mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201180  67F4                    2454mm       BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
00201182  13D8 00D30007           2455mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00201188                          2456mm     ENDC
00201188                          2457mm     
00201188                 FALSE    2458mm     IFNE DEBUG
00201188                          2459mm     ENDC
00201188                          2460mm 
00201188                          2461mm     ENDM
00201188  4EF9 0020116E           2462m     JMP LOOP_176
0020118E                          2463m EXIT_176
0020118E                          2464m     ENDM
0020118E                          2465m       PRINT_REG D4,D3,D6,D7,A0
0020118E                          2466mm     PRINT_CHAR #'0',D3          ;0X HEADER
0020118E                          2467mm WAIT_FOR_READY_179                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020118E                 TRUE     2468mm     IFEQ DEBUG
0020118E  1639 00D30003           2469mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201194  0803 0002               2470mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201198  67F4                    2471mm       BEQ WAIT_FOR_READY_179          ; NO SPACE, CHECK AGAIN
0020119A  13FC 0030 00D30007      2472mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002011A2                          2473mm     ENDC
002011A2                          2474mm     
002011A2                 FALSE    2475mm     IFNE DEBUG
002011A2                          2476mm     ENDC
002011A2                          2477mm 
002011A2                          2478mm     ENDM
002011A2                          2479mm     PRINT_CHAR #'x',D3
002011A2                          2480mm WAIT_FOR_READY_180                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011A2                 TRUE     2481mm     IFEQ DEBUG
002011A2  1639 00D30003           2482mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011A8  0803 0002               2483mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011AC  67F4                    2484mm       BEQ WAIT_FOR_READY_180          ; NO SPACE, CHECK AGAIN
002011AE  13FC 0078 00D30007      2485mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002011B6                          2486mm     ENDC
002011B6                          2487mm     
002011B6                 FALSE    2488mm     IFNE DEBUG
002011B6                          2489mm     ENDC
002011B6                          2490mm 
002011B6                          2491mm     ENDM
002011B6  7E07                    2492m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002011B8                          2493m LOOP_178
002011B8                          2494mm     BIN2HEX D4,D6,A0
002011B8  41F9 00201573           2495mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002011BE  E99C                    2496mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002011C0  1C04                    2497mm   MOVE.B D4,D6
002011C2  0286 0000000F           2498mm   ANDI.L #$F,D6
002011C8  1C30 6000               2499mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
002011CC                          2500mm   ENDM
002011CC                          2501mm     PRINT_CHAR D6,D3
002011CC                          2502mm WAIT_FOR_READY_182                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011CC                 TRUE     2503mm     IFEQ DEBUG
002011CC  1639 00D30003           2504mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011D2  0803 0002               2505mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011D6  67F4                    2506mm       BEQ WAIT_FOR_READY_182          ; NO SPACE, CHECK AGAIN
002011D8  13C6 00D30007           2507mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
002011DE                          2508mm     ENDC
002011DE                          2509mm     
002011DE                 FALSE    2510mm     IFNE DEBUG
002011DE                          2511mm     ENDC
002011DE                          2512mm 
002011DE                          2513mm     ENDM
002011DE  57CF FFD8               2514m     DBEQ D7,LOOP_178
002011E2                          2515m     ENDM
002011E2                          2516m       PRINT_CRLF D3     
002011E2                          2517mm     PRINT_CHAR #13,D3             ; CR
002011E2                          2518mm WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011E2                 TRUE     2519mm     IFEQ DEBUG
002011E2  1639 00D30003           2520mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011E8  0803 0002               2521mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011EC  67F4                    2522mm       BEQ WAIT_FOR_READY_184          ; NO SPACE, CHECK AGAIN
002011EE  13FC 000D 00D30007      2523mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002011F6                          2524mm     ENDC
002011F6                          2525mm     
002011F6                 FALSE    2526mm     IFNE DEBUG
002011F6                          2527mm     ENDC
002011F6                          2528mm 
002011F6                          2529mm     ENDM
002011F6                          2530mm     PRINT_CHAR #10,D3             ; LF
002011F6                          2531mm WAIT_FOR_READY_185                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011F6                 TRUE     2532mm     IFEQ DEBUG
002011F6  1639 00D30003           2533mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011FC  0803 0002               2534mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201200  67F4                    2535mm       BEQ WAIT_FOR_READY_185          ; NO SPACE, CHECK AGAIN
00201202  13FC 000A 00D30007      2536mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020120A                          2537mm     ENDC
0020120A                          2538mm     
0020120A                 FALSE    2539mm     IFNE DEBUG
0020120A                          2540mm     ENDC
0020120A                          2541mm 
0020120A                          2542mm     ENDM
0020120A                          2543m     ENDM
0020120A                          2544      ENDI
0020120A                          2545      
0020120A  4ED1                    2546      JMP (A1)
0020120C                          2547  DOWNLOAD_DONE
0020120C                          2548m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
0020120C                          2549mm     PRINT_CHAR #'0',D3          ;0X HEADER
0020120C                          2550mm WAIT_FOR_READY_187                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020120C                 TRUE     2551mm     IFEQ DEBUG
0020120C  1639 00D30003           2552mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201212  0803 0002               2553mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201216  67F4                    2554mm       BEQ WAIT_FOR_READY_187          ; NO SPACE, CHECK AGAIN
00201218  13FC 0030 00D30007      2555mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00201220                          2556mm     ENDC
00201220                          2557mm     
00201220                 FALSE    2558mm     IFNE DEBUG
00201220                          2559mm     ENDC
00201220                          2560mm 
00201220                          2561mm     ENDM
00201220                          2562mm     PRINT_CHAR #'x',D3
00201220                          2563mm WAIT_FOR_READY_188                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201220                 TRUE     2564mm     IFEQ DEBUG
00201220  1639 00D30003           2565mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201226  0803 0002               2566mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020122A  67F4                    2567mm       BEQ WAIT_FOR_READY_188          ; NO SPACE, CHECK AGAIN
0020122C  13FC 0078 00D30007      2568mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00201234                          2569mm     ENDC
00201234                          2570mm     
00201234                 FALSE    2571mm     IFNE DEBUG
00201234                          2572mm     ENDC
00201234                          2573mm 
00201234                          2574mm     ENDM
00201234  7C07                    2575m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201236                          2576m LOOP_186
00201236                          2577mm     BIN2HEX D4,D7,A0
00201236  41F9 00201573           2578mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
0020123C  E99C                    2579mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020123E  1E04                    2580mm   MOVE.B D4,D7
00201240  0287 0000000F           2581mm   ANDI.L #$F,D7
00201246  1E30 7000               2582mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0020124A                          2583mm   ENDM
0020124A                          2584mm     PRINT_CHAR D7,D3
0020124A                          2585mm WAIT_FOR_READY_190                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020124A                 TRUE     2586mm     IFEQ DEBUG
0020124A  1639 00D30003           2587mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201250  0803 0002               2588mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201254  67F4                    2589mm       BEQ WAIT_FOR_READY_190          ; NO SPACE, CHECK AGAIN
00201256  13C7 00D30007           2590mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020125C                          2591mm     ENDC
0020125C                          2592mm     
0020125C                 FALSE    2593mm     IFNE DEBUG
0020125C                          2594mm     ENDC
0020125C                          2595mm 
0020125C                          2596mm     ENDM
0020125C  57CE FFD8               2597m     DBEQ D6,LOOP_186
00201260                          2598m     ENDM
00201260  41F9 002014ED           2599      LEA READ,A0
00201266                          2600m     PRINT_STR A0,D3
00201266                          2601m LOOP_191
00201266  0C10 0000               2602m     CMP.B #0,(A0)                 ; 0 -> DONE
0020126A  6700 001A               2603m     BEQ EXIT_191
0020126E                          2604mm     PRINT_CHAR (A0)+,D3
0020126E                          2605mm WAIT_FOR_READY_192                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020126E                 TRUE     2606mm     IFEQ DEBUG
0020126E  1639 00D30003           2607mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201274  0803 0002               2608mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201278  67F4                    2609mm       BEQ WAIT_FOR_READY_192          ; NO SPACE, CHECK AGAIN
0020127A  13D8 00D30007           2610mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00201280                          2611mm     ENDC
00201280                          2612mm     
00201280                 FALSE    2613mm     IFNE DEBUG
00201280                          2614mm     ENDC
00201280                          2615mm 
00201280                          2616mm     ENDM
00201280  4EF9 00201266           2617m     JMP LOOP_191
00201286                          2618m EXIT_191
00201286                          2619m     ENDM
00201286  2E0A                    2620      MOVE.L A2,D7                    ; set address accumulator to start address
00201288                          2621m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
00201288                          2622mm     PRINT_CHAR #'0',D3          ;0X HEADER
00201288                          2623mm WAIT_FOR_READY_194                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201288                 TRUE     2624mm     IFEQ DEBUG
00201288  1639 00D30003           2625mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020128E  0803 0002               2626mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201292  67F4                    2627mm       BEQ WAIT_FOR_READY_194          ; NO SPACE, CHECK AGAIN
00201294  13FC 0030 00D30007      2628mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0020129C                          2629mm     ENDC
0020129C                          2630mm     
0020129C                 FALSE    2631mm     IFNE DEBUG
0020129C                          2632mm     ENDC
0020129C                          2633mm 
0020129C                          2634mm     ENDM
0020129C                          2635mm     PRINT_CHAR #'x',D3
0020129C                          2636mm WAIT_FOR_READY_195                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020129C                 TRUE     2637mm     IFEQ DEBUG
0020129C  1639 00D30003           2638mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002012A2  0803 0002               2639mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002012A6  67F4                    2640mm       BEQ WAIT_FOR_READY_195          ; NO SPACE, CHECK AGAIN
002012A8  13FC 0078 00D30007      2641mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002012B0                          2642mm     ENDC
002012B0                          2643mm     
002012B0                 FALSE    2644mm     IFNE DEBUG
002012B0                          2645mm     ENDC
002012B0                          2646mm 
002012B0                          2647mm     ENDM
002012B0  7C07                    2648m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002012B2                          2649m LOOP_193
002012B2                          2650mm     BIN2HEX D7,D2,A0
002012B2  41F9 00201573           2651mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002012B8  E99F                    2652mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002012BA  1407                    2653mm   MOVE.B D7,D2
002012BC  0282 0000000F           2654mm   ANDI.L #$F,D2
002012C2  1430 2000               2655mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
002012C6                          2656mm   ENDM
002012C6                          2657mm     PRINT_CHAR D2,D3
002012C6                          2658mm WAIT_FOR_READY_197                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012C6                 TRUE     2659mm     IFEQ DEBUG
002012C6  1639 00D30003           2660mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002012CC  0803 0002               2661mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002012D0  67F4                    2662mm       BEQ WAIT_FOR_READY_197          ; NO SPACE, CHECK AGAIN
002012D2  13C2 00D30007           2663mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002012D8                          2664mm     ENDC
002012D8                          2665mm     
002012D8                 FALSE    2666mm     IFNE DEBUG
002012D8                          2667mm     ENDC
002012D8                          2668mm 
002012D8                          2669mm     ENDM
002012D8  57CE FFD8               2670m     DBEQ D6,LOOP_193
002012DC                          2671m     ENDM
002012DC                          2672m     PRINT_CRLF D3     
002012DC                          2673mm     PRINT_CHAR #13,D3             ; CR
002012DC                          2674mm WAIT_FOR_READY_199                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012DC                 TRUE     2675mm     IFEQ DEBUG
002012DC  1639 00D30003           2676mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002012E2  0803 0002               2677mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002012E6  67F4                    2678mm       BEQ WAIT_FOR_READY_199          ; NO SPACE, CHECK AGAIN
002012E8  13FC 000D 00D30007      2679mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002012F0                          2680mm     ENDC
002012F0                          2681mm     
002012F0                 FALSE    2682mm     IFNE DEBUG
002012F0                          2683mm     ENDC
002012F0                          2684mm 
002012F0                          2685mm     ENDM
002012F0                          2686mm     PRINT_CHAR #10,D3             ; LF
002012F0                          2687mm WAIT_FOR_READY_200                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012F0                 TRUE     2688mm     IFEQ DEBUG
002012F0  1639 00D30003           2689mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002012F6  0803 0002               2690mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002012FA  67F4                    2691mm       BEQ WAIT_FOR_READY_200          ; NO SPACE, CHECK AGAIN
002012FC  13FC 000A 00D30007      2692mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201304                          2693mm     ENDC
00201304                          2694mm     
00201304                 FALSE    2695mm     IFNE DEBUG
00201304                          2696mm     ENDC
00201304                          2697mm 
00201304                          2698mm     ENDM
00201304                          2699m     ENDM
00201304                          2700          
00201304  4EF9 00200188           2701      JMP MAIN_LOOP
0020130A                          2702      
0020130A  2047                    2703  G   MOVE.L D7,A0                    ; address accumulator -> address register
0020130C  3E3C 0000               2704      MOVE #0,D7                      ; clear the now used address accumulator
00201310  4ED0                    2705      JMP (A0)                        ; jump to it!
00201312                          2706      
00201312  207C 00200000           2707  Z   MOVE.L #RAM,A0                  ; address of RAM
00201318  7000                    2708      MOVE.L #0,D0                    ; number of bytes
0020131A                          2709     
0020131A                          2710      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
00201324                          2711         
00201324  2200                    2712        MOVE.L D0,D1                  ; progress update
00201326  E089                    2713        LSR.L #8,D1 
00201328  E089                    2714        LSR.L #8,D1
0020132A  0281 0000000F           2715        ANDI.L #$F,D1
00201330  13C1 00E00001           2716        MOVE.B D1,DISPLAY
00201336                          2717  
00201336  20C0                    2718        MOVE.L D0,(A0)+ 
00201338  5880                    2719        ADD.L #4,D0
0020133A                          2720      ENDW
0020133C                          2721   
0020133C  207C 00200000           2722      MOVE.L #RAM,A0              ; address of RAM
00201342  7000                    2723      MOVE.L #0,D0                ; number of bytes
00201344                          2724     
00201344                          2725      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
0020134E                          2726  
0020134E  2200                    2727        MOVE.L D0,D1              ; progress update
00201350  E089                    2728        LSR.L #8,D1
00201352  E089                    2729        LSR.L #8,D1
00201354  0281 0000000F           2730        ANDI.L #$F,D1
0020135A  13C1 00E00001           2731        MOVE.B D1,DISPLAY
00201360                          2732  
00201360  2218                    2733        MOVE.L (A0)+,D1
00201362                          2734        
00201362                          2735        IF.L D0 <EQ> D1 THEN
00201368  6000 00A8               2736          BRA OK
0020136C                          2737        ENDI 
0020136C                          2738        
0020136C  43F9 0020155B           2739        LEA RAM_ERROR,A1
00201372                          2740m       PRINT_STR A1,D1
00201372                          2741m LOOP_201
00201372  0C11 0000               2742m     CMP.B #0,(A1)                 ; 0 -> DONE
00201376  6700 001A               2743m     BEQ EXIT_201
0020137A                          2744mm     PRINT_CHAR (A1)+,D1
0020137A                          2745mm WAIT_FOR_READY_202                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020137A                 TRUE     2746mm     IFEQ DEBUG
0020137A  1239 00D30003           2747mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
00201380  0801 0002               2748mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
00201384  67F4                    2749mm       BEQ WAIT_FOR_READY_202          ; NO SPACE, CHECK AGAIN
00201386  13D9 00D30007           2750mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020138C                          2751mm     ENDC
0020138C                          2752mm     
0020138C                 FALSE    2753mm     IFNE DEBUG
0020138C                          2754mm     ENDC
0020138C                          2755mm 
0020138C                          2756mm     ENDM
0020138C  4EF9 00201372           2757m     JMP LOOP_201
00201392                          2758m EXIT_201
00201392                          2759m     ENDM
00201392  2208                    2760        MOVE.L A0,D1
00201394  5981                    2761        SUB.L #4,D1
00201396                          2762m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
00201396                          2763mm     PRINT_CHAR #'0',D3          ;0X HEADER
00201396                          2764mm WAIT_FOR_READY_204                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201396                 TRUE     2765mm     IFEQ DEBUG
00201396  1639 00D30003           2766mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020139C  0803 0002               2767mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002013A0  67F4                    2768mm       BEQ WAIT_FOR_READY_204          ; NO SPACE, CHECK AGAIN
002013A2  13FC 0030 00D30007      2769mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002013AA                          2770mm     ENDC
002013AA                          2771mm     
002013AA                 FALSE    2772mm     IFNE DEBUG
002013AA                          2773mm     ENDC
002013AA                          2774mm 
002013AA                          2775mm     ENDM
002013AA                          2776mm     PRINT_CHAR #'x',D3
002013AA                          2777mm WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013AA                 TRUE     2778mm     IFEQ DEBUG
002013AA  1639 00D30003           2779mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002013B0  0803 0002               2780mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002013B4  67F4                    2781mm       BEQ WAIT_FOR_READY_205          ; NO SPACE, CHECK AGAIN
002013B6  13FC 0078 00D30007      2782mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002013BE                          2783mm     ENDC
002013BE                          2784mm     
002013BE                 FALSE    2785mm     IFNE DEBUG
002013BE                          2786mm     ENDC
002013BE                          2787mm 
002013BE                          2788mm     ENDM
002013BE  7C07                    2789m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002013C0                          2790m LOOP_203
002013C0                          2791mm     BIN2HEX D1,D2,A1
002013C0  43F9 00201573           2792mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
002013C6  E999                    2793mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002013C8  1401                    2794mm   MOVE.B D1,D2
002013CA  0282 0000000F           2795mm   ANDI.L #$F,D2
002013D0  1431 2000               2796mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
002013D4                          2797mm   ENDM
002013D4                          2798mm     PRINT_CHAR D2,D3
002013D4                          2799mm WAIT_FOR_READY_207                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013D4                 TRUE     2800mm     IFEQ DEBUG
002013D4  1639 00D30003           2801mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002013DA  0803 0002               2802mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002013DE  67F4                    2803mm       BEQ WAIT_FOR_READY_207          ; NO SPACE, CHECK AGAIN
002013E0  13C2 00D30007           2804mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002013E6                          2805mm     ENDC
002013E6                          2806mm     
002013E6                 FALSE    2807mm     IFNE DEBUG
002013E6                          2808mm     ENDC
002013E6                          2809mm 
002013E6                          2810mm     ENDM
002013E6  57CE FFD8               2811m     DBEQ D6,LOOP_203
002013EA                          2812m     ENDM
002013EA                          2813m       PRINT_CRLF D3
002013EA                          2814mm     PRINT_CHAR #13,D3             ; CR
002013EA                          2815mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013EA                 TRUE     2816mm     IFEQ DEBUG
002013EA  1639 00D30003           2817mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002013F0  0803 0002               2818mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002013F4  67F4                    2819mm       BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
002013F6  13FC 000D 00D30007      2820mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002013FE                          2821mm     ENDC
002013FE                          2822mm     
002013FE                 FALSE    2823mm     IFNE DEBUG
002013FE                          2824mm     ENDC
002013FE                          2825mm 
002013FE                          2826mm     ENDM
002013FE                          2827mm     PRINT_CHAR #10,D3             ; LF
002013FE                          2828mm WAIT_FOR_READY_210                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013FE                 TRUE     2829mm     IFEQ DEBUG
002013FE  1639 00D30003           2830mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201404  0803 0002               2831mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201408  67F4                    2832mm       BEQ WAIT_FOR_READY_210          ; NO SPACE, CHECK AGAIN
0020140A  13FC 000A 00D30007      2833mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201412                          2834mm     ENDC
00201412                          2835mm     
00201412                 FALSE    2836mm     IFNE DEBUG
00201412                          2837mm     ENDC
00201412                          2838mm 
00201412                          2839mm     ENDM
00201412                          2840m     ENDM
00201412                          2841  OK    
00201412  5880                    2842        ADD.L #4,D0
00201414                          2843      ENDW
00201418                          2844      
00201418  4EF9 00200188           2845      JMP MAIN_LOOP
0020141E                          2846    
0020141E                          2847  HEX_DIGIT
0020141E  E98F                    2848      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00201420                          2849m     HEX2BIN D2,D2,A0
00201420  41F9 00201583           2850m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201426  0402 0030               2851m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020142A  C4BC 000000FF           2852m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201430  1430 2000               2853m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201434                          2854m   ENDM
00201434  8E02                    2855      OR.B D2,D7  
00201436  4EF9 002001B0           2856      JMP GET_INPUT
0020143C                          2857  
0020143C  FFFF FFFF               2858      SIMHALT                         ; halt simulator
00201440                          2859  
00201440                          2860  ; strings
00201440= 4D 44 46 2D 6D 6F ...   2861  VERSION DC.B 'MDF-mon V1.11 (04/04/2021)',13,10,0
0020145D= 3F 20 48 65 6C 70 ...   2862  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,'Z Zap memory',10,13,0
002014D6= 48 75 68 3F 0D 0A 00    2863  HUH     DC.B 'Huh?',13,10,0
002014DD= 55 6E 69 6D 70 6C ...   2864  UNIMP   DC.B 'Unimplemented',13,10,0
002014ED= 20 53 20 72 65 63 ...   2865  READ    DC.B ' S records read, start address = ',0
0020150F= 57 41 52 4E 49 4E ...   2866  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00201535= 57 41 52 4E 49 4E ...   2867  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
0020155B= 57 41 52 4E 49 4E ...   2868  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
00201573= 30 31 32 33 34 35 ...   2869  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201583= 00 01 02 03 04 05 ...   2870  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0020159A                          2871      
0020159A                          2872      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201573
CONTINUE_103        200A84
CONTINUE_107        200AE2
CONTINUE_111        200B42
CONTINUE_115        200BA0
CONTINUE_119        200C04
CONTINUE_123        200C62
CONTINUE_127        200CD8
CONTINUE_131        200D36
CONTINUE_135        200D96
CONTINUE_139        200DF4
CONTINUE_146        200E98
CONTINUE_149        200EE4
CONTINUE_152        200F32
CONTINUE_155        200F7E
CONTINUE_158        200FD0
CONTINUE_161        20101C
CONTINUE_170        2010E8
CONTINUE_173        201134
CONTINUE_44         2004B2
CONTINUE_46         2004EE
CONTINUE_48         200526
CONTINUE_51         200572
CONTINUE_54         2005C8
CONTINUE_57         200614
CONTINUE_60         200662
CONTINUE_63         2006AE
CONTINUE_66         20070E
CONTINUE_69         20075A
CONTINUE_76         2007F8
CONTINUE_80         200856
CONTINUE_84         2008B6
CONTINUE_88         200914
CONTINUE_92         200988
CONTINUE_96         2009E6
CS_FAILURE          201535
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       20120C
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_164            201082
EXIT_176            20118E
EXIT_19             2002E2
EXIT_191            201286
EXIT_201            201392
EXIT_21             20030E
EXIT_23             20033A
EXIT_5              200142
G                   20130A
GET_INPUT           2001B0
H                   2002E8
HELP                20145D
HEX2BIN             12B
HEX2BIN_LUT         201583
HEX_DIGIT           20141E
HUH                 2014D6
LOOP_164            201062
LOOP_176            20116E
LOOP_178            2011B8
LOOP_186            201236
LOOP_19             2002C2
LOOP_191            201266
LOOP_193            2012B2
LOOP_201            201372
LOOP_203            2013C0
LOOP_21             2002EE
LOOP_23             20031A
LOOP_25             20036E
LOOP_5              200122
MAIN_LOOP           200188
OK                  201412
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   200340
RAM                 200000
RAM_ERROR           20155B
READ                2014ED
READ_CHAR           79D
READ_DATA_TO_POKE   200410
RRRR                0
S                   200490
START               200008
UNIMP               2014DD
UNREC               20150F
V                   200314
VERSION             201440
W                   2003C8
WAIT_CHAR           615
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_101  200A2C
WAIT_FOR_READY_102  200A40
WAIT_FOR_READY_103  200A68
WAIT_FOR_READY_105  200A9C
WAIT_FOR_READY_107  200AC6
WAIT_FOR_READY_109  200AFA
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_111  200B26
WAIT_FOR_READY_113  200B5A
WAIT_FOR_READY_115  200B84
WAIT_FOR_READY_117  200BB8
WAIT_FOR_READY_119  200BE8
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_121  200C1C
WAIT_FOR_READY_123  200C46
WAIT_FOR_READY_125  200C7A
WAIT_FOR_READY_127  200CBC
WAIT_FOR_READY_129  200CF0
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D1A
WAIT_FOR_READY_133  200D4E
WAIT_FOR_READY_135  200D7A
WAIT_FOR_READY_137  200DAE
WAIT_FOR_READY_139  200DD8
WAIT_FOR_READY_141  200E0C
WAIT_FOR_READY_144  200E40
WAIT_FOR_READY_145  200E54
WAIT_FOR_READY_146  200E7C
WAIT_FOR_READY_149  200EC8
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_152  200F16
WAIT_FOR_READY_155  200F62
WAIT_FOR_READY_158  200FB4
WAIT_FOR_READY_161  201000
WAIT_FOR_READY_165  20106A
WAIT_FOR_READY_166  201082
WAIT_FOR_READY_168  201094
WAIT_FOR_READY_169  2010A8
WAIT_FOR_READY_17   200264
WAIT_FOR_READY_170  2010CC
WAIT_FOR_READY_173  201118
WAIT_FOR_READY_177  201176
WAIT_FOR_READY_179  20118E
WAIT_FOR_READY_18   200278
WAIT_FOR_READY_180  2011A2
WAIT_FOR_READY_182  2011CC
WAIT_FOR_READY_184  2011E2
WAIT_FOR_READY_185  2011F6
WAIT_FOR_READY_187  20120C
WAIT_FOR_READY_188  201220
WAIT_FOR_READY_190  20124A
WAIT_FOR_READY_192  20126E
WAIT_FOR_READY_194  201288
WAIT_FOR_READY_195  20129C
WAIT_FOR_READY_197  2012C6
WAIT_FOR_READY_199  2012DC
WAIT_FOR_READY_20   2002CA
WAIT_FOR_READY_200  2012F0
WAIT_FOR_READY_202  20137A
WAIT_FOR_READY_204  201396
WAIT_FOR_READY_205  2013AA
WAIT_FOR_READY_207  2013D4
WAIT_FOR_READY_209  2013EA
WAIT_FOR_READY_210  2013FE
WAIT_FOR_READY_22   2002F6
WAIT_FOR_READY_24   200322
WAIT_FOR_READY_26   200344
WAIT_FOR_READY_27   200358
WAIT_FOR_READY_29   200382
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   200398
WAIT_FOR_READY_32   2003AC
WAIT_FOR_READY_33   2003CA
WAIT_FOR_READY_35   2003E4
WAIT_FOR_READY_37   200412
WAIT_FOR_READY_39   20042C
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   200462
WAIT_FOR_READY_43   200476
WAIT_FOR_READY_44   200496
WAIT_FOR_READY_46   2004D2
WAIT_FOR_READY_48   20050A
WAIT_FOR_READY_51   200556
WAIT_FOR_READY_54   2005AC
WAIT_FOR_READY_57   2005F8
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200646
WAIT_FOR_READY_63   200692
WAIT_FOR_READY_66   2006F2
WAIT_FOR_READY_69   20073E
WAIT_FOR_READY_72   20078A
WAIT_FOR_READY_74   2007A0
WAIT_FOR_READY_75   2007B4
WAIT_FOR_READY_76   2007DC
WAIT_FOR_READY_78   200810
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   20083A
WAIT_FOR_READY_82   20086E
WAIT_FOR_READY_84   20089A
WAIT_FOR_READY_86   2008CE
WAIT_FOR_READY_88   2008F8
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   20092C
WAIT_FOR_READY_92   20096C
WAIT_FOR_READY_94   2009A0
WAIT_FOR_READY_96   2009CA
WAIT_FOR_READY_98   2009FE
WAIT_FOR_SRECORD    200496
Z                   201312
_00000000           2007D2
_00000001           2010C2
_00000002           200A5E
_00000003           2010C2
_00000004           200E72
_00000005           2010C2
_00000006           20105C
_00000007           2010C2
_00000008           20120A
_00000009           20136C
_10000000           2006E4
_10000001           2007A0
_10000002           20095E
_10000003           200A2C
_10000004           200CAE
_10000005           200E40
_10000006           20131A
_10000007           20133C
_10000008           201344
_10000009           201418
