00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 05/04/2021 13:07:04

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; reading the last odd byte doesn't seem to work for S1 records
00000000                             9  ; burn the monitor into eeprom from code
00000000                            10  ; add LDS and UDS with an OR gate
00000000                            11  ; S2 records don't deal well with odd lengths / addresses
00000000                            12  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            13  ;ram CHECK AT STARTUP??? WIOLL PREVEWNT RUNNIG CODE FROM RAM THOUGH, SO need cold/warm start
00000000                            14  ; check for escape during Z
00000000                            15  ; fix the DUART base address
00000000                            16  ; tidy up layout (indentation and comments)
00000000                            17  ; stop using two registers in download
00000000                            18  ; add a .W and .B variants of PRINT_REG
00000000                            19  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            20  ; fix being able to enter random chars when W'ing
00000000                            21  ;JMP -> BRA
00000000                            22  
00000000                            23  
00000000                            24      ORG  $0
00000000                            25      ;ORG  $200000
00000000                            26  
00000000  =00000000                 27  DEBUG               EQU 0
00000000                            28  
00000000                            29  ; constants
00000000  =00E00000                 30  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 31  DISPLAY_            EQU $0
00000000  =00E00001                 32  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            33  
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35  
00000000  =00D30000                 36  DUART_BASE          EQU $D30000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  RRRR
00000000  =00D30001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00D30011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00D30009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            83    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84    MOVE.B \1,\2
00000000                            85    ANDI.L #$F,\2
00000000                            86    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            87    ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            94    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            95    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            96    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            97    ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105        MOVE.B DUART_SRA,\2           ; read status register
00000000                           106        BTST #2,\2                    ; check for space to send
00000000                           107        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                           108        MOVE.B \1,DUART_TXA           ; send the next character
00000000                           109      ENDC
00000000                           110      
00000000                           111      IFNE DEBUG
00000000                           112        MOVE.B \1,D1
00000000                           113        MOVE.L #6,D0   
00000000                           114        TRAP #15                      ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll
00000000                           121  PRINT_CRLF MACRO                  
00000000                           122      PRINT_CHAR #13,\1             ; CR
00000000                           123      PRINT_CHAR #10,\1             ; LF
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #0,(\1)                 ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      JMP LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           139  PRINT_REG MACRO
00000000                           140      PRINT_CHAR #'0',\2          ;0x header
00000000                           141      PRINT_CHAR #'x',\2
00000000                           142      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148    
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           154  
00000000                           155      IFEQ DEBUG
00000000                           156        MOVE.B DUART_SRA,\2         ; read status register
00000000                           157        BTST #0,\2                    ; check for character
00000000                           158        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           159      ENDC
00000000                           160      
00000000                           161      READ_CHAR \1
00000000                           162  
00000000                           163      IFEQ DEBUG
00000000                           164        PRINT_CHAR \1,\2            ; echo it back
00000000                           165      ENDC
00000000                           166      ENDM
00000000                           167      
00000000                           168  ; read a char from the serial port - assumes that there is one!
00000000                           169  ; \ 1= data register for read char
00000000                           170  ; will stamp on D0 and D1 in debug mode
00000000                           171  READ_CHAR MACRO
00000000                           172      IFEQ DEBUG
00000000                           173        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           174      ENDC
00000000                           175      IFNE DEBUG
00000000                           176        MOVE.L #5,D0    
00000000                           177        TRAP #15                    ; read from keyboard in simulator
00000000                           178        MOVE.L D1,\1
00000000                           179      ENDC
00000000                           180       
00000000                           181      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           182      BEQ START
00000000                           183      ENDM
00000000                           184      
00000000                           185      
00000000                           186  ; read data from the download serial port
00000000                           187  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           188  DOWNLOAD MACRO
00000000                           189  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           190  
00000000                           191      MOVE.B DUART_SRA,\2           ; check for command
00000000                           192      BTST #0,\2                    ; check for character
00000000                           193      BEQ CONTINUE\@                ; nothing, continue
00000000                           194   
00000000                           195      READ_CHAR \1
00000000                           196  CONTINUE\@
00000000                           197      MOVE.B DUART_SRB,\2         ; read status register
00000000                           198      BTST #0,\2                  ; check for character
00000000                           199      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           200      
00000000                           201      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           202      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           203      
00000000                           204      ENDM
00000000                           205  
00000000                           206  
00000000                           207  ; register catalogue
00000000                           208  ; D0 - used for simulator I/O
00000000                           209  ; D1 - used for simulator I/O
00000000                           210  ; D2 - read character
00000000                           211  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           212  ; D4 - count of S records read
00000000                           213  ; D5 - data to write / data read / byte count for S record load
00000000                           214  ; D6 - working register used in R/W and download
00000000                           215  ; D7 - address accumulator / reset by download
00000000                           216  ; A0 - address of string to print 
00000000                           217  
00000000                           218  ; start vector
00000000= 00000000                 219      DC.L $00000000              ; PC
00000004= 00000000                 220      DC.L $00000000              ; SP
00000008                           221      
00000008                           222  ; start of program  
00000008                           223  START
00000008  13FC 0000 00E00001       224      MOVE.B #0,DISPLAY
00000010                           225  
00000010                           226  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       227      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       228      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     229      NOP
00000022  13FC 0040 00D30005       230      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     231      NOP
0000002C  13FC 0030 00D30005       232      MOVE.B #$30,DUART_CRA
00000034  4E71                     233      NOP
00000036  13FC 0020 00D30005       234      MOVE.B #$20,DUART_CRA
0000003E  4E71                     235      NOP
00000040  13FC 0010 00D30005       236      MOVE.B #$10,DUART_CRA   
00000048                           237  
00000048  13FC 000A 00D30015       238      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       239      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     240      NOP
0000005A  13FC 0040 00D30015       241      MOVE.B #$40,DUART_CRB           
00000062  4E71                     242      NOP
00000064  13FC 0030 00D30015       243      MOVE.B #$30,DUART_CRB
0000006C  4E71                     244      NOP
0000006E  13FC 0020 00D30015       245      MOVE.B #$20,DUART_CRB
00000076  4E71                     246      NOP
00000078  13FC 0010 00D30015       247      MOVE.B #$10,DUART_CRB   
00000080                           248  
00000080                           249  ;initialise UART
00000080  13FC 0000 00D30009       250      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       251      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       252      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           253  
00000098                           254  ; channel A
00000098  13FC 0013 00D30001       255      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       256      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       257      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       258      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           259  
000000B8                           260  ; channel B
000000B8  13FC 0013 00D30011       261      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       262      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       263      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       264      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           265  
000000D8                           266m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           267m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      268m     IFEQ DEBUG
000000D8  1639 00D30003            269m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                270m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     271m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       272m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           273m     ENDC
000000EC                           274m     
000000EC                 FALSE     275m     IFNE DEBUG
000000EC                           276m     ENDC
000000EC                           277m 
000000EC                           278m     ENDM
000000EC                           279  
000000EC  13FC 0001 00E00001       280      MOVE.B #1,DISPLAY
000000F4                           281         
000000F4                           282m     PRINT_CRLF D3
000000F4                           283mm     PRINT_CHAR #13,D3             ; CR
000000F4                           284mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      285mm     IFEQ DEBUG
000000F4  1639 00D30003            286mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                287mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     288mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       289mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           290mm     ENDC
00000108                           291mm     
00000108                 FALSE     292mm     IFNE DEBUG
00000108                           293mm     ENDC
00000108                           294mm 
00000108                           295mm     ENDM
00000108                           296mm     PRINT_CHAR #10,D3             ; LF
00000108                           297mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      298mm     IFEQ DEBUG
00000108  1639 00D30003            299mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                300mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     301mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       302mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           303mm     ENDC
0000011C                           304mm     
0000011C                 FALSE     305mm     IFNE DEBUG
0000011C                           306mm     ENDC
0000011C                           307mm 
0000011C                           308mm     ENDM
0000011C                           309m     ENDM
0000011C                           310  
0000011C  41F9 0000175A            311      LEA VERSION,A0
00000122                           312m     PRINT_STR A0,D3
00000122                           313m LOOP_5
00000122  0C10 0000                314m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                315m     BEQ EXIT_5
0000012A                           316mm     PRINT_CHAR (A0)+,D3
0000012A                           317mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      318mm     IFEQ DEBUG
0000012A  1639 00D30003            319mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                320mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     321mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            322mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           323mm     ENDC
0000013C                           324mm     
0000013C                 FALSE     325mm     IFNE DEBUG
0000013C                           326mm     ENDC
0000013C                           327mm 
0000013C                           328mm     ENDM
0000013C  4EF8 0122                329m     JMP LOOP_5
00000140                           330m EXIT_5
00000140                           331m     ENDM
00000140                           332m     PRINT_CRLF D3
00000140                           333mm     PRINT_CHAR #13,D3             ; CR
00000140                           334mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      335mm     IFEQ DEBUG
00000140  1639 00D30003            336mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                337mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     338mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       339mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           340mm     ENDC
00000154                           341mm     
00000154                 FALSE     342mm     IFNE DEBUG
00000154                           343mm     ENDC
00000154                           344mm 
00000154                           345mm     ENDM
00000154                           346mm     PRINT_CHAR #10,D3             ; LF
00000154                           347mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      348mm     IFEQ DEBUG
00000154  1639 00D30003            349mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                350mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     351mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       352mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           353mm     ENDC
00000168                           354mm     
00000168                 FALSE     355mm     IFNE DEBUG
00000168                           356mm     ENDC
00000168                           357mm 
00000168                           358mm     ENDM
00000168                           359m     ENDM
00000168                           360m     PRINT_CHAR #7,D3
00000168                           361m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      362m     IFEQ DEBUG
00000168  1639 00D30003            363m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                364m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     365m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       366m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           367m     ENDC
0000017C                           368m     
0000017C                 FALSE     369m     IFNE DEBUG
0000017C                           370m     ENDC
0000017C                           371m 
0000017C                           372m     ENDM
0000017C                           373  
0000017C  7E00                     374      MOVE.L #0,D7                    ; address accumulator
0000017E                           375  
0000017E  13FC 0002 00E00001       376      MOVE.B #2,DISPLAY
00000186                           377  MAIN_LOOP
00000186                           378m     PRINT_CHAR #'>',D3               ; prompt
00000186                           379m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      380m     IFEQ DEBUG
00000186  1639 00D30003            381m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                382m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     383m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       384m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           385m     ENDC
0000019A                           386m     
0000019A                 FALSE     387m     IFNE DEBUG
0000019A                           388m     ENDC
0000019A                           389m 
0000019A                           390m     ENDM
0000019A                           391m     PRINT_CHAR #32,D3                ; space
0000019A                           392m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      393m     IFEQ DEBUG
0000019A  1639 00D30003            394m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                395m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     396m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       397m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           398m     ENDC
000001AE                           399m     
000001AE                 FALSE     400m     IFNE DEBUG
000001AE                           401m     ENDC
000001AE                           402m 
000001AE                           403m     ENDM
000001AE                           404      
000001AE                           405  GET_INPUT
000001AE                           406m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           407m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           408m 
000001AE                 TRUE      409m     IFEQ DEBUG
000001AE  1639 00D30003            410m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                411m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     412m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           413m     ENDC
000001BA                           414m     
000001BA                           415mm     READ_CHAR D2
000001BA                 TRUE      416mm     IFEQ DEBUG
000001BA  1439 00D30007            417mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           418mm     ENDC
000001C0                 FALSE     419mm     IFNE DEBUG
000001C0                           420mm     ENDC
000001C0                           421mm      
000001C0  B43C 001B                422mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                423mm     BEQ START
000001C8                           424mm     ENDM
000001C8                           425m 
000001C8                 TRUE      426m     IFEQ DEBUG
000001C8                           427mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           428mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      429mm     IFEQ DEBUG
000001C8  1639 00D30003            430mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                431mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     432mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            433mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           434mm     ENDC
000001DA                           435mm     
000001DA                 FALSE     436mm     IFNE DEBUG
000001DA                           437mm     ENDC
000001DA                           438mm 
000001DA                           439mm     ENDM
000001DA                           440m     ENDC
000001DA                           441m     ENDM
000001DA                           442      
000001DA  B43C 0030                443      CMP.B #'0',D2
000001DE  6700 155A                444      BEQ HEX_DIGIT
000001E2  B43C 0031                445      CMP.B #'1',D2
000001E6  6700 1552                446      BEQ HEX_DIGIT
000001EA  B43C 0032                447      CMP.B #'2',D2
000001EE  6700 154A                448      BEQ HEX_DIGIT
000001F2  B43C 0033                449      CMP.B #'3',D2
000001F6  6700 1542                450      BEQ HEX_DIGIT
000001FA  B43C 0034                451      CMP.B #'4',D2
000001FE  6700 153A                452      BEQ HEX_DIGIT
00000202  B43C 0035                453      CMP.B #'5',D2
00000206  6700 1532                454      BEQ HEX_DIGIT
0000020A  B43C 0036                455      CMP.B #'6',D2
0000020E  6700 152A                456      BEQ HEX_DIGIT
00000212  B43C 0037                457      CMP.B #'7',D2
00000216  6700 1522                458      BEQ HEX_DIGIT
0000021A  B43C 0038                459      CMP.B #'8',D2
0000021E  6700 151A                460      BEQ HEX_DIGIT
00000222  B43C 0039                461      CMP.B #'9',D2
00000226  6700 1512                462      BEQ HEX_DIGIT
0000022A  B43C 0041                463      CMP.B #'A',D2
0000022E  6700 150A                464      BEQ HEX_DIGIT
00000232  B43C 0042                465      CMP.B #'B',D2
00000236  6700 1502                466      BEQ HEX_DIGIT
0000023A  B43C 0043                467      CMP.B #'C',D2
0000023E  6700 14FA                468      BEQ HEX_DIGIT
00000242  B43C 0044                469      CMP.B #'D',D2
00000246  6700 14F2                470      BEQ HEX_DIGIT
0000024A  B43C 0045                471      CMP.B #'E',D2
0000024E  6700 14EA                472      BEQ HEX_DIGIT
00000252  B43C 0046                473      CMP.B #'F',D2
00000256  6700 14E2                474      BEQ HEX_DIGIT
0000025A                           475      
0000025A  B43C 0057                476      CMP.B #'W',D2
0000025E  6700 0158                477      BEQ W
00000262                           478  
00000262                           479m     PRINT_CRLF D3
00000262                           480mm     PRINT_CHAR #13,D3             ; CR
00000262                           481mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      482mm     IFEQ DEBUG
00000262  1639 00D30003            483mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                484mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     485mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       486mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           487mm     ENDC
00000276                           488mm     
00000276                 FALSE     489mm     IFNE DEBUG
00000276                           490mm     ENDC
00000276                           491mm 
00000276                           492mm     ENDM
00000276                           493mm     PRINT_CHAR #10,D3             ; LF
00000276                           494mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      495mm     IFEQ DEBUG
00000276  1639 00D30003            496mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                497mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     498mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       499mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           500mm     ENDC
0000028A                           501mm     
0000028A                 FALSE     502mm     IFNE DEBUG
0000028A                           503mm     ENDC
0000028A                           504mm 
0000028A                           505mm     ENDM
0000028A                           506m     ENDM
0000028A                           507   
0000028A  B43C 003F                508      CMP.B #'?',D2
0000028E  6700 0052                509      BEQ H
00000292                           510  
00000292  B43C 0056                511      CMP.B #'V',D2
00000296  6700 0072                512      BEQ V
0000029A                           513      
0000029A  B43C 0052                514      CMP.B #'R',D2
0000029E  6700 0092                515      BEQ R
000002A2                           516  
000002A2  B43C 0053                517      CMP.B #'S',D2
000002A6  6700 01D6                518      BEQ S
000002AA                           519  
000002AA  B43C 0047                520      CMP.B #'G',D2
000002AE  6700 137A                521      BEQ G   
000002B2                           522  
000002B2  B43C 005A                523      CMP.B #'Z',D2
000002B6  6700 137A                524      BEQ Z   
000002BA                           525  
000002BA  41F9 000017F0            526      LEA HUH,A0
000002C0                           527m     PRINT_STR A0,D3
000002C0                           528m LOOP_19
000002C0  0C10 0000                529m     CMP.B #0,(A0)                 ; 0 -> DONE
000002C4  6700 0018                530m     BEQ EXIT_19
000002C8                           531mm     PRINT_CHAR (A0)+,D3
000002C8                           532mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      533mm     IFEQ DEBUG
000002C8  1639 00D30003            534mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002CE  0803 0002                535mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002D2  67F4                     536mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002D4  13D8 00D30007            537mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002DA                           538mm     ENDC
000002DA                           539mm     
000002DA                 FALSE     540mm     IFNE DEBUG
000002DA                           541mm     ENDC
000002DA                           542mm 
000002DA                           543mm     ENDM
000002DA  4EF8 02C0                544m     JMP LOOP_19
000002DE                           545m EXIT_19
000002DE                           546m     ENDM
000002DE                           547                         
000002DE  4EF8 0186                548      JMP MAIN_LOOP
000002E2                           549      
000002E2                           550  ; commands
000002E2  41F9 00001777            551  H   LEA HELP,A0
000002E8                           552m     PRINT_STR A0,D3
000002E8                           553m LOOP_21
000002E8  0C10 0000                554m     CMP.B #0,(A0)                 ; 0 -> DONE
000002EC  6700 0018                555m     BEQ EXIT_21
000002F0                           556mm     PRINT_CHAR (A0)+,D3
000002F0                           557mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      558mm     IFEQ DEBUG
000002F0  1639 00D30003            559mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002F6  0803 0002                560mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002FA  67F4                     561mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002FC  13D8 00D30007            562mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000302                           563mm     ENDC
00000302                           564mm     
00000302                 FALSE     565mm     IFNE DEBUG
00000302                           566mm     ENDC
00000302                           567mm 
00000302                           568mm     ENDM
00000302  4EF8 02E8                569m     JMP LOOP_21
00000306                           570m EXIT_21
00000306                           571m     ENDM
00000306  4EF8 0186                572      JMP MAIN_LOOP
0000030A                           573  
0000030A  41F9 0000175A            574  V   LEA VERSION,A0
00000310                           575m     PRINT_STR A0,D3       
00000310                           576m LOOP_23
00000310  0C10 0000                577m     CMP.B #0,(A0)                 ; 0 -> DONE
00000314  6700 0018                578m     BEQ EXIT_23
00000318                           579mm     PRINT_CHAR (A0)+,D3
00000318                           580mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000318                 TRUE      581mm     IFEQ DEBUG
00000318  1639 00D30003            582mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000031E  0803 0002                583mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000322  67F4                     584mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
00000324  13D8 00D30007            585mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000032A                           586mm     ENDC
0000032A                           587mm     
0000032A                 FALSE     588mm     IFNE DEBUG
0000032A                           589mm     ENDC
0000032A                           590mm 
0000032A                           591mm     ENDM
0000032A  4EF8 0310                592m     JMP LOOP_23
0000032E                           593m EXIT_23
0000032E                           594m     ENDM
0000032E  4EF8 0186                595      JMP MAIN_LOOP
00000332                           596      
00000332                           597  R   
00000332  2047                     598      MOVE.L D7,A0                    ; address accumulator -> address register
00000334  2A10                     599      MOVE.L (A0),D5                  ; read the memory and print it
00000336                           600m     PRINT_REG D5,D3,D7,D6,A0
00000336                           601mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000336                           602mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000336                 TRUE      603mm     IFEQ DEBUG
00000336  1639 00D30003            604mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000033C  0803 0002                605mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000340  67F4                     606mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00000342  13FC 0030 00D30007       607mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0000034A                           608mm     ENDC
0000034A                           609mm     
0000034A                 FALSE     610mm     IFNE DEBUG
0000034A                           611mm     ENDC
0000034A                           612mm 
0000034A                           613mm     ENDM
0000034A                           614mm     PRINT_CHAR #'x',D3
0000034A                           615mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000034A                 TRUE      616mm     IFEQ DEBUG
0000034A  1639 00D30003            617mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000350  0803 0002                618mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000354  67F4                     619mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000356  13FC 0078 00D30007       620mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0000035E                           621mm     ENDC
0000035E                           622mm     
0000035E                 FALSE     623mm     IFNE DEBUG
0000035E                           624mm     ENDC
0000035E                           625mm 
0000035E                           626mm     ENDM
0000035E  7C07                     627m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000360                           628m LOOP_25
00000360                           629mm     BIN2HEX D5,D7,A0
00000360  41F9 0000188D            630mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000366  E99D                     631mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000368  1E05                     632mm   MOVE.B D5,D7
0000036A  0287 0000000F            633mm   ANDI.L #$F,D7
00000370  1E30 7000                634mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000374                           635mm   ENDM
00000374                           636mm     PRINT_CHAR D7,D3
00000374                           637mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000374                 TRUE      638mm     IFEQ DEBUG
00000374  1639 00D30003            639mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000037A  0803 0002                640mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000037E  67F4                     641mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000380  13C7 00D30007            642mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000386                           643mm     ENDC
00000386                           644mm     
00000386                 FALSE     645mm     IFNE DEBUG
00000386                           646mm     ENDC
00000386                           647mm 
00000386                           648mm     ENDM
00000386  57CE FFD8                649m     DBEQ D6,LOOP_25
0000038A                           650m     ENDM
0000038A                           651m     PRINT_CRLF D3
0000038A                           652mm     PRINT_CHAR #13,D3             ; CR
0000038A                           653mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038A                 TRUE      654mm     IFEQ DEBUG
0000038A  1639 00D30003            655mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000390  0803 0002                656mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000394  67F4                     657mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
00000396  13FC 000D 00D30007       658mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000039E                           659mm     ENDC
0000039E                           660mm     
0000039E                 FALSE     661mm     IFNE DEBUG
0000039E                           662mm     ENDC
0000039E                           663mm 
0000039E                           664mm     ENDM
0000039E                           665mm     PRINT_CHAR #10,D3             ; LF
0000039E                           666mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039E                 TRUE      667mm     IFEQ DEBUG
0000039E  1639 00D30003            668mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003A4  0803 0002                669mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003A8  67F4                     670mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
000003AA  13FC 000A 00D30007       671mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000003B2                           672mm     ENDC
000003B2                           673mm     
000003B2                 FALSE     674mm     IFNE DEBUG
000003B2                           675mm     ENDC
000003B2                           676mm 
000003B2                           677mm     ENDM
000003B2                           678m     ENDM
000003B2  7E00                     679      MOVE.L #0,D7                    ; clear the now used address accumulator
000003B4  4EF8 0186                680      JMP MAIN_LOOP
000003B8                           681  
000003B8  7A00                     682  W   MOVE.L #0,D5                    ; D5 will be the value to write            
000003BA                           683  
000003BA                           684m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
000003BA                           685m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BA                           686m 
000003BA                 TRUE      687m     IFEQ DEBUG
000003BA  1639 00D30003            688m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003C0  0803 0000                689m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003C4  67F4                     690m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
000003C6                           691m     ENDC
000003C6                           692m     
000003C6                           693mm     READ_CHAR D2
000003C6                 TRUE      694mm     IFEQ DEBUG
000003C6  1439 00D30007            695mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003CC                           696mm     ENDC
000003CC                 FALSE     697mm     IFNE DEBUG
000003CC                           698mm     ENDC
000003CC                           699mm      
000003CC  B43C 001B                700mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003D0  6700 FC36                701mm     BEQ START
000003D4                           702mm     ENDM
000003D4                           703m 
000003D4                 TRUE      704m     IFEQ DEBUG
000003D4                           705mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003D4                           706mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D4                 TRUE      707mm     IFEQ DEBUG
000003D4  1639 00D30003            708mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003DA  0803 0002                709mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003DE  67F4                     710mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
000003E0  13C2 00D30007            711mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003E6                           712mm     ENDC
000003E6                           713mm     
000003E6                 FALSE     714mm     IFNE DEBUG
000003E6                           715mm     ENDC
000003E6                           716mm 
000003E6                           717mm     ENDM
000003E6                           718m     ENDC
000003E6                           719m     ENDM
000003E6                           720m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003E6  41F9 0000189D            721m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003EC  0402 0030                722m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F0  C4BC 000000FF            723m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000003F6  1430 2000                724m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000003FA                           725m   ENDM
000003FA  1A02                     726      MOVE.B D2,D5                    ; put at bottom of D5
000003FC                           727  
000003FC  3C3C 0006                728      MOVE #6,D6                      ; 7 bytes left to read
00000400                           729      
00000400                           730  READ_DATA_TO_POKE
00000400  E98D                     731      LSL.L #4,D5                     ; make what we have so far more significant
00000402                           732m     WAIT_CHAR D2,D3                 ; next character -> D2
00000402                           733m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           734m 
00000402                 TRUE      735m     IFEQ DEBUG
00000402  1639 00D30003            736m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000408  0803 0000                737m       BTST #0,D3                    ; CHECK FOR CHARACTER
0000040C  67F4                     738m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
0000040E                           739m     ENDC
0000040E                           740m     
0000040E                           741mm     READ_CHAR D2
0000040E                 TRUE      742mm     IFEQ DEBUG
0000040E  1439 00D30007            743mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000414                           744mm     ENDC
00000414                 FALSE     745mm     IFNE DEBUG
00000414                           746mm     ENDC
00000414                           747mm      
00000414  B43C 001B                748mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                749mm     BEQ START
0000041C                           750mm     ENDM
0000041C                           751m 
0000041C                 TRUE      752m     IFEQ DEBUG
0000041C                           753mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0000041C                           754mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      755mm     IFEQ DEBUG
0000041C  1639 00D30003            756mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000422  0803 0002                757mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000426  67F4                     758mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00000428  13C2 00D30007            759mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000042E                           760mm     ENDC
0000042E                           761mm     
0000042E                 FALSE     762mm     IFNE DEBUG
0000042E                           763mm     ENDC
0000042E                           764mm 
0000042E                           765mm     ENDM
0000042E                           766m     ENDC
0000042E                           767m     ENDM
0000042E                           768m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
0000042E  41F9 0000189D            769m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000434  0402 0030                770m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000438  C4BC 000000FF            771m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000043E  1430 2000                772m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000442                           773m   ENDM
00000442  8A02                     774      OR.B D2,D5
00000444  023C 00FB                775      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000448  57CE FFB6                776      DBEQ D6,READ_DATA_TO_POKE
0000044C                           777      
0000044C  2047                     778      MOVE.L D7,A0                    ; address accumulator -> address register
0000044E  7E00                     779      MOVE.L #0,D7                    ; clear the now used address accumulator
00000450                           780      
00000450  2085                     781      MOVE.L D5,(A0)                  ; write the data
00000452                           782  
00000452                           783m     PRINT_CRLF D3
00000452                           784mm     PRINT_CHAR #13,D3             ; CR
00000452                           785mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                 TRUE      786mm     IFEQ DEBUG
00000452  1639 00D30003            787mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000458  0803 0002                788mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000045C  67F4                     789mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
0000045E  13FC 000D 00D30007       790mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000466                           791mm     ENDC
00000466                           792mm     
00000466                 FALSE     793mm     IFNE DEBUG
00000466                           794mm     ENDC
00000466                           795mm 
00000466                           796mm     ENDM
00000466                           797mm     PRINT_CHAR #10,D3             ; LF
00000466                           798mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000466                 TRUE      799mm     IFEQ DEBUG
00000466  1639 00D30003            800mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000046C  0803 0002                801mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000470  67F4                     802mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
00000472  13FC 000A 00D30007       803mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000047A                           804mm     ENDC
0000047A                           805mm     
0000047A                 FALSE     806mm     IFNE DEBUG
0000047A                           807mm     ENDC
0000047A                           808mm 
0000047A                           809mm     ENDM
0000047A                           810m     ENDM
0000047A  4EF8 0186                811      JMP MAIN_LOOP
0000047E                           812  
0000047E                           813  
0000047E  2647                     814  S   MOVE.L D7,A3                    ; grab the address accumulator
00000480  7800                     815      MOVE.L #0,D4                    ; count of records read -> D4
00000482  2478 0000                816      MOVE.L 0,A2                     ; start address -> A2
00000486                           817      
00000486                           818  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00000486                           819m     DOWNLOAD D2,D3                  
00000486                           820m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                           821m 
00000486  1639 00D30003            822m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000048C  0803 0000                823m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000490  6700 0010                824m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
00000494                           825m  
00000494                           826mm     READ_CHAR D2
00000494                 TRUE      827mm     IFEQ DEBUG
00000494  1439 00D30007            828mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000049A                           829mm     ENDC
0000049A                 FALSE     830mm     IFNE DEBUG
0000049A                           831mm     ENDC
0000049A                           832mm      
0000049A  B43C 001B                833mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000049E  6700 FB68                834mm     BEQ START
000004A2                           835mm     ENDM
000004A2                           836m CONTINUE_44
000004A2  1639 00D30013            837m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004A8  0803 0000                838m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004AC  67D8                     839m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004AE                           840m     
000004AE  1439 00D30017            841m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004B4  13C2 00E00001            842m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004BA                           843m     
000004BA                           844m     ENDM
000004BA  B43C 0053                845      CMP.B #'S',D2                   ; found S?    
000004BE  66C6                     846      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
000004C0                           847      
000004C0  5284                     848      ADD.L #1,D4                     ; read another S record, increment count
000004C2                           849      
000004C2                           850m     DOWNLOAD D7,D3                  ; read the record digit
000004C2                           851m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C2                           852m 
000004C2  1639 00D30003            853m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004C8  0803 0000                854m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004CC  6700 0010                855m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004D0                           856m  
000004D0                           857mm     READ_CHAR D7
000004D0                 TRUE      858mm     IFEQ DEBUG
000004D0  1E39 00D30007            859mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
000004D6                           860mm     ENDC
000004D6                 FALSE     861mm     IFNE DEBUG
000004D6                           862mm     ENDC
000004D6                           863mm      
000004D6  BE3C 001B                864mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
000004DA  6700 FB2C                865mm     BEQ START
000004DE                           866mm     ENDM
000004DE                           867m CONTINUE_46
000004DE  1639 00D30013            868m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004E4  0803 0000                869m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004E8  67D8                     870m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
000004EA                           871m     
000004EA  1E39 00D30017            872m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
000004F0  13C7 00E00001            873m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
000004F6                           874m     
000004F6                           875m     ENDM
000004F6                           876  
000004F6  7C00                     877      MOVE.L #0,D6                    ; checksum
000004F8                           878  
000004F8  7A00                     879      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
000004FA                           880m     DOWNLOAD D2,D3              
000004FA                           881m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FA                           882m 
000004FA  1639 00D30003            883m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000500  0803 0000                884m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000504  6700 0010                885m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00000508                           886m  
00000508                           887mm     READ_CHAR D2
00000508                 TRUE      888mm     IFEQ DEBUG
00000508  1439 00D30007            889mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000050E                           890mm     ENDC
0000050E                 FALSE     891mm     IFNE DEBUG
0000050E                           892mm     ENDC
0000050E                           893mm      
0000050E  B43C 001B                894mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000512  6700 FAF4                895mm     BEQ START
00000516                           896mm     ENDM
00000516                           897m CONTINUE_48
00000516  1639 00D30013            898m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000051C  0803 0000                899m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000520  67D8                     900m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00000522                           901m     
00000522  1439 00D30017            902m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000528  13C2 00E00001            903m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000052E                           904m     
0000052E                           905m     ENDM
0000052E                           906m     HEX2BIN D2,D2,A0
0000052E  41F9 0000189D            907m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000534  0402 0030                908m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000538  C4BC 000000FF            909m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000053E  1430 2000                910m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000542                           911m   ENDM
00000542  8A82                     912      OR.L D2,D5
00000544  E98D                     913      LSL.L #4,D5    
00000546                           914m     DOWNLOAD D2,D3
00000546                           915m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000546                           916m 
00000546  1639 00D30003            917m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000054C  0803 0000                918m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000550  6700 0010                919m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
00000554                           920m  
00000554                           921mm     READ_CHAR D2
00000554                 TRUE      922mm     IFEQ DEBUG
00000554  1439 00D30007            923mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000055A                           924mm     ENDC
0000055A                 FALSE     925mm     IFNE DEBUG
0000055A                           926mm     ENDC
0000055A                           927mm      
0000055A  B43C 001B                928mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000055E  6700 FAA8                929mm     BEQ START
00000562                           930mm     ENDM
00000562                           931m CONTINUE_51
00000562  1639 00D30013            932m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000568  0803 0000                933m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000056C  67D8                     934m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
0000056E                           935m     
0000056E  1439 00D30017            936m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000574  13C2 00E00001            937m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000057A                           938m     
0000057A                           939m     ENDM
0000057A                           940m     HEX2BIN D2,D2,A0  
0000057A  41F9 0000189D            941m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000580  0402 0030                942m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000584  C4BC 000000FF            943m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000058A  1430 2000                944m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000058E                           945m   ENDM
0000058E  8A82                     946      OR.L D2,D5
00000590                           947                  
00000590  DC85                     948      ADD.L D5,D6                     ; add byte count into checksum
00000592                           949  
00000592                           950      IF.B D7 <EQ> #'0' THEN.L        ; header
00000592  BE3C 0030                951s     CMP.B   #'0',D7
00000596  6600 0228                952s     BNE.L   _00000000
0000059A  7E00                     953          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
0000059C                           954m         DOWNLOAD D2,D3              ; top byte
0000059C                           955m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059C                           956m 
0000059C  1639 00D30003            957m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005A2  0803 0000                958m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005A6  6700 0010                959m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
000005AA                           960m  
000005AA                           961mm     READ_CHAR D2
000005AA                 TRUE      962mm     IFEQ DEBUG
000005AA  1439 00D30007            963mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005B0                           964mm     ENDC
000005B0                 FALSE     965mm     IFNE DEBUG
000005B0                           966mm     ENDC
000005B0                           967mm      
000005B0  B43C 001B                968mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005B4  6700 FA52                969mm     BEQ START
000005B8                           970mm     ENDM
000005B8                           971m CONTINUE_54
000005B8  1639 00D30013            972m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005BE  0803 0000                973m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005C2  67D8                     974m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
000005C4                           975m     
000005C4  1439 00D30017            976m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005CA  13C2 00E00001            977m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005D0                           978m     
000005D0                           979m     ENDM
000005D0                           980m         HEX2BIN D2,D2,A0
000005D0  41F9 0000189D            981m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005D6  0402 0030                982m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005DA  C4BC 000000FF            983m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005E0  1430 2000                984m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005E4                           985m   ENDM
000005E4  8E82                     986          OR.L D2,D7
000005E6  E98F                     987          LSL.L #4,D7
000005E8                           988m         DOWNLOAD D2,D3         
000005E8                           989m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E8                           990m 
000005E8  1639 00D30003            991m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005EE  0803 0000                992m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005F2  6700 0010                993m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
000005F6                           994m  
000005F6                           995mm     READ_CHAR D2
000005F6                 TRUE      996mm     IFEQ DEBUG
000005F6  1439 00D30007            997mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005FC                           998mm     ENDC
000005FC                 FALSE     999mm     IFNE DEBUG
000005FC                          1000mm     ENDC
000005FC                          1001mm      
000005FC  B43C 001B               1002mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000600  6700 FA06               1003mm     BEQ START
00000604                          1004mm     ENDM
00000604                          1005m CONTINUE_57
00000604  1639 00D30013           1006m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000060A  0803 0000               1007m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000060E  67D8                    1008m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
00000610                          1009m     
00000610  1439 00D30017           1010m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000616  13C2 00E00001           1011m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000061C                          1012m     
0000061C                          1013m     ENDM
0000061C                          1014m         HEX2BIN D2,D2,A0
0000061C  41F9 0000189D           1015m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000622  0402 0030               1016m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000626  C4BC 000000FF           1017m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000062C  1430 2000               1018m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000630                          1019m   ENDM
00000630  8E82                    1020          OR.L D2,D7
00000632                          1021          
00000632  DC87                    1022          ADD.L D7,D6                 ; add top byte of address into checksum
00000634                          1023  
00000634  E98F                    1024          LSL.L #4,D7                 ; bottom byte
00000636                          1025m         DOWNLOAD D2,D3
00000636                          1026m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000636                          1027m 
00000636  1639 00D30003           1028m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000063C  0803 0000               1029m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000640  6700 0010               1030m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
00000644                          1031m  
00000644                          1032mm     READ_CHAR D2
00000644                 TRUE     1033mm     IFEQ DEBUG
00000644  1439 00D30007           1034mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000064A                          1035mm     ENDC
0000064A                 FALSE    1036mm     IFNE DEBUG
0000064A                          1037mm     ENDC
0000064A                          1038mm      
0000064A  B43C 001B               1039mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000064E  6700 F9B8               1040mm     BEQ START
00000652                          1041mm     ENDM
00000652                          1042m CONTINUE_60
00000652  1639 00D30013           1043m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000658  0803 0000               1044m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000065C  67D8                    1045m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
0000065E                          1046m     
0000065E  1439 00D30017           1047m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000664  13C2 00E00001           1048m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000066A                          1049m     
0000066A                          1050m     ENDM
0000066A                          1051m         HEX2BIN D2,D2,A0
0000066A  41F9 0000189D           1052m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000670  0402 0030               1053m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000674  C4BC 000000FF           1054m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000067A  1430 2000               1055m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000067E                          1056m   ENDM
0000067E  8E82                    1057          OR.L D2,D7
00000680  E98F                    1058          LSL.L #4,D7        
00000682                          1059m         DOWNLOAD D2,D3
00000682                          1060m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000682                          1061m 
00000682  1639 00D30003           1062m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000688  0803 0000               1063m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000068C  6700 0010               1064m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
00000690                          1065m  
00000690                          1066mm     READ_CHAR D2
00000690                 TRUE     1067mm     IFEQ DEBUG
00000690  1439 00D30007           1068mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000696                          1069mm     ENDC
00000696                 FALSE    1070mm     IFNE DEBUG
00000696                          1071mm     ENDC
00000696                          1072mm      
00000696  B43C 001B               1073mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000069A  6700 F96C               1074mm     BEQ START
0000069E                          1075mm     ENDM
0000069E                          1076m CONTINUE_63
0000069E  1639 00D30013           1077m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006A4  0803 0000               1078m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006A8  67D8                    1079m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
000006AA                          1080m     
000006AA  1439 00D30017           1081m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006B0  13C2 00E00001           1082m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006B6                          1083m     
000006B6                          1084m     ENDM
000006B6                          1085m         HEX2BIN D2,D2,A0
000006B6  41F9 0000189D           1086m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000006BC  0402 0030               1087m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006C0  C4BC 000000FF           1088m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000006C6  1430 2000               1089m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006CA                          1090m   ENDM
000006CA  8E82                    1091          OR.L D2,D7
000006CC                          1092          
000006CC  7400                    1093          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
000006CE  1407                    1094          MOVE.B D7,D2
000006D0  DC82                    1095          ADD.L D2,D6
000006D2                          1096          
000006D2  5785                    1097          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006D4                          1098          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006D4                          1099s _10000000
000006D4  BABC 00000000           1100s     CMP.L   #0,D5
000006DA  6F00 00B4               1101s     BLE _10000001
000006DE  5385                    1102            SUB.L #1,D5
000006E0                          1103              
000006E0  7E00                    1104            MOVE.L #0,D7              ; D7 holds the byte
000006E2                          1105              
000006E2                          1106m           DOWNLOAD D2,D3            ; MS 4 bits
000006E2                          1107m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E2                          1108m 
000006E2  1639 00D30003           1109m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006E8  0803 0000               1110m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006EC  6700 0010               1111m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
000006F0                          1112m  
000006F0                          1113mm     READ_CHAR D2
000006F0                 TRUE     1114mm     IFEQ DEBUG
000006F0  1439 00D30007           1115mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006F6                          1116mm     ENDC
000006F6                 FALSE    1117mm     IFNE DEBUG
000006F6                          1118mm     ENDC
000006F6                          1119mm      
000006F6  B43C 001B               1120mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006FA  6700 F90C               1121mm     BEQ START
000006FE                          1122mm     ENDM
000006FE                          1123m CONTINUE_66
000006FE  1639 00D30013           1124m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000704  0803 0000               1125m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000708  67D8                    1126m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
0000070A                          1127m     
0000070A  1439 00D30017           1128m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000710  13C2 00E00001           1129m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000716                          1130m     
00000716                          1131m     ENDM
00000716                          1132m           HEX2BIN D2,D2,A0
00000716  41F9 0000189D           1133m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000071C  0402 0030               1134m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000720  C4BC 000000FF           1135m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000726  1430 2000               1136m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000072A                          1137m   ENDM
0000072A  8E82                    1138            OR.L D2,D7
0000072C  E98F                    1139            LSL.L #4,D7
0000072E                          1140               
0000072E                          1141m           DOWNLOAD D2,D3            ; LS 4 bits    
0000072E                          1142m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000072E                          1143m 
0000072E  1639 00D30003           1144m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000734  0803 0000               1145m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000738  6700 0010               1146m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
0000073C                          1147m  
0000073C                          1148mm     READ_CHAR D2
0000073C                 TRUE     1149mm     IFEQ DEBUG
0000073C  1439 00D30007           1150mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000742                          1151mm     ENDC
00000742                 FALSE    1152mm     IFNE DEBUG
00000742                          1153mm     ENDC
00000742                          1154mm      
00000742  B43C 001B               1155mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000746  6700 F8C0               1156mm     BEQ START
0000074A                          1157mm     ENDM
0000074A                          1158m CONTINUE_69
0000074A  1639 00D30013           1159m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000750  0803 0000               1160m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000754  67D8                    1161m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00000756                          1162m     
00000756  1439 00D30017           1163m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000075C  13C2 00E00001           1164m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000762                          1165m     
00000762                          1166m     ENDM
00000762                          1167m           HEX2BIN D2,D2,A0
00000762  41F9 0000189D           1168m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000768  0402 0030               1169m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000076C  C4BC 000000FF           1170m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000772  1430 2000               1171m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000776                          1172m   ENDM
00000776  8E82                    1173            OR.L D2,D7
00000778                          1174              
00000778  DC87                    1175            ADD.L D7,D6               ; add into checksum
0000077A                          1176            
0000077A                          1177m           PRINT_CHAR D7,D3          ; assume ASCII and print it
0000077A                          1178m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000077A                 TRUE     1179m     IFEQ DEBUG
0000077A  1639 00D30003           1180m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000780  0803 0002               1181m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000784  67F4                    1182m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
00000786  13C7 00D30007           1183m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000078C                          1184m     ENDC
0000078C                          1185m     
0000078C                 FALSE    1186m     IFNE DEBUG
0000078C                          1187m     ENDC
0000078C                          1188m 
0000078C                          1189m     ENDM
0000078C                          1190          ENDW
0000078C  6000 FF46               1191s     BRA _10000000
00000790                          1192s _10000001
00000790                          1193m         PRINT_CRLF D3
00000790                          1194mm     PRINT_CHAR #13,D3             ; CR
00000790                          1195mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000790                 TRUE     1196mm     IFEQ DEBUG
00000790  1639 00D30003           1197mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000796  0803 0002               1198mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000079A  67F4                    1199mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
0000079C  13FC 000D 00D30007      1200mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000007A4                          1201mm     ENDC
000007A4                          1202mm     
000007A4                 FALSE    1203mm     IFNE DEBUG
000007A4                          1204mm     ENDC
000007A4                          1205mm 
000007A4                          1206mm     ENDM
000007A4                          1207mm     PRINT_CHAR #10,D3             ; LF
000007A4                          1208mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A4                 TRUE     1209mm     IFEQ DEBUG
000007A4  1639 00D30003           1210mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007AA  0803 0002               1211mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007AE  67F4                    1212mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
000007B0  13FC 000A 00D30007      1213mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000007B8                          1214mm     ENDC
000007B8                          1215mm     
000007B8                 FALSE    1216mm     IFNE DEBUG
000007B8                          1217mm     ENDC
000007B8                          1218mm 
000007B8                          1219mm     ENDM
000007B8                          1220m     ENDM
000007B8  43F8 0486               1221         LEA WAIT_FOR_SRECORD,A1            
000007BC                          1222      ELSE
000007BC  6000 0C26               1223s     BRA _00000001
000007C0                          1224s _00000000
000007C0                          1225        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
000007C0  BE3C 0031               1226s     CMP.B   #'1',D7
000007C4  6600 04F4               1227s     BNE.L   _00000002
000007C8  7E00                    1228          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007CA                          1229m         DOWNLOAD D2,D3              ; top byte
000007CA                          1230m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CA                          1231m 
000007CA  1639 00D30003           1232m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007D0  0803 0000               1233m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007D4  6700 0010               1234m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
000007D8                          1235m  
000007D8                          1236mm     READ_CHAR D2
000007D8                 TRUE     1237mm     IFEQ DEBUG
000007D8  1439 00D30007           1238mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007DE                          1239mm     ENDC
000007DE                 FALSE    1240mm     IFNE DEBUG
000007DE                          1241mm     ENDC
000007DE                          1242mm      
000007DE  B43C 001B               1243mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007E2  6700 F824               1244mm     BEQ START
000007E6                          1245mm     ENDM
000007E6                          1246m CONTINUE_76
000007E6  1639 00D30013           1247m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007EC  0803 0000               1248m     BTST #0,D3                  ; CHECK FOR CHARACTER
000007F0  67D8                    1249m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
000007F2                          1250m     
000007F2  1439 00D30017           1251m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000007F8  13C2 00E00001           1252m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000007FE                          1253m     
000007FE                          1254m     ENDM
000007FE                          1255m         PRINT_CHAR D2,D3
000007FE                          1256m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FE                 TRUE     1257m     IFEQ DEBUG
000007FE  1639 00D30003           1258m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000804  0803 0002               1259m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000808  67F4                    1260m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
0000080A  13C2 00D30007           1261m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000810                          1262m     ENDC
00000810                          1263m     
00000810                 FALSE    1264m     IFNE DEBUG
00000810                          1265m     ENDC
00000810                          1266m 
00000810                          1267m     ENDM
00000810                          1268m         HEX2BIN D2,D2,A0
00000810  41F9 0000189D           1269m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000816  0402 0030               1270m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000081A  C4BC 000000FF           1271m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000820  1430 2000               1272m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000824                          1273m   ENDM
00000824  8E82                    1274          OR.L D2,D7
00000826  E98F                    1275          LSL.L #4,D7
00000828                          1276m         DOWNLOAD D2,D3         
00000828                          1277m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000828                          1278m 
00000828  1639 00D30003           1279m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000082E  0803 0000               1280m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000832  6700 0010               1281m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00000836                          1282m  
00000836                          1283mm     READ_CHAR D2
00000836                 TRUE     1284mm     IFEQ DEBUG
00000836  1439 00D30007           1285mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000083C                          1286mm     ENDC
0000083C                 FALSE    1287mm     IFNE DEBUG
0000083C                          1288mm     ENDC
0000083C                          1289mm      
0000083C  B43C 001B               1290mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000840  6700 F7C6               1291mm     BEQ START
00000844                          1292mm     ENDM
00000844                          1293m CONTINUE_80
00000844  1639 00D30013           1294m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000084A  0803 0000               1295m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000084E  67D8                    1296m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
00000850                          1297m     
00000850  1439 00D30017           1298m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000856  13C2 00E00001           1299m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000085C                          1300m     
0000085C                          1301m     ENDM
0000085C                          1302m         PRINT_CHAR D2,D3
0000085C                          1303m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085C                 TRUE     1304m     IFEQ DEBUG
0000085C  1639 00D30003           1305m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000862  0803 0002               1306m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000866  67F4                    1307m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00000868  13C2 00D30007           1308m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000086E                          1309m     ENDC
0000086E                          1310m     
0000086E                 FALSE    1311m     IFNE DEBUG
0000086E                          1312m     ENDC
0000086E                          1313m 
0000086E                          1314m     ENDM
0000086E                          1315m         HEX2BIN D2,D2,A0
0000086E  41F9 0000189D           1316m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000874  0402 0030               1317m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000878  C4BC 000000FF           1318m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000087E  1430 2000               1319m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000882                          1320m   ENDM
00000882  8E82                    1321          OR.L D2,D7
00000884                          1322          
00000884  DC87                    1323          ADD.L D7,D6                 ; add top byte of address into checksum
00000886                          1324  
00000886  E98F                    1325          LSL.L #4,D7                 ; bottom byte
00000888                          1326m         DOWNLOAD D2,D3
00000888                          1327m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000888                          1328m 
00000888  1639 00D30003           1329m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000088E  0803 0000               1330m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000892  6700 0010               1331m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
00000896                          1332m  
00000896                          1333mm     READ_CHAR D2
00000896                 TRUE     1334mm     IFEQ DEBUG
00000896  1439 00D30007           1335mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000089C                          1336mm     ENDC
0000089C                 FALSE    1337mm     IFNE DEBUG
0000089C                          1338mm     ENDC
0000089C                          1339mm      
0000089C  B43C 001B               1340mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008A0  6700 F766               1341mm     BEQ START
000008A4                          1342mm     ENDM
000008A4                          1343m CONTINUE_84
000008A4  1639 00D30013           1344m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008AA  0803 0000               1345m     BTST #0,D3                  ; CHECK FOR CHARACTER
000008AE  67D8                    1346m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
000008B0                          1347m     
000008B0  1439 00D30017           1348m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000008B6  13C2 00E00001           1349m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000008BC                          1350m     
000008BC                          1351m     ENDM
000008BC                          1352m         PRINT_CHAR D2,D3
000008BC                          1353m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BC                 TRUE     1354m     IFEQ DEBUG
000008BC  1639 00D30003           1355m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008C2  0803 0002               1356m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008C6  67F4                    1357m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
000008C8  13C2 00D30007           1358m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000008CE                          1359m     ENDC
000008CE                          1360m     
000008CE                 FALSE    1361m     IFNE DEBUG
000008CE                          1362m     ENDC
000008CE                          1363m 
000008CE                          1364m     ENDM
000008CE                          1365m         HEX2BIN D2,D2,A0
000008CE  41F9 0000189D           1366m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000008D4  0402 0030               1367m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D8  C4BC 000000FF           1368m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000008DE  1430 2000               1369m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000008E2                          1370m   ENDM
000008E2  8E82                    1371          OR.L D2,D7
000008E4  E98F                    1372          LSL.L #4,D7        
000008E6                          1373m         DOWNLOAD D2,D3
000008E6                          1374m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                          1375m 
000008E6  1639 00D30003           1376m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000008EC  0803 0000               1377m     BTST #0,D3                    ; CHECK FOR CHARACTER
000008F0  6700 0010               1378m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
000008F4                          1379m  
000008F4                          1380mm     READ_CHAR D2
000008F4                 TRUE     1381mm     IFEQ DEBUG
000008F4  1439 00D30007           1382mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000008FA                          1383mm     ENDC
000008FA                 FALSE    1384mm     IFNE DEBUG
000008FA                          1385mm     ENDC
000008FA                          1386mm      
000008FA  B43C 001B               1387mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008FE  6700 F708               1388mm     BEQ START
00000902                          1389mm     ENDM
00000902                          1390m CONTINUE_88
00000902  1639 00D30013           1391m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000908  0803 0000               1392m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000090C  67D8                    1393m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
0000090E                          1394m     
0000090E  1439 00D30017           1395m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000914  13C2 00E00001           1396m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000091A                          1397m     
0000091A                          1398m     ENDM
0000091A                          1399m         PRINT_CHAR D2,D3
0000091A                          1400m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000091A                 TRUE     1401m     IFEQ DEBUG
0000091A  1639 00D30003           1402m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000920  0803 0002               1403m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000924  67F4                    1404m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00000926  13C2 00D30007           1405m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000092C                          1406m     ENDC
0000092C                          1407m     
0000092C                 FALSE    1408m     IFNE DEBUG
0000092C                          1409m     ENDC
0000092C                          1410m 
0000092C                          1411m     ENDM
0000092C                          1412m         HEX2BIN D2,D2,A0
0000092C  41F9 0000189D           1413m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000932  0402 0030               1414m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000936  C4BC 000000FF           1415m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000093C  1430 2000               1416m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000940                          1417m   ENDM
00000940  8E82                    1418          OR.L D2,D7
00000942                          1419          
00000942  7400                    1420          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000944  1407                    1421          MOVE.B D7,D2
00000946  DC82                    1422          ADD.L D2,D6
00000948                          1423          
00000948  DE8B                    1424          ADD.L A3,D7                 ; add in the offset
0000094A                          1425          
0000094A  5785                    1426          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
0000094C                          1427          
0000094C  0807 0000               1428          BTST #0,D7                  ; deal with odd addresses
00000950                          1429  
00000950  2247                    1430          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000952  6700 00D0               1431          BEQ EVEN
00000956                          1432                  
00000956  5385                    1433          SUB.L #1,D5
00000958  5389                    1434          SUB.L #1,A1
0000095A                          1435          
0000095A  7E00                    1436          MOVE.L #0,D7
0000095C                          1437m         DOWNLOAD D2,D3            ; MS 4 bits
0000095C                          1438m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                          1439m 
0000095C  1639 00D30003           1440m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000962  0803 0000               1441m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000966  6700 0010               1442m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
0000096A                          1443m  
0000096A                          1444mm     READ_CHAR D2
0000096A                 TRUE     1445mm     IFEQ DEBUG
0000096A  1439 00D30007           1446mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000970                          1447mm     ENDC
00000970                 FALSE    1448mm     IFNE DEBUG
00000970                          1449mm     ENDC
00000970                          1450mm      
00000970  B43C 001B               1451mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000974  6700 F692               1452mm     BEQ START
00000978                          1453mm     ENDM
00000978                          1454m CONTINUE_92
00000978  1639 00D30013           1455m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000097E  0803 0000               1456m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000982  67D8                    1457m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
00000984                          1458m     
00000984  1439 00D30017           1459m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000098A  13C2 00E00001           1460m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000990                          1461m     
00000990                          1462m     ENDM
00000990                          1463m         PRINT_CHAR D2,D3
00000990                          1464m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000990                 TRUE     1465m     IFEQ DEBUG
00000990  1639 00D30003           1466m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000996  0803 0002               1467m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000099A  67F4                    1468m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
0000099C  13C2 00D30007           1469m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000009A2                          1470m     ENDC
000009A2                          1471m     
000009A2                 FALSE    1472m     IFNE DEBUG
000009A2                          1473m     ENDC
000009A2                          1474m 
000009A2                          1475m     ENDM
000009A2                          1476m         HEX2BIN D2,D2,A0
000009A2  41F9 0000189D           1477m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000009A8  0402 0030               1478m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009AC  C4BC 000000FF           1479m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009B2  1430 2000               1480m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009B6                          1481m   ENDM
000009B6  8E82                    1482          OR.L D2,D7
000009B8  E98F                    1483          LSL.L #4,D7
000009BA                          1484               
000009BA                          1485m         DOWNLOAD D2,D3            ; LS 4 bits    
000009BA                          1486m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BA                          1487m 
000009BA  1639 00D30003           1488m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000009C0  0803 0000               1489m     BTST #0,D3                    ; CHECK FOR CHARACTER
000009C4  6700 0010               1490m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
000009C8                          1491m  
000009C8                          1492mm     READ_CHAR D2
000009C8                 TRUE     1493mm     IFEQ DEBUG
000009C8  1439 00D30007           1494mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000009CE                          1495mm     ENDC
000009CE                 FALSE    1496mm     IFNE DEBUG
000009CE                          1497mm     ENDC
000009CE                          1498mm      
000009CE  B43C 001B               1499mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000009D2  6700 F634               1500mm     BEQ START
000009D6                          1501mm     ENDM
000009D6                          1502m CONTINUE_96
000009D6  1639 00D30013           1503m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000009DC  0803 0000               1504m     BTST #0,D3                  ; CHECK FOR CHARACTER
000009E0  67D8                    1505m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
000009E2                          1506m     
000009E2  1439 00D30017           1507m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000009E8  13C2 00E00001           1508m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009EE                          1509m     
000009EE                          1510m     ENDM
000009EE                          1511m         PRINT_CHAR D2,D3
000009EE                          1512m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EE                 TRUE     1513m     IFEQ DEBUG
000009EE  1639 00D30003           1514m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009F4  0803 0002               1515m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009F8  67F4                    1516m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
000009FA  13C2 00D30007           1517m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A00                          1518m     ENDC
00000A00                          1519m     
00000A00                 FALSE    1520m     IFNE DEBUG
00000A00                          1521m     ENDC
00000A00                          1522m 
00000A00                          1523m     ENDM
00000A00                          1524m         HEX2BIN D2,D2,A0
00000A00  41F9 0000189D           1525m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A06  0402 0030               1526m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A0A  C4BC 000000FF           1527m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A10  1430 2000               1528m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A14                          1529m   ENDM
00000A14  8E82                    1530          OR.L D2,D7
00000A16                          1531                          
00000A16  DC87                    1532          ADD.L D7,D6               ; add into checksum
00000A18                          1533                        
00000A18  3611                    1534          MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00000A1A                          1535          
00000A1A  0243 FF00               1536          ANDI.W #$FF00,D3
00000A1E  8647                    1537          OR.W D7,D3
00000A20                          1538          
00000A20  3283                    1539          MOVE.W D3,(A1)           ; store it!
00000A22  5489                    1540          ADD.L #2,A1
00000A24                          1541  EVEN        
00000A24                          1542          WHILE.L D5 <GE> #2 DO       ; read the data bytes
00000A24                          1543s _10000002
00000A24  BABC 00000002           1544s     CMP.L   #2,D5
00000A2A  6D00 018A               1545s     BLT _10000003
00000A2E  5585                    1546              SUB.L #2,D5
00000A30  7E00                    1547              MOVE.L #0,D7              ; D7 holds the word
00000A32                          1548              
00000A32                          1549m             DOWNLOAD D2,D3            ; MS 4 bits
00000A32                          1550m WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A32                          1551m 
00000A32  1639 00D30003           1552m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A38  0803 0000               1553m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A3C  6700 0010               1554m     BEQ CONTINUE_100                ; NOTHING, CONTINUE
00000A40                          1555m  
00000A40                          1556mm     READ_CHAR D2
00000A40                 TRUE     1557mm     IFEQ DEBUG
00000A40  1439 00D30007           1558mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A46                          1559mm     ENDC
00000A46                 FALSE    1560mm     IFNE DEBUG
00000A46                          1561mm     ENDC
00000A46                          1562mm      
00000A46  B43C 001B               1563mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A4A  6700 F5BC               1564mm     BEQ START
00000A4E                          1565mm     ENDM
00000A4E                          1566m CONTINUE_100
00000A4E  1639 00D30013           1567m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A54  0803 0000               1568m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A58  67D8                    1569m     BEQ WAIT_FOR_READY_100        ; NOTHING, CHECK AGAIN
00000A5A                          1570m     
00000A5A  1439 00D30017           1571m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A60  13C2 00E00001           1572m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000A66                          1573m     
00000A66                          1574m     ENDM
00000A66                          1575m             PRINT_CHAR D2,D3
00000A66                          1576m WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                 TRUE     1577m     IFEQ DEBUG
00000A66  1639 00D30003           1578m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A6C  0803 0002               1579m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A70  67F4                    1580m       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00000A72  13C2 00D30007           1581m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A78                          1582m     ENDC
00000A78                          1583m     
00000A78                 FALSE    1584m     IFNE DEBUG
00000A78                          1585m     ENDC
00000A78                          1586m 
00000A78                          1587m     ENDM
00000A78                          1588m             HEX2BIN D2,D2,A0
00000A78  41F9 0000189D           1589m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A7E  0402 0030               1590m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A82  C4BC 000000FF           1591m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A88  1430 2000               1592m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A8C                          1593m   ENDM
00000A8C  8E82                    1594              OR.L D2,D7
00000A8E  E98F                    1595              LSL.L #4,D7
00000A90                          1596               
00000A90                          1597m             DOWNLOAD D2,D3            ; LS 4 bits    
00000A90                          1598m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A90                          1599m 
00000A90  1639 00D30003           1600m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A96  0803 0000               1601m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A9A  6700 0010               1602m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00000A9E                          1603m  
00000A9E                          1604mm     READ_CHAR D2
00000A9E                 TRUE     1605mm     IFEQ DEBUG
00000A9E  1439 00D30007           1606mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AA4                          1607mm     ENDC
00000AA4                 FALSE    1608mm     IFNE DEBUG
00000AA4                          1609mm     ENDC
00000AA4                          1610mm      
00000AA4  B43C 001B               1611mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AA8  6700 F55E               1612mm     BEQ START
00000AAC                          1613mm     ENDM
00000AAC                          1614m CONTINUE_104
00000AAC  1639 00D30013           1615m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000AB2  0803 0000               1616m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000AB6  67D8                    1617m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00000AB8                          1618m     
00000AB8  1439 00D30017           1619m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000ABE  13C2 00E00001           1620m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000AC4                          1621m     
00000AC4                          1622m     ENDM
00000AC4                          1623m             PRINT_CHAR D2,D3
00000AC4                          1624m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC4                 TRUE     1625m     IFEQ DEBUG
00000AC4  1639 00D30003           1626m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000ACA  0803 0002               1627m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000ACE  67F4                    1628m       BEQ WAIT_FOR_READY_106          ; NO SPACE, CHECK AGAIN
00000AD0  13C2 00D30007           1629m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000AD6                          1630m     ENDC
00000AD6                          1631m     
00000AD6                 FALSE    1632m     IFNE DEBUG
00000AD6                          1633m     ENDC
00000AD6                          1634m 
00000AD6                          1635m     ENDM
00000AD6                          1636m             HEX2BIN D2,D2,A0
00000AD6  41F9 0000189D           1637m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000ADC  0402 0030               1638m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AE0  C4BC 000000FF           1639m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000AE6  1430 2000               1640m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000AEA                          1641m   ENDM
00000AEA  8E82                    1642              OR.L D2,D7
00000AEC                          1643                          
00000AEC  DC87                    1644              ADD.L D7,D6               ; add into checksum
00000AEE                          1645              
00000AEE  E98F                    1646              LSL.L #4,D7
00000AF0                          1647m             DOWNLOAD D2,D3            ; MS 4 bits
00000AF0                          1648m WAIT_FOR_READY_108                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                          1649m 
00000AF0  1639 00D30003           1650m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AF6  0803 0000               1651m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AFA  6700 0010               1652m     BEQ CONTINUE_108                ; NOTHING, CONTINUE
00000AFE                          1653m  
00000AFE                          1654mm     READ_CHAR D2
00000AFE                 TRUE     1655mm     IFEQ DEBUG
00000AFE  1439 00D30007           1656mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B04                          1657mm     ENDC
00000B04                 FALSE    1658mm     IFNE DEBUG
00000B04                          1659mm     ENDC
00000B04                          1660mm      
00000B04  B43C 001B               1661mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B08  6700 F4FE               1662mm     BEQ START
00000B0C                          1663mm     ENDM
00000B0C                          1664m CONTINUE_108
00000B0C  1639 00D30013           1665m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B12  0803 0000               1666m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B16  67D8                    1667m     BEQ WAIT_FOR_READY_108        ; NOTHING, CHECK AGAIN
00000B18                          1668m     
00000B18  1439 00D30017           1669m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B1E  13C2 00E00001           1670m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B24                          1671m     
00000B24                          1672m     ENDM
00000B24                          1673m             PRINT_CHAR D2,D3
00000B24                          1674m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B24                 TRUE     1675m     IFEQ DEBUG
00000B24  1639 00D30003           1676m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000B2A  0803 0002               1677m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000B2E  67F4                    1678m       BEQ WAIT_FOR_READY_110          ; NO SPACE, CHECK AGAIN
00000B30  13C2 00D30007           1679m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000B36                          1680m     ENDC
00000B36                          1681m     
00000B36                 FALSE    1682m     IFNE DEBUG
00000B36                          1683m     ENDC
00000B36                          1684m 
00000B36                          1685m     ENDM
00000B36                          1686m             HEX2BIN D2,D2,A0
00000B36  41F9 0000189D           1687m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B3C  0402 0030               1688m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B40  C4BC 000000FF           1689m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B46  1430 2000               1690m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B4A                          1691m   ENDM
00000B4A  8E82                    1692              OR.L D2,D7
00000B4C                          1693               
00000B4C  E98F                    1694              LSL.L #4,D7
00000B4E                          1695m             DOWNLOAD D2,D3            ; LS 4 bits    
00000B4E                          1696m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4E                          1697m 
00000B4E  1639 00D30003           1698m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B54  0803 0000               1699m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B58  6700 0010               1700m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00000B5C                          1701m  
00000B5C                          1702mm     READ_CHAR D2
00000B5C                 TRUE     1703mm     IFEQ DEBUG
00000B5C  1439 00D30007           1704mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B62                          1705mm     ENDC
00000B62                 FALSE    1706mm     IFNE DEBUG
00000B62                          1707mm     ENDC
00000B62                          1708mm      
00000B62  B43C 001B               1709mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B66  6700 F4A0               1710mm     BEQ START
00000B6A                          1711mm     ENDM
00000B6A                          1712m CONTINUE_112
00000B6A  1639 00D30013           1713m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B70  0803 0000               1714m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B74  67D8                    1715m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00000B76                          1716m     
00000B76  1439 00D30017           1717m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B7C  13C2 00E00001           1718m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B82                          1719m     
00000B82                          1720m     ENDM
00000B82                          1721m             PRINT_CHAR D2,D3
00000B82                          1722m WAIT_FOR_READY_114                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B82                 TRUE     1723m     IFEQ DEBUG
00000B82  1639 00D30003           1724m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000B88  0803 0002               1725m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000B8C  67F4                    1726m       BEQ WAIT_FOR_READY_114          ; NO SPACE, CHECK AGAIN
00000B8E  13C2 00D30007           1727m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000B94                          1728m     ENDC
00000B94                          1729m     
00000B94                 FALSE    1730m     IFNE DEBUG
00000B94                          1731m     ENDC
00000B94                          1732m 
00000B94                          1733m     ENDM
00000B94                          1734m             HEX2BIN D2,D2,A0
00000B94  41F9 0000189D           1735m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B9A  0402 0030               1736m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B9E  C4BC 000000FF           1737m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000BA4  1430 2000               1738m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BA8                          1739m   ENDM
00000BA8  8E82                    1740              OR.L D2,D7
00000BAA                          1741              
00000BAA  7400                    1742              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00000BAC  1407                    1743              MOVE.B D7,D2
00000BAE  DC82                    1744              ADD.L D2,D6
00000BB0                          1745              
00000BB0  32C7                    1746              MOVE.W D7,(A1)+          ; store it!
00000BB2                          1747          ENDW
00000BB2  6000 FE70               1748s     BRA _10000002
00000BB6                          1749s _10000003
00000BB6                          1750          
00000BB6                          1751          IF D5 <EQ> #1 THEN
00000BB6  BA7C 0001               1752s     CMP.W   #1,D5
00000BBA  6600 00CE               1753s     BNE _00000003
00000BBE  7E00                    1754              MOVE.L #0,D7              ; D7 holds the word
00000BC0                          1755                      
00000BC0                          1756m             DOWNLOAD D2,D3            ; MS 4 bits
00000BC0                          1757m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC0                          1758m 
00000BC0  1639 00D30003           1759m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000BC6  0803 0000               1760m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000BCA  6700 0010               1761m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00000BCE                          1762m  
00000BCE                          1763mm     READ_CHAR D2
00000BCE                 TRUE     1764mm     IFEQ DEBUG
00000BCE  1439 00D30007           1765mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000BD4                          1766mm     ENDC
00000BD4                 FALSE    1767mm     IFNE DEBUG
00000BD4                          1768mm     ENDC
00000BD4                          1769mm      
00000BD4  B43C 001B               1770mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BD8  6700 F42E               1771mm     BEQ START
00000BDC                          1772mm     ENDM
00000BDC                          1773m CONTINUE_116
00000BDC  1639 00D30013           1774m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BE2  0803 0000               1775m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BE6  67D8                    1776m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00000BE8                          1777m     
00000BE8  1439 00D30017           1778m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BEE  13C2 00E00001           1779m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000BF4                          1780m     
00000BF4                          1781m     ENDM
00000BF4                          1782m             PRINT_CHAR D2,D3
00000BF4                          1783m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF4                 TRUE     1784m     IFEQ DEBUG
00000BF4  1639 00D30003           1785m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000BFA  0803 0002               1786m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000BFE  67F4                    1787m       BEQ WAIT_FOR_READY_118          ; NO SPACE, CHECK AGAIN
00000C00  13C2 00D30007           1788m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C06                          1789m     ENDC
00000C06                          1790m     
00000C06                 FALSE    1791m     IFNE DEBUG
00000C06                          1792m     ENDC
00000C06                          1793m 
00000C06                          1794m     ENDM
00000C06                          1795m             HEX2BIN D2,D2,A0
00000C06  41F9 0000189D           1796m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C0C  0402 0030               1797m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C10  C4BC 000000FF           1798m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C16  1430 2000               1799m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C1A                          1800m   ENDM
00000C1A  8E82                    1801              OR.L D2,D7
00000C1C  E98F                    1802              LSL.L #4,D7
00000C1E                          1803               
00000C1E                          1804m             DOWNLOAD D2,D3            ; LS 4 bits    
00000C1E                          1805m WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1E                          1806m 
00000C1E  1639 00D30003           1807m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000C24  0803 0000               1808m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000C28  6700 0010               1809m     BEQ CONTINUE_120                ; NOTHING, CONTINUE
00000C2C                          1810m  
00000C2C                          1811mm     READ_CHAR D2
00000C2C                 TRUE     1812mm     IFEQ DEBUG
00000C2C  1439 00D30007           1813mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000C32                          1814mm     ENDC
00000C32                 FALSE    1815mm     IFNE DEBUG
00000C32                          1816mm     ENDC
00000C32                          1817mm      
00000C32  B43C 001B               1818mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000C36  6700 F3D0               1819mm     BEQ START
00000C3A                          1820mm     ENDM
00000C3A                          1821m CONTINUE_120
00000C3A  1639 00D30013           1822m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000C40  0803 0000               1823m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000C44  67D8                    1824m     BEQ WAIT_FOR_READY_120        ; NOTHING, CHECK AGAIN
00000C46                          1825m     
00000C46  1439 00D30017           1826m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000C4C  13C2 00E00001           1827m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000C52                          1828m     
00000C52                          1829m     ENDM
00000C52                          1830m             PRINT_CHAR D2,D3
00000C52                          1831m WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C52                 TRUE     1832m     IFEQ DEBUG
00000C52  1639 00D30003           1833m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C58  0803 0002               1834m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C5C  67F4                    1835m       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00000C5E  13C2 00D30007           1836m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C64                          1837m     ENDC
00000C64                          1838m     
00000C64                 FALSE    1839m     IFNE DEBUG
00000C64                          1840m     ENDC
00000C64                          1841m 
00000C64                          1842m     ENDM
00000C64                          1843m             HEX2BIN D2,D2,A0
00000C64  41F9 0000189D           1844m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C6A  0402 0030               1845m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C6E  C4BC 000000FF           1846m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C74  1430 2000               1847m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C78                          1848m   ENDM
00000C78  8E82                    1849              OR.L D2,D7
00000C7A                          1850                          
00000C7A  DC87                    1851              ADD.L D7,D6               ; add into checksum
00000C7C                          1852              
00000C7C  3611                    1853              MOVE.W (A1),D3            ; get the current data and replace the top byte
00000C7E  E18F                    1854              LSL.L #8,D7
00000C80  C6BC 000000FF           1855              AND.L #$00FF,D3
00000C86  8687                    1856              OR.L D7,D3
00000C88                          1857  
00000C88  32C3                    1858              MOVE.W D3,(A1)+          ; store it!
00000C8A                          1859          ENDI
00000C8A                          1860s _00000003
00000C8A                          1861    
00000C8A                          1862m         PRINT_CRLF D3
00000C8A                          1863mm     PRINT_CHAR #13,D3             ; CR
00000C8A                          1864mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8A                 TRUE     1865mm     IFEQ DEBUG
00000C8A  1639 00D30003           1866mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C90  0803 0002               1867mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C94  67F4                    1868mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00000C96  13FC 000D 00D30007      1869mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C9E                          1870mm     ENDC
00000C9E                          1871mm     
00000C9E                 FALSE    1872mm     IFNE DEBUG
00000C9E                          1873mm     ENDC
00000C9E                          1874mm 
00000C9E                          1875mm     ENDM
00000C9E                          1876mm     PRINT_CHAR #10,D3             ; LF
00000C9E                          1877mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9E                 TRUE     1878mm     IFEQ DEBUG
00000C9E  1639 00D30003           1879mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000CA4  0803 0002               1880mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000CA8  67F4                    1881mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00000CAA  13FC 000A 00D30007      1882mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000CB2                          1883mm     ENDC
00000CB2                          1884mm     
00000CB2                 FALSE    1885mm     IFNE DEBUG
00000CB2                          1886mm     ENDC
00000CB2                          1887mm 
00000CB2                          1888mm     ENDM
00000CB2                          1889m     ENDM
00000CB2  43F8 0486               1890          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00000CB6                          1891        ELSE
00000CB6  6000 072C               1892s     BRA _00000004
00000CBA                          1893s _00000002
00000CBA                          1894          IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00000CBA  BE3C 0032               1895s     CMP.B   #'2',D7
00000CBE  6600 04D8               1896s     BNE.L   _00000005
00000CC2  7E00                    1897            MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000CC4                          1898m           DOWNLOAD D2,D3              ; top byte
00000CC4                          1899m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CC4                          1900m 
00000CC4  1639 00D30003           1901m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CCA  0803 0000               1902m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CCE  6700 0010               1903m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00000CD2                          1904m  
00000CD2                          1905mm     READ_CHAR D2
00000CD2                 TRUE     1906mm     IFEQ DEBUG
00000CD2  1439 00D30007           1907mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CD8                          1908mm     ENDC
00000CD8                 FALSE    1909mm     IFNE DEBUG
00000CD8                          1910mm     ENDC
00000CD8                          1911mm      
00000CD8  B43C 001B               1912mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CDC  6700 F32A               1913mm     BEQ START
00000CE0                          1914mm     ENDM
00000CE0                          1915m CONTINUE_127
00000CE0  1639 00D30013           1916m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000CE6  0803 0000               1917m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000CEA  67D8                    1918m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00000CEC                          1919m     
00000CEC  1439 00D30017           1920m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000CF2  13C2 00E00001           1921m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000CF8                          1922m     
00000CF8                          1923m     ENDM
00000CF8                          1924m           PRINT_CHAR D2,D3
00000CF8                          1925m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF8                 TRUE     1926m     IFEQ DEBUG
00000CF8  1639 00D30003           1927m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000CFE  0803 0002               1928m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D02  67F4                    1929m       BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00000D04  13C2 00D30007           1930m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D0A                          1931m     ENDC
00000D0A                          1932m     
00000D0A                 FALSE    1933m     IFNE DEBUG
00000D0A                          1934m     ENDC
00000D0A                          1935m 
00000D0A                          1936m     ENDM
00000D0A                          1937m           HEX2BIN D2,D2,A0
00000D0A  41F9 0000189D           1938m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D10  0402 0030               1939m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D14  C4BC 000000FF           1940m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D1A  1430 2000               1941m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D1E                          1942m   ENDM
00000D1E  8E82                    1943            OR.L D2,D7
00000D20  E98F                    1944            LSL.L #4,D7
00000D22                          1945m           DOWNLOAD D2,D3         
00000D22                          1946m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D22                          1947m 
00000D22  1639 00D30003           1948m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000D28  0803 0000               1949m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000D2C  6700 0010               1950m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00000D30                          1951m  
00000D30                          1952mm     READ_CHAR D2
00000D30                 TRUE     1953mm     IFEQ DEBUG
00000D30  1439 00D30007           1954mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000D36                          1955mm     ENDC
00000D36                 FALSE    1956mm     IFNE DEBUG
00000D36                          1957mm     ENDC
00000D36                          1958mm      
00000D36  B43C 001B               1959mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000D3A  6700 F2CC               1960mm     BEQ START
00000D3E                          1961mm     ENDM
00000D3E                          1962m CONTINUE_131
00000D3E  1639 00D30013           1963m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000D44  0803 0000               1964m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000D48  67D8                    1965m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00000D4A                          1966m     
00000D4A  1439 00D30017           1967m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000D50  13C2 00E00001           1968m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000D56                          1969m     
00000D56                          1970m     ENDM
00000D56                          1971m           PRINT_CHAR D2,D3
00000D56                          1972m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D56                 TRUE     1973m     IFEQ DEBUG
00000D56  1639 00D30003           1974m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D5C  0803 0002               1975m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D60  67F4                    1976m       BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00000D62  13C2 00D30007           1977m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D68                          1978m     ENDC
00000D68                          1979m     
00000D68                 FALSE    1980m     IFNE DEBUG
00000D68                          1981m     ENDC
00000D68                          1982m 
00000D68                          1983m     ENDM
00000D68                          1984m           HEX2BIN D2,D2,A0
00000D68  41F9 0000189D           1985m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D6E  0402 0030               1986m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D72  C4BC 000000FF           1987m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D78  1430 2000               1988m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D7C                          1989m   ENDM
00000D7C  8E82                    1990            OR.L D2,D7
00000D7E                          1991          
00000D7E  DC87                    1992            ADD.L D7,D6                 ; add top byte of address into checksum
00000D80                          1993  
00000D80  E98F                    1994            LSL.L #4,D7                 ; middle byte
00000D82                          1995m           DOWNLOAD D2,D3
00000D82                          1996m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D82                          1997m 
00000D82  1639 00D30003           1998m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000D88  0803 0000               1999m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000D8C  6700 0010               2000m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00000D90                          2001m  
00000D90                          2002mm     READ_CHAR D2
00000D90                 TRUE     2003mm     IFEQ DEBUG
00000D90  1439 00D30007           2004mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000D96                          2005mm     ENDC
00000D96                 FALSE    2006mm     IFNE DEBUG
00000D96                          2007mm     ENDC
00000D96                          2008mm      
00000D96  B43C 001B               2009mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000D9A  6700 F26C               2010mm     BEQ START
00000D9E                          2011mm     ENDM
00000D9E                          2012m CONTINUE_135
00000D9E  1639 00D30013           2013m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000DA4  0803 0000               2014m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000DA8  67D8                    2015m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00000DAA                          2016m     
00000DAA  1439 00D30017           2017m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000DB0  13C2 00E00001           2018m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000DB6                          2019m     
00000DB6                          2020m     ENDM
00000DB6                          2021m           PRINT_CHAR D2,D3
00000DB6                          2022m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB6                 TRUE     2023m     IFEQ DEBUG
00000DB6  1639 00D30003           2024m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DBC  0803 0002               2025m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DC0  67F4                    2026m       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00000DC2  13C2 00D30007           2027m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DC8                          2028m     ENDC
00000DC8                          2029m     
00000DC8                 FALSE    2030m     IFNE DEBUG
00000DC8                          2031m     ENDC
00000DC8                          2032m 
00000DC8                          2033m     ENDM
00000DC8                          2034m           HEX2BIN D2,D2,A0
00000DC8  41F9 0000189D           2035m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000DCE  0402 0030               2036m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DD2  C4BC 000000FF           2037m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000DD8  1430 2000               2038m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000DDC                          2039m   ENDM
00000DDC  8E82                    2040            OR.L D2,D7
00000DDE  E98F                    2041            LSL.L #4,D7        
00000DE0                          2042m           DOWNLOAD D2,D3
00000DE0                          2043m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE0                          2044m 
00000DE0  1639 00D30003           2045m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000DE6  0803 0000               2046m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000DEA  6700 0010               2047m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00000DEE                          2048m  
00000DEE                          2049mm     READ_CHAR D2
00000DEE                 TRUE     2050mm     IFEQ DEBUG
00000DEE  1439 00D30007           2051mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000DF4                          2052mm     ENDC
00000DF4                 FALSE    2053mm     IFNE DEBUG
00000DF4                          2054mm     ENDC
00000DF4                          2055mm      
00000DF4  B43C 001B               2056mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000DF8  6700 F20E               2057mm     BEQ START
00000DFC                          2058mm     ENDM
00000DFC                          2059m CONTINUE_139
00000DFC  1639 00D30013           2060m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000E02  0803 0000               2061m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000E06  67D8                    2062m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00000E08                          2063m     
00000E08  1439 00D30017           2064m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000E0E  13C2 00E00001           2065m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000E14                          2066m     
00000E14                          2067m     ENDM
00000E14                          2068m           PRINT_CHAR D2,D3
00000E14                          2069m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E14                 TRUE     2070m     IFEQ DEBUG
00000E14  1639 00D30003           2071m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E1A  0803 0002               2072m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E1E  67F4                    2073m       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00000E20  13C2 00D30007           2074m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E26                          2075m     ENDC
00000E26                          2076m     
00000E26                 FALSE    2077m     IFNE DEBUG
00000E26                          2078m     ENDC
00000E26                          2079m 
00000E26                          2080m     ENDM
00000E26                          2081m           HEX2BIN D2,D2,A0
00000E26  41F9 0000189D           2082m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000E2C  0402 0030               2083m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E30  C4BC 000000FF           2084m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000E36  1430 2000               2085m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000E3A                          2086m   ENDM
00000E3A  8E82                    2087            OR.L D2,D7
00000E3C                          2088          
00000E3C  7400                    2089            MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00000E3E  1407                    2090            MOVE.B D7,D2
00000E40  DC82                    2091            ADD.L D2,D6
00000E42                          2092            
00000E42  E98F                    2093            LSL.L #4,D7                 ; bottom byte
00000E44                          2094m           DOWNLOAD D2,D3
00000E44                          2095m WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E44                          2096m 
00000E44  1639 00D30003           2097m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000E4A  0803 0000               2098m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000E4E  6700 0010               2099m     BEQ CONTINUE_143                ; NOTHING, CONTINUE
00000E52                          2100m  
00000E52                          2101mm     READ_CHAR D2
00000E52                 TRUE     2102mm     IFEQ DEBUG
00000E52  1439 00D30007           2103mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000E58                          2104mm     ENDC
00000E58                 FALSE    2105mm     IFNE DEBUG
00000E58                          2106mm     ENDC
00000E58                          2107mm      
00000E58  B43C 001B               2108mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000E5C  6700 F1AA               2109mm     BEQ START
00000E60                          2110mm     ENDM
00000E60                          2111m CONTINUE_143
00000E60  1639 00D30013           2112m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000E66  0803 0000               2113m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000E6A  67D8                    2114m     BEQ WAIT_FOR_READY_143        ; NOTHING, CHECK AGAIN
00000E6C                          2115m     
00000E6C  1439 00D30017           2116m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000E72  13C2 00E00001           2117m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000E78                          2118m     
00000E78                          2119m     ENDM
00000E78                          2120m           PRINT_CHAR D2,D3
00000E78                          2121m WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E78                 TRUE     2122m     IFEQ DEBUG
00000E78  1639 00D30003           2123m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E7E  0803 0002               2124m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E82  67F4                    2125m       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00000E84  13C2 00D30007           2126m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E8A                          2127m     ENDC
00000E8A                          2128m     
00000E8A                 FALSE    2129m     IFNE DEBUG
00000E8A                          2130m     ENDC
00000E8A                          2131m 
00000E8A                          2132m     ENDM
00000E8A                          2133m           HEX2BIN D2,D2,A0
00000E8A  41F9 0000189D           2134m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000E90  0402 0030               2135m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E94  C4BC 000000FF           2136m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000E9A  1430 2000               2137m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000E9E                          2138m   ENDM
00000E9E  8E82                    2139            OR.L D2,D7
00000EA0  E98F                    2140            LSL.L #4,D7        
00000EA2                          2141m           DOWNLOAD D2,D3
00000EA2                          2142m WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA2                          2143m 
00000EA2  1639 00D30003           2144m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000EA8  0803 0000               2145m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000EAC  6700 0010               2146m     BEQ CONTINUE_147                ; NOTHING, CONTINUE
00000EB0                          2147m  
00000EB0                          2148mm     READ_CHAR D2
00000EB0                 TRUE     2149mm     IFEQ DEBUG
00000EB0  1439 00D30007           2150mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000EB6                          2151mm     ENDC
00000EB6                 FALSE    2152mm     IFNE DEBUG
00000EB6                          2153mm     ENDC
00000EB6                          2154mm      
00000EB6  B43C 001B               2155mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000EBA  6700 F14C               2156mm     BEQ START
00000EBE                          2157mm     ENDM
00000EBE                          2158m CONTINUE_147
00000EBE  1639 00D30013           2159m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000EC4  0803 0000               2160m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000EC8  67D8                    2161m     BEQ WAIT_FOR_READY_147        ; NOTHING, CHECK AGAIN
00000ECA                          2162m     
00000ECA  1439 00D30017           2163m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000ED0  13C2 00E00001           2164m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000ED6                          2165m     
00000ED6                          2166m     ENDM
00000ED6                          2167m           PRINT_CHAR D2,D3
00000ED6                          2168m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ED6                 TRUE     2169m     IFEQ DEBUG
00000ED6  1639 00D30003           2170m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EDC  0803 0002               2171m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EE0  67F4                    2172m       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00000EE2  13C2 00D30007           2173m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000EE8                          2174m     ENDC
00000EE8                          2175m     
00000EE8                 FALSE    2176m     IFNE DEBUG
00000EE8                          2177m     ENDC
00000EE8                          2178m 
00000EE8                          2179m     ENDM
00000EE8                          2180m           HEX2BIN D2,D2,A0
00000EE8  41F9 0000189D           2181m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000EEE  0402 0030               2182m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EF2  C4BC 000000FF           2183m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000EF8  1430 2000               2184m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000EFC                          2185m   ENDM
00000EFC  8E82                    2186            OR.L D2,D7
00000EFE                          2187          
00000EFE  7400                    2188            MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000F00  1407                    2189            MOVE.B D7,D2
00000F02  DC82                    2190            ADD.L D2,D6
00000F04                          2191          
00000F04  2247                    2192            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000F06  D3CB                    2193            ADD.L A3,A1                 ; add in the offset
00000F08                          2194                  
00000F08  5985                    2195            SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00000F0A                          2196            WHILE.L D5 <GE> #2 DO       ; read the data bytes
00000F0A                          2197s _10000004
00000F0A  BABC 00000002           2198s     CMP.L   #2,D5
00000F10  6D00 018A               2199s     BLT _10000005
00000F14  5585                    2200              SUB.L #2,D5
00000F16                          2201              
00000F16  7E00                    2202              MOVE.L #0,D7              ; D7 holds the word
00000F18                          2203              
00000F18                          2204m             DOWNLOAD D2,D3            ; MS 4 bits
00000F18                          2205m WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F18                          2206m 
00000F18  1639 00D30003           2207m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000F1E  0803 0000               2208m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000F22  6700 0010               2209m     BEQ CONTINUE_151                ; NOTHING, CONTINUE
00000F26                          2210m  
00000F26                          2211mm     READ_CHAR D2
00000F26                 TRUE     2212mm     IFEQ DEBUG
00000F26  1439 00D30007           2213mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000F2C                          2214mm     ENDC
00000F2C                 FALSE    2215mm     IFNE DEBUG
00000F2C                          2216mm     ENDC
00000F2C                          2217mm      
00000F2C  B43C 001B               2218mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000F30  6700 F0D6               2219mm     BEQ START
00000F34                          2220mm     ENDM
00000F34                          2221m CONTINUE_151
00000F34  1639 00D30013           2222m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000F3A  0803 0000               2223m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000F3E  67D8                    2224m     BEQ WAIT_FOR_READY_151        ; NOTHING, CHECK AGAIN
00000F40                          2225m     
00000F40  1439 00D30017           2226m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000F46  13C2 00E00001           2227m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000F4C                          2228m     
00000F4C                          2229m     ENDM
00000F4C                          2230m             PRINT_CHAR D2,D3
00000F4C                          2231m WAIT_FOR_READY_153                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F4C                 TRUE     2232m     IFEQ DEBUG
00000F4C  1639 00D30003           2233m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000F52  0803 0002               2234m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000F56  67F4                    2235m       BEQ WAIT_FOR_READY_153          ; NO SPACE, CHECK AGAIN
00000F58  13C2 00D30007           2236m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000F5E                          2237m     ENDC
00000F5E                          2238m     
00000F5E                 FALSE    2239m     IFNE DEBUG
00000F5E                          2240m     ENDC
00000F5E                          2241m 
00000F5E                          2242m     ENDM
00000F5E                          2243m             HEX2BIN D2,D2,A0
00000F5E  41F9 0000189D           2244m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000F64  0402 0030               2245m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F68  C4BC 000000FF           2246m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000F6E  1430 2000               2247m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000F72                          2248m   ENDM
00000F72  8E82                    2249              OR.L D2,D7
00000F74  E98F                    2250              LSL.L #4,D7
00000F76                          2251               
00000F76                          2252m             DOWNLOAD D2,D3            ; LS 4 bits    
00000F76                          2253m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F76                          2254m 
00000F76  1639 00D30003           2255m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000F7C  0803 0000               2256m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000F80  6700 0010               2257m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00000F84                          2258m  
00000F84                          2259mm     READ_CHAR D2
00000F84                 TRUE     2260mm     IFEQ DEBUG
00000F84  1439 00D30007           2261mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000F8A                          2262mm     ENDC
00000F8A                 FALSE    2263mm     IFNE DEBUG
00000F8A                          2264mm     ENDC
00000F8A                          2265mm      
00000F8A  B43C 001B               2266mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000F8E  6700 F078               2267mm     BEQ START
00000F92                          2268mm     ENDM
00000F92                          2269m CONTINUE_155
00000F92  1639 00D30013           2270m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000F98  0803 0000               2271m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000F9C  67D8                    2272m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00000F9E                          2273m     
00000F9E  1439 00D30017           2274m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000FA4  13C2 00E00001           2275m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000FAA                          2276m     
00000FAA                          2277m     ENDM
00000FAA                          2278m             PRINT_CHAR D2,D3
00000FAA                          2279m WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FAA                 TRUE     2280m     IFEQ DEBUG
00000FAA  1639 00D30003           2281m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000FB0  0803 0002               2282m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000FB4  67F4                    2283m       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00000FB6  13C2 00D30007           2284m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000FBC                          2285m     ENDC
00000FBC                          2286m     
00000FBC                 FALSE    2287m     IFNE DEBUG
00000FBC                          2288m     ENDC
00000FBC                          2289m 
00000FBC                          2290m     ENDM
00000FBC                          2291m             HEX2BIN D2,D2,A0
00000FBC  41F9 0000189D           2292m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000FC2  0402 0030               2293m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FC6  C4BC 000000FF           2294m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000FCC  1430 2000               2295m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000FD0                          2296m   ENDM
00000FD0  8E82                    2297              OR.L D2,D7
00000FD2                          2298                          
00000FD2  DC87                    2299              ADD.L D7,D6               ; add into checksum
00000FD4                          2300              
00000FD4  E98F                    2301              LSL.L #4,D7
00000FD6                          2302m             DOWNLOAD D2,D3            ; MS 4 bits
00000FD6                          2303m WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD6                          2304m 
00000FD6  1639 00D30003           2305m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000FDC  0803 0000               2306m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000FE0  6700 0010               2307m     BEQ CONTINUE_159                ; NOTHING, CONTINUE
00000FE4                          2308m  
00000FE4                          2309mm     READ_CHAR D2
00000FE4                 TRUE     2310mm     IFEQ DEBUG
00000FE4  1439 00D30007           2311mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000FEA                          2312mm     ENDC
00000FEA                 FALSE    2313mm     IFNE DEBUG
00000FEA                          2314mm     ENDC
00000FEA                          2315mm      
00000FEA  B43C 001B               2316mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000FEE  6700 F018               2317mm     BEQ START
00000FF2                          2318mm     ENDM
00000FF2                          2319m CONTINUE_159
00000FF2  1639 00D30013           2320m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000FF8  0803 0000               2321m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000FFC  67D8                    2322m     BEQ WAIT_FOR_READY_159        ; NOTHING, CHECK AGAIN
00000FFE                          2323m     
00000FFE  1439 00D30017           2324m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001004  13C2 00E00001           2325m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000100A                          2326m     
0000100A                          2327m     ENDM
0000100A                          2328m             PRINT_CHAR D2,D3
0000100A                          2329m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100A                 TRUE     2330m     IFEQ DEBUG
0000100A  1639 00D30003           2331m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001010  0803 0002               2332m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001014  67F4                    2333m       BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
00001016  13C2 00D30007           2334m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000101C                          2335m     ENDC
0000101C                          2336m     
0000101C                 FALSE    2337m     IFNE DEBUG
0000101C                          2338m     ENDC
0000101C                          2339m 
0000101C                          2340m     ENDM
0000101C                          2341m             HEX2BIN D2,D2,A0
0000101C  41F9 0000189D           2342m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001022  0402 0030               2343m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001026  C4BC 000000FF           2344m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000102C  1430 2000               2345m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001030                          2346m   ENDM
00001030  8E82                    2347              OR.L D2,D7
00001032                          2348               
00001032  E98F                    2349              LSL.L #4,D7
00001034                          2350m             DOWNLOAD D2,D3            ; LS 4 bits    
00001034                          2351m WAIT_FOR_READY_163                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001034                          2352m 
00001034  1639 00D30003           2353m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000103A  0803 0000               2354m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000103E  6700 0010               2355m     BEQ CONTINUE_163                ; NOTHING, CONTINUE
00001042                          2356m  
00001042                          2357mm     READ_CHAR D2
00001042                 TRUE     2358mm     IFEQ DEBUG
00001042  1439 00D30007           2359mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001048                          2360mm     ENDC
00001048                 FALSE    2361mm     IFNE DEBUG
00001048                          2362mm     ENDC
00001048                          2363mm      
00001048  B43C 001B               2364mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000104C  6700 EFBA               2365mm     BEQ START
00001050                          2366mm     ENDM
00001050                          2367m CONTINUE_163
00001050  1639 00D30013           2368m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001056  0803 0000               2369m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000105A  67D8                    2370m     BEQ WAIT_FOR_READY_163        ; NOTHING, CHECK AGAIN
0000105C                          2371m     
0000105C  1439 00D30017           2372m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001062  13C2 00E00001           2373m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001068                          2374m     
00001068                          2375m     ENDM
00001068                          2376m             PRINT_CHAR D2,D3
00001068                          2377m WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001068                 TRUE     2378m     IFEQ DEBUG
00001068  1639 00D30003           2379m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000106E  0803 0002               2380m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001072  67F4                    2381m       BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
00001074  13C2 00D30007           2382m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000107A                          2383m     ENDC
0000107A                          2384m     
0000107A                 FALSE    2385m     IFNE DEBUG
0000107A                          2386m     ENDC
0000107A                          2387m 
0000107A                          2388m     ENDM
0000107A                          2389m             HEX2BIN D2,D2,A0
0000107A  41F9 0000189D           2390m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001080  0402 0030               2391m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001084  C4BC 000000FF           2392m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000108A  1430 2000               2393m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000108E                          2394m   ENDM
0000108E  8E82                    2395              OR.L D2,D7
00001090                          2396              
00001090  7400                    2397              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00001092  1407                    2398              MOVE.B D7,D2
00001094  DC82                    2399              ADD.L D2,D6
00001096                          2400              
00001096  32C7                    2401              MOVE.W D7,(A1)+             ; store it!
00001098                          2402              
00001098                          2403            ENDW
00001098  6000 FE70               2404s     BRA _10000004
0000109C                          2405s _10000005
0000109C                          2406            
0000109C                          2407              
0000109C                          2408            IF D5 <EQ> #1 THEN
0000109C  BA7C 0001               2409s     CMP.W   #1,D5
000010A0  6600 00C6               2410s     BNE _00000006
000010A4  7E00                    2411              MOVE.L #0,D7              ; D7 holds the word
000010A6                          2412                      
000010A6                          2413m             DOWNLOAD D2,D3            ; MS 4 bits
000010A6                          2414m WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A6                          2415m 
000010A6  1639 00D30003           2416m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000010AC  0803 0000               2417m     BTST #0,D3                    ; CHECK FOR CHARACTER
000010B0  6700 0010               2418m     BEQ CONTINUE_167                ; NOTHING, CONTINUE
000010B4                          2419m  
000010B4                          2420mm     READ_CHAR D2
000010B4                 TRUE     2421mm     IFEQ DEBUG
000010B4  1439 00D30007           2422mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000010BA                          2423mm     ENDC
000010BA                 FALSE    2424mm     IFNE DEBUG
000010BA                          2425mm     ENDC
000010BA                          2426mm      
000010BA  B43C 001B               2427mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000010BE  6700 EF48               2428mm     BEQ START
000010C2                          2429mm     ENDM
000010C2                          2430m CONTINUE_167
000010C2  1639 00D30013           2431m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000010C8  0803 0000               2432m     BTST #0,D3                  ; CHECK FOR CHARACTER
000010CC  67D8                    2433m     BEQ WAIT_FOR_READY_167        ; NOTHING, CHECK AGAIN
000010CE                          2434m     
000010CE  1439 00D30017           2435m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000010D4  13C2 00E00001           2436m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000010DA                          2437m     
000010DA                          2438m     ENDM
000010DA                          2439m             PRINT_CHAR D2,D3
000010DA                          2440m WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010DA                 TRUE     2441m     IFEQ DEBUG
000010DA  1639 00D30003           2442m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000010E0  0803 0002               2443m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000010E4  67F4                    2444m       BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
000010E6  13C2 00D30007           2445m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000010EC                          2446m     ENDC
000010EC                          2447m     
000010EC                 FALSE    2448m     IFNE DEBUG
000010EC                          2449m     ENDC
000010EC                          2450m 
000010EC                          2451m     ENDM
000010EC                          2452m             HEX2BIN D2,D2,A0
000010EC  41F9 0000189D           2453m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000010F2  0402 0030               2454m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010F6  C4BC 000000FF           2455m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000010FC  1430 2000               2456m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001100                          2457m   ENDM
00001100  8E82                    2458              OR.L D2,D7
00001102  E98F                    2459              LSL.L #4,D7
00001104                          2460               
00001104                          2461m             DOWNLOAD D2,D3            ; LS 4 bits    
00001104                          2462m WAIT_FOR_READY_171                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001104                          2463m 
00001104  1639 00D30003           2464m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000110A  0803 0000               2465m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000110E  6700 0010               2466m     BEQ CONTINUE_171                ; NOTHING, CONTINUE
00001112                          2467m  
00001112                          2468mm     READ_CHAR D2
00001112                 TRUE     2469mm     IFEQ DEBUG
00001112  1439 00D30007           2470mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001118                          2471mm     ENDC
00001118                 FALSE    2472mm     IFNE DEBUG
00001118                          2473mm     ENDC
00001118                          2474mm      
00001118  B43C 001B               2475mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000111C  6700 EEEA               2476mm     BEQ START
00001120                          2477mm     ENDM
00001120                          2478m CONTINUE_171
00001120  1639 00D30013           2479m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001126  0803 0000               2480m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000112A  67D8                    2481m     BEQ WAIT_FOR_READY_171        ; NOTHING, CHECK AGAIN
0000112C                          2482m     
0000112C  1439 00D30017           2483m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001132  13C2 00E00001           2484m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001138                          2485m     
00001138                          2486m     ENDM
00001138                          2487m             PRINT_CHAR D2,D3
00001138                          2488m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001138                 TRUE     2489m     IFEQ DEBUG
00001138  1639 00D30003           2490m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000113E  0803 0002               2491m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001142  67F4                    2492m       BEQ WAIT_FOR_READY_173          ; NO SPACE, CHECK AGAIN
00001144  13C2 00D30007           2493m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000114A                          2494m     ENDC
0000114A                          2495m     
0000114A                 FALSE    2496m     IFNE DEBUG
0000114A                          2497m     ENDC
0000114A                          2498m 
0000114A                          2499m     ENDM
0000114A                          2500m             HEX2BIN D2,D2,A0
0000114A  41F9 0000189D           2501m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001150  0402 0030               2502m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001154  C4BC 000000FF           2503m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000115A  1430 2000               2504m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000115E                          2505m   ENDM
0000115E  8E82                    2506              OR.L D2,D7
00001160                          2507                          
00001160  DC87                    2508              ADD.L D7,D6               ; add into checksum
00001162                          2509              
00001162  3283                    2510              MOVE.W D3,(A1)            ; get the current data and replace the bottom byte
00001164  1602                    2511              MOVE.B D2,D3
00001166                          2512  
00001166  32C3                    2513              MOVE.W D3,(A1)+           ; store it!
00001168                          2514            ENDI
00001168                          2515s _00000006
00001168                          2516m           PRINT_CRLF D3
00001168                          2517mm     PRINT_CHAR #13,D3             ; CR
00001168                          2518mm WAIT_FOR_READY_176                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001168                 TRUE     2519mm     IFEQ DEBUG
00001168  1639 00D30003           2520mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000116E  0803 0002               2521mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001172  67F4                    2522mm       BEQ WAIT_FOR_READY_176          ; NO SPACE, CHECK AGAIN
00001174  13FC 000D 00D30007      2523mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000117C                          2524mm     ENDC
0000117C                          2525mm     
0000117C                 FALSE    2526mm     IFNE DEBUG
0000117C                          2527mm     ENDC
0000117C                          2528mm 
0000117C                          2529mm     ENDM
0000117C                          2530mm     PRINT_CHAR #10,D3             ; LF
0000117C                          2531mm WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000117C                 TRUE     2532mm     IFEQ DEBUG
0000117C  1639 00D30003           2533mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001182  0803 0002               2534mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001186  67F4                    2535mm       BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
00001188  13FC 000A 00D30007      2536mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001190                          2537mm     ENDC
00001190                          2538mm     
00001190                 FALSE    2539mm     IFNE DEBUG
00001190                          2540mm     ENDC
00001190                          2541mm 
00001190                          2542mm     ENDM
00001190                          2543m     ENDM
00001190  43F8 0486               2544            LEA WAIT_FOR_SRECORD,A1     ; next place to go
00001194                          2545          ELSE
00001194  6000 024E               2546s     BRA _00000007
00001198                          2547s _00000005
00001198                          2548            IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00001198  BE3C 0038               2549s     CMP.B   #'8',D7
0000119C  6600 01E4               2550s     BNE.L   _00000008
000011A0  7E00                    2551              MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000011A2                          2552m             DOWNLOAD D2,D3            ; top byte
000011A2                          2553m WAIT_FOR_READY_178                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011A2                          2554m 
000011A2  1639 00D30003           2555m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000011A8  0803 0000               2556m     BTST #0,D3                    ; CHECK FOR CHARACTER
000011AC  6700 0010               2557m     BEQ CONTINUE_178                ; NOTHING, CONTINUE
000011B0                          2558m  
000011B0                          2559mm     READ_CHAR D2
000011B0                 TRUE     2560mm     IFEQ DEBUG
000011B0  1439 00D30007           2561mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000011B6                          2562mm     ENDC
000011B6                 FALSE    2563mm     IFNE DEBUG
000011B6                          2564mm     ENDC
000011B6                          2565mm      
000011B6  B43C 001B               2566mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000011BA  6700 EE4C               2567mm     BEQ START
000011BE                          2568mm     ENDM
000011BE                          2569m CONTINUE_178
000011BE  1639 00D30013           2570m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000011C4  0803 0000               2571m     BTST #0,D3                  ; CHECK FOR CHARACTER
000011C8  67D8                    2572m     BEQ WAIT_FOR_READY_178        ; NOTHING, CHECK AGAIN
000011CA                          2573m     
000011CA  1439 00D30017           2574m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000011D0  13C2 00E00001           2575m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000011D6                          2576m     
000011D6                          2577m     ENDM
000011D6                          2578m             HEX2BIN D2,D2,A0
000011D6  41F9 0000189D           2579m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000011DC  0402 0030               2580m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000011E0  C4BC 000000FF           2581m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000011E6  1430 2000               2582m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000011EA                          2583m   ENDM
000011EA  8E82                    2584              OR.L D2,D7
000011EC  E98F                    2585              LSL.L #4,D7
000011EE                          2586m             DOWNLOAD D2,D3         
000011EE                          2587m WAIT_FOR_READY_181                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EE                          2588m 
000011EE  1639 00D30003           2589m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000011F4  0803 0000               2590m     BTST #0,D3                    ; CHECK FOR CHARACTER
000011F8  6700 0010               2591m     BEQ CONTINUE_181                ; NOTHING, CONTINUE
000011FC                          2592m  
000011FC                          2593mm     READ_CHAR D2
000011FC                 TRUE     2594mm     IFEQ DEBUG
000011FC  1439 00D30007           2595mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001202                          2596mm     ENDC
00001202                 FALSE    2597mm     IFNE DEBUG
00001202                          2598mm     ENDC
00001202                          2599mm      
00001202  B43C 001B               2600mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001206  6700 EE00               2601mm     BEQ START
0000120A                          2602mm     ENDM
0000120A                          2603m CONTINUE_181
0000120A  1639 00D30013           2604m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001210  0803 0000               2605m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001214  67D8                    2606m     BEQ WAIT_FOR_READY_181        ; NOTHING, CHECK AGAIN
00001216                          2607m     
00001216  1439 00D30017           2608m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000121C  13C2 00E00001           2609m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001222                          2610m     
00001222                          2611m     ENDM
00001222                          2612m             HEX2BIN D2,D2,A0
00001222  41F9 0000189D           2613m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001228  0402 0030               2614m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000122C  C4BC 000000FF           2615m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001232  1430 2000               2616m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001236                          2617m   ENDM
00001236  8E82                    2618              OR.L D2,D7
00001238                          2619          
00001238  DC87                    2620              ADD.L D7,D6               ; add top byte of address into checksum
0000123A                          2621  
0000123A  E98F                    2622              LSL.L #4,D7               ; middle byte
0000123C                          2623m             DOWNLOAD D2,D3
0000123C                          2624m WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000123C                          2625m 
0000123C  1639 00D30003           2626m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001242  0803 0000               2627m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001246  6700 0010               2628m     BEQ CONTINUE_184                ; NOTHING, CONTINUE
0000124A                          2629m  
0000124A                          2630mm     READ_CHAR D2
0000124A                 TRUE     2631mm     IFEQ DEBUG
0000124A  1439 00D30007           2632mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001250                          2633mm     ENDC
00001250                 FALSE    2634mm     IFNE DEBUG
00001250                          2635mm     ENDC
00001250                          2636mm      
00001250  B43C 001B               2637mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001254  6700 EDB2               2638mm     BEQ START
00001258                          2639mm     ENDM
00001258                          2640m CONTINUE_184
00001258  1639 00D30013           2641m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000125E  0803 0000               2642m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001262  67D8                    2643m     BEQ WAIT_FOR_READY_184        ; NOTHING, CHECK AGAIN
00001264                          2644m     
00001264  1439 00D30017           2645m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000126A  13C2 00E00001           2646m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001270                          2647m     
00001270                          2648m     ENDM
00001270                          2649m             HEX2BIN D2,D2,A0
00001270  41F9 0000189D           2650m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001276  0402 0030               2651m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000127A  C4BC 000000FF           2652m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001280  1430 2000               2653m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001284                          2654m   ENDM
00001284  8E82                    2655              OR.L D2,D7
00001286  E98F                    2656              LSL.L #4,D7        
00001288                          2657m             DOWNLOAD D2,D3
00001288                          2658m WAIT_FOR_READY_187                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001288                          2659m 
00001288  1639 00D30003           2660m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000128E  0803 0000               2661m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001292  6700 0010               2662m     BEQ CONTINUE_187                ; NOTHING, CONTINUE
00001296                          2663m  
00001296                          2664mm     READ_CHAR D2
00001296                 TRUE     2665mm     IFEQ DEBUG
00001296  1439 00D30007           2666mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000129C                          2667mm     ENDC
0000129C                 FALSE    2668mm     IFNE DEBUG
0000129C                          2669mm     ENDC
0000129C                          2670mm      
0000129C  B43C 001B               2671mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000012A0  6700 ED66               2672mm     BEQ START
000012A4                          2673mm     ENDM
000012A4                          2674m CONTINUE_187
000012A4  1639 00D30013           2675m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000012AA  0803 0000               2676m     BTST #0,D3                  ; CHECK FOR CHARACTER
000012AE  67D8                    2677m     BEQ WAIT_FOR_READY_187        ; NOTHING, CHECK AGAIN
000012B0                          2678m     
000012B0  1439 00D30017           2679m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000012B6  13C2 00E00001           2680m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000012BC                          2681m     
000012BC                          2682m     ENDM
000012BC                          2683m             HEX2BIN D2,D2,A0
000012BC  41F9 0000189D           2684m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000012C2  0402 0030               2685m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012C6  C4BC 000000FF           2686m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000012CC  1430 2000               2687m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000012D0                          2688m   ENDM
000012D0  8E82                    2689              OR.L D2,D7
000012D2                          2690          
000012D2  7400                    2691              MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
000012D4  1407                    2692              MOVE.B D7,D2
000012D6  DC82                    2693              ADD.L D2,D6
000012D8                          2694            
000012D8  E98F                    2695              LSL.L #4,D7               ; bottom byte
000012DA                          2696m             DOWNLOAD D2,D3
000012DA                          2697m WAIT_FOR_READY_190                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DA                          2698m 
000012DA  1639 00D30003           2699m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000012E0  0803 0000               2700m     BTST #0,D3                    ; CHECK FOR CHARACTER
000012E4  6700 0010               2701m     BEQ CONTINUE_190                ; NOTHING, CONTINUE
000012E8                          2702m  
000012E8                          2703mm     READ_CHAR D2
000012E8                 TRUE     2704mm     IFEQ DEBUG
000012E8  1439 00D30007           2705mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000012EE                          2706mm     ENDC
000012EE                 FALSE    2707mm     IFNE DEBUG
000012EE                          2708mm     ENDC
000012EE                          2709mm      
000012EE  B43C 001B               2710mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000012F2  6700 ED14               2711mm     BEQ START
000012F6                          2712mm     ENDM
000012F6                          2713m CONTINUE_190
000012F6  1639 00D30013           2714m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000012FC  0803 0000               2715m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001300  67D8                    2716m     BEQ WAIT_FOR_READY_190        ; NOTHING, CHECK AGAIN
00001302                          2717m     
00001302  1439 00D30017           2718m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001308  13C2 00E00001           2719m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000130E                          2720m     
0000130E                          2721m     ENDM
0000130E                          2722m             HEX2BIN D2,D2,A0
0000130E  41F9 0000189D           2723m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001314  0402 0030               2724m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001318  C4BC 000000FF           2725m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000131E  1430 2000               2726m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001322                          2727m   ENDM
00001322  8E82                    2728              OR.L D2,D7
00001324  E98F                    2729              LSL.L #4,D7        
00001326                          2730m             DOWNLOAD D2,D3
00001326                          2731m WAIT_FOR_READY_193                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001326                          2732m 
00001326  1639 00D30003           2733m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000132C  0803 0000               2734m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001330  6700 0010               2735m     BEQ CONTINUE_193                ; NOTHING, CONTINUE
00001334                          2736m  
00001334                          2737mm     READ_CHAR D2
00001334                 TRUE     2738mm     IFEQ DEBUG
00001334  1439 00D30007           2739mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000133A                          2740mm     ENDC
0000133A                 FALSE    2741mm     IFNE DEBUG
0000133A                          2742mm     ENDC
0000133A                          2743mm      
0000133A  B43C 001B               2744mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000133E  6700 ECC8               2745mm     BEQ START
00001342                          2746mm     ENDM
00001342                          2747m CONTINUE_193
00001342  1639 00D30013           2748m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001348  0803 0000               2749m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000134C  67D8                    2750m     BEQ WAIT_FOR_READY_193        ; NOTHING, CHECK AGAIN
0000134E                          2751m     
0000134E  1439 00D30017           2752m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001354  13C2 00E00001           2753m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000135A                          2754m     
0000135A                          2755m     ENDM
0000135A                          2756m             HEX2BIN D2,D2,A0
0000135A  41F9 0000189D           2757m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001360  0402 0030               2758m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001364  C4BC 000000FF           2759m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000136A  1430 2000               2760m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000136E                          2761m   ENDM
0000136E  8E82                    2762              OR.L D2,D7
00001370                          2763          
00001370  7400                    2764              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00001372  1407                    2765              MOVE.B D7,D2
00001374  DC82                    2766              ADD.L D2,D6
00001376                          2767            
00001376  2447                    2768              MOVE.L D7,A2              ; start address -> A2
00001378                          2769          
00001378  43F9 00001530           2770              LEA DOWNLOAD_DONE,A1      ; next place to go
0000137E                          2771            ELSE
0000137E  6000 0064               2772s     BRA _00000009
00001382                          2773s _00000008
00001382  41F9 00001829           2774              LEA UNREC,A0              ; warn for unrecognised type
00001388                          2775m             PRINT_STR A0,D3
00001388                          2776m LOOP_196
00001388  0C10 0000               2777m     CMP.B #0,(A0)                 ; 0 -> DONE
0000138C  6700 0018               2778m     BEQ EXIT_196
00001390                          2779mm     PRINT_CHAR (A0)+,D3
00001390                          2780mm WAIT_FOR_READY_197                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001390                 TRUE     2781mm     IFEQ DEBUG
00001390  1639 00D30003           2782mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001396  0803 0002               2783mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000139A  67F4                    2784mm       BEQ WAIT_FOR_READY_197          ; NO SPACE, CHECK AGAIN
0000139C  13D8 00D30007           2785mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000013A2                          2786mm     ENDC
000013A2                          2787mm     
000013A2                 FALSE    2788mm     IFNE DEBUG
000013A2                          2789mm     ENDC
000013A2                          2790mm 
000013A2                          2791mm     ENDM
000013A2  4EF8 1388               2792m     JMP LOOP_196
000013A6                          2793m EXIT_196
000013A6                          2794m     ENDM
000013A6                          2795m             PRINT_CHAR D7,D3
000013A6                          2796m WAIT_FOR_READY_198                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013A6                 TRUE     2797m     IFEQ DEBUG
000013A6  1639 00D30003           2798m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000013AC  0803 0002               2799m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000013B0  67F4                    2800m       BEQ WAIT_FOR_READY_198          ; NO SPACE, CHECK AGAIN
000013B2  13C7 00D30007           2801m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
000013B8                          2802m     ENDC
000013B8                          2803m     
000013B8                 FALSE    2804m     IFNE DEBUG
000013B8                          2805m     ENDC
000013B8                          2806m 
000013B8                          2807m     ENDM
000013B8                          2808m             PRINT_CRLF D3
000013B8                          2809mm     PRINT_CHAR #13,D3             ; CR
000013B8                          2810mm WAIT_FOR_READY_200                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013B8                 TRUE     2811mm     IFEQ DEBUG
000013B8  1639 00D30003           2812mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000013BE  0803 0002               2813mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000013C2  67F4                    2814mm       BEQ WAIT_FOR_READY_200          ; NO SPACE, CHECK AGAIN
000013C4  13FC 000D 00D30007      2815mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000013CC                          2816mm     ENDC
000013CC                          2817mm     
000013CC                 FALSE    2818mm     IFNE DEBUG
000013CC                          2819mm     ENDC
000013CC                          2820mm 
000013CC                          2821mm     ENDM
000013CC                          2822mm     PRINT_CHAR #10,D3             ; LF
000013CC                          2823mm WAIT_FOR_READY_201                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013CC                 TRUE     2824mm     IFEQ DEBUG
000013CC  1639 00D30003           2825mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000013D2  0803 0002               2826mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000013D6  67F4                    2827mm       BEQ WAIT_FOR_READY_201          ; NO SPACE, CHECK AGAIN
000013D8  13FC 000A 00D30007      2828mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000013E0                          2829mm     ENDC
000013E0                          2830mm     
000013E0                 FALSE    2831mm     IFNE DEBUG
000013E0                          2832mm     ENDC
000013E0                          2833mm 
000013E0                          2834mm     ENDM
000013E0                          2835m     ENDM
000013E0                          2836      
000013E0  4EF8 0486               2837              JMP WAIT_FOR_SRECORD      ; ignore any other type    
000013E4                          2838            ENDI
000013E4                          2839s _00000009
000013E4                          2840          ENDI
000013E4                          2841s _00000007
000013E4                          2842        ENDI
000013E4                          2843s _00000004
000013E4                          2844      ENDI
000013E4                          2845s _00000001
000013E4                          2846      
000013E4  4686                    2847      NOT.L D6                        ; ones complement the checksum
000013E6  0286 000000FF           2848      ANDI.L #$FF,D6                  ; and take the LSByte
000013EC                          2849          
000013EC  7E00                    2850      MOVE.L #0,D7                    ; read the checksum from the data stream
000013EE                          2851m     DOWNLOAD D2,D3                  ; top byte
000013EE                          2852m WAIT_FOR_READY_202                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013EE                          2853m 
000013EE  1639 00D30003           2854m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000013F4  0803 0000               2855m     BTST #0,D3                    ; CHECK FOR CHARACTER
000013F8  6700 0010               2856m     BEQ CONTINUE_202                ; NOTHING, CONTINUE
000013FC                          2857m  
000013FC                          2858mm     READ_CHAR D2
000013FC                 TRUE     2859mm     IFEQ DEBUG
000013FC  1439 00D30007           2860mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001402                          2861mm     ENDC
00001402                 FALSE    2862mm     IFNE DEBUG
00001402                          2863mm     ENDC
00001402                          2864mm      
00001402  B43C 001B               2865mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001406  6700 EC00               2866mm     BEQ START
0000140A                          2867mm     ENDM
0000140A                          2868m CONTINUE_202
0000140A  1639 00D30013           2869m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001410  0803 0000               2870m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001414  67D8                    2871m     BEQ WAIT_FOR_READY_202        ; NOTHING, CHECK AGAIN
00001416                          2872m     
00001416  1439 00D30017           2873m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000141C  13C2 00E00001           2874m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001422                          2875m     
00001422                          2876m     ENDM
00001422                          2877m     HEX2BIN D2,D2,A0
00001422  41F9 0000189D           2878m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001428  0402 0030               2879m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000142C  C4BC 000000FF           2880m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001432  1430 2000               2881m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001436                          2882m   ENDM
00001436  8E82                    2883      OR.L D2,D7
00001438  E98F                    2884      LSL.L #4,D7
0000143A                          2885m     DOWNLOAD D2,D3                  ; bottom byte
0000143A                          2886m WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000143A                          2887m 
0000143A  1639 00D30003           2888m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001440  0803 0000               2889m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001444  6700 0010               2890m     BEQ CONTINUE_205                ; NOTHING, CONTINUE
00001448                          2891m  
00001448                          2892mm     READ_CHAR D2
00001448                 TRUE     2893mm     IFEQ DEBUG
00001448  1439 00D30007           2894mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000144E                          2895mm     ENDC
0000144E                 FALSE    2896mm     IFNE DEBUG
0000144E                          2897mm     ENDC
0000144E                          2898mm      
0000144E  B43C 001B               2899mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001452  6700 EBB4               2900mm     BEQ START
00001456                          2901mm     ENDM
00001456                          2902m CONTINUE_205
00001456  1639 00D30013           2903m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000145C  0803 0000               2904m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001460  67D8                    2905m     BEQ WAIT_FOR_READY_205        ; NOTHING, CHECK AGAIN
00001462                          2906m     
00001462  1439 00D30017           2907m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001468  13C2 00E00001           2908m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000146E                          2909m     
0000146E                          2910m     ENDM
0000146E                          2911m     HEX2BIN D2,D2,A0
0000146E  41F9 0000189D           2912m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001474  0402 0030               2913m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001478  C4BC 000000FF           2914m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000147E  1430 2000               2915m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001482                          2916m   ENDM
00001482  8E82                    2917      OR.L D2,D7
00001484                          2918                  
00001484                          2919      IF.B D7 <NE> D6 THEN.L
00001484  BE06                    2920s     CMP.B   D6,D7
00001486  6700 00A6               2921s     BEQ.L   _0000000A
0000148A  41F9 0000184F           2922        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00001490                          2923m       PRINT_STR A0,D3
00001490                          2924m LOOP_208
00001490  0C10 0000               2925m     CMP.B #0,(A0)                 ; 0 -> DONE
00001494  6700 0018               2926m     BEQ EXIT_208
00001498                          2927mm     PRINT_CHAR (A0)+,D3
00001498                          2928mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001498                 TRUE     2929mm     IFEQ DEBUG
00001498  1639 00D30003           2930mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000149E  0803 0002               2931mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014A2  67F4                    2932mm       BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
000014A4  13D8 00D30007           2933mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000014AA                          2934mm     ENDC
000014AA                          2935mm     
000014AA                 FALSE    2936mm     IFNE DEBUG
000014AA                          2937mm     ENDC
000014AA                          2938mm 
000014AA                          2939mm     ENDM
000014AA  4EF8 1490               2940m     JMP LOOP_208
000014AE                          2941m EXIT_208
000014AE                          2942m     ENDM
000014AE                          2943m       PRINT_REG D4,D3,D6,D7,A0
000014AE                          2944mm     PRINT_CHAR #'0',D3          ;0X HEADER
000014AE                          2945mm WAIT_FOR_READY_211                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014AE                 TRUE     2946mm     IFEQ DEBUG
000014AE  1639 00D30003           2947mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000014B4  0803 0002               2948mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014B8  67F4                    2949mm       BEQ WAIT_FOR_READY_211          ; NO SPACE, CHECK AGAIN
000014BA  13FC 0030 00D30007      2950mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000014C2                          2951mm     ENDC
000014C2                          2952mm     
000014C2                 FALSE    2953mm     IFNE DEBUG
000014C2                          2954mm     ENDC
000014C2                          2955mm 
000014C2                          2956mm     ENDM
000014C2                          2957mm     PRINT_CHAR #'x',D3
000014C2                          2958mm WAIT_FOR_READY_212                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014C2                 TRUE     2959mm     IFEQ DEBUG
000014C2  1639 00D30003           2960mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000014C8  0803 0002               2961mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014CC  67F4                    2962mm       BEQ WAIT_FOR_READY_212          ; NO SPACE, CHECK AGAIN
000014CE  13FC 0078 00D30007      2963mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000014D6                          2964mm     ENDC
000014D6                          2965mm     
000014D6                 FALSE    2966mm     IFNE DEBUG
000014D6                          2967mm     ENDC
000014D6                          2968mm 
000014D6                          2969mm     ENDM
000014D6  7E07                    2970m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014D8                          2971m LOOP_210
000014D8                          2972mm     BIN2HEX D4,D6,A0
000014D8  41F9 0000188D           2973mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
000014DE  E99C                    2974mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014E0  1C04                    2975mm   MOVE.B D4,D6
000014E2  0286 0000000F           2976mm   ANDI.L #$F,D6
000014E8  1C30 6000               2977mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
000014EC                          2978mm   ENDM
000014EC                          2979mm     PRINT_CHAR D6,D3
000014EC                          2980mm WAIT_FOR_READY_214                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014EC                 TRUE     2981mm     IFEQ DEBUG
000014EC  1639 00D30003           2982mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000014F2  0803 0002               2983mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014F6  67F4                    2984mm       BEQ WAIT_FOR_READY_214          ; NO SPACE, CHECK AGAIN
000014F8  13C6 00D30007           2985mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
000014FE                          2986mm     ENDC
000014FE                          2987mm     
000014FE                 FALSE    2988mm     IFNE DEBUG
000014FE                          2989mm     ENDC
000014FE                          2990mm 
000014FE                          2991mm     ENDM
000014FE  57CF FFD8               2992m     DBEQ D7,LOOP_210
00001502                          2993m     ENDM
00001502                          2994m       PRINT_CRLF D3
00001502                          2995mm     PRINT_CHAR #13,D3             ; CR
00001502                          2996mm WAIT_FOR_READY_216                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001502                 TRUE     2997mm     IFEQ DEBUG
00001502  1639 00D30003           2998mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001508  0803 0002               2999mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000150C  67F4                    3000mm       BEQ WAIT_FOR_READY_216          ; NO SPACE, CHECK AGAIN
0000150E  13FC 000D 00D30007      3001mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00001516                          3002mm     ENDC
00001516                          3003mm     
00001516                 FALSE    3004mm     IFNE DEBUG
00001516                          3005mm     ENDC
00001516                          3006mm 
00001516                          3007mm     ENDM
00001516                          3008mm     PRINT_CHAR #10,D3             ; LF
00001516                          3009mm WAIT_FOR_READY_217                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001516                 TRUE     3010mm     IFEQ DEBUG
00001516  1639 00D30003           3011mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000151C  0803 0002               3012mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001520  67F4                    3013mm       BEQ WAIT_FOR_READY_217          ; NO SPACE, CHECK AGAIN
00001522  13FC 000A 00D30007      3014mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000152A                          3015mm     ENDC
0000152A                          3016mm     
0000152A                 FALSE    3017mm     IFNE DEBUG
0000152A                          3018mm     ENDC
0000152A                          3019mm 
0000152A                          3020mm     ENDM
0000152A                          3021m     ENDM
0000152A  6000 EC5A               3022        BRA MAIN_LOOP
0000152E                          3023      ENDI
0000152E                          3024s _0000000A
0000152E                          3025      
0000152E  4ED1                    3026      JMP (A1)
00001530                          3027  DOWNLOAD_DONE
00001530                          3028m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00001530                          3029mm     PRINT_CHAR #'0',D3          ;0X HEADER
00001530                          3030mm WAIT_FOR_READY_219                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001530                 TRUE     3031mm     IFEQ DEBUG
00001530  1639 00D30003           3032mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001536  0803 0002               3033mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000153A  67F4                    3034mm       BEQ WAIT_FOR_READY_219          ; NO SPACE, CHECK AGAIN
0000153C  13FC 0030 00D30007      3035mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00001544                          3036mm     ENDC
00001544                          3037mm     
00001544                 FALSE    3038mm     IFNE DEBUG
00001544                          3039mm     ENDC
00001544                          3040mm 
00001544                          3041mm     ENDM
00001544                          3042mm     PRINT_CHAR #'x',D3
00001544                          3043mm WAIT_FOR_READY_220                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001544                 TRUE     3044mm     IFEQ DEBUG
00001544  1639 00D30003           3045mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000154A  0803 0002               3046mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000154E  67F4                    3047mm       BEQ WAIT_FOR_READY_220          ; NO SPACE, CHECK AGAIN
00001550  13FC 0078 00D30007      3048mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00001558                          3049mm     ENDC
00001558                          3050mm     
00001558                 FALSE    3051mm     IFNE DEBUG
00001558                          3052mm     ENDC
00001558                          3053mm 
00001558                          3054mm     ENDM
00001558  7C07                    3055m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000155A                          3056m LOOP_218
0000155A                          3057mm     BIN2HEX D4,D7,A0
0000155A  41F9 0000188D           3058mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00001560  E99C                    3059mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001562  1E04                    3060mm   MOVE.B D4,D7
00001564  0287 0000000F           3061mm   ANDI.L #$F,D7
0000156A  1E30 7000               3062mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0000156E                          3063mm   ENDM
0000156E                          3064mm     PRINT_CHAR D7,D3
0000156E                          3065mm WAIT_FOR_READY_222                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000156E                 TRUE     3066mm     IFEQ DEBUG
0000156E  1639 00D30003           3067mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001574  0803 0002               3068mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001578  67F4                    3069mm       BEQ WAIT_FOR_READY_222          ; NO SPACE, CHECK AGAIN
0000157A  13C7 00D30007           3070mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00001580                          3071mm     ENDC
00001580                          3072mm     
00001580                 FALSE    3073mm     IFNE DEBUG
00001580                          3074mm     ENDC
00001580                          3075mm 
00001580                          3076mm     ENDM
00001580  57CE FFD8               3077m     DBEQ D6,LOOP_218
00001584                          3078m     ENDM
00001584  41F9 00001807           3079      LEA READ,A0
0000158A                          3080m     PRINT_STR A0,D3
0000158A                          3081m LOOP_223
0000158A  0C10 0000               3082m     CMP.B #0,(A0)                 ; 0 -> DONE
0000158E  6700 0018               3083m     BEQ EXIT_223
00001592                          3084mm     PRINT_CHAR (A0)+,D3
00001592                          3085mm WAIT_FOR_READY_224                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001592                 TRUE     3086mm     IFEQ DEBUG
00001592  1639 00D30003           3087mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001598  0803 0002               3088mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000159C  67F4                    3089mm       BEQ WAIT_FOR_READY_224          ; NO SPACE, CHECK AGAIN
0000159E  13D8 00D30007           3090mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000015A4                          3091mm     ENDC
000015A4                          3092mm     
000015A4                 FALSE    3093mm     IFNE DEBUG
000015A4                          3094mm     ENDC
000015A4                          3095mm 
000015A4                          3096mm     ENDM
000015A4  4EF8 158A               3097m     JMP LOOP_223
000015A8                          3098m EXIT_223
000015A8                          3099m     ENDM
000015A8  2E0A                    3100      MOVE.L A2,D7                    ; set address accumulator to start address
000015AA                          3101m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
000015AA                          3102mm     PRINT_CHAR #'0',D3          ;0X HEADER
000015AA                          3103mm WAIT_FOR_READY_226                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015AA                 TRUE     3104mm     IFEQ DEBUG
000015AA  1639 00D30003           3105mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015B0  0803 0002               3106mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015B4  67F4                    3107mm       BEQ WAIT_FOR_READY_226          ; NO SPACE, CHECK AGAIN
000015B6  13FC 0030 00D30007      3108mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000015BE                          3109mm     ENDC
000015BE                          3110mm     
000015BE                 FALSE    3111mm     IFNE DEBUG
000015BE                          3112mm     ENDC
000015BE                          3113mm 
000015BE                          3114mm     ENDM
000015BE                          3115mm     PRINT_CHAR #'x',D3
000015BE                          3116mm WAIT_FOR_READY_227                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015BE                 TRUE     3117mm     IFEQ DEBUG
000015BE  1639 00D30003           3118mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015C4  0803 0002               3119mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015C8  67F4                    3120mm       BEQ WAIT_FOR_READY_227          ; NO SPACE, CHECK AGAIN
000015CA  13FC 0078 00D30007      3121mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000015D2                          3122mm     ENDC
000015D2                          3123mm     
000015D2                 FALSE    3124mm     IFNE DEBUG
000015D2                          3125mm     ENDC
000015D2                          3126mm 
000015D2                          3127mm     ENDM
000015D2  7C07                    3128m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000015D4                          3129m LOOP_225
000015D4                          3130mm     BIN2HEX D7,D2,A0
000015D4  41F9 0000188D           3131mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
000015DA  E99F                    3132mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000015DC  1407                    3133mm   MOVE.B D7,D2
000015DE  0282 0000000F           3134mm   ANDI.L #$F,D2
000015E4  1430 2000               3135mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
000015E8                          3136mm   ENDM
000015E8                          3137mm     PRINT_CHAR D2,D3
000015E8                          3138mm WAIT_FOR_READY_229                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015E8                 TRUE     3139mm     IFEQ DEBUG
000015E8  1639 00D30003           3140mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015EE  0803 0002               3141mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015F2  67F4                    3142mm       BEQ WAIT_FOR_READY_229          ; NO SPACE, CHECK AGAIN
000015F4  13C2 00D30007           3143mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000015FA                          3144mm     ENDC
000015FA                          3145mm     
000015FA                 FALSE    3146mm     IFNE DEBUG
000015FA                          3147mm     ENDC
000015FA                          3148mm 
000015FA                          3149mm     ENDM
000015FA  57CE FFD8               3150m     DBEQ D6,LOOP_225
000015FE                          3151m     ENDM
000015FE                          3152m     PRINT_CRLF D3     
000015FE                          3153mm     PRINT_CHAR #13,D3             ; CR
000015FE                          3154mm WAIT_FOR_READY_231                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015FE                 TRUE     3155mm     IFEQ DEBUG
000015FE  1639 00D30003           3156mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001604  0803 0002               3157mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001608  67F4                    3158mm       BEQ WAIT_FOR_READY_231          ; NO SPACE, CHECK AGAIN
0000160A  13FC 000D 00D30007      3159mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00001612                          3160mm     ENDC
00001612                          3161mm     
00001612                 FALSE    3162mm     IFNE DEBUG
00001612                          3163mm     ENDC
00001612                          3164mm 
00001612                          3165mm     ENDM
00001612                          3166mm     PRINT_CHAR #10,D3             ; LF
00001612                          3167mm WAIT_FOR_READY_232                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001612                 TRUE     3168mm     IFEQ DEBUG
00001612  1639 00D30003           3169mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001618  0803 0002               3170mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000161C  67F4                    3171mm       BEQ WAIT_FOR_READY_232          ; NO SPACE, CHECK AGAIN
0000161E  13FC 000A 00D30007      3172mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001626                          3173mm     ENDC
00001626                          3174mm     
00001626                 FALSE    3175mm     IFNE DEBUG
00001626                          3176mm     ENDC
00001626                          3177mm 
00001626                          3178mm     ENDM
00001626                          3179m     ENDM
00001626                          3180          
00001626  4EF8 0186               3181      JMP MAIN_LOOP
0000162A                          3182      
0000162A  2047                    3183  G   MOVE.L D7,A0                    ; address accumulator -> address register
0000162C  3E3C 0000               3184      MOVE #0,D7                      ; clear the now used address accumulator
00001630  4ED0                    3185      JMP (A0)                        ; jump to it!
00001632                          3186      
00001632  207C 00200000           3187  Z   MOVE.L #RAM,A0                  ; address of RAM
00001638  7000                    3188      MOVE.L #0,D0                    ; number of bytes
0000163A                          3189     
0000163A                          3190      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
0000163A                          3191s _10000006
0000163A  B0BC 00040000           3192s     CMP.L   #$40000,D0
00001640  6E00 001A               3193s     BGT _10000007
00001644                          3194         
00001644  2200                    3195        MOVE.L D0,D1                  ; progress update
00001646  E089                    3196        LSR.L #8,D1 
00001648  E089                    3197        LSR.L #8,D1
0000164A  0281 0000000F           3198        ANDI.L #$F,D1
00001650  13C1 00E00001           3199        MOVE.B D1,DISPLAY
00001656                          3200  
00001656  20C0                    3201        MOVE.L D0,(A0)+ 
00001658  5880                    3202        ADD.L #4,D0
0000165A                          3203      ENDW
0000165A  60DE                    3204s     BRA _10000006
0000165C                          3205s _10000007
0000165C                          3206   
0000165C  207C 00200000           3207      MOVE.L #RAM,A0              ; address of RAM
00001662  7000                    3208      MOVE.L #0,D0                ; number of bytes
00001664                          3209     
00001664                          3210      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00001664                          3211s _10000008
00001664  B0BC 00040000           3212s     CMP.L   #$40000,D0
0000166A  6E00 00CA               3213s     BGT _10000009
0000166E                          3214  
0000166E  2200                    3215        MOVE.L D0,D1              ; progress update
00001670  E089                    3216        LSR.L #8,D1
00001672  E089                    3217        LSR.L #8,D1
00001674  0281 0000000F           3218        ANDI.L #$F,D1
0000167A  13C1 00E00001           3219        MOVE.B D1,DISPLAY
00001680                          3220  
00001680  2218                    3221        MOVE.L (A0)+,D1
00001682                          3222        
00001682                          3223        IF.L D0 <EQ> D1 THEN
00001682  B081                    3224s     CMP.L   D1,D0
00001684  6600 0006               3225s     BNE _0000000B
00001688  6000 00A6               3226          BRA OK
0000168C                          3227        ENDI 
0000168C                          3228s _0000000B
0000168C                          3229        
0000168C  43F9 00001875           3230        LEA RAM_ERROR,A1
00001692                          3231m       PRINT_STR A1,D1
00001692                          3232m LOOP_233
00001692  0C11 0000               3233m     CMP.B #0,(A1)                 ; 0 -> DONE
00001696  6700 0018               3234m     BEQ EXIT_233
0000169A                          3235mm     PRINT_CHAR (A1)+,D1
0000169A                          3236mm WAIT_FOR_READY_234                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000169A                 TRUE     3237mm     IFEQ DEBUG
0000169A  1239 00D30003           3238mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
000016A0  0801 0002               3239mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
000016A4  67F4                    3240mm       BEQ WAIT_FOR_READY_234          ; NO SPACE, CHECK AGAIN
000016A6  13D9 00D30007           3241mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000016AC                          3242mm     ENDC
000016AC                          3243mm     
000016AC                 FALSE    3244mm     IFNE DEBUG
000016AC                          3245mm     ENDC
000016AC                          3246mm 
000016AC                          3247mm     ENDM
000016AC  4EF8 1692               3248m     JMP LOOP_233
000016B0                          3249m EXIT_233
000016B0                          3250m     ENDM
000016B0  2208                    3251        MOVE.L A0,D1
000016B2  5981                    3252        SUB.L #4,D1
000016B4                          3253m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
000016B4                          3254mm     PRINT_CHAR #'0',D3          ;0X HEADER
000016B4                          3255mm WAIT_FOR_READY_236                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016B4                 TRUE     3256mm     IFEQ DEBUG
000016B4  1639 00D30003           3257mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016BA  0803 0002               3258mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016BE  67F4                    3259mm       BEQ WAIT_FOR_READY_236          ; NO SPACE, CHECK AGAIN
000016C0  13FC 0030 00D30007      3260mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000016C8                          3261mm     ENDC
000016C8                          3262mm     
000016C8                 FALSE    3263mm     IFNE DEBUG
000016C8                          3264mm     ENDC
000016C8                          3265mm 
000016C8                          3266mm     ENDM
000016C8                          3267mm     PRINT_CHAR #'x',D3
000016C8                          3268mm WAIT_FOR_READY_237                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016C8                 TRUE     3269mm     IFEQ DEBUG
000016C8  1639 00D30003           3270mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016CE  0803 0002               3271mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016D2  67F4                    3272mm       BEQ WAIT_FOR_READY_237          ; NO SPACE, CHECK AGAIN
000016D4  13FC 0078 00D30007      3273mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000016DC                          3274mm     ENDC
000016DC                          3275mm     
000016DC                 FALSE    3276mm     IFNE DEBUG
000016DC                          3277mm     ENDC
000016DC                          3278mm 
000016DC                          3279mm     ENDM
000016DC  7C07                    3280m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000016DE                          3281m LOOP_235
000016DE                          3282mm     BIN2HEX D1,D2,A1
000016DE  43F9 0000188D           3283mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
000016E4  E999                    3284mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000016E6  1401                    3285mm   MOVE.B D1,D2
000016E8  0282 0000000F           3286mm   ANDI.L #$F,D2
000016EE  1431 2000               3287mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
000016F2                          3288mm   ENDM
000016F2                          3289mm     PRINT_CHAR D2,D3
000016F2                          3290mm WAIT_FOR_READY_239                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016F2                 TRUE     3291mm     IFEQ DEBUG
000016F2  1639 00D30003           3292mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016F8  0803 0002               3293mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016FC  67F4                    3294mm       BEQ WAIT_FOR_READY_239          ; NO SPACE, CHECK AGAIN
000016FE  13C2 00D30007           3295mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001704                          3296mm     ENDC
00001704                          3297mm     
00001704                 FALSE    3298mm     IFNE DEBUG
00001704                          3299mm     ENDC
00001704                          3300mm 
00001704                          3301mm     ENDM
00001704  57CE FFD8               3302m     DBEQ D6,LOOP_235
00001708                          3303m     ENDM
00001708                          3304m       PRINT_CRLF D3
00001708                          3305mm     PRINT_CHAR #13,D3             ; CR
00001708                          3306mm WAIT_FOR_READY_241                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001708                 TRUE     3307mm     IFEQ DEBUG
00001708  1639 00D30003           3308mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000170E  0803 0002               3309mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001712  67F4                    3310mm       BEQ WAIT_FOR_READY_241          ; NO SPACE, CHECK AGAIN
00001714  13FC 000D 00D30007      3311mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000171C                          3312mm     ENDC
0000171C                          3313mm     
0000171C                 FALSE    3314mm     IFNE DEBUG
0000171C                          3315mm     ENDC
0000171C                          3316mm 
0000171C                          3317mm     ENDM
0000171C                          3318mm     PRINT_CHAR #10,D3             ; LF
0000171C                          3319mm WAIT_FOR_READY_242                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000171C                 TRUE     3320mm     IFEQ DEBUG
0000171C  1639 00D30003           3321mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001722  0803 0002               3322mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001726  67F4                    3323mm       BEQ WAIT_FOR_READY_242          ; NO SPACE, CHECK AGAIN
00001728  13FC 000A 00D30007      3324mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001730                          3325mm     ENDC
00001730                          3326mm     
00001730                 FALSE    3327mm     IFNE DEBUG
00001730                          3328mm     ENDC
00001730                          3329mm 
00001730                          3330mm     ENDM
00001730                          3331m     ENDM
00001730                          3332  OK    
00001730  5880                    3333        ADD.L #4,D0
00001732                          3334      ENDW
00001732  6000 FF30               3335s     BRA _10000008
00001736                          3336s _10000009
00001736                          3337      
00001736  4EF8 0186               3338      JMP MAIN_LOOP
0000173A                          3339    
0000173A                          3340  HEX_DIGIT
0000173A  E98F                    3341      LSL.L #4,D7                    ; add the next digit in the next 4 bits
0000173C                          3342m     HEX2BIN D2,D2,A0
0000173C  41F9 0000189D           3343m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001742  0402 0030               3344m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001746  C4BC 000000FF           3345m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000174C  1430 2000               3346m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001750                          3347m   ENDM
00001750  8E02                    3348      OR.B D2,D7  
00001752  4EF8 01AE               3349      JMP GET_INPUT
00001756                          3350  
00001756  FFFF FFFF               3351      SIMHALT                         ; halt simulator
0000175A                          3352  
0000175A                          3353  ; strings
0000175A= 4D 44 46 2D 6D 6F ...   3354  VERSION DC.B 'MDF-mon V1.14 (05/04/2021)',13,10,0
00001777= 3F 20 48 65 6C 70 ...   3355  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,'Z Zap memory',10,13,0
000017F0= 48 75 68 3F 0D 0A 00    3356  HUH     DC.B 'Huh?',13,10,0
000017F7= 55 6E 69 6D 70 6C ...   3357  UNIMP   DC.B 'Unimplemented',13,10,0
00001807= 20 53 20 72 65 63 ...   3358  READ    DC.B ' S records read, start address = ',0
00001829= 57 41 52 4E 49 4E ...   3359  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
0000184F= 57 41 52 4E 49 4E ...   3360  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00001875= 57 41 52 4E 49 4E ...   3361  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
0000188D= 30 31 32 33 34 35 ...   3362  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000189D= 00 01 02 03 04 05 ...   3363  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000018B4                          3364      
000018B4                          3365      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         188D
CONTINUE_100        A4E
CONTINUE_104        AAC
CONTINUE_108        B0C
CONTINUE_112        B6A
CONTINUE_116        BDC
CONTINUE_120        C3A
CONTINUE_127        CE0
CONTINUE_131        D3E
CONTINUE_135        D9E
CONTINUE_139        DFC
CONTINUE_143        E60
CONTINUE_147        EBE
CONTINUE_151        F34
CONTINUE_155        F92
CONTINUE_159        FF2
CONTINUE_163        1050
CONTINUE_167        10C2
CONTINUE_171        1120
CONTINUE_178        11BE
CONTINUE_181        120A
CONTINUE_184        1258
CONTINUE_187        12A4
CONTINUE_190        12F6
CONTINUE_193        1342
CONTINUE_202        140A
CONTINUE_205        1456
CONTINUE_44         4A2
CONTINUE_46         4DE
CONTINUE_48         516
CONTINUE_51         562
CONTINUE_54         5B8
CONTINUE_57         604
CONTINUE_60         652
CONTINUE_63         69E
CONTINUE_66         6FE
CONTINUE_69         74A
CONTINUE_76         7E6
CONTINUE_80         844
CONTINUE_84         8A4
CONTINUE_88         902
CONTINUE_92         978
CONTINUE_96         9D6
CS_FAILURE          184F
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       1530
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EVEN                A24
EXIT_19             2DE
EXIT_196            13A6
EXIT_208            14AE
EXIT_21             306
EXIT_223            15A8
EXIT_23             32E
EXIT_233            16B0
EXIT_5              140
G                   162A
GET_INPUT           1AE
H                   2E2
HELP                1777
HEX2BIN             12B
HEX2BIN_LUT         189D
HEX_DIGIT           173A
HUH                 17F0
LOOP_19             2C0
LOOP_196            1388
LOOP_208            1490
LOOP_21             2E8
LOOP_210            14D8
LOOP_218            155A
LOOP_223            158A
LOOP_225            15D4
LOOP_23             310
LOOP_233            1692
LOOP_235            16DE
LOOP_25             360
LOOP_5              122
MAIN_LOOP           186
OK                  1730
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   332
RAM                 200000
RAM_ERROR           1875
READ                1807
READ_CHAR           79D
READ_DATA_TO_POKE   400
RRRR                0
S                   47E
START               8
UNIMP               17F7
UNREC               1829
V                   30A
VERSION             175A
W                   3B8
WAIT_CHAR           615
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_100  A32
WAIT_FOR_READY_102  A66
WAIT_FOR_READY_104  A90
WAIT_FOR_READY_106  AC4
WAIT_FOR_READY_108  AF0
WAIT_FOR_READY_11   186
WAIT_FOR_READY_110  B24
WAIT_FOR_READY_112  B4E
WAIT_FOR_READY_114  B82
WAIT_FOR_READY_116  BC0
WAIT_FOR_READY_118  BF4
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_120  C1E
WAIT_FOR_READY_122  C52
WAIT_FOR_READY_125  C8A
WAIT_FOR_READY_126  C9E
WAIT_FOR_READY_127  CC4
WAIT_FOR_READY_129  CF8
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_131  D22
WAIT_FOR_READY_133  D56
WAIT_FOR_READY_135  D82
WAIT_FOR_READY_137  DB6
WAIT_FOR_READY_139  DE0
WAIT_FOR_READY_141  E14
WAIT_FOR_READY_143  E44
WAIT_FOR_READY_145  E78
WAIT_FOR_READY_147  EA2
WAIT_FOR_READY_149  ED6
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  F18
WAIT_FOR_READY_153  F4C
WAIT_FOR_READY_155  F76
WAIT_FOR_READY_157  FAA
WAIT_FOR_READY_159  FD6
WAIT_FOR_READY_161  100A
WAIT_FOR_READY_163  1034
WAIT_FOR_READY_165  1068
WAIT_FOR_READY_167  10A6
WAIT_FOR_READY_169  10DA
WAIT_FOR_READY_17   262
WAIT_FOR_READY_171  1104
WAIT_FOR_READY_173  1138
WAIT_FOR_READY_176  1168
WAIT_FOR_READY_177  117C
WAIT_FOR_READY_178  11A2
WAIT_FOR_READY_18   276
WAIT_FOR_READY_181  11EE
WAIT_FOR_READY_184  123C
WAIT_FOR_READY_187  1288
WAIT_FOR_READY_190  12DA
WAIT_FOR_READY_193  1326
WAIT_FOR_READY_197  1390
WAIT_FOR_READY_198  13A6
WAIT_FOR_READY_20   2C8
WAIT_FOR_READY_200  13B8
WAIT_FOR_READY_201  13CC
WAIT_FOR_READY_202  13EE
WAIT_FOR_READY_205  143A
WAIT_FOR_READY_209  1498
WAIT_FOR_READY_211  14AE
WAIT_FOR_READY_212  14C2
WAIT_FOR_READY_214  14EC
WAIT_FOR_READY_216  1502
WAIT_FOR_READY_217  1516
WAIT_FOR_READY_219  1530
WAIT_FOR_READY_22   2F0
WAIT_FOR_READY_220  1544
WAIT_FOR_READY_222  156E
WAIT_FOR_READY_224  1592
WAIT_FOR_READY_226  15AA
WAIT_FOR_READY_227  15BE
WAIT_FOR_READY_229  15E8
WAIT_FOR_READY_231  15FE
WAIT_FOR_READY_232  1612
WAIT_FOR_READY_234  169A
WAIT_FOR_READY_236  16B4
WAIT_FOR_READY_237  16C8
WAIT_FOR_READY_239  16F2
WAIT_FOR_READY_24   318
WAIT_FOR_READY_241  1708
WAIT_FOR_READY_242  171C
WAIT_FOR_READY_26   336
WAIT_FOR_READY_27   34A
WAIT_FOR_READY_29   374
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   38A
WAIT_FOR_READY_32   39E
WAIT_FOR_READY_33   3BA
WAIT_FOR_READY_35   3D4
WAIT_FOR_READY_37   402
WAIT_FOR_READY_39   41C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   452
WAIT_FOR_READY_43   466
WAIT_FOR_READY_44   486
WAIT_FOR_READY_46   4C2
WAIT_FOR_READY_48   4FA
WAIT_FOR_READY_51   546
WAIT_FOR_READY_54   59C
WAIT_FOR_READY_57   5E8
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_60   636
WAIT_FOR_READY_63   682
WAIT_FOR_READY_66   6E2
WAIT_FOR_READY_69   72E
WAIT_FOR_READY_72   77A
WAIT_FOR_READY_74   790
WAIT_FOR_READY_75   7A4
WAIT_FOR_READY_76   7CA
WAIT_FOR_READY_78   7FE
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   828
WAIT_FOR_READY_82   85C
WAIT_FOR_READY_84   888
WAIT_FOR_READY_86   8BC
WAIT_FOR_READY_88   8E6
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   91A
WAIT_FOR_READY_92   95C
WAIT_FOR_READY_94   990
WAIT_FOR_READY_96   9BA
WAIT_FOR_READY_98   9EE
WAIT_FOR_SRECORD    486
Z                   1632
_00000000           7C0
_00000001           13E4
_00000002           CBA
_00000003           C8A
_00000004           13E4
_00000005           1198
_00000006           1168
_00000007           13E4
_00000008           1382
_00000009           13E4
_0000000A           152E
_0000000B           168C
_10000000           6D4
_10000001           790
_10000002           A24
_10000003           BB6
_10000004           F0A
_10000005           109C
_10000006           163A
_10000007           165C
_10000008           1664
_10000009           1736
