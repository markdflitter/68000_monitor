00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08/04/2021 07:01:55

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; tidy up layout (indentation and comments)
00000000                             9  ; tidy up NAND gate invertor and wiring for OE and WE on eeproms
00000000                            10  ; tidy up power loom
00000000                            11  ; add LDS and UDS with an OR gate and test because then I can do byte writes and it will make the download simpler
00000000                            12  ; stop using two registers in download
00000000                            13  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            14  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            15  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            16  
00000000                            17  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; fix the reset vector so that it jumps to the start
00000000                            20  ; Replace JMP -> BRA
00000000                            21  ; implement backspace
00000000                            22  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            23  ; fix being able to enter random chars when W'ing
00000000                            24  ; ram check at startup?  Not sure if this is a good idea!
00000000                            25  
00000000                            26      ;ORG  $0
00200000                            27      ORG  $200000
00200000                            28  
00200000  =00000000                 29  DEBUG               EQU 0
00200000                            30  
00200000                            31  ; constants
00200000  =00000000                 32  ROM                 EQU $0
00200000  =00200000                 33  RAM                 EQU $200000
00200000                            34     
00200000  =00C00000                 35  DUART_BASE          EQU $C00000
00200000  =00000000                 36  DUART_MRA_          EQU $0
00200000  =00000001                 37  DUART_CSRA_         EQU $1
00200000  =00000001                 38  DUART_SRA_          EQU $1
00200000  =00000002                 39  DUART_CRA_          EQU $2
00200000  =00000003                 40  DUART_TXA_          EQU $3
00200000  =00000003                 41  DUART_RXA_          EQU $3
00200000  =00000004                 42  DUART_ACR_          EQU $4
00200000  =00000005                 43  DUART_IMR_          EQU $5
00200000  =00000008                 44  DUART_MRB_          EQU $8
00200000  =00000009                 45  DUART_CSRB_         EQU $9
00200000  =00000009                 46  DUART_SRB_          EQU $9
00200000  =0000000A                 47  DUART_CRB_          EQU $A
00200000  =0000000B                 48  DUART_TXB_          EQU $B
00200000  =0000000B                 49  DUART_RXB_          EQU $B
00200000  =0000000C                 50  DUART_IVR_          EQU $C
00200000  =0000000D                 51  DUART_OPCR_         EQU $D
00200000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00200000                            54  RRRR
00200000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            61  
00200000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            68  
00200000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            75  
00200000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 77  DISPLAY_            EQU $0
00200000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            79  
00200000                            80  ; macros
00200000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            82  ; the input register is changed during the process
00200000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            84  BIN2HEX MACRO
00200000                            85      LEA BIN2HEX_LUT,\3                ; load the lookup table
00200000                            86      ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            87      MOVE.B \1,\2
00200000                            88      ANDI.L #$F,\2
00200000                            89      MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00200000                            90      ENDM
00200000                            91  
00200000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            93  ; the input register is changed during the process
00200000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            95  HEX2BIN MACRO
00200000                            96      LEA HEX2BIN_LUT,\3                  ; load the lookup table
00200000                            97      SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00200000                            98      AND.L #$FF,\1                       ; ignore the top 3 bytes
00200000                            99      MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00200000                           100      ENDM
00200000                           101  
00200000                           102  ; send a single char to the serial port
00200000                           103  ; \1 = char to send, \2 = data register to use for status poll
00200000                           104  ; will stamp on D0 and D1 in debug mode
00200000                           105  PRINT_CHAR MACRO
00200000                           106  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           107      IFEQ DEBUG
00200000                           108          MOVE.B DUART_SRA,\2           ; read status register
00200000                           109          BTST #2,\2                    ; check for space to send
00200000                           110          BEQ WAIT_FOR_READY\@          ; no space, check again
00200000                           111          MOVE.B \1,DUART_TXA           ; send the next character
00200000                           112      ENDC
00200000                           113      
00200000                           114      IFNE DEBUG
00200000                           115          MOVE.B \1,D1
00200000                           116          MOVE.L #6,D0   
00200000                           117          TRAP #15                      ; write to terminal in simulator
00200000                           118      ENDC
00200000                           119  
00200000                           120      ENDM
00200000                           121  
00200000                           122  ; send CR,LF to the serial port
00200000                           123  ; \1 = data register to use for status poll
00200000                           124  PRINT_CRLF MACRO
00200000                           125      PRINT_CHAR #13,\1             ; CR
00200000                           126      PRINT_CHAR #10,\1             ; LF
00200000                           127      ENDM
00200000                           128  
00200000                           129  ; send C-style, zero terminated string to the serial port
00200000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           131  PRINT_STR MACRO
00200000                           132  LOOP\@
00200000                           133      CMP.B #0,(\1)                 ; 0 -> done
00200000                           134      BEQ EXIT\@
00200000                           135      PRINT_CHAR (\1)+,\2
00200000                           136      JMP LOOP\@
00200000                           137  EXIT\@
00200000                           138      ENDM
00200000                           139    
00200000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           142  PRINT_REG MACRO
00200000                           143      PRINT_CHAR #'0',\2          ;0x header
00200000                           144      PRINT_CHAR #'x',\2
00200000                           145      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00200000                           146  LOOP\@
00200000                           147      BIN2HEX \1,\3,\5
00200000                           148      PRINT_CHAR \3,\2
00200000                           149      DBEQ \4,LOOP\@
00200000                           150      ENDM
00200000                           151    
00200000                           152  ; wait for a char from the serial port
00200000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           154  ; will stamp on D0 and D1 in debug mode
00200000                           155  WAIT_CHAR MACRO
00200000                           156  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           157  
00200000                           158      IFEQ DEBUG
00200000                           159          MOVE.B DUART_SRA,\2         ; read status register
00200000                           160          BTST #0,\2                    ; check for character
00200000                           161          BEQ WAIT_FOR_READY\@          ; nothing, check again
00200000                           162      ENDC
00200000                           163      
00200000                           164      READ_CHAR \1
00200000                           165  
00200000                           166      IFEQ DEBUG
00200000                           167          PRINT_CHAR \1,\2            ; echo it back
00200000                           168      ENDC
00200000                           169      ENDM
00200000                           170      
00200000                           171  ; read a char from the serial port - assumes that there is one!
00200000                           172  ; \ 1= data register for read char
00200000                           173  ; will stamp on D0 and D1 in debug mode
00200000                           174  READ_CHAR MACRO
00200000                           175      IFEQ DEBUG
00200000                           176          MOVE.B DUART_RXA,\1         ; got a character, read it
00200000                           177      ENDC
00200000                           178      IFNE DEBUG
00200000                           179          MOVE.L #5,D0    
00200000                           180          TRAP #15                    ; read from keyboard in simulator
00200000                           181          MOVE.L D1,\1
00200000                           182      ENDC
00200000                           183       
00200000                           184      CMP.B #$1B,\1                 ; check for escape and go to start
00200000                           185      BEQ START
00200000                           186      ENDM
00200000                           187      
00200000                           188      
00200000                           189  ; read data from the download serial port
00200000                           190  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           191  DOWNLOAD MACRO
00200000                           192  WAIT_FOR_READY\@                  ; wait until the there is space to send
00200000                           193  
00200000                           194      MOVE.B DUART_SRA,\2           ; check for command
00200000                           195      BTST #0,\2                    ; check for character
00200000                           196      BEQ CONTINUE\@                ; nothing, continue
00200000                           197   
00200000                           198      READ_CHAR \1
00200000                           199  CONTINUE\@
00200000                           200      MOVE.B DUART_SRB,\2         ; read status register
00200000                           201      BTST #0,\2                  ; check for character
00200000                           202      BEQ WAIT_FOR_READY\@        ; nothing, check again
00200000                           203      
00200000                           204      MOVE.B DUART_RXB,\1         ; got a character, read it
00200000                           205      MOVE.B \1,DISPLAY           ; echo to the display
00200000                           206      
00200000                           207      ENDM
00200000                           208  
00200000                           209  ; register catalogue
00200000                           210  ; D0 - used for simulator I/O
00200000                           211  ; D1 - used for simulator I/O
00200000                           212  ; D2 - read character
00200000                           213  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           214  ; D4 - count of S records read
00200000                           215  ; D5 - data to write / data read / byte count for S record load
00200000                           216  ; D6 - working register used in R/W and download
00200000                           217  ; D7 - address accumulator / reset by download
00200000                           218  ; A0 - address of string to print 
00200000                           219  
00200000                           220  ; start vector
00200000= 00000000                 221  STACK    DC.L $00000000              ; STACK
00200004= 00200008                 222  RESET    DC.L START                  ; RESET
00200008                           223      
00200008                           224  ; start of program  
00200008                           225  START
00200008  13FC 0000 00E00001       226      MOVE.B #0,DISPLAY
00200010                           227  
00200010                           228  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       229      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00200018  13FC 0050 00C00005       230      MOVE.B #$50,DUART_CRA           ; reset everyting
00200020  4E71                     231      NOP
00200022  13FC 0040 00C00005       232      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     233      NOP
0020002C  13FC 0030 00C00005       234      MOVE.B #$30,DUART_CRA
00200034  4E71                     235      NOP
00200036  13FC 0020 00C00005       236      MOVE.B #$20,DUART_CRA
0020003E  4E71                     237      NOP
00200040  13FC 0010 00C00005       238      MOVE.B #$10,DUART_CRA   
00200048                           239  
00200048  13FC 000A 00C00015       240      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00200050  13FC 0050 00C00015       241      MOVE.B #$50,DUART_CRB           ; reset everyting
00200058  4E71                     242      NOP
0020005A  13FC 0040 00C00015       243      MOVE.B #$40,DUART_CRB           
00200062  4E71                     244      NOP
00200064  13FC 0030 00C00015       245      MOVE.B #$30,DUART_CRB
0020006C  4E71                     246      NOP
0020006E  13FC 0020 00C00015       247      MOVE.B #$20,DUART_CRB
00200076  4E71                     248      NOP
00200078  13FC 0010 00C00015       249      MOVE.B #$10,DUART_CRB   
00200080                           250  
00200080                           251  ;initialise UART
00200080  13FC 0000 00C00009       252      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       253      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00200090  13FC 0000 00C0001B       254      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00200098                           255  
00200098                           256  ; channel A
00200098  13FC 0013 00C00001       257      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       258      MOVE.B #$07,DUART_MRA           ; 1 stop bit
002000A8  13FC 00BB 00C00003       259      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
002000B0  13FC 0005 00C00005       260      MOVE.B #$5,DUART_CRA            ; enable rx & tx
002000B8                           261  
002000B8                           262  ; channel B
002000B8  13FC 0013 00C00011       263      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       264      MOVE.B #$07,DUART_MRB           ; 1 stop bit
002000C8  13FC 00BB 00C00013       265      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
002000D0  13FC 0005 00C00015       266      MOVE.B #$5,DUART_CRB            ; enable rx & tx
002000D8                           267  
002000D8                           268m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
002000D8                           269m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      270m     IFEQ DEBUG
002000D8  1639 00C00003            271m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000DE  0803 0002                272m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000E2  67F4                     273m         BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       274m         MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
002000EC                           275m     ENDC
002000EC                           276m     
002000EC                 FALSE     277m     IFNE DEBUG
002000EC                           278m     ENDC
002000EC                           279m 
002000EC                           280m     ENDM
002000EC                           281  
002000EC  13FC 0001 00E00001       282      MOVE.B #1,DISPLAY
002000F4                           283         
002000F4                           284m     PRINT_CRLF D3
002000F4                           285mm     PRINT_CHAR #13,D3             ; CR
002000F4                           286mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      287mm     IFEQ DEBUG
002000F4  1639 00C00003            288mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002000FA  0803 0002                289mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002000FE  67F4                     290mm         BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       291mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200108                           292mm     ENDC
00200108                           293mm     
00200108                 FALSE     294mm     IFNE DEBUG
00200108                           295mm     ENDC
00200108                           296mm 
00200108                           297mm     ENDM
00200108                           298mm     PRINT_CHAR #10,D3             ; LF
00200108                           299mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      300mm     IFEQ DEBUG
00200108  1639 00C00003            301mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020010E  0803 0002                302mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200112  67F4                     303mm         BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       304mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020011C                           305mm     ENDC
0020011C                           306mm     
0020011C                 FALSE     307mm     IFNE DEBUG
0020011C                           308mm     ENDC
0020011C                           309mm 
0020011C                           310mm     ENDM
0020011C                           311m     ENDM
0020011C                           312  
0020011C  41F9 002019E2            313      LEA VERSION,A0
00200122                           314m     PRINT_STR A0,D3
00200122                           315m LOOP_5
00200122  0C10 0000                316m     CMP.B #0,(A0)                 ; 0 -> DONE
00200126  6700 001A                317m     BEQ EXIT_5
0020012A                           318mm     PRINT_CHAR (A0)+,D3
0020012A                           319mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      320mm     IFEQ DEBUG
0020012A  1639 00C00003            321mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200130  0803 0002                322mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200134  67F4                     323mm         BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            324mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020013C                           325mm     ENDC
0020013C                           326mm     
0020013C                 FALSE     327mm     IFNE DEBUG
0020013C                           328mm     ENDC
0020013C                           329mm 
0020013C                           330mm     ENDM
0020013C  4EF9 00200122            331m     JMP LOOP_5
00200142                           332m EXIT_5
00200142                           333m     ENDM
00200142                           334m     PRINT_CRLF D3
00200142                           335mm     PRINT_CHAR #13,D3             ; CR
00200142                           336mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      337mm     IFEQ DEBUG
00200142  1639 00C00003            338mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200148  0803 0002                339mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020014C  67F4                     340mm         BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       341mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200156                           342mm     ENDC
00200156                           343mm     
00200156                 FALSE     344mm     IFNE DEBUG
00200156                           345mm     ENDC
00200156                           346mm 
00200156                           347mm     ENDM
00200156                           348mm     PRINT_CHAR #10,D3             ; LF
00200156                           349mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      350mm     IFEQ DEBUG
00200156  1639 00C00003            351mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020015C  0803 0002                352mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200160  67F4                     353mm         BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       354mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020016A                           355mm     ENDC
0020016A                           356mm     
0020016A                 FALSE     357mm     IFNE DEBUG
0020016A                           358mm     ENDC
0020016A                           359mm 
0020016A                           360mm     ENDM
0020016A                           361m     ENDM
0020016A                           362m     PRINT_CHAR #7,D3
0020016A                           363m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      364m     IFEQ DEBUG
0020016A  1639 00C00003            365m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200170  0803 0002                366m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200174  67F4                     367m         BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       368m         MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020017E                           369m     ENDC
0020017E                           370m     
0020017E                 FALSE     371m     IFNE DEBUG
0020017E                           372m     ENDC
0020017E                           373m 
0020017E                           374m     ENDM
0020017E                           375  
0020017E  7E00                     376      MOVE.L #0,D7                    ; address accumulator
00200180                           377  
00200180  13FC 0002 00E00001       378      MOVE.B #2,DISPLAY
00200188                           379  MAIN_LOOP
00200188                           380m     PRINT_CHAR #'>',D3               ; prompt
00200188                           381m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      382m     IFEQ DEBUG
00200188  1639 00C00003            383m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020018E  0803 0002                384m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200192  67F4                     385m         BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       386m         MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0020019C                           387m     ENDC
0020019C                           388m     
0020019C                 FALSE     389m     IFNE DEBUG
0020019C                           390m     ENDC
0020019C                           391m 
0020019C                           392m     ENDM
0020019C                           393m     PRINT_CHAR #32,D3                ; space
0020019C                           394m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      395m     IFEQ DEBUG
0020019C  1639 00C00003            396m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001A2  0803 0002                397m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001A6  67F4                     398m         BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       399m         MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
002001B0                           400m     ENDC
002001B0                           401m     
002001B0                 FALSE     402m     IFNE DEBUG
002001B0                           403m     ENDC
002001B0                           404m 
002001B0                           405m     ENDM
002001B0                           406      
002001B0                           407  GET_INPUT
002001B0                           408m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
002001B0                           409m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           410m 
002001B0                 TRUE      411m     IFEQ DEBUG
002001B0  1639 00C00003            412m         MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002001B6  0803 0000                413m         BTST #0,D3                    ; CHECK FOR CHARACTER
002001BA  67F4                     414m         BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
002001BC                           415m     ENDC
002001BC                           416m     
002001BC                           417mm     READ_CHAR D2
002001BC                 TRUE      418mm     IFEQ DEBUG
002001BC  1439 00C00007            419mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002001C2                           420mm     ENDC
002001C2                 FALSE     421mm     IFNE DEBUG
002001C2                           422mm     ENDC
002001C2                           423mm      
002001C2  B43C 001B                424mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                425mm     BEQ START
002001CA                           426mm     ENDM
002001CA                           427m 
002001CA                 TRUE      428m     IFEQ DEBUG
002001CA                           429mm         PRINT_CHAR D2,D3            ; ECHO IT BACK
002001CA                           430mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      431mm     IFEQ DEBUG
002001CA  1639 00C00003            432mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002001D0  0803 0002                433mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002001D4  67F4                     434mm         BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            435mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002001DC                           436mm     ENDC
002001DC                           437mm     
002001DC                 FALSE     438mm     IFNE DEBUG
002001DC                           439mm     ENDC
002001DC                           440mm 
002001DC                           441mm     ENDM
002001DC                           442m     ENDC
002001DC                           443m     ENDM
002001DC                           444      
002001DC  B43C 0030                445      CMP.B #'0',D2
002001E0  6700 17DE                446      BEQ HEX_DIGIT
002001E4  B43C 0031                447      CMP.B #'1',D2
002001E8  6700 17D6                448      BEQ HEX_DIGIT
002001EC  B43C 0032                449      CMP.B #'2',D2
002001F0  6700 17CE                450      BEQ HEX_DIGIT
002001F4  B43C 0033                451      CMP.B #'3',D2
002001F8  6700 17C6                452      BEQ HEX_DIGIT
002001FC  B43C 0034                453      CMP.B #'4',D2
00200200  6700 17BE                454      BEQ HEX_DIGIT
00200204  B43C 0035                455      CMP.B #'5',D2
00200208  6700 17B6                456      BEQ HEX_DIGIT
0020020C  B43C 0036                457      CMP.B #'6',D2
00200210  6700 17AE                458      BEQ HEX_DIGIT
00200214  B43C 0037                459      CMP.B #'7',D2
00200218  6700 17A6                460      BEQ HEX_DIGIT
0020021C  B43C 0038                461      CMP.B #'8',D2
00200220  6700 179E                462      BEQ HEX_DIGIT
00200224  B43C 0039                463      CMP.B #'9',D2
00200228  6700 1796                464      BEQ HEX_DIGIT
0020022C  B43C 0041                465      CMP.B #'A',D2
00200230  6700 178E                466      BEQ HEX_DIGIT
00200234  B43C 0042                467      CMP.B #'B',D2
00200238  6700 1786                468      BEQ HEX_DIGIT
0020023C  B43C 0043                469      CMP.B #'C',D2
00200240  6700 177E                470      BEQ HEX_DIGIT
00200244  B43C 0044                471      CMP.B #'D',D2
00200248  6700 1776                472      BEQ HEX_DIGIT
0020024C  B43C 0045                473      CMP.B #'E',D2
00200250  6700 176E                474      BEQ HEX_DIGIT
00200254  B43C 0046                475      CMP.B #'F',D2
00200258  6700 1766                476      BEQ HEX_DIGIT
0020025C                           477      
0020025C  B43C 0057                478      CMP.B #'W',D2
00200260  6700 016E                479      BEQ W
00200264                           480      
00200264  B43C 004C                481      CMP.B #'L',D2
00200268  6700 15E0                482      BEQ L 
0020026C                           483  
0020026C                           484m     PRINT_CRLF D3
0020026C                           485mm     PRINT_CHAR #13,D3             ; CR
0020026C                           486mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      487mm     IFEQ DEBUG
0020026C  1639 00C00003            488mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200272  0803 0002                489mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200276  67F4                     490mm         BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       491mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200280                           492mm     ENDC
00200280                           493mm     
00200280                 FALSE     494mm     IFNE DEBUG
00200280                           495mm     ENDC
00200280                           496mm 
00200280                           497mm     ENDM
00200280                           498mm     PRINT_CHAR #10,D3             ; LF
00200280                           499mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      500mm     IFEQ DEBUG
00200280  1639 00C00003            501mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200286  0803 0002                502mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020028A  67F4                     503mm         BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       504mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200294                           505mm     ENDC
00200294                           506mm     
00200294                 FALSE     507mm     IFNE DEBUG
00200294                           508mm     ENDC
00200294                           509mm 
00200294                           510mm     ENDM
00200294                           511m     ENDM
00200294                           512   
00200294  B43C 003F                513      CMP.B #'?',D2
00200298  6700 0056                514      BEQ H
0020029C                           515  
0020029C  B43C 0056                516      CMP.B #'V',D2
002002A0  6700 007A                517      BEQ V
002002A4                           518      
002002A4  B43C 0052                519      CMP.B #'R',D2
002002A8  6700 009E                520      BEQ R
002002AC                           521  
002002AC  B43C 0053                522      CMP.B #'S',D2
002002B0  6700 01E6                523      BEQ S
002002B4                           524  
002002B4  B43C 0047                525      CMP.B #'G',D2
002002B8  6700 147C                526      BEQ G   
002002BC                           527  
002002BC  B43C 005A                528      CMP.B #'Z',D2
002002C0  6700 147C                529      BEQ Z   
002002C4                           530  
002002C4  41F9 00201A96            531      LEA HUH,A0
002002CA                           532m     PRINT_STR A0,D3
002002CA                           533m LOOP_19
002002CA  0C10 0000                534m     CMP.B #0,(A0)                 ; 0 -> DONE
002002CE  6700 001A                535m     BEQ EXIT_19
002002D2                           536mm     PRINT_CHAR (A0)+,D3
002002D2                           537mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      538mm     IFEQ DEBUG
002002D2  1639 00C00003            539mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002002D8  0803 0002                540mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002002DC  67F4                     541mm         BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            542mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002002E4                           543mm     ENDC
002002E4                           544mm     
002002E4                 FALSE     545mm     IFNE DEBUG
002002E4                           546mm     ENDC
002002E4                           547mm 
002002E4                           548mm     ENDM
002002E4  4EF9 002002CA            549m     JMP LOOP_19
002002EA                           550m EXIT_19
002002EA                           551m     ENDM
002002EA                           552                         
002002EA  4EF9 00200188            553      JMP MAIN_LOOP
002002F0                           554      
002002F0                           555  ; commands
002002F0  41F9 002019FF            556  H   LEA HELP,A0
002002F6                           557m     PRINT_STR A0,D3
002002F6                           558m LOOP_21
002002F6  0C10 0000                559m     CMP.B #0,(A0)                 ; 0 -> DONE
002002FA  6700 001A                560m     BEQ EXIT_21
002002FE                           561mm     PRINT_CHAR (A0)+,D3
002002FE                           562mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      563mm     IFEQ DEBUG
002002FE  1639 00C00003            564mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200304  0803 0002                565mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200308  67F4                     566mm         BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            567mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00200310                           568mm     ENDC
00200310                           569mm     
00200310                 FALSE     570mm     IFNE DEBUG
00200310                           571mm     ENDC
00200310                           572mm 
00200310                           573mm     ENDM
00200310  4EF9 002002F6            574m     JMP LOOP_21
00200316                           575m EXIT_21
00200316                           576m     ENDM
00200316  4EF9 00200188            577      JMP MAIN_LOOP
0020031C                           578  
0020031C  41F9 002019E2            579  V   LEA VERSION,A0
00200322                           580m     PRINT_STR A0,D3       
00200322                           581m LOOP_23
00200322  0C10 0000                582m     CMP.B #0,(A0)                 ; 0 -> DONE
00200326  6700 001A                583m     BEQ EXIT_23
0020032A                           584mm     PRINT_CHAR (A0)+,D3
0020032A                           585mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      586mm     IFEQ DEBUG
0020032A  1639 00C00003            587mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200330  0803 0002                588mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200334  67F4                     589mm         BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            590mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020033C                           591mm     ENDC
0020033C                           592mm     
0020033C                 FALSE     593mm     IFNE DEBUG
0020033C                           594mm     ENDC
0020033C                           595mm 
0020033C                           596mm     ENDM
0020033C  4EF9 00200322            597m     JMP LOOP_23
00200342                           598m EXIT_23
00200342                           599m     ENDM
00200342  4EF9 00200188            600      JMP MAIN_LOOP
00200348                           601      
00200348  2047                     602  R   MOVE.L D7,A0                    ; address accumulator -> address register
0020034A  2A10                     603      MOVE.L (A0),D5                  ; read the memory and print it
0020034C                           604m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           605mm     PRINT_CHAR #'0',D3          ;0X HEADER
0020034C                           606mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      607mm     IFEQ DEBUG
0020034C  1639 00C00003            608mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200352  0803 0002                609mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200356  67F4                     610mm         BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       611mm         MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00200360                           612mm     ENDC
00200360                           613mm     
00200360                 FALSE     614mm     IFNE DEBUG
00200360                           615mm     ENDC
00200360                           616mm 
00200360                           617mm     ENDM
00200360                           618mm     PRINT_CHAR #'x',D3
00200360                           619mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      620mm     IFEQ DEBUG
00200360  1639 00C00003            621mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200366  0803 0002                622mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020036A  67F4                     623mm         BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       624mm         MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00200374                           625mm     ENDC
00200374                           626mm     
00200374                 FALSE     627mm     IFNE DEBUG
00200374                           628mm     ENDC
00200374                           629mm 
00200374                           630mm     ENDM
00200374  7C07                     631m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           632m LOOP_25
00200376                           633mm     BIN2HEX D5,D7,A0
00200376  41F9 00201AFA            634mm     LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
0020037C  E99D                     635mm     ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     636mm     MOVE.B D5,D7
00200380  0287 0000000F            637mm     ANDI.L #$F,D7
00200386  1E30 7000                638mm     MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           639mm     ENDM
0020038A                           640mm     PRINT_CHAR D7,D3
0020038A                           641mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      642mm     IFEQ DEBUG
0020038A  1639 00C00003            643mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200390  0803 0002                644mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200394  67F4                     645mm         BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            646mm         MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0020039C                           647mm     ENDC
0020039C                           648mm     
0020039C                 FALSE     649mm     IFNE DEBUG
0020039C                           650mm     ENDC
0020039C                           651mm 
0020039C                           652mm     ENDM
0020039C  57CE FFD8                653m     DBEQ D6,LOOP_25
002003A0                           654m     ENDM
002003A0                           655m     PRINT_CRLF D3
002003A0                           656mm     PRINT_CHAR #13,D3             ; CR
002003A0                           657mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      658mm     IFEQ DEBUG
002003A0  1639 00C00003            659mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003A6  0803 0002                660mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003AA  67F4                     661mm         BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       662mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002003B4                           663mm     ENDC
002003B4                           664mm     
002003B4                 FALSE     665mm     IFNE DEBUG
002003B4                           666mm     ENDC
002003B4                           667mm 
002003B4                           668mm     ENDM
002003B4                           669mm     PRINT_CHAR #10,D3             ; LF
002003B4                           670mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      671mm     IFEQ DEBUG
002003B4  1639 00C00003            672mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003BA  0803 0002                673mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003BE  67F4                     674mm         BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       675mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002003C8                           676mm     ENDC
002003C8                           677mm     
002003C8                 FALSE     678mm     IFNE DEBUG
002003C8                           679mm     ENDC
002003C8                           680mm 
002003C8                           681mm     ENDM
002003C8                           682m     ENDM
002003C8  7E00                     683      MOVE.L #0,D7                    ; clear the now used address accumulator
002003CA  4EF9 00200188            684      JMP MAIN_LOOP
002003D0                           685  
002003D0  7A00                     686  W   MOVE.L #0,D5                    ; D5 will be the value to write            
002003D2                           687  
002003D2                           688m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
002003D2                           689m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           690m 
002003D2                 TRUE      691m     IFEQ DEBUG
002003D2  1639 00C00003            692m         MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
002003D8  0803 0000                693m         BTST #0,D3                    ; CHECK FOR CHARACTER
002003DC  67F4                     694m         BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
002003DE                           695m     ENDC
002003DE                           696m     
002003DE                           697mm     READ_CHAR D2
002003DE                 TRUE      698mm     IFEQ DEBUG
002003DE  1439 00C00007            699mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002003E4                           700mm     ENDC
002003E4                 FALSE     701mm     IFNE DEBUG
002003E4                           702mm     ENDC
002003E4                           703mm      
002003E4  B43C 001B                704mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                705mm     BEQ START
002003EC                           706mm     ENDM
002003EC                           707m 
002003EC                 TRUE      708m     IFEQ DEBUG
002003EC                           709mm         PRINT_CHAR D2,D3            ; ECHO IT BACK
002003EC                           710mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      711mm     IFEQ DEBUG
002003EC  1639 00C00003            712mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002003F2  0803 0002                713mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002003F6  67F4                     714mm         BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            715mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002003FE                           716mm     ENDC
002003FE                           717mm     
002003FE                 FALSE     718mm     IFNE DEBUG
002003FE                           719mm     ENDC
002003FE                           720mm 
002003FE                           721mm     ENDM
002003FE                           722m     ENDC
002003FE                           723m     ENDM
002003FE                           724m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002003FE  41F9 00201B0A            725m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200404  0402 0030                726m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            727m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                728m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           729m     ENDM
00200412  1A02                     730      MOVE.B D2,D5                    ; put at bottom of D5
00200414                           731  
00200414  3C3C 0006                732      MOVE #6,D6                      ; 7 bytes left to read
00200418                           733      
00200418                           734  READ_DATA_TO_POKE
00200418  E98D                     735      LSL.L #4,D5                     ; make what we have so far more significant
0020041A                           736m     WAIT_CHAR D2,D3                 ; next character -> D2
0020041A                           737m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           738m 
0020041A                 TRUE      739m     IFEQ DEBUG
0020041A  1639 00C00003            740m         MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00200420  0803 0000                741m         BTST #0,D3                    ; CHECK FOR CHARACTER
00200424  67F4                     742m         BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
00200426                           743m     ENDC
00200426                           744m     
00200426                           745mm     READ_CHAR D2
00200426                 TRUE      746mm     IFEQ DEBUG
00200426  1439 00C00007            747mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020042C                           748mm     ENDC
0020042C                 FALSE     749mm     IFNE DEBUG
0020042C                           750mm     ENDC
0020042C                           751mm      
0020042C  B43C 001B                752mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                753mm     BEQ START
00200434                           754mm     ENDM
00200434                           755m 
00200434                 TRUE      756m     IFEQ DEBUG
00200434                           757mm         PRINT_CHAR D2,D3            ; ECHO IT BACK
00200434                           758mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      759mm     IFEQ DEBUG
00200434  1639 00C00003            760mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020043A  0803 0002                761mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020043E  67F4                     762mm         BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            763mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200446                           764mm     ENDC
00200446                           765mm     
00200446                 FALSE     766mm     IFNE DEBUG
00200446                           767mm     ENDC
00200446                           768mm 
00200446                           769mm     ENDM
00200446                           770m     ENDC
00200446                           771m     ENDM
00200446                           772m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00200446  41F9 00201B0A            773m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                774m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            775m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                776m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           777m     ENDM
0020045A  8A02                     778      OR.B D2,D5
0020045C  023C 00FB                779      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                780      DBEQ D6,READ_DATA_TO_POKE
00200464                           781      
00200464  2047                     782      MOVE.L D7,A0                    ; address accumulator -> address register
00200466  7E00                     783      MOVE.L #0,D7                    ; clear the now used address accumulator
00200468                           784      
00200468  2085                     785      MOVE.L D5,(A0)                  ; write the data
0020046A                           786  
0020046A                           787m     PRINT_CRLF D3
0020046A                           788mm     PRINT_CHAR #13,D3             ; CR
0020046A                           789mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      790mm     IFEQ DEBUG
0020046A  1639 00C00003            791mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200470  0803 0002                792mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200474  67F4                     793mm         BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       794mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020047E                           795mm     ENDC
0020047E                           796mm     
0020047E                 FALSE     797mm     IFNE DEBUG
0020047E                           798mm     ENDC
0020047E                           799mm 
0020047E                           800mm     ENDM
0020047E                           801mm     PRINT_CHAR #10,D3             ; LF
0020047E                           802mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      803mm     IFEQ DEBUG
0020047E  1639 00C00003            804mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200484  0803 0002                805mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200488  67F4                     806mm         BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       807mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200492                           808mm     ENDC
00200492                           809mm     
00200492                 FALSE     810mm     IFNE DEBUG
00200492                           811mm     ENDC
00200492                           812mm 
00200492                           813mm     ENDM
00200492                           814m     ENDM
00200492  4EF9 00200188            815      JMP MAIN_LOOP
00200498                           816  
00200498                           817          
00200498  2647                     818  S   MOVE.L D7,A3                    ; grab the address accumulator
0020049A  7800                     819      MOVE.L #0,D4                    ; count of records read -> D4
0020049C  2478 0000                820      MOVE.L 0,A2                     ; start address -> A2
002004A0                           821      
002004A0                           822  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
002004A0                           823m     DOWNLOAD D2,D3                  
002004A0                           824m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           825m 
002004A0  1639 00C00003            826m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004A6  0803 0000                827m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004AA  6700 0010                828m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
002004AE                           829m  
002004AE                           830mm     READ_CHAR D2
002004AE                 TRUE      831mm     IFEQ DEBUG
002004AE  1439 00C00007            832mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002004B4                           833mm     ENDC
002004B4                 FALSE     834mm     IFNE DEBUG
002004B4                           835mm     ENDC
002004B4                           836mm      
002004B4  B43C 001B                837mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                838mm     BEQ START
002004BC                           839mm     ENDM
002004BC                           840m CONTINUE_44
002004BC  1639 00C00013            841m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004C2  0803 0000                842m     BTST #0,D3                  ; CHECK FOR CHARACTER
002004C6  67D8                     843m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
002004C8                           844m     
002004C8  1439 00C00017            845m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            846m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002004D4                           847m     
002004D4                           848m     ENDM
002004D4  B43C 0053                849      CMP.B #'S',D2                   ; found S?    
002004D8  66C6                     850      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
002004DA                           851      
002004DA  5284                     852      ADD.L #1,D4                     ; read another S record, increment count
002004DC                           853      
002004DC                           854m     DOWNLOAD D7,D3                  ; read the record digit
002004DC                           855m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DC                           856m 
002004DC  1639 00C00003            857m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002004E2  0803 0000                858m     BTST #0,D3                    ; CHECK FOR CHARACTER
002004E6  6700 0010                859m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
002004EA                           860m  
002004EA                           861mm     READ_CHAR D7
002004EA                 TRUE      862mm     IFEQ DEBUG
002004EA  1E39 00C00007            863mm         MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
002004F0                           864mm     ENDC
002004F0                 FALSE     865mm     IFNE DEBUG
002004F0                           866mm     ENDC
002004F0                           867mm      
002004F0  BE3C 001B                868mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
002004F4  6700 FB12                869mm     BEQ START
002004F8                           870mm     ENDM
002004F8                           871m CONTINUE_46
002004F8  1639 00C00013            872m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002004FE  0803 0000                873m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200502  67D8                     874m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
00200504                           875m     
00200504  1E39 00C00017            876m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
0020050A  13C7 00E00001            877m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
00200510                           878m     
00200510                           879m     ENDM
00200510                           880  
00200510  7C00                     881      MOVE.L #0,D6                    ; checksum
00200512                           882  
00200512  7A00                     883      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
00200514                           884m     DOWNLOAD D2,D3              
00200514                           885m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                           886m 
00200514  1639 00C00003            887m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020051A  0803 0000                888m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020051E  6700 0010                889m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00200522                           890m  
00200522                           891mm     READ_CHAR D2
00200522                 TRUE      892mm     IFEQ DEBUG
00200522  1439 00C00007            893mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200528                           894mm     ENDC
00200528                 FALSE     895mm     IFNE DEBUG
00200528                           896mm     ENDC
00200528                           897mm      
00200528  B43C 001B                898mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020052C  6700 FADA                899mm     BEQ START
00200530                           900mm     ENDM
00200530                           901m CONTINUE_48
00200530  1639 00C00013            902m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200536  0803 0000                903m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020053A  67D8                     904m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
0020053C                           905m     
0020053C  1439 00C00017            906m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200542  13C2 00E00001            907m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200548                           908m     
00200548                           909m     ENDM
00200548                           910m     HEX2BIN D2,D2,A0
00200548  41F9 00201B0A            911m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020054E  0402 0030                912m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200552  C4BC 000000FF            913m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200558  1430 2000                914m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020055C                           915m     ENDM
0020055C  8A82                     916      OR.L D2,D5
0020055E  E98D                     917      LSL.L #4,D5    
00200560                           918m     DOWNLOAD D2,D3
00200560                           919m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200560                           920m 
00200560  1639 00C00003            921m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200566  0803 0000                922m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020056A  6700 0010                923m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
0020056E                           924m  
0020056E                           925mm     READ_CHAR D2
0020056E                 TRUE      926mm     IFEQ DEBUG
0020056E  1439 00C00007            927mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200574                           928mm     ENDC
00200574                 FALSE     929mm     IFNE DEBUG
00200574                           930mm     ENDC
00200574                           931mm      
00200574  B43C 001B                932mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200578  6700 FA8E                933mm     BEQ START
0020057C                           934mm     ENDM
0020057C                           935m CONTINUE_51
0020057C  1639 00C00013            936m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200582  0803 0000                937m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200586  67D8                     938m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
00200588                           939m     
00200588  1439 00C00017            940m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020058E  13C2 00E00001            941m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200594                           942m     
00200594                           943m     ENDM
00200594                           944m     HEX2BIN D2,D2,A0  
00200594  41F9 00201B0A            945m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020059A  0402 0030                946m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020059E  C4BC 000000FF            947m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005A4  1430 2000                948m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005A8                           949m     ENDM
002005A8  8A82                     950      OR.L D2,D5
002005AA                           951                  
002005AA  DC85                     952      ADD.L D5,D6                     ; add byte count into checksum
002005AC                           953  
002005AC                           954      IF.B D7 <EQ> #'0' THEN.L        ; header
002005AC  BE3C 0030                955s     CMP.B   #'0',D7
002005B0  6600 022A                956s     BNE.L   _00000000
002005B4  7E00                     957          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
002005B6                           958m         DOWNLOAD D2,D3              ; top byte
002005B6                           959m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B6                           960m 
002005B6  1639 00C00003            961m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002005BC  0803 0000                962m     BTST #0,D3                    ; CHECK FOR CHARACTER
002005C0  6700 0010                963m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
002005C4                           964m  
002005C4                           965mm     READ_CHAR D2
002005C4                 TRUE      966mm     IFEQ DEBUG
002005C4  1439 00C00007            967mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002005CA                           968mm     ENDC
002005CA                 FALSE     969mm     IFNE DEBUG
002005CA                           970mm     ENDC
002005CA                           971mm      
002005CA  B43C 001B                972mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002005CE  6700 FA38                973mm     BEQ START
002005D2                           974mm     ENDM
002005D2                           975m CONTINUE_54
002005D2  1639 00C00013            976m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002005D8  0803 0000                977m     BTST #0,D3                  ; CHECK FOR CHARACTER
002005DC  67D8                     978m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
002005DE                           979m     
002005DE  1439 00C00017            980m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002005E4  13C2 00E00001            981m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002005EA                           982m     
002005EA                           983m     ENDM
002005EA                           984m         HEX2BIN D2,D2,A0
002005EA  41F9 00201B0A            985m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002005F0  0402 0030                986m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005F4  C4BC 000000FF            987m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002005FA  1430 2000                988m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002005FE                           989m     ENDM
002005FE  8E82                     990          OR.L D2,D7
00200600  E98F                     991          LSL.L #4,D7
00200602                           992m         DOWNLOAD D2,D3         
00200602                           993m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200602                           994m 
00200602  1639 00C00003            995m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200608  0803 0000                996m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020060C  6700 0010                997m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
00200610                           998m  
00200610                           999mm     READ_CHAR D2
00200610                 TRUE     1000mm     IFEQ DEBUG
00200610  1439 00C00007           1001mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200616                          1002mm     ENDC
00200616                 FALSE    1003mm     IFNE DEBUG
00200616                          1004mm     ENDC
00200616                          1005mm      
00200616  B43C 001B               1006mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020061A  6700 F9EC               1007mm     BEQ START
0020061E                          1008mm     ENDM
0020061E                          1009m CONTINUE_57
0020061E  1639 00C00013           1010m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200624  0803 0000               1011m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200628  67D8                    1012m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
0020062A                          1013m     
0020062A  1439 00C00017           1014m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200630  13C2 00E00001           1015m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200636                          1016m     
00200636                          1017m     ENDM
00200636                          1018m         HEX2BIN D2,D2,A0
00200636  41F9 00201B0A           1019m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020063C  0402 0030               1020m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200640  C4BC 000000FF           1021m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200646  1430 2000               1022m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020064A                          1023m     ENDM
0020064A  8E82                    1024          OR.L D2,D7
0020064C                          1025          
0020064C  DC87                    1026          ADD.L D7,D6                 ; add top byte of address into checksum
0020064E                          1027  
0020064E  E98F                    1028          LSL.L #4,D7                 ; bottom byte
00200650                          1029m         DOWNLOAD D2,D3
00200650                          1030m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200650                          1031m 
00200650  1639 00C00003           1032m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200656  0803 0000               1033m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020065A  6700 0010               1034m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
0020065E                          1035m  
0020065E                          1036mm     READ_CHAR D2
0020065E                 TRUE     1037mm     IFEQ DEBUG
0020065E  1439 00C00007           1038mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200664                          1039mm     ENDC
00200664                 FALSE    1040mm     IFNE DEBUG
00200664                          1041mm     ENDC
00200664                          1042mm      
00200664  B43C 001B               1043mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200668  6700 F99E               1044mm     BEQ START
0020066C                          1045mm     ENDM
0020066C                          1046m CONTINUE_60
0020066C  1639 00C00013           1047m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200672  0803 0000               1048m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200676  67D8                    1049m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
00200678                          1050m     
00200678  1439 00C00017           1051m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020067E  13C2 00E00001           1052m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200684                          1053m     
00200684                          1054m     ENDM
00200684                          1055m         HEX2BIN D2,D2,A0
00200684  41F9 00201B0A           1056m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020068A  0402 0030               1057m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020068E  C4BC 000000FF           1058m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200694  1430 2000               1059m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200698                          1060m     ENDM
00200698  8E82                    1061          OR.L D2,D7
0020069A  E98F                    1062          LSL.L #4,D7        
0020069C                          1063m         DOWNLOAD D2,D3
0020069C                          1064m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020069C                          1065m 
0020069C  1639 00C00003           1066m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002006A2  0803 0000               1067m     BTST #0,D3                    ; CHECK FOR CHARACTER
002006A6  6700 0010               1068m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
002006AA                          1069m  
002006AA                          1070mm     READ_CHAR D2
002006AA                 TRUE     1071mm     IFEQ DEBUG
002006AA  1439 00C00007           1072mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002006B0                          1073mm     ENDC
002006B0                 FALSE    1074mm     IFNE DEBUG
002006B0                          1075mm     ENDC
002006B0                          1076mm      
002006B0  B43C 001B               1077mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002006B4  6700 F952               1078mm     BEQ START
002006B8                          1079mm     ENDM
002006B8                          1080m CONTINUE_63
002006B8  1639 00C00013           1081m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002006BE  0803 0000               1082m     BTST #0,D3                  ; CHECK FOR CHARACTER
002006C2  67D8                    1083m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
002006C4                          1084m     
002006C4  1439 00C00017           1085m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002006CA  13C2 00E00001           1086m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002006D0                          1087m     
002006D0                          1088m     ENDM
002006D0                          1089m         HEX2BIN D2,D2,A0
002006D0  41F9 00201B0A           1090m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002006D6  0402 0030               1091m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006DA  C4BC 000000FF           1092m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002006E0  1430 2000               1093m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002006E4                          1094m     ENDM
002006E4  8E82                    1095          OR.L D2,D7
002006E6                          1096          
002006E6  7400                    1097          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
002006E8  1407                    1098          MOVE.B D7,D2
002006EA  DC82                    1099          ADD.L D2,D6
002006EC                          1100          
002006EC  5785                    1101          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
002006EE                          1102          WHILE.L D5 <GT> #0 DO       ; read the data bytes
002006EE                          1103s _10000000
002006EE  BABC 00000000           1104s     CMP.L   #0,D5
002006F4  6F00 00B4               1105s     BLE _10000001
002006F8  5385                    1106              SUB.L #1,D5
002006FA                          1107              
002006FA  7E00                    1108              MOVE.L #0,D7              ; D7 holds the byte
002006FC                          1109              
002006FC                          1110m             DOWNLOAD D2,D3            ; MS 4 bits
002006FC                          1111m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006FC                          1112m 
002006FC  1639 00C00003           1113m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200702  0803 0000               1114m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200706  6700 0010               1115m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
0020070A                          1116m  
0020070A                          1117mm     READ_CHAR D2
0020070A                 TRUE     1118mm     IFEQ DEBUG
0020070A  1439 00C00007           1119mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200710                          1120mm     ENDC
00200710                 FALSE    1121mm     IFNE DEBUG
00200710                          1122mm     ENDC
00200710                          1123mm      
00200710  B43C 001B               1124mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200714  6700 F8F2               1125mm     BEQ START
00200718                          1126mm     ENDM
00200718                          1127m CONTINUE_66
00200718  1639 00C00013           1128m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020071E  0803 0000               1129m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200722  67D8                    1130m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
00200724                          1131m     
00200724  1439 00C00017           1132m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020072A  13C2 00E00001           1133m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200730                          1134m     
00200730                          1135m     ENDM
00200730                          1136m             HEX2BIN D2,D2,A0
00200730  41F9 00201B0A           1137m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200736  0402 0030               1138m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020073A  C4BC 000000FF           1139m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200740  1430 2000               1140m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200744                          1141m     ENDM
00200744  8E82                    1142              OR.L D2,D7
00200746  E98F                    1143              LSL.L #4,D7
00200748                          1144               
00200748                          1145m             DOWNLOAD D2,D3            ; LS 4 bits    
00200748                          1146m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200748                          1147m 
00200748  1639 00C00003           1148m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020074E  0803 0000               1149m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200752  6700 0010               1150m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
00200756                          1151m  
00200756                          1152mm     READ_CHAR D2
00200756                 TRUE     1153mm     IFEQ DEBUG
00200756  1439 00C00007           1154mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020075C                          1155mm     ENDC
0020075C                 FALSE    1156mm     IFNE DEBUG
0020075C                          1157mm     ENDC
0020075C                          1158mm      
0020075C  B43C 001B               1159mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200760  6700 F8A6               1160mm     BEQ START
00200764                          1161mm     ENDM
00200764                          1162m CONTINUE_69
00200764  1639 00C00013           1163m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020076A  0803 0000               1164m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020076E  67D8                    1165m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00200770                          1166m     
00200770  1439 00C00017           1167m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200776  13C2 00E00001           1168m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020077C                          1169m     
0020077C                          1170m     ENDM
0020077C                          1171m             HEX2BIN D2,D2,A0
0020077C  41F9 00201B0A           1172m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200782  0402 0030               1173m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200786  C4BC 000000FF           1174m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020078C  1430 2000               1175m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200790                          1176m     ENDM
00200790  8E82                    1177              OR.L D2,D7
00200792                          1178              
00200792  DC87                    1179              ADD.L D7,D6               ; add into checksum
00200794                          1180            
00200794                          1181m             PRINT_CHAR D7,D3          ; assume ASCII and print it
00200794                          1182m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200794                 TRUE     1183m     IFEQ DEBUG
00200794  1639 00C00003           1184m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020079A  0803 0002               1185m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020079E  67F4                    1186m         BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
002007A0  13C7 00C00007           1187m         MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002007A6                          1188m     ENDC
002007A6                          1189m     
002007A6                 FALSE    1190m     IFNE DEBUG
002007A6                          1191m     ENDC
002007A6                          1192m 
002007A6                          1193m     ENDM
002007A6                          1194          ENDW
002007A6  6000 FF46               1195s     BRA _10000000
002007AA                          1196s _10000001
002007AA                          1197m         PRINT_CRLF D3
002007AA                          1198mm     PRINT_CHAR #13,D3             ; CR
002007AA                          1199mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007AA                 TRUE     1200mm     IFEQ DEBUG
002007AA  1639 00C00003           1201mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007B0  0803 0002               1202mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007B4  67F4                    1203mm         BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
002007B6  13FC 000D 00C00007      1204mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002007BE                          1205mm     ENDC
002007BE                          1206mm     
002007BE                 FALSE    1207mm     IFNE DEBUG
002007BE                          1208mm     ENDC
002007BE                          1209mm 
002007BE                          1210mm     ENDM
002007BE                          1211mm     PRINT_CHAR #10,D3             ; LF
002007BE                          1212mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007BE                 TRUE     1213mm     IFEQ DEBUG
002007BE  1639 00C00003           1214mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002007C4  0803 0002               1215mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002007C8  67F4                    1216mm         BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
002007CA  13FC 000A 00C00007      1217mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002007D2                          1218mm     ENDC
002007D2                          1219mm     
002007D2                 FALSE    1220mm     IFNE DEBUG
002007D2                          1221mm     ENDC
002007D2                          1222mm 
002007D2                          1223mm     ENDM
002007D2                          1224m     ENDM
002007D2  43F9 002004A0           1225         LEA WAIT_FOR_SRECORD,A1            
002007D8                          1226      ELSE
002007D8  6000 0D0E               1227s     BRA _00000001
002007DC                          1228s _00000000
002007DC                          1229          IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
002007DC  BE3C 0031               1230s     CMP.B   #'1',D7
002007E0  6600 04F6               1231s     BNE.L   _00000002
002007E4  7E00                    1232              MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007E6                          1233m             DOWNLOAD D2,D3              ; top byte
002007E6                          1234m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007E6                          1235m 
002007E6  1639 00C00003           1236m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002007EC  0803 0000               1237m     BTST #0,D3                    ; CHECK FOR CHARACTER
002007F0  6700 0010               1238m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
002007F4                          1239m  
002007F4                          1240mm     READ_CHAR D2
002007F4                 TRUE     1241mm     IFEQ DEBUG
002007F4  1439 00C00007           1242mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002007FA                          1243mm     ENDC
002007FA                 FALSE    1244mm     IFNE DEBUG
002007FA                          1245mm     ENDC
002007FA                          1246mm      
002007FA  B43C 001B               1247mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002007FE  6700 F808               1248mm     BEQ START
00200802                          1249mm     ENDM
00200802                          1250m CONTINUE_76
00200802  1639 00C00013           1251m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200808  0803 0000               1252m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020080C  67D8                    1253m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
0020080E                          1254m     
0020080E  1439 00C00017           1255m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200814  13C2 00E00001           1256m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020081A                          1257m     
0020081A                          1258m     ENDM
0020081A                          1259m             PRINT_CHAR D2,D3
0020081A                          1260m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020081A                 TRUE     1261m     IFEQ DEBUG
0020081A  1639 00C00003           1262m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200820  0803 0002               1263m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200824  67F4                    1264m         BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
00200826  13C2 00C00007           1265m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020082C                          1266m     ENDC
0020082C                          1267m     
0020082C                 FALSE    1268m     IFNE DEBUG
0020082C                          1269m     ENDC
0020082C                          1270m 
0020082C                          1271m     ENDM
0020082C                          1272m             HEX2BIN D2,D2,A0
0020082C  41F9 00201B0A           1273m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200832  0402 0030               1274m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200836  C4BC 000000FF           1275m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020083C  1430 2000               1276m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200840                          1277m     ENDM
00200840  8E82                    1278              OR.L D2,D7
00200842  E98F                    1279              LSL.L #4,D7
00200844                          1280m             DOWNLOAD D2,D3         
00200844                          1281m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200844                          1282m 
00200844  1639 00C00003           1283m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020084A  0803 0000               1284m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020084E  6700 0010               1285m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00200852                          1286m  
00200852                          1287mm     READ_CHAR D2
00200852                 TRUE     1288mm     IFEQ DEBUG
00200852  1439 00C00007           1289mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200858                          1290mm     ENDC
00200858                 FALSE    1291mm     IFNE DEBUG
00200858                          1292mm     ENDC
00200858                          1293mm      
00200858  B43C 001B               1294mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020085C  6700 F7AA               1295mm     BEQ START
00200860                          1296mm     ENDM
00200860                          1297m CONTINUE_80
00200860  1639 00C00013           1298m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200866  0803 0000               1299m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020086A  67D8                    1300m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
0020086C                          1301m     
0020086C  1439 00C00017           1302m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200872  13C2 00E00001           1303m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200878                          1304m     
00200878                          1305m     ENDM
00200878                          1306m             PRINT_CHAR D2,D3
00200878                          1307m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1308m     IFEQ DEBUG
00200878  1639 00C00003           1309m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020087E  0803 0002               1310m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200882  67F4                    1311m         BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00200884  13C2 00C00007           1312m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0020088A                          1313m     ENDC
0020088A                          1314m     
0020088A                 FALSE    1315m     IFNE DEBUG
0020088A                          1316m     ENDC
0020088A                          1317m 
0020088A                          1318m     ENDM
0020088A                          1319m             HEX2BIN D2,D2,A0
0020088A  41F9 00201B0A           1320m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200890  0402 0030               1321m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200894  C4BC 000000FF           1322m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020089A  1430 2000               1323m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020089E                          1324m     ENDM
0020089E  8E82                    1325              OR.L D2,D7
002008A0                          1326          
002008A0  DC87                    1327              ADD.L D7,D6                 ; add top byte of address into checksum
002008A2                          1328  
002008A2  E98F                    1329              LSL.L #4,D7                 ; bottom byte
002008A4                          1330m             DOWNLOAD D2,D3
002008A4                          1331m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A4                          1332m 
002008A4  1639 00C00003           1333m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002008AA  0803 0000               1334m     BTST #0,D3                    ; CHECK FOR CHARACTER
002008AE  6700 0010               1335m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
002008B2                          1336m  
002008B2                          1337mm     READ_CHAR D2
002008B2                 TRUE     1338mm     IFEQ DEBUG
002008B2  1439 00C00007           1339mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002008B8                          1340mm     ENDC
002008B8                 FALSE    1341mm     IFNE DEBUG
002008B8                          1342mm     ENDC
002008B8                          1343mm      
002008B8  B43C 001B               1344mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002008BC  6700 F74A               1345mm     BEQ START
002008C0                          1346mm     ENDM
002008C0                          1347m CONTINUE_84
002008C0  1639 00C00013           1348m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002008C6  0803 0000               1349m     BTST #0,D3                  ; CHECK FOR CHARACTER
002008CA  67D8                    1350m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
002008CC                          1351m     
002008CC  1439 00C00017           1352m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002008D2  13C2 00E00001           1353m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002008D8                          1354m     
002008D8                          1355m     ENDM
002008D8                          1356m             PRINT_CHAR D2,D3
002008D8                          1357m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1358m     IFEQ DEBUG
002008D8  1639 00C00003           1359m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002008DE  0803 0002               1360m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1361m         BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
002008E4  13C2 00C00007           1362m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002008EA                          1363m     ENDC
002008EA                          1364m     
002008EA                 FALSE    1365m     IFNE DEBUG
002008EA                          1366m     ENDC
002008EA                          1367m 
002008EA                          1368m     ENDM
002008EA                          1369m             HEX2BIN D2,D2,A0
002008EA  41F9 00201B0A           1370m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002008F0  0402 0030               1371m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F4  C4BC 000000FF           1372m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002008FA  1430 2000               1373m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002008FE                          1374m     ENDM
002008FE  8E82                    1375              OR.L D2,D7
00200900  E98F                    1376              LSL.L #4,D7        
00200902                          1377m             DOWNLOAD D2,D3
00200902                          1378m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200902                          1379m 
00200902  1639 00C00003           1380m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200908  0803 0000               1381m     BTST #0,D3                    ; CHECK FOR CHARACTER
0020090C  6700 0010               1382m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
00200910                          1383m  
00200910                          1384mm     READ_CHAR D2
00200910                 TRUE     1385mm     IFEQ DEBUG
00200910  1439 00C00007           1386mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200916                          1387mm     ENDC
00200916                 FALSE    1388mm     IFNE DEBUG
00200916                          1389mm     ENDC
00200916                          1390mm      
00200916  B43C 001B               1391mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020091A  6700 F6EC               1392mm     BEQ START
0020091E                          1393mm     ENDM
0020091E                          1394m CONTINUE_88
0020091E  1639 00C00013           1395m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200924  0803 0000               1396m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200928  67D8                    1397m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
0020092A                          1398m     
0020092A  1439 00C00017           1399m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200930  13C2 00E00001           1400m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200936                          1401m     
00200936                          1402m     ENDM
00200936                          1403m             PRINT_CHAR D2,D3
00200936                          1404m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200936                 TRUE     1405m     IFEQ DEBUG
00200936  1639 00C00003           1406m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020093C  0803 0002               1407m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200940  67F4                    1408m         BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00200942  13C2 00C00007           1409m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200948                          1410m     ENDC
00200948                          1411m     
00200948                 FALSE    1412m     IFNE DEBUG
00200948                          1413m     ENDC
00200948                          1414m 
00200948                          1415m     ENDM
00200948                          1416m             HEX2BIN D2,D2,A0
00200948  41F9 00201B0A           1417m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020094E  0402 0030               1418m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200952  C4BC 000000FF           1419m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200958  1430 2000               1420m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020095C                          1421m     ENDM
0020095C  8E82                    1422              OR.L D2,D7
0020095E                          1423          
0020095E  7400                    1424              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200960  1407                    1425              MOVE.B D7,D2
00200962  DC82                    1426              ADD.L D2,D6
00200964                          1427          
00200964  DE8B                    1428              ADD.L A3,D7                 ; add in the offset
00200966                          1429          
00200966  5785                    1430              SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
00200968                          1431          
00200968  0807 0000               1432              BTST #0,D7                  ; deal with odd addresses
0020096C                          1433  
0020096C  2247                    1434              MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
0020096E  6700 00D0               1435              BEQ EVEN
00200972                          1436                  
00200972  5385                    1437              SUB.L #1,D5
00200974  5389                    1438              SUB.L #1,A1
00200976                          1439          
00200976  7E00                    1440              MOVE.L #0,D7
00200978                          1441m             DOWNLOAD D2,D3            ; MS 4 bits
00200978                          1442m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200978                          1443m 
00200978  1639 00C00003           1444m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020097E  0803 0000               1445m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200982  6700 0010               1446m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
00200986                          1447m  
00200986                          1448mm     READ_CHAR D2
00200986                 TRUE     1449mm     IFEQ DEBUG
00200986  1439 00C00007           1450mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020098C                          1451mm     ENDC
0020098C                 FALSE    1452mm     IFNE DEBUG
0020098C                          1453mm     ENDC
0020098C                          1454mm      
0020098C  B43C 001B               1455mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200990  6700 F676               1456mm     BEQ START
00200994                          1457mm     ENDM
00200994                          1458m CONTINUE_92
00200994  1639 00C00013           1459m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020099A  0803 0000               1460m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020099E  67D8                    1461m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
002009A0                          1462m     
002009A0  1439 00C00017           1463m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002009A6  13C2 00E00001           1464m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002009AC                          1465m     
002009AC                          1466m     ENDM
002009AC                          1467m             PRINT_CHAR D2,D3
002009AC                          1468m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009AC                 TRUE     1469m     IFEQ DEBUG
002009AC  1639 00C00003           1470m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002009B2  0803 0002               1471m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002009B6  67F4                    1472m         BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
002009B8  13C2 00C00007           1473m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002009BE                          1474m     ENDC
002009BE                          1475m     
002009BE                 FALSE    1476m     IFNE DEBUG
002009BE                          1477m     ENDC
002009BE                          1478m 
002009BE                          1479m     ENDM
002009BE                          1480m             HEX2BIN D2,D2,A0
002009BE  41F9 00201B0A           1481m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002009C4  0402 0030               1482m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009C8  C4BC 000000FF           1483m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002009CE  1430 2000               1484m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002009D2                          1485m     ENDM
002009D2  8E82                    1486              OR.L D2,D7
002009D4  E98F                    1487              LSL.L #4,D7
002009D6                          1488               
002009D6                          1489m             DOWNLOAD D2,D3            ; LS 4 bits    
002009D6                          1490m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                          1491m 
002009D6  1639 00C00003           1492m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002009DC  0803 0000               1493m     BTST #0,D3                    ; CHECK FOR CHARACTER
002009E0  6700 0010               1494m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
002009E4                          1495m  
002009E4                          1496mm     READ_CHAR D2
002009E4                 TRUE     1497mm     IFEQ DEBUG
002009E4  1439 00C00007           1498mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002009EA                          1499mm     ENDC
002009EA                 FALSE    1500mm     IFNE DEBUG
002009EA                          1501mm     ENDC
002009EA                          1502mm      
002009EA  B43C 001B               1503mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002009EE  6700 F618               1504mm     BEQ START
002009F2                          1505mm     ENDM
002009F2                          1506m CONTINUE_96
002009F2  1639 00C00013           1507m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002009F8  0803 0000               1508m     BTST #0,D3                  ; CHECK FOR CHARACTER
002009FC  67D8                    1509m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
002009FE                          1510m     
002009FE  1439 00C00017           1511m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A04  13C2 00E00001           1512m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A0A                          1513m     
00200A0A                          1514m     ENDM
00200A0A                          1515m             PRINT_CHAR D2,D3
00200A0A                          1516m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A0A                 TRUE     1517m     IFEQ DEBUG
00200A0A  1639 00C00003           1518m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A10  0803 0002               1519m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A14  67F4                    1520m         BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
00200A16  13C2 00C00007           1521m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A1C                          1522m     ENDC
00200A1C                          1523m     
00200A1C                 FALSE    1524m     IFNE DEBUG
00200A1C                          1525m     ENDC
00200A1C                          1526m 
00200A1C                          1527m     ENDM
00200A1C                          1528m             HEX2BIN D2,D2,A0
00200A1C  41F9 00201B0A           1529m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A22  0402 0030               1530m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A26  C4BC 000000FF           1531m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200A2C  1430 2000               1532m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200A30                          1533m     ENDM
00200A30  8E82                    1534              OR.L D2,D7
00200A32                          1535                          
00200A32  DC87                    1536              ADD.L D7,D6               ; add into checksum
00200A34                          1537                        
00200A34  3611                    1538              MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200A36                          1539          
00200A36  0243 FF00               1540              ANDI.W #$FF00,D3
00200A3A  8647                    1541              OR.W D7,D3
00200A3C                          1542          
00200A3C  3283                    1543              MOVE.W D3,(A1)           ; store it!
00200A3E  5489                    1544              ADD.L #2,A1
00200A40                          1545  EVEN        
00200A40                          1546              WHILE.L D5 <GE> #2 DO       ; read the data bytes
00200A40                          1547s _10000002
00200A40  BABC 00000002           1548s     CMP.L   #2,D5
00200A46  6D00 018A               1549s     BLT _10000003
00200A4A  5585                    1550                  SUB.L #2,D5
00200A4C  7E00                    1551                  MOVE.L #0,D7              ; D7 holds the word
00200A4E                          1552              
00200A4E                          1553m                 DOWNLOAD D2,D3            ; MS 4 bits
00200A4E                          1554m WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4E                          1555m 
00200A4E  1639 00C00003           1556m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200A54  0803 0000               1557m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200A58  6700 0010               1558m     BEQ CONTINUE_100                ; NOTHING, CONTINUE
00200A5C                          1559m  
00200A5C                          1560mm     READ_CHAR D2
00200A5C                 TRUE     1561mm     IFEQ DEBUG
00200A5C  1439 00C00007           1562mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200A62                          1563mm     ENDC
00200A62                 FALSE    1564mm     IFNE DEBUG
00200A62                          1565mm     ENDC
00200A62                          1566mm      
00200A62  B43C 001B               1567mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200A66  6700 F5A0               1568mm     BEQ START
00200A6A                          1569mm     ENDM
00200A6A                          1570m CONTINUE_100
00200A6A  1639 00C00013           1571m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200A70  0803 0000               1572m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200A74  67D8                    1573m     BEQ WAIT_FOR_READY_100        ; NOTHING, CHECK AGAIN
00200A76                          1574m     
00200A76  1439 00C00017           1575m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200A7C  13C2 00E00001           1576m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200A82                          1577m     
00200A82                          1578m     ENDM
00200A82                          1579m                 PRINT_CHAR D2,D3
00200A82                          1580m WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A82                 TRUE     1581m     IFEQ DEBUG
00200A82  1639 00C00003           1582m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200A88  0803 0002               1583m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200A8C  67F4                    1584m         BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00200A8E  13C2 00C00007           1585m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200A94                          1586m     ENDC
00200A94                          1587m     
00200A94                 FALSE    1588m     IFNE DEBUG
00200A94                          1589m     ENDC
00200A94                          1590m 
00200A94                          1591m     ENDM
00200A94                          1592m                 HEX2BIN D2,D2,A0
00200A94  41F9 00201B0A           1593m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200A9A  0402 0030               1594m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A9E  C4BC 000000FF           1595m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200AA4  1430 2000               1596m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200AA8                          1597m     ENDM
00200AA8  8E82                    1598                  OR.L D2,D7
00200AAA  E98F                    1599                  LSL.L #4,D7
00200AAC                          1600               
00200AAC                          1601m                 DOWNLOAD D2,D3            ; LS 4 bits    
00200AAC                          1602m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAC                          1603m 
00200AAC  1639 00C00003           1604m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200AB2  0803 0000               1605m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200AB6  6700 0010               1606m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00200ABA                          1607m  
00200ABA                          1608mm     READ_CHAR D2
00200ABA                 TRUE     1609mm     IFEQ DEBUG
00200ABA  1439 00C00007           1610mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200AC0                          1611mm     ENDC
00200AC0                 FALSE    1612mm     IFNE DEBUG
00200AC0                          1613mm     ENDC
00200AC0                          1614mm      
00200AC0  B43C 001B               1615mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200AC4  6700 F542               1616mm     BEQ START
00200AC8                          1617mm     ENDM
00200AC8                          1618m CONTINUE_104
00200AC8  1639 00C00013           1619m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200ACE  0803 0000               1620m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200AD2  67D8                    1621m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00200AD4                          1622m     
00200AD4  1439 00C00017           1623m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200ADA  13C2 00E00001           1624m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200AE0                          1625m     
00200AE0                          1626m     ENDM
00200AE0                          1627m                 PRINT_CHAR D2,D3
00200AE0                          1628m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1629m     IFEQ DEBUG
00200AE0  1639 00C00003           1630m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200AE6  0803 0002               1631m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1632m         BEQ WAIT_FOR_READY_106          ; NO SPACE, CHECK AGAIN
00200AEC  13C2 00C00007           1633m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200AF2                          1634m     ENDC
00200AF2                          1635m     
00200AF2                 FALSE    1636m     IFNE DEBUG
00200AF2                          1637m     ENDC
00200AF2                          1638m 
00200AF2                          1639m     ENDM
00200AF2                          1640m                 HEX2BIN D2,D2,A0
00200AF2  41F9 00201B0A           1641m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200AF8  0402 0030               1642m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AFC  C4BC 000000FF           1643m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B02  1430 2000               1644m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B06                          1645m     ENDM
00200B06  8E82                    1646                  OR.L D2,D7
00200B08                          1647                          
00200B08  DC87                    1648                  ADD.L D7,D6               ; add into checksum
00200B0A                          1649              
00200B0A  E98F                    1650                  LSL.L #4,D7
00200B0C                          1651m                 DOWNLOAD D2,D3            ; MS 4 bits
00200B0C                          1652m WAIT_FOR_READY_108                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0C                          1653m 
00200B0C  1639 00C00003           1654m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B12  0803 0000               1655m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B16  6700 0010               1656m     BEQ CONTINUE_108                ; NOTHING, CONTINUE
00200B1A                          1657m  
00200B1A                          1658mm     READ_CHAR D2
00200B1A                 TRUE     1659mm     IFEQ DEBUG
00200B1A  1439 00C00007           1660mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B20                          1661mm     ENDC
00200B20                 FALSE    1662mm     IFNE DEBUG
00200B20                          1663mm     ENDC
00200B20                          1664mm      
00200B20  B43C 001B               1665mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B24  6700 F4E2               1666mm     BEQ START
00200B28                          1667mm     ENDM
00200B28                          1668m CONTINUE_108
00200B28  1639 00C00013           1669m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B2E  0803 0000               1670m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B32  67D8                    1671m     BEQ WAIT_FOR_READY_108        ; NOTHING, CHECK AGAIN
00200B34                          1672m     
00200B34  1439 00C00017           1673m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B3A  13C2 00E00001           1674m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B40                          1675m     
00200B40                          1676m     ENDM
00200B40                          1677m                 PRINT_CHAR D2,D3
00200B40                          1678m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B40                 TRUE     1679m     IFEQ DEBUG
00200B40  1639 00C00003           1680m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200B46  0803 0002               1681m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200B4A  67F4                    1682m         BEQ WAIT_FOR_READY_110          ; NO SPACE, CHECK AGAIN
00200B4C  13C2 00C00007           1683m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200B52                          1684m     ENDC
00200B52                          1685m     
00200B52                 FALSE    1686m     IFNE DEBUG
00200B52                          1687m     ENDC
00200B52                          1688m 
00200B52                          1689m     ENDM
00200B52                          1690m                 HEX2BIN D2,D2,A0
00200B52  41F9 00201B0A           1691m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200B58  0402 0030               1692m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B5C  C4BC 000000FF           1693m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200B62  1430 2000               1694m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200B66                          1695m     ENDM
00200B66  8E82                    1696                  OR.L D2,D7
00200B68                          1697               
00200B68  E98F                    1698                  LSL.L #4,D7
00200B6A                          1699m                 DOWNLOAD D2,D3            ; LS 4 bits    
00200B6A                          1700m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B6A                          1701m 
00200B6A  1639 00C00003           1702m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200B70  0803 0000               1703m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200B74  6700 0010               1704m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00200B78                          1705m  
00200B78                          1706mm     READ_CHAR D2
00200B78                 TRUE     1707mm     IFEQ DEBUG
00200B78  1439 00C00007           1708mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200B7E                          1709mm     ENDC
00200B7E                 FALSE    1710mm     IFNE DEBUG
00200B7E                          1711mm     ENDC
00200B7E                          1712mm      
00200B7E  B43C 001B               1713mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200B82  6700 F484               1714mm     BEQ START
00200B86                          1715mm     ENDM
00200B86                          1716m CONTINUE_112
00200B86  1639 00C00013           1717m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200B8C  0803 0000               1718m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200B90  67D8                    1719m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00200B92                          1720m     
00200B92  1439 00C00017           1721m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200B98  13C2 00E00001           1722m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200B9E                          1723m     
00200B9E                          1724m     ENDM
00200B9E                          1725m                 PRINT_CHAR D2,D3
00200B9E                          1726m WAIT_FOR_READY_114                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B9E                 TRUE     1727m     IFEQ DEBUG
00200B9E  1639 00C00003           1728m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200BA4  0803 0002               1729m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200BA8  67F4                    1730m         BEQ WAIT_FOR_READY_114          ; NO SPACE, CHECK AGAIN
00200BAA  13C2 00C00007           1731m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200BB0                          1732m     ENDC
00200BB0                          1733m     
00200BB0                 FALSE    1734m     IFNE DEBUG
00200BB0                          1735m     ENDC
00200BB0                          1736m 
00200BB0                          1737m     ENDM
00200BB0                          1738m                 HEX2BIN D2,D2,A0
00200BB0  41F9 00201B0A           1739m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200BB6  0402 0030               1740m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BBA  C4BC 000000FF           1741m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200BC0  1430 2000               1742m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200BC4                          1743m     ENDM
00200BC4  8E82                    1744                  OR.L D2,D7
00200BC6                          1745              
00200BC6  7400                    1746                  MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00200BC8  1407                    1747                  MOVE.B D7,D2
00200BCA  DC82                    1748                  ADD.L D2,D6
00200BCC                          1749              
00200BCC  32C7                    1750                  MOVE.W D7,(A1)+          ; store it!
00200BCE                          1751              ENDW
00200BCE  6000 FE70               1752s     BRA _10000002
00200BD2                          1753s _10000003
00200BD2                          1754          
00200BD2                          1755              IF D5 <EQ> #1 THEN
00200BD2  BA7C 0001               1756s     CMP.W   #1,D5
00200BD6  6600 00CE               1757s     BNE _00000003
00200BDA  7E00                    1758                  MOVE.L #0,D7              ; D7 holds the word
00200BDC                          1759                      
00200BDC                          1760m                 DOWNLOAD D2,D3            ; MS 4 bits
00200BDC                          1761m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BDC                          1762m 
00200BDC  1639 00C00003           1763m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200BE2  0803 0000               1764m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200BE6  6700 0010               1765m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00200BEA                          1766m  
00200BEA                          1767mm     READ_CHAR D2
00200BEA                 TRUE     1768mm     IFEQ DEBUG
00200BEA  1439 00C00007           1769mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200BF0                          1770mm     ENDC
00200BF0                 FALSE    1771mm     IFNE DEBUG
00200BF0                          1772mm     ENDC
00200BF0                          1773mm      
00200BF0  B43C 001B               1774mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200BF4  6700 F412               1775mm     BEQ START
00200BF8                          1776mm     ENDM
00200BF8                          1777m CONTINUE_116
00200BF8  1639 00C00013           1778m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200BFE  0803 0000               1779m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C02  67D8                    1780m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00200C04                          1781m     
00200C04  1439 00C00017           1782m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C0A  13C2 00E00001           1783m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C10                          1784m     
00200C10                          1785m     ENDM
00200C10                          1786m                 PRINT_CHAR D2,D3
00200C10                          1787m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C10                 TRUE     1788m     IFEQ DEBUG
00200C10  1639 00C00003           1789m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C16  0803 0002               1790m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C1A  67F4                    1791m         BEQ WAIT_FOR_READY_118          ; NO SPACE, CHECK AGAIN
00200C1C  13C2 00C00007           1792m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C22                          1793m     ENDC
00200C22                          1794m     
00200C22                 FALSE    1795m     IFNE DEBUG
00200C22                          1796m     ENDC
00200C22                          1797m 
00200C22                          1798m     ENDM
00200C22                          1799m                 HEX2BIN D2,D2,A0
00200C22  41F9 00201B0A           1800m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C28  0402 0030               1801m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C2C  C4BC 000000FF           1802m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C32  1430 2000               1803m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C36                          1804m     ENDM
00200C36  8E82                    1805                  OR.L D2,D7
00200C38  E98F                    1806              LSL.L #4,D7
00200C3A                          1807               
00200C3A                          1808m             DOWNLOAD D2,D3            ; LS 4 bits    
00200C3A                          1809m WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C3A                          1810m 
00200C3A  1639 00C00003           1811m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200C40  0803 0000               1812m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200C44  6700 0010               1813m     BEQ CONTINUE_120                ; NOTHING, CONTINUE
00200C48                          1814m  
00200C48                          1815mm     READ_CHAR D2
00200C48                 TRUE     1816mm     IFEQ DEBUG
00200C48  1439 00C00007           1817mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200C4E                          1818mm     ENDC
00200C4E                 FALSE    1819mm     IFNE DEBUG
00200C4E                          1820mm     ENDC
00200C4E                          1821mm      
00200C4E  B43C 001B               1822mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200C52  6700 F3B4               1823mm     BEQ START
00200C56                          1824mm     ENDM
00200C56                          1825m CONTINUE_120
00200C56  1639 00C00013           1826m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200C5C  0803 0000               1827m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200C60  67D8                    1828m     BEQ WAIT_FOR_READY_120        ; NOTHING, CHECK AGAIN
00200C62                          1829m     
00200C62  1439 00C00017           1830m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200C68  13C2 00E00001           1831m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200C6E                          1832m     
00200C6E                          1833m     ENDM
00200C6E                          1834m             PRINT_CHAR D2,D3
00200C6E                          1835m WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6E                 TRUE     1836m     IFEQ DEBUG
00200C6E  1639 00C00003           1837m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200C74  0803 0002               1838m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200C78  67F4                    1839m         BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00200C7A  13C2 00C00007           1840m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200C80                          1841m     ENDC
00200C80                          1842m     
00200C80                 FALSE    1843m     IFNE DEBUG
00200C80                          1844m     ENDC
00200C80                          1845m 
00200C80                          1846m     ENDM
00200C80                          1847m             HEX2BIN D2,D2,A0
00200C80  41F9 00201B0A           1848m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200C86  0402 0030               1849m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C8A  C4BC 000000FF           1850m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200C90  1430 2000               1851m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200C94                          1852m     ENDM
00200C94  8E82                    1853              OR.L D2,D7
00200C96                          1854                          
00200C96  DC87                    1855              ADD.L D7,D6               ; add into checksum
00200C98                          1856              
00200C98  3611                    1857              MOVE.W (A1),D3            ; get the current data and replace the top byte
00200C9A  E18F                    1858              LSL.L #8,D7
00200C9C  C6BC 000000FF           1859              AND.L #$00FF,D3
00200CA2  8687                    1860              OR.L D7,D3
00200CA4                          1861  
00200CA4  32C3                    1862              MOVE.W D3,(A1)+          ; store it!
00200CA6                          1863          ENDI
00200CA6                          1864s _00000003
00200CA6                          1865    
00200CA6                          1866m         PRINT_CRLF D3
00200CA6                          1867mm     PRINT_CHAR #13,D3             ; CR
00200CA6                          1868mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CA6                 TRUE     1869mm     IFEQ DEBUG
00200CA6  1639 00C00003           1870mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CAC  0803 0002               1871mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CB0  67F4                    1872mm         BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00200CB2  13FC 000D 00C00007      1873mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CBA                          1874mm     ENDC
00200CBA                          1875mm     
00200CBA                 FALSE    1876mm     IFNE DEBUG
00200CBA                          1877mm     ENDC
00200CBA                          1878mm 
00200CBA                          1879mm     ENDM
00200CBA                          1880mm     PRINT_CHAR #10,D3             ; LF
00200CBA                          1881mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBA                 TRUE     1882mm     IFEQ DEBUG
00200CBA  1639 00C00003           1883mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200CC0  0803 0002               1884mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200CC4  67F4                    1885mm         BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00200CC6  13FC 000A 00C00007      1886mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00200CCE                          1887mm     ENDC
00200CCE                          1888mm     
00200CCE                 FALSE    1889mm     IFNE DEBUG
00200CCE                          1890mm     ENDC
00200CCE                          1891mm 
00200CCE                          1892mm     ENDM
00200CCE                          1893m     ENDM
00200CCE  43F9 002004A0           1894          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00200CD4                          1895        ELSE
00200CD4  6000 0812               1896s     BRA _00000004
00200CD8                          1897s _00000002
00200CD8                          1898              IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00200CD8  BE3C 0032               1899s     CMP.B   #'2',D7
00200CDC  6600 05BA               1900s     BNE.L   _00000005
00200CE0  7E00                    1901                  MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200CE2                          1902m                 DOWNLOAD D2,D3              ; top byte
00200CE2                          1903m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE2                          1904m 
00200CE2  1639 00C00003           1905m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200CE8  0803 0000               1906m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200CEC  6700 0010               1907m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00200CF0                          1908m  
00200CF0                          1909mm     READ_CHAR D2
00200CF0                 TRUE     1910mm     IFEQ DEBUG
00200CF0  1439 00C00007           1911mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200CF6                          1912mm     ENDC
00200CF6                 FALSE    1913mm     IFNE DEBUG
00200CF6                          1914mm     ENDC
00200CF6                          1915mm      
00200CF6  B43C 001B               1916mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200CFA  6700 F30C               1917mm     BEQ START
00200CFE                          1918mm     ENDM
00200CFE                          1919m CONTINUE_127
00200CFE  1639 00C00013           1920m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D04  0803 0000               1921m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D08  67D8                    1922m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00200D0A                          1923m     
00200D0A  1439 00C00017           1924m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D10  13C2 00E00001           1925m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D16                          1926m     
00200D16                          1927m     ENDM
00200D16                          1928m                 PRINT_CHAR D2,D3
00200D16                          1929m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D16                 TRUE     1930m     IFEQ DEBUG
00200D16  1639 00C00003           1931m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D1C  0803 0002               1932m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D20  67F4                    1933m         BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00200D22  13C2 00C00007           1934m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D28                          1935m     ENDC
00200D28                          1936m     
00200D28                 FALSE    1937m     IFNE DEBUG
00200D28                          1938m     ENDC
00200D28                          1939m 
00200D28                          1940m     ENDM
00200D28                          1941m                 HEX2BIN D2,D2,A0
00200D28  41F9 00201B0A           1942m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D2E  0402 0030               1943m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D32  C4BC 000000FF           1944m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D38  1430 2000               1945m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D3C                          1946m     ENDM
00200D3C  8E82                    1947                  OR.L D2,D7
00200D3E  E98F                    1948                  LSL.L #4,D7
00200D40                          1949m                 DOWNLOAD D2,D3         
00200D40                          1950m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D40                          1951m 
00200D40  1639 00C00003           1952m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200D46  0803 0000               1953m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200D4A  6700 0010               1954m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00200D4E                          1955m  
00200D4E                          1956mm     READ_CHAR D2
00200D4E                 TRUE     1957mm     IFEQ DEBUG
00200D4E  1439 00C00007           1958mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200D54                          1959mm     ENDC
00200D54                 FALSE    1960mm     IFNE DEBUG
00200D54                          1961mm     ENDC
00200D54                          1962mm      
00200D54  B43C 001B               1963mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200D58  6700 F2AE               1964mm     BEQ START
00200D5C                          1965mm     ENDM
00200D5C                          1966m CONTINUE_131
00200D5C  1639 00C00013           1967m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200D62  0803 0000               1968m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200D66  67D8                    1969m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00200D68                          1970m     
00200D68  1439 00C00017           1971m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200D6E  13C2 00E00001           1972m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200D74                          1973m     
00200D74                          1974m     ENDM
00200D74                          1975m                 PRINT_CHAR D2,D3
00200D74                          1976m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D74                 TRUE     1977m     IFEQ DEBUG
00200D74  1639 00C00003           1978m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200D7A  0803 0002               1979m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200D7E  67F4                    1980m         BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00200D80  13C2 00C00007           1981m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200D86                          1982m     ENDC
00200D86                          1983m     
00200D86                 FALSE    1984m     IFNE DEBUG
00200D86                          1985m     ENDC
00200D86                          1986m 
00200D86                          1987m     ENDM
00200D86                          1988m                 HEX2BIN D2,D2,A0
00200D86  41F9 00201B0A           1989m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200D8C  0402 0030               1990m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D90  C4BC 000000FF           1991m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200D96  1430 2000               1992m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200D9A                          1993m     ENDM
00200D9A  8E82                    1994                  OR.L D2,D7
00200D9C                          1995                  
00200D9C  DC87                    1996                  ADD.L D7,D6                 ; add top byte of address into checksum
00200D9E                          1997  
00200D9E  E98F                    1998                  LSL.L #4,D7                 ; middle byte
00200DA0                          1999m                 DOWNLOAD D2,D3
00200DA0                          2000m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA0                          2001m 
00200DA0  1639 00C00003           2002m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200DA6  0803 0000               2003m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200DAA  6700 0010               2004m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00200DAE                          2005m  
00200DAE                          2006mm     READ_CHAR D2
00200DAE                 TRUE     2007mm     IFEQ DEBUG
00200DAE  1439 00C00007           2008mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200DB4                          2009mm     ENDC
00200DB4                 FALSE    2010mm     IFNE DEBUG
00200DB4                          2011mm     ENDC
00200DB4                          2012mm      
00200DB4  B43C 001B               2013mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200DB8  6700 F24E               2014mm     BEQ START
00200DBC                          2015mm     ENDM
00200DBC                          2016m CONTINUE_135
00200DBC  1639 00C00013           2017m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200DC2  0803 0000               2018m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200DC6  67D8                    2019m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00200DC8                          2020m     
00200DC8  1439 00C00017           2021m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200DCE  13C2 00E00001           2022m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200DD4                          2023m     
00200DD4                          2024m     ENDM
00200DD4                          2025m                 PRINT_CHAR D2,D3
00200DD4                          2026m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DD4                 TRUE     2027m     IFEQ DEBUG
00200DD4  1639 00C00003           2028m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200DDA  0803 0002               2029m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200DDE  67F4                    2030m         BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00200DE0  13C2 00C00007           2031m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200DE6                          2032m     ENDC
00200DE6                          2033m     
00200DE6                 FALSE    2034m     IFNE DEBUG
00200DE6                          2035m     ENDC
00200DE6                          2036m 
00200DE6                          2037m     ENDM
00200DE6                          2038m                 HEX2BIN D2,D2,A0
00200DE6  41F9 00201B0A           2039m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200DEC  0402 0030               2040m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF0  C4BC 000000FF           2041m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200DF6  1430 2000               2042m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200DFA                          2043m     ENDM
00200DFA  8E82                    2044                  OR.L D2,D7
00200DFC  E98F                    2045                  LSL.L #4,D7        
00200DFE                          2046m                 DOWNLOAD D2,D3
00200DFE                          2047m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DFE                          2048m 
00200DFE  1639 00C00003           2049m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E04  0803 0000               2050m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E08  6700 0010               2051m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00200E0C                          2052m  
00200E0C                          2053mm     READ_CHAR D2
00200E0C                 TRUE     2054mm     IFEQ DEBUG
00200E0C  1439 00C00007           2055mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E12                          2056mm     ENDC
00200E12                 FALSE    2057mm     IFNE DEBUG
00200E12                          2058mm     ENDC
00200E12                          2059mm      
00200E12  B43C 001B               2060mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E16  6700 F1F0               2061mm     BEQ START
00200E1A                          2062mm     ENDM
00200E1A                          2063m CONTINUE_139
00200E1A  1639 00C00013           2064m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E20  0803 0000               2065m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E24  67D8                    2066m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00200E26                          2067m     
00200E26  1439 00C00017           2068m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E2C  13C2 00E00001           2069m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E32                          2070m     
00200E32                          2071m     ENDM
00200E32                          2072m                 PRINT_CHAR D2,D3
00200E32                          2073m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E32                 TRUE     2074m     IFEQ DEBUG
00200E32  1639 00C00003           2075m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E38  0803 0002               2076m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200E3C  67F4                    2077m         BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00200E3E  13C2 00C00007           2078m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200E44                          2079m     ENDC
00200E44                          2080m     
00200E44                 FALSE    2081m     IFNE DEBUG
00200E44                          2082m     ENDC
00200E44                          2083m 
00200E44                          2084m     ENDM
00200E44                          2085m                 HEX2BIN D2,D2,A0
00200E44  41F9 00201B0A           2086m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200E4A  0402 0030               2087m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E4E  C4BC 000000FF           2088m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200E54  1430 2000               2089m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200E58                          2090m     ENDM
00200E58  8E82                    2091                  OR.L D2,D7
00200E5A                          2092                  
00200E5A  7400                    2093                  MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00200E5C  1407                    2094                  MOVE.B D7,D2
00200E5E  DC82                    2095                  ADD.L D2,D6
00200E60                          2096            
00200E60  E98F                    2097                  LSL.L #4,D7                 ; bottom byte
00200E62                          2098m                 DOWNLOAD D2,D3
00200E62                          2099m WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                          2100m 
00200E62  1639 00C00003           2101m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200E68  0803 0000               2102m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200E6C  6700 0010               2103m     BEQ CONTINUE_143                ; NOTHING, CONTINUE
00200E70                          2104m  
00200E70                          2105mm     READ_CHAR D2
00200E70                 TRUE     2106mm     IFEQ DEBUG
00200E70  1439 00C00007           2107mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200E76                          2108mm     ENDC
00200E76                 FALSE    2109mm     IFNE DEBUG
00200E76                          2110mm     ENDC
00200E76                          2111mm      
00200E76  B43C 001B               2112mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200E7A  6700 F18C               2113mm     BEQ START
00200E7E                          2114mm     ENDM
00200E7E                          2115m CONTINUE_143
00200E7E  1639 00C00013           2116m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200E84  0803 0000               2117m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200E88  67D8                    2118m     BEQ WAIT_FOR_READY_143        ; NOTHING, CHECK AGAIN
00200E8A                          2119m     
00200E8A  1439 00C00017           2120m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200E90  13C2 00E00001           2121m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200E96                          2122m     
00200E96                          2123m     ENDM
00200E96                          2124m                 PRINT_CHAR D2,D3
00200E96                          2125m WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E96                 TRUE     2126m     IFEQ DEBUG
00200E96  1639 00C00003           2127m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200E9C  0803 0002               2128m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200EA0  67F4                    2129m         BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00200EA2  13C2 00C00007           2130m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200EA8                          2131m     ENDC
00200EA8                          2132m     
00200EA8                 FALSE    2133m     IFNE DEBUG
00200EA8                          2134m     ENDC
00200EA8                          2135m 
00200EA8                          2136m     ENDM
00200EA8                          2137m                 HEX2BIN D2,D2,A0
00200EA8  41F9 00201B0A           2138m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200EAE  0402 0030               2139m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EB2  C4BC 000000FF           2140m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200EB8  1430 2000               2141m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200EBC                          2142m     ENDM
00200EBC  8E82                    2143                  OR.L D2,D7
00200EBE  E98F                    2144                  LSL.L #4,D7        
00200EC0                          2145m                 DOWNLOAD D2,D3
00200EC0                          2146m WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC0                          2147m 
00200EC0  1639 00C00003           2148m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200EC6  0803 0000               2149m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200ECA  6700 0010               2150m     BEQ CONTINUE_147                ; NOTHING, CONTINUE
00200ECE                          2151m  
00200ECE                          2152mm     READ_CHAR D2
00200ECE                 TRUE     2153mm     IFEQ DEBUG
00200ECE  1439 00C00007           2154mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200ED4                          2155mm     ENDC
00200ED4                 FALSE    2156mm     IFNE DEBUG
00200ED4                          2157mm     ENDC
00200ED4                          2158mm      
00200ED4  B43C 001B               2159mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200ED8  6700 F12E               2160mm     BEQ START
00200EDC                          2161mm     ENDM
00200EDC                          2162m CONTINUE_147
00200EDC  1639 00C00013           2163m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200EE2  0803 0000               2164m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200EE6  67D8                    2165m     BEQ WAIT_FOR_READY_147        ; NOTHING, CHECK AGAIN
00200EE8                          2166m     
00200EE8  1439 00C00017           2167m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200EEE  13C2 00E00001           2168m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200EF4                          2169m     
00200EF4                          2170m     ENDM
00200EF4                          2171m                 PRINT_CHAR D2,D3
00200EF4                          2172m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EF4                 TRUE     2173m     IFEQ DEBUG
00200EF4  1639 00C00003           2174m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200EFA  0803 0002               2175m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200EFE  67F4                    2176m         BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00200F00  13C2 00C00007           2177m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F06                          2178m     ENDC
00200F06                          2179m     
00200F06                 FALSE    2180m     IFNE DEBUG
00200F06                          2181m     ENDC
00200F06                          2182m 
00200F06                          2183m     ENDM
00200F06                          2184m                 HEX2BIN D2,D2,A0
00200F06  41F9 00201B0A           2185m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F0C  0402 0030               2186m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F10  C4BC 000000FF           2187m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F16  1430 2000               2188m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F1A                          2189m     ENDM
00200F1A  8E82                    2190                  OR.L D2,D7
00200F1C                          2191          
00200F1C  7400                    2192                  MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00200F1E  1407                    2193                  MOVE.B D7,D2
00200F20  DC82                    2194                  ADD.L D2,D6
00200F22                          2195                  
00200F22  2247                    2196                  MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F24  D3CB                    2197                  ADD.L A3,A1                 ; add in the offset
00200F26                          2198                    
00200F26  0807 0000               2199                  BTST #0,D7                  ; deal with odd addresses
00200F2A                          2200  
00200F2A  2247                    2201                  MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00200F2C  6700 00D0               2202                  BEQ EVEN2
00200F30                          2203                          
00200F30  5385                    2204                  SUB.L #1,D5
00200F32  5389                    2205                  SUB.L #1,A1
00200F34                          2206                  
00200F34  7E00                    2207                  MOVE.L #0,D7
00200F36                          2208m                 DOWNLOAD D2,D3            ; MS 4 bits
00200F36                          2209m WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F36                          2210m 
00200F36  1639 00C00003           2211m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F3C  0803 0000               2212m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F40  6700 0010               2213m     BEQ CONTINUE_151                ; NOTHING, CONTINUE
00200F44                          2214m  
00200F44                          2215mm     READ_CHAR D2
00200F44                 TRUE     2216mm     IFEQ DEBUG
00200F44  1439 00C00007           2217mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200F4A                          2218mm     ENDC
00200F4A                 FALSE    2219mm     IFNE DEBUG
00200F4A                          2220mm     ENDC
00200F4A                          2221mm      
00200F4A  B43C 001B               2222mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200F4E  6700 F0B8               2223mm     BEQ START
00200F52                          2224mm     ENDM
00200F52                          2225m CONTINUE_151
00200F52  1639 00C00013           2226m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200F58  0803 0000               2227m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200F5C  67D8                    2228m     BEQ WAIT_FOR_READY_151        ; NOTHING, CHECK AGAIN
00200F5E                          2229m     
00200F5E  1439 00C00017           2230m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200F64  13C2 00E00001           2231m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200F6A                          2232m     
00200F6A                          2233m     ENDM
00200F6A                          2234m                 PRINT_CHAR D2,D3
00200F6A                          2235m WAIT_FOR_READY_153                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F6A                 TRUE     2236m     IFEQ DEBUG
00200F6A  1639 00C00003           2237m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200F70  0803 0002               2238m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200F74  67F4                    2239m         BEQ WAIT_FOR_READY_153          ; NO SPACE, CHECK AGAIN
00200F76  13C2 00C00007           2240m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200F7C                          2241m     ENDC
00200F7C                          2242m     
00200F7C                 FALSE    2243m     IFNE DEBUG
00200F7C                          2244m     ENDC
00200F7C                          2245m 
00200F7C                          2246m     ENDM
00200F7C                          2247m                 HEX2BIN D2,D2,A0
00200F7C  41F9 00201B0A           2248m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200F82  0402 0030               2249m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F86  C4BC 000000FF           2250m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200F8C  1430 2000               2251m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200F90                          2252m     ENDM
00200F90  8E82                    2253                  OR.L D2,D7
00200F92  E98F                    2254                  LSL.L #4,D7
00200F94                          2255                       
00200F94                          2256m                 DOWNLOAD D2,D3            ; LS 4 bits    
00200F94                          2257m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                          2258m 
00200F94  1639 00C00003           2259m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00200F9A  0803 0000               2260m     BTST #0,D3                    ; CHECK FOR CHARACTER
00200F9E  6700 0010               2261m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00200FA2                          2262m  
00200FA2                          2263mm     READ_CHAR D2
00200FA2                 TRUE     2264mm     IFEQ DEBUG
00200FA2  1439 00C00007           2265mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00200FA8                          2266mm     ENDC
00200FA8                 FALSE    2267mm     IFNE DEBUG
00200FA8                          2268mm     ENDC
00200FA8                          2269mm      
00200FA8  B43C 001B               2270mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00200FAC  6700 F05A               2271mm     BEQ START
00200FB0                          2272mm     ENDM
00200FB0                          2273m CONTINUE_155
00200FB0  1639 00C00013           2274m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00200FB6  0803 0000               2275m     BTST #0,D3                  ; CHECK FOR CHARACTER
00200FBA  67D8                    2276m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00200FBC                          2277m     
00200FBC  1439 00C00017           2278m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00200FC2  13C2 00E00001           2279m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00200FC8                          2280m     
00200FC8                          2281m     ENDM
00200FC8                          2282m                 PRINT_CHAR D2,D3
00200FC8                          2283m WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FC8                 TRUE     2284m     IFEQ DEBUG
00200FC8  1639 00C00003           2285m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00200FCE  0803 0002               2286m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00200FD2  67F4                    2287m         BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00200FD4  13C2 00C00007           2288m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00200FDA                          2289m     ENDC
00200FDA                          2290m     
00200FDA                 FALSE    2291m     IFNE DEBUG
00200FDA                          2292m     ENDC
00200FDA                          2293m 
00200FDA                          2294m     ENDM
00200FDA                          2295m                 HEX2BIN D2,D2,A0
00200FDA  41F9 00201B0A           2296m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00200FE0  0402 0030               2297m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FE4  C4BC 000000FF           2298m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00200FEA  1430 2000               2299m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00200FEE                          2300m     ENDM
00200FEE  8E82                    2301                  OR.L D2,D7
00200FF0                          2302                          
00200FF0  DC87                    2303                  ADD.L D7,D6               ; add into checksum
00200FF2                          2304                                
00200FF2  3611                    2305                  MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00200FF4                          2306                  
00200FF4  0243 FF00               2307                  ANDI.W #$FF00,D3
00200FF8  8647                    2308                  OR.W D7,D3
00200FFA                          2309                  
00200FFA  3283                    2310                  MOVE.W D3,(A1)           ; store it!
00200FFC  5489                    2311                  ADD.L #2,A1
00200FFE                          2312  EVEN2
00200FFE  5985                    2313                  SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00201000                          2314                  WHILE.L D5 <GE> #2 DO       ; read the data bytes
00201000                          2315s _10000004
00201000  BABC 00000002           2316s     CMP.L   #2,D5
00201006  6D00 018A               2317s     BLT _10000005
0020100A  5585                    2318                      SUB.L #2,D5
0020100C                          2319                      
0020100C  7E00                    2320                      MOVE.L #0,D7              ; D7 holds the word
0020100E                          2321                      
0020100E                          2322m                     DOWNLOAD D2,D3            ; MS 4 bits
0020100E                          2323m WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020100E                          2324m 
0020100E  1639 00C00003           2325m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201014  0803 0000               2326m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201018  6700 0010               2327m     BEQ CONTINUE_159                ; NOTHING, CONTINUE
0020101C                          2328m  
0020101C                          2329mm     READ_CHAR D2
0020101C                 TRUE     2330mm     IFEQ DEBUG
0020101C  1439 00C00007           2331mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201022                          2332mm     ENDC
00201022                 FALSE    2333mm     IFNE DEBUG
00201022                          2334mm     ENDC
00201022                          2335mm      
00201022  B43C 001B               2336mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201026  6700 EFE0               2337mm     BEQ START
0020102A                          2338mm     ENDM
0020102A                          2339m CONTINUE_159
0020102A  1639 00C00013           2340m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201030  0803 0000               2341m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201034  67D8                    2342m     BEQ WAIT_FOR_READY_159        ; NOTHING, CHECK AGAIN
00201036                          2343m     
00201036  1439 00C00017           2344m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020103C  13C2 00E00001           2345m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201042                          2346m     
00201042                          2347m     ENDM
00201042                          2348m                     PRINT_CHAR D2,D3
00201042                          2349m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201042                 TRUE     2350m     IFEQ DEBUG
00201042  1639 00C00003           2351m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201048  0803 0002               2352m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020104C  67F4                    2353m         BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
0020104E  13C2 00C00007           2354m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201054                          2355m     ENDC
00201054                          2356m     
00201054                 FALSE    2357m     IFNE DEBUG
00201054                          2358m     ENDC
00201054                          2359m 
00201054                          2360m     ENDM
00201054                          2361m                     HEX2BIN D2,D2,A0
00201054  41F9 00201B0A           2362m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020105A  0402 0030               2363m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020105E  C4BC 000000FF           2364m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201064  1430 2000               2365m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201068                          2366m     ENDM
00201068  8E82                    2367                      OR.L D2,D7
0020106A  E98F                    2368                      LSL.L #4,D7
0020106C                          2369                       
0020106C                          2370m                     DOWNLOAD D2,D3            ; LS 4 bits    
0020106C                          2371m WAIT_FOR_READY_163                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020106C                          2372m 
0020106C  1639 00C00003           2373m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201072  0803 0000               2374m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201076  6700 0010               2375m     BEQ CONTINUE_163                ; NOTHING, CONTINUE
0020107A                          2376m  
0020107A                          2377mm     READ_CHAR D2
0020107A                 TRUE     2378mm     IFEQ DEBUG
0020107A  1439 00C00007           2379mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201080                          2380mm     ENDC
00201080                 FALSE    2381mm     IFNE DEBUG
00201080                          2382mm     ENDC
00201080                          2383mm      
00201080  B43C 001B               2384mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201084  6700 EF82               2385mm     BEQ START
00201088                          2386mm     ENDM
00201088                          2387m CONTINUE_163
00201088  1639 00C00013           2388m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020108E  0803 0000               2389m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201092  67D8                    2390m     BEQ WAIT_FOR_READY_163        ; NOTHING, CHECK AGAIN
00201094                          2391m     
00201094  1439 00C00017           2392m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020109A  13C2 00E00001           2393m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002010A0                          2394m     
002010A0                          2395m     ENDM
002010A0                          2396m                     PRINT_CHAR D2,D3
002010A0                          2397m WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A0                 TRUE     2398m     IFEQ DEBUG
002010A0  1639 00C00003           2399m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002010A6  0803 0002               2400m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002010AA  67F4                    2401m         BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
002010AC  13C2 00C00007           2402m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002010B2                          2403m     ENDC
002010B2                          2404m     
002010B2                 FALSE    2405m     IFNE DEBUG
002010B2                          2406m     ENDC
002010B2                          2407m 
002010B2                          2408m     ENDM
002010B2                          2409m                     HEX2BIN D2,D2,A0
002010B2  41F9 00201B0A           2410m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002010B8  0402 0030               2411m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002010BC  C4BC 000000FF           2412m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002010C2  1430 2000               2413m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002010C6                          2414m     ENDM
002010C6  8E82                    2415                      OR.L D2,D7
002010C8                          2416                          
002010C8  DC87                    2417                      ADD.L D7,D6               ; add into checksum
002010CA                          2418                      
002010CA  E98F                    2419                      LSL.L #4,D7
002010CC                          2420m                     DOWNLOAD D2,D3            ; MS 4 bits
002010CC                          2421m WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010CC                          2422m 
002010CC  1639 00C00003           2423m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002010D2  0803 0000               2424m     BTST #0,D3                    ; CHECK FOR CHARACTER
002010D6  6700 0010               2425m     BEQ CONTINUE_167                ; NOTHING, CONTINUE
002010DA                          2426m  
002010DA                          2427mm     READ_CHAR D2
002010DA                 TRUE     2428mm     IFEQ DEBUG
002010DA  1439 00C00007           2429mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002010E0                          2430mm     ENDC
002010E0                 FALSE    2431mm     IFNE DEBUG
002010E0                          2432mm     ENDC
002010E0                          2433mm      
002010E0  B43C 001B               2434mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002010E4  6700 EF22               2435mm     BEQ START
002010E8                          2436mm     ENDM
002010E8                          2437m CONTINUE_167
002010E8  1639 00C00013           2438m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002010EE  0803 0000               2439m     BTST #0,D3                  ; CHECK FOR CHARACTER
002010F2  67D8                    2440m     BEQ WAIT_FOR_READY_167        ; NOTHING, CHECK AGAIN
002010F4                          2441m     
002010F4  1439 00C00017           2442m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002010FA  13C2 00E00001           2443m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201100                          2444m     
00201100                          2445m     ENDM
00201100                          2446m                     PRINT_CHAR D2,D3
00201100                          2447m WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201100                 TRUE     2448m     IFEQ DEBUG
00201100  1639 00C00003           2449m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201106  0803 0002               2450m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020110A  67F4                    2451m         BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
0020110C  13C2 00C00007           2452m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201112                          2453m     ENDC
00201112                          2454m     
00201112                 FALSE    2455m     IFNE DEBUG
00201112                          2456m     ENDC
00201112                          2457m 
00201112                          2458m     ENDM
00201112                          2459m                     HEX2BIN D2,D2,A0
00201112  41F9 00201B0A           2460m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201118  0402 0030               2461m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020111C  C4BC 000000FF           2462m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201122  1430 2000               2463m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201126                          2464m     ENDM
00201126  8E82                    2465                      OR.L D2,D7
00201128                          2466                       
00201128  E98F                    2467                      LSL.L #4,D7
0020112A                          2468m                     DOWNLOAD D2,D3            ; LS 4 bits    
0020112A                          2469m WAIT_FOR_READY_171                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020112A                          2470m 
0020112A  1639 00C00003           2471m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201130  0803 0000               2472m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201134  6700 0010               2473m     BEQ CONTINUE_171                ; NOTHING, CONTINUE
00201138                          2474m  
00201138                          2475mm     READ_CHAR D2
00201138                 TRUE     2476mm     IFEQ DEBUG
00201138  1439 00C00007           2477mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020113E                          2478mm     ENDC
0020113E                 FALSE    2479mm     IFNE DEBUG
0020113E                          2480mm     ENDC
0020113E                          2481mm      
0020113E  B43C 001B               2482mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201142  6700 EEC4               2483mm     BEQ START
00201146                          2484mm     ENDM
00201146                          2485m CONTINUE_171
00201146  1639 00C00013           2486m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020114C  0803 0000               2487m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201150  67D8                    2488m     BEQ WAIT_FOR_READY_171        ; NOTHING, CHECK AGAIN
00201152                          2489m     
00201152  1439 00C00017           2490m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201158  13C2 00E00001           2491m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020115E                          2492m     
0020115E                          2493m     ENDM
0020115E                          2494m                     PRINT_CHAR D2,D3
0020115E                          2495m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020115E                 TRUE     2496m     IFEQ DEBUG
0020115E  1639 00C00003           2497m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201164  0803 0002               2498m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201168  67F4                    2499m         BEQ WAIT_FOR_READY_173          ; NO SPACE, CHECK AGAIN
0020116A  13C2 00C00007           2500m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201170                          2501m     ENDC
00201170                          2502m     
00201170                 FALSE    2503m     IFNE DEBUG
00201170                          2504m     ENDC
00201170                          2505m 
00201170                          2506m     ENDM
00201170                          2507m                     HEX2BIN D2,D2,A0
00201170  41F9 00201B0A           2508m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201176  0402 0030               2509m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020117A  C4BC 000000FF           2510m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201180  1430 2000               2511m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201184                          2512m     ENDM
00201184  8E82                    2513                      OR.L D2,D7
00201186                          2514                      
00201186  7400                    2515                      MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00201188  1407                    2516                      MOVE.B D7,D2
0020118A  DC82                    2517                      ADD.L D2,D6
0020118C                          2518                      
0020118C  32C7                    2519                      MOVE.W D7,(A1)+             ; store it!
0020118E                          2520              
0020118E                          2521                  ENDW
0020118E  6000 FE70               2522s     BRA _10000004
00201192                          2523s _10000005
00201192                          2524              
00201192                          2525                  IF D5 <EQ> #1 THEN
00201192  BA7C 0001               2526s     CMP.W   #1,D5
00201196  6600 00CE               2527s     BNE _00000006
0020119A  7E00                    2528                      MOVE.L #0,D7              ; D7 holds the word
0020119C                          2529                              
0020119C                          2530m                     DOWNLOAD D2,D3            ; MS 4 bits
0020119C                          2531m WAIT_FOR_READY_175                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020119C                          2532m 
0020119C  1639 00C00003           2533m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002011A2  0803 0000               2534m     BTST #0,D3                    ; CHECK FOR CHARACTER
002011A6  6700 0010               2535m     BEQ CONTINUE_175                ; NOTHING, CONTINUE
002011AA                          2536m  
002011AA                          2537mm     READ_CHAR D2
002011AA                 TRUE     2538mm     IFEQ DEBUG
002011AA  1439 00C00007           2539mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002011B0                          2540mm     ENDC
002011B0                 FALSE    2541mm     IFNE DEBUG
002011B0                          2542mm     ENDC
002011B0                          2543mm      
002011B0  B43C 001B               2544mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002011B4  6700 EE52               2545mm     BEQ START
002011B8                          2546mm     ENDM
002011B8                          2547m CONTINUE_175
002011B8  1639 00C00013           2548m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002011BE  0803 0000               2549m     BTST #0,D3                  ; CHECK FOR CHARACTER
002011C2  67D8                    2550m     BEQ WAIT_FOR_READY_175        ; NOTHING, CHECK AGAIN
002011C4                          2551m     
002011C4  1439 00C00017           2552m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002011CA  13C2 00E00001           2553m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002011D0                          2554m     
002011D0                          2555m     ENDM
002011D0                          2556m                     PRINT_CHAR D2,D3
002011D0                          2557m WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011D0                 TRUE     2558m     IFEQ DEBUG
002011D0  1639 00C00003           2559m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002011D6  0803 0002               2560m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002011DA  67F4                    2561m         BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
002011DC  13C2 00C00007           2562m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002011E2                          2563m     ENDC
002011E2                          2564m     
002011E2                 FALSE    2565m     IFNE DEBUG
002011E2                          2566m     ENDC
002011E2                          2567m 
002011E2                          2568m     ENDM
002011E2                          2569m                     HEX2BIN D2,D2,A0
002011E2  41F9 00201B0A           2570m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002011E8  0402 0030               2571m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002011EC  C4BC 000000FF           2572m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002011F2  1430 2000               2573m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002011F6                          2574m     ENDM
002011F6  8E82                    2575                      OR.L D2,D7
002011F8  E98F                    2576                      LSL.L #4,D7
002011FA                          2577                       
002011FA                          2578m                     DOWNLOAD D2,D3            ; LS 4 bits    
002011FA                          2579m WAIT_FOR_READY_179                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011FA                          2580m 
002011FA  1639 00C00003           2581m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201200  0803 0000               2582m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201204  6700 0010               2583m     BEQ CONTINUE_179                ; NOTHING, CONTINUE
00201208                          2584m  
00201208                          2585mm     READ_CHAR D2
00201208                 TRUE     2586mm     IFEQ DEBUG
00201208  1439 00C00007           2587mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020120E                          2588mm     ENDC
0020120E                 FALSE    2589mm     IFNE DEBUG
0020120E                          2590mm     ENDC
0020120E                          2591mm      
0020120E  B43C 001B               2592mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201212  6700 EDF4               2593mm     BEQ START
00201216                          2594mm     ENDM
00201216                          2595m CONTINUE_179
00201216  1639 00C00013           2596m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020121C  0803 0000               2597m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201220  67D8                    2598m     BEQ WAIT_FOR_READY_179        ; NOTHING, CHECK AGAIN
00201222                          2599m     
00201222  1439 00C00017           2600m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201228  13C2 00E00001           2601m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020122E                          2602m     
0020122E                          2603m     ENDM
0020122E                          2604m                     PRINT_CHAR D2,D3
0020122E                          2605m WAIT_FOR_READY_181                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122E                 TRUE     2606m     IFEQ DEBUG
0020122E  1639 00C00003           2607m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201234  0803 0002               2608m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201238  67F4                    2609m         BEQ WAIT_FOR_READY_181          ; NO SPACE, CHECK AGAIN
0020123A  13C2 00C00007           2610m         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201240                          2611m     ENDC
00201240                          2612m     
00201240                 FALSE    2613m     IFNE DEBUG
00201240                          2614m     ENDC
00201240                          2615m 
00201240                          2616m     ENDM
00201240                          2617m                     HEX2BIN D2,D2,A0
00201240  41F9 00201B0A           2618m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201246  0402 0030               2619m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020124A  C4BC 000000FF           2620m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201250  1430 2000               2621m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201254                          2622m     ENDM
00201254  8E82                    2623                      OR.L D2,D7
00201256                          2624                                  
00201256  DC87                    2625                      ADD.L D7,D6               ; add into checksum
00201258                          2626                      
00201258  3611                    2627                      MOVE.W (A1),D3            ; get the current data and replace the top byte
0020125A  E18F                    2628                      LSL.L #8,D7
0020125C  C6BC 000000FF           2629                      AND.L #$00FF,D3
00201262  8687                    2630                      OR.L D7,D3
00201264                          2631  
00201264  32C3                    2632                      MOVE.W D3,(A1)+          ; store it!
00201266                          2633                  ENDI
00201266                          2634s _00000006
00201266                          2635m                 PRINT_CRLF D3
00201266                          2636mm     PRINT_CHAR #13,D3             ; CR
00201266                          2637mm WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201266                 TRUE     2638mm     IFEQ DEBUG
00201266  1639 00C00003           2639mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020126C  0803 0002               2640mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201270  67F4                    2641mm         BEQ WAIT_FOR_READY_184          ; NO SPACE, CHECK AGAIN
00201272  13FC 000D 00C00007      2642mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020127A                          2643mm     ENDC
0020127A                          2644mm     
0020127A                 FALSE    2645mm     IFNE DEBUG
0020127A                          2646mm     ENDC
0020127A                          2647mm 
0020127A                          2648mm     ENDM
0020127A                          2649mm     PRINT_CHAR #10,D3             ; LF
0020127A                          2650mm WAIT_FOR_READY_185                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020127A                 TRUE     2651mm     IFEQ DEBUG
0020127A  1639 00C00003           2652mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201280  0803 0002               2653mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201284  67F4                    2654mm         BEQ WAIT_FOR_READY_185          ; NO SPACE, CHECK AGAIN
00201286  13FC 000A 00C00007      2655mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020128E                          2656mm     ENDC
0020128E                          2657mm     
0020128E                 FALSE    2658mm     IFNE DEBUG
0020128E                          2659mm     ENDC
0020128E                          2660mm 
0020128E                          2661mm     ENDM
0020128E                          2662m     ENDM
0020128E  43F9 002004A0           2663                  LEA WAIT_FOR_SRECORD,A1     ; next place to go
00201294                          2664              ELSE
00201294  6000 0252               2665s     BRA _00000007
00201298                          2666s _00000005
00201298                          2667                  IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00201298  BE3C 0038               2668s     CMP.B   #'8',D7
0020129C  6600 01E4               2669s     BNE.L   _00000008
002012A0  7E00                    2670                      MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002012A2                          2671m                     DOWNLOAD D2,D3            ; top byte
002012A2                          2672m WAIT_FOR_READY_186                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012A2                          2673m 
002012A2  1639 00C00003           2674m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012A8  0803 0000               2675m     BTST #0,D3                    ; CHECK FOR CHARACTER
002012AC  6700 0010               2676m     BEQ CONTINUE_186                ; NOTHING, CONTINUE
002012B0                          2677m  
002012B0                          2678mm     READ_CHAR D2
002012B0                 TRUE     2679mm     IFEQ DEBUG
002012B0  1439 00C00007           2680mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002012B6                          2681mm     ENDC
002012B6                 FALSE    2682mm     IFNE DEBUG
002012B6                          2683mm     ENDC
002012B6                          2684mm      
002012B6  B43C 001B               2685mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002012BA  6700 ED4C               2686mm     BEQ START
002012BE                          2687mm     ENDM
002012BE                          2688m CONTINUE_186
002012BE  1639 00C00013           2689m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002012C4  0803 0000               2690m     BTST #0,D3                  ; CHECK FOR CHARACTER
002012C8  67D8                    2691m     BEQ WAIT_FOR_READY_186        ; NOTHING, CHECK AGAIN
002012CA                          2692m     
002012CA  1439 00C00017           2693m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002012D0  13C2 00E00001           2694m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002012D6                          2695m     
002012D6                          2696m     ENDM
002012D6                          2697m                     HEX2BIN D2,D2,A0
002012D6  41F9 00201B0A           2698m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002012DC  0402 0030               2699m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012E0  C4BC 000000FF           2700m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002012E6  1430 2000               2701m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002012EA                          2702m     ENDM
002012EA  8E82                    2703                      OR.L D2,D7
002012EC  E98F                    2704                      LSL.L #4,D7
002012EE                          2705m                     DOWNLOAD D2,D3         
002012EE                          2706m WAIT_FOR_READY_189                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012EE                          2707m 
002012EE  1639 00C00003           2708m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002012F4  0803 0000               2709m     BTST #0,D3                    ; CHECK FOR CHARACTER
002012F8  6700 0010               2710m     BEQ CONTINUE_189                ; NOTHING, CONTINUE
002012FC                          2711m  
002012FC                          2712mm     READ_CHAR D2
002012FC                 TRUE     2713mm     IFEQ DEBUG
002012FC  1439 00C00007           2714mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201302                          2715mm     ENDC
00201302                 FALSE    2716mm     IFNE DEBUG
00201302                          2717mm     ENDC
00201302                          2718mm      
00201302  B43C 001B               2719mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201306  6700 ED00               2720mm     BEQ START
0020130A                          2721mm     ENDM
0020130A                          2722m CONTINUE_189
0020130A  1639 00C00013           2723m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201310  0803 0000               2724m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201314  67D8                    2725m     BEQ WAIT_FOR_READY_189        ; NOTHING, CHECK AGAIN
00201316                          2726m     
00201316  1439 00C00017           2727m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020131C  13C2 00E00001           2728m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201322                          2729m     
00201322                          2730m     ENDM
00201322                          2731m                     HEX2BIN D2,D2,A0
00201322  41F9 00201B0A           2732m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201328  0402 0030               2733m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020132C  C4BC 000000FF           2734m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201332  1430 2000               2735m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201336                          2736m     ENDM
00201336  8E82                    2737                      OR.L D2,D7
00201338                          2738                  
00201338  DC87                    2739                      ADD.L D7,D6               ; add top byte of address into checksum
0020133A                          2740  
0020133A  E98F                    2741                      LSL.L #4,D7               ; middle byte
0020133C                          2742m                     DOWNLOAD D2,D3
0020133C                          2743m WAIT_FOR_READY_192                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133C                          2744m 
0020133C  1639 00C00003           2745m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201342  0803 0000               2746m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201346  6700 0010               2747m     BEQ CONTINUE_192                ; NOTHING, CONTINUE
0020134A                          2748m  
0020134A                          2749mm     READ_CHAR D2
0020134A                 TRUE     2750mm     IFEQ DEBUG
0020134A  1439 00C00007           2751mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201350                          2752mm     ENDC
00201350                 FALSE    2753mm     IFNE DEBUG
00201350                          2754mm     ENDC
00201350                          2755mm      
00201350  B43C 001B               2756mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201354  6700 ECB2               2757mm     BEQ START
00201358                          2758mm     ENDM
00201358                          2759m CONTINUE_192
00201358  1639 00C00013           2760m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0020135E  0803 0000               2761m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201362  67D8                    2762m     BEQ WAIT_FOR_READY_192        ; NOTHING, CHECK AGAIN
00201364                          2763m     
00201364  1439 00C00017           2764m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020136A  13C2 00E00001           2765m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201370                          2766m     
00201370                          2767m     ENDM
00201370                          2768m                     HEX2BIN D2,D2,A0
00201370  41F9 00201B0A           2769m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201376  0402 0030               2770m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020137A  C4BC 000000FF           2771m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201380  1430 2000               2772m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201384                          2773m     ENDM
00201384  8E82                    2774                      OR.L D2,D7
00201386  E98F                    2775                      LSL.L #4,D7        
00201388                          2776m                     DOWNLOAD D2,D3
00201388                          2777m WAIT_FOR_READY_195                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201388                          2778m 
00201388  1639 00C00003           2779m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020138E  0803 0000               2780m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201392  6700 0010               2781m     BEQ CONTINUE_195                ; NOTHING, CONTINUE
00201396                          2782m  
00201396                          2783mm     READ_CHAR D2
00201396                 TRUE     2784mm     IFEQ DEBUG
00201396  1439 00C00007           2785mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020139C                          2786mm     ENDC
0020139C                 FALSE    2787mm     IFNE DEBUG
0020139C                          2788mm     ENDC
0020139C                          2789mm      
0020139C  B43C 001B               2790mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013A0  6700 EC66               2791mm     BEQ START
002013A4                          2792mm     ENDM
002013A4                          2793m CONTINUE_195
002013A4  1639 00C00013           2794m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002013AA  0803 0000               2795m     BTST #0,D3                  ; CHECK FOR CHARACTER
002013AE  67D8                    2796m     BEQ WAIT_FOR_READY_195        ; NOTHING, CHECK AGAIN
002013B0                          2797m     
002013B0  1439 00C00017           2798m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
002013B6  13C2 00E00001           2799m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
002013BC                          2800m     
002013BC                          2801m     ENDM
002013BC                          2802m                     HEX2BIN D2,D2,A0
002013BC  41F9 00201B0A           2803m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002013C2  0402 0030               2804m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013C6  C4BC 000000FF           2805m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002013CC  1430 2000               2806m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002013D0                          2807m     ENDM
002013D0  8E82                    2808                      OR.L D2,D7
002013D2                          2809          
002013D2  7400                    2810                      MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
002013D4  1407                    2811                      MOVE.B D7,D2
002013D6  DC82                    2812                      ADD.L D2,D6
002013D8                          2813                    
002013D8  E98F                    2814                      LSL.L #4,D7               ; bottom byte
002013DA                          2815m                     DOWNLOAD D2,D3
002013DA                          2816m WAIT_FOR_READY_198                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013DA                          2817m 
002013DA  1639 00C00003           2818m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002013E0  0803 0000               2819m     BTST #0,D3                    ; CHECK FOR CHARACTER
002013E4  6700 0010               2820m     BEQ CONTINUE_198                ; NOTHING, CONTINUE
002013E8                          2821m  
002013E8                          2822mm     READ_CHAR D2
002013E8                 TRUE     2823mm     IFEQ DEBUG
002013E8  1439 00C00007           2824mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002013EE                          2825mm     ENDC
002013EE                 FALSE    2826mm     IFNE DEBUG
002013EE                          2827mm     ENDC
002013EE                          2828mm      
002013EE  B43C 001B               2829mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002013F2  6700 EC14               2830mm     BEQ START
002013F6                          2831mm     ENDM
002013F6                          2832m CONTINUE_198
002013F6  1639 00C00013           2833m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
002013FC  0803 0000               2834m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201400  67D8                    2835m     BEQ WAIT_FOR_READY_198        ; NOTHING, CHECK AGAIN
00201402                          2836m     
00201402  1439 00C00017           2837m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201408  13C2 00E00001           2838m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020140E                          2839m     
0020140E                          2840m     ENDM
0020140E                          2841m                     HEX2BIN D2,D2,A0
0020140E  41F9 00201B0A           2842m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201414  0402 0030               2843m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201418  C4BC 000000FF           2844m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020141E  1430 2000               2845m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201422                          2846m     ENDM
00201422  8E82                    2847                      OR.L D2,D7
00201424  E98F                    2848                      LSL.L #4,D7        
00201426                          2849m                     DOWNLOAD D2,D3
00201426                          2850m WAIT_FOR_READY_201                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201426                          2851m 
00201426  1639 00C00003           2852m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0020142C  0803 0000               2853m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201430  6700 0010               2854m     BEQ CONTINUE_201                ; NOTHING, CONTINUE
00201434                          2855m  
00201434                          2856mm     READ_CHAR D2
00201434                 TRUE     2857mm     IFEQ DEBUG
00201434  1439 00C00007           2858mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020143A                          2859mm     ENDC
0020143A                 FALSE    2860mm     IFNE DEBUG
0020143A                          2861mm     ENDC
0020143A                          2862mm      
0020143A  B43C 001B               2863mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020143E  6700 EBC8               2864mm     BEQ START
00201442                          2865mm     ENDM
00201442                          2866m CONTINUE_201
00201442  1639 00C00013           2867m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201448  0803 0000               2868m     BTST #0,D3                  ; CHECK FOR CHARACTER
0020144C  67D8                    2869m     BEQ WAIT_FOR_READY_201        ; NOTHING, CHECK AGAIN
0020144E                          2870m     
0020144E  1439 00C00017           2871m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201454  13C2 00E00001           2872m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0020145A                          2873m     
0020145A                          2874m     ENDM
0020145A                          2875m                     HEX2BIN D2,D2,A0
0020145A  41F9 00201B0A           2876m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201460  0402 0030               2877m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201464  C4BC 000000FF           2878m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0020146A  1430 2000               2879m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020146E                          2880m     ENDM
0020146E  8E82                    2881                      OR.L D2,D7
00201470                          2882                  
00201470  7400                    2883                      MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00201472  1407                    2884                      MOVE.B D7,D2
00201474  DC82                    2885                      ADD.L D2,D6
00201476                          2886                    
00201476  2447                    2887                      MOVE.L D7,A2              ; start address -> A2
00201478                          2888                  
00201478  43F9 00201638           2889                      LEA DOWNLOAD_DONE,A1      ; next place to go
0020147E                          2890                  ELSE
0020147E  6000 0068               2891s     BRA _00000009
00201482                          2892s _00000008
00201482  41F9 00201ABF           2893                      LEA UNREC,A0              ; warn for unrecognised type
00201488                          2894m                     PRINT_STR A0,D3
00201488                          2895m LOOP_204
00201488  0C10 0000               2896m     CMP.B #0,(A0)                 ; 0 -> DONE
0020148C  6700 001A               2897m     BEQ EXIT_204
00201490                          2898mm     PRINT_CHAR (A0)+,D3
00201490                          2899mm WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201490                 TRUE     2900mm     IFEQ DEBUG
00201490  1639 00C00003           2901mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201496  0803 0002               2902mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020149A  67F4                    2903mm         BEQ WAIT_FOR_READY_205          ; NO SPACE, CHECK AGAIN
0020149C  13D8 00C00007           2904mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002014A2                          2905mm     ENDC
002014A2                          2906mm     
002014A2                 FALSE    2907mm     IFNE DEBUG
002014A2                          2908mm     ENDC
002014A2                          2909mm 
002014A2                          2910mm     ENDM
002014A2  4EF9 00201488           2911m     JMP LOOP_204
002014A8                          2912m EXIT_204
002014A8                          2913m     ENDM
002014A8                          2914m                     PRINT_CHAR D7,D3
002014A8                          2915m WAIT_FOR_READY_206                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014A8                 TRUE     2916m     IFEQ DEBUG
002014A8  1639 00C00003           2917m         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014AE  0803 0002               2918m         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014B2  67F4                    2919m         BEQ WAIT_FOR_READY_206          ; NO SPACE, CHECK AGAIN
002014B4  13C7 00C00007           2920m         MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
002014BA                          2921m     ENDC
002014BA                          2922m     
002014BA                 FALSE    2923m     IFNE DEBUG
002014BA                          2924m     ENDC
002014BA                          2925m 
002014BA                          2926m     ENDM
002014BA                          2927m                     PRINT_CRLF D3
002014BA                          2928mm     PRINT_CHAR #13,D3             ; CR
002014BA                          2929mm WAIT_FOR_READY_208                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014BA                 TRUE     2930mm     IFEQ DEBUG
002014BA  1639 00C00003           2931mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014C0  0803 0002               2932mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014C4  67F4                    2933mm         BEQ WAIT_FOR_READY_208          ; NO SPACE, CHECK AGAIN
002014C6  13FC 000D 00C00007      2934mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002014CE                          2935mm     ENDC
002014CE                          2936mm     
002014CE                 FALSE    2937mm     IFNE DEBUG
002014CE                          2938mm     ENDC
002014CE                          2939mm 
002014CE                          2940mm     ENDM
002014CE                          2941mm     PRINT_CHAR #10,D3             ; LF
002014CE                          2942mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014CE                 TRUE     2943mm     IFEQ DEBUG
002014CE  1639 00C00003           2944mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002014D4  0803 0002               2945mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002014D8  67F4                    2946mm         BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
002014DA  13FC 000A 00C00007      2947mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
002014E2                          2948mm     ENDC
002014E2                          2949mm     
002014E2                 FALSE    2950mm     IFNE DEBUG
002014E2                          2951mm     ENDC
002014E2                          2952mm 
002014E2                          2953mm     ENDM
002014E2                          2954m     ENDM
002014E2                          2955              
002014E2  4EF9 002004A0           2956                      JMP WAIT_FOR_SRECORD      ; ignore any other type    
002014E8                          2957                  ENDI
002014E8                          2958s _00000009
002014E8                          2959              ENDI
002014E8                          2960s _00000007
002014E8                          2961          ENDI
002014E8                          2962s _00000004
002014E8                          2963      ENDI
002014E8                          2964s _00000001
002014E8                          2965      
002014E8  4686                    2966      NOT.L D6                        ; ones complement the checksum
002014EA  0286 000000FF           2967      ANDI.L #$FF,D6                  ; and take the LSByte
002014F0                          2968          
002014F0  7E00                    2969      MOVE.L #0,D7                    ; read the checksum from the data stream
002014F2                          2970m     DOWNLOAD D2,D3                  ; top byte
002014F2                          2971m WAIT_FOR_READY_210                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014F2                          2972m 
002014F2  1639 00C00003           2973m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
002014F8  0803 0000               2974m     BTST #0,D3                    ; CHECK FOR CHARACTER
002014FC  6700 0010               2975m     BEQ CONTINUE_210                ; NOTHING, CONTINUE
00201500                          2976m  
00201500                          2977mm     READ_CHAR D2
00201500                 TRUE     2978mm     IFEQ DEBUG
00201500  1439 00C00007           2979mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201506                          2980mm     ENDC
00201506                 FALSE    2981mm     IFNE DEBUG
00201506                          2982mm     ENDC
00201506                          2983mm      
00201506  B43C 001B               2984mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0020150A  6700 EAFC               2985mm     BEQ START
0020150E                          2986mm     ENDM
0020150E                          2987m CONTINUE_210
0020150E  1639 00C00013           2988m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201514  0803 0000               2989m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201518  67D8                    2990m     BEQ WAIT_FOR_READY_210        ; NOTHING, CHECK AGAIN
0020151A                          2991m     
0020151A  1439 00C00017           2992m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00201520  13C2 00E00001           2993m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201526                          2994m     
00201526                          2995m     ENDM
00201526                          2996m     HEX2BIN D2,D2,A0
00201526  41F9 00201B0A           2997m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020152C  0402 0030               2998m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201530  C4BC 000000FF           2999m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201536  1430 2000               3000m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020153A                          3001m     ENDM
0020153A  8E82                    3002      OR.L D2,D7
0020153C  E98F                    3003      LSL.L #4,D7
0020153E                          3004m     DOWNLOAD D2,D3                  ; bottom byte
0020153E                          3005m WAIT_FOR_READY_213                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020153E                          3006m 
0020153E  1639 00C00003           3007m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00201544  0803 0000               3008m     BTST #0,D3                    ; CHECK FOR CHARACTER
00201548  6700 0010               3009m     BEQ CONTINUE_213                ; NOTHING, CONTINUE
0020154C                          3010m  
0020154C                          3011mm     READ_CHAR D2
0020154C                 TRUE     3012mm     IFEQ DEBUG
0020154C  1439 00C00007           3013mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00201552                          3014mm     ENDC
00201552                 FALSE    3015mm     IFNE DEBUG
00201552                          3016mm     ENDC
00201552                          3017mm      
00201552  B43C 001B               3018mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201556  6700 EAB0               3019mm     BEQ START
0020155A                          3020mm     ENDM
0020155A                          3021m CONTINUE_213
0020155A  1639 00C00013           3022m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00201560  0803 0000               3023m     BTST #0,D3                  ; CHECK FOR CHARACTER
00201564  67D8                    3024m     BEQ WAIT_FOR_READY_213        ; NOTHING, CHECK AGAIN
00201566                          3025m     
00201566  1439 00C00017           3026m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0020156C  13C2 00E00001           3027m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00201572                          3028m     
00201572                          3029m     ENDM
00201572                          3030m     HEX2BIN D2,D2,A0
00201572  41F9 00201B0A           3031m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00201578  0402 0030               3032m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020157C  C4BC 000000FF           3033m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201582  1430 2000               3034m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00201586                          3035m     ENDM
00201586  8E82                    3036      OR.L D2,D7
00201588                          3037                  
00201588                          3038      IF.B D7 <NE> D6 THEN.L
00201588  BE06                    3039s     CMP.B   D6,D7
0020158A  6700 00AA               3040s     BEQ.L   _0000000A
0020158E  41F9 00201AD6           3041          LEA CS_FAILURE,A0             ; warn for mismatched checksum
00201594                          3042m         PRINT_STR A0,D3
00201594                          3043m LOOP_216
00201594  0C10 0000               3044m     CMP.B #0,(A0)                 ; 0 -> DONE
00201598  6700 001A               3045m     BEQ EXIT_216
0020159C                          3046mm     PRINT_CHAR (A0)+,D3
0020159C                          3047mm WAIT_FOR_READY_217                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020159C                 TRUE     3048mm     IFEQ DEBUG
0020159C  1639 00C00003           3049mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015A2  0803 0002               3050mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015A6  67F4                    3051mm         BEQ WAIT_FOR_READY_217          ; NO SPACE, CHECK AGAIN
002015A8  13D8 00C00007           3052mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002015AE                          3053mm     ENDC
002015AE                          3054mm     
002015AE                 FALSE    3055mm     IFNE DEBUG
002015AE                          3056mm     ENDC
002015AE                          3057mm 
002015AE                          3058mm     ENDM
002015AE  4EF9 00201594           3059m     JMP LOOP_216
002015B4                          3060m EXIT_216
002015B4                          3061m     ENDM
002015B4                          3062m         PRINT_REG D4,D3,D6,D7,A0
002015B4                          3063mm     PRINT_CHAR #'0',D3          ;0X HEADER
002015B4                          3064mm WAIT_FOR_READY_219                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015B4                 TRUE     3065mm     IFEQ DEBUG
002015B4  1639 00C00003           3066mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015BA  0803 0002               3067mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015BE  67F4                    3068mm         BEQ WAIT_FOR_READY_219          ; NO SPACE, CHECK AGAIN
002015C0  13FC 0030 00C00007      3069mm         MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002015C8                          3070mm     ENDC
002015C8                          3071mm     
002015C8                 FALSE    3072mm     IFNE DEBUG
002015C8                          3073mm     ENDC
002015C8                          3074mm 
002015C8                          3075mm     ENDM
002015C8                          3076mm     PRINT_CHAR #'x',D3
002015C8                          3077mm WAIT_FOR_READY_220                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015C8                 TRUE     3078mm     IFEQ DEBUG
002015C8  1639 00C00003           3079mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015CE  0803 0002               3080mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015D2  67F4                    3081mm         BEQ WAIT_FOR_READY_220          ; NO SPACE, CHECK AGAIN
002015D4  13FC 0078 00C00007      3082mm         MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002015DC                          3083mm     ENDC
002015DC                          3084mm     
002015DC                 FALSE    3085mm     IFNE DEBUG
002015DC                          3086mm     ENDC
002015DC                          3087mm 
002015DC                          3088mm     ENDM
002015DC  7E07                    3089m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002015DE                          3090m LOOP_218
002015DE                          3091mm     BIN2HEX D4,D6,A0
002015DE  41F9 00201AFA           3092mm     LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002015E4  E99C                    3093mm     ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002015E6  1C04                    3094mm     MOVE.B D4,D6
002015E8  0286 0000000F           3095mm     ANDI.L #$F,D6
002015EE  1C30 6000               3096mm     MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
002015F2                          3097mm     ENDM
002015F2                          3098mm     PRINT_CHAR D6,D3
002015F2                          3099mm WAIT_FOR_READY_222                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015F2                 TRUE     3100mm     IFEQ DEBUG
002015F2  1639 00C00003           3101mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002015F8  0803 0002               3102mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002015FC  67F4                    3103mm         BEQ WAIT_FOR_READY_222          ; NO SPACE, CHECK AGAIN
002015FE  13C6 00C00007           3104mm         MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00201604                          3105mm     ENDC
00201604                          3106mm     
00201604                 FALSE    3107mm     IFNE DEBUG
00201604                          3108mm     ENDC
00201604                          3109mm 
00201604                          3110mm     ENDM
00201604  57CF FFD8               3111m     DBEQ D7,LOOP_218
00201608                          3112m     ENDM
00201608                          3113m         PRINT_CRLF D3
00201608                          3114mm     PRINT_CHAR #13,D3             ; CR
00201608                          3115mm WAIT_FOR_READY_224                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201608                 TRUE     3116mm     IFEQ DEBUG
00201608  1639 00C00003           3117mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020160E  0803 0002               3118mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201612  67F4                    3119mm         BEQ WAIT_FOR_READY_224          ; NO SPACE, CHECK AGAIN
00201614  13FC 000D 00C00007      3120mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020161C                          3121mm     ENDC
0020161C                          3122mm     
0020161C                 FALSE    3123mm     IFNE DEBUG
0020161C                          3124mm     ENDC
0020161C                          3125mm 
0020161C                          3126mm     ENDM
0020161C                          3127mm     PRINT_CHAR #10,D3             ; LF
0020161C                          3128mm WAIT_FOR_READY_225                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020161C                 TRUE     3129mm     IFEQ DEBUG
0020161C  1639 00C00003           3130mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201622  0803 0002               3131mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201626  67F4                    3132mm         BEQ WAIT_FOR_READY_225          ; NO SPACE, CHECK AGAIN
00201628  13FC 000A 00C00007      3133mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201630                          3134mm     ENDC
00201630                          3135mm     
00201630                 FALSE    3136mm     IFNE DEBUG
00201630                          3137mm     ENDC
00201630                          3138mm 
00201630                          3139mm     ENDM
00201630                          3140m     ENDM
00201630  4EF9 00200188           3141          JMP MAIN_LOOP
00201636                          3142      ENDI
00201636                          3143s _0000000A
00201636                          3144      
00201636  4ED1                    3145      JMP (A1)
00201638                          3146  DOWNLOAD_DONE
00201638                          3147m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00201638                          3148mm     PRINT_CHAR #'0',D3          ;0X HEADER
00201638                          3149mm WAIT_FOR_READY_227                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201638                 TRUE     3150mm     IFEQ DEBUG
00201638  1639 00C00003           3151mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020163E  0803 0002               3152mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201642  67F4                    3153mm         BEQ WAIT_FOR_READY_227          ; NO SPACE, CHECK AGAIN
00201644  13FC 0030 00C00007      3154mm         MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0020164C                          3155mm     ENDC
0020164C                          3156mm     
0020164C                 FALSE    3157mm     IFNE DEBUG
0020164C                          3158mm     ENDC
0020164C                          3159mm 
0020164C                          3160mm     ENDM
0020164C                          3161mm     PRINT_CHAR #'x',D3
0020164C                          3162mm WAIT_FOR_READY_228                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020164C                 TRUE     3163mm     IFEQ DEBUG
0020164C  1639 00C00003           3164mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201652  0803 0002               3165mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201656  67F4                    3166mm         BEQ WAIT_FOR_READY_228          ; NO SPACE, CHECK AGAIN
00201658  13FC 0078 00C00007      3167mm         MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00201660                          3168mm     ENDC
00201660                          3169mm     
00201660                 FALSE    3170mm     IFNE DEBUG
00201660                          3171mm     ENDC
00201660                          3172mm 
00201660                          3173mm     ENDM
00201660  7C07                    3174m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201662                          3175m LOOP_226
00201662                          3176mm     BIN2HEX D4,D7,A0
00201662  41F9 00201AFA           3177mm     LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00201668  E99C                    3178mm     ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020166A  1E04                    3179mm     MOVE.B D4,D7
0020166C  0287 0000000F           3180mm     ANDI.L #$F,D7
00201672  1E30 7000               3181mm     MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00201676                          3182mm     ENDM
00201676                          3183mm     PRINT_CHAR D7,D3
00201676                          3184mm WAIT_FOR_READY_230                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201676                 TRUE     3185mm     IFEQ DEBUG
00201676  1639 00C00003           3186mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020167C  0803 0002               3187mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201680  67F4                    3188mm         BEQ WAIT_FOR_READY_230          ; NO SPACE, CHECK AGAIN
00201682  13C7 00C00007           3189mm         MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00201688                          3190mm     ENDC
00201688                          3191mm     
00201688                 FALSE    3192mm     IFNE DEBUG
00201688                          3193mm     ENDC
00201688                          3194mm 
00201688                          3195mm     ENDM
00201688  57CE FFD8               3196m     DBEQ D6,LOOP_226
0020168C                          3197m     ENDM
0020168C  41F9 00201A9D           3198      LEA READ,A0
00201692                          3199m     PRINT_STR A0,D3
00201692                          3200m LOOP_231
00201692  0C10 0000               3201m     CMP.B #0,(A0)                 ; 0 -> DONE
00201696  6700 001A               3202m     BEQ EXIT_231
0020169A                          3203mm     PRINT_CHAR (A0)+,D3
0020169A                          3204mm WAIT_FOR_READY_232                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020169A                 TRUE     3205mm     IFEQ DEBUG
0020169A  1639 00C00003           3206mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016A0  0803 0002               3207mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016A4  67F4                    3208mm         BEQ WAIT_FOR_READY_232          ; NO SPACE, CHECK AGAIN
002016A6  13D8 00C00007           3209mm         MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002016AC                          3210mm     ENDC
002016AC                          3211mm     
002016AC                 FALSE    3212mm     IFNE DEBUG
002016AC                          3213mm     ENDC
002016AC                          3214mm 
002016AC                          3215mm     ENDM
002016AC  4EF9 00201692           3216m     JMP LOOP_231
002016B2                          3217m EXIT_231
002016B2                          3218m     ENDM
002016B2  2E0A                    3219      MOVE.L A2,D7                    ; set address accumulator to start address
002016B4                          3220m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
002016B4                          3221mm     PRINT_CHAR #'0',D3          ;0X HEADER
002016B4                          3222mm WAIT_FOR_READY_234                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016B4                 TRUE     3223mm     IFEQ DEBUG
002016B4  1639 00C00003           3224mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016BA  0803 0002               3225mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016BE  67F4                    3226mm         BEQ WAIT_FOR_READY_234          ; NO SPACE, CHECK AGAIN
002016C0  13FC 0030 00C00007      3227mm         MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002016C8                          3228mm     ENDC
002016C8                          3229mm     
002016C8                 FALSE    3230mm     IFNE DEBUG
002016C8                          3231mm     ENDC
002016C8                          3232mm 
002016C8                          3233mm     ENDM
002016C8                          3234mm     PRINT_CHAR #'x',D3
002016C8                          3235mm WAIT_FOR_READY_235                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016C8                 TRUE     3236mm     IFEQ DEBUG
002016C8  1639 00C00003           3237mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016CE  0803 0002               3238mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016D2  67F4                    3239mm         BEQ WAIT_FOR_READY_235          ; NO SPACE, CHECK AGAIN
002016D4  13FC 0078 00C00007      3240mm         MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002016DC                          3241mm     ENDC
002016DC                          3242mm     
002016DC                 FALSE    3243mm     IFNE DEBUG
002016DC                          3244mm     ENDC
002016DC                          3245mm 
002016DC                          3246mm     ENDM
002016DC  7C07                    3247m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002016DE                          3248m LOOP_233
002016DE                          3249mm     BIN2HEX D7,D2,A0
002016DE  41F9 00201AFA           3250mm     LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
002016E4  E99F                    3251mm     ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002016E6  1407                    3252mm     MOVE.B D7,D2
002016E8  0282 0000000F           3253mm     ANDI.L #$F,D2
002016EE  1430 2000               3254mm     MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
002016F2                          3255mm     ENDM
002016F2                          3256mm     PRINT_CHAR D2,D3
002016F2                          3257mm WAIT_FOR_READY_237                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016F2                 TRUE     3258mm     IFEQ DEBUG
002016F2  1639 00C00003           3259mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002016F8  0803 0002               3260mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002016FC  67F4                    3261mm         BEQ WAIT_FOR_READY_237          ; NO SPACE, CHECK AGAIN
002016FE  13C2 00C00007           3262mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201704                          3263mm     ENDC
00201704                          3264mm     
00201704                 FALSE    3265mm     IFNE DEBUG
00201704                          3266mm     ENDC
00201704                          3267mm 
00201704                          3268mm     ENDM
00201704  57CE FFD8               3269m     DBEQ D6,LOOP_233
00201708                          3270m     ENDM
00201708                          3271m     PRINT_CRLF D3     
00201708                          3272mm     PRINT_CHAR #13,D3             ; CR
00201708                          3273mm WAIT_FOR_READY_239                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201708                 TRUE     3274mm     IFEQ DEBUG
00201708  1639 00C00003           3275mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020170E  0803 0002               3276mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201712  67F4                    3277mm         BEQ WAIT_FOR_READY_239          ; NO SPACE, CHECK AGAIN
00201714  13FC 000D 00C00007      3278mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020171C                          3279mm     ENDC
0020171C                          3280mm     
0020171C                 FALSE    3281mm     IFNE DEBUG
0020171C                          3282mm     ENDC
0020171C                          3283mm 
0020171C                          3284mm     ENDM
0020171C                          3285mm     PRINT_CHAR #10,D3             ; LF
0020171C                          3286mm WAIT_FOR_READY_240                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020171C                 TRUE     3287mm     IFEQ DEBUG
0020171C  1639 00C00003           3288mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201722  0803 0002               3289mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201726  67F4                    3290mm         BEQ WAIT_FOR_READY_240          ; NO SPACE, CHECK AGAIN
00201728  13FC 000A 00C00007      3291mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201730                          3292mm     ENDC
00201730                          3293mm     
00201730                 FALSE    3294mm     IFNE DEBUG
00201730                          3295mm     ENDC
00201730                          3296mm 
00201730                          3297mm     ENDM
00201730                          3298m     ENDM
00201730                          3299          
00201730  4EF9 00200188           3300      JMP MAIN_LOOP
00201736                          3301      
00201736  2047                    3302  G   MOVE.L D7,A0                    ; address accumulator -> address register
00201738  3E3C 0000               3303      MOVE #0,D7                      ; clear the now used address accumulator
0020173C  4ED0                    3304      JMP (A0)                        ; jump to it!
0020173E                          3305      
0020173E  207C 00200000           3306  Z   MOVE.L #RAM,A0                  ; address of RAM
00201744  7000                    3307      MOVE.L #0,D0                    ; number of bytes
00201746                          3308     
00201746                          3309      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
00201746                          3310s _10000006
00201746  B0BC 00040000           3311s     CMP.L   #$40000,D0
0020174C  6E00 001A               3312s     BGT _10000007
00201750                          3313         
00201750  2200                    3314          MOVE.L D0,D1                  ; progress update
00201752  E089                    3315          LSR.L #8,D1 
00201754  E089                    3316          LSR.L #8,D1
00201756  0281 0000000F           3317          ANDI.L #$F,D1
0020175C  13C1 00E00001           3318          MOVE.B D1,DISPLAY
00201762                          3319  
00201762  20C0                    3320          MOVE.L D0,(A0)+ 
00201764  5880                    3321          ADD.L #4,D0
00201766                          3322      ENDW
00201766  60DE                    3323s     BRA _10000006
00201768                          3324s _10000007
00201768                          3325   
00201768  207C 00200000           3326      MOVE.L #RAM,A0              ; address of RAM
0020176E  7000                    3327      MOVE.L #0,D0                ; number of bytes
00201770                          3328     
00201770                          3329      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00201770                          3330s _10000008
00201770  B0BC 00040000           3331s     CMP.L   #$40000,D0
00201776  6E00 00CC               3332s     BGT _10000009
0020177A                          3333  
0020177A  2200                    3334          MOVE.L D0,D1              ; progress update
0020177C  E089                    3335          LSR.L #8,D1
0020177E  E089                    3336          LSR.L #8,D1
00201780  0281 0000000F           3337          ANDI.L #$F,D1
00201786  13C1 00E00001           3338          MOVE.B D1,DISPLAY
0020178C                          3339  
0020178C  2218                    3340          MOVE.L (A0)+,D1
0020178E                          3341            
0020178E                          3342          IF.L D0 <EQ> D1 THEN
0020178E  B081                    3343s     CMP.L   D1,D0
00201790  6600 0006               3344s     BNE _0000000B
00201794  6000 00A8               3345              BRA OK
00201798                          3346          ENDI 
00201798                          3347s _0000000B
00201798                          3348            
00201798  43F9 00201AE8           3349          LEA RAM_ERROR,A1
0020179E                          3350m         PRINT_STR A1,D1
0020179E                          3351m LOOP_241
0020179E  0C11 0000               3352m     CMP.B #0,(A1)                 ; 0 -> DONE
002017A2  6700 001A               3353m     BEQ EXIT_241
002017A6                          3354mm     PRINT_CHAR (A1)+,D1
002017A6                          3355mm WAIT_FOR_READY_242                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017A6                 TRUE     3356mm     IFEQ DEBUG
002017A6  1239 00C00003           3357mm         MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
002017AC  0801 0002               3358mm         BTST #2,D1                    ; CHECK FOR SPACE TO SEND
002017B0  67F4                    3359mm         BEQ WAIT_FOR_READY_242          ; NO SPACE, CHECK AGAIN
002017B2  13D9 00C00007           3360mm         MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
002017B8                          3361mm     ENDC
002017B8                          3362mm     
002017B8                 FALSE    3363mm     IFNE DEBUG
002017B8                          3364mm     ENDC
002017B8                          3365mm 
002017B8                          3366mm     ENDM
002017B8  4EF9 0020179E           3367m     JMP LOOP_241
002017BE                          3368m EXIT_241
002017BE                          3369m     ENDM
002017BE  2208                    3370          MOVE.L A0,D1
002017C0  5981                    3371          SUB.L #4,D1
002017C2                          3372m         PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
002017C2                          3373mm     PRINT_CHAR #'0',D3          ;0X HEADER
002017C2                          3374mm WAIT_FOR_READY_244                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017C2                 TRUE     3375mm     IFEQ DEBUG
002017C2  1639 00C00003           3376mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017C8  0803 0002               3377mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017CC  67F4                    3378mm         BEQ WAIT_FOR_READY_244          ; NO SPACE, CHECK AGAIN
002017CE  13FC 0030 00C00007      3379mm         MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
002017D6                          3380mm     ENDC
002017D6                          3381mm     
002017D6                 FALSE    3382mm     IFNE DEBUG
002017D6                          3383mm     ENDC
002017D6                          3384mm 
002017D6                          3385mm     ENDM
002017D6                          3386mm     PRINT_CHAR #'x',D3
002017D6                          3387mm WAIT_FOR_READY_245                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017D6                 TRUE     3388mm     IFEQ DEBUG
002017D6  1639 00C00003           3389mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002017DC  0803 0002               3390mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002017E0  67F4                    3391mm         BEQ WAIT_FOR_READY_245          ; NO SPACE, CHECK AGAIN
002017E2  13FC 0078 00C00007      3392mm         MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
002017EA                          3393mm     ENDC
002017EA                          3394mm     
002017EA                 FALSE    3395mm     IFNE DEBUG
002017EA                          3396mm     ENDC
002017EA                          3397mm 
002017EA                          3398mm     ENDM
002017EA  7C07                    3399m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002017EC                          3400m LOOP_243
002017EC                          3401mm     BIN2HEX D1,D2,A1
002017EC  43F9 00201AFA           3402mm     LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
002017F2  E999                    3403mm     ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002017F4  1401                    3404mm     MOVE.B D1,D2
002017F6  0282 0000000F           3405mm     ANDI.L #$F,D2
002017FC  1431 2000               3406mm     MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00201800                          3407mm     ENDM
00201800                          3408mm     PRINT_CHAR D2,D3
00201800                          3409mm WAIT_FOR_READY_247                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201800                 TRUE     3410mm     IFEQ DEBUG
00201800  1639 00C00003           3411mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201806  0803 0002               3412mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0020180A  67F4                    3413mm         BEQ WAIT_FOR_READY_247          ; NO SPACE, CHECK AGAIN
0020180C  13C2 00C00007           3414mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201812                          3415mm     ENDC
00201812                          3416mm     
00201812                 FALSE    3417mm     IFNE DEBUG
00201812                          3418mm     ENDC
00201812                          3419mm 
00201812                          3420mm     ENDM
00201812  57CE FFD8               3421m     DBEQ D6,LOOP_243
00201816                          3422m     ENDM
00201816                          3423m         PRINT_CRLF D3
00201816                          3424mm     PRINT_CHAR #13,D3             ; CR
00201816                          3425mm WAIT_FOR_READY_249                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201816                 TRUE     3426mm     IFEQ DEBUG
00201816  1639 00C00003           3427mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020181C  0803 0002               3428mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201820  67F4                    3429mm         BEQ WAIT_FOR_READY_249          ; NO SPACE, CHECK AGAIN
00201822  13FC 000D 00C00007      3430mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0020182A                          3431mm     ENDC
0020182A                          3432mm     
0020182A                 FALSE    3433mm     IFNE DEBUG
0020182A                          3434mm     ENDC
0020182A                          3435mm 
0020182A                          3436mm     ENDM
0020182A                          3437mm     PRINT_CHAR #10,D3             ; LF
0020182A                          3438mm WAIT_FOR_READY_250                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020182A                 TRUE     3439mm     IFEQ DEBUG
0020182A  1639 00C00003           3440mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201830  0803 0002               3441mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201834  67F4                    3442mm         BEQ WAIT_FOR_READY_250          ; NO SPACE, CHECK AGAIN
00201836  13FC 000A 00C00007      3443mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0020183E                          3444mm     ENDC
0020183E                          3445mm     
0020183E                 FALSE    3446mm     IFNE DEBUG
0020183E                          3447mm     ENDC
0020183E                          3448mm 
0020183E                          3449mm     ENDM
0020183E                          3450m     ENDM
0020183E                          3451  OK    
0020183E  5880                    3452          ADD.L #4,D0
00201840                          3453      ENDW
00201840  6000 FF2E               3454s     BRA _10000008
00201844                          3455s _10000009
00201844                          3456      
00201844  4EF9 00200188           3457      JMP MAIN_LOOP
0020184A                          3458    
0020184A  7A00                    3459  L   MOVE.L #0,D5                    ; D5 will be the length  to write            
0020184C                          3460  
0020184C                          3461m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
0020184C                          3462m WAIT_FOR_READY_251                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020184C                          3463m 
0020184C                 TRUE     3464m     IFEQ DEBUG
0020184C  1639 00C00003           3465m         MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00201852  0803 0000               3466m         BTST #0,D3                    ; CHECK FOR CHARACTER
00201856  67F4                    3467m         BEQ WAIT_FOR_READY_251          ; NOTHING, CHECK AGAIN
00201858                          3468m     ENDC
00201858                          3469m     
00201858                          3470mm     READ_CHAR D2
00201858                 TRUE     3471mm     IFEQ DEBUG
00201858  1439 00C00007           3472mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0020185E                          3473mm     ENDC
0020185E                 FALSE    3474mm     IFNE DEBUG
0020185E                          3475mm     ENDC
0020185E                          3476mm      
0020185E  B43C 001B               3477mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00201862  6700 E7A4               3478mm     BEQ START
00201866                          3479mm     ENDM
00201866                          3480m 
00201866                 TRUE     3481m     IFEQ DEBUG
00201866                          3482mm         PRINT_CHAR D2,D3            ; ECHO IT BACK
00201866                          3483mm WAIT_FOR_READY_253                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201866                 TRUE     3484mm     IFEQ DEBUG
00201866  1639 00C00003           3485mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0020186C  0803 0002               3486mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201870  67F4                    3487mm         BEQ WAIT_FOR_READY_253          ; NO SPACE, CHECK AGAIN
00201872  13C2 00C00007           3488mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00201878                          3489mm     ENDC
00201878                          3490mm     
00201878                 FALSE    3491mm     IFNE DEBUG
00201878                          3492mm     ENDC
00201878                          3493mm 
00201878                          3494mm     ENDM
00201878                          3495m     ENDC
00201878                          3496m     ENDM
00201878                          3497m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00201878  41F9 00201B0A           3498m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0020187E  0402 0030               3499m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201882  C4BC 000000FF           3500m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00201888  1430 2000               3501m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0020188C                          3502m     ENDM
0020188C  1A02                    3503      MOVE.B D2,D5                    ; put at bottom of D5
0020188E                          3504  
0020188E  3C3C 0002               3505      MOVE #2,D6                      ; 3 bytes left to read
00201892                          3506      
00201892                          3507  READ_LENGTH
00201892  E98D                    3508      LSL.L #4,D5                     ; make what we have so far more significant
00201894                          3509m     WAIT_CHAR D2,D3                 ; next character -> D2
00201894                          3510m WAIT_FOR_READY_255                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201894                          3511m 
00201894                 TRUE     3512m     IFEQ DEBUG
00201894  1639 00C00003           3513m         MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
0020189A  0803 0000               3514m         BTST #0,D3                    ; CHECK FOR CHARACTER
0020189E  67F4                    3515m         BEQ WAIT_FOR_READY_255          ; NOTHING, CHECK AGAIN
002018A0                          3516m     ENDC
002018A0                          3517m     
002018A0                          3518mm     READ_CHAR D2
002018A0                 TRUE     3519mm     IFEQ DEBUG
002018A0  1439 00C00007           3520mm         MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
002018A6                          3521mm     ENDC
002018A6                 FALSE    3522mm     IFNE DEBUG
002018A6                          3523mm     ENDC
002018A6                          3524mm      
002018A6  B43C 001B               3525mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
002018AA  6700 E75C               3526mm     BEQ START
002018AE                          3527mm     ENDM
002018AE                          3528m 
002018AE                 TRUE     3529m     IFEQ DEBUG
002018AE                          3530mm         PRINT_CHAR D2,D3            ; ECHO IT BACK
002018AE                          3531mm WAIT_FOR_READY_257                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018AE                 TRUE     3532mm     IFEQ DEBUG
002018AE  1639 00C00003           3533mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018B4  0803 0002               3534mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018B8  67F4                    3535mm         BEQ WAIT_FOR_READY_257          ; NO SPACE, CHECK AGAIN
002018BA  13C2 00C00007           3536mm         MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
002018C0                          3537mm     ENDC
002018C0                          3538mm     
002018C0                 FALSE    3539mm     IFNE DEBUG
002018C0                          3540mm     ENDC
002018C0                          3541mm 
002018C0                          3542mm     ENDM
002018C0                          3543m     ENDC
002018C0                          3544m     ENDM
002018C0                          3545m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
002018C0  41F9 00201B0A           3546m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002018C6  0402 0030               3547m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002018CA  C4BC 000000FF           3548m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002018D0  1430 2000               3549m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002018D4                          3550m     ENDM
002018D4  8A02                    3551      OR.B D2,D5
002018D6  023C 00FB               3552      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
002018DA  57CE FFB6               3553      DBEQ D6,READ_LENGTH
002018DE                          3554          
002018DE                          3555m     PRINT_CRLF D3
002018DE                          3556mm     PRINT_CHAR #13,D3             ; CR
002018DE                          3557mm WAIT_FOR_READY_260                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018DE                 TRUE     3558mm     IFEQ DEBUG
002018DE  1639 00C00003           3559mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018E4  0803 0002               3560mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018E8  67F4                    3561mm         BEQ WAIT_FOR_READY_260          ; NO SPACE, CHECK AGAIN
002018EA  13FC 000D 00C00007      3562mm         MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
002018F2                          3563mm     ENDC
002018F2                          3564mm     
002018F2                 FALSE    3565mm     IFNE DEBUG
002018F2                          3566mm     ENDC
002018F2                          3567mm 
002018F2                          3568mm     ENDM
002018F2                          3569mm     PRINT_CHAR #10,D3             ; LF
002018F2                          3570mm WAIT_FOR_READY_261                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018F2                 TRUE     3571mm     IFEQ DEBUG
002018F2  1639 00C00003           3572mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
002018F8  0803 0002               3573mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
002018FC  67F4                    3574mm         BEQ WAIT_FOR_READY_261          ; NO SPACE, CHECK AGAIN
002018FE  13FC 000A 00C00007      3575mm         MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00201906                          3576mm     ENDC
00201906                          3577mm     
00201906                 FALSE    3578mm     IFNE DEBUG
00201906                          3579mm     ENDC
00201906                          3580mm 
00201906                          3581mm     ENDM
00201906                          3582m     ENDM
00201906                          3583  
00201906  207C 00000000           3584      MOVE.L #ROM,A0                  ; start of ROM
0020190C                          3585      
0020190C  2247                    3586      MOVE.L D7,A1                    ; address accumulator -> address register
0020190E  7E00                    3587      MOVE.L #0,D7                    ; clear the now used address accumulator
00201910                          3588      
00201910  267C 00002AAA           3589      MOVE.L #$2AAA,A3
00201916  36BC AAAA               3590      MOVE.W #$AAAA,(A3)
0020191A  267C 00001554           3591      MOVE.L #$1554,A3
00201920  36BC 5555               3592      MOVE.W #$5555,(A3)
00201924  267C 00002AAA           3593      MOVE.L #$2AAA,A3
0020192A  36BC 8080               3594      MOVE.W #$8080,(A3)
0020192E  267C 00002AAA           3595      MOVE.L #$2AAA,A3
00201934  36BC AAAA               3596      MOVE.W #$AAAA,(A3)
00201938  267C 00001554           3597      MOVE.L #$1554,A3
0020193E  36BC 5555               3598      MOVE.W #$5555,(A3)
00201942  267C 00002AAA           3599      MOVE.L #$2AAA,A3
00201948  36BC 2020               3600      MOVE.W #$2020,(A3)
0020194C                          3601      
0020194C  45F9 00201B21           3602      LEA LOADING,A2                ; important for timing
00201952                          3603m     PRINT_STR A2,D3
00201952                          3604m LOOP_262
00201952  0C12 0000               3605m     CMP.B #0,(A2)                 ; 0 -> DONE
00201956  6700 001A               3606m     BEQ EXIT_262
0020195A                          3607mm     PRINT_CHAR (A2)+,D3
0020195A                          3608mm WAIT_FOR_READY_263                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020195A                 TRUE     3609mm     IFEQ DEBUG
0020195A  1639 00C00003           3610mm         MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00201960  0803 0002               3611mm         BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00201964  67F4                    3612mm         BEQ WAIT_FOR_READY_263          ; NO SPACE, CHECK AGAIN
00201966  13DA 00C00007           3613mm         MOVE.B (A2)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0020196C                          3614mm     ENDC
0020196C                          3615mm     
0020196C                 FALSE    3616mm     IFNE DEBUG
0020196C                          3617mm     ENDC
0020196C                          3618mm 
0020196C                          3619mm     ENDM
0020196C  4EF9 00201952           3620m     JMP LOOP_262
00201972                          3621m EXIT_262
00201972                          3622m     ENDM
00201972                          3623  
00201972  023C 00FB               3624      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00201976                          3625      
00201976                          3626      WHILE D5 <GT> #0 DO
00201976                          3627s _1000000A
00201976  BA7C 0000               3628s     CMP.W   #0,D5
0020197A  6F00 0020               3629s     BLE _1000000B
0020197E  5585                    3630          SUB.L #2,D5
00201980                          3631            
00201980  13D1 00E00001           3632          MOVE.B (A1),DISPLAY
00201986  3091                    3633          MOVE.W (A1),(A0)            ; write the data
00201988                          3634        
00201988                          3635    WAIT_FOR_COMPLETE:
00201988  3410                    3636          MOVE.W (A0),D2
0020198A                          3637  
0020198A                          3638          IF D2 <NE> (A1) THEN
0020198A  B451                    3639s     CMP.W   (A1),D2
0020198C  6700 0008               3640s     BEQ _0000000C
00201990  4EF9 00201988           3641              JMP WAIT_FOR_COMPLETE
00201996                          3642          ENDI
00201996                          3643s _0000000C
00201996                          3644        
00201996  5488                    3645          ADD.L #2,A0
00201998  5489                    3646          ADD.L #2,A1
0020199A                          3647      ENDW  
0020199A  60DA                    3648s     BRA _1000000A
0020199C                          3649s _1000000B
0020199C                          3650      
0020199C  267C 00002AAA           3651      MOVE.L #$2AAA,A3
002019A2  36BC AAAA               3652      MOVE.W #$AAAA,(A3)
002019A6  267C 00001554           3653      MOVE.L #$1554,A3
002019AC  36BC 5555               3654      MOVE.W #$5555,(A3)
002019B0  267C 00002AAA           3655      MOVE.L #$2AAA,A3
002019B6  36BC A0A0               3656      MOVE.W #$A0A0,(A3)
002019BA                          3657              
002019BA  4EF9 00200188           3658      JMP MAIN_LOOP
002019C0                          3659          
002019C0                          3660  HEX_DIGIT
002019C0  E98F                    3661      LSL.L #4,D7                    ; add the next digit in the next 4 bits
002019C2                          3662m     HEX2BIN D2,D2,A0
002019C2  41F9 00201B0A           3663m     LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
002019C8  0402 0030               3664m     SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002019CC  C4BC 000000FF           3665m     AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
002019D2  1430 2000               3666m     MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
002019D6                          3667m     ENDM
002019D6  8E02                    3668      OR.B D2,D7  
002019D8  4EF9 002001B0           3669      JMP GET_INPUT
002019DE                          3670  
002019DE  FFFF FFFF               3671      SIMHALT                         ; halt simulator
002019E2                          3672  
002019E2                          3673  ; strings
002019E2= 4D 44 46 2D 6D 6F ...   3674  VERSION DC.B 'MDF-mon V1.31 (08/04/2021)',13,10,0
002019FF= 3F 20 48 65 6C 70 ...   3675  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201A96= 48 75 68 3F 0D 0A 00    3676  HUH     DC.B 'Huh?',13,10,0
00201A9D= 20 53 20 72 65 63 ...   3677  READ    DC.B ' S records read, start address = ',0
00201ABF= 57 3A 20 55 6E 6B ...   3678  UNREC   DC.B 'W: Unknown Srec type: ',0
00201AD6= 57 3A 20 43 53 20 ...   3679  CS_FAILURE   DC.B 'W: CS failure at ',0
00201AE8= 57 3A 20 52 41 4D ...   3680  RAM_ERROR DC.B 'W: RAM error at: ',0
00201AFA= 30 31 32 33 34 35 ...   3681  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201B0A= 00 01 02 03 04 05 ...   3682  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201B21= 4C 6F 61 64 69 6E ...   3683  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201B35                          3684      
00201B35                          3685      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201AFA
CONTINUE_100        200A6A
CONTINUE_104        200AC8
CONTINUE_108        200B28
CONTINUE_112        200B86
CONTINUE_116        200BF8
CONTINUE_120        200C56
CONTINUE_127        200CFE
CONTINUE_131        200D5C
CONTINUE_135        200DBC
CONTINUE_139        200E1A
CONTINUE_143        200E7E
CONTINUE_147        200EDC
CONTINUE_151        200F52
CONTINUE_155        200FB0
CONTINUE_159        20102A
CONTINUE_163        201088
CONTINUE_167        2010E8
CONTINUE_171        201146
CONTINUE_175        2011B8
CONTINUE_179        201216
CONTINUE_186        2012BE
CONTINUE_189        20130A
CONTINUE_192        201358
CONTINUE_195        2013A4
CONTINUE_198        2013F6
CONTINUE_201        201442
CONTINUE_210        20150E
CONTINUE_213        20155A
CONTINUE_44         2004BC
CONTINUE_46         2004F8
CONTINUE_48         200530
CONTINUE_51         20057C
CONTINUE_54         2005D2
CONTINUE_57         20061E
CONTINUE_60         20066C
CONTINUE_63         2006B8
CONTINUE_66         200718
CONTINUE_69         200764
CONTINUE_76         200802
CONTINUE_80         200860
CONTINUE_84         2008C0
CONTINUE_88         20091E
CONTINUE_92         200994
CONTINUE_96         2009F2
CS_FAILURE          201AD6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            91A
DOWNLOAD_DONE       201638
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EVEN                200A40
EVEN2               200FFE
EXIT_19             2002EA
EXIT_204            2014A8
EXIT_21             200316
EXIT_216            2015B4
EXIT_23             200342
EXIT_231            2016B2
EXIT_241            2017BE
EXIT_262            201972
EXIT_5              200142
G                   201736
GET_INPUT           2001B0
H                   2002F0
HELP                2019FF
HEX2BIN             137
HEX2BIN_LUT         201B0A
HEX_DIGIT           2019C0
HUH                 201A96
L                   20184A
LOADING             201B21
LOOP_19             2002CA
LOOP_204            201488
LOOP_21             2002F6
LOOP_216            201594
LOOP_218            2015DE
LOOP_226            201662
LOOP_23             200322
LOOP_231            201692
LOOP_233            2016DE
LOOP_241            20179E
LOOP_243            2017EC
LOOP_25             200376
LOOP_262            201952
LOOP_5              200122
MAIN_LOOP           200188
OK                  20183E
PRINT_CHAR          26E
PRINT_CRLF          475
PRINT_REG           551
PRINT_STR           4CF
R                   200348
RAM                 200000
RAM_ERROR           201AE8
READ                201A9D
READ_CHAR           7C9
READ_DATA_TO_POKE   200418
READ_LENGTH         201892
RESET               200004
ROM                 0
RRRR                200000
S                   200498
STACK               200000
START               200008
UNREC               201ABF
V                   20031C
VERSION             2019E2
W                   2003D0
WAIT_CHAR           639
WAIT_FOR_COMPLETE   201988
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  200A4E
WAIT_FOR_READY_102  200A82
WAIT_FOR_READY_104  200AAC
WAIT_FOR_READY_106  200AE0
WAIT_FOR_READY_108  200B0C
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200B40
WAIT_FOR_READY_112  200B6A
WAIT_FOR_READY_114  200B9E
WAIT_FOR_READY_116  200BDC
WAIT_FOR_READY_118  200C10
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_120  200C3A
WAIT_FOR_READY_122  200C6E
WAIT_FOR_READY_125  200CA6
WAIT_FOR_READY_126  200CBA
WAIT_FOR_READY_127  200CE2
WAIT_FOR_READY_129  200D16
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D40
WAIT_FOR_READY_133  200D74
WAIT_FOR_READY_135  200DA0
WAIT_FOR_READY_137  200DD4
WAIT_FOR_READY_139  200DFE
WAIT_FOR_READY_141  200E32
WAIT_FOR_READY_143  200E62
WAIT_FOR_READY_145  200E96
WAIT_FOR_READY_147  200EC0
WAIT_FOR_READY_149  200EF4
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200F36
WAIT_FOR_READY_153  200F6A
WAIT_FOR_READY_155  200F94
WAIT_FOR_READY_157  200FC8
WAIT_FOR_READY_159  20100E
WAIT_FOR_READY_161  201042
WAIT_FOR_READY_163  20106C
WAIT_FOR_READY_165  2010A0
WAIT_FOR_READY_167  2010CC
WAIT_FOR_READY_169  201100
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  20112A
WAIT_FOR_READY_173  20115E
WAIT_FOR_READY_175  20119C
WAIT_FOR_READY_177  2011D0
WAIT_FOR_READY_179  2011FA
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  20122E
WAIT_FOR_READY_184  201266
WAIT_FOR_READY_185  20127A
WAIT_FOR_READY_186  2012A2
WAIT_FOR_READY_189  2012EE
WAIT_FOR_READY_192  20133C
WAIT_FOR_READY_195  201388
WAIT_FOR_READY_198  2013DA
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  201426
WAIT_FOR_READY_205  201490
WAIT_FOR_READY_206  2014A8
WAIT_FOR_READY_208  2014BA
WAIT_FOR_READY_209  2014CE
WAIT_FOR_READY_210  2014F2
WAIT_FOR_READY_213  20153E
WAIT_FOR_READY_217  20159C
WAIT_FOR_READY_219  2015B4
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_220  2015C8
WAIT_FOR_READY_222  2015F2
WAIT_FOR_READY_224  201608
WAIT_FOR_READY_225  20161C
WAIT_FOR_READY_227  201638
WAIT_FOR_READY_228  20164C
WAIT_FOR_READY_230  201676
WAIT_FOR_READY_232  20169A
WAIT_FOR_READY_234  2016B4
WAIT_FOR_READY_235  2016C8
WAIT_FOR_READY_237  2016F2
WAIT_FOR_READY_239  201708
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_240  20171C
WAIT_FOR_READY_242  2017A6
WAIT_FOR_READY_244  2017C2
WAIT_FOR_READY_245  2017D6
WAIT_FOR_READY_247  201800
WAIT_FOR_READY_249  201816
WAIT_FOR_READY_250  20182A
WAIT_FOR_READY_251  20184C
WAIT_FOR_READY_253  201866
WAIT_FOR_READY_255  201894
WAIT_FOR_READY_257  2018AE
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_260  2018DE
WAIT_FOR_READY_261  2018F2
WAIT_FOR_READY_263  20195A
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DC
WAIT_FOR_READY_48   200514
WAIT_FOR_READY_51   200560
WAIT_FOR_READY_54   2005B6
WAIT_FOR_READY_57   200602
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200650
WAIT_FOR_READY_63   20069C
WAIT_FOR_READY_66   2006FC
WAIT_FOR_READY_69   200748
WAIT_FOR_READY_72   200794
WAIT_FOR_READY_74   2007AA
WAIT_FOR_READY_75   2007BE
WAIT_FOR_READY_76   2007E6
WAIT_FOR_READY_78   20081A
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   200844
WAIT_FOR_READY_82   200878
WAIT_FOR_READY_84   2008A4
WAIT_FOR_READY_86   2008D8
WAIT_FOR_READY_88   200902
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   200936
WAIT_FOR_READY_92   200978
WAIT_FOR_READY_94   2009AC
WAIT_FOR_READY_96   2009D6
WAIT_FOR_READY_98   200A0A
WAIT_FOR_SRECORD    2004A0
Z                   20173E
_00000000           2007DC
_00000001           2014E8
_00000002           200CD8
_00000003           200CA6
_00000004           2014E8
_00000005           201298
_00000006           201266
_00000007           2014E8
_00000008           201482
_00000009           2014E8
_0000000A           201636
_0000000B           201798
_0000000C           201996
_10000000           2006EE
_10000001           2007AA
_10000002           200A40
_10000003           200BD2
_10000004           201000
_10000005           201192
_10000006           201746
_10000007           201768
_10000008           201770
_10000009           201844
_1000000A           201976
_1000000B           20199C
