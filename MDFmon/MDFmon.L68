00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 18:01:22

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ORG  $0
00000000                            21      ;ORG  $200000
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF,\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      PRINT_CHAR #'0',\2                              ;0x header
00000000                           143      PRINT_CHAR #'x',\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  
00000000                           227  ; register catalogue
00000000                           228  ; D0 - used for simulator I/O
00000000                           229  ; D1 - used for simulator I/O
00000000                           230  ; D2 - read character
00000000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           232  ; D6 - working register used in R/W
00000000                           233  ; D7 - address accumulator, reset by download
00000000                           234  ; A0 - address of string to print 
00000000                           235  
00000000                           236  ; start vector
00000000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 238  RESET    DC.L START                             ; RESET
00000008                           239      
00000008                           240  ; start of program  
00000008                           241  START
00000008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00000010                           243  
00000010                           244  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                           ; reset everyting
00000020  4E71                     247      NOP
00000022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     249      NOP
0000002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00000034  4E71                     251      NOP
00000036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0000003E  4E71                     253      NOP
00000040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00000048                           255  
00000048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                           ; reset everyting
00000058  4E71                     258      NOP
0000005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00000062  4E71                     260      NOP
00000064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0000006C  4E71                     262      NOP
0000006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00000076  4E71                     264      NOP
00000078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00000080                           266  
00000080                           267  ;initialise UART
00000080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00000098                           271  
00000098                           272  ; channel A
00000098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
000000A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
000000B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000000B8                           277  
000000B8                           278  ; channel B
000000B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000D8                           283  
000000D8                           284m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      286m     IFEQ DEBUG
000000D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           291m     ENDC
000000EC                           292m     
000000EC                 FALSE     293m     IFNE DEBUG
000000EC                           294m     ENDC
000000EC                           295m 
000000EC                           296m     ENDM
000000EC                           297  
000000EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
000000F4                           299         
000000F4                           300m     PRINT_CRLF D3,A0
000000F4  41F9 00000E7E            301m     LEA CRLF,A0
000000FA                           302mm     PRINT_STR A0,D3
000000FA                           303mm LOOP_3
000000FA  0C10 0000                304mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FE  6700 0016                305mm     BEQ EXIT_3
00000102                           306mmm     PRINT_CHAR (A0)+,D3
00000102                           307mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000102                 TRUE      308mmm     IFEQ DEBUG
00000102  1639 00C00003            309mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000108  0803 0002                310mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010C  67F4                     311mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
0000010E  13D8 00C00007            312mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000114                           313mmm     ENDC
00000114                           314mmm     
00000114                 FALSE     315mmm     IFNE DEBUG
00000114                           316mmm     ENDC
00000114                           317mmm 
00000114                           318mmm     ENDM
00000114  60E4                     319mm     BRA LOOP_3
00000116                           320mm EXIT_3
00000116                           321mm     ENDM
00000116                           322m     ENDM
00000116                           323  
00000116  41F9 00000D12            324      LEA VERSION,A0
0000011C                           325m     PRINT_STR A0,D3
0000011C                           326m LOOP_5
0000011C  0C10 0000                327m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000120  6700 0016                328m     BEQ EXIT_5
00000124                           329mm     PRINT_CHAR (A0)+,D3
00000124                           330mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000124                 TRUE      331mm     IFEQ DEBUG
00000124  1639 00C00003            332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000012A  0803 0002                333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012E  67F4                     334mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000130  13D8 00C00007            335mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000136                           336mm     ENDC
00000136                           337mm     
00000136                 FALSE     338mm     IFNE DEBUG
00000136                           339mm     ENDC
00000136                           340mm 
00000136                           341mm     ENDM
00000136  60E4                     342m     BRA LOOP_5
00000138                           343m EXIT_5
00000138                           344m     ENDM
00000138                           345m     PRINT_CRLF D3,A0
00000138  41F9 00000E7E            346m     LEA CRLF,A0
0000013E                           347mm     PRINT_STR A0,D3
0000013E                           348mm LOOP_8
0000013E  0C10 0000                349mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                350mm     BEQ EXIT_8
00000146                           351mmm     PRINT_CHAR (A0)+,D3
00000146                           352mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      353mmm     IFEQ DEBUG
00000146  1639 00C00003            354mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                355mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     356mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            357mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           358mmm     ENDC
00000158                           359mmm     
00000158                 FALSE     360mmm     IFNE DEBUG
00000158                           361mmm     ENDC
00000158                           362mmm 
00000158                           363mmm     ENDM
00000158  60E4                     364mm     BRA LOOP_8
0000015A                           365mm EXIT_8
0000015A                           366mm     ENDM
0000015A                           367m     ENDM
0000015A                           368  
0000015A  7E00                     369      MOVE.L #0,D7                                    ; address accumulator
0000015C                           370  
0000015C  13FC 0002 00E00001       371      MOVE.B #2,DISPLAY
00000164                           372  MAIN_LOOP
00000164                           373m     PRINT_CHAR #'>',D3                          ; prompt
00000164                           374m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000164                 TRUE      375m     IFEQ DEBUG
00000164  1639 00C00003            376m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016A  0803 0002                377m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000016E  67F4                     378m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000170  13FC 003E 00C00007       379m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000178                           380m     ENDC
00000178                           381m     
00000178                 FALSE     382m     IFNE DEBUG
00000178                           383m     ENDC
00000178                           384m 
00000178                           385m     ENDM
00000178                           386m     PRINT_CHAR #32,D3                           ; space
00000178                           387m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      388m     IFEQ DEBUG
00000178  1639 00C00003            389m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                390m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     391m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000184  13FC 0020 00C00007       392m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000018C                           393m     ENDC
0000018C                           394m     
0000018C                 FALSE     395m     IFNE DEBUG
0000018C                           396m     ENDC
0000018C                           397m 
0000018C                           398m     ENDM
0000018C                           399      
0000018C                           400  GET_INPUT
0000018C                           401m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000018C                           402m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000018C                 TRUE      403m     IFEQ DEBUG
0000018C  1639 00C00003            404m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000192  0803 0000                405m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000196  67F4                     406m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000198                           407m     ENDC
00000198                           408m     
00000198                           409mm     READ_CHAR D2
00000198                 TRUE      410mm     IFEQ DEBUG
00000198  1439 00C00007            411mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000019E                           412mm     ENDC
0000019E                 FALSE     413mm     IFNE DEBUG
0000019E                           414mm     ENDC
0000019E                           415mm      
0000019E  B43C 001B                416mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001A2  6700 FE64                417mm     BEQ START
000001A6                           418mm     ENDM
000001A6                           419m 
000001A6                 TRUE      420m     IFEQ DEBUG
000001A6                           421mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001A6                           422mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001A6                 TRUE      423mm     IFEQ DEBUG
000001A6  1639 00C00003            424mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001AC  0803 0002                425mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001B0  67F4                     426mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
000001B2  13C2 00C00007            427mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001B8                           428mm     ENDC
000001B8                           429mm     
000001B8                 FALSE     430mm     IFNE DEBUG
000001B8                           431mm     ENDC
000001B8                           432mm 
000001B8                           433mm     ENDM
000001B8                           434m     ENDC
000001B8                           435m     ENDM
000001B8                           436      
000001B8                           437      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001B8  B43C 0030                438s     CMP.B   #'0',D2
000001BC  6D00 000E                439s     BLT _00000000
000001C0  B43C 0039                440s     CMP.B   #'9',D2
000001C4  6E00 0006                441s     BGT _00000000
000001C8  6000 0B28                442          BRA HEX_DIGIT
000001CC                           443      ENDI
000001CC                           444s _00000000
000001CC                           445      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001CC  B43C 0041                446s     CMP.B   #'A',D2
000001D0  6D00 000E                447s     BLT _00000001
000001D4  B43C 0046                448s     CMP.B   #'F',D2
000001D8  6E00 0006                449s     BGT _00000001
000001DC  6000 0B14                450          BRA HEX_DIGIT
000001E0                           451      ENDI
000001E0                           452s _00000001
000001E0                           453          
000001E0  B43C 0077                454      CMP.B #'w',D2
000001E4  6700 0132                455      BEQ W
000001E8                           456      
000001E8  B43C 006C                457      CMP.B #'l',D2
000001EC  6700 0A04                458      BEQ L 
000001F0                           459  
000001F0                           460m     PRINT_CRLF D3,A0
000001F0  41F9 00000E7E            461m     LEA CRLF,A0
000001F6                           462mm     PRINT_STR A0,D3
000001F6                           463mm LOOP_16
000001F6  0C10 0000                464mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001FA  6700 0016                465mm     BEQ EXIT_16
000001FE                           466mmm     PRINT_CHAR (A0)+,D3
000001FE                           467mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001FE                 TRUE      468mmm     IFEQ DEBUG
000001FE  1639 00C00003            469mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000204  0803 0002                470mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000208  67F4                     471mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0000020A  13D8 00C00007            472mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000210                           473mmm     ENDC
00000210                           474mmm     
00000210                 FALSE     475mmm     IFNE DEBUG
00000210                           476mmm     ENDC
00000210                           477mmm 
00000210                           478mmm     ENDM
00000210  60E4                     479mm     BRA LOOP_16
00000212                           480mm EXIT_16
00000212                           481mm     ENDM
00000212                           482m     ENDM
00000212                           483   
00000212  B43C 003F                484      CMP.B #'?',D2
00000216  6700 0050                485      BEQ H
0000021A                           486  
0000021A  B43C 0076                487      CMP.B #'v',D2
0000021E  6700 0052                488      BEQ V
00000222                           489      
00000222  B43C 0072                490      CMP.B #'r',D2
00000226  6700 0070                491      BEQ R
0000022A                           492  
0000022A  B43C 0073                493      CMP.B #'s',D2
0000022E  6700 0160                494      BEQ S
00000232                           495  
00000232  B43C 0067                496      CMP.B #'g',D2
00000236  6700 08C2                497      BEQ G   
0000023A                           498  
0000023A  B43C 007A                499      CMP.B #'z',D2
0000023E  6700 08C2                500      BEQ Z   
00000242                           501  
00000242  41F9 00000DDF            502      LEA HUH,A0
00000248                           503m     PRINT_STR A0,D3
00000248                           504m LOOP_18
00000248  0C10 0000                505m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024C  6700 0016                506m     BEQ EXIT_18
00000250                           507mm     PRINT_CHAR (A0)+,D3
00000250                           508mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000250                 TRUE      509mm     IFEQ DEBUG
00000250  1639 00C00003            510mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000256  0803 0002                511mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000025A  67F4                     512mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000025C  13D8 00C00007            513mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000262                           514mm     ENDC
00000262                           515mm     
00000262                 FALSE     516mm     IFNE DEBUG
00000262                           517mm     ENDC
00000262                           518mm 
00000262                           519mm     ENDM
00000262  60E4                     520m     BRA LOOP_18
00000264                           521m EXIT_18
00000264                           522m     ENDM
00000264                           523                         
00000264  6000 FEFE                524      BRA MAIN_LOOP
00000268                           525      
00000268                           526  ; commands
00000268                           527  H   
00000268  41F9 00000D2F            528      LEA HELP,A0
0000026E  6000 0008                529      BRA PRINTSTR
00000272                           530  
00000272                           531  V   
00000272  41F9 00000D12            532      LEA VERSION,A0
00000278                           533  PRINTSTR
00000278                           534m     PRINT_STR A0,D3       
00000278                           535m LOOP_20
00000278  0C10 0000                536m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000027C  6700 0016                537m     BEQ EXIT_20
00000280                           538mm     PRINT_CHAR (A0)+,D3
00000280                           539mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000280                 TRUE      540mm     IFEQ DEBUG
00000280  1639 00C00003            541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000286  0803 0002                542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000028A  67F4                     543mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000028C  13D8 00C00007            544mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000292                           545mm     ENDC
00000292                           546mm     
00000292                 FALSE     547mm     IFNE DEBUG
00000292                           548mm     ENDC
00000292                           549mm 
00000292                           550mm     ENDM
00000292  60E4                     551m     BRA LOOP_20
00000294                           552m EXIT_20
00000294                           553m     ENDM
00000294  6000 FECE                554      BRA MAIN_LOOP
00000298                           555      
00000298                           556  R   
00000298  2047                     557      MOVE.L D7,A0                                    ; address accumulator -> address register
0000029A  2A10                     558      MOVE.L (A0),D5                                  ; read the memory and print it
0000029C                           559m     PRINT_REG D5,D3,D7,D6,A0
0000029C                           560mm     PRINT_CHAR #'0',D3                              ;0X HEADER
0000029C                           561mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      562mm     IFEQ DEBUG
0000029C  1639 00C00003            563mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                564mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     565mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
000002A8  13FC 0030 00C00007       566mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002B0                           567mm     ENDC
000002B0                           568mm     
000002B0                 FALSE     569mm     IFNE DEBUG
000002B0                           570mm     ENDC
000002B0                           571mm 
000002B0                           572mm     ENDM
000002B0                           573mm     PRINT_CHAR #'x',D3
000002B0                           574mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B0                 TRUE      575mm     IFEQ DEBUG
000002B0  1639 00C00003            576mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002B6  0803 0002                577mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002BA  67F4                     578mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
000002BC  13FC 0078 00C00007       579mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002C4                           580mm     ENDC
000002C4                           581mm     
000002C4                 FALSE     582mm     IFNE DEBUG
000002C4                           583mm     ENDC
000002C4                           584mm 
000002C4                           585mm     ENDM
000002C4  7C07                     586m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002C6                           587m LOOP_22
000002C6                           588mm     BIN2HEX D5,D7,A0
000002C6  41F9 00000E43            589mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
000002CC  E99D                     590mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002CE  1E05                     591mm     MOVE.B D5,D7
000002D0  0287 0000000F            592mm     ANDI.L #$F,D7
000002D6  1E30 7000                593mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
000002DA                           594mm     ENDM
000002DA                           595mm     PRINT_CHAR D7,D3
000002DA                           596mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DA                 TRUE      597mm     IFEQ DEBUG
000002DA  1639 00C00003            598mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002E0  0803 0002                599mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002E4  67F4                     600mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002E6  13C7 00C00007            601mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002EC                           602mm     ENDC
000002EC                           603mm     
000002EC                 FALSE     604mm     IFNE DEBUG
000002EC                           605mm     ENDC
000002EC                           606mm 
000002EC                           607mm     ENDM
000002EC  57CE FFD8                608m     DBEQ D6,LOOP_22
000002F0                           609m     ENDM
000002F0                           610m     PRINT_CRLF D3,A0
000002F0  41F9 00000E7E            611m     LEA CRLF,A0
000002F6                           612mm     PRINT_STR A0,D3
000002F6                           613mm LOOP_28
000002F6  0C10 0000                614mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002FA  6700 0016                615mm     BEQ EXIT_28
000002FE                           616mmm     PRINT_CHAR (A0)+,D3
000002FE                           617mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      618mmm     IFEQ DEBUG
000002FE  1639 00C00003            619mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000304  0803 0002                620mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000308  67F4                     621mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            622mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000310                           623mmm     ENDC
00000310                           624mmm     
00000310                 FALSE     625mmm     IFNE DEBUG
00000310                           626mmm     ENDC
00000310                           627mmm 
00000310                           628mmm     ENDM
00000310  60E4                     629mm     BRA LOOP_28
00000312                           630mm EXIT_28
00000312                           631mm     ENDM
00000312                           632m     ENDM
00000312  7E00                     633      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000314  6000 FE4E                634      BRA MAIN_LOOP
00000318                           635  
00000318                           636  W
00000318  3C3C 0007                637      MOVE #7,D6                                      ; 7 bytes left to read
0000031C                           638      
0000031C                           639  READ_DATA_TO_POKE
0000031C  E98D                     640      LSL.L #4,D5                                     ; make what we have so far more significant
0000031E                           641m     WAIT_CHAR D2,D3                                 ; next character -> D2
0000031E                           642m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031E                 TRUE      643m     IFEQ DEBUG
0000031E  1639 00C00003            644m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000324  0803 0000                645m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000328  67F4                     646m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
0000032A                           647m     ENDC
0000032A                           648m     
0000032A                           649mm     READ_CHAR D2
0000032A                 TRUE      650mm     IFEQ DEBUG
0000032A  1439 00C00007            651mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000330                           652mm     ENDC
00000330                 FALSE     653mm     IFNE DEBUG
00000330                           654mm     ENDC
00000330                           655mm      
00000330  B43C 001B                656mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000334  6700 FCD2                657mm     BEQ START
00000338                           658mm     ENDM
00000338                           659m 
00000338                 TRUE      660m     IFEQ DEBUG
00000338                           661mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000338                           662mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000338                 TRUE      663mm     IFEQ DEBUG
00000338  1639 00C00003            664mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000033E  0803 0002                665mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000342  67F4                     666mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00000344  13C2 00C00007            667mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000034A                           668mm     ENDC
0000034A                           669mm     
0000034A                 FALSE     670mm     IFNE DEBUG
0000034A                           671mm     ENDC
0000034A                           672mm 
0000034A                           673mm     ENDM
0000034A                           674m     ENDC
0000034A                           675m     ENDM
0000034A                           676m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0000034A  41F9 00000E53            677m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000350  0402 0030                678m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000354  C4BC 000000FF            679m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000035A  1430 2000                680m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
0000035E                           681m     ENDM
0000035E  8A02                     682      OR.B D2,D5
00000360  57CE FFBA                683      DBEQ D6,READ_DATA_TO_POKE
00000364                           684      
00000364  2047                     685      MOVE.L D7,A0                                    ; address accumulator -> address register
00000366  7E00                     686      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000368                           687      
00000368  2085                     688      MOVE.L D5,(A0)                                  ; write the data
0000036A                           689  
0000036A                           690m     PRINT_CRLF D3,A0
0000036A  41F9 00000E7E            691m     LEA CRLF,A0
00000370                           692mm     PRINT_STR A0,D3
00000370                           693mm LOOP_35
00000370  0C10 0000                694mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000374  6700 0016                695mm     BEQ EXIT_35
00000378                           696mmm     PRINT_CHAR (A0)+,D3
00000378                           697mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000378                 TRUE      698mmm     IFEQ DEBUG
00000378  1639 00C00003            699mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000037E  0803 0002                700mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000382  67F4                     701mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
00000384  13D8 00C00007            702mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000038A                           703mmm     ENDC
0000038A                           704mmm     
0000038A                 FALSE     705mmm     IFNE DEBUG
0000038A                           706mmm     ENDC
0000038A                           707mmm 
0000038A                           708mmm     ENDM
0000038A  60E4                     709mm     BRA LOOP_35
0000038C                           710mm EXIT_35
0000038C                           711mm     ENDM
0000038C                           712m     ENDM
0000038C  6000 FDD6                713      BRA MAIN_LOOP
00000390                           714  
00000390                           715  ; register map for S
00000390                           716  ; A0 - start address
00000390                           717  ; A1 - offset
00000390                           718  ; A2 - next address to write
00000390                           719  ; A3 - next location (jmp)
00000390                           720  ; A4 - Working Address Register
00000390                           721  ; D0 - record count
00000390                           722  ; D1 - 'S', record type, data byte
00000390                           723  ; D2 - checksum
00000390                           724  ; D3 - data byte count
00000390                           725  ; D4 - read address, moved into A2
00000390                           726  ; D5 - temp
00000390                           727  ; D6 - temp
00000390                           728  ; D7 - temp
00000390                           729  S
00000390  2078 0000                730      MOVE.L 0,A0                                     ; start address -> A0
00000394  2247                     731      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000396                           732      
00000396  7000                     733      MOVE.L #0,D0                                    ; count of records read -> D0
00000398                           734          
00000398                           735  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000398                           736m     DOWNLOAD D1                 
00000398                           737m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000398                           738m 
00000398  1239 00C00003            739m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0000039E  0801 0000                740m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003A2  6700 0010                741m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
000003A6                           742m  
000003A6                           743mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003A6                 TRUE      744mm     IFEQ DEBUG
000003A6  1239 00C00007            745mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003AC                           746mm     ENDC
000003AC                 FALSE     747mm     IFNE DEBUG
000003AC                           748mm     ENDC
000003AC                           749mm      
000003AC  B23C 001B                750mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003B0  6700 FC56                751mm     BEQ START
000003B4                           752mm     ENDM
000003B4                           753m CONTINUE_37
000003B4  1239 00C00013            754m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003BA  0801 0000                755m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003BE  67D8                     756m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
000003C0                           757m     
000003C0  1239 00C00017            758m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003C6  13C1 00E00001            759m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003CC                           760m     
000003CC                           761m     ENDM
000003CC  B23C 0053                762      CMP.B #'S',D1                                   ; found S?    
000003D0  66C6                     763      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003D2                           764      
000003D2                           765m     PRINT_CHAR #'S',D5                            ; print the S
000003D2                           766m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D2                 TRUE      767m     IFEQ DEBUG
000003D2  1A39 00C00003            768m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003D8  0805 0002                769m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003DC  67F4                     770m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003DE  13FC 0053 00C00007       771m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003E6                           772m     ENDC
000003E6                           773m     
000003E6                 FALSE     774m     IFNE DEBUG
000003E6                           775m     ENDC
000003E6                           776m 
000003E6                           777m     ENDM
000003E6  5280                     778      ADD.L #1,D0                                     ; read another S record, increment count
000003E8                           779      
000003E8                           780m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003E8                           781m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E8                           782m 
000003E8  1239 00C00003            783m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003EE  0801 0000                784m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003F2  6700 0010                785m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003F6                           786m  
000003F6                           787mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003F6                 TRUE      788mm     IFEQ DEBUG
000003F6  1239 00C00007            789mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003FC                           790mm     ENDC
000003FC                 FALSE     791mm     IFNE DEBUG
000003FC                           792mm     ENDC
000003FC                           793mm      
000003FC  B23C 001B                794mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000400  6700 FC06                795mm     BEQ START
00000404                           796mm     ENDM
00000404                           797m CONTINUE_40
00000404  1239 00C00013            798m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000040A  0801 0000                799m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000040E  67D8                     800m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
00000410                           801m     
00000410  1239 00C00017            802m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000416  13C1 00E00001            803m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000041C                           804m     
0000041C                           805m     ENDM
0000041C                           806m     PRINT_CHAR D1,D5
0000041C                           807m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041C                 TRUE      808m     IFEQ DEBUG
0000041C  1A39 00C00003            809m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000422  0805 0002                810m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000426  67F4                     811m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000428  13C1 00C00007            812m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000042E                           813m     ENDC
0000042E                           814m     
0000042E                 FALSE     815m     IFNE DEBUG
0000042E                           816m     ENDC
0000042E                           817m 
0000042E                           818m     ENDM
0000042E                           819  
0000042E  7400                     820      MOVE.L #0,D2                                    ; clear the checksum
00000430                           821  
00000430                           822m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00000430  1E3C 0002                823m     MOVE.B #2,D7
00000434                           824m     WHILE.B D7 <GT> 0 DO
00000434                           825ms _10000000
00000434  BE38 0000                826ms     CMP.B   0,D7
00000438  6F00 0064                827ms     BLE _10000001
0000043C  E98B                     828m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
0000043E                           829mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000043E                           830mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043E                           831mm 
0000043E  1A39 00C00003            832mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000444  0805 0000                833mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000448  6700 0010                834mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0000044C                           835mm  
0000044C                           836mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000044C                 TRUE      837mmm     IFEQ DEBUG
0000044C  1A39 00C00007            838mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000452                           839mmm     ENDC
00000452                 FALSE     840mmm     IFNE DEBUG
00000452                           841mmm     ENDC
00000452                           842mmm      
00000452  BA3C 001B                843mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000456  6700 FBB0                844mmm     BEQ START
0000045A                           845mmm     ENDM
0000045A                           846mm CONTINUE_44
0000045A  1A39 00C00013            847mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000460  0805 0000                848mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000464  67D8                     849mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00000466                           850mm     
00000466  1A39 00C00017            851mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000046C  13C5 00E00001            852mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000472                           853mm     
00000472                           854mm     ENDM
00000472                           855mm         PRINT_CHAR D5,D6
00000472                           856mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000472                 TRUE      857mm     IFEQ DEBUG
00000472  1C39 00C00003            858mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000478  0806 0002                859mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000047C  67F4                     860mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
0000047E  13C5 00C00007            861mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000484                           862mm     ENDC
00000484                           863mm     
00000484                 FALSE     864mm     IFNE DEBUG
00000484                           865mm     ENDC
00000484                           866mm 
00000484                           867mm     ENDM
00000484                           868mm         HEX2BIN D5,D5,A4
00000484  49F9 00000E53            869mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000048A  0405 0030                870mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000048E  CABC 000000FF            871mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000494  1A34 5000                872mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000498                           873mm     ENDM
00000498  8605                     874m         OR.B D5,D3
0000049A  5307                     875m         SUB.B #1,D7
0000049C                           876m     ENDW
0000049C  6096                     877ms     BRA _10000000
0000049E                           878ms _10000001
0000049E                           879m     
0000049E  7A00                     880m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000004A0  1A03                     881m     MOVE.B D3,D5
000004A2  D483                     882m     ADD.L D3,D2
000004A4                           883m 
000004A4                           884m     ENDM
000004A4                           885  
000004A4                           886      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004A4  B23C 0030                887s     CMP.B   #'0',D1
000004A8  6600 002C                888s     BNE.L   _00000002
000004AC                           889m         PRINT_CRLF D5,A4
000004AC  49F9 00000E7E            890m     LEA CRLF,A4
000004B2                           891mm     PRINT_STR A4,D5
000004B2                           892mm LOOP_49
000004B2  0C14 0000                893mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000004B6  6700 0016                894mm     BEQ EXIT_49
000004BA                           895mmm     PRINT_CHAR (A4)+,D5
000004BA                           896mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BA                 TRUE      897mmm     IFEQ DEBUG
000004BA  1A39 00C00003            898mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004C0  0805 0002                899mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004C4  67F4                     900mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
000004C6  13DC 00C00007            901mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000004CC                           902mmm     ENDC
000004CC                           903mmm     
000004CC                 FALSE     904mmm     IFNE DEBUG
000004CC                           905mmm     ENDC
000004CC                           906mmm 
000004CC                           907mmm     ENDM
000004CC  60E4                     908mm     BRA LOOP_49
000004CE                           909mm EXIT_49
000004CE                           910mm     ENDM
000004CE                           911m     ENDM
000004CE  6000 FEC8                912          BRA WAIT_FOR_SRECORD
000004D2                           913      ELSE
000004D2  6000 03F8                914s     BRA _00000003
000004D6                           915s _00000002
000004D6                           916          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000004D6  B23C 0031                917s     CMP.B   #'1',D1
000004DA  6708                     918s     BEQ.S   _00000004
000004DC  B23C 0032                919s     CMP.B   #'2',D1
000004E0  6600 01FC                920s     BNE.L   _00000005
000004E4                           921s _00000004
000004E4  5783                     922              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004E6                           923      
000004E6  7800                     924              MOVE.L #0,D4                            ; read two bytes of address
000004E8                           925m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004E8  1E3C 0002                926m     MOVE.B #2,D7
000004EC                           927m     WHILE.B D7 <GT> 0 DO
000004EC                           928ms _10000002
000004EC  BE38 0000                929ms     CMP.B   0,D7
000004F0  6F00 0064                930ms     BLE _10000003
000004F4  E98C                     931m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004F6                           932mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004F6                           933mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F6                           934mm 
000004F6  1A39 00C00003            935mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004FC  0805 0000                936mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000500  6700 0010                937mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
00000504                           938mm  
00000504                           939mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000504                 TRUE      940mmm     IFEQ DEBUG
00000504  1A39 00C00007            941mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000050A                           942mmm     ENDC
0000050A                 FALSE     943mmm     IFNE DEBUG
0000050A                           944mmm     ENDC
0000050A                           945mmm      
0000050A  BA3C 001B                946mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000050E  6700 FAF8                947mmm     BEQ START
00000512                           948mmm     ENDM
00000512                           949mm CONTINUE_52
00000512  1A39 00C00013            950mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000518  0805 0000                951mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000051C  67D8                     952mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
0000051E                           953mm     
0000051E  1A39 00C00017            954mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000524  13C5 00E00001            955mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000052A                           956mm     
0000052A                           957mm     ENDM
0000052A                           958mm         PRINT_CHAR D5,D6
0000052A                           959mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052A                 TRUE      960mm     IFEQ DEBUG
0000052A  1C39 00C00003            961mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000530  0806 0002                962mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000534  67F4                     963mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
00000536  13C5 00C00007            964mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000053C                           965mm     ENDC
0000053C                           966mm     
0000053C                 FALSE     967mm     IFNE DEBUG
0000053C                           968mm     ENDC
0000053C                           969mm 
0000053C                           970mm     ENDM
0000053C                           971mm         HEX2BIN D5,D5,A4
0000053C  49F9 00000E53            972mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000542  0405 0030                973mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000546  CABC 000000FF            974mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000054C  1A34 5000                975mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000550                           976mm     ENDM
00000550  8805                     977m         OR.B D5,D4
00000552  5307                     978m         SUB.B #1,D7
00000554                           979m     ENDW
00000554  6096                     980ms     BRA _10000002
00000556                           981ms _10000003
00000556                           982m     
00000556  7A00                     983m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000558  1A04                     984m     MOVE.B D4,D5
0000055A  D484                     985m     ADD.L D4,D2
0000055C                           986m 
0000055C                           987m     ENDM
0000055C                           988m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
0000055C  1E3C 0002                989m     MOVE.B #2,D7
00000560                           990m     WHILE.B D7 <GT> 0 DO
00000560                           991ms _10000004
00000560  BE38 0000                992ms     CMP.B   0,D7
00000564  6F00 0064                993ms     BLE _10000005
00000568  E98C                     994m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000056A                           995mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000056A                           996mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056A                           997mm 
0000056A  1A39 00C00003            998mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000570  0805 0000                999mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000574  6700 0010               1000mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000578                          1001mm  
00000578                          1002mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000578                 TRUE     1003mmm     IFEQ DEBUG
00000578  1A39 00C00007           1004mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000057E                          1005mmm     ENDC
0000057E                 FALSE    1006mmm     IFNE DEBUG
0000057E                          1007mmm     ENDC
0000057E                          1008mmm      
0000057E  BA3C 001B               1009mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000582  6700 FA84               1010mmm     BEQ START
00000586                          1011mmm     ENDM
00000586                          1012mm CONTINUE_57
00000586  1A39 00C00013           1013mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000058C  0805 0000               1014mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000590  67D8                    1015mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00000592                          1016mm     
00000592  1A39 00C00017           1017mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000598  13C5 00E00001           1018mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000059E                          1019mm     
0000059E                          1020mm     ENDM
0000059E                          1021mm         PRINT_CHAR D5,D6
0000059E                          1022mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059E                 TRUE     1023mm     IFEQ DEBUG
0000059E  1C39 00C00003           1024mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005A4  0806 0002               1025mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005A8  67F4                    1026mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
000005AA  13C5 00C00007           1027mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005B0                          1028mm     ENDC
000005B0                          1029mm     
000005B0                 FALSE    1030mm     IFNE DEBUG
000005B0                          1031mm     ENDC
000005B0                          1032mm 
000005B0                          1033mm     ENDM
000005B0                          1034mm         HEX2BIN D5,D5,A4
000005B0  49F9 00000E53           1035mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005B6  0405 0030               1036mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005BA  CABC 000000FF           1037mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005C0  1A34 5000               1038mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005C4                          1039mm     ENDM
000005C4  8805                    1040m         OR.B D5,D4
000005C6  5307                    1041m         SUB.B #1,D7
000005C8                          1042m     ENDW
000005C8  6096                    1043ms     BRA _10000004
000005CA                          1044ms _10000005
000005CA                          1045m     
000005CA  7A00                    1046m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005CC  1A04                    1047m     MOVE.B D4,D5
000005CE  D484                    1048m     ADD.L D4,D2
000005D0                          1049m 
000005D0                          1050m     ENDM
000005D0                          1051              
000005D0                          1052              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
000005D0  B23C 0032               1053s     CMP.B   #'2',D1
000005D4  6600 0078               1054s     BNE.L   _00000006
000005D8  5383                    1055                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005DA                          1056m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005DA  1E3C 0002               1057m     MOVE.B #2,D7
000005DE                          1058m     WHILE.B D7 <GT> 0 DO
000005DE                          1059ms _10000006
000005DE  BE38 0000               1060ms     CMP.B   0,D7
000005E2  6F00 0064               1061ms     BLE _10000007
000005E6  E98C                    1062m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005E8                          1063mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005E8                          1064mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E8                          1065mm 
000005E8  1A39 00C00003           1066mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005EE  0805 0000               1067mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005F2  6700 0010               1068mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005F6                          1069mm  
000005F6                          1070mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005F6                 TRUE     1071mmm     IFEQ DEBUG
000005F6  1A39 00C00007           1072mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005FC                          1073mmm     ENDC
000005FC                 FALSE    1074mmm     IFNE DEBUG
000005FC                          1075mmm     ENDC
000005FC                          1076mmm      
000005FC  BA3C 001B               1077mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000600  6700 FA06               1078mmm     BEQ START
00000604                          1079mmm     ENDM
00000604                          1080mm CONTINUE_62
00000604  1A39 00C00013           1081mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000060A  0805 0000               1082mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000060E  67D8                    1083mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
00000610                          1084mm     
00000610  1A39 00C00017           1085mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000616  13C5 00E00001           1086mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000061C                          1087mm     
0000061C                          1088mm     ENDM
0000061C                          1089mm         PRINT_CHAR D5,D6
0000061C                          1090mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061C                 TRUE     1091mm     IFEQ DEBUG
0000061C  1C39 00C00003           1092mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000622  0806 0002               1093mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000626  67F4                    1094mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
00000628  13C5 00C00007           1095mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000062E                          1096mm     ENDC
0000062E                          1097mm     
0000062E                 FALSE    1098mm     IFNE DEBUG
0000062E                          1099mm     ENDC
0000062E                          1100mm 
0000062E                          1101mm     ENDM
0000062E                          1102mm         HEX2BIN D5,D5,A4
0000062E  49F9 00000E53           1103mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000634  0405 0030               1104mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000638  CABC 000000FF           1105mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000063E  1A34 5000               1106mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000642                          1107mm     ENDM
00000642  8805                    1108m         OR.B D5,D4
00000644  5307                    1109m         SUB.B #1,D7
00000646                          1110m     ENDW
00000646  6096                    1111ms     BRA _10000006
00000648                          1112ms _10000007
00000648                          1113m     
00000648  7A00                    1114m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000064A  1A04                    1115m     MOVE.B D4,D5
0000064C  D484                    1116m     ADD.L D4,D2
0000064E                          1117m 
0000064E                          1118m     ENDM
0000064E                          1119              ENDI
0000064E                          1120s _00000006
0000064E                          1121              
0000064E  2444                    1122                  MOVE.L D4,A2                            ; put the address in an address register
00000650  D5C9                    1123              ADD.L A1,A2                             ; add in the offset
00000652                          1124  
00000652                          1125              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
00000652                          1126s _10000008
00000652  B63C 0000               1127s     CMP.B   #0,D3
00000656  6F00 007E               1128s     BLE _10000009
0000065A                          1129m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
0000065A  1E3C 0002               1130m     MOVE.B #2,D7
0000065E                          1131m     WHILE.B D7 <GT> 0 DO
0000065E                          1132ms _1000000A
0000065E  BE38 0000               1133ms     CMP.B   0,D7
00000662  6F00 0064               1134ms     BLE _1000000B
00000666  E989                    1135m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000668                          1136mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000668                          1137mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000668                          1138mm 
00000668  1A39 00C00003           1139mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000066E  0805 0000               1140mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000672  6700 0010               1141mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
00000676                          1142mm  
00000676                          1143mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000676                 TRUE     1144mmm     IFEQ DEBUG
00000676  1A39 00C00007           1145mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000067C                          1146mmm     ENDC
0000067C                 FALSE    1147mmm     IFNE DEBUG
0000067C                          1148mmm     ENDC
0000067C                          1149mmm      
0000067C  BA3C 001B               1150mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000680  6700 F986               1151mmm     BEQ START
00000684                          1152mmm     ENDM
00000684                          1153mm CONTINUE_67
00000684  1A39 00C00013           1154mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000068A  0805 0000               1155mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000068E  67D8                    1156mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000690                          1157mm     
00000690  1A39 00C00017           1158mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000696  13C5 00E00001           1159mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000069C                          1160mm     
0000069C                          1161mm     ENDM
0000069C                          1162mm         PRINT_CHAR D5,D6
0000069C                          1163mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069C                 TRUE     1164mm     IFEQ DEBUG
0000069C  1C39 00C00003           1165mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006A2  0806 0002               1166mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006A6  67F4                    1167mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
000006A8  13C5 00C00007           1168mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006AE                          1169mm     ENDC
000006AE                          1170mm     
000006AE                 FALSE    1171mm     IFNE DEBUG
000006AE                          1172mm     ENDC
000006AE                          1173mm 
000006AE                          1174mm     ENDM
000006AE                          1175mm         HEX2BIN D5,D5,A4
000006AE  49F9 00000E53           1176mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000006B4  0405 0030               1177mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B8  CABC 000000FF           1178mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006BE  1A34 5000               1179mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006C2                          1180mm     ENDM
000006C2  8205                    1181m         OR.B D5,D1
000006C4  5307                    1182m         SUB.B #1,D7
000006C6                          1183m     ENDW
000006C6  6096                    1184ms     BRA _1000000A
000006C8                          1185ms _1000000B
000006C8                          1186m     
000006C8  7A00                    1187m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006CA  1A01                    1188m     MOVE.B D1,D5
000006CC  D481                    1189m     ADD.L D1,D2
000006CE                          1190m 
000006CE                          1191m     ENDM
000006CE                          1192                          
000006CE  14C1                    1193                  MOVE.B D1,(A2)+                     ; store it!
000006D0                          1194  
000006D0  5303                    1195                  SUB.B #1,D3                     ; 1 less byte to go
000006D2                          1196              ENDW
000006D2  6000 FF7E               1197s     BRA _10000008
000006D6                          1198s _10000009
000006D6                          1199          
000006D6  47F8 0398               1200              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006DA                          1201          ELSE
000006DA  6000 01F0               1202s     BRA _00000007
000006DE                          1203s _00000005
000006DE                          1204              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006DE  B23C 0038               1205s     CMP.B   #'8',D1
000006E2  6600 016C               1206s     BNE.L   _00000008
000006E6  7800                    1207                  MOVE.L #0,D4                    ; read the 24 bit start address
000006E8                          1208m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006E8  1E3C 0002               1209m     MOVE.B #2,D7
000006EC                          1210m     WHILE.B D7 <GT> 0 DO
000006EC                          1211ms _1000000C
000006EC  BE38 0000               1212ms     CMP.B   0,D7
000006F0  6F00 0064               1213ms     BLE _1000000D
000006F4  E98C                    1214m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006F6                          1215mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006F6                          1216mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F6                          1217mm 
000006F6  1A39 00C00003           1218mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006FC  0805 0000               1219mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000700  6700 0010               1220mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
00000704                          1221mm  
00000704                          1222mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000704                 TRUE     1223mmm     IFEQ DEBUG
00000704  1A39 00C00007           1224mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000070A                          1225mmm     ENDC
0000070A                 FALSE    1226mmm     IFNE DEBUG
0000070A                          1227mmm     ENDC
0000070A                          1228mmm      
0000070A  BA3C 001B               1229mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000070E  6700 F8F8               1230mmm     BEQ START
00000712                          1231mmm     ENDM
00000712                          1232mm CONTINUE_72
00000712  1A39 00C00013           1233mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000718  0805 0000               1234mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000071C  67D8                    1235mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
0000071E                          1236mm     
0000071E  1A39 00C00017           1237mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000724  13C5 00E00001           1238mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000072A                          1239mm     
0000072A                          1240mm     ENDM
0000072A                          1241mm         PRINT_CHAR D5,D6
0000072A                          1242mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000072A                 TRUE     1243mm     IFEQ DEBUG
0000072A  1C39 00C00003           1244mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000730  0806 0002               1245mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000734  67F4                    1246mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
00000736  13C5 00C00007           1247mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000073C                          1248mm     ENDC
0000073C                          1249mm     
0000073C                 FALSE    1250mm     IFNE DEBUG
0000073C                          1251mm     ENDC
0000073C                          1252mm 
0000073C                          1253mm     ENDM
0000073C                          1254mm         HEX2BIN D5,D5,A4
0000073C  49F9 00000E53           1255mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000742  0405 0030               1256mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000746  CABC 000000FF           1257mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000074C  1A34 5000               1258mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000750                          1259mm     ENDM
00000750  8805                    1260m         OR.B D5,D4
00000752  5307                    1261m         SUB.B #1,D7
00000754                          1262m     ENDW
00000754  6096                    1263ms     BRA _1000000C
00000756                          1264ms _1000000D
00000756                          1265m     
00000756  7A00                    1266m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000758  1A04                    1267m     MOVE.B D4,D5
0000075A  D484                    1268m     ADD.L D4,D2
0000075C                          1269m 
0000075C                          1270m     ENDM
0000075C                          1271m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
0000075C  1E3C 0002               1272m     MOVE.B #2,D7
00000760                          1273m     WHILE.B D7 <GT> 0 DO
00000760                          1274ms _1000000E
00000760  BE38 0000               1275ms     CMP.B   0,D7
00000764  6F00 0064               1276ms     BLE _1000000F
00000768  E98C                    1277m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000076A                          1278mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000076A                          1279mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076A                          1280mm 
0000076A  1A39 00C00003           1281mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000770  0805 0000               1282mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000774  6700 0010               1283mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000778                          1284mm  
00000778                          1285mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000778                 TRUE     1286mmm     IFEQ DEBUG
00000778  1A39 00C00007           1287mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000077E                          1288mmm     ENDC
0000077E                 FALSE    1289mmm     IFNE DEBUG
0000077E                          1290mmm     ENDC
0000077E                          1291mmm      
0000077E  BA3C 001B               1292mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000782  6700 F884               1293mmm     BEQ START
00000786                          1294mmm     ENDM
00000786                          1295mm CONTINUE_77
00000786  1A39 00C00013           1296mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000078C  0805 0000               1297mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000790  67D8                    1298mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
00000792                          1299mm     
00000792  1A39 00C00017           1300mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000798  13C5 00E00001           1301mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000079E                          1302mm     
0000079E                          1303mm     ENDM
0000079E                          1304mm         PRINT_CHAR D5,D6
0000079E                          1305mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000079E                 TRUE     1306mm     IFEQ DEBUG
0000079E  1C39 00C00003           1307mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007A4  0806 0002               1308mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007A8  67F4                    1309mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
000007AA  13C5 00C00007           1310mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007B0                          1311mm     ENDC
000007B0                          1312mm     
000007B0                 FALSE    1313mm     IFNE DEBUG
000007B0                          1314mm     ENDC
000007B0                          1315mm 
000007B0                          1316mm     ENDM
000007B0                          1317mm         HEX2BIN D5,D5,A4
000007B0  49F9 00000E53           1318mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007B6  0405 0030               1319mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007BA  CABC 000000FF           1320mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007C0  1A34 5000               1321mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007C4                          1322mm     ENDM
000007C4  8805                    1323m         OR.B D5,D4
000007C6  5307                    1324m         SUB.B #1,D7
000007C8                          1325m     ENDW
000007C8  6096                    1326ms     BRA _1000000E
000007CA                          1327ms _1000000F
000007CA                          1328m     
000007CA  7A00                    1329m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007CC  1A04                    1330m     MOVE.B D4,D5
000007CE  D484                    1331m     ADD.L D4,D2
000007D0                          1332m 
000007D0                          1333m     ENDM
000007D0                          1334m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
000007D0  1E3C 0002               1335m     MOVE.B #2,D7
000007D4                          1336m     WHILE.B D7 <GT> 0 DO
000007D4                          1337ms _10000010
000007D4  BE38 0000               1338ms     CMP.B   0,D7
000007D8  6F00 0064               1339ms     BLE _10000011
000007DC  E98C                    1340m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007DE                          1341mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007DE                          1342mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DE                          1343mm 
000007DE  1A39 00C00003           1344mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007E4  0805 0000               1345mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007E8  6700 0010               1346mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007EC                          1347mm  
000007EC                          1348mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007EC                 TRUE     1349mmm     IFEQ DEBUG
000007EC  1A39 00C00007           1350mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007F2                          1351mmm     ENDC
000007F2                 FALSE    1352mmm     IFNE DEBUG
000007F2                          1353mmm     ENDC
000007F2                          1354mmm      
000007F2  BA3C 001B               1355mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007F6  6700 F810               1356mmm     BEQ START
000007FA                          1357mmm     ENDM
000007FA                          1358mm CONTINUE_82
000007FA  1A39 00C00013           1359mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000800  0805 0000               1360mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000804  67D8                    1361mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
00000806                          1362mm     
00000806  1A39 00C00017           1363mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000080C  13C5 00E00001           1364mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000812                          1365mm     
00000812                          1366mm     ENDM
00000812                          1367mm         PRINT_CHAR D5,D6
00000812                          1368mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000812                 TRUE     1369mm     IFEQ DEBUG
00000812  1C39 00C00003           1370mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000818  0806 0002               1371mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000081C  67F4                    1372mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
0000081E  13C5 00C00007           1373mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000824                          1374mm     ENDC
00000824                          1375mm     
00000824                 FALSE    1376mm     IFNE DEBUG
00000824                          1377mm     ENDC
00000824                          1378mm 
00000824                          1379mm     ENDM
00000824                          1380mm         HEX2BIN D5,D5,A4
00000824  49F9 00000E53           1381mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000082A  0405 0030               1382mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000082E  CABC 000000FF           1383mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000834  1A34 5000               1384mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000838                          1385mm     ENDM
00000838  8805                    1386m         OR.B D5,D4
0000083A  5307                    1387m         SUB.B #1,D7
0000083C                          1388m     ENDW
0000083C  6096                    1389ms     BRA _10000010
0000083E                          1390ms _10000011
0000083E                          1391m     
0000083E  7A00                    1392m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000840  1A04                    1393m     MOVE.B D4,D5
00000842  D484                    1394m     ADD.L D4,D2
00000844                          1395m 
00000844                          1396m     ENDM
00000844                          1397                    
00000844  2044                    1398                  MOVE.L D4,A0                    ; start address -> A0
00000846                          1399                  
00000846  47F9 00000A08           1400                  LEA DOWNLOAD_DONE,A3            ; next place to go
0000084C                          1401              ELSE
0000084C  6000 007E               1402s     BRA _00000009
00000850                          1403s _00000008
00000850                          1404m                 PRINT_CRLF D5,A4
00000850  49F9 00000E7E           1405m     LEA CRLF,A4
00000856                          1406mm     PRINT_STR A4,D5
00000856                          1407mm LOOP_87
00000856  0C14 0000               1408mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000085A  6700 0016               1409mm     BEQ EXIT_87
0000085E                          1410mmm     PRINT_CHAR (A4)+,D5
0000085E                          1411mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085E                 TRUE     1412mmm     IFEQ DEBUG
0000085E  1A39 00C00003           1413mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000864  0805 0002               1414mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000868  67F4                    1415mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
0000086A  13DC 00C00007           1416mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000870                          1417mmm     ENDC
00000870                          1418mmm     
00000870                 FALSE    1419mmm     IFNE DEBUG
00000870                          1420mmm     ENDC
00000870                          1421mmm 
00000870                          1422mmm     ENDM
00000870  60E4                    1423mm     BRA LOOP_87
00000872                          1424mm EXIT_87
00000872                          1425mm     ENDM
00000872                          1426m     ENDM
00000872                          1427              
00000872  49F9 00000E08           1428                  LEA UNREC,A4                    ; warn for unrecognised type
00000878                          1429m                 PRINT_STR A4,D5
00000878                          1430m LOOP_89
00000878  0C14 0000               1431m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000087C  6700 0016               1432m     BEQ EXIT_89
00000880                          1433mm     PRINT_CHAR (A4)+,D5
00000880                          1434mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000880                 TRUE     1435mm     IFEQ DEBUG
00000880  1A39 00C00003           1436mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000886  0805 0002               1437mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000088A  67F4                    1438mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
0000088C  13DC 00C00007           1439mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000892                          1440mm     ENDC
00000892                          1441mm     
00000892                 FALSE    1442mm     IFNE DEBUG
00000892                          1443mm     ENDC
00000892                          1444mm 
00000892                          1445mm     ENDM
00000892  60E4                    1446m     BRA LOOP_89
00000894                          1447m EXIT_89
00000894                          1448m     ENDM
00000894                          1449m                 PRINT_CHAR D1,D5
00000894                          1450m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000894                 TRUE     1451m     IFEQ DEBUG
00000894  1A39 00C00003           1452m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000089A  0805 0002               1453m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000089E  67F4                    1454m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
000008A0  13C1 00C00007           1455m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008A6                          1456m     ENDC
000008A6                          1457m     
000008A6                 FALSE    1458m     IFNE DEBUG
000008A6                          1459m     ENDC
000008A6                          1460m 
000008A6                          1461m     ENDM
000008A6                          1462m                 PRINT_CRLF D5,A4
000008A6  49F9 00000E7E           1463m     LEA CRLF,A4
000008AC                          1464mm     PRINT_STR A4,D5
000008AC                          1465mm LOOP_93
000008AC  0C14 0000               1466mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008B0  6700 0016               1467mm     BEQ EXIT_93
000008B4                          1468mmm     PRINT_CHAR (A4)+,D5
000008B4                          1469mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B4                 TRUE     1470mmm     IFEQ DEBUG
000008B4  1A39 00C00003           1471mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008BA  0805 0002               1472mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008BE  67F4                    1473mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
000008C0  13DC 00C00007           1474mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008C6                          1475mmm     ENDC
000008C6                          1476mmm     
000008C6                 FALSE    1477mmm     IFNE DEBUG
000008C6                          1478mmm     ENDC
000008C6                          1479mmm 
000008C6                          1480mmm     ENDM
000008C6  60E4                    1481mm     BRA LOOP_93
000008C8                          1482mm EXIT_93
000008C8                          1483mm     ENDM
000008C8                          1484m     ENDM
000008C8                          1485              
000008C8  6000 FACE               1486                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
000008CC                          1487              ENDI
000008CC                          1488s _00000009
000008CC                          1489          ENDI
000008CC                          1490s _00000007
000008CC                          1491      ENDI
000008CC                          1492s _00000003
000008CC                          1493      
000008CC                          1494m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
000008CC  1E3C 0002               1495m     MOVE.B #2,D7
000008D0                          1496m     WHILE.B D7 <GT> 0 DO
000008D0                          1497ms _10000012
000008D0  BE38 0000               1498ms     CMP.B   0,D7
000008D4  6F00 0064               1499ms     BLE _10000013
000008D8  E98C                    1500m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008DA                          1501mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008DA                          1502mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DA                          1503mm 
000008DA  1A39 00C00003           1504mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008E0  0805 0000               1505mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008E4  6700 0010               1506mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008E8                          1507mm  
000008E8                          1508mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008E8                 TRUE     1509mmm     IFEQ DEBUG
000008E8  1A39 00C00007           1510mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008EE                          1511mmm     ENDC
000008EE                 FALSE    1512mmm     IFNE DEBUG
000008EE                          1513mmm     ENDC
000008EE                          1514mmm      
000008EE  BA3C 001B               1515mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008F2  6700 F714               1516mmm     BEQ START
000008F6                          1517mmm     ENDM
000008F6                          1518mm CONTINUE_96
000008F6  1A39 00C00013           1519mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008FC  0805 0000               1520mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000900  67D8                    1521mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
00000902                          1522mm     
00000902  1A39 00C00017           1523mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000908  13C5 00E00001           1524mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000090E                          1525mm     
0000090E                          1526mm     ENDM
0000090E                          1527mm         PRINT_CHAR D5,D6
0000090E                          1528mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090E                 TRUE     1529mm     IFEQ DEBUG
0000090E  1C39 00C00003           1530mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000914  0806 0002               1531mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000918  67F4                    1532mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
0000091A  13C5 00C00007           1533mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000920                          1534mm     ENDC
00000920                          1535mm     
00000920                 FALSE    1536mm     IFNE DEBUG
00000920                          1537mm     ENDC
00000920                          1538mm 
00000920                          1539mm     ENDM
00000920                          1540mm         HEX2BIN D5,D5,A4
00000920  49F9 00000E53           1541mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000926  0405 0030               1542mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000092A  CABC 000000FF           1543mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000930  1A34 5000               1544mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000934                          1545mm     ENDM
00000934  8805                    1546m         OR.B D5,D4
00000936  5307                    1547m         SUB.B #1,D7
00000938                          1548m     ENDW
00000938  6096                    1549ms     BRA _10000012
0000093A                          1550ms _10000013
0000093A                          1551m     
0000093A  7A00                    1552m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000093C  1A04                    1553m     MOVE.B D4,D5
0000093E  D484                    1554m     ADD.L D4,D2
00000940                          1555m 
00000940                          1556m     ENDM
00000940                          1557m     PRINT_CRLF D5,A4
00000940  49F9 00000E7E           1558m     LEA CRLF,A4
00000946                          1559mm     PRINT_STR A4,D5
00000946                          1560mm LOOP_101
00000946  0C14 0000               1561mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000094A  6700 0016               1562mm     BEQ EXIT_101
0000094E                          1563mmm     PRINT_CHAR (A4)+,D5
0000094E                          1564mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094E                 TRUE     1565mmm     IFEQ DEBUG
0000094E  1A39 00C00003           1566mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000954  0805 0002               1567mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000958  67F4                    1568mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
0000095A  13DC 00C00007           1569mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000960                          1570mmm     ENDC
00000960                          1571mmm     
00000960                 FALSE    1572mmm     IFNE DEBUG
00000960                          1573mmm     ENDC
00000960                          1574mmm 
00000960                          1575mmm     ENDM
00000960  60E4                    1576mm     BRA LOOP_101
00000962                          1577mm EXIT_101
00000962                          1578mm     ENDM
00000962                          1579m     ENDM
00000962                          1580          
00000962                          1581      IF.B D2 <NE> #$FF THEN.L
00000962  B43C 00FF               1582s     CMP.B   #$FF,D2
00000966  6700 009E               1583s     BEQ.L   _0000000A
0000096A  49F9 00000E1F           1584          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000970                          1585m         PRINT_STR A4,D5
00000970                          1586m LOOP_103
00000970  0C14 0000               1587m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000974  6700 0016               1588m     BEQ EXIT_103
00000978                          1589mm     PRINT_CHAR (A4)+,D5
00000978                          1590mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000978                 TRUE     1591mm     IFEQ DEBUG
00000978  1A39 00C00003           1592mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000097E  0805 0002               1593mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000982  67F4                    1594mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
00000984  13DC 00C00007           1595mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000098A                          1596mm     ENDC
0000098A                          1597mm     
0000098A                 FALSE    1598mm     IFNE DEBUG
0000098A                          1599mm     ENDC
0000098A                          1600mm 
0000098A                          1601mm     ENDM
0000098A  60E4                    1602m     BRA LOOP_103
0000098C                          1603m EXIT_103
0000098C                          1604m     ENDM
0000098C                          1605m         PRINT_REG D0,D5,D2,D6,A4
0000098C                          1606mm     PRINT_CHAR #'0',D5                              ;0X HEADER
0000098C                          1607mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1608mm     IFEQ DEBUG
0000098C  1A39 00C00003           1609mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000992  0805 0002               1610mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000996  67F4                    1611mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000998  13FC 0030 00C00007      1612mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000009A0                          1613mm     ENDC
000009A0                          1614mm     
000009A0                 FALSE    1615mm     IFNE DEBUG
000009A0                          1616mm     ENDC
000009A0                          1617mm 
000009A0                          1618mm     ENDM
000009A0                          1619mm     PRINT_CHAR #'x',D5
000009A0                          1620mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A0                 TRUE     1621mm     IFEQ DEBUG
000009A0  1A39 00C00003           1622mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009A6  0805 0002               1623mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009AA  67F4                    1624mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
000009AC  13FC 0078 00C00007      1625mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000009B4                          1626mm     ENDC
000009B4                          1627mm     
000009B4                 FALSE    1628mm     IFNE DEBUG
000009B4                          1629mm     ENDC
000009B4                          1630mm 
000009B4                          1631mm     ENDM
000009B4  7C07                    1632m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009B6                          1633m LOOP_105
000009B6                          1634mm     BIN2HEX D0,D2,A4
000009B6  49F9 00000E43           1635mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
000009BC  E998                    1636mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009BE  1400                    1637mm     MOVE.B D0,D2
000009C0  0282 0000000F           1638mm     ANDI.L #$F,D2
000009C6  1434 2000               1639mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
000009CA                          1640mm     ENDM
000009CA                          1641mm     PRINT_CHAR D2,D5
000009CA                          1642mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009CA                 TRUE     1643mm     IFEQ DEBUG
000009CA  1A39 00C00003           1644mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009D0  0805 0002               1645mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009D4  67F4                    1646mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
000009D6  13C2 00C00007           1647mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009DC                          1648mm     ENDC
000009DC                          1649mm     
000009DC                 FALSE    1650mm     IFNE DEBUG
000009DC                          1651mm     ENDC
000009DC                          1652mm 
000009DC                          1653mm     ENDM
000009DC  57CE FFD8               1654m     DBEQ D6,LOOP_105
000009E0                          1655m     ENDM
000009E0                          1656m         PRINT_CRLF D5,A4
000009E0  49F9 00000E7E           1657m     LEA CRLF,A4
000009E6                          1658mm     PRINT_STR A4,D5
000009E6                          1659mm LOOP_111
000009E6  0C14 0000               1660mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009EA  6700 0016               1661mm     BEQ EXIT_111
000009EE                          1662mmm     PRINT_CHAR (A4)+,D5
000009EE                          1663mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EE                 TRUE     1664mmm     IFEQ DEBUG
000009EE  1A39 00C00003           1665mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009F4  0805 0002               1666mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009F8  67F4                    1667mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
000009FA  13DC 00C00007           1668mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A00                          1669mmm     ENDC
00000A00                          1670mmm     
00000A00                 FALSE    1671mmm     IFNE DEBUG
00000A00                          1672mmm     ENDC
00000A00                          1673mmm 
00000A00                          1674mmm     ENDM
00000A00  60E4                    1675mm     BRA LOOP_111
00000A02                          1676mm EXIT_111
00000A02                          1677mm     ENDM
00000A02                          1678m     ENDM
00000A02  6000 F760               1679          BRA MAIN_LOOP
00000A06                          1680      ENDI
00000A06                          1681s _0000000A
00000A06                          1682      
00000A06  4ED3                    1683      JMP (A3)
00000A08                          1684  DOWNLOAD_DONE
00000A08                          1685m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A08                          1686mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A08                          1687mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A08                 TRUE     1688mm     IFEQ DEBUG
00000A08  1A39 00C00003           1689mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A0E  0805 0002               1690mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A12  67F4                    1691mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000A14  13FC 0030 00C00007      1692mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A1C                          1693mm     ENDC
00000A1C                          1694mm     
00000A1C                 FALSE    1695mm     IFNE DEBUG
00000A1C                          1696mm     ENDC
00000A1C                          1697mm 
00000A1C                          1698mm     ENDM
00000A1C                          1699mm     PRINT_CHAR #'x',D5
00000A1C                          1700mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1C                 TRUE     1701mm     IFEQ DEBUG
00000A1C  1A39 00C00003           1702mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A22  0805 0002               1703mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A26  67F4                    1704mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000A28  13FC 0078 00C00007      1705mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A30                          1706mm     ENDC
00000A30                          1707mm     
00000A30                 FALSE    1708mm     IFNE DEBUG
00000A30                          1709mm     ENDC
00000A30                          1710mm 
00000A30                          1711mm     ENDM
00000A30  7407                    1712m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A32                          1713m LOOP_113
00000A32                          1714mm     BIN2HEX D0,D6,A1
00000A32  43F9 00000E43           1715mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A38  E998                    1716mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A3A  1C00                    1717mm     MOVE.B D0,D6
00000A3C  0286 0000000F           1718mm     ANDI.L #$F,D6
00000A42  1C31 6000               1719mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A46                          1720mm     ENDM
00000A46                          1721mm     PRINT_CHAR D6,D5
00000A46                          1722mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A46                 TRUE     1723mm     IFEQ DEBUG
00000A46  1A39 00C00003           1724mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A4C  0805 0002               1725mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A50  67F4                    1726mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A52  13C6 00C00007           1727mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A58                          1728mm     ENDC
00000A58                          1729mm     
00000A58                 FALSE    1730mm     IFNE DEBUG
00000A58                          1731mm     ENDC
00000A58                          1732mm 
00000A58                          1733mm     ENDM
00000A58  57CA FFD8               1734m     DBEQ D2,LOOP_113
00000A5C                          1735m     ENDM
00000A5C  43F9 00000DE6           1736      LEA READ,A1
00000A62                          1737m     PRINT_STR A1,D5
00000A62                          1738m LOOP_118
00000A62  0C11 0000               1739m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A66  6700 0016               1740m     BEQ EXIT_118
00000A6A                          1741mm     PRINT_CHAR (A1)+,D5
00000A6A                          1742mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6A                 TRUE     1743mm     IFEQ DEBUG
00000A6A  1A39 00C00003           1744mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A70  0805 0002               1745mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A74  67F4                    1746mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A76  13D9 00C00007           1747mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A7C                          1748mm     ENDC
00000A7C                          1749mm     
00000A7C                 FALSE    1750mm     IFNE DEBUG
00000A7C                          1751mm     ENDC
00000A7C                          1752mm 
00000A7C                          1753mm     ENDM
00000A7C  60E4                    1754m     BRA LOOP_118
00000A7E                          1755m EXIT_118
00000A7E                          1756m     ENDM
00000A7E  2E08                    1757      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A80                          1758m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A80                          1759mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A80                          1760mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1761mm     IFEQ DEBUG
00000A80  1A39 00C00003           1762mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A86  0805 0002               1763mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1764mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A8C  13FC 0030 00C00007      1765mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A94                          1766mm     ENDC
00000A94                          1767mm     
00000A94                 FALSE    1768mm     IFNE DEBUG
00000A94                          1769mm     ENDC
00000A94                          1770mm 
00000A94                          1771mm     ENDM
00000A94                          1772mm     PRINT_CHAR #'x',D5
00000A94                          1773mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A94                 TRUE     1774mm     IFEQ DEBUG
00000A94  1A39 00C00003           1775mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9A  0805 0002               1776mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A9E  67F4                    1777mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000AA0  13FC 0078 00C00007      1778mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AA8                          1779mm     ENDC
00000AA8                          1780mm     
00000AA8                 FALSE    1781mm     IFNE DEBUG
00000AA8                          1782mm     ENDC
00000AA8                          1783mm 
00000AA8                          1784mm     ENDM
00000AA8  7407                    1785m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AAA                          1786m LOOP_120
00000AAA                          1787mm     BIN2HEX D7,D6,A1
00000AAA  43F9 00000E43           1788mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000AB0  E99F                    1789mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AB2  1C07                    1790mm     MOVE.B D7,D6
00000AB4  0286 0000000F           1791mm     ANDI.L #$F,D6
00000ABA  1C31 6000               1792mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000ABE                          1793mm     ENDM
00000ABE                          1794mm     PRINT_CHAR D6,D5
00000ABE                          1795mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ABE                 TRUE     1796mm     IFEQ DEBUG
00000ABE  1A39 00C00003           1797mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AC4  0805 0002               1798mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AC8  67F4                    1799mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000ACA  13C6 00C00007           1800mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AD0                          1801mm     ENDC
00000AD0                          1802mm     
00000AD0                 FALSE    1803mm     IFNE DEBUG
00000AD0                          1804mm     ENDC
00000AD0                          1805mm 
00000AD0                          1806mm     ENDM
00000AD0  57CA FFD8               1807m     DBEQ D2,LOOP_120
00000AD4                          1808m     ENDM
00000AD4                          1809m     PRINT_CRLF D5,A4     
00000AD4  49F9 00000E7E           1810m     LEA CRLF,A4
00000ADA                          1811mm     PRINT_STR A4,D5
00000ADA                          1812mm LOOP_126
00000ADA  0C14 0000               1813mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000ADE  6700 0016               1814mm     BEQ EXIT_126
00000AE2                          1815mmm     PRINT_CHAR (A4)+,D5
00000AE2                          1816mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE2                 TRUE     1817mmm     IFEQ DEBUG
00000AE2  1A39 00C00003           1818mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AE8  0805 0002               1819mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AEC  67F4                    1820mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AEE  13DC 00C00007           1821mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AF4                          1822mmm     ENDC
00000AF4                          1823mmm     
00000AF4                 FALSE    1824mmm     IFNE DEBUG
00000AF4                          1825mmm     ENDC
00000AF4                          1826mmm 
00000AF4                          1827mmm     ENDM
00000AF4  60E4                    1828mm     BRA LOOP_126
00000AF6                          1829mm EXIT_126
00000AF6                          1830mm     ENDM
00000AF6                          1831m     ENDM
00000AF6                          1832          
00000AF6  6000 F66C               1833      BRA MAIN_LOOP
00000AFA                          1834      
00000AFA                          1835  G
00000AFA  2047                    1836      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AFC  3E3C 0000               1837      MOVE #0,D7                                      ; clear the now used address accumulator
00000B00  4ED0                    1838      JMP (A0)                                        ; jump to it!
00000B02                          1839      
00000B02                          1840  Z
00000B02  207C 00200000           1841      MOVE.L #RAM,A0                                  ; address of RAM
00000B08                          1842      
00000B08                          1843      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000B08  7000                    1844s     MOVE.L  #0,D0
00000B0A  6000 0012               1845s     BRA _20000001
00000B0E                          1846s _20000000
00000B0E  2200                    1847              MOVE.L D0,D1                              ; progress update
00000B10  E089                    1848          LSR.L #8,D1 
00000B12  E089                    1849          LSR.L #8,D1
00000B14  13C1 00E00001           1850          MOVE.B D1,DISPLAY
00000B1A                          1851  
00000B1A  20C0                    1852          MOVE.L D0,(A0)+
00000B1C                          1853      ENDF
00000B1C  5880                    1854s     ADD.L   #4,D0
00000B1E                          1855s _20000001
00000B1E  B0BC 00040000           1856s     CMP.L   #$40000,D0
00000B24  6FE8                    1857s     BLE _20000000
00000B26                          1858   
00000B26  207C 00200000           1859      MOVE.L #RAM,A0                                    ; address of RAM
00000B2C                          1860     
00000B2C                          1861      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000B2C  7000                    1862s     MOVE.L  #0,D0
00000B2E  6000 00B4               1863s     BRA _20000003
00000B32                          1864s _20000002
00000B32  2200                    1865          MOVE.L D0,D1                              ; progress update
00000B34  E089                    1866          LSR.L #8,D1
00000B36  E089                    1867          LSR.L #8,D1
00000B38  13C1 00E00001           1868          MOVE.B D1,DISPLAY
00000B3E                          1869  
00000B3E  2218                    1870          MOVE.L (A0)+,D1
00000B40                          1871            
00000B40                          1872          IF.L D0 <NE> D1 THEN      
00000B40  B081                    1873s     CMP.L   D1,D0
00000B42  6700 009E               1874s     BEQ _0000000B
00000B46  43F9 00000E31           1875              LEA RAM_ERROR,A1
00000B4C                          1876m             PRINT_STR A1,D1
00000B4C                          1877m LOOP_128
00000B4C  0C11 0000               1878m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B50  6700 0016               1879m     BEQ EXIT_128
00000B54                          1880mm     PRINT_CHAR (A1)+,D1
00000B54                          1881mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B54                 TRUE     1882mm     IFEQ DEBUG
00000B54  1239 00C00003           1883mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B5A  0801 0002               1884mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B5E  67F4                    1885mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B60  13D9 00C00007           1886mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B66                          1887mm     ENDC
00000B66                          1888mm     
00000B66                 FALSE    1889mm     IFNE DEBUG
00000B66                          1890mm     ENDC
00000B66                          1891mm 
00000B66                          1892mm     ENDM
00000B66  60E4                    1893m     BRA LOOP_128
00000B68                          1894m EXIT_128
00000B68                          1895m     ENDM
00000B68  2208                    1896              MOVE.L A0,D1
00000B6A  5981                    1897              SUB.L #4,D1
00000B6C                          1898m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B6C                          1899mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00000B6C                          1900mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B6C                 TRUE     1901mm     IFEQ DEBUG
00000B6C  1639 00C00003           1902mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B72  0803 0002               1903mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B76  67F4                    1904mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B78  13FC 0030 00C00007      1905mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B80                          1906mm     ENDC
00000B80                          1907mm     
00000B80                 FALSE    1908mm     IFNE DEBUG
00000B80                          1909mm     ENDC
00000B80                          1910mm 
00000B80                          1911mm     ENDM
00000B80                          1912mm     PRINT_CHAR #'x',D3
00000B80                          1913mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B80                 TRUE     1914mm     IFEQ DEBUG
00000B80  1639 00C00003           1915mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B86  0803 0002               1916mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B8A  67F4                    1917mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000B8C  13FC 0078 00C00007      1918mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B94                          1919mm     ENDC
00000B94                          1920mm     
00000B94                 FALSE    1921mm     IFNE DEBUG
00000B94                          1922mm     ENDC
00000B94                          1923mm 
00000B94                          1924mm     ENDM
00000B94  7C07                    1925m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B96                          1926m LOOP_130
00000B96                          1927mm     BIN2HEX D1,D2,A1
00000B96  43F9 00000E43           1928mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B9C  E999                    1929mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B9E  1401                    1930mm     MOVE.B D1,D2
00000BA0  0282 0000000F           1931mm     ANDI.L #$F,D2
00000BA6  1431 2000               1932mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BAA                          1933mm     ENDM
00000BAA                          1934mm     PRINT_CHAR D2,D3
00000BAA                          1935mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAA                 TRUE     1936mm     IFEQ DEBUG
00000BAA  1639 00C00003           1937mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BB0  0803 0002               1938mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BB4  67F4                    1939mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000BB6  13C2 00C00007           1940mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BBC                          1941mm     ENDC
00000BBC                          1942mm     
00000BBC                 FALSE    1943mm     IFNE DEBUG
00000BBC                          1944mm     ENDC
00000BBC                          1945mm 
00000BBC                          1946mm     ENDM
00000BBC  57CE FFD8               1947m     DBEQ D6,LOOP_130
00000BC0                          1948m     ENDM
00000BC0                          1949m             PRINT_CRLF D3,A1
00000BC0  43F9 00000E7E           1950m     LEA CRLF,A1
00000BC6                          1951mm     PRINT_STR A1,D3
00000BC6                          1952mm LOOP_136
00000BC6  0C11 0000               1953mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BCA  6700 0016               1954mm     BEQ EXIT_136
00000BCE                          1955mmm     PRINT_CHAR (A1)+,D3
00000BCE                          1956mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCE                 TRUE     1957mmm     IFEQ DEBUG
00000BCE  1639 00C00003           1958mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BD4  0803 0002               1959mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD8  67F4                    1960mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000BDA  13D9 00C00007           1961mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BE0                          1962mmm     ENDC
00000BE0                          1963mmm     
00000BE0                 FALSE    1964mmm     IFNE DEBUG
00000BE0                          1965mmm     ENDC
00000BE0                          1966mmm 
00000BE0                          1967mmm     ENDM
00000BE0  60E4                    1968mm     BRA LOOP_136
00000BE2                          1969mm EXIT_136
00000BE2                          1970mm     ENDM
00000BE2                          1971m     ENDM
00000BE2                          1972          ENDI 
00000BE2                          1973s _0000000B
00000BE2                          1974      ENDF
00000BE2  5880                    1975s     ADD.L   #4,D0
00000BE4                          1976s _20000003
00000BE4  B0BC 00040000           1977s     CMP.L   #$40000,D0
00000BEA  6F00 FF46               1978s     BLE _20000002
00000BEE                          1979      
00000BEE  6000 F574               1980      BRA MAIN_LOOP
00000BF2                          1981    
00000BF2                          1982  L
00000BF2  7A00                    1983      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000BF4                          1984  
00000BF4                          1985      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000BF4  3C3C 0000               1986s     MOVE.W  #0,D6
00000BF8  6000 0048               1987s     BRA _20000005
00000BFC                          1988s _20000004
00000BFC  E98D                    1989          LSL.L #4,D5                                 ; make what we have so far more significant
00000BFE                          1990m         WAIT_CHAR D2,D3                             ; next character -> D2
00000BFE                          1991m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BFE                 TRUE     1992m     IFEQ DEBUG
00000BFE  1639 00C00003           1993m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C04  0803 0000               1994m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000C08  67F4                    1995m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000C0A                          1996m     ENDC
00000C0A                          1997m     
00000C0A                          1998mm     READ_CHAR D2
00000C0A                 TRUE     1999mm     IFEQ DEBUG
00000C0A  1439 00C00007           2000mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000C10                          2001mm     ENDC
00000C10                 FALSE    2002mm     IFNE DEBUG
00000C10                          2003mm     ENDC
00000C10                          2004mm      
00000C10  B43C 001B               2005mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000C14  6700 F3F2               2006mm     BEQ START
00000C18                          2007mm     ENDM
00000C18                          2008m 
00000C18                 TRUE     2009m     IFEQ DEBUG
00000C18                          2010mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000C18                          2011mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C18                 TRUE     2012mm     IFEQ DEBUG
00000C18  1639 00C00003           2013mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C1E  0803 0002               2014mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C22  67F4                    2015mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000C24  13C2 00C00007           2016mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C2A                          2017mm     ENDC
00000C2A                          2018mm     
00000C2A                 FALSE    2019mm     IFNE DEBUG
00000C2A                          2020mm     ENDC
00000C2A                          2021mm 
00000C2A                          2022mm     ENDM
00000C2A                          2023m     ENDC
00000C2A                          2024m     ENDM
00000C2A                          2025m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000C2A  41F9 00000E53           2026m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000C30  0402 0030               2027m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C34  C4BC 000000FF           2028m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000C3A  1430 2000               2029m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000C3E                          2030m     ENDM
00000C3E  8A02                    2031          OR.B D2,D5
00000C40                          2032      ENDF
00000C40  5246                    2033s     ADD.W   #1,D6
00000C42                          2034s _20000005
00000C42  BC7C 0003               2035s     CMP.W   #3,D6
00000C46  6FB4                    2036s     BLE _20000004
00000C48                          2037            
00000C48                          2038m     PRINT_CRLF D3,A0
00000C48  41F9 00000E7E           2039m     LEA CRLF,A0
00000C4E                          2040mm     PRINT_STR A0,D3
00000C4E                          2041mm LOOP_143
00000C4E  0C10 0000               2042mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C52  6700 0016               2043mm     BEQ EXIT_143
00000C56                          2044mmm     PRINT_CHAR (A0)+,D3
00000C56                          2045mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C56                 TRUE     2046mmm     IFEQ DEBUG
00000C56  1639 00C00003           2047mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5C  0803 0002               2048mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C60  67F4                    2049mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C62  13D8 00C00007           2050mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C68                          2051mmm     ENDC
00000C68                          2052mmm     
00000C68                 FALSE    2053mmm     IFNE DEBUG
00000C68                          2054mmm     ENDC
00000C68                          2055mmm 
00000C68                          2056mmm     ENDM
00000C68  60E4                    2057mm     BRA LOOP_143
00000C6A                          2058mm EXIT_143
00000C6A                          2059mm     ENDM
00000C6A                          2060m     ENDM
00000C6A                          2061  
00000C6A  207C 00000000           2062      MOVE.L #ROM,A0                                  ; start of ROM
00000C70                          2063      
00000C70  2247                    2064      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C72  7E00                    2065      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C74                          2066      
00000C74  31FC AAAA 2AAA          2067      MOVE.W #$AAAA,$2AAA
00000C7A  31FC 5555 1554          2068      MOVE.W #$5555,$1554
00000C80  31FC 8080 2AAA          2069      MOVE.W #$8080,$2AAA
00000C86  31FC AAAA 2AAA          2070      MOVE.W #$AAAA,$2AAA
00000C8C  31FC 5555 1554          2071      MOVE.W #$5555,$1554
00000C92  31FC 2020 2AAA          2072      MOVE.W #$2020,$2AAA
00000C98                          2073      
00000C98  45F9 00000E6A           2074      LEA LOADING,A2                              ; important for timing
00000C9E                          2075m     PRINT_STR A2,D3
00000C9E                          2076m LOOP_145
00000C9E  0C12 0000               2077m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CA2  6700 0016               2078m     BEQ EXIT_145
00000CA6                          2079mm     PRINT_CHAR (A2)+,D3
00000CA6                          2080mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA6                 TRUE     2081mm     IFEQ DEBUG
00000CA6  1639 00C00003           2082mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CAC  0803 0002               2083mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB0  67F4                    2084mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000CB2  13DA 00C00007           2085mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CB8                          2086mm     ENDC
00000CB8                          2087mm     
00000CB8                 FALSE    2088mm     IFNE DEBUG
00000CB8                          2089mm     ENDC
00000CB8                          2090mm 
00000CB8                          2091mm     ENDM
00000CB8  60E4                    2092m     BRA LOOP_145
00000CBA                          2093m EXIT_145
00000CBA                          2094m     ENDM
00000CBA                          2095      
00000CBA                          2096      WHILE D5 <GT> #0 DO
00000CBA                          2097s _10000014
00000CBA  BA7C 0000               2098s     CMP.W   #0,D5
00000CBE  6F00 001C               2099s     BLE _10000015
00000CC2  5585                    2100          SUB.L #2,D5
00000CC4                          2101            
00000CC4  13D1 00E00001           2102          MOVE.B (A1),DISPLAY
00000CCA  3091                    2103          MOVE.W (A1),(A0)                            ; write the data
00000CCC                          2104        
00000CCC                          2105  WAIT_FOR_COMPLETE
00000CCC  3410                    2106          MOVE.W (A0),D2
00000CCE                          2107  
00000CCE                          2108          IF D2 <NE> (A1) THEN
00000CCE  B451                    2109s     CMP.W   (A1),D2
00000CD0  6700 0004               2110s     BEQ _0000000C
00000CD4  60F6                    2111              BRA WAIT_FOR_COMPLETE
00000CD6                          2112          ENDI
00000CD6                          2113s _0000000C
00000CD6                          2114        
00000CD6  5488                    2115          ADD.L #2,A0
00000CD8  5489                    2116          ADD.L #2,A1
00000CDA                          2117       ENDW    
00000CDA  60DE                    2118s     BRA _10000014
00000CDC                          2119s _10000015
00000CDC                          2120      
00000CDC  31FC AAAA 2AAA          2121      MOVE.W #$AAAA,$2AAA
00000CE2  31FC 5555 1554          2122      MOVE.W #$5555,$1554
00000CE8  31FC A0A0 2AAA          2123      MOVE.W #$A0A0,$2AAA
00000CEE                          2124              
00000CEE  6000 F474               2125      BRA MAIN_LOOP
00000CF2                          2126          
00000CF2                          2127  HEX_DIGIT
00000CF2  E98F                    2128      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000CF4                          2129m     HEX2BIN D2,D2,A0
00000CF4  41F9 00000E53           2130m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000CFA  0402 0030               2131m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CFE  C4BC 000000FF           2132m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000D04  1430 2000               2133m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000D08                          2134m     ENDM
00000D08  8E02                    2135      OR.B D2,D7  
00000D0A  6000 F480               2136      BRA GET_INPUT
00000D0E                          2137  
00000D0E  FFFF FFFF               2138      SIMHALT                                         ; halt simulator
00000D12                          2139  
00000D12                          2140  ; strings
00000D12= 4D 44 46 2D 6D 6F ...   2141  VERSION DC.B 'MDF-mon V1.54 (10/04/2021)',CR,LF,NULL
00000D2F= 3F 09 09 09 68 65 ...   2142  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000D39= 5B 76 5D 09 09 09 ...   2143          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000D48= 78 78 78 78 78 78 ...   2144          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D60= 78 78 78 78 78 78 ...   2145          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D80= 5B 73 5D 09 09 09 ...   2146          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000D9A= 78 78 78 78 78 78 ...   2147          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000DAB= 5B 7A 5D 09 09 09 ...   2148          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000DBD= 78 78 78 78 78 78 ...   2149          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000DDF= 48 75 68 3F 0D 0A 00    2150  HUH     DC.B 'Huh?',CR,LF,NULL
00000DE6= 20 53 20 72 65 63 ...   2151  READ    DC.B ' S records read, start address = ',NULL
00000E08= 57 3A 20 55 6E 6B ...   2152  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000E1F= 57 3A 20 43 53 20 ...   2153  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000E31= 57 3A 20 52 41 4D ...   2154  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000E43= 30 31 32 33 34 35 ...   2155  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E53= 00 01 02 03 04 05 ...   2156  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E6A= 4C 6F 61 64 69 6E ...   2157  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E7E= 0D 0A 00                2158  CRLF    DC.B CR,LF,NULL
00000E81                          2159      
00000E81                          2160      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         E43
CONTINUE_37         3B4
CONTINUE_40         404
CONTINUE_44         45A
CONTINUE_52         512
CONTINUE_57         586
CONTINUE_62         604
CONTINUE_67         684
CONTINUE_72         712
CONTINUE_77         786
CONTINUE_82         7FA
CONTINUE_96         8F6
CR                  D
CRLF                E7E
CS_FAILURE          E1F
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            962
DOWNLOAD_BYTE       C47
DOWNLOAD_DONE       A08
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_101            962
EXIT_103            98C
EXIT_111            A02
EXIT_118            A7E
EXIT_126            AF6
EXIT_128            B68
EXIT_136            BE2
EXIT_143            C6A
EXIT_145            CBA
EXIT_16             212
EXIT_18             264
EXIT_20             294
EXIT_28             312
EXIT_3              116
EXIT_35             38C
EXIT_49             4CE
EXIT_5              138
EXIT_8              15A
EXIT_87             872
EXIT_89             894
EXIT_93             8C8
G                   AFA
GET_INPUT           18C
H                   268
HELP                D2F
HEX2BIN             134
HEX2BIN_LUT         E53
HEX_DIGIT           CF2
HUH                 DDF
L                   BF2
LF                  A
LOADING             E6A
LOOP_101            946
LOOP_103            970
LOOP_105            9B6
LOOP_111            9E6
LOOP_113            A32
LOOP_118            A62
LOOP_120            AAA
LOOP_126            ADA
LOOP_128            B4C
LOOP_130            B96
LOOP_136            BC6
LOOP_143            C4E
LOOP_145            C9E
LOOP_16             1F6
LOOP_18             248
LOOP_20             278
LOOP_22             2C6
LOOP_28             2F6
LOOP_3              FA
LOOP_35             370
LOOP_49             4B2
LOOP_5              11C
LOOP_8              13E
LOOP_87             856
LOOP_89             878
LOOP_93             8AC
MAIN_LOOP           164
NULL                0
PRINTSTR            278
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
R                   298
RAM                 200000
RAM_ERROR           E31
READ                DE6
READ_CHAR           7FC
READ_DATA_TO_POKE   31C
RESET               4
ROM                 0
S                   390
STACK               0
START               8
TAB                 9
UNREC               E08
V                   272
VERSION             D12
W                   318
WAIT_CHAR           64D
WAIT_FOR_COMPLETE   CCC
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   164
WAIT_FOR_READY_102  94E
WAIT_FOR_READY_104  978
WAIT_FOR_READY_106  98C
WAIT_FOR_READY_107  9A0
WAIT_FOR_READY_109  9CA
WAIT_FOR_READY_11   178
WAIT_FOR_READY_112  9EE
WAIT_FOR_READY_114  A08
WAIT_FOR_READY_115  A1C
WAIT_FOR_READY_117  A46
WAIT_FOR_READY_119  A6A
WAIT_FOR_READY_12   18C
WAIT_FOR_READY_121  A80
WAIT_FOR_READY_122  A94
WAIT_FOR_READY_124  ABE
WAIT_FOR_READY_127  AE2
WAIT_FOR_READY_129  B54
WAIT_FOR_READY_131  B6C
WAIT_FOR_READY_132  B80
WAIT_FOR_READY_134  BAA
WAIT_FOR_READY_137  BCE
WAIT_FOR_READY_138  BFE
WAIT_FOR_READY_14   1A6
WAIT_FOR_READY_140  C18
WAIT_FOR_READY_144  C56
WAIT_FOR_READY_146  CA6
WAIT_FOR_READY_17   1FE
WAIT_FOR_READY_19   250
WAIT_FOR_READY_21   280
WAIT_FOR_READY_23   29C
WAIT_FOR_READY_24   2B0
WAIT_FOR_READY_26   2DA
WAIT_FOR_READY_29   2FE
WAIT_FOR_READY_30   31E
WAIT_FOR_READY_32   338
WAIT_FOR_READY_36   378
WAIT_FOR_READY_37   398
WAIT_FOR_READY_39   3D2
WAIT_FOR_READY_4    102
WAIT_FOR_READY_40   3E8
WAIT_FOR_READY_42   41C
WAIT_FOR_READY_44   43E
WAIT_FOR_READY_46   472
WAIT_FOR_READY_50   4BA
WAIT_FOR_READY_52   4F6
WAIT_FOR_READY_54   52A
WAIT_FOR_READY_57   56A
WAIT_FOR_READY_59   59E
WAIT_FOR_READY_6    124
WAIT_FOR_READY_62   5E8
WAIT_FOR_READY_64   61C
WAIT_FOR_READY_67   668
WAIT_FOR_READY_69   69C
WAIT_FOR_READY_72   6F6
WAIT_FOR_READY_74   72A
WAIT_FOR_READY_77   76A
WAIT_FOR_READY_79   79E
WAIT_FOR_READY_82   7DE
WAIT_FOR_READY_84   812
WAIT_FOR_READY_88   85E
WAIT_FOR_READY_9    146
WAIT_FOR_READY_90   880
WAIT_FOR_READY_91   894
WAIT_FOR_READY_94   8B4
WAIT_FOR_READY_96   8DA
WAIT_FOR_READY_98   90E
WAIT_FOR_SRECORD    398
Z                   B02
_00000000           1CC
_00000001           1E0
_00000002           4D6
_00000003           8CC
_00000004           4E4
_00000005           6DE
_00000006           64E
_00000007           8CC
_00000008           850
_00000009           8CC
_0000000A           A06
_0000000B           BE2
_0000000C           CD6
_10000000           434
_10000001           49E
_10000002           4EC
_10000003           556
_10000004           560
_10000005           5CA
_10000006           5DE
_10000007           648
_10000008           652
_10000009           6D6
_1000000A           65E
_1000000B           6C8
_1000000C           6EC
_1000000D           756
_1000000E           760
_1000000F           7CA
_10000010           7D4
_10000011           83E
_10000012           8D0
_10000013           93A
_10000014           CBA
_10000015           CDC
_20000000           B0E
_20000001           B1E
_20000002           B32
_20000003           BE4
_20000004           BFC
_20000005           C42
