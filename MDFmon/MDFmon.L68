00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08/04/2021 07:15:07

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; consistency for use of labels
00000000                             9  ; increase baud rate x 4?
00000000                            10  ; don't waste code on the srec header
00000000                            11  ; tidy up NAND gate invertor and wiring for OE and WE on eeproms
00000000                            12  ; tidy up power loom
00000000                            13  ; add LDS and UDS with an OR gate and test because then I can do byte writes and it will make the download simpler
00000000                            14  ; stop using two registers in download
00000000                            15  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            16  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            17  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            18  
00000000                            19  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            20  ; keep track of highest address hit during srec download
00000000                            21  ; fix the reset vector so that it jumps to the start
00000000                            22  ; Replace JMP -> BRA
00000000                            23  ; implement backspace
00000000                            24  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            25  ; fix being able to enter random chars when W'ing
00000000                            26  ; ram check at startup?  Not sure if this is a good idea!
00000000                            27  
00000000                            28      ;ORG  $0
00200000                            29      ORG  $200000
00200000                            30  
00200000  =00000000                 31  DEBUG               EQU 0
00200000                            32  
00200000                            33  ; constants
00200000  =00000000                 34  ROM                 EQU $0
00200000  =00200000                 35  RAM                 EQU $200000
00200000                            36     
00200000  =00C00000                 37  DUART_BASE          EQU $C00000
00200000  =00000000                 38  DUART_MRA_          EQU $0
00200000  =00000001                 39  DUART_CSRA_         EQU $1
00200000  =00000001                 40  DUART_SRA_          EQU $1
00200000  =00000002                 41  DUART_CRA_          EQU $2
00200000  =00000003                 42  DUART_TXA_          EQU $3
00200000  =00000003                 43  DUART_RXA_          EQU $3
00200000  =00000004                 44  DUART_ACR_          EQU $4
00200000  =00000005                 45  DUART_IMR_          EQU $5
00200000  =00000008                 46  DUART_MRB_          EQU $8
00200000  =00000009                 47  DUART_CSRB_         EQU $9
00200000  =00000009                 48  DUART_SRB_          EQU $9
00200000  =0000000A                 49  DUART_CRB_          EQU $A
00200000  =0000000B                 50  DUART_TXB_          EQU $B
00200000  =0000000B                 51  DUART_RXB_          EQU $B
00200000  =0000000C                 52  DUART_IVR_          EQU $C
00200000  =0000000D                 53  DUART_OPCR_         EQU $D
00200000  =0000000E                 54  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 55  DUART_RESET_OPR_    EQU $F
00200000                            56  RRRR
00200000  =00C00001                 57  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 58  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 59  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 60  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 61  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 62  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            63  
00200000  =00C00011                 64  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 65  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 66  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 67  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 68  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 69  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            70  
00200000  =00C00009                 71  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 72  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 73  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 74  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 75  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 76  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            77  
00200000  =00E00000                 78  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 79  DISPLAY_            EQU $0
00200000  =00E00001                 80  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            81  
00200000                            82  ; macros
00200000                            83  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            84  ; the input register is changed during the process
00200000                            85  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            86  BIN2HEX MACRO
00200000                            87      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            88      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            89      MOVE.B \1,\2
00200000                            90      ANDI.L #$F,\2
00200000                            91      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            92      ENDM
00200000                            93  
00200000                            94  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            95  ; the input register is changed during the process
00200000                            96  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            97  HEX2BIN MACRO
00200000                            98      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            99      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                           100      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                           101      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           102      ENDM
00200000                           103  
00200000                           104  ; send a single char to the serial port
00200000                           105  ; \1 = char to send, \2 = data register to use for status poll
00200000                           106  ; will stamp on D0 and D1 in debug mode
00200000                           107  PRINT_CHAR MACRO
00200000                           108  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           109      IFEQ DEBUG
00200000                           110          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           111          BTST #2,\2                              ; check for space to send
00200000                           112          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           113          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           114      ENDC
00200000                           115      
00200000                           116      IFNE DEBUG
00200000                           117          MOVE.B \1,D1
00200000                           118          MOVE.L #6,D0   
00200000                           119          TRAP #15                                ; write to terminal in simulator
00200000                           120      ENDC
00200000                           121  
00200000                           122      ENDM
00200000                           123  
00200000                           124  ; send CR,LF to the serial port
00200000                           125  ; \1 = data register to use for status poll
00200000                           126  PRINT_CRLF MACRO
00200000                           127      PRINT_CHAR #13,\1                           ; CR
00200000                           128      PRINT_CHAR #10,\1                           ; LF
00200000                           129      ENDM
00200000                           130  
00200000                           131  ; send C-style, zero terminated string to the serial port
00200000                           132  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           133  PRINT_STR MACRO
00200000                           134  LOOP\@
00200000                           135      CMP.B #0,(\1)                               ; 0 -> done
00200000                           136      BEQ EXIT\@
00200000                           137      PRINT_CHAR (\1)+,\2
00200000                           138      JMP LOOP\@
00200000                           139  EXIT\@
00200000                           140      ENDM
00200000                           141    
00200000                           142  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           143  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           144  PRINT_REG MACRO
00200000                           145      PRINT_CHAR #'0',\2                          ;0x header
00200000                           146      PRINT_CHAR #'x',\2
00200000                           147      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           148  LOOP\@
00200000                           149      BIN2HEX \1,\3,\5
00200000                           150      PRINT_CHAR \3,\2
00200000                           151      DBEQ \4,LOOP\@
00200000                           152      ENDM
00200000                           153    
00200000                           154  ; wait for a char from the serial port
00200000                           155  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           156  ; will stamp on D0 and D1 in debug mode
00200000                           157  WAIT_CHAR MACRO
00200000                           158  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           159  
00200000                           160      IFEQ DEBUG
00200000                           161          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           162          BTST #0,\2                              ; check for character
00200000                           163          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           164      ENDC
00200000                           165      
00200000                           166      READ_CHAR \1
00200000                           167  
00200000                           168      IFEQ DEBUG
00200000                           169          PRINT_CHAR \1,\2                        ; echo it back
00200000                           170      ENDC
00200000                           171      ENDM
00200000                           172      
00200000                           173  ; read a char from the serial port - assumes that there is one!
00200000                           174  ; \ 1= data register for read char
00200000                           175  ; will stamp on D0 and D1 in debug mode
00200000                           176  READ_CHAR MACRO
00200000                           177      IFEQ DEBUG
00200000                           178          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           179      ENDC
00200000                           180      IFNE DEBUG
00200000                           181          MOVE.L #5,D0    
00200000                           182          TRAP #15                                ; read from keyboard in simulator
00200000                           183          MOVE.L D1,\1
00200000                           184      ENDC
00200000                           185       
00200000                           186      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           187      BEQ START
00200000                           188      ENDM
00200000                           189      
00200000                           190      
00200000                           191  ; read data from the download serial port
00200000                           192  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           193  DOWNLOAD MACRO
00200000                           194  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           195  
00200000                           196      MOVE.B DUART_SRA,\2                         ; check for command
00200000                           197      BTST #0,\2                                  ; check for character
00200000                           198      BEQ CONTINUE\@                              ; nothing, continue
00200000                           199   
00200000                           200      READ_CHAR \1
00200000                           201  CONTINUE\@
00200000                           202      MOVE.B DUART_SRB,\2                         ; read status register
00200000                           203      BTST #0,\2                                  ; check for character
00200000                           204      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           205      
00200000                           206      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           207      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           208      
00200000                           209      ENDM
00200000                           210  
00200000                           211  ; register catalogue
00200000                           212  ; D0 - used for simulator I/O
00200000                           213  ; D1 - used for simulator I/O
00200000                           214  ; D2 - read character
00200000                           215  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           216  ; D4 - count of S records read
00200000                           217  ; D5 - data to write / data read / byte count for S record load
00200000                           218  ; D6 - working register used in R/W and download
00200000                           219  ; D7 - address accumulator / reset by download
00200000                           220  ; A0 - address of string to print 
00200000                           221  
00200000                           222  ; start vector
00200000= 00000000                 223  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 224  RESET    DC.L START                             ; RESET
00200008                           225      
00200008                           226  ; start of program  
00200008                           227  START
00200008  13FC 0000 00E00001       228      MOVE.B #0,DISPLAY
00200010                           229  
00200010                           230  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       231      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       232      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     233      NOP
00200022  13FC 0040 00C00005       234      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     235      NOP
0020002C  13FC 0030 00C00005       236      MOVE.B #$30,DUART_CRA
00200034  4E71                     237      NOP
00200036  13FC 0020 00C00005       238      MOVE.B #$20,DUART_CRA
0020003E  4E71                     239      NOP
00200040  13FC 0010 00C00005       240      MOVE.B #$10,DUART_CRA   
00200048                           241  
00200048  13FC 000A 00C00015       242      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       243      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     244      NOP
0020005A  13FC 0040 00C00015       245      MOVE.B #$40,DUART_CRB           
00200062  4E71                     246      NOP
00200064  13FC 0030 00C00015       247      MOVE.B #$30,DUART_CRB
0020006C  4E71                     248      NOP
0020006E  13FC 0020 00C00015       249      MOVE.B #$20,DUART_CRB
00200076  4E71                     250      NOP
00200078  13FC 0010 00C00015       251      MOVE.B #$10,DUART_CRB   
00200080                           252  
00200080                           253  ;initialise UART
00200080  13FC 0000 00C00009       254      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       255      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       256      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           257  
00200098                           258  ; channel A
00200098  13FC 0013 00C00001       259      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       260      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00BB 00C00003       261      MOVE.B #$BB,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       262      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           263  
002000B8                           264  ; channel B
002000B8  13FC 0013 00C00011       265      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       266      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00BB 00C00013       267      MOVE.B #$BB,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       268      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           269  
002000D8                           270m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           271m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      272m     IFEQ DEBUG
002000D8  1639 00C00003            273m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                274m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     275m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       276m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           277m     ENDC
002000EC                           278m     
002000EC                 FALSE     279m     IFNE DEBUG
002000EC                           280m     ENDC
002000EC                           281m 
002000EC                           282m     ENDM
002000EC                           283  
002000EC  13FC 0001 00E00001       284      MOVE.B #1,DISPLAY
002000F4                           285         
002000F4                           286m     PRINT_CRLF D3
002000F4                           287mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           288mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      289mm     IFEQ DEBUG
002000F4  1639 00C00003            290mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                291mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     292mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       293mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           294mm     ENDC
00200108                           295mm     
00200108                 FALSE     296mm     IFNE DEBUG
00200108                           297mm     ENDC
00200108                           298mm 
00200108                           299mm     ENDM
00200108                           300mm     PRINT_CHAR #10,D3                           ; LF
00200108                           301mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      302mm     IFEQ DEBUG
00200108  1639 00C00003            303mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                304mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     305mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       306mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           307mm     ENDC
0020011C                           308mm     
0020011C                 FALSE     309mm     IFNE DEBUG
0020011C                           310mm     ENDC
0020011C                           311mm 
0020011C                           312mm     ENDM
0020011C                           313m     ENDM
0020011C                           314  
0020011C  41F9 002019E2            315      LEA VERSION,A0
00200122                           316m     PRINT_STR A0,D3
00200122                           317m LOOP_5
00200122  0C10 0000                318m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                319m     BEQ EXIT_5
0020012A                           320mm     PRINT_CHAR (A0)+,D3
0020012A                           321mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      322mm     IFEQ DEBUG
0020012A  1639 00C00003            323mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                324mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     325mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            326mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           327mm     ENDC
0020013C                           328mm     
0020013C                 FALSE     329mm     IFNE DEBUG
0020013C                           330mm     ENDC
0020013C                           331mm 
0020013C                           332mm     ENDM
0020013C  4EF9 00200122            333m     JMP LOOP_5
00200142                           334m EXIT_5
00200142                           335m     ENDM
00200142                           336m     PRINT_CRLF D3
00200142                           337mm     PRINT_CHAR #13,D3                           ; CR
00200142                           338mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      339mm     IFEQ DEBUG
00200142  1639 00C00003            340mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                341mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     342mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       343mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           344mm     ENDC
00200156                           345mm     
00200156                 FALSE     346mm     IFNE DEBUG
00200156                           347mm     ENDC
00200156                           348mm 
00200156                           349mm     ENDM
00200156                           350mm     PRINT_CHAR #10,D3                           ; LF
00200156                           351mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      352mm     IFEQ DEBUG
00200156  1639 00C00003            353mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                354mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     355mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       356mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           357mm     ENDC
0020016A                           358mm     
0020016A                 FALSE     359mm     IFNE DEBUG
0020016A                           360mm     ENDC
0020016A                           361mm 
0020016A                           362mm     ENDM
0020016A                           363m     ENDM
0020016A                           364m     PRINT_CHAR #7,D3
0020016A                           365m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      366m     IFEQ DEBUG
0020016A  1639 00C00003            367m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                368m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     369m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       370m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           371m     ENDC
0020017E                           372m     
0020017E                 FALSE     373m     IFNE DEBUG
0020017E                           374m     ENDC
0020017E                           375m 
0020017E                           376m     ENDM
0020017E                           377  
0020017E  7E00                     378      MOVE.L #0,D7                                ; address accumulator
00200180                           379  
00200180  13FC 0002 00E00001       380      MOVE.B #2,DISPLAY
00200188                           381  MAIN_LOOP
00200188                           382m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           383m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      384m     IFEQ DEBUG
00200188  1639 00C00003            385m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                386m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     387m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       388m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           389m     ENDC
0020019C                           390m     
0020019C                 FALSE     391m     IFNE DEBUG
0020019C                           392m     ENDC
0020019C                           393m 
0020019C                           394m     ENDM
0020019C                           395m     PRINT_CHAR #32,D3                           ; space
0020019C                           396m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      397m     IFEQ DEBUG
0020019C  1639 00C00003            398m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                399m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     400m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       401m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           402m     ENDC
002001B0                           403m     
002001B0                 FALSE     404m     IFNE DEBUG
002001B0                           405m     ENDC
002001B0                           406m 
002001B0                           407m     ENDM
002001B0                           408      
002001B0                           409  GET_INPUT
002001B0                           410m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           411m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           412m 
002001B0                 TRUE      413m     IFEQ DEBUG
002001B0  1639 00C00003            414m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                415m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     416m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           417m     ENDC
002001BC                           418m     
002001BC                           419mm     READ_CHAR D2
002001BC                 TRUE      420mm     IFEQ DEBUG
002001BC  1439 00C00007            421mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           422mm     ENDC
002001C2                 FALSE     423mm     IFNE DEBUG
002001C2                           424mm     ENDC
002001C2                           425mm      
002001C2  B43C 001B                426mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                427mm     BEQ START
002001CA                           428mm     ENDM
002001CA                           429m 
002001CA                 TRUE      430m     IFEQ DEBUG
002001CA                           431mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           432mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      433mm     IFEQ DEBUG
002001CA  1639 00C00003            434mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                435mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     436mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            437mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           438mm     ENDC
002001DC                           439mm     
002001DC                 FALSE     440mm     IFNE DEBUG
002001DC                           441mm     ENDC
002001DC                           442mm 
002001DC                           443mm     ENDM
002001DC                           444m     ENDC
002001DC                           445m     ENDM
002001DC                           446      
002001DC  B43C 0030                447      CMP.B #'0',D2
002001E0  6700 17DE                448      BEQ HEX_DIGIT
002001E4  B43C 0031                449      CMP.B #'1',D2
002001E8  6700 17D6                450      BEQ HEX_DIGIT
002001EC  B43C 0032                451      CMP.B #'2',D2
002001F0  6700 17CE                452      BEQ HEX_DIGIT
002001F4  B43C 0033                453      CMP.B #'3',D2
002001F8  6700 17C6                454      BEQ HEX_DIGIT
002001FC  B43C 0034                455      CMP.B #'4',D2
00200200  6700 17BE                456      BEQ HEX_DIGIT
00200204  B43C 0035                457      CMP.B #'5',D2
00200208  6700 17B6                458      BEQ HEX_DIGIT
0020020C  B43C 0036                459      CMP.B #'6',D2
00200210  6700 17AE                460      BEQ HEX_DIGIT
00200214  B43C 0037                461      CMP.B #'7',D2
00200218  6700 17A6                462      BEQ HEX_DIGIT
0020021C  B43C 0038                463      CMP.B #'8',D2
00200220  6700 179E                464      BEQ HEX_DIGIT
00200224  B43C 0039                465      CMP.B #'9',D2
00200228  6700 1796                466      BEQ HEX_DIGIT
0020022C  B43C 0041                467      CMP.B #'A',D2
00200230  6700 178E                468      BEQ HEX_DIGIT
00200234  B43C 0042                469      CMP.B #'B',D2
00200238  6700 1786                470      BEQ HEX_DIGIT
0020023C  B43C 0043                471      CMP.B #'C',D2
00200240  6700 177E                472      BEQ HEX_DIGIT
00200244  B43C 0044                473      CMP.B #'D',D2
00200248  6700 1776                474      BEQ HEX_DIGIT
0020024C  B43C 0045                475      CMP.B #'E',D2
00200250  6700 176E                476      BEQ HEX_DIGIT
00200254  B43C 0046                477      CMP.B #'F',D2
00200258  6700 1766                478      BEQ HEX_DIGIT
0020025C                           479      
0020025C  B43C 0057                480      CMP.B #'W',D2
00200260  6700 016E                481      BEQ W
00200264                           482      
00200264  B43C 004C                483      CMP.B #'L',D2
00200268  6700 15E0                484      BEQ L 
0020026C                           485  
0020026C                           486m     PRINT_CRLF D3
0020026C                           487mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           488mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      489mm     IFEQ DEBUG
0020026C  1639 00C00003            490mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                491mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     492mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       493mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           494mm     ENDC
00200280                           495mm     
00200280                 FALSE     496mm     IFNE DEBUG
00200280                           497mm     ENDC
00200280                           498mm 
00200280                           499mm     ENDM
00200280                           500mm     PRINT_CHAR #10,D3                           ; LF
00200280                           501mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      502mm     IFEQ DEBUG
00200280  1639 00C00003            503mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                504mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     505mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       506mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           507mm     ENDC
00200294                           508mm     
00200294                 FALSE     509mm     IFNE DEBUG
00200294                           510mm     ENDC
00200294                           511mm 
00200294                           512mm     ENDM
00200294                           513m     ENDM
00200294                           514   
00200294  B43C 003F                515      CMP.B #'?',D2
00200298  6700 0056                516      BEQ H
0020029C                           517  
0020029C  B43C 0056                518      CMP.B #'V',D2
002002A0  6700 007A                519      BEQ V
002002A4                           520      
002002A4  B43C 0052                521      CMP.B #'R',D2
002002A8  6700 009E                522      BEQ R
002002AC                           523  
002002AC  B43C 0053                524      CMP.B #'S',D2
002002B0  6700 01E6                525      BEQ S
002002B4                           526  
002002B4  B43C 0047                527      CMP.B #'G',D2
002002B8  6700 147C                528      BEQ G   
002002BC                           529  
002002BC  B43C 005A                530      CMP.B #'Z',D2
002002C0  6700 147C                531      BEQ Z   
002002C4                           532  
002002C4  41F9 00201A96            533      LEA HUH,A0
002002CA                           534m     PRINT_STR A0,D3
002002CA                           535m LOOP_19
002002CA  0C10 0000                536m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                537m     BEQ EXIT_19
002002D2                           538mm     PRINT_CHAR (A0)+,D3
002002D2                           539mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      540mm     IFEQ DEBUG
002002D2  1639 00C00003            541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     543mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            544mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           545mm     ENDC
002002E4                           546mm     
002002E4                 FALSE     547mm     IFNE DEBUG
002002E4                           548mm     ENDC
002002E4                           549mm 
002002E4                           550mm     ENDM
002002E4  4EF9 002002CA            551m     JMP LOOP_19
002002EA                           552m EXIT_19
002002EA                           553m     ENDM
002002EA                           554                         
002002EA  4EF9 00200188            555      JMP MAIN_LOOP
002002F0                           556      
002002F0                           557  ; commands
002002F0  41F9 002019FF            558  H   LEA HELP,A0
002002F6                           559m     PRINT_STR A0,D3
002002F6                           560m LOOP_21
002002F6  0C10 0000                561m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                562m     BEQ EXIT_21
002002FE                           563mm     PRINT_CHAR (A0)+,D3
002002FE                           564mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      565mm     IFEQ DEBUG
002002FE  1639 00C00003            566mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                567mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     568mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            569mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           570mm     ENDC
00200310                           571mm     
00200310                 FALSE     572mm     IFNE DEBUG
00200310                           573mm     ENDC
00200310                           574mm 
00200310                           575mm     ENDM
00200310  4EF9 002002F6            576m     JMP LOOP_21
00200316                           577m EXIT_21
00200316                           578m     ENDM
00200316  4EF9 00200188            579      JMP MAIN_LOOP
0020031C                           580  
0020031C  41F9 002019E2            581  V   LEA VERSION,A0
00200322                           582m     PRINT_STR A0,D3       
00200322                           583m LOOP_23
00200322  0C10 0000                584m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                585m     BEQ EXIT_23
0020032A                           586mm     PRINT_CHAR (A0)+,D3
0020032A                           587mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      588mm     IFEQ DEBUG
0020032A  1639 00C00003            589mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                590mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     591mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            592mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           593mm     ENDC
0020033C                           594mm     
0020033C                 FALSE     595mm     IFNE DEBUG
0020033C                           596mm     ENDC
0020033C                           597mm 
0020033C                           598mm     ENDM
0020033C  4EF9 00200322            599m     JMP LOOP_23
00200342                           600m EXIT_23
00200342                           601m     ENDM
00200342  4EF9 00200188            602      JMP MAIN_LOOP
00200348                           603      
00200348  2047                     604  R   MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     605      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           606m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           607mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           608mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      609mm     IFEQ DEBUG
0020034C  1639 00C00003            610mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                611mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     612mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       613mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           614mm     ENDC
00200360                           615mm     
00200360                 FALSE     616mm     IFNE DEBUG
00200360                           617mm     ENDC
00200360                           618mm 
00200360                           619mm     ENDM
00200360                           620mm     PRINT_CHAR #'x',D3
00200360                           621mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      622mm     IFEQ DEBUG
00200360  1639 00C00003            623mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                624mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     625mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       626mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           627mm     ENDC
00200374                           628mm     
00200374                 FALSE     629mm     IFNE DEBUG
00200374                           630mm     ENDC
00200374                           631mm 
00200374                           632mm     ENDM
00200374  7C07                     633m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           634m LOOP_25
00200376                           635mm     BIN2HEX D5,D7,A0
00200376  41F9 00201AFA            636mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     637mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     638mm     MOVE.B D5,D7
00200380  0287 0000000F            639mm     ANDI.L #$F,D7
00200386  1E30 7000                640mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           641mm     ENDM
0020038A                           642mm     PRINT_CHAR D7,D3
0020038A                           643mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      644mm     IFEQ DEBUG
0020038A  1639 00C00003            645mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                646mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     647mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            648mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           649mm     ENDC
0020039C                           650mm     
0020039C                 FALSE     651mm     IFNE DEBUG
0020039C                           652mm     ENDC
0020039C                           653mm 
0020039C                           654mm     ENDM
0020039C  57CE FFD8                655m     DBEQ D6,LOOP_25
002003A0                           656m     ENDM
002003A0                           657m     PRINT_CRLF D3
002003A0                           658mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           659mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      660mm     IFEQ DEBUG
002003A0  1639 00C00003            661mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                662mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     663mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       664mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           665mm     ENDC
002003B4                           666mm     
002003B4                 FALSE     667mm     IFNE DEBUG
002003B4                           668mm     ENDC
002003B4                           669mm 
002003B4                           670mm     ENDM
002003B4                           671mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           672mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      673mm     IFEQ DEBUG
002003B4  1639 00C00003            674mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                675mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     676mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       677mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           678mm     ENDC
002003C8                           679mm     
002003C8                 FALSE     680mm     IFNE DEBUG
002003C8                           681mm     ENDC
002003C8                           682mm 
002003C8                           683mm     ENDM
002003C8                           684m     ENDM
002003C8  7E00                     685      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            686      JMP MAIN_LOOP
002003D0                           687  
002003D0  7A00                     688  W   MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           689  
002003D2                           690m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           691m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           692m 
002003D2                 TRUE      693m     IFEQ DEBUG
002003D2  1639 00C00003            694m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                695m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     696m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           697m     ENDC
002003DE                           698m     
002003DE                           699mm     READ_CHAR D2
002003DE                 TRUE      700mm     IFEQ DEBUG
002003DE  1439 00C00007            701mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           702mm     ENDC
002003E4                 FALSE     703mm     IFNE DEBUG
002003E4                           704mm     ENDC
002003E4                           705mm      
002003E4  B43C 001B                706mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                707mm     BEQ START
002003EC                           708mm     ENDM
002003EC                           709m 
002003EC                 TRUE      710m     IFEQ DEBUG
002003EC                           711mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           712mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      713mm     IFEQ DEBUG
002003EC  1639 00C00003            714mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                715mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     716mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            717mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           718mm     ENDC
002003FE                           719mm     
002003FE                 FALSE     720mm     IFNE DEBUG
002003FE                           721mm     ENDC
002003FE                           722mm 
002003FE                           723mm     ENDM
002003FE                           724m     ENDC
002003FE                           725m     ENDM
002003FE                           726m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 00201B0A            727m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                728m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            729m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                730m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           731m     ENDM
00200412  1A02                     732      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           733  
00200414  3C3C 0006                734      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           735      
00200418                           736  READ_DATA_TO_POKE
00200418  E98D                     737      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           738m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           739m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           740m 
0020041A                 TRUE      741m     IFEQ DEBUG
0020041A  1639 00C00003            742m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                743m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     744m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           745m     ENDC
00200426                           746m     
00200426                           747mm     READ_CHAR D2
00200426                 TRUE      748mm     IFEQ DEBUG
00200426  1439 00C00007            749mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           750mm     ENDC
0020042C                 FALSE     751mm     IFNE DEBUG
0020042C                           752mm     ENDC
0020042C                           753mm      
0020042C  B43C 001B                754mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                755mm     BEQ START
00200434                           756mm     ENDM
00200434                           757m 
00200434                 TRUE      758m     IFEQ DEBUG
00200434                           759mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           760mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      761mm     IFEQ DEBUG
00200434  1639 00C00003            762mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                763mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     764mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            765mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           766mm     ENDC
00200446                           767mm     
00200446                 FALSE     768mm     IFNE DEBUG
00200446                           769mm     ENDC
00200446                           770mm 
00200446                           771mm     ENDM
00200446                           772m     ENDC
00200446                           773m     ENDM
00200446                           774m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 00201B0A            775m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                776m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            777m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                778m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           779m     ENDM
0020045A  8A02                     780      OR.B D2,D5
0020045C  023C 00FB                781      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                782      DBEQ D6,READ_DATA_TO_POKE
00200464                           783      
00200464  2047                     784      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     785      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           786      
00200468  2085                     787      MOVE.L D5,(A0)                              ; write the data
0020046A                           788  
0020046A                           789m     PRINT_CRLF D3
0020046A                           790mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           791mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      792mm     IFEQ DEBUG
0020046A  1639 00C00003            793mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                794mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     795mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       796mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           797mm     ENDC
0020047E                           798mm     
0020047E                 FALSE     799mm     IFNE DEBUG
0020047E                           800mm     ENDC
0020047E                           801mm 
0020047E                           802mm     ENDM
0020047E                           803mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           804mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      805mm     IFEQ DEBUG
0020047E  1639 00C00003            806mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                807mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     808mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       809mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           810mm     ENDC
00200492                           811mm     
00200492                 FALSE     812mm     IFNE DEBUG
00200492                           813mm     ENDC
00200492                           814mm 
00200492                           815mm     ENDM
00200492                           816m     ENDM
00200492  4EF9 00200188            817      JMP MAIN_LOOP
00200498                           818  
00200498                           819          
00200498  2647                     820  S   MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     821      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                822      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           823      
002004A0                           824  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           825m     DOWNLOAD D2,D3                  
002004A0                           826m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           827m 
002004A0  1639 00C00003            828m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004A6  0803 0000                829m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                830m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           831m  
002004AE                           832mm     READ_CHAR D2
002004AE                 TRUE      833mm     IFEQ DEBUG
002004AE  1439 00C00007            834mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           835mm     ENDC
002004B4                 FALSE     836mm     IFNE DEBUG
002004B4                           837mm     ENDC
002004B4                           838mm      
002004B4  B43C 001B                839mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                840mm     BEQ START
002004BC                           841mm     ENDM
002004BC                           842m CONTINUE_44
002004BC  1639 00C00013            843m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002004C2  0803 0000                844m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004C6  67D8                     845m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           846m     
002004C8  1439 00C00017            847m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            848m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           849m     
002004D4                           850m     ENDM
002004D4  B43C 0053                851      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     852      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           853      
002004DA  5284                     854      ADD.L #1,D4                                 ; read another S record, increment count
002004DC                           855      
002004DC                           856m     DOWNLOAD D7,D3                              ; read the record digit
002004DC                           857m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DC                           858m 
002004DC  1639 00C00003            859m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004E2  0803 0000                860m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004E6  6700 0010                861m     BEQ CONTINUE_46                             ; NOTHING, CONTINUE
002004EA                           862m  
002004EA                           863mm     READ_CHAR D7
002004EA                 TRUE      864mm     IFEQ DEBUG
002004EA  1E39 00C00007            865mm         MOVE.B DUART_RXA,D7                     ; GOT A CHARACTER, READ IT
002004F0                           866mm     ENDC
002004F0                 FALSE     867mm     IFNE DEBUG
002004F0                           868mm     ENDC
002004F0                           869mm      
002004F0  BE3C 001B                870mm     CMP.B #$1B,D7                               ; CHECK FOR ESCAPE AND GO TO START
002004F4  6700 FB12                871mm     BEQ START
002004F8                           872mm     ENDM
002004F8                           873m CONTINUE_46
002004F8  1639 00C00013            874m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002004FE  0803 0000                875m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200502  67D8                     876m     BEQ WAIT_FOR_READY_46                       ; NOTHING, CHECK AGAIN
00200504                           877m     
00200504  1E39 00C00017            878m     MOVE.B DUART_RXB,D7                         ; GOT A CHARACTER, READ IT
0020050A  13C7 00E00001            879m     MOVE.B D7,DISPLAY                           ; ECHO TO THE DISPLAY
00200510                           880m     
00200510                           881m     ENDM
00200510                           882  
00200510  7C00                     883      MOVE.L #0,D6                                ; checksum
00200512                           884  
00200512  7A00                     885      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00200514                           886m     DOWNLOAD D2,D3              
00200514                           887m WAIT_FOR_READY_48                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200514                           888m 
00200514  1639 00C00003            889m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020051A  0803 0000                890m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020051E  6700 0010                891m     BEQ CONTINUE_48                             ; NOTHING, CONTINUE
00200522                           892m  
00200522                           893mm     READ_CHAR D2
00200522                 TRUE      894mm     IFEQ DEBUG
00200522  1439 00C00007            895mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200528                           896mm     ENDC
00200528                 FALSE     897mm     IFNE DEBUG
00200528                           898mm     ENDC
00200528                           899mm      
00200528  B43C 001B                900mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020052C  6700 FADA                901mm     BEQ START
00200530                           902mm     ENDM
00200530                           903m CONTINUE_48
00200530  1639 00C00013            904m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200536  0803 0000                905m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020053A  67D8                     906m     BEQ WAIT_FOR_READY_48                       ; NOTHING, CHECK AGAIN
0020053C                           907m     
0020053C  1439 00C00017            908m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200542  13C2 00E00001            909m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200548                           910m     
00200548                           911m     ENDM
00200548                           912m     HEX2BIN D2,D2,A0
00200548  41F9 00201B0A            913m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020054E  0402 0030                914m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200552  C4BC 000000FF            915m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200558  1430 2000                916m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020055C                           917m     ENDM
0020055C  8A82                     918      OR.L D2,D5
0020055E  E98D                     919      LSL.L #4,D5    
00200560                           920m     DOWNLOAD D2,D3
00200560                           921m WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200560                           922m 
00200560  1639 00C00003            923m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200566  0803 0000                924m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020056A  6700 0010                925m     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0020056E                           926m  
0020056E                           927mm     READ_CHAR D2
0020056E                 TRUE      928mm     IFEQ DEBUG
0020056E  1439 00C00007            929mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200574                           930mm     ENDC
00200574                 FALSE     931mm     IFNE DEBUG
00200574                           932mm     ENDC
00200574                           933mm      
00200574  B43C 001B                934mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200578  6700 FA8E                935mm     BEQ START
0020057C                           936mm     ENDM
0020057C                           937m CONTINUE_51
0020057C  1639 00C00013            938m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200582  0803 0000                939m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200586  67D8                     940m     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200588                           941m     
00200588  1439 00C00017            942m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020058E  13C2 00E00001            943m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200594                           944m     
00200594                           945m     ENDM
00200594                           946m     HEX2BIN D2,D2,A0  
00200594  41F9 00201B0A            947m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020059A  0402 0030                948m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020059E  C4BC 000000FF            949m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005A4  1430 2000                950m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005A8                           951m     ENDM
002005A8  8A82                     952      OR.L D2,D5
002005AA                           953                  
002005AA  DC85                     954      ADD.L D5,D6                                 ; add byte count into checksum
002005AC                           955  
002005AC                           956      IF.B D7 <EQ> #'0' THEN.L                    ; header
002005AC  BE3C 0030                957s     CMP.B   #'0',D7
002005B0  6600 022A                958s     BNE.L   _00000000
002005B4  7E00                     959          MOVE.L #0,D7                            ; read the 16 bit address, just checksum and then ignore
002005B6                           960m         DOWNLOAD D2,D3                          ; top byte
002005B6                           961m WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B6                           962m 
002005B6  1639 00C00003            963m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002005BC  0803 0000                964m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005C0  6700 0010                965m     BEQ CONTINUE_54                             ; NOTHING, CONTINUE
002005C4                           966m  
002005C4                           967mm     READ_CHAR D2
002005C4                 TRUE      968mm     IFEQ DEBUG
002005C4  1439 00C00007            969mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002005CA                           970mm     ENDC
002005CA                 FALSE     971mm     IFNE DEBUG
002005CA                           972mm     ENDC
002005CA                           973mm      
002005CA  B43C 001B                974mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002005CE  6700 FA38                975mm     BEQ START
002005D2                           976mm     ENDM
002005D2                           977m CONTINUE_54
002005D2  1639 00C00013            978m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002005D8  0803 0000                979m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005DC  67D8                     980m     BEQ WAIT_FOR_READY_54                       ; NOTHING, CHECK AGAIN
002005DE                           981m     
002005DE  1439 00C00017            982m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002005E4  13C2 00E00001            983m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002005EA                           984m     
002005EA                           985m     ENDM
002005EA                           986m         HEX2BIN D2,D2,A0
002005EA  41F9 00201B0A            987m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002005F0  0402 0030                988m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005F4  C4BC 000000FF            989m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005FA  1430 2000                990m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005FE                           991m     ENDM
002005FE  8E82                     992          OR.L D2,D7
00200600  E98F                     993          LSL.L #4,D7
00200602                           994m         DOWNLOAD D2,D3         
00200602                           995m WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200602                           996m 
00200602  1639 00C00003            997m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200608  0803 0000                998m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020060C  6700 0010                999m     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00200610                          1000m  
00200610                          1001mm     READ_CHAR D2
00200610                 TRUE     1002mm     IFEQ DEBUG
00200610  1439 00C00007           1003mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200616                          1004mm     ENDC
00200616                 FALSE    1005mm     IFNE DEBUG
00200616                          1006mm     ENDC
00200616                          1007mm      
00200616  B43C 001B               1008mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020061A  6700 F9EC               1009mm     BEQ START
0020061E                          1010mm     ENDM
0020061E                          1011m CONTINUE_57
0020061E  1639 00C00013           1012m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200624  0803 0000               1013m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200628  67D8                    1014m     BEQ WAIT_FOR_READY_57                       ; NOTHING, CHECK AGAIN
0020062A                          1015m     
0020062A  1439 00C00017           1016m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200630  13C2 00E00001           1017m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200636                          1018m     
00200636                          1019m     ENDM
00200636                          1020m         HEX2BIN D2,D2,A0
00200636  41F9 00201B0A           1021m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020063C  0402 0030               1022m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200640  C4BC 000000FF           1023m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200646  1430 2000               1024m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020064A                          1025m     ENDM
0020064A  8E82                    1026          OR.L D2,D7
0020064C                          1027          
0020064C  DC87                    1028          ADD.L D7,D6                             ; add top byte of address into checksum
0020064E                          1029  
0020064E  E98F                    1030          LSL.L #4,D7                             ; bottom byte
00200650                          1031m         DOWNLOAD D2,D3
00200650                          1032m WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200650                          1033m 
00200650  1639 00C00003           1034m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200656  0803 0000               1035m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020065A  6700 0010               1036m     BEQ CONTINUE_60                             ; NOTHING, CONTINUE
0020065E                          1037m  
0020065E                          1038mm     READ_CHAR D2
0020065E                 TRUE     1039mm     IFEQ DEBUG
0020065E  1439 00C00007           1040mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200664                          1041mm     ENDC
00200664                 FALSE    1042mm     IFNE DEBUG
00200664                          1043mm     ENDC
00200664                          1044mm      
00200664  B43C 001B               1045mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200668  6700 F99E               1046mm     BEQ START
0020066C                          1047mm     ENDM
0020066C                          1048m CONTINUE_60
0020066C  1639 00C00013           1049m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200672  0803 0000               1050m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200676  67D8                    1051m     BEQ WAIT_FOR_READY_60                       ; NOTHING, CHECK AGAIN
00200678                          1052m     
00200678  1439 00C00017           1053m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020067E  13C2 00E00001           1054m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200684                          1055m     
00200684                          1056m     ENDM
00200684                          1057m         HEX2BIN D2,D2,A0
00200684  41F9 00201B0A           1058m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020068A  0402 0030               1059m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020068E  C4BC 000000FF           1060m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200694  1430 2000               1061m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200698                          1062m     ENDM
00200698  8E82                    1063          OR.L D2,D7
0020069A  E98F                    1064          LSL.L #4,D7        
0020069C                          1065m         DOWNLOAD D2,D3
0020069C                          1066m WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020069C                          1067m 
0020069C  1639 00C00003           1068m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002006A2  0803 0000               1069m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006A6  6700 0010               1070m     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
002006AA                          1071m  
002006AA                          1072mm     READ_CHAR D2
002006AA                 TRUE     1073mm     IFEQ DEBUG
002006AA  1439 00C00007           1074mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002006B0                          1075mm     ENDC
002006B0                 FALSE    1076mm     IFNE DEBUG
002006B0                          1077mm     ENDC
002006B0                          1078mm      
002006B0  B43C 001B               1079mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002006B4  6700 F952               1080mm     BEQ START
002006B8                          1081mm     ENDM
002006B8                          1082m CONTINUE_63
002006B8  1639 00C00013           1083m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002006BE  0803 0000               1084m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006C2  67D8                    1085m     BEQ WAIT_FOR_READY_63                       ; NOTHING, CHECK AGAIN
002006C4                          1086m     
002006C4  1439 00C00017           1087m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006CA  13C2 00E00001           1088m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006D0                          1089m     
002006D0                          1090m     ENDM
002006D0                          1091m         HEX2BIN D2,D2,A0
002006D0  41F9 00201B0A           1092m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006D6  0402 0030               1093m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006DA  C4BC 000000FF           1094m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006E0  1430 2000               1095m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006E4                          1096m     ENDM
002006E4  8E82                    1097          OR.L D2,D7
002006E6                          1098          
002006E6  7400                    1099          MOVE.L #0,D2                            ; rextract bottom byte of address and add into checksum
002006E8  1407                    1100          MOVE.B D7,D2
002006EA  DC82                    1101          ADD.L D2,D6
002006EC                          1102          
002006EC  5785                    1103          SUB.L #3,D5                             ; subtract three bytes for 16 bit address and 1 byte checksum
002006EE                          1104          WHILE.L D5 <GT> #0 DO                   ; read the data bytes
002006EE                          1105s _10000000
002006EE  BABC 00000000           1106s     CMP.L   #0,D5
002006F4  6F00 00B4               1107s     BLE _10000001
002006F8  5385                    1108              SUB.L #1,D5
002006FA                          1109              
002006FA  7E00                    1110              MOVE.L #0,D7                        ; D7 holds the byte
002006FC                          1111              
002006FC                          1112m             DOWNLOAD D2,D3                      ; MS 4 bits
002006FC                          1113m WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006FC                          1114m 
002006FC  1639 00C00003           1115m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200702  0803 0000               1116m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200706  6700 0010               1117m     BEQ CONTINUE_66                             ; NOTHING, CONTINUE
0020070A                          1118m  
0020070A                          1119mm     READ_CHAR D2
0020070A                 TRUE     1120mm     IFEQ DEBUG
0020070A  1439 00C00007           1121mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200710                          1122mm     ENDC
00200710                 FALSE    1123mm     IFNE DEBUG
00200710                          1124mm     ENDC
00200710                          1125mm      
00200710  B43C 001B               1126mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200714  6700 F8F2               1127mm     BEQ START
00200718                          1128mm     ENDM
00200718                          1129m CONTINUE_66
00200718  1639 00C00013           1130m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020071E  0803 0000               1131m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200722  67D8                    1132m     BEQ WAIT_FOR_READY_66                       ; NOTHING, CHECK AGAIN
00200724                          1133m     
00200724  1439 00C00017           1134m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020072A  13C2 00E00001           1135m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200730                          1136m     
00200730                          1137m     ENDM
00200730                          1138m             HEX2BIN D2,D2,A0
00200730  41F9 00201B0A           1139m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200736  0402 0030               1140m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020073A  C4BC 000000FF           1141m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200740  1430 2000               1142m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200744                          1143m     ENDM
00200744  8E82                    1144              OR.L D2,D7
00200746  E98F                    1145              LSL.L #4,D7
00200748                          1146               
00200748                          1147m             DOWNLOAD D2,D3                      ; LS 4 bits    
00200748                          1148m WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200748                          1149m 
00200748  1639 00C00003           1150m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020074E  0803 0000               1151m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200752  6700 0010               1152m     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00200756                          1153m  
00200756                          1154mm     READ_CHAR D2
00200756                 TRUE     1155mm     IFEQ DEBUG
00200756  1439 00C00007           1156mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020075C                          1157mm     ENDC
0020075C                 FALSE    1158mm     IFNE DEBUG
0020075C                          1159mm     ENDC
0020075C                          1160mm      
0020075C  B43C 001B               1161mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200760  6700 F8A6               1162mm     BEQ START
00200764                          1163mm     ENDM
00200764                          1164m CONTINUE_69
00200764  1639 00C00013           1165m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020076A  0803 0000               1166m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020076E  67D8                    1167m     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00200770                          1168m     
00200770  1439 00C00017           1169m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200776  13C2 00E00001           1170m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020077C                          1171m     
0020077C                          1172m     ENDM
0020077C                          1173m             HEX2BIN D2,D2,A0
0020077C  41F9 00201B0A           1174m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200782  0402 0030               1175m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200786  C4BC 000000FF           1176m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020078C  1430 2000               1177m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200790                          1178m     ENDM
00200790  8E82                    1179              OR.L D2,D7
00200792                          1180              
00200792  DC87                    1181              ADD.L D7,D6                         ; add into checksum
00200794                          1182            
00200794                          1183m             PRINT_CHAR D7,D3                    ; assume ASCII and print it
00200794                          1184m WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200794                 TRUE     1185m     IFEQ DEBUG
00200794  1639 00C00003           1186m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020079A  0803 0002               1187m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020079E  67F4                    1188m         BEQ WAIT_FOR_READY_72                   ; NO SPACE, CHECK AGAIN
002007A0  13C7 00C00007           1189m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007A6                          1190m     ENDC
002007A6                          1191m     
002007A6                 FALSE    1192m     IFNE DEBUG
002007A6                          1193m     ENDC
002007A6                          1194m 
002007A6                          1195m     ENDM
002007A6                          1196          ENDW
002007A6  6000 FF46               1197s     BRA _10000000
002007AA                          1198s _10000001
002007AA                          1199m         PRINT_CRLF D3
002007AA                          1200mm     PRINT_CHAR #13,D3                           ; CR
002007AA                          1201mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007AA                 TRUE     1202mm     IFEQ DEBUG
002007AA  1639 00C00003           1203mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007B0  0803 0002               1204mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007B4  67F4                    1205mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
002007B6  13FC 000D 00C00007      1206mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002007BE                          1207mm     ENDC
002007BE                          1208mm     
002007BE                 FALSE    1209mm     IFNE DEBUG
002007BE                          1210mm     ENDC
002007BE                          1211mm 
002007BE                          1212mm     ENDM
002007BE                          1213mm     PRINT_CHAR #10,D3                           ; LF
002007BE                          1214mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007BE                 TRUE     1215mm     IFEQ DEBUG
002007BE  1639 00C00003           1216mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007C4  0803 0002               1217mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007C8  67F4                    1218mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
002007CA  13FC 000A 00C00007      1219mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002007D2                          1220mm     ENDC
002007D2                          1221mm     
002007D2                 FALSE    1222mm     IFNE DEBUG
002007D2                          1223mm     ENDC
002007D2                          1224mm 
002007D2                          1225mm     ENDM
002007D2                          1226m     ENDM
002007D2  43F9 002004A0           1227         LEA WAIT_FOR_SRECORD,A1            
002007D8                          1228      ELSE
002007D8  6000 0D0E               1229s     BRA _00000001
002007DC                          1230s _00000000
002007DC                          1231          IF.B D7 <EQ> #'1' THEN.L                ; 16 bit address data record
002007DC  BE3C 0031               1232s     CMP.B   #'1',D7
002007E0  6600 04F6               1233s     BNE.L   _00000002
002007E4  7E00                    1234              MOVE.L #0,D7                        ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007E6                          1235m             DOWNLOAD D2,D3                      ; top byte
002007E6                          1236m WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007E6                          1237m 
002007E6  1639 00C00003           1238m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002007EC  0803 0000               1239m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002007F0  6700 0010               1240m     BEQ CONTINUE_76                             ; NOTHING, CONTINUE
002007F4                          1241m  
002007F4                          1242mm     READ_CHAR D2
002007F4                 TRUE     1243mm     IFEQ DEBUG
002007F4  1439 00C00007           1244mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002007FA                          1245mm     ENDC
002007FA                 FALSE    1246mm     IFNE DEBUG
002007FA                          1247mm     ENDC
002007FA                          1248mm      
002007FA  B43C 001B               1249mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002007FE  6700 F808               1250mm     BEQ START
00200802                          1251mm     ENDM
00200802                          1252m CONTINUE_76
00200802  1639 00C00013           1253m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200808  0803 0000               1254m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020080C  67D8                    1255m     BEQ WAIT_FOR_READY_76                       ; NOTHING, CHECK AGAIN
0020080E                          1256m     
0020080E  1439 00C00017           1257m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200814  13C2 00E00001           1258m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020081A                          1259m     
0020081A                          1260m     ENDM
0020081A                          1261m             PRINT_CHAR D2,D3
0020081A                          1262m WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020081A                 TRUE     1263m     IFEQ DEBUG
0020081A  1639 00C00003           1264m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200820  0803 0002               1265m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200824  67F4                    1266m         BEQ WAIT_FOR_READY_78                   ; NO SPACE, CHECK AGAIN
00200826  13C2 00C00007           1267m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020082C                          1268m     ENDC
0020082C                          1269m     
0020082C                 FALSE    1270m     IFNE DEBUG
0020082C                          1271m     ENDC
0020082C                          1272m 
0020082C                          1273m     ENDM
0020082C                          1274m             HEX2BIN D2,D2,A0
0020082C  41F9 00201B0A           1275m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200832  0402 0030               1276m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200836  C4BC 000000FF           1277m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020083C  1430 2000               1278m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200840                          1279m     ENDM
00200840  8E82                    1280              OR.L D2,D7
00200842  E98F                    1281              LSL.L #4,D7
00200844                          1282m             DOWNLOAD D2,D3         
00200844                          1283m WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200844                          1284m 
00200844  1639 00C00003           1285m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020084A  0803 0000               1286m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020084E  6700 0010               1287m     BEQ CONTINUE_80                             ; NOTHING, CONTINUE
00200852                          1288m  
00200852                          1289mm     READ_CHAR D2
00200852                 TRUE     1290mm     IFEQ DEBUG
00200852  1439 00C00007           1291mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200858                          1292mm     ENDC
00200858                 FALSE    1293mm     IFNE DEBUG
00200858                          1294mm     ENDC
00200858                          1295mm      
00200858  B43C 001B               1296mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020085C  6700 F7AA               1297mm     BEQ START
00200860                          1298mm     ENDM
00200860                          1299m CONTINUE_80
00200860  1639 00C00013           1300m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200866  0803 0000               1301m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020086A  67D8                    1302m     BEQ WAIT_FOR_READY_80                       ; NOTHING, CHECK AGAIN
0020086C                          1303m     
0020086C  1439 00C00017           1304m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200872  13C2 00E00001           1305m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200878                          1306m     
00200878                          1307m     ENDM
00200878                          1308m             PRINT_CHAR D2,D3
00200878                          1309m WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1310m     IFEQ DEBUG
00200878  1639 00C00003           1311m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020087E  0803 0002               1312m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200882  67F4                    1313m         BEQ WAIT_FOR_READY_82                   ; NO SPACE, CHECK AGAIN
00200884  13C2 00C00007           1314m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020088A                          1315m     ENDC
0020088A                          1316m     
0020088A                 FALSE    1317m     IFNE DEBUG
0020088A                          1318m     ENDC
0020088A                          1319m 
0020088A                          1320m     ENDM
0020088A                          1321m             HEX2BIN D2,D2,A0
0020088A  41F9 00201B0A           1322m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200890  0402 0030               1323m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200894  C4BC 000000FF           1324m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020089A  1430 2000               1325m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020089E                          1326m     ENDM
0020089E  8E82                    1327              OR.L D2,D7
002008A0                          1328          
002008A0  DC87                    1329              ADD.L D7,D6                         ; add top byte of address into checksum
002008A2                          1330  
002008A2  E98F                    1331              LSL.L #4,D7                         ; bottom byte
002008A4                          1332m             DOWNLOAD D2,D3
002008A4                          1333m WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A4                          1334m 
002008A4  1639 00C00003           1335m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002008AA  0803 0000               1336m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008AE  6700 0010               1337m     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
002008B2                          1338m  
002008B2                          1339mm     READ_CHAR D2
002008B2                 TRUE     1340mm     IFEQ DEBUG
002008B2  1439 00C00007           1341mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008B8                          1342mm     ENDC
002008B8                 FALSE    1343mm     IFNE DEBUG
002008B8                          1344mm     ENDC
002008B8                          1345mm      
002008B8  B43C 001B               1346mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002008BC  6700 F74A               1347mm     BEQ START
002008C0                          1348mm     ENDM
002008C0                          1349m CONTINUE_84
002008C0  1639 00C00013           1350m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002008C6  0803 0000               1351m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008CA  67D8                    1352m     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
002008CC                          1353m     
002008CC  1439 00C00017           1354m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008D2  13C2 00E00001           1355m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008D8                          1356m     
002008D8                          1357m     ENDM
002008D8                          1358m             PRINT_CHAR D2,D3
002008D8                          1359m WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D8                 TRUE     1360m     IFEQ DEBUG
002008D8  1639 00C00003           1361m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008DE  0803 0002               1362m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008E2  67F4                    1363m         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008E4  13C2 00C00007           1364m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008EA                          1365m     ENDC
002008EA                          1366m     
002008EA                 FALSE    1367m     IFNE DEBUG
002008EA                          1368m     ENDC
002008EA                          1369m 
002008EA                          1370m     ENDM
002008EA                          1371m             HEX2BIN D2,D2,A0
002008EA  41F9 00201B0A           1372m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008F0  0402 0030               1373m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F4  C4BC 000000FF           1374m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008FA  1430 2000               1375m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008FE                          1376m     ENDM
002008FE  8E82                    1377              OR.L D2,D7
00200900  E98F                    1378              LSL.L #4,D7        
00200902                          1379m             DOWNLOAD D2,D3
00200902                          1380m WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200902                          1381m 
00200902  1639 00C00003           1382m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200908  0803 0000               1383m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020090C  6700 0010               1384m     BEQ CONTINUE_88                             ; NOTHING, CONTINUE
00200910                          1385m  
00200910                          1386mm     READ_CHAR D2
00200910                 TRUE     1387mm     IFEQ DEBUG
00200910  1439 00C00007           1388mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200916                          1389mm     ENDC
00200916                 FALSE    1390mm     IFNE DEBUG
00200916                          1391mm     ENDC
00200916                          1392mm      
00200916  B43C 001B               1393mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020091A  6700 F6EC               1394mm     BEQ START
0020091E                          1395mm     ENDM
0020091E                          1396m CONTINUE_88
0020091E  1639 00C00013           1397m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200924  0803 0000               1398m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200928  67D8                    1399m     BEQ WAIT_FOR_READY_88                       ; NOTHING, CHECK AGAIN
0020092A                          1400m     
0020092A  1439 00C00017           1401m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200930  13C2 00E00001           1402m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200936                          1403m     
00200936                          1404m     ENDM
00200936                          1405m             PRINT_CHAR D2,D3
00200936                          1406m WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200936                 TRUE     1407m     IFEQ DEBUG
00200936  1639 00C00003           1408m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020093C  0803 0002               1409m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200940  67F4                    1410m         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00200942  13C2 00C00007           1411m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200948                          1412m     ENDC
00200948                          1413m     
00200948                 FALSE    1414m     IFNE DEBUG
00200948                          1415m     ENDC
00200948                          1416m 
00200948                          1417m     ENDM
00200948                          1418m             HEX2BIN D2,D2,A0
00200948  41F9 00201B0A           1419m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020094E  0402 0030               1420m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200952  C4BC 000000FF           1421m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200958  1430 2000               1422m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020095C                          1423m     ENDM
0020095C  8E82                    1424              OR.L D2,D7
0020095E                          1425          
0020095E  7400                    1426              MOVE.L #0,D2                        ; rextract bottom byte of address and add into checksum
00200960  1407                    1427              MOVE.B D7,D2
00200962  DC82                    1428              ADD.L D2,D6
00200964                          1429          
00200964  DE8B                    1430              ADD.L A3,D7                         ; add in the offset
00200966                          1431          
00200966  5785                    1432              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
00200968                          1433          
00200968  0807 0000               1434              BTST #0,D7                          ; deal with odd addresses
0020096C                          1435  
0020096C  2247                    1436              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
0020096E  6700 00D0               1437              BEQ EVEN
00200972                          1438                  
00200972  5385                    1439              SUB.L #1,D5
00200974  5389                    1440              SUB.L #1,A1
00200976                          1441          
00200976  7E00                    1442              MOVE.L #0,D7
00200978                          1443m             DOWNLOAD D2,D3                      ; MS 4 bits
00200978                          1444m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200978                          1445m 
00200978  1639 00C00003           1446m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020097E  0803 0000               1447m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200982  6700 0010               1448m     BEQ CONTINUE_92                             ; NOTHING, CONTINUE
00200986                          1449m  
00200986                          1450mm     READ_CHAR D2
00200986                 TRUE     1451mm     IFEQ DEBUG
00200986  1439 00C00007           1452mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020098C                          1453mm     ENDC
0020098C                 FALSE    1454mm     IFNE DEBUG
0020098C                          1455mm     ENDC
0020098C                          1456mm      
0020098C  B43C 001B               1457mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200990  6700 F676               1458mm     BEQ START
00200994                          1459mm     ENDM
00200994                          1460m CONTINUE_92
00200994  1639 00C00013           1461m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020099A  0803 0000               1462m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020099E  67D8                    1463m     BEQ WAIT_FOR_READY_92                       ; NOTHING, CHECK AGAIN
002009A0                          1464m     
002009A0  1439 00C00017           1465m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002009A6  13C2 00E00001           1466m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002009AC                          1467m     
002009AC                          1468m     ENDM
002009AC                          1469m             PRINT_CHAR D2,D3
002009AC                          1470m WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009AC                 TRUE     1471m     IFEQ DEBUG
002009AC  1639 00C00003           1472m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009B2  0803 0002               1473m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009B6  67F4                    1474m         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
002009B8  13C2 00C00007           1475m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009BE                          1476m     ENDC
002009BE                          1477m     
002009BE                 FALSE    1478m     IFNE DEBUG
002009BE                          1479m     ENDC
002009BE                          1480m 
002009BE                          1481m     ENDM
002009BE                          1482m             HEX2BIN D2,D2,A0
002009BE  41F9 00201B0A           1483m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002009C4  0402 0030               1484m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009C8  C4BC 000000FF           1485m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002009CE  1430 2000               1486m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002009D2                          1487m     ENDM
002009D2  8E82                    1488              OR.L D2,D7
002009D4  E98F                    1489              LSL.L #4,D7
002009D6                          1490               
002009D6                          1491m             DOWNLOAD D2,D3                      ; LS 4 bits    
002009D6                          1492m WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D6                          1493m 
002009D6  1639 00C00003           1494m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002009DC  0803 0000               1495m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009E0  6700 0010               1496m     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
002009E4                          1497m  
002009E4                          1498mm     READ_CHAR D2
002009E4                 TRUE     1499mm     IFEQ DEBUG
002009E4  1439 00C00007           1500mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002009EA                          1501mm     ENDC
002009EA                 FALSE    1502mm     IFNE DEBUG
002009EA                          1503mm     ENDC
002009EA                          1504mm      
002009EA  B43C 001B               1505mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002009EE  6700 F618               1506mm     BEQ START
002009F2                          1507mm     ENDM
002009F2                          1508m CONTINUE_96
002009F2  1639 00C00013           1509m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002009F8  0803 0000               1510m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009FC  67D8                    1511m     BEQ WAIT_FOR_READY_96                       ; NOTHING, CHECK AGAIN
002009FE                          1512m     
002009FE  1439 00C00017           1513m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A04  13C2 00E00001           1514m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A0A                          1515m     
00200A0A                          1516m     ENDM
00200A0A                          1517m             PRINT_CHAR D2,D3
00200A0A                          1518m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A0A                 TRUE     1519m     IFEQ DEBUG
00200A0A  1639 00C00003           1520m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A10  0803 0002               1521m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A14  67F4                    1522m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00200A16  13C2 00C00007           1523m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A1C                          1524m     ENDC
00200A1C                          1525m     
00200A1C                 FALSE    1526m     IFNE DEBUG
00200A1C                          1527m     ENDC
00200A1C                          1528m 
00200A1C                          1529m     ENDM
00200A1C                          1530m             HEX2BIN D2,D2,A0
00200A1C  41F9 00201B0A           1531m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A22  0402 0030               1532m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A26  C4BC 000000FF           1533m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A2C  1430 2000               1534m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A30                          1535m     ENDM
00200A30  8E82                    1536              OR.L D2,D7
00200A32                          1537                          
00200A32  DC87                    1538              ADD.L D7,D6                         ; add into checksum
00200A34                          1539                        
00200A34  3611                    1540              MOVE.W (A1),D3                      ; get the current data and replace the bottom byte
00200A36                          1541          
00200A36  0243 FF00               1542              ANDI.W #$FF00,D3
00200A3A  8647                    1543              OR.W D7,D3
00200A3C                          1544          
00200A3C  3283                    1545              MOVE.W D3,(A1)                      ; store it!
00200A3E  5489                    1546              ADD.L #2,A1
00200A40                          1547  EVEN        
00200A40                          1548              WHILE.L D5 <GE> #2 DO               ; read the data bytes
00200A40                          1549s _10000002
00200A40  BABC 00000002           1550s     CMP.L   #2,D5
00200A46  6D00 018A               1551s     BLT _10000003
00200A4A  5585                    1552                  SUB.L #2,D5
00200A4C  7E00                    1553                  MOVE.L #0,D7                    ; D7 holds the word
00200A4E                          1554              
00200A4E                          1555m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200A4E                          1556m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4E                          1557m 
00200A4E  1639 00C00003           1558m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200A54  0803 0000               1559m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A58  6700 0010               1560m     BEQ CONTINUE_100                                ; NOTHING, CONTINUE
00200A5C                          1561m  
00200A5C                          1562mm     READ_CHAR D2
00200A5C                 TRUE     1563mm     IFEQ DEBUG
00200A5C  1439 00C00007           1564mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A62                          1565mm     ENDC
00200A62                 FALSE    1566mm     IFNE DEBUG
00200A62                          1567mm     ENDC
00200A62                          1568mm      
00200A62  B43C 001B               1569mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A66  6700 F5A0               1570mm     BEQ START
00200A6A                          1571mm     ENDM
00200A6A                          1572m CONTINUE_100
00200A6A  1639 00C00013           1573m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200A70  0803 0000               1574m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A74  67D8                    1575m     BEQ WAIT_FOR_READY_100                      ; NOTHING, CHECK AGAIN
00200A76                          1576m     
00200A76  1439 00C00017           1577m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A7C  13C2 00E00001           1578m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A82                          1579m     
00200A82                          1580m     ENDM
00200A82                          1581m                 PRINT_CHAR D2,D3
00200A82                          1582m WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A82                 TRUE     1583m     IFEQ DEBUG
00200A82  1639 00C00003           1584m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A88  0803 0002               1585m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A8C  67F4                    1586m         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00200A8E  13C2 00C00007           1587m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A94                          1588m     ENDC
00200A94                          1589m     
00200A94                 FALSE    1590m     IFNE DEBUG
00200A94                          1591m     ENDC
00200A94                          1592m 
00200A94                          1593m     ENDM
00200A94                          1594m                 HEX2BIN D2,D2,A0
00200A94  41F9 00201B0A           1595m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A9A  0402 0030               1596m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A9E  C4BC 000000FF           1597m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200AA4  1430 2000               1598m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200AA8                          1599m     ENDM
00200AA8  8E82                    1600                  OR.L D2,D7
00200AAA  E98F                    1601                  LSL.L #4,D7
00200AAC                          1602               
00200AAC                          1603m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200AAC                          1604m WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AAC                          1605m 
00200AAC  1639 00C00003           1606m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200AB2  0803 0000               1607m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AB6  6700 0010               1608m     BEQ CONTINUE_104                                ; NOTHING, CONTINUE
00200ABA                          1609m  
00200ABA                          1610mm     READ_CHAR D2
00200ABA                 TRUE     1611mm     IFEQ DEBUG
00200ABA  1439 00C00007           1612mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200AC0                          1613mm     ENDC
00200AC0                 FALSE    1614mm     IFNE DEBUG
00200AC0                          1615mm     ENDC
00200AC0                          1616mm      
00200AC0  B43C 001B               1617mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200AC4  6700 F542               1618mm     BEQ START
00200AC8                          1619mm     ENDM
00200AC8                          1620m CONTINUE_104
00200AC8  1639 00C00013           1621m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200ACE  0803 0000               1622m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AD2  67D8                    1623m     BEQ WAIT_FOR_READY_104                      ; NOTHING, CHECK AGAIN
00200AD4                          1624m     
00200AD4  1439 00C00017           1625m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200ADA  13C2 00E00001           1626m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200AE0                          1627m     
00200AE0                          1628m     ENDM
00200AE0                          1629m                 PRINT_CHAR D2,D3
00200AE0                          1630m WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1631m     IFEQ DEBUG
00200AE0  1639 00C00003           1632m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AE6  0803 0002               1633m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1634m         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00200AEC  13C2 00C00007           1635m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AF2                          1636m     ENDC
00200AF2                          1637m     
00200AF2                 FALSE    1638m     IFNE DEBUG
00200AF2                          1639m     ENDC
00200AF2                          1640m 
00200AF2                          1641m     ENDM
00200AF2                          1642m                 HEX2BIN D2,D2,A0
00200AF2  41F9 00201B0A           1643m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200AF8  0402 0030               1644m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200AFC  C4BC 000000FF           1645m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B02  1430 2000               1646m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B06                          1647m     ENDM
00200B06  8E82                    1648                  OR.L D2,D7
00200B08                          1649                          
00200B08  DC87                    1650                  ADD.L D7,D6                     ; add into checksum
00200B0A                          1651              
00200B0A  E98F                    1652                  LSL.L #4,D7
00200B0C                          1653m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200B0C                          1654m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0C                          1655m 
00200B0C  1639 00C00003           1656m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200B12  0803 0000               1657m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B16  6700 0010               1658m     BEQ CONTINUE_108                                ; NOTHING, CONTINUE
00200B1A                          1659m  
00200B1A                          1660mm     READ_CHAR D2
00200B1A                 TRUE     1661mm     IFEQ DEBUG
00200B1A  1439 00C00007           1662mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B20                          1663mm     ENDC
00200B20                 FALSE    1664mm     IFNE DEBUG
00200B20                          1665mm     ENDC
00200B20                          1666mm      
00200B20  B43C 001B               1667mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B24  6700 F4E2               1668mm     BEQ START
00200B28                          1669mm     ENDM
00200B28                          1670m CONTINUE_108
00200B28  1639 00C00013           1671m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B2E  0803 0000               1672m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B32  67D8                    1673m     BEQ WAIT_FOR_READY_108                      ; NOTHING, CHECK AGAIN
00200B34                          1674m     
00200B34  1439 00C00017           1675m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B3A  13C2 00E00001           1676m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B40                          1677m     
00200B40                          1678m     ENDM
00200B40                          1679m                 PRINT_CHAR D2,D3
00200B40                          1680m WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B40                 TRUE     1681m     IFEQ DEBUG
00200B40  1639 00C00003           1682m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B46  0803 0002               1683m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B4A  67F4                    1684m         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200B4C  13C2 00C00007           1685m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B52                          1686m     ENDC
00200B52                          1687m     
00200B52                 FALSE    1688m     IFNE DEBUG
00200B52                          1689m     ENDC
00200B52                          1690m 
00200B52                          1691m     ENDM
00200B52                          1692m                 HEX2BIN D2,D2,A0
00200B52  41F9 00201B0A           1693m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B58  0402 0030               1694m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B5C  C4BC 000000FF           1695m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B62  1430 2000               1696m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B66                          1697m     ENDM
00200B66  8E82                    1698                  OR.L D2,D7
00200B68                          1699               
00200B68  E98F                    1700                  LSL.L #4,D7
00200B6A                          1701m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200B6A                          1702m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B6A                          1703m 
00200B6A  1639 00C00003           1704m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200B70  0803 0000               1705m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B74  6700 0010               1706m     BEQ CONTINUE_112                                ; NOTHING, CONTINUE
00200B78                          1707m  
00200B78                          1708mm     READ_CHAR D2
00200B78                 TRUE     1709mm     IFEQ DEBUG
00200B78  1439 00C00007           1710mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B7E                          1711mm     ENDC
00200B7E                 FALSE    1712mm     IFNE DEBUG
00200B7E                          1713mm     ENDC
00200B7E                          1714mm      
00200B7E  B43C 001B               1715mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B82  6700 F484               1716mm     BEQ START
00200B86                          1717mm     ENDM
00200B86                          1718m CONTINUE_112
00200B86  1639 00C00013           1719m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B8C  0803 0000               1720m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B90  67D8                    1721m     BEQ WAIT_FOR_READY_112                      ; NOTHING, CHECK AGAIN
00200B92                          1722m     
00200B92  1439 00C00017           1723m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B98  13C2 00E00001           1724m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B9E                          1725m     
00200B9E                          1726m     ENDM
00200B9E                          1727m                 PRINT_CHAR D2,D3
00200B9E                          1728m WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B9E                 TRUE     1729m     IFEQ DEBUG
00200B9E  1639 00C00003           1730m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BA4  0803 0002               1731m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BA8  67F4                    1732m         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200BAA  13C2 00C00007           1733m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200BB0                          1734m     ENDC
00200BB0                          1735m     
00200BB0                 FALSE    1736m     IFNE DEBUG
00200BB0                          1737m     ENDC
00200BB0                          1738m 
00200BB0                          1739m     ENDM
00200BB0                          1740m                 HEX2BIN D2,D2,A0
00200BB0  41F9 00201B0A           1741m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200BB6  0402 0030               1742m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BBA  C4BC 000000FF           1743m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200BC0  1430 2000               1744m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200BC4                          1745m     ENDM
00200BC4  8E82                    1746                  OR.L D2,D7
00200BC6                          1747              
00200BC6  7400                    1748                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200BC8  1407                    1749                  MOVE.B D7,D2
00200BCA  DC82                    1750                  ADD.L D2,D6
00200BCC                          1751              
00200BCC  32C7                    1752                  MOVE.W D7,(A1)+                 ; store it!
00200BCE                          1753              ENDW
00200BCE  6000 FE70               1754s     BRA _10000002
00200BD2                          1755s _10000003
00200BD2                          1756          
00200BD2                          1757              IF D5 <EQ> #1 THEN
00200BD2  BA7C 0001               1758s     CMP.W   #1,D5
00200BD6  6600 00CE               1759s     BNE _00000003
00200BDA  7E00                    1760                  MOVE.L #0,D7                    ; D7 holds the word
00200BDC                          1761                      
00200BDC                          1762m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200BDC                          1763m WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BDC                          1764m 
00200BDC  1639 00C00003           1765m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200BE2  0803 0000               1766m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200BE6  6700 0010               1767m     BEQ CONTINUE_116                                ; NOTHING, CONTINUE
00200BEA                          1768m  
00200BEA                          1769mm     READ_CHAR D2
00200BEA                 TRUE     1770mm     IFEQ DEBUG
00200BEA  1439 00C00007           1771mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200BF0                          1772mm     ENDC
00200BF0                 FALSE    1773mm     IFNE DEBUG
00200BF0                          1774mm     ENDC
00200BF0                          1775mm      
00200BF0  B43C 001B               1776mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200BF4  6700 F412               1777mm     BEQ START
00200BF8                          1778mm     ENDM
00200BF8                          1779m CONTINUE_116
00200BF8  1639 00C00013           1780m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200BFE  0803 0000               1781m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C02  67D8                    1782m     BEQ WAIT_FOR_READY_116                      ; NOTHING, CHECK AGAIN
00200C04                          1783m     
00200C04  1439 00C00017           1784m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C0A  13C2 00E00001           1785m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C10                          1786m     
00200C10                          1787m     ENDM
00200C10                          1788m                 PRINT_CHAR D2,D3
00200C10                          1789m WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C10                 TRUE     1790m     IFEQ DEBUG
00200C10  1639 00C00003           1791m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C16  0803 0002               1792m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C1A  67F4                    1793m         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200C1C  13C2 00C00007           1794m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C22                          1795m     ENDC
00200C22                          1796m     
00200C22                 FALSE    1797m     IFNE DEBUG
00200C22                          1798m     ENDC
00200C22                          1799m 
00200C22                          1800m     ENDM
00200C22                          1801m                 HEX2BIN D2,D2,A0
00200C22  41F9 00201B0A           1802m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C28  0402 0030               1803m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C2C  C4BC 000000FF           1804m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C32  1430 2000               1805m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C36                          1806m     ENDM
00200C36  8E82                    1807                  OR.L D2,D7
00200C38  E98F                    1808              LSL.L #4,D7
00200C3A                          1809               
00200C3A                          1810m             DOWNLOAD D2,D3                      ; LS 4 bits    
00200C3A                          1811m WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C3A                          1812m 
00200C3A  1639 00C00003           1813m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200C40  0803 0000               1814m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C44  6700 0010               1815m     BEQ CONTINUE_120                                ; NOTHING, CONTINUE
00200C48                          1816m  
00200C48                          1817mm     READ_CHAR D2
00200C48                 TRUE     1818mm     IFEQ DEBUG
00200C48  1439 00C00007           1819mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C4E                          1820mm     ENDC
00200C4E                 FALSE    1821mm     IFNE DEBUG
00200C4E                          1822mm     ENDC
00200C4E                          1823mm      
00200C4E  B43C 001B               1824mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200C52  6700 F3B4               1825mm     BEQ START
00200C56                          1826mm     ENDM
00200C56                          1827m CONTINUE_120
00200C56  1639 00C00013           1828m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200C5C  0803 0000               1829m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C60  67D8                    1830m     BEQ WAIT_FOR_READY_120                      ; NOTHING, CHECK AGAIN
00200C62                          1831m     
00200C62  1439 00C00017           1832m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C68  13C2 00E00001           1833m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C6E                          1834m     
00200C6E                          1835m     ENDM
00200C6E                          1836m             PRINT_CHAR D2,D3
00200C6E                          1837m WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C6E                 TRUE     1838m     IFEQ DEBUG
00200C6E  1639 00C00003           1839m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C74  0803 0002               1840m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C78  67F4                    1841m         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200C7A  13C2 00C00007           1842m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C80                          1843m     ENDC
00200C80                          1844m     
00200C80                 FALSE    1845m     IFNE DEBUG
00200C80                          1846m     ENDC
00200C80                          1847m 
00200C80                          1848m     ENDM
00200C80                          1849m             HEX2BIN D2,D2,A0
00200C80  41F9 00201B0A           1850m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C86  0402 0030               1851m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C8A  C4BC 000000FF           1852m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C90  1430 2000               1853m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C94                          1854m     ENDM
00200C94  8E82                    1855              OR.L D2,D7
00200C96                          1856                          
00200C96  DC87                    1857              ADD.L D7,D6                         ; add into checksum
00200C98                          1858              
00200C98  3611                    1859              MOVE.W (A1),D3                      ; get the current data and replace the top byte
00200C9A  E18F                    1860              LSL.L #8,D7
00200C9C  C6BC 000000FF           1861              AND.L #$00FF,D3
00200CA2  8687                    1862              OR.L D7,D3
00200CA4                          1863  
00200CA4  32C3                    1864              MOVE.W D3,(A1)+                     ; store it!
00200CA6                          1865          ENDI
00200CA6                          1866s _00000003
00200CA6                          1867    
00200CA6                          1868m         PRINT_CRLF D3
00200CA6                          1869mm     PRINT_CHAR #13,D3                           ; CR
00200CA6                          1870mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CA6                 TRUE     1871mm     IFEQ DEBUG
00200CA6  1639 00C00003           1872mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CAC  0803 0002               1873mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CB0  67F4                    1874mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00200CB2  13FC 000D 00C00007      1875mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200CBA                          1876mm     ENDC
00200CBA                          1877mm     
00200CBA                 FALSE    1878mm     IFNE DEBUG
00200CBA                          1879mm     ENDC
00200CBA                          1880mm 
00200CBA                          1881mm     ENDM
00200CBA                          1882mm     PRINT_CHAR #10,D3                           ; LF
00200CBA                          1883mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBA                 TRUE     1884mm     IFEQ DEBUG
00200CBA  1639 00C00003           1885mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CC0  0803 0002               1886mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC4  67F4                    1887mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200CC6  13FC 000A 00C00007      1888mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200CCE                          1889mm     ENDC
00200CCE                          1890mm     
00200CCE                 FALSE    1891mm     IFNE DEBUG
00200CCE                          1892mm     ENDC
00200CCE                          1893mm 
00200CCE                          1894mm     ENDM
00200CCE                          1895m     ENDM
00200CCE  43F9 002004A0           1896          LEA WAIT_FOR_SRECORD,A1                 ; next place to go
00200CD4                          1897        ELSE
00200CD4  6000 0812               1898s     BRA _00000004
00200CD8                          1899s _00000002
00200CD8                          1900              IF.B D7 <EQ> #'2' THEN.L            ; 24 bit address data record
00200CD8  BE3C 0032               1901s     CMP.B   #'2',D7
00200CDC  6600 05BA               1902s     BNE.L   _00000005
00200CE0  7E00                    1903                  MOVE.L #0,D7                    ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200CE2                          1904m                 DOWNLOAD D2,D3                  ; top byte
00200CE2                          1905m WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE2                          1906m 
00200CE2  1639 00C00003           1907m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200CE8  0803 0000               1908m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200CEC  6700 0010               1909m     BEQ CONTINUE_127                                ; NOTHING, CONTINUE
00200CF0                          1910m  
00200CF0                          1911mm     READ_CHAR D2
00200CF0                 TRUE     1912mm     IFEQ DEBUG
00200CF0  1439 00C00007           1913mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200CF6                          1914mm     ENDC
00200CF6                 FALSE    1915mm     IFNE DEBUG
00200CF6                          1916mm     ENDC
00200CF6                          1917mm      
00200CF6  B43C 001B               1918mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFA  6700 F30C               1919mm     BEQ START
00200CFE                          1920mm     ENDM
00200CFE                          1921m CONTINUE_127
00200CFE  1639 00C00013           1922m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D04  0803 0000               1923m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D08  67D8                    1924m     BEQ WAIT_FOR_READY_127                      ; NOTHING, CHECK AGAIN
00200D0A                          1925m     
00200D0A  1439 00C00017           1926m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D10  13C2 00E00001           1927m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D16                          1928m     
00200D16                          1929m     ENDM
00200D16                          1930m                 PRINT_CHAR D2,D3
00200D16                          1931m WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D16                 TRUE     1932m     IFEQ DEBUG
00200D16  1639 00C00003           1933m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D1C  0803 0002               1934m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D20  67F4                    1935m         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200D22  13C2 00C00007           1936m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D28                          1937m     ENDC
00200D28                          1938m     
00200D28                 FALSE    1939m     IFNE DEBUG
00200D28                          1940m     ENDC
00200D28                          1941m 
00200D28                          1942m     ENDM
00200D28                          1943m                 HEX2BIN D2,D2,A0
00200D28  41F9 00201B0A           1944m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D2E  0402 0030               1945m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D32  C4BC 000000FF           1946m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D38  1430 2000               1947m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D3C                          1948m     ENDM
00200D3C  8E82                    1949                  OR.L D2,D7
00200D3E  E98F                    1950                  LSL.L #4,D7
00200D40                          1951m                 DOWNLOAD D2,D3         
00200D40                          1952m WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D40                          1953m 
00200D40  1639 00C00003           1954m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200D46  0803 0000               1955m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D4A  6700 0010               1956m     BEQ CONTINUE_131                                ; NOTHING, CONTINUE
00200D4E                          1957m  
00200D4E                          1958mm     READ_CHAR D2
00200D4E                 TRUE     1959mm     IFEQ DEBUG
00200D4E  1439 00C00007           1960mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D54                          1961mm     ENDC
00200D54                 FALSE    1962mm     IFNE DEBUG
00200D54                          1963mm     ENDC
00200D54                          1964mm      
00200D54  B43C 001B               1965mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D58  6700 F2AE               1966mm     BEQ START
00200D5C                          1967mm     ENDM
00200D5C                          1968m CONTINUE_131
00200D5C  1639 00C00013           1969m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D62  0803 0000               1970m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D66  67D8                    1971m     BEQ WAIT_FOR_READY_131                      ; NOTHING, CHECK AGAIN
00200D68                          1972m     
00200D68  1439 00C00017           1973m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D6E  13C2 00E00001           1974m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D74                          1975m     
00200D74                          1976m     ENDM
00200D74                          1977m                 PRINT_CHAR D2,D3
00200D74                          1978m WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D74                 TRUE     1979m     IFEQ DEBUG
00200D74  1639 00C00003           1980m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D7A  0803 0002               1981m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D7E  67F4                    1982m         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200D80  13C2 00C00007           1983m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D86                          1984m     ENDC
00200D86                          1985m     
00200D86                 FALSE    1986m     IFNE DEBUG
00200D86                          1987m     ENDC
00200D86                          1988m 
00200D86                          1989m     ENDM
00200D86                          1990m                 HEX2BIN D2,D2,A0
00200D86  41F9 00201B0A           1991m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D8C  0402 0030               1992m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D90  C4BC 000000FF           1993m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D96  1430 2000               1994m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D9A                          1995m     ENDM
00200D9A  8E82                    1996                  OR.L D2,D7
00200D9C                          1997                  
00200D9C  DC87                    1998                  ADD.L D7,D6                     ; add top byte of address into checksum
00200D9E                          1999  
00200D9E  E98F                    2000                  LSL.L #4,D7                     ; middle byte
00200DA0                          2001m                 DOWNLOAD D2,D3
00200DA0                          2002m WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA0                          2003m 
00200DA0  1639 00C00003           2004m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200DA6  0803 0000               2005m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DAA  6700 0010               2006m     BEQ CONTINUE_135                                ; NOTHING, CONTINUE
00200DAE                          2007m  
00200DAE                          2008mm     READ_CHAR D2
00200DAE                 TRUE     2009mm     IFEQ DEBUG
00200DAE  1439 00C00007           2010mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DB4                          2011mm     ENDC
00200DB4                 FALSE    2012mm     IFNE DEBUG
00200DB4                          2013mm     ENDC
00200DB4                          2014mm      
00200DB4  B43C 001B               2015mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DB8  6700 F24E               2016mm     BEQ START
00200DBC                          2017mm     ENDM
00200DBC                          2018m CONTINUE_135
00200DBC  1639 00C00013           2019m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200DC2  0803 0000               2020m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DC6  67D8                    2021m     BEQ WAIT_FOR_READY_135                      ; NOTHING, CHECK AGAIN
00200DC8                          2022m     
00200DC8  1439 00C00017           2023m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200DCE  13C2 00E00001           2024m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200DD4                          2025m     
00200DD4                          2026m     ENDM
00200DD4                          2027m                 PRINT_CHAR D2,D3
00200DD4                          2028m WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DD4                 TRUE     2029m     IFEQ DEBUG
00200DD4  1639 00C00003           2030m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DDA  0803 0002               2031m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DDE  67F4                    2032m         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00200DE0  13C2 00C00007           2033m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DE6                          2034m     ENDC
00200DE6                          2035m     
00200DE6                 FALSE    2036m     IFNE DEBUG
00200DE6                          2037m     ENDC
00200DE6                          2038m 
00200DE6                          2039m     ENDM
00200DE6                          2040m                 HEX2BIN D2,D2,A0
00200DE6  41F9 00201B0A           2041m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DEC  0402 0030               2042m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF0  C4BC 000000FF           2043m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DF6  1430 2000               2044m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DFA                          2045m     ENDM
00200DFA  8E82                    2046                  OR.L D2,D7
00200DFC  E98F                    2047                  LSL.L #4,D7        
00200DFE                          2048m                 DOWNLOAD D2,D3
00200DFE                          2049m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DFE                          2050m 
00200DFE  1639 00C00003           2051m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200E04  0803 0000               2052m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E08  6700 0010               2053m     BEQ CONTINUE_139                                ; NOTHING, CONTINUE
00200E0C                          2054m  
00200E0C                          2055mm     READ_CHAR D2
00200E0C                 TRUE     2056mm     IFEQ DEBUG
00200E0C  1439 00C00007           2057mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E12                          2058mm     ENDC
00200E12                 FALSE    2059mm     IFNE DEBUG
00200E12                          2060mm     ENDC
00200E12                          2061mm      
00200E12  B43C 001B               2062mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E16  6700 F1F0               2063mm     BEQ START
00200E1A                          2064mm     ENDM
00200E1A                          2065m CONTINUE_139
00200E1A  1639 00C00013           2066m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200E20  0803 0000               2067m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E24  67D8                    2068m     BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00200E26                          2069m     
00200E26  1439 00C00017           2070m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200E2C  13C2 00E00001           2071m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200E32                          2072m     
00200E32                          2073m     ENDM
00200E32                          2074m                 PRINT_CHAR D2,D3
00200E32                          2075m WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E32                 TRUE     2076m     IFEQ DEBUG
00200E32  1639 00C00003           2077m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E38  0803 0002               2078m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E3C  67F4                    2079m         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200E3E  13C2 00C00007           2080m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200E44                          2081m     ENDC
00200E44                          2082m     
00200E44                 FALSE    2083m     IFNE DEBUG
00200E44                          2084m     ENDC
00200E44                          2085m 
00200E44                          2086m     ENDM
00200E44                          2087m                 HEX2BIN D2,D2,A0
00200E44  41F9 00201B0A           2088m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200E4A  0402 0030               2089m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200E4E  C4BC 000000FF           2090m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200E54  1430 2000               2091m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200E58                          2092m     ENDM
00200E58  8E82                    2093                  OR.L D2,D7
00200E5A                          2094                  
00200E5A  7400                    2095                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
00200E5C  1407                    2096                  MOVE.B D7,D2
00200E5E  DC82                    2097                  ADD.L D2,D6
00200E60                          2098            
00200E60  E98F                    2099                  LSL.L #4,D7                     ; bottom byte
00200E62                          2100m                 DOWNLOAD D2,D3
00200E62                          2101m WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                          2102m 
00200E62  1639 00C00003           2103m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200E68  0803 0000               2104m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E6C  6700 0010               2105m     BEQ CONTINUE_143                                ; NOTHING, CONTINUE
00200E70                          2106m  
00200E70                          2107mm     READ_CHAR D2
00200E70                 TRUE     2108mm     IFEQ DEBUG
00200E70  1439 00C00007           2109mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E76                          2110mm     ENDC
00200E76                 FALSE    2111mm     IFNE DEBUG
00200E76                          2112mm     ENDC
00200E76                          2113mm      
00200E76  B43C 001B               2114mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E7A  6700 F18C               2115mm     BEQ START
00200E7E                          2116mm     ENDM
00200E7E                          2117m CONTINUE_143
00200E7E  1639 00C00013           2118m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200E84  0803 0000               2119m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E88  67D8                    2120m     BEQ WAIT_FOR_READY_143                      ; NOTHING, CHECK AGAIN
00200E8A                          2121m     
00200E8A  1439 00C00017           2122m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200E90  13C2 00E00001           2123m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200E96                          2124m     
00200E96                          2125m     ENDM
00200E96                          2126m                 PRINT_CHAR D2,D3
00200E96                          2127m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E96                 TRUE     2128m     IFEQ DEBUG
00200E96  1639 00C00003           2129m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E9C  0803 0002               2130m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EA0  67F4                    2131m         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00200EA2  13C2 00C00007           2132m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200EA8                          2133m     ENDC
00200EA8                          2134m     
00200EA8                 FALSE    2135m     IFNE DEBUG
00200EA8                          2136m     ENDC
00200EA8                          2137m 
00200EA8                          2138m     ENDM
00200EA8                          2139m                 HEX2BIN D2,D2,A0
00200EA8  41F9 00201B0A           2140m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200EAE  0402 0030               2141m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EB2  C4BC 000000FF           2142m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EB8  1430 2000               2143m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EBC                          2144m     ENDM
00200EBC  8E82                    2145                  OR.L D2,D7
00200EBE  E98F                    2146                  LSL.L #4,D7        
00200EC0                          2147m                 DOWNLOAD D2,D3
00200EC0                          2148m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EC0                          2149m 
00200EC0  1639 00C00003           2150m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200EC6  0803 0000               2151m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200ECA  6700 0010               2152m     BEQ CONTINUE_147                                ; NOTHING, CONTINUE
00200ECE                          2153m  
00200ECE                          2154mm     READ_CHAR D2
00200ECE                 TRUE     2155mm     IFEQ DEBUG
00200ECE  1439 00C00007           2156mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200ED4                          2157mm     ENDC
00200ED4                 FALSE    2158mm     IFNE DEBUG
00200ED4                          2159mm     ENDC
00200ED4                          2160mm      
00200ED4  B43C 001B               2161mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200ED8  6700 F12E               2162mm     BEQ START
00200EDC                          2163mm     ENDM
00200EDC                          2164m CONTINUE_147
00200EDC  1639 00C00013           2165m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200EE2  0803 0000               2166m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200EE6  67D8                    2167m     BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00200EE8                          2168m     
00200EE8  1439 00C00017           2169m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200EEE  13C2 00E00001           2170m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200EF4                          2171m     
00200EF4                          2172m     ENDM
00200EF4                          2173m                 PRINT_CHAR D2,D3
00200EF4                          2174m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EF4                 TRUE     2175m     IFEQ DEBUG
00200EF4  1639 00C00003           2176m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200EFA  0803 0002               2177m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EFE  67F4                    2178m         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00200F00  13C2 00C00007           2179m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F06                          2180m     ENDC
00200F06                          2181m     
00200F06                 FALSE    2182m     IFNE DEBUG
00200F06                          2183m     ENDC
00200F06                          2184m 
00200F06                          2185m     ENDM
00200F06                          2186m                 HEX2BIN D2,D2,A0
00200F06  41F9 00201B0A           2187m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F0C  0402 0030               2188m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F10  C4BC 000000FF           2189m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F16  1430 2000               2190m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F1A                          2191m     ENDM
00200F1A  8E82                    2192                  OR.L D2,D7
00200F1C                          2193          
00200F1C  7400                    2194                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200F1E  1407                    2195                  MOVE.B D7,D2
00200F20  DC82                    2196                  ADD.L D2,D6
00200F22                          2197                  
00200F22  2247                    2198                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200F24  D3CB                    2199                  ADD.L A3,A1                     ; add in the offset
00200F26                          2200                    
00200F26  0807 0000               2201                  BTST #0,D7                      ; deal with odd addresses
00200F2A                          2202  
00200F2A  2247                    2203                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200F2C  6700 00D0               2204                  BEQ EVEN2
00200F30                          2205                          
00200F30  5385                    2206                  SUB.L #1,D5
00200F32  5389                    2207                  SUB.L #1,A1
00200F34                          2208                  
00200F34  7E00                    2209                  MOVE.L #0,D7
00200F36                          2210m                 DOWNLOAD D2,D3                  ; MS 4 bits
00200F36                          2211m WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F36                          2212m 
00200F36  1639 00C00003           2213m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200F3C  0803 0000               2214m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F40  6700 0010               2215m     BEQ CONTINUE_151                                ; NOTHING, CONTINUE
00200F44                          2216m  
00200F44                          2217mm     READ_CHAR D2
00200F44                 TRUE     2218mm     IFEQ DEBUG
00200F44  1439 00C00007           2219mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200F4A                          2220mm     ENDC
00200F4A                 FALSE    2221mm     IFNE DEBUG
00200F4A                          2222mm     ENDC
00200F4A                          2223mm      
00200F4A  B43C 001B               2224mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200F4E  6700 F0B8               2225mm     BEQ START
00200F52                          2226mm     ENDM
00200F52                          2227m CONTINUE_151
00200F52  1639 00C00013           2228m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200F58  0803 0000               2229m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F5C  67D8                    2230m     BEQ WAIT_FOR_READY_151                      ; NOTHING, CHECK AGAIN
00200F5E                          2231m     
00200F5E  1439 00C00017           2232m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200F64  13C2 00E00001           2233m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200F6A                          2234m     
00200F6A                          2235m     ENDM
00200F6A                          2236m                 PRINT_CHAR D2,D3
00200F6A                          2237m WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F6A                 TRUE     2238m     IFEQ DEBUG
00200F6A  1639 00C00003           2239m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F70  0803 0002               2240m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F74  67F4                    2241m         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00200F76  13C2 00C00007           2242m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F7C                          2243m     ENDC
00200F7C                          2244m     
00200F7C                 FALSE    2245m     IFNE DEBUG
00200F7C                          2246m     ENDC
00200F7C                          2247m 
00200F7C                          2248m     ENDM
00200F7C                          2249m                 HEX2BIN D2,D2,A0
00200F7C  41F9 00201B0A           2250m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F82  0402 0030               2251m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F86  C4BC 000000FF           2252m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F8C  1430 2000               2253m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F90                          2254m     ENDM
00200F90  8E82                    2255                  OR.L D2,D7
00200F92  E98F                    2256                  LSL.L #4,D7
00200F94                          2257                       
00200F94                          2258m                 DOWNLOAD D2,D3                  ; LS 4 bits    
00200F94                          2259m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                          2260m 
00200F94  1639 00C00003           2261m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200F9A  0803 0000               2262m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F9E  6700 0010               2263m     BEQ CONTINUE_155                                ; NOTHING, CONTINUE
00200FA2                          2264m  
00200FA2                          2265mm     READ_CHAR D2
00200FA2                 TRUE     2266mm     IFEQ DEBUG
00200FA2  1439 00C00007           2267mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200FA8                          2268mm     ENDC
00200FA8                 FALSE    2269mm     IFNE DEBUG
00200FA8                          2270mm     ENDC
00200FA8                          2271mm      
00200FA8  B43C 001B               2272mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200FAC  6700 F05A               2273mm     BEQ START
00200FB0                          2274mm     ENDM
00200FB0                          2275m CONTINUE_155
00200FB0  1639 00C00013           2276m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200FB6  0803 0000               2277m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200FBA  67D8                    2278m     BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00200FBC                          2279m     
00200FBC  1439 00C00017           2280m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200FC2  13C2 00E00001           2281m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200FC8                          2282m     
00200FC8                          2283m     ENDM
00200FC8                          2284m                 PRINT_CHAR D2,D3
00200FC8                          2285m WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FC8                 TRUE     2286m     IFEQ DEBUG
00200FC8  1639 00C00003           2287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FCE  0803 0002               2288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FD2  67F4                    2289m         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200FD4  13C2 00C00007           2290m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200FDA                          2291m     ENDC
00200FDA                          2292m     
00200FDA                 FALSE    2293m     IFNE DEBUG
00200FDA                          2294m     ENDC
00200FDA                          2295m 
00200FDA                          2296m     ENDM
00200FDA                          2297m                 HEX2BIN D2,D2,A0
00200FDA  41F9 00201B0A           2298m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200FE0  0402 0030               2299m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200FE4  C4BC 000000FF           2300m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200FEA  1430 2000               2301m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200FEE                          2302m     ENDM
00200FEE  8E82                    2303                  OR.L D2,D7
00200FF0                          2304                          
00200FF0  DC87                    2305                  ADD.L D7,D6                     ; add into checksum
00200FF2                          2306                                
00200FF2  3611                    2307                  MOVE.W (A1),D3                  ; get the current data and replace the bottom byte
00200FF4                          2308                  
00200FF4  0243 FF00               2309                  ANDI.W #$FF00,D3
00200FF8  8647                    2310                  OR.W D7,D3
00200FFA                          2311                  
00200FFA  3283                    2312                  MOVE.W D3,(A1)                  ; store it!
00200FFC  5489                    2313                  ADD.L #2,A1
00200FFE                          2314  EVEN2
00200FFE  5985                    2315                  SUB.L #4,D5                     ; subtract four bytes for 24 bit address and 1 byte checksum
00201000                          2316                  WHILE.L D5 <GE> #2 DO           ; read the data bytes
00201000                          2317s _10000004
00201000  BABC 00000002           2318s     CMP.L   #2,D5
00201006  6D00 018A               2319s     BLT _10000005
0020100A  5585                    2320                      SUB.L #2,D5
0020100C                          2321                      
0020100C  7E00                    2322                      MOVE.L #0,D7                ; D7 holds the word
0020100E                          2323                      
0020100E                          2324m                     DOWNLOAD D2,D3              ; MS 4 bits
0020100E                          2325m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020100E                          2326m 
0020100E  1639 00C00003           2327m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201014  0803 0000               2328m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201018  6700 0010               2329m     BEQ CONTINUE_159                                ; NOTHING, CONTINUE
0020101C                          2330m  
0020101C                          2331mm     READ_CHAR D2
0020101C                 TRUE     2332mm     IFEQ DEBUG
0020101C  1439 00C00007           2333mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201022                          2334mm     ENDC
00201022                 FALSE    2335mm     IFNE DEBUG
00201022                          2336mm     ENDC
00201022                          2337mm      
00201022  B43C 001B               2338mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201026  6700 EFE0               2339mm     BEQ START
0020102A                          2340mm     ENDM
0020102A                          2341m CONTINUE_159
0020102A  1639 00C00013           2342m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201030  0803 0000               2343m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201034  67D8                    2344m     BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00201036                          2345m     
00201036  1439 00C00017           2346m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020103C  13C2 00E00001           2347m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201042                          2348m     
00201042                          2349m     ENDM
00201042                          2350m                     PRINT_CHAR D2,D3
00201042                          2351m WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201042                 TRUE     2352m     IFEQ DEBUG
00201042  1639 00C00003           2353m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201048  0803 0002               2354m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020104C  67F4                    2355m         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
0020104E  13C2 00C00007           2356m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201054                          2357m     ENDC
00201054                          2358m     
00201054                 FALSE    2359m     IFNE DEBUG
00201054                          2360m     ENDC
00201054                          2361m 
00201054                          2362m     ENDM
00201054                          2363m                     HEX2BIN D2,D2,A0
00201054  41F9 00201B0A           2364m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020105A  0402 0030               2365m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020105E  C4BC 000000FF           2366m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201064  1430 2000               2367m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201068                          2368m     ENDM
00201068  8E82                    2369                      OR.L D2,D7
0020106A  E98F                    2370                      LSL.L #4,D7
0020106C                          2371                       
0020106C                          2372m                     DOWNLOAD D2,D3              ; LS 4 bits    
0020106C                          2373m WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020106C                          2374m 
0020106C  1639 00C00003           2375m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201072  0803 0000               2376m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201076  6700 0010               2377m     BEQ CONTINUE_163                                ; NOTHING, CONTINUE
0020107A                          2378m  
0020107A                          2379mm     READ_CHAR D2
0020107A                 TRUE     2380mm     IFEQ DEBUG
0020107A  1439 00C00007           2381mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201080                          2382mm     ENDC
00201080                 FALSE    2383mm     IFNE DEBUG
00201080                          2384mm     ENDC
00201080                          2385mm      
00201080  B43C 001B               2386mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201084  6700 EF82               2387mm     BEQ START
00201088                          2388mm     ENDM
00201088                          2389m CONTINUE_163
00201088  1639 00C00013           2390m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020108E  0803 0000               2391m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201092  67D8                    2392m     BEQ WAIT_FOR_READY_163                      ; NOTHING, CHECK AGAIN
00201094                          2393m     
00201094  1439 00C00017           2394m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020109A  13C2 00E00001           2395m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002010A0                          2396m     
002010A0                          2397m     ENDM
002010A0                          2398m                     PRINT_CHAR D2,D3
002010A0                          2399m WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A0                 TRUE     2400m     IFEQ DEBUG
002010A0  1639 00C00003           2401m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010A6  0803 0002               2402m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010AA  67F4                    2403m         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
002010AC  13C2 00C00007           2404m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002010B2                          2405m     ENDC
002010B2                          2406m     
002010B2                 FALSE    2407m     IFNE DEBUG
002010B2                          2408m     ENDC
002010B2                          2409m 
002010B2                          2410m     ENDM
002010B2                          2411m                     HEX2BIN D2,D2,A0
002010B2  41F9 00201B0A           2412m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002010B8  0402 0030               2413m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002010BC  C4BC 000000FF           2414m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002010C2  1430 2000               2415m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002010C6                          2416m     ENDM
002010C6  8E82                    2417                      OR.L D2,D7
002010C8                          2418                          
002010C8  DC87                    2419                      ADD.L D7,D6                 ; add into checksum
002010CA                          2420                      
002010CA  E98F                    2421                      LSL.L #4,D7
002010CC                          2422m                     DOWNLOAD D2,D3              ; MS 4 bits
002010CC                          2423m WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010CC                          2424m 
002010CC  1639 00C00003           2425m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002010D2  0803 0000               2426m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002010D6  6700 0010               2427m     BEQ CONTINUE_167                                ; NOTHING, CONTINUE
002010DA                          2428m  
002010DA                          2429mm     READ_CHAR D2
002010DA                 TRUE     2430mm     IFEQ DEBUG
002010DA  1439 00C00007           2431mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002010E0                          2432mm     ENDC
002010E0                 FALSE    2433mm     IFNE DEBUG
002010E0                          2434mm     ENDC
002010E0                          2435mm      
002010E0  B43C 001B               2436mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002010E4  6700 EF22               2437mm     BEQ START
002010E8                          2438mm     ENDM
002010E8                          2439m CONTINUE_167
002010E8  1639 00C00013           2440m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002010EE  0803 0000               2441m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002010F2  67D8                    2442m     BEQ WAIT_FOR_READY_167                      ; NOTHING, CHECK AGAIN
002010F4                          2443m     
002010F4  1439 00C00017           2444m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002010FA  13C2 00E00001           2445m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201100                          2446m     
00201100                          2447m     ENDM
00201100                          2448m                     PRINT_CHAR D2,D3
00201100                          2449m WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201100                 TRUE     2450m     IFEQ DEBUG
00201100  1639 00C00003           2451m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201106  0803 0002               2452m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020110A  67F4                    2453m         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
0020110C  13C2 00C00007           2454m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201112                          2455m     ENDC
00201112                          2456m     
00201112                 FALSE    2457m     IFNE DEBUG
00201112                          2458m     ENDC
00201112                          2459m 
00201112                          2460m     ENDM
00201112                          2461m                     HEX2BIN D2,D2,A0
00201112  41F9 00201B0A           2462m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201118  0402 0030               2463m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020111C  C4BC 000000FF           2464m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201122  1430 2000               2465m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201126                          2466m     ENDM
00201126  8E82                    2467                      OR.L D2,D7
00201128                          2468                       
00201128  E98F                    2469                      LSL.L #4,D7
0020112A                          2470m                     DOWNLOAD D2,D3              ; LS 4 bits    
0020112A                          2471m WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020112A                          2472m 
0020112A  1639 00C00003           2473m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201130  0803 0000               2474m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201134  6700 0010               2475m     BEQ CONTINUE_171                                ; NOTHING, CONTINUE
00201138                          2476m  
00201138                          2477mm     READ_CHAR D2
00201138                 TRUE     2478mm     IFEQ DEBUG
00201138  1439 00C00007           2479mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020113E                          2480mm     ENDC
0020113E                 FALSE    2481mm     IFNE DEBUG
0020113E                          2482mm     ENDC
0020113E                          2483mm      
0020113E  B43C 001B               2484mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201142  6700 EEC4               2485mm     BEQ START
00201146                          2486mm     ENDM
00201146                          2487m CONTINUE_171
00201146  1639 00C00013           2488m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020114C  0803 0000               2489m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201150  67D8                    2490m     BEQ WAIT_FOR_READY_171                      ; NOTHING, CHECK AGAIN
00201152                          2491m     
00201152  1439 00C00017           2492m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201158  13C2 00E00001           2493m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020115E                          2494m     
0020115E                          2495m     ENDM
0020115E                          2496m                     PRINT_CHAR D2,D3
0020115E                          2497m WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020115E                 TRUE     2498m     IFEQ DEBUG
0020115E  1639 00C00003           2499m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201164  0803 0002               2500m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201168  67F4                    2501m         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
0020116A  13C2 00C00007           2502m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201170                          2503m     ENDC
00201170                          2504m     
00201170                 FALSE    2505m     IFNE DEBUG
00201170                          2506m     ENDC
00201170                          2507m 
00201170                          2508m     ENDM
00201170                          2509m                     HEX2BIN D2,D2,A0
00201170  41F9 00201B0A           2510m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201176  0402 0030               2511m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020117A  C4BC 000000FF           2512m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201180  1430 2000               2513m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201184                          2514m     ENDM
00201184  8E82                    2515                      OR.L D2,D7
00201186                          2516                      
00201186  7400                    2517                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00201188  1407                    2518                      MOVE.B D7,D2
0020118A  DC82                    2519                      ADD.L D2,D6
0020118C                          2520                      
0020118C  32C7                    2521                      MOVE.W D7,(A1)+             ; store it!
0020118E                          2522              
0020118E                          2523                  ENDW
0020118E  6000 FE70               2524s     BRA _10000004
00201192                          2525s _10000005
00201192                          2526              
00201192                          2527                  IF D5 <EQ> #1 THEN
00201192  BA7C 0001               2528s     CMP.W   #1,D5
00201196  6600 00CE               2529s     BNE _00000006
0020119A  7E00                    2530                      MOVE.L #0,D7                ; D7 holds the word
0020119C                          2531                              
0020119C                          2532m                     DOWNLOAD D2,D3              ; MS 4 bits
0020119C                          2533m WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020119C                          2534m 
0020119C  1639 00C00003           2535m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002011A2  0803 0000               2536m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002011A6  6700 0010               2537m     BEQ CONTINUE_175                                ; NOTHING, CONTINUE
002011AA                          2538m  
002011AA                          2539mm     READ_CHAR D2
002011AA                 TRUE     2540mm     IFEQ DEBUG
002011AA  1439 00C00007           2541mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002011B0                          2542mm     ENDC
002011B0                 FALSE    2543mm     IFNE DEBUG
002011B0                          2544mm     ENDC
002011B0                          2545mm      
002011B0  B43C 001B               2546mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002011B4  6700 EE52               2547mm     BEQ START
002011B8                          2548mm     ENDM
002011B8                          2549m CONTINUE_175
002011B8  1639 00C00013           2550m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002011BE  0803 0000               2551m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002011C2  67D8                    2552m     BEQ WAIT_FOR_READY_175                      ; NOTHING, CHECK AGAIN
002011C4                          2553m     
002011C4  1439 00C00017           2554m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002011CA  13C2 00E00001           2555m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002011D0                          2556m     
002011D0                          2557m     ENDM
002011D0                          2558m                     PRINT_CHAR D2,D3
002011D0                          2559m WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011D0                 TRUE     2560m     IFEQ DEBUG
002011D0  1639 00C00003           2561m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011D6  0803 0002               2562m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011DA  67F4                    2563m         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
002011DC  13C2 00C00007           2564m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002011E2                          2565m     ENDC
002011E2                          2566m     
002011E2                 FALSE    2567m     IFNE DEBUG
002011E2                          2568m     ENDC
002011E2                          2569m 
002011E2                          2570m     ENDM
002011E2                          2571m                     HEX2BIN D2,D2,A0
002011E2  41F9 00201B0A           2572m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002011E8  0402 0030               2573m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002011EC  C4BC 000000FF           2574m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002011F2  1430 2000               2575m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002011F6                          2576m     ENDM
002011F6  8E82                    2577                      OR.L D2,D7
002011F8  E98F                    2578                      LSL.L #4,D7
002011FA                          2579                       
002011FA                          2580m                     DOWNLOAD D2,D3              ; LS 4 bits    
002011FA                          2581m WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011FA                          2582m 
002011FA  1639 00C00003           2583m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201200  0803 0000               2584m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201204  6700 0010               2585m     BEQ CONTINUE_179                                ; NOTHING, CONTINUE
00201208                          2586m  
00201208                          2587mm     READ_CHAR D2
00201208                 TRUE     2588mm     IFEQ DEBUG
00201208  1439 00C00007           2589mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020120E                          2590mm     ENDC
0020120E                 FALSE    2591mm     IFNE DEBUG
0020120E                          2592mm     ENDC
0020120E                          2593mm      
0020120E  B43C 001B               2594mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201212  6700 EDF4               2595mm     BEQ START
00201216                          2596mm     ENDM
00201216                          2597m CONTINUE_179
00201216  1639 00C00013           2598m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020121C  0803 0000               2599m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201220  67D8                    2600m     BEQ WAIT_FOR_READY_179                      ; NOTHING, CHECK AGAIN
00201222                          2601m     
00201222  1439 00C00017           2602m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201228  13C2 00E00001           2603m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020122E                          2604m     
0020122E                          2605m     ENDM
0020122E                          2606m                     PRINT_CHAR D2,D3
0020122E                          2607m WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122E                 TRUE     2608m     IFEQ DEBUG
0020122E  1639 00C00003           2609m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201234  0803 0002               2610m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201238  67F4                    2611m         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
0020123A  13C2 00C00007           2612m         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201240                          2613m     ENDC
00201240                          2614m     
00201240                 FALSE    2615m     IFNE DEBUG
00201240                          2616m     ENDC
00201240                          2617m 
00201240                          2618m     ENDM
00201240                          2619m                     HEX2BIN D2,D2,A0
00201240  41F9 00201B0A           2620m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201246  0402 0030               2621m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020124A  C4BC 000000FF           2622m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201250  1430 2000               2623m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201254                          2624m     ENDM
00201254  8E82                    2625                      OR.L D2,D7
00201256                          2626                                  
00201256  DC87                    2627                      ADD.L D7,D6                 ; add into checksum
00201258                          2628                      
00201258  3611                    2629                      MOVE.W (A1),D3              ; get the current data and replace the top byte
0020125A  E18F                    2630                      LSL.L #8,D7
0020125C  C6BC 000000FF           2631                      AND.L #$00FF,D3
00201262  8687                    2632                      OR.L D7,D3
00201264                          2633  
00201264  32C3                    2634                      MOVE.W D3,(A1)+             ; store it!
00201266                          2635                  ENDI
00201266                          2636s _00000006
00201266                          2637m                 PRINT_CRLF D3
00201266                          2638mm     PRINT_CHAR #13,D3                           ; CR
00201266                          2639mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201266                 TRUE     2640mm     IFEQ DEBUG
00201266  1639 00C00003           2641mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020126C  0803 0002               2642mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201270  67F4                    2643mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00201272  13FC 000D 00C00007      2644mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020127A                          2645mm     ENDC
0020127A                          2646mm     
0020127A                 FALSE    2647mm     IFNE DEBUG
0020127A                          2648mm     ENDC
0020127A                          2649mm 
0020127A                          2650mm     ENDM
0020127A                          2651mm     PRINT_CHAR #10,D3                           ; LF
0020127A                          2652mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020127A                 TRUE     2653mm     IFEQ DEBUG
0020127A  1639 00C00003           2654mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201280  0803 0002               2655mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201284  67F4                    2656mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00201286  13FC 000A 00C00007      2657mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020128E                          2658mm     ENDC
0020128E                          2659mm     
0020128E                 FALSE    2660mm     IFNE DEBUG
0020128E                          2661mm     ENDC
0020128E                          2662mm 
0020128E                          2663mm     ENDM
0020128E                          2664m     ENDM
0020128E  43F9 002004A0           2665                  LEA WAIT_FOR_SRECORD,A1         ; next place to go
00201294                          2666              ELSE
00201294  6000 0252               2667s     BRA _00000007
00201298                          2668s _00000005
00201298                          2669                  IF.B D7 <EQ> #'8' THEN.L        ; termination record, exit
00201298  BE3C 0038               2670s     CMP.B   #'8',D7
0020129C  6600 01E4               2671s     BNE.L   _00000008
002012A0  7E00                    2672                      MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002012A2                          2673m                     DOWNLOAD D2,D3              ; top byte
002012A2                          2674m WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012A2                          2675m 
002012A2  1639 00C00003           2676m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002012A8  0803 0000               2677m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012AC  6700 0010               2678m     BEQ CONTINUE_186                                ; NOTHING, CONTINUE
002012B0                          2679m  
002012B0                          2680mm     READ_CHAR D2
002012B0                 TRUE     2681mm     IFEQ DEBUG
002012B0  1439 00C00007           2682mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002012B6                          2683mm     ENDC
002012B6                 FALSE    2684mm     IFNE DEBUG
002012B6                          2685mm     ENDC
002012B6                          2686mm      
002012B6  B43C 001B               2687mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002012BA  6700 ED4C               2688mm     BEQ START
002012BE                          2689mm     ENDM
002012BE                          2690m CONTINUE_186
002012BE  1639 00C00013           2691m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002012C4  0803 0000               2692m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012C8  67D8                    2693m     BEQ WAIT_FOR_READY_186                      ; NOTHING, CHECK AGAIN
002012CA                          2694m     
002012CA  1439 00C00017           2695m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002012D0  13C2 00E00001           2696m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002012D6                          2697m     
002012D6                          2698m     ENDM
002012D6                          2699m                     HEX2BIN D2,D2,A0
002012D6  41F9 00201B0A           2700m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002012DC  0402 0030               2701m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012E0  C4BC 000000FF           2702m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002012E6  1430 2000               2703m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002012EA                          2704m     ENDM
002012EA  8E82                    2705                      OR.L D2,D7
002012EC  E98F                    2706                      LSL.L #4,D7
002012EE                          2707m                     DOWNLOAD D2,D3         
002012EE                          2708m WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012EE                          2709m 
002012EE  1639 00C00003           2710m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002012F4  0803 0000               2711m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002012F8  6700 0010               2712m     BEQ CONTINUE_189                                ; NOTHING, CONTINUE
002012FC                          2713m  
002012FC                          2714mm     READ_CHAR D2
002012FC                 TRUE     2715mm     IFEQ DEBUG
002012FC  1439 00C00007           2716mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201302                          2717mm     ENDC
00201302                 FALSE    2718mm     IFNE DEBUG
00201302                          2719mm     ENDC
00201302                          2720mm      
00201302  B43C 001B               2721mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201306  6700 ED00               2722mm     BEQ START
0020130A                          2723mm     ENDM
0020130A                          2724m CONTINUE_189
0020130A  1639 00C00013           2725m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201310  0803 0000               2726m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201314  67D8                    2727m     BEQ WAIT_FOR_READY_189                      ; NOTHING, CHECK AGAIN
00201316                          2728m     
00201316  1439 00C00017           2729m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020131C  13C2 00E00001           2730m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201322                          2731m     
00201322                          2732m     ENDM
00201322                          2733m                     HEX2BIN D2,D2,A0
00201322  41F9 00201B0A           2734m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201328  0402 0030               2735m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020132C  C4BC 000000FF           2736m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201332  1430 2000               2737m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201336                          2738m     ENDM
00201336  8E82                    2739                      OR.L D2,D7
00201338                          2740                  
00201338  DC87                    2741                      ADD.L D7,D6                 ; add top byte of address into checksum
0020133A                          2742  
0020133A  E98F                    2743                      LSL.L #4,D7                 ; middle byte
0020133C                          2744m                     DOWNLOAD D2,D3
0020133C                          2745m WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133C                          2746m 
0020133C  1639 00C00003           2747m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201342  0803 0000               2748m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201346  6700 0010               2749m     BEQ CONTINUE_192                                ; NOTHING, CONTINUE
0020134A                          2750m  
0020134A                          2751mm     READ_CHAR D2
0020134A                 TRUE     2752mm     IFEQ DEBUG
0020134A  1439 00C00007           2753mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201350                          2754mm     ENDC
00201350                 FALSE    2755mm     IFNE DEBUG
00201350                          2756mm     ENDC
00201350                          2757mm      
00201350  B43C 001B               2758mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201354  6700 ECB2               2759mm     BEQ START
00201358                          2760mm     ENDM
00201358                          2761m CONTINUE_192
00201358  1639 00C00013           2762m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020135E  0803 0000               2763m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201362  67D8                    2764m     BEQ WAIT_FOR_READY_192                      ; NOTHING, CHECK AGAIN
00201364                          2765m     
00201364  1439 00C00017           2766m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020136A  13C2 00E00001           2767m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201370                          2768m     
00201370                          2769m     ENDM
00201370                          2770m                     HEX2BIN D2,D2,A0
00201370  41F9 00201B0A           2771m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201376  0402 0030               2772m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020137A  C4BC 000000FF           2773m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201380  1430 2000               2774m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201384                          2775m     ENDM
00201384  8E82                    2776                      OR.L D2,D7
00201386  E98F                    2777                      LSL.L #4,D7        
00201388                          2778m                     DOWNLOAD D2,D3
00201388                          2779m WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201388                          2780m 
00201388  1639 00C00003           2781m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020138E  0803 0000               2782m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201392  6700 0010               2783m     BEQ CONTINUE_195                                ; NOTHING, CONTINUE
00201396                          2784m  
00201396                          2785mm     READ_CHAR D2
00201396                 TRUE     2786mm     IFEQ DEBUG
00201396  1439 00C00007           2787mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020139C                          2788mm     ENDC
0020139C                 FALSE    2789mm     IFNE DEBUG
0020139C                          2790mm     ENDC
0020139C                          2791mm      
0020139C  B43C 001B               2792mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002013A0  6700 EC66               2793mm     BEQ START
002013A4                          2794mm     ENDM
002013A4                          2795m CONTINUE_195
002013A4  1639 00C00013           2796m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002013AA  0803 0000               2797m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002013AE  67D8                    2798m     BEQ WAIT_FOR_READY_195                      ; NOTHING, CHECK AGAIN
002013B0                          2799m     
002013B0  1439 00C00017           2800m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002013B6  13C2 00E00001           2801m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002013BC                          2802m     
002013BC                          2803m     ENDM
002013BC                          2804m                     HEX2BIN D2,D2,A0
002013BC  41F9 00201B0A           2805m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002013C2  0402 0030               2806m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013C6  C4BC 000000FF           2807m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002013CC  1430 2000               2808m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002013D0                          2809m     ENDM
002013D0  8E82                    2810                      OR.L D2,D7
002013D2                          2811          
002013D2  7400                    2812                      MOVE.L #0,D2                ; rextract middle byte of address and add into checksum
002013D4  1407                    2813                      MOVE.B D7,D2
002013D6  DC82                    2814                      ADD.L D2,D6
002013D8                          2815                    
002013D8  E98F                    2816                      LSL.L #4,D7                 ; bottom byte
002013DA                          2817m                     DOWNLOAD D2,D3
002013DA                          2818m WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002013DA                          2819m 
002013DA  1639 00C00003           2820m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002013E0  0803 0000               2821m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002013E4  6700 0010               2822m     BEQ CONTINUE_198                                ; NOTHING, CONTINUE
002013E8                          2823m  
002013E8                          2824mm     READ_CHAR D2
002013E8                 TRUE     2825mm     IFEQ DEBUG
002013E8  1439 00C00007           2826mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002013EE                          2827mm     ENDC
002013EE                 FALSE    2828mm     IFNE DEBUG
002013EE                          2829mm     ENDC
002013EE                          2830mm      
002013EE  B43C 001B               2831mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002013F2  6700 EC14               2832mm     BEQ START
002013F6                          2833mm     ENDM
002013F6                          2834m CONTINUE_198
002013F6  1639 00C00013           2835m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002013FC  0803 0000               2836m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201400  67D8                    2837m     BEQ WAIT_FOR_READY_198                      ; NOTHING, CHECK AGAIN
00201402                          2838m     
00201402  1439 00C00017           2839m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201408  13C2 00E00001           2840m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020140E                          2841m     
0020140E                          2842m     ENDM
0020140E                          2843m                     HEX2BIN D2,D2,A0
0020140E  41F9 00201B0A           2844m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201414  0402 0030               2845m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201418  C4BC 000000FF           2846m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020141E  1430 2000               2847m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201422                          2848m     ENDM
00201422  8E82                    2849                      OR.L D2,D7
00201424  E98F                    2850                      LSL.L #4,D7        
00201426                          2851m                     DOWNLOAD D2,D3
00201426                          2852m WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201426                          2853m 
00201426  1639 00C00003           2854m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020142C  0803 0000               2855m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201430  6700 0010               2856m     BEQ CONTINUE_201                                ; NOTHING, CONTINUE
00201434                          2857m  
00201434                          2858mm     READ_CHAR D2
00201434                 TRUE     2859mm     IFEQ DEBUG
00201434  1439 00C00007           2860mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020143A                          2861mm     ENDC
0020143A                 FALSE    2862mm     IFNE DEBUG
0020143A                          2863mm     ENDC
0020143A                          2864mm      
0020143A  B43C 001B               2865mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020143E  6700 EBC8               2866mm     BEQ START
00201442                          2867mm     ENDM
00201442                          2868m CONTINUE_201
00201442  1639 00C00013           2869m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201448  0803 0000               2870m     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020144C  67D8                    2871m     BEQ WAIT_FOR_READY_201                      ; NOTHING, CHECK AGAIN
0020144E                          2872m     
0020144E  1439 00C00017           2873m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201454  13C2 00E00001           2874m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020145A                          2875m     
0020145A                          2876m     ENDM
0020145A                          2877m                     HEX2BIN D2,D2,A0
0020145A  41F9 00201B0A           2878m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201460  0402 0030               2879m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201464  C4BC 000000FF           2880m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020146A  1430 2000               2881m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020146E                          2882m     ENDM
0020146E  8E82                    2883                      OR.L D2,D7
00201470                          2884                  
00201470  7400                    2885                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00201472  1407                    2886                      MOVE.B D7,D2
00201474  DC82                    2887                      ADD.L D2,D6
00201476                          2888                    
00201476  2447                    2889                      MOVE.L D7,A2                ; start address -> A2
00201478                          2890                  
00201478  43F9 00201638           2891                      LEA DOWNLOAD_DONE,A1        ; next place to go
0020147E                          2892                  ELSE
0020147E  6000 0068               2893s     BRA _00000009
00201482                          2894s _00000008
00201482  41F9 00201ABF           2895                      LEA UNREC,A0                ; warn for unrecognised type
00201488                          2896m                     PRINT_STR A0,D3
00201488                          2897m LOOP_204
00201488  0C10 0000               2898m     CMP.B #0,(A0)                               ; 0 -> DONE
0020148C  6700 001A               2899m     BEQ EXIT_204
00201490                          2900mm     PRINT_CHAR (A0)+,D3
00201490                          2901mm WAIT_FOR_READY_205                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201490                 TRUE     2902mm     IFEQ DEBUG
00201490  1639 00C00003           2903mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201496  0803 0002               2904mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020149A  67F4                    2905mm         BEQ WAIT_FOR_READY_205                      ; NO SPACE, CHECK AGAIN
0020149C  13D8 00C00007           2906mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002014A2                          2907mm     ENDC
002014A2                          2908mm     
002014A2                 FALSE    2909mm     IFNE DEBUG
002014A2                          2910mm     ENDC
002014A2                          2911mm 
002014A2                          2912mm     ENDM
002014A2  4EF9 00201488           2913m     JMP LOOP_204
002014A8                          2914m EXIT_204
002014A8                          2915m     ENDM
002014A8                          2916m                     PRINT_CHAR D7,D3
002014A8                          2917m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014A8                 TRUE     2918m     IFEQ DEBUG
002014A8  1639 00C00003           2919m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014AE  0803 0002               2920m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014B2  67F4                    2921m         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
002014B4  13C7 00C00007           2922m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002014BA                          2923m     ENDC
002014BA                          2924m     
002014BA                 FALSE    2925m     IFNE DEBUG
002014BA                          2926m     ENDC
002014BA                          2927m 
002014BA                          2928m     ENDM
002014BA                          2929m                     PRINT_CRLF D3
002014BA                          2930mm     PRINT_CHAR #13,D3                           ; CR
002014BA                          2931mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014BA                 TRUE     2932mm     IFEQ DEBUG
002014BA  1639 00C00003           2933mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014C0  0803 0002               2934mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014C4  67F4                    2935mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
002014C6  13FC 000D 00C00007      2936mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002014CE                          2937mm     ENDC
002014CE                          2938mm     
002014CE                 FALSE    2939mm     IFNE DEBUG
002014CE                          2940mm     ENDC
002014CE                          2941mm 
002014CE                          2942mm     ENDM
002014CE                          2943mm     PRINT_CHAR #10,D3                           ; LF
002014CE                          2944mm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014CE                 TRUE     2945mm     IFEQ DEBUG
002014CE  1639 00C00003           2946mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002014D4  0803 0002               2947mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002014D8  67F4                    2948mm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
002014DA  13FC 000A 00C00007      2949mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002014E2                          2950mm     ENDC
002014E2                          2951mm     
002014E2                 FALSE    2952mm     IFNE DEBUG
002014E2                          2953mm     ENDC
002014E2                          2954mm 
002014E2                          2955mm     ENDM
002014E2                          2956m     ENDM
002014E2                          2957              
002014E2  4EF9 002004A0           2958                      JMP WAIT_FOR_SRECORD        ; ignore any other type    
002014E8                          2959                  ENDI
002014E8                          2960s _00000009
002014E8                          2961              ENDI
002014E8                          2962s _00000007
002014E8                          2963          ENDI
002014E8                          2964s _00000004
002014E8                          2965      ENDI
002014E8                          2966s _00000001
002014E8                          2967      
002014E8  4686                    2968      NOT.L D6                                    ; ones complement the checksum
002014EA  0286 000000FF           2969      ANDI.L #$FF,D6                              ; and take the LSByte
002014F0                          2970          
002014F0  7E00                    2971      MOVE.L #0,D7                                ; read the checksum from the data stream
002014F2                          2972m     DOWNLOAD D2,D3                              ; top byte
002014F2                          2973m WAIT_FOR_READY_210                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002014F2                          2974m 
002014F2  1639 00C00003           2975m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002014F8  0803 0000               2976m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002014FC  6700 0010               2977m     BEQ CONTINUE_210                                ; NOTHING, CONTINUE
00201500                          2978m  
00201500                          2979mm     READ_CHAR D2
00201500                 TRUE     2980mm     IFEQ DEBUG
00201500  1439 00C00007           2981mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201506                          2982mm     ENDC
00201506                 FALSE    2983mm     IFNE DEBUG
00201506                          2984mm     ENDC
00201506                          2985mm      
00201506  B43C 001B               2986mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020150A  6700 EAFC               2987mm     BEQ START
0020150E                          2988mm     ENDM
0020150E                          2989m CONTINUE_210
0020150E  1639 00C00013           2990m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201514  0803 0000               2991m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201518  67D8                    2992m     BEQ WAIT_FOR_READY_210                      ; NOTHING, CHECK AGAIN
0020151A                          2993m     
0020151A  1439 00C00017           2994m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00201520  13C2 00E00001           2995m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201526                          2996m     
00201526                          2997m     ENDM
00201526                          2998m     HEX2BIN D2,D2,A0
00201526  41F9 00201B0A           2999m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020152C  0402 0030               3000m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201530  C4BC 000000FF           3001m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201536  1430 2000               3002m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020153A                          3003m     ENDM
0020153A  8E82                    3004      OR.L D2,D7
0020153C  E98F                    3005      LSL.L #4,D7
0020153E                          3006m     DOWNLOAD D2,D3                              ; bottom byte
0020153E                          3007m WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020153E                          3008m 
0020153E  1639 00C00003           3009m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00201544  0803 0000               3010m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201548  6700 0010               3011m     BEQ CONTINUE_213                                ; NOTHING, CONTINUE
0020154C                          3012m  
0020154C                          3013mm     READ_CHAR D2
0020154C                 TRUE     3014mm     IFEQ DEBUG
0020154C  1439 00C00007           3015mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201552                          3016mm     ENDC
00201552                 FALSE    3017mm     IFNE DEBUG
00201552                          3018mm     ENDC
00201552                          3019mm      
00201552  B43C 001B               3020mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201556  6700 EAB0               3021mm     BEQ START
0020155A                          3022mm     ENDM
0020155A                          3023m CONTINUE_213
0020155A  1639 00C00013           3024m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00201560  0803 0000               3025m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00201564  67D8                    3026m     BEQ WAIT_FOR_READY_213                      ; NOTHING, CHECK AGAIN
00201566                          3027m     
00201566  1439 00C00017           3028m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020156C  13C2 00E00001           3029m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00201572                          3030m     
00201572                          3031m     ENDM
00201572                          3032m     HEX2BIN D2,D2,A0
00201572  41F9 00201B0A           3033m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201578  0402 0030               3034m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020157C  C4BC 000000FF           3035m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201582  1430 2000               3036m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00201586                          3037m     ENDM
00201586  8E82                    3038      OR.L D2,D7
00201588                          3039                  
00201588                          3040      IF.B D7 <NE> D6 THEN.L
00201588  BE06                    3041s     CMP.B   D6,D7
0020158A  6700 00AA               3042s     BEQ.L   _0000000A
0020158E  41F9 00201AD6           3043          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00201594                          3044m         PRINT_STR A0,D3
00201594                          3045m LOOP_216
00201594  0C10 0000               3046m     CMP.B #0,(A0)                               ; 0 -> DONE
00201598  6700 001A               3047m     BEQ EXIT_216
0020159C                          3048mm     PRINT_CHAR (A0)+,D3
0020159C                          3049mm WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020159C                 TRUE     3050mm     IFEQ DEBUG
0020159C  1639 00C00003           3051mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015A2  0803 0002               3052mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015A6  67F4                    3053mm         BEQ WAIT_FOR_READY_217                      ; NO SPACE, CHECK AGAIN
002015A8  13D8 00C00007           3054mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002015AE                          3055mm     ENDC
002015AE                          3056mm     
002015AE                 FALSE    3057mm     IFNE DEBUG
002015AE                          3058mm     ENDC
002015AE                          3059mm 
002015AE                          3060mm     ENDM
002015AE  4EF9 00201594           3061m     JMP LOOP_216
002015B4                          3062m EXIT_216
002015B4                          3063m     ENDM
002015B4                          3064m         PRINT_REG D4,D3,D6,D7,A0
002015B4                          3065mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002015B4                          3066mm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015B4                 TRUE     3067mm     IFEQ DEBUG
002015B4  1639 00C00003           3068mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015BA  0803 0002               3069mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015BE  67F4                    3070mm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
002015C0  13FC 0030 00C00007      3071mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002015C8                          3072mm     ENDC
002015C8                          3073mm     
002015C8                 FALSE    3074mm     IFNE DEBUG
002015C8                          3075mm     ENDC
002015C8                          3076mm 
002015C8                          3077mm     ENDM
002015C8                          3078mm     PRINT_CHAR #'x',D3
002015C8                          3079mm WAIT_FOR_READY_220                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015C8                 TRUE     3080mm     IFEQ DEBUG
002015C8  1639 00C00003           3081mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015CE  0803 0002               3082mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015D2  67F4                    3083mm         BEQ WAIT_FOR_READY_220                      ; NO SPACE, CHECK AGAIN
002015D4  13FC 0078 00C00007      3084mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002015DC                          3085mm     ENDC
002015DC                          3086mm     
002015DC                 FALSE    3087mm     IFNE DEBUG
002015DC                          3088mm     ENDC
002015DC                          3089mm 
002015DC                          3090mm     ENDM
002015DC  7E07                    3091m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002015DE                          3092m LOOP_218
002015DE                          3093mm     BIN2HEX D4,D6,A0
002015DE  41F9 00201AFA           3094mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002015E4  E99C                    3095mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002015E6  1C04                    3096mm     MOVE.B D4,D6
002015E8  0286 0000000F           3097mm     ANDI.L #$F,D6
002015EE  1C30 6000               3098mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
002015F2                          3099mm     ENDM
002015F2                          3100mm     PRINT_CHAR D6,D3
002015F2                          3101mm WAIT_FOR_READY_222                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002015F2                 TRUE     3102mm     IFEQ DEBUG
002015F2  1639 00C00003           3103mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002015F8  0803 0002               3104mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002015FC  67F4                    3105mm         BEQ WAIT_FOR_READY_222                      ; NO SPACE, CHECK AGAIN
002015FE  13C6 00C00007           3106mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201604                          3107mm     ENDC
00201604                          3108mm     
00201604                 FALSE    3109mm     IFNE DEBUG
00201604                          3110mm     ENDC
00201604                          3111mm 
00201604                          3112mm     ENDM
00201604  57CF FFD8               3113m     DBEQ D7,LOOP_218
00201608                          3114m     ENDM
00201608                          3115m         PRINT_CRLF D3
00201608                          3116mm     PRINT_CHAR #13,D3                           ; CR
00201608                          3117mm WAIT_FOR_READY_224                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201608                 TRUE     3118mm     IFEQ DEBUG
00201608  1639 00C00003           3119mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020160E  0803 0002               3120mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201612  67F4                    3121mm         BEQ WAIT_FOR_READY_224                      ; NO SPACE, CHECK AGAIN
00201614  13FC 000D 00C00007      3122mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020161C                          3123mm     ENDC
0020161C                          3124mm     
0020161C                 FALSE    3125mm     IFNE DEBUG
0020161C                          3126mm     ENDC
0020161C                          3127mm 
0020161C                          3128mm     ENDM
0020161C                          3129mm     PRINT_CHAR #10,D3                           ; LF
0020161C                          3130mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020161C                 TRUE     3131mm     IFEQ DEBUG
0020161C  1639 00C00003           3132mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201622  0803 0002               3133mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201626  67F4                    3134mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
00201628  13FC 000A 00C00007      3135mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201630                          3136mm     ENDC
00201630                          3137mm     
00201630                 FALSE    3138mm     IFNE DEBUG
00201630                          3139mm     ENDC
00201630                          3140mm 
00201630                          3141mm     ENDM
00201630                          3142m     ENDM
00201630  4EF9 00200188           3143          JMP MAIN_LOOP
00201636                          3144      ENDI
00201636                          3145s _0000000A
00201636                          3146      
00201636  4ED1                    3147      JMP (A1)
00201638                          3148  DOWNLOAD_DONE
00201638                          3149m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00201638                          3150mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201638                          3151mm WAIT_FOR_READY_227                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201638                 TRUE     3152mm     IFEQ DEBUG
00201638  1639 00C00003           3153mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020163E  0803 0002               3154mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201642  67F4                    3155mm         BEQ WAIT_FOR_READY_227                      ; NO SPACE, CHECK AGAIN
00201644  13FC 0030 00C00007      3156mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020164C                          3157mm     ENDC
0020164C                          3158mm     
0020164C                 FALSE    3159mm     IFNE DEBUG
0020164C                          3160mm     ENDC
0020164C                          3161mm 
0020164C                          3162mm     ENDM
0020164C                          3163mm     PRINT_CHAR #'x',D3
0020164C                          3164mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020164C                 TRUE     3165mm     IFEQ DEBUG
0020164C  1639 00C00003           3166mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201652  0803 0002               3167mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201656  67F4                    3168mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
00201658  13FC 0078 00C00007      3169mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00201660                          3170mm     ENDC
00201660                          3171mm     
00201660                 FALSE    3172mm     IFNE DEBUG
00201660                          3173mm     ENDC
00201660                          3174mm 
00201660                          3175mm     ENDM
00201660  7C07                    3176m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201662                          3177m LOOP_226
00201662                          3178mm     BIN2HEX D4,D7,A0
00201662  41F9 00201AFA           3179mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201668  E99C                    3180mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020166A  1E04                    3181mm     MOVE.B D4,D7
0020166C  0287 0000000F           3182mm     ANDI.L #$F,D7
00201672  1E30 7000               3183mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00201676                          3184mm     ENDM
00201676                          3185mm     PRINT_CHAR D7,D3
00201676                          3186mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201676                 TRUE     3187mm     IFEQ DEBUG
00201676  1639 00C00003           3188mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020167C  0803 0002               3189mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201680  67F4                    3190mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00201682  13C7 00C00007           3191mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201688                          3192mm     ENDC
00201688                          3193mm     
00201688                 FALSE    3194mm     IFNE DEBUG
00201688                          3195mm     ENDC
00201688                          3196mm 
00201688                          3197mm     ENDM
00201688  57CE FFD8               3198m     DBEQ D6,LOOP_226
0020168C                          3199m     ENDM
0020168C  41F9 00201A9D           3200      LEA READ,A0
00201692                          3201m     PRINT_STR A0,D3
00201692                          3202m LOOP_231
00201692  0C10 0000               3203m     CMP.B #0,(A0)                               ; 0 -> DONE
00201696  6700 001A               3204m     BEQ EXIT_231
0020169A                          3205mm     PRINT_CHAR (A0)+,D3
0020169A                          3206mm WAIT_FOR_READY_232                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020169A                 TRUE     3207mm     IFEQ DEBUG
0020169A  1639 00C00003           3208mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016A0  0803 0002               3209mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016A4  67F4                    3210mm         BEQ WAIT_FOR_READY_232                      ; NO SPACE, CHECK AGAIN
002016A6  13D8 00C00007           3211mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002016AC                          3212mm     ENDC
002016AC                          3213mm     
002016AC                 FALSE    3214mm     IFNE DEBUG
002016AC                          3215mm     ENDC
002016AC                          3216mm 
002016AC                          3217mm     ENDM
002016AC  4EF9 00201692           3218m     JMP LOOP_231
002016B2                          3219m EXIT_231
002016B2                          3220m     ENDM
002016B2  2E0A                    3221      MOVE.L A2,D7                                ; set address accumulator to start address
002016B4                          3222m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
002016B4                          3223mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002016B4                          3224mm WAIT_FOR_READY_234                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016B4                 TRUE     3225mm     IFEQ DEBUG
002016B4  1639 00C00003           3226mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016BA  0803 0002               3227mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016BE  67F4                    3228mm         BEQ WAIT_FOR_READY_234                      ; NO SPACE, CHECK AGAIN
002016C0  13FC 0030 00C00007      3229mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002016C8                          3230mm     ENDC
002016C8                          3231mm     
002016C8                 FALSE    3232mm     IFNE DEBUG
002016C8                          3233mm     ENDC
002016C8                          3234mm 
002016C8                          3235mm     ENDM
002016C8                          3236mm     PRINT_CHAR #'x',D3
002016C8                          3237mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016C8                 TRUE     3238mm     IFEQ DEBUG
002016C8  1639 00C00003           3239mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016CE  0803 0002               3240mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016D2  67F4                    3241mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
002016D4  13FC 0078 00C00007      3242mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002016DC                          3243mm     ENDC
002016DC                          3244mm     
002016DC                 FALSE    3245mm     IFNE DEBUG
002016DC                          3246mm     ENDC
002016DC                          3247mm 
002016DC                          3248mm     ENDM
002016DC  7C07                    3249m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002016DE                          3250m LOOP_233
002016DE                          3251mm     BIN2HEX D7,D2,A0
002016DE  41F9 00201AFA           3252mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002016E4  E99F                    3253mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002016E6  1407                    3254mm     MOVE.B D7,D2
002016E8  0282 0000000F           3255mm     ANDI.L #$F,D2
002016EE  1430 2000               3256mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002016F2                          3257mm     ENDM
002016F2                          3258mm     PRINT_CHAR D2,D3
002016F2                          3259mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002016F2                 TRUE     3260mm     IFEQ DEBUG
002016F2  1639 00C00003           3261mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002016F8  0803 0002               3262mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002016FC  67F4                    3263mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
002016FE  13C2 00C00007           3264mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201704                          3265mm     ENDC
00201704                          3266mm     
00201704                 FALSE    3267mm     IFNE DEBUG
00201704                          3268mm     ENDC
00201704                          3269mm 
00201704                          3270mm     ENDM
00201704  57CE FFD8               3271m     DBEQ D6,LOOP_233
00201708                          3272m     ENDM
00201708                          3273m     PRINT_CRLF D3     
00201708                          3274mm     PRINT_CHAR #13,D3                           ; CR
00201708                          3275mm WAIT_FOR_READY_239                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201708                 TRUE     3276mm     IFEQ DEBUG
00201708  1639 00C00003           3277mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020170E  0803 0002               3278mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201712  67F4                    3279mm         BEQ WAIT_FOR_READY_239                      ; NO SPACE, CHECK AGAIN
00201714  13FC 000D 00C00007      3280mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020171C                          3281mm     ENDC
0020171C                          3282mm     
0020171C                 FALSE    3283mm     IFNE DEBUG
0020171C                          3284mm     ENDC
0020171C                          3285mm 
0020171C                          3286mm     ENDM
0020171C                          3287mm     PRINT_CHAR #10,D3                           ; LF
0020171C                          3288mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020171C                 TRUE     3289mm     IFEQ DEBUG
0020171C  1639 00C00003           3290mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201722  0803 0002               3291mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201726  67F4                    3292mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00201728  13FC 000A 00C00007      3293mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201730                          3294mm     ENDC
00201730                          3295mm     
00201730                 FALSE    3296mm     IFNE DEBUG
00201730                          3297mm     ENDC
00201730                          3298mm 
00201730                          3299mm     ENDM
00201730                          3300m     ENDM
00201730                          3301          
00201730  4EF9 00200188           3302      JMP MAIN_LOOP
00201736                          3303      
00201736  2047                    3304  G   MOVE.L D7,A0                                ; address accumulator -> address register
00201738  3E3C 0000               3305      MOVE #0,D7                                  ; clear the now used address accumulator
0020173C  4ED0                    3306      JMP (A0)                                    ; jump to it!
0020173E                          3307      
0020173E  207C 00200000           3308  Z   MOVE.L #RAM,A0                              ; address of RAM
00201744  7000                    3309      MOVE.L #0,D0                                ; number of bytes
00201746                          3310     
00201746                          3311      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201746                          3312s _10000006
00201746  B0BC 00040000           3313s     CMP.L   #$40000,D0
0020174C  6E00 001A               3314s     BGT _10000007
00201750                          3315         
00201750  2200                    3316          MOVE.L D0,D1                            ; progress update
00201752  E089                    3317          LSR.L #8,D1 
00201754  E089                    3318          LSR.L #8,D1
00201756  0281 0000000F           3319          ANDI.L #$F,D1
0020175C  13C1 00E00001           3320          MOVE.B D1,DISPLAY
00201762                          3321  
00201762  20C0                    3322          MOVE.L D0,(A0)+ 
00201764  5880                    3323          ADD.L #4,D0
00201766                          3324      ENDW
00201766  60DE                    3325s     BRA _10000006
00201768                          3326s _10000007
00201768                          3327   
00201768  207C 00200000           3328      MOVE.L #RAM,A0                              ; address of RAM
0020176E  7000                    3329      MOVE.L #0,D0                                ; number of bytes
00201770                          3330     
00201770                          3331      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201770                          3332s _10000008
00201770  B0BC 00040000           3333s     CMP.L   #$40000,D0
00201776  6E00 00CC               3334s     BGT _10000009
0020177A                          3335  
0020177A  2200                    3336          MOVE.L D0,D1                            ; progress update
0020177C  E089                    3337          LSR.L #8,D1
0020177E  E089                    3338          LSR.L #8,D1
00201780  0281 0000000F           3339          ANDI.L #$F,D1
00201786  13C1 00E00001           3340          MOVE.B D1,DISPLAY
0020178C                          3341  
0020178C  2218                    3342          MOVE.L (A0)+,D1
0020178E                          3343            
0020178E                          3344          IF.L D0 <EQ> D1 THEN
0020178E  B081                    3345s     CMP.L   D1,D0
00201790  6600 0006               3346s     BNE _0000000B
00201794  6000 00A8               3347              BRA OK
00201798                          3348          ENDI 
00201798                          3349s _0000000B
00201798                          3350            
00201798  43F9 00201AE8           3351          LEA RAM_ERROR,A1
0020179E                          3352m         PRINT_STR A1,D1
0020179E                          3353m LOOP_241
0020179E  0C11 0000               3354m     CMP.B #0,(A1)                               ; 0 -> DONE
002017A2  6700 001A               3355m     BEQ EXIT_241
002017A6                          3356mm     PRINT_CHAR (A1)+,D1
002017A6                          3357mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017A6                 TRUE     3358mm     IFEQ DEBUG
002017A6  1239 00C00003           3359mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
002017AC  0801 0002               3360mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
002017B0  67F4                    3361mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
002017B2  13D9 00C00007           3362mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002017B8                          3363mm     ENDC
002017B8                          3364mm     
002017B8                 FALSE    3365mm     IFNE DEBUG
002017B8                          3366mm     ENDC
002017B8                          3367mm 
002017B8                          3368mm     ENDM
002017B8  4EF9 0020179E           3369m     JMP LOOP_241
002017BE                          3370m EXIT_241
002017BE                          3371m     ENDM
002017BE  2208                    3372          MOVE.L A0,D1
002017C0  5981                    3373          SUB.L #4,D1
002017C2                          3374m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
002017C2                          3375mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002017C2                          3376mm WAIT_FOR_READY_244                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017C2                 TRUE     3377mm     IFEQ DEBUG
002017C2  1639 00C00003           3378mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002017C8  0803 0002               3379mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002017CC  67F4                    3380mm         BEQ WAIT_FOR_READY_244                      ; NO SPACE, CHECK AGAIN
002017CE  13FC 0030 00C00007      3381mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002017D6                          3382mm     ENDC
002017D6                          3383mm     
002017D6                 FALSE    3384mm     IFNE DEBUG
002017D6                          3385mm     ENDC
002017D6                          3386mm 
002017D6                          3387mm     ENDM
002017D6                          3388mm     PRINT_CHAR #'x',D3
002017D6                          3389mm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002017D6                 TRUE     3390mm     IFEQ DEBUG
002017D6  1639 00C00003           3391mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002017DC  0803 0002               3392mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002017E0  67F4                    3393mm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
002017E2  13FC 0078 00C00007      3394mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002017EA                          3395mm     ENDC
002017EA                          3396mm     
002017EA                 FALSE    3397mm     IFNE DEBUG
002017EA                          3398mm     ENDC
002017EA                          3399mm 
002017EA                          3400mm     ENDM
002017EA  7C07                    3401m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002017EC                          3402m LOOP_243
002017EC                          3403mm     BIN2HEX D1,D2,A1
002017EC  43F9 00201AFA           3404mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
002017F2  E999                    3405mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002017F4  1401                    3406mm     MOVE.B D1,D2
002017F6  0282 0000000F           3407mm     ANDI.L #$F,D2
002017FC  1431 2000               3408mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00201800                          3409mm     ENDM
00201800                          3410mm     PRINT_CHAR D2,D3
00201800                          3411mm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201800                 TRUE     3412mm     IFEQ DEBUG
00201800  1639 00C00003           3413mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201806  0803 0002               3414mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020180A  67F4                    3415mm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
0020180C  13C2 00C00007           3416mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201812                          3417mm     ENDC
00201812                          3418mm     
00201812                 FALSE    3419mm     IFNE DEBUG
00201812                          3420mm     ENDC
00201812                          3421mm 
00201812                          3422mm     ENDM
00201812  57CE FFD8               3423m     DBEQ D6,LOOP_243
00201816                          3424m     ENDM
00201816                          3425m         PRINT_CRLF D3
00201816                          3426mm     PRINT_CHAR #13,D3                           ; CR
00201816                          3427mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201816                 TRUE     3428mm     IFEQ DEBUG
00201816  1639 00C00003           3429mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020181C  0803 0002               3430mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201820  67F4                    3431mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00201822  13FC 000D 00C00007      3432mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020182A                          3433mm     ENDC
0020182A                          3434mm     
0020182A                 FALSE    3435mm     IFNE DEBUG
0020182A                          3436mm     ENDC
0020182A                          3437mm 
0020182A                          3438mm     ENDM
0020182A                          3439mm     PRINT_CHAR #10,D3                           ; LF
0020182A                          3440mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020182A                 TRUE     3441mm     IFEQ DEBUG
0020182A  1639 00C00003           3442mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201830  0803 0002               3443mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201834  67F4                    3444mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
00201836  13FC 000A 00C00007      3445mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020183E                          3446mm     ENDC
0020183E                          3447mm     
0020183E                 FALSE    3448mm     IFNE DEBUG
0020183E                          3449mm     ENDC
0020183E                          3450mm 
0020183E                          3451mm     ENDM
0020183E                          3452m     ENDM
0020183E                          3453  OK    
0020183E  5880                    3454          ADD.L #4,D0
00201840                          3455      ENDW
00201840  6000 FF2E               3456s     BRA _10000008
00201844                          3457s _10000009
00201844                          3458      
00201844  4EF9 00200188           3459      JMP MAIN_LOOP
0020184A                          3460    
0020184A  7A00                    3461  L   MOVE.L #0,D5                                ; D5 will be the length  to write            
0020184C                          3462  
0020184C                          3463m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
0020184C                          3464m WAIT_FOR_READY_251                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020184C                          3465m 
0020184C                 TRUE     3466m     IFEQ DEBUG
0020184C  1639 00C00003           3467m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201852  0803 0000               3468m         BTST #0,D3                              ; CHECK FOR CHARACTER
00201856  67F4                    3469m         BEQ WAIT_FOR_READY_251                      ; NOTHING, CHECK AGAIN
00201858                          3470m     ENDC
00201858                          3471m     
00201858                          3472mm     READ_CHAR D2
00201858                 TRUE     3473mm     IFEQ DEBUG
00201858  1439 00C00007           3474mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020185E                          3475mm     ENDC
0020185E                 FALSE    3476mm     IFNE DEBUG
0020185E                          3477mm     ENDC
0020185E                          3478mm      
0020185E  B43C 001B               3479mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201862  6700 E7A4               3480mm     BEQ START
00201866                          3481mm     ENDM
00201866                          3482m 
00201866                 TRUE     3483m     IFEQ DEBUG
00201866                          3484mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00201866                          3485mm WAIT_FOR_READY_253                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201866                 TRUE     3486mm     IFEQ DEBUG
00201866  1639 00C00003           3487mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020186C  0803 0002               3488mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201870  67F4                    3489mm         BEQ WAIT_FOR_READY_253                      ; NO SPACE, CHECK AGAIN
00201872  13C2 00C00007           3490mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201878                          3491mm     ENDC
00201878                          3492mm     
00201878                 FALSE    3493mm     IFNE DEBUG
00201878                          3494mm     ENDC
00201878                          3495mm 
00201878                          3496mm     ENDM
00201878                          3497m     ENDC
00201878                          3498m     ENDM
00201878                          3499m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00201878  41F9 00201B0A           3500m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020187E  0402 0030               3501m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201882  C4BC 000000FF           3502m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201888  1430 2000               3503m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020188C                          3504m     ENDM
0020188C  1A02                    3505      MOVE.B D2,D5                                ; put at bottom of D5
0020188E                          3506  
0020188E  3C3C 0002               3507      MOVE #2,D6                                  ; 3 bytes left to read
00201892                          3508      
00201892                          3509  READ_LENGTH
00201892  E98D                    3510      LSL.L #4,D5                                 ; make what we have so far more significant
00201894                          3511m     WAIT_CHAR D2,D3                             ; next character -> D2
00201894                          3512m WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201894                          3513m 
00201894                 TRUE     3514m     IFEQ DEBUG
00201894  1639 00C00003           3515m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020189A  0803 0000               3516m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020189E  67F4                    3517m         BEQ WAIT_FOR_READY_255                      ; NOTHING, CHECK AGAIN
002018A0                          3518m     ENDC
002018A0                          3519m     
002018A0                          3520mm     READ_CHAR D2
002018A0                 TRUE     3521mm     IFEQ DEBUG
002018A0  1439 00C00007           3522mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002018A6                          3523mm     ENDC
002018A6                 FALSE    3524mm     IFNE DEBUG
002018A6                          3525mm     ENDC
002018A6                          3526mm      
002018A6  B43C 001B               3527mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002018AA  6700 E75C               3528mm     BEQ START
002018AE                          3529mm     ENDM
002018AE                          3530m 
002018AE                 TRUE     3531m     IFEQ DEBUG
002018AE                          3532mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002018AE                          3533mm WAIT_FOR_READY_257                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018AE                 TRUE     3534mm     IFEQ DEBUG
002018AE  1639 00C00003           3535mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018B4  0803 0002               3536mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018B8  67F4                    3537mm         BEQ WAIT_FOR_READY_257                      ; NO SPACE, CHECK AGAIN
002018BA  13C2 00C00007           3538mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002018C0                          3539mm     ENDC
002018C0                          3540mm     
002018C0                 FALSE    3541mm     IFNE DEBUG
002018C0                          3542mm     ENDC
002018C0                          3543mm 
002018C0                          3544mm     ENDM
002018C0                          3545m     ENDC
002018C0                          3546m     ENDM
002018C0                          3547m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002018C0  41F9 00201B0A           3548m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002018C6  0402 0030               3549m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002018CA  C4BC 000000FF           3550m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002018D0  1430 2000               3551m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002018D4                          3552m     ENDM
002018D4  8A02                    3553      OR.B D2,D5
002018D6  023C 00FB               3554      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
002018DA  57CE FFB6               3555      DBEQ D6,READ_LENGTH
002018DE                          3556          
002018DE                          3557m     PRINT_CRLF D3
002018DE                          3558mm     PRINT_CHAR #13,D3                           ; CR
002018DE                          3559mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018DE                 TRUE     3560mm     IFEQ DEBUG
002018DE  1639 00C00003           3561mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018E4  0803 0002               3562mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018E8  67F4                    3563mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
002018EA  13FC 000D 00C00007      3564mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002018F2                          3565mm     ENDC
002018F2                          3566mm     
002018F2                 FALSE    3567mm     IFNE DEBUG
002018F2                          3568mm     ENDC
002018F2                          3569mm 
002018F2                          3570mm     ENDM
002018F2                          3571mm     PRINT_CHAR #10,D3                           ; LF
002018F2                          3572mm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002018F2                 TRUE     3573mm     IFEQ DEBUG
002018F2  1639 00C00003           3574mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002018F8  0803 0002               3575mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002018FC  67F4                    3576mm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
002018FE  13FC 000A 00C00007      3577mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201906                          3578mm     ENDC
00201906                          3579mm     
00201906                 FALSE    3580mm     IFNE DEBUG
00201906                          3581mm     ENDC
00201906                          3582mm 
00201906                          3583mm     ENDM
00201906                          3584m     ENDM
00201906                          3585  
00201906  207C 00000000           3586      MOVE.L #ROM,A0                              ; start of ROM
0020190C                          3587      
0020190C  2247                    3588      MOVE.L D7,A1                                ; address accumulator -> address register
0020190E  7E00                    3589      MOVE.L #0,D7                                ; clear the now used address accumulator
00201910                          3590      
00201910  267C 00002AAA           3591      MOVE.L #$2AAA,A3
00201916  36BC AAAA               3592      MOVE.W #$AAAA,(A3)
0020191A  267C 00001554           3593      MOVE.L #$1554,A3
00201920  36BC 5555               3594      MOVE.W #$5555,(A3)
00201924  267C 00002AAA           3595      MOVE.L #$2AAA,A3
0020192A  36BC 8080               3596      MOVE.W #$8080,(A3)
0020192E  267C 00002AAA           3597      MOVE.L #$2AAA,A3
00201934  36BC AAAA               3598      MOVE.W #$AAAA,(A3)
00201938  267C 00001554           3599      MOVE.L #$1554,A3
0020193E  36BC 5555               3600      MOVE.W #$5555,(A3)
00201942  267C 00002AAA           3601      MOVE.L #$2AAA,A3
00201948  36BC 2020               3602      MOVE.W #$2020,(A3)
0020194C                          3603      
0020194C  45F9 00201B21           3604      LEA LOADING,A2                              ; important for timing
00201952                          3605m     PRINT_STR A2,D3
00201952                          3606m LOOP_262
00201952  0C12 0000               3607m     CMP.B #0,(A2)                               ; 0 -> DONE
00201956  6700 001A               3608m     BEQ EXIT_262
0020195A                          3609mm     PRINT_CHAR (A2)+,D3
0020195A                          3610mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020195A                 TRUE     3611mm     IFEQ DEBUG
0020195A  1639 00C00003           3612mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201960  0803 0002               3613mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201964  67F4                    3614mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
00201966  13DA 00C00007           3615mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020196C                          3616mm     ENDC
0020196C                          3617mm     
0020196C                 FALSE    3618mm     IFNE DEBUG
0020196C                          3619mm     ENDC
0020196C                          3620mm 
0020196C                          3621mm     ENDM
0020196C  4EF9 00201952           3622m     JMP LOOP_262
00201972                          3623m EXIT_262
00201972                          3624m     ENDM
00201972                          3625  
00201972  023C 00FB               3626      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00201976                          3627      
00201976                          3628      WHILE D5 <GT> #0 DO
00201976                          3629s _1000000A
00201976  BA7C 0000               3630s     CMP.W   #0,D5
0020197A  6F00 0020               3631s     BLE _1000000B
0020197E  5585                    3632          SUB.L #2,D5
00201980                          3633            
00201980  13D1 00E00001           3634          MOVE.B (A1),DISPLAY
00201986  3091                    3635          MOVE.W (A1),(A0)                        ; write the data
00201988                          3636        
00201988                          3637    WAIT_FOR_COMPLETE:
00201988  3410                    3638          MOVE.W (A0),D2
0020198A                          3639  
0020198A                          3640          IF D2 <NE> (A1) THEN
0020198A  B451                    3641s     CMP.W   (A1),D2
0020198C  6700 0008               3642s     BEQ _0000000C
00201990  4EF9 00201988           3643              JMP WAIT_FOR_COMPLETE
00201996                          3644          ENDI
00201996                          3645s _0000000C
00201996                          3646        
00201996  5488                    3647          ADD.L #2,A0
00201998  5489                    3648          ADD.L #2,A1
0020199A                          3649      ENDW  
0020199A  60DA                    3650s     BRA _1000000A
0020199C                          3651s _1000000B
0020199C                          3652      
0020199C  267C 00002AAA           3653      MOVE.L #$2AAA,A3
002019A2  36BC AAAA               3654      MOVE.W #$AAAA,(A3)
002019A6  267C 00001554           3655      MOVE.L #$1554,A3
002019AC  36BC 5555               3656      MOVE.W #$5555,(A3)
002019B0  267C 00002AAA           3657      MOVE.L #$2AAA,A3
002019B6  36BC A0A0               3658      MOVE.W #$A0A0,(A3)
002019BA                          3659              
002019BA  4EF9 00200188           3660      JMP MAIN_LOOP
002019C0                          3661          
002019C0                          3662  HEX_DIGIT
002019C0  E98F                    3663      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
002019C2                          3664m     HEX2BIN D2,D2,A0
002019C2  41F9 00201B0A           3665m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002019C8  0402 0030               3666m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002019CC  C4BC 000000FF           3667m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002019D2  1430 2000               3668m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002019D6                          3669m     ENDM
002019D6  8E02                    3670      OR.B D2,D7  
002019D8  4EF9 002001B0           3671      JMP GET_INPUT
002019DE                          3672  
002019DE  FFFF FFFF               3673      SIMHALT                                     ; halt simulator
002019E2                          3674  
002019E2                          3675  ; strings
002019E2= 4D 44 46 2D 6D 6F ...   3676  VERSION DC.B 'MDF-mon V1.31 (08/04/2021)',13,10,0
002019FF= 3F 20 48 65 6C 70 ...   3677  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201A96= 48 75 68 3F 0D 0A 00    3678  HUH     DC.B 'Huh?',13,10,0
00201A9D= 20 53 20 72 65 63 ...   3679  READ    DC.B ' S records read, start address = ',0
00201ABF= 57 3A 20 55 6E 6B ...   3680  UNREC   DC.B 'W: Unknown Srec type: ',0
00201AD6= 57 3A 20 43 53 20 ...   3681  CS_FAILURE   DC.B 'W: CS failure at ',0
00201AE8= 57 3A 20 52 41 4D ...   3682  RAM_ERROR DC.B 'W: RAM error at: ',0
00201AFA= 30 31 32 33 34 35 ...   3683  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00201B0A= 00 01 02 03 04 05 ...   3684  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201B21= 4C 6F 61 64 69 6E ...   3685  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201B35                          3686      
00201B35                          3687      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         201AFA
CONTINUE_100        200A6A
CONTINUE_104        200AC8
CONTINUE_108        200B28
CONTINUE_112        200B86
CONTINUE_116        200BF8
CONTINUE_120        200C56
CONTINUE_127        200CFE
CONTINUE_131        200D5C
CONTINUE_135        200DBC
CONTINUE_139        200E1A
CONTINUE_143        200E7E
CONTINUE_147        200EDC
CONTINUE_151        200F52
CONTINUE_155        200FB0
CONTINUE_159        20102A
CONTINUE_163        201088
CONTINUE_167        2010E8
CONTINUE_171        201146
CONTINUE_175        2011B8
CONTINUE_179        201216
CONTINUE_186        2012BE
CONTINUE_189        20130A
CONTINUE_192        201358
CONTINUE_195        2013A4
CONTINUE_198        2013F6
CONTINUE_201        201442
CONTINUE_210        20150E
CONTINUE_213        20155A
CONTINUE_44         2004BC
CONTINUE_46         2004F8
CONTINUE_48         200530
CONTINUE_51         20057C
CONTINUE_54         2005D2
CONTINUE_57         20061E
CONTINUE_60         20066C
CONTINUE_63         2006B8
CONTINUE_66         200718
CONTINUE_69         200764
CONTINUE_76         200802
CONTINUE_80         200860
CONTINUE_84         2008C0
CONTINUE_88         20091E
CONTINUE_92         200994
CONTINUE_96         2009F2
CS_FAILURE          201AD6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_DONE       201638
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EVEN                200A40
EVEN2               200FFE
EXIT_19             2002EA
EXIT_204            2014A8
EXIT_21             200316
EXIT_216            2015B4
EXIT_23             200342
EXIT_231            2016B2
EXIT_241            2017BE
EXIT_262            201972
EXIT_5              200142
G                   201736
GET_INPUT           2001B0
H                   2002F0
HELP                2019FF
HEX2BIN             134
HEX2BIN_LUT         201B0A
HEX_DIGIT           2019C0
HUH                 201A96
L                   20184A
LOADING             201B21
LOOP_19             2002CA
LOOP_204            201488
LOOP_21             2002F6
LOOP_216            201594
LOOP_218            2015DE
LOOP_226            201662
LOOP_23             200322
LOOP_231            201692
LOOP_233            2016DE
LOOP_241            20179E
LOOP_243            2017EC
LOOP_25             200376
LOOP_262            201952
LOOP_5              200122
MAIN_LOOP           200188
OK                  20183E
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           201AE8
READ                201A9D
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         201892
RESET               200004
ROM                 0
RRRR                200000
S                   200498
STACK               200000
START               200008
UNREC               201ABF
V                   20031C
VERSION             2019E2
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   201988
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  200A4E
WAIT_FOR_READY_102  200A82
WAIT_FOR_READY_104  200AAC
WAIT_FOR_READY_106  200AE0
WAIT_FOR_READY_108  200B0C
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200B40
WAIT_FOR_READY_112  200B6A
WAIT_FOR_READY_114  200B9E
WAIT_FOR_READY_116  200BDC
WAIT_FOR_READY_118  200C10
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_120  200C3A
WAIT_FOR_READY_122  200C6E
WAIT_FOR_READY_125  200CA6
WAIT_FOR_READY_126  200CBA
WAIT_FOR_READY_127  200CE2
WAIT_FOR_READY_129  200D16
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200D40
WAIT_FOR_READY_133  200D74
WAIT_FOR_READY_135  200DA0
WAIT_FOR_READY_137  200DD4
WAIT_FOR_READY_139  200DFE
WAIT_FOR_READY_141  200E32
WAIT_FOR_READY_143  200E62
WAIT_FOR_READY_145  200E96
WAIT_FOR_READY_147  200EC0
WAIT_FOR_READY_149  200EF4
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200F36
WAIT_FOR_READY_153  200F6A
WAIT_FOR_READY_155  200F94
WAIT_FOR_READY_157  200FC8
WAIT_FOR_READY_159  20100E
WAIT_FOR_READY_161  201042
WAIT_FOR_READY_163  20106C
WAIT_FOR_READY_165  2010A0
WAIT_FOR_READY_167  2010CC
WAIT_FOR_READY_169  201100
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  20112A
WAIT_FOR_READY_173  20115E
WAIT_FOR_READY_175  20119C
WAIT_FOR_READY_177  2011D0
WAIT_FOR_READY_179  2011FA
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  20122E
WAIT_FOR_READY_184  201266
WAIT_FOR_READY_185  20127A
WAIT_FOR_READY_186  2012A2
WAIT_FOR_READY_189  2012EE
WAIT_FOR_READY_192  20133C
WAIT_FOR_READY_195  201388
WAIT_FOR_READY_198  2013DA
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  201426
WAIT_FOR_READY_205  201490
WAIT_FOR_READY_206  2014A8
WAIT_FOR_READY_208  2014BA
WAIT_FOR_READY_209  2014CE
WAIT_FOR_READY_210  2014F2
WAIT_FOR_READY_213  20153E
WAIT_FOR_READY_217  20159C
WAIT_FOR_READY_219  2015B4
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_220  2015C8
WAIT_FOR_READY_222  2015F2
WAIT_FOR_READY_224  201608
WAIT_FOR_READY_225  20161C
WAIT_FOR_READY_227  201638
WAIT_FOR_READY_228  20164C
WAIT_FOR_READY_230  201676
WAIT_FOR_READY_232  20169A
WAIT_FOR_READY_234  2016B4
WAIT_FOR_READY_235  2016C8
WAIT_FOR_READY_237  2016F2
WAIT_FOR_READY_239  201708
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_240  20171C
WAIT_FOR_READY_242  2017A6
WAIT_FOR_READY_244  2017C2
WAIT_FOR_READY_245  2017D6
WAIT_FOR_READY_247  201800
WAIT_FOR_READY_249  201816
WAIT_FOR_READY_250  20182A
WAIT_FOR_READY_251  20184C
WAIT_FOR_READY_253  201866
WAIT_FOR_READY_255  201894
WAIT_FOR_READY_257  2018AE
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_260  2018DE
WAIT_FOR_READY_261  2018F2
WAIT_FOR_READY_263  20195A
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DC
WAIT_FOR_READY_48   200514
WAIT_FOR_READY_51   200560
WAIT_FOR_READY_54   2005B6
WAIT_FOR_READY_57   200602
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200650
WAIT_FOR_READY_63   20069C
WAIT_FOR_READY_66   2006FC
WAIT_FOR_READY_69   200748
WAIT_FOR_READY_72   200794
WAIT_FOR_READY_74   2007AA
WAIT_FOR_READY_75   2007BE
WAIT_FOR_READY_76   2007E6
WAIT_FOR_READY_78   20081A
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   200844
WAIT_FOR_READY_82   200878
WAIT_FOR_READY_84   2008A4
WAIT_FOR_READY_86   2008D8
WAIT_FOR_READY_88   200902
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   200936
WAIT_FOR_READY_92   200978
WAIT_FOR_READY_94   2009AC
WAIT_FOR_READY_96   2009D6
WAIT_FOR_READY_98   200A0A
WAIT_FOR_SRECORD    2004A0
Z                   20173E
_00000000           2007DC
_00000001           2014E8
_00000002           200CD8
_00000003           200CA6
_00000004           2014E8
_00000005           201298
_00000006           201266
_00000007           2014E8
_00000008           201482
_00000009           2014E8
_0000000A           201636
_0000000B           201798
_0000000C           201996
_10000000           2006EE
_10000001           2007AA
_10000002           200A40
_10000003           200BD2
_10000004           201000
_10000005           201192
_10000006           201746
_10000007           201768
_10000008           201770
_10000009           201844
_1000000A           201976
_1000000B           20199C
