00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 15:22:53

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; revisit use of bytes and longs, eg for checksum
00000000                             9  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            10  ; Review for any other savings
00000000                            11  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            12  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            13  
00000000                            14  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            15  ; keep track of highest address hit during srec download
00000000                            16  ; fix the reset vector so that it jumps to the start
00000000                            17  ; implement backspace
00000000                            18  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            19  ; fix being able to enter random chars when W'ing
00000000                            20  ; ram check at startup?  Not sure if this is a good idea!
00000000                            21  ; byte W?
00000000                            22  
00000000                            23      ORG  $0
00000000                            24      ;ORG  $200000
00000000                            25  
00000000  =00000000                 26  DEBUG               EQU 0
00000000                            27  
00000000                            28  ; constants
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31     
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           106          BTST #2,\2                              ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           109      ENDC
00000000                           110      
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll
00000000                           121  PRINT_CRLF MACRO
00000000                           122      PRINT_CHAR #13,\1                           ; CR
00000000                           123      PRINT_CHAR #10,\1                           ; LF
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #0,(\1)                               ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           139  PRINT_REG MACRO
00000000                           140      PRINT_CHAR #'0',\2                          ;0x header
00000000                           141      PRINT_CHAR #'x',\2
00000000                           142      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148    
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           156          BTST #0,\2                              ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           158      ENDC
00000000                           159      
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                        ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166      
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179       
00000000                           180      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183      
00000000                           184      
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           191      BTST #0,\1                                  ; check for character
00000000                           192      BEQ CONTINUE\@                              ; nothing, continue
00000000                           193   
00000000                           194      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           197      BTST #0,\1                                  ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           202      
00000000                           203      ENDM
00000000                           204      
00000000                           205  ; read two hex digits from the download serial port and convert to a byte
00000000                           206  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           207  DOWNLOAD_BYTE MACRO
00000000                           208      MOVE.B #2,\4
00000000                           209      WHILE.B \4 <GT> 0 DO
00000000                           210          LSL.L #4,\1                         ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           211          DOWNLOAD \2
00000000                           212          PRINT_CHAR \2,\3
00000000                           213          HEX2BIN \2,\2,\6
00000000                           214          OR.B \2,\1
00000000                           215          SUB.B #1,\4
00000000                           216      ENDW
00000000                           217      
00000000                           218      MOVE.L #0,\2                            ; rextract latest byte of address and add into checksum
00000000                           219      MOVE.B \1,\2
00000000                           220      ADD.L \1,\5
00000000                           221  
00000000                           222      ENDM
00000000                           223      
00000000                           224  
00000000                           225  ; register catalogue
00000000                           226  ; D0 - used for simulator I/O
00000000                           227  ; D1 - used for simulator I/O
00000000                           228  ; D2 - read character
00000000                           229  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           230  ; D6 - working register used in R/W
00000000                           231  ; D7 - address accumulator, reset by download
00000000                           232  ; A0 - address of string to print 
00000000                           233  
00000000                           234  ; start vector
00000000= 00000000                 235  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 236  RESET    DC.L START                             ; RESET
00000008                           237      
00000008                           238  ; start of program  
00000008                           239  START
00000008  13FC 0000 00E00001       240      MOVE.B #0,DISPLAY
00000010                           241  
00000010                           242  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       243      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       244      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     245      NOP
00000022  13FC 0040 00C00005       246      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     247      NOP
0000002C  13FC 0030 00C00005       248      MOVE.B #$30,DUART_CRA
00000034  4E71                     249      NOP
00000036  13FC 0020 00C00005       250      MOVE.B #$20,DUART_CRA
0000003E  4E71                     251      NOP
00000040  13FC 0010 00C00005       252      MOVE.B #$10,DUART_CRA   
00000048                           253  
00000048  13FC 000A 00C00015       254      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       255      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     256      NOP
0000005A  13FC 0040 00C00015       257      MOVE.B #$40,DUART_CRB           
00000062  4E71                     258      NOP
00000064  13FC 0030 00C00015       259      MOVE.B #$30,DUART_CRB
0000006C  4E71                     260      NOP
0000006E  13FC 0020 00C00015       261      MOVE.B #$20,DUART_CRB
00000076  4E71                     262      NOP
00000078  13FC 0010 00C00015       263      MOVE.B #$10,DUART_CRB   
00000080                           264  
00000080                           265  ;initialise UART
00000080  13FC 0000 00C00009       266      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       267      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       268      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           269  
00000098                           270  ; channel A
00000098  13FC 0013 00C00001       271      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       272      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       273      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       274      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           275  
000000B8                           276  ; channel B
000000B8  13FC 0013 00C00011       277      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       278      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       279      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       280      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           281  
000000D8                           282m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           283m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      284m     IFEQ DEBUG
000000D8  1639 00C00003            285m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                286m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     287m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       288m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           289m     ENDC
000000EC                           290m     
000000EC                 FALSE     291m     IFNE DEBUG
000000EC                           292m     ENDC
000000EC                           293m 
000000EC                           294m     ENDM
000000EC                           295  
000000EC  13FC 0001 00E00001       296      MOVE.B #1,DISPLAY
000000F4                           297         
000000F4                           298m     PRINT_CRLF D3
000000F4                           299mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           300mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      301mm     IFEQ DEBUG
000000F4  1639 00C00003            302mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                303mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     304mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       305mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           306mm     ENDC
00000108                           307mm     
00000108                 FALSE     308mm     IFNE DEBUG
00000108                           309mm     ENDC
00000108                           310mm 
00000108                           311mm     ENDM
00000108                           312mm     PRINT_CHAR #10,D3                           ; LF
00000108                           313mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      314mm     IFEQ DEBUG
00000108  1639 00C00003            315mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                316mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     317mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       318mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           319mm     ENDC
0000011C                           320mm     
0000011C                 FALSE     321mm     IFNE DEBUG
0000011C                           322mm     ENDC
0000011C                           323mm 
0000011C                           324mm     ENDM
0000011C                           325m     ENDM
0000011C                           326  
0000011C  41F9 00000E56            327      LEA VERSION,A0
00000122                           328m     PRINT_STR A0,D3
00000122                           329m LOOP_5
00000122  0C10 0000                330m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0016                331m     BEQ EXIT_5
0000012A                           332mm     PRINT_CHAR (A0)+,D3
0000012A                           333mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      334mm     IFEQ DEBUG
0000012A  1639 00C00003            335mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                336mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     337mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            338mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           339mm     ENDC
0000013C                           340mm     
0000013C                 FALSE     341mm     IFNE DEBUG
0000013C                           342mm     ENDC
0000013C                           343mm 
0000013C                           344mm     ENDM
0000013C  60E4                     345m     BRA LOOP_5
0000013E                           346m EXIT_5
0000013E                           347m     ENDM
0000013E                           348m     PRINT_CRLF D3
0000013E                           349mm     PRINT_CHAR #13,D3                           ; CR
0000013E                           350mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      351mm     IFEQ DEBUG
0000013E  1639 00C00003            352mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                353mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     354mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014A  13FC 000D 00C00007       355mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000152                           356mm     ENDC
00000152                           357mm     
00000152                 FALSE     358mm     IFNE DEBUG
00000152                           359mm     ENDC
00000152                           360mm 
00000152                           361mm     ENDM
00000152                           362mm     PRINT_CHAR #10,D3                           ; LF
00000152                           363mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      364mm     IFEQ DEBUG
00000152  1639 00C00003            365mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000158  0803 0002                366mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015C  67F4                     367mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0000015E  13FC 000A 00C00007       368mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000166                           369mm     ENDC
00000166                           370mm     
00000166                 FALSE     371mm     IFNE DEBUG
00000166                           372mm     ENDC
00000166                           373mm 
00000166                           374mm     ENDM
00000166                           375m     ENDM
00000166                           376m     PRINT_CHAR #7,D3
00000166                           377m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000166                 TRUE      378m     IFEQ DEBUG
00000166  1639 00C00003            379m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016C  0803 0002                380m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000170  67F4                     381m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000172  13FC 0007 00C00007       382m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017A                           383m     ENDC
0000017A                           384m     
0000017A                 FALSE     385m     IFNE DEBUG
0000017A                           386m     ENDC
0000017A                           387m 
0000017A                           388m     ENDM
0000017A                           389  
0000017A  7E00                     390      MOVE.L #0,D7                                ; address accumulator
0000017C                           391  
0000017C  13FC 0002 00E00001       392      MOVE.B #2,DISPLAY
00000184                           393  MAIN_LOOP
00000184                           394m     PRINT_CHAR #'>',D3                          ; prompt
00000184                           395m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000184                 TRUE      396m     IFEQ DEBUG
00000184  1639 00C00003            397m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018A  0803 0002                398m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000018E  67F4                     399m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000190  13FC 003E 00C00007       400m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000198                           401m     ENDC
00000198                           402m     
00000198                 FALSE     403m     IFNE DEBUG
00000198                           404m     ENDC
00000198                           405m 
00000198                           406m     ENDM
00000198                           407m     PRINT_CHAR #32,D3                           ; space
00000198                           408m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000198                 TRUE      409m     IFEQ DEBUG
00000198  1639 00C00003            410m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000019E  0803 0002                411m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A2  67F4                     412m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A4  13FC 0020 00C00007       413m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AC                           414m     ENDC
000001AC                           415m     
000001AC                 FALSE     416m     IFNE DEBUG
000001AC                           417m     ENDC
000001AC                           418m 
000001AC                           419m     ENDM
000001AC                           420      
000001AC                           421  GET_INPUT
000001AC                           422m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AC                           423m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AC                 TRUE      424m     IFEQ DEBUG
000001AC  1639 00C00003            425m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B2  0803 0000                426m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B6  67F4                     427m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001B8                           428m     ENDC
000001B8                           429m     
000001B8                           430mm     READ_CHAR D2
000001B8                 TRUE      431mm     IFEQ DEBUG
000001B8  1439 00C00007            432mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001BE                           433mm     ENDC
000001BE                 FALSE     434mm     IFNE DEBUG
000001BE                           435mm     ENDC
000001BE                           436mm      
000001BE  B43C 001B                437mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C2  6700 FE44                438mm     BEQ START
000001C6                           439mm     ENDM
000001C6                           440m 
000001C6                 TRUE      441m     IFEQ DEBUG
000001C6                           442mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C6                           443mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C6                 TRUE      444mm     IFEQ DEBUG
000001C6  1639 00C00003            445mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CC  0803 0002                446mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D0  67F4                     447mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D2  13C2 00C00007            448mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001D8                           449mm     ENDC
000001D8                           450mm     
000001D8                 FALSE     451mm     IFNE DEBUG
000001D8                           452mm     ENDC
000001D8                           453mm 
000001D8                           454mm     ENDM
000001D8                           455m     ENDC
000001D8                           456m     ENDM
000001D8                           457      
000001D8                           458      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001D8  B43C 0030                459s     CMP.B   #'0',D2
000001DC  6D00 000E                460s     BLT _00000000
000001E0  B43C 0039                461s     CMP.B   #'9',D2
000001E4  6E00 0006                462s     BGT _00000000
000001E8  6000 0C4C                463          BRA HEX_DIGIT
000001EC                           464      ENDI
000001EC                           465s _00000000
000001EC                           466      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001EC  B43C 0041                467s     CMP.B   #'A',D2
000001F0  6D00 000E                468s     BLT _00000001
000001F4  B43C 0046                469s     CMP.B   #'F',D2
000001F8  6E00 0006                470s     BGT _00000001
000001FC  6000 0C38                471          BRA HEX_DIGIT
00000200                           472      ENDI
00000200                           473s _00000001
00000200                           474          
00000200  B43C 0077                475      CMP.B #'w',D2
00000204  6700 015A                476      BEQ W
00000208                           477      
00000208  B43C 006C                478      CMP.B #'l',D2
0000020C  6700 0ABC                479      BEQ L 
00000210                           480  
00000210                           481m     PRINT_CRLF D3
00000210                           482mm     PRINT_CHAR #13,D3                           ; CR
00000210                           483mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000210                 TRUE      484mm     IFEQ DEBUG
00000210  1639 00C00003            485mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000216  0803 0002                486mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000021A  67F4                     487mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0000021C  13FC 000D 00C00007       488mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000224                           489mm     ENDC
00000224                           490mm     
00000224                 FALSE     491mm     IFNE DEBUG
00000224                           492mm     ENDC
00000224                           493mm 
00000224                           494mm     ENDM
00000224                           495mm     PRINT_CHAR #10,D3                           ; LF
00000224                           496mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000224                 TRUE      497mm     IFEQ DEBUG
00000224  1639 00C00003            498mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000022A  0803 0002                499mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000022E  67F4                     500mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00000230  13FC 000A 00C00007       501mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000238                           502mm     ENDC
00000238                           503mm     
00000238                 FALSE     504mm     IFNE DEBUG
00000238                           505mm     ENDC
00000238                           506mm 
00000238                           507mm     ENDM
00000238                           508m     ENDM
00000238                           509   
00000238  B43C 003F                510      CMP.B #'?',D2
0000023C  6700 0050                511      BEQ H
00000240                           512  
00000240  B43C 0076                513      CMP.B #'v',D2
00000244  6700 006E                514      BEQ V
00000248                           515      
00000248  B43C 0072                516      CMP.B #'r',D2
0000024C  6700 008C                517      BEQ R
00000250                           518  
00000250  B43C 0073                519      CMP.B #'s',D2
00000254  6700 01D0                520      BEQ S
00000258                           521  
00000258  B43C 0067                522      CMP.B #'g',D2
0000025C  6700 095E                523      BEQ G   
00000260                           524  
00000260  B43C 007A                525      CMP.B #'z',D2
00000264  6700 095E                526      BEQ Z   
00000268                           527  
00000268  41F9 00000F18            528      LEA HUH,A0
0000026E                           529m     PRINT_STR A0,D3
0000026E                           530m LOOP_19
0000026E  0C10 0000                531m     CMP.B #0,(A0)                               ; 0 -> DONE
00000272  6700 0016                532m     BEQ EXIT_19
00000276                           533mm     PRINT_CHAR (A0)+,D3
00000276                           534mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      535mm     IFEQ DEBUG
00000276  1639 00C00003            536mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000027C  0803 0002                537mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000280  67F4                     538mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
00000282  13D8 00C00007            539mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000288                           540mm     ENDC
00000288                           541mm     
00000288                 FALSE     542mm     IFNE DEBUG
00000288                           543mm     ENDC
00000288                           544mm 
00000288                           545mm     ENDM
00000288  60E4                     546m     BRA LOOP_19
0000028A                           547m EXIT_19
0000028A                           548m     ENDM
0000028A                           549                         
0000028A  6000 FEF8                550      BRA MAIN_LOOP
0000028E                           551      
0000028E                           552  ; commands
0000028E                           553  H   
0000028E  41F9 00000E73            554      LEA HELP,A0
00000294                           555m     PRINT_STR A0,D3
00000294                           556m LOOP_21
00000294  0C10 0000                557m     CMP.B #0,(A0)                               ; 0 -> DONE
00000298  6700 0016                558m     BEQ EXIT_21
0000029C                           559mm     PRINT_CHAR (A0)+,D3
0000029C                           560mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      561mm     IFEQ DEBUG
0000029C  1639 00C00003            562mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                563mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     564mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
000002A8  13D8 00C00007            565mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002AE                           566mm     ENDC
000002AE                           567mm     
000002AE                 FALSE     568mm     IFNE DEBUG
000002AE                           569mm     ENDC
000002AE                           570mm 
000002AE                           571mm     ENDM
000002AE  60E4                     572m     BRA LOOP_21
000002B0                           573m EXIT_21
000002B0                           574m     ENDM
000002B0  6000 FED2                575      BRA MAIN_LOOP
000002B4                           576  
000002B4                           577  V   
000002B4  41F9 00000E56            578      LEA VERSION,A0
000002BA                           579m     PRINT_STR A0,D3       
000002BA                           580m LOOP_23
000002BA  0C10 0000                581m     CMP.B #0,(A0)                               ; 0 -> DONE
000002BE  6700 0016                582m     BEQ EXIT_23
000002C2                           583mm     PRINT_CHAR (A0)+,D3
000002C2                           584mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C2                 TRUE      585mm     IFEQ DEBUG
000002C2  1639 00C00003            586mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002C8  0803 0002                587mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002CC  67F4                     588mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
000002CE  13D8 00C00007            589mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D4                           590mm     ENDC
000002D4                           591mm     
000002D4                 FALSE     592mm     IFNE DEBUG
000002D4                           593mm     ENDC
000002D4                           594mm 
000002D4                           595mm     ENDM
000002D4  60E4                     596m     BRA LOOP_23
000002D6                           597m EXIT_23
000002D6                           598m     ENDM
000002D6  6000 FEAC                599      BRA MAIN_LOOP
000002DA                           600      
000002DA                           601  R   
000002DA  2047                     602      MOVE.L D7,A0                                ; address accumulator -> address register
000002DC  2A10                     603      MOVE.L (A0),D5                              ; read the memory and print it
000002DE                           604m     PRINT_REG D5,D3,D7,D6,A0
000002DE                           605mm     PRINT_CHAR #'0',D3                          ;0X HEADER
000002DE                           606mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      607mm     IFEQ DEBUG
000002DE  1639 00C00003            608mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002E4  0803 0002                609mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002E8  67F4                     610mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002EA  13FC 0030 00C00007       611mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002F2                           612mm     ENDC
000002F2                           613mm     
000002F2                 FALSE     614mm     IFNE DEBUG
000002F2                           615mm     ENDC
000002F2                           616mm 
000002F2                           617mm     ENDM
000002F2                           618mm     PRINT_CHAR #'x',D3
000002F2                           619mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F2                 TRUE      620mm     IFEQ DEBUG
000002F2  1639 00C00003            621mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002F8  0803 0002                622mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002FC  67F4                     623mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002FE  13FC 0078 00C00007       624mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000306                           625mm     ENDC
00000306                           626mm     
00000306                 FALSE     627mm     IFNE DEBUG
00000306                           628mm     ENDC
00000306                           629mm 
00000306                           630mm     ENDM
00000306  7C07                     631m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000308                           632m LOOP_25
00000308                           633mm     BIN2HEX D5,D7,A0
00000308  41F9 00000F7C            634mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000030E  E99D                     635mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000310  1E05                     636mm     MOVE.B D5,D7
00000312  0287 0000000F            637mm     ANDI.L #$F,D7
00000318  1E30 7000                638mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0000031C                           639mm     ENDM
0000031C                           640mm     PRINT_CHAR D7,D3
0000031C                           641mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031C                 TRUE      642mm     IFEQ DEBUG
0000031C  1639 00C00003            643mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000322  0803 0002                644mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000326  67F4                     645mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000328  13C7 00C00007            646mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000032E                           647mm     ENDC
0000032E                           648mm     
0000032E                 FALSE     649mm     IFNE DEBUG
0000032E                           650mm     ENDC
0000032E                           651mm 
0000032E                           652mm     ENDM
0000032E  57CE FFD8                653m     DBEQ D6,LOOP_25
00000332                           654m     ENDM
00000332                           655m     PRINT_CRLF D3
00000332                           656mm     PRINT_CHAR #13,D3                           ; CR
00000332                           657mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000332                 TRUE      658mm     IFEQ DEBUG
00000332  1639 00C00003            659mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000338  0803 0002                660mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000033C  67F4                     661mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
0000033E  13FC 000D 00C00007       662mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000346                           663mm     ENDC
00000346                           664mm     
00000346                 FALSE     665mm     IFNE DEBUG
00000346                           666mm     ENDC
00000346                           667mm 
00000346                           668mm     ENDM
00000346                           669mm     PRINT_CHAR #10,D3                           ; LF
00000346                           670mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000346                 TRUE      671mm     IFEQ DEBUG
00000346  1639 00C00003            672mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000034C  0803 0002                673mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000350  67F4                     674mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00000352  13FC 000A 00C00007       675mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000035A                           676mm     ENDC
0000035A                           677mm     
0000035A                 FALSE     678mm     IFNE DEBUG
0000035A                           679mm     ENDC
0000035A                           680mm 
0000035A                           681mm     ENDM
0000035A                           682m     ENDM
0000035A  7E00                     683      MOVE.L #0,D7                                ; clear the now used address accumulator
0000035C  6000 FE26                684      BRA MAIN_LOOP
00000360                           685  
00000360                           686  W
00000360  7A00                     687      MOVE.L #0,D5                                ; D5 will be the value to write            
00000362                           688  
00000362                           689m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000362                           690m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000362                 TRUE      691m     IFEQ DEBUG
00000362  1639 00C00003            692m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000368  0803 0000                693m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000036C  67F4                     694m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
0000036E                           695m     ENDC
0000036E                           696m     
0000036E                           697mm     READ_CHAR D2
0000036E                 TRUE      698mm     IFEQ DEBUG
0000036E  1439 00C00007            699mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000374                           700mm     ENDC
00000374                 FALSE     701mm     IFNE DEBUG
00000374                           702mm     ENDC
00000374                           703mm      
00000374  B43C 001B                704mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000378  6700 FC8E                705mm     BEQ START
0000037C                           706mm     ENDM
0000037C                           707m 
0000037C                 TRUE      708m     IFEQ DEBUG
0000037C                           709mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000037C                           710mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037C                 TRUE      711mm     IFEQ DEBUG
0000037C  1639 00C00003            712mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000382  0803 0002                713mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000386  67F4                     714mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
00000388  13C2 00C00007            715mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000038E                           716mm     ENDC
0000038E                           717mm     
0000038E                 FALSE     718mm     IFNE DEBUG
0000038E                           719mm     ENDC
0000038E                           720mm 
0000038E                           721mm     ENDM
0000038E                           722m     ENDC
0000038E                           723m     ENDM
0000038E                           724m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0000038E  41F9 00000F8C            725m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000394  0402 0030                726m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000398  C4BC 000000FF            727m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000039E  1430 2000                728m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003A2                           729m     ENDM
000003A2  1A02                     730      MOVE.B D2,D5                                ; put at bottom of D5
000003A4                           731  
000003A4  3C3C 0006                732      MOVE #6,D6                                  ; 7 bytes left to read
000003A8                           733      
000003A8                           734  READ_DATA_TO_POKE
000003A8  E98D                     735      LSL.L #4,D5                                 ; make what we have so far more significant
000003AA                           736m     WAIT_CHAR D2,D3                             ; next character -> D2
000003AA                           737m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AA                 TRUE      738m     IFEQ DEBUG
000003AA  1639 00C00003            739m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003B0  0803 0000                740m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003B4  67F4                     741m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
000003B6                           742m     ENDC
000003B6                           743m     
000003B6                           744mm     READ_CHAR D2
000003B6                 TRUE      745mm     IFEQ DEBUG
000003B6  1439 00C00007            746mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003BC                           747mm     ENDC
000003BC                 FALSE     748mm     IFNE DEBUG
000003BC                           749mm     ENDC
000003BC                           750mm      
000003BC  B43C 001B                751mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003C0  6700 FC46                752mm     BEQ START
000003C4                           753mm     ENDM
000003C4                           754m 
000003C4                 TRUE      755m     IFEQ DEBUG
000003C4                           756mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003C4                           757mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C4                 TRUE      758mm     IFEQ DEBUG
000003C4  1639 00C00003            759mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003CA  0803 0002                760mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003CE  67F4                     761mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003D0  13C2 00C00007            762mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003D6                           763mm     ENDC
000003D6                           764mm     
000003D6                 FALSE     765mm     IFNE DEBUG
000003D6                           766mm     ENDC
000003D6                           767mm 
000003D6                           768mm     ENDM
000003D6                           769m     ENDC
000003D6                           770m     ENDM
000003D6                           771m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003D6  41F9 00000F8C            772m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003DC  0402 0030                773m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003E0  C4BC 000000FF            774m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003E6  1430 2000                775m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003EA                           776m     ENDM
000003EA  8A02                     777      OR.B D2,D5
000003EC  023C 00FB                778      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
000003F0  57CE FFB6                779      DBEQ D6,READ_DATA_TO_POKE
000003F4                           780      
000003F4  2047                     781      MOVE.L D7,A0                                ; address accumulator -> address register
000003F6  7E00                     782      MOVE.L #0,D7                                ; clear the now used address accumulator
000003F8                           783      
000003F8  2085                     784      MOVE.L D5,(A0)                              ; write the data
000003FA                           785  
000003FA                           786m     PRINT_CRLF D3
000003FA                           787mm     PRINT_CHAR #13,D3                           ; CR
000003FA                           788mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003FA                 TRUE      789mm     IFEQ DEBUG
000003FA  1639 00C00003            790mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000400  0803 0002                791mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000404  67F4                     792mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000406  13FC 000D 00C00007       793mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000040E                           794mm     ENDC
0000040E                           795mm     
0000040E                 FALSE     796mm     IFNE DEBUG
0000040E                           797mm     ENDC
0000040E                           798mm 
0000040E                           799mm     ENDM
0000040E                           800mm     PRINT_CHAR #10,D3                           ; LF
0000040E                           801mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040E                 TRUE      802mm     IFEQ DEBUG
0000040E  1639 00C00003            803mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000414  0803 0002                804mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000418  67F4                     805mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0000041A  13FC 000A 00C00007       806mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000422                           807mm     ENDC
00000422                           808mm     
00000422                 FALSE     809mm     IFNE DEBUG
00000422                           810mm     ENDC
00000422                           811mm 
00000422                           812mm     ENDM
00000422                           813m     ENDM
00000422  6000 FD60                814      BRA MAIN_LOOP
00000426                           815  
00000426                           816  ; register map for S
00000426                           817  ; A0 - start address
00000426                           818  ; A1 - offset
00000426                           819  ; A2 - next address to write
00000426                           820  ; A3 - next location (jmp)
00000426                           821  ; A4 - Working Address Register
00000426                           822  ; D0 - record count
00000426                           823  ; D1 - 'S', record type, data byte
00000426                           824  ; D2 - checksum
00000426                           825  ; D3 - data byte count
00000426                           826  ; D4 - read address, moved into A2
00000426                           827  ; D5 - temp
00000426                           828  ; D6 - temp
00000426                           829  ; D7 - temp
00000426                           830  S
00000426  2078 0000                831      MOVE.L 0,A0                                 ; start address -> A0
0000042A  2247                     832      MOVE.L D7,A1                                ; grab the address accumulator (offset) into A1
0000042C                           833      
0000042C  7000                     834      MOVE.L #0,D0                                ; count of records read -> D0
0000042E                           835          
0000042E                           836  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
0000042E                           837m     DOWNLOAD D1                 
0000042E                           838m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042E                           839m 
0000042E  1239 00C00003            840m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000434  0801 0000                841m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000438  6700 0010                842m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0000043C                           843m  
0000043C                           844mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000043C                 TRUE      845mm     IFEQ DEBUG
0000043C  1239 00C00007            846mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
00000442                           847mm     ENDC
00000442                 FALSE     848mm     IFNE DEBUG
00000442                           849mm     ENDC
00000442                           850mm      
00000442  B23C 001B                851mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000446  6700 FBC0                852mm     BEQ START
0000044A                           853mm     ENDM
0000044A                           854m CONTINUE_44
0000044A  1239 00C00013            855m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
00000450  0801 0000                856m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000454  67D8                     857m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
00000456                           858m     
00000456  1239 00C00017            859m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
0000045C  13C1 00E00001            860m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
00000462                           861m     
00000462                           862m     ENDM
00000462  B23C 0053                863      CMP.B #'S',D1                               ; found S?    
00000466  66C6                     864      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
00000468                           865      
00000468                           866m     PRINT_CHAR #'S',D5                          ; print the S
00000468                           867m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      868m     IFEQ DEBUG
00000468  1A39 00C00003            869m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000046E  0805 0002                870m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000472  67F4                     871m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000474  13FC 0053 00C00007       872m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000047C                           873m     ENDC
0000047C                           874m     
0000047C                 FALSE     875m     IFNE DEBUG
0000047C                           876m     ENDC
0000047C                           877m 
0000047C                           878m     ENDM
0000047C  5280                     879      ADD.L #1,D0                                 ; read another S record, increment count
0000047E                           880      
0000047E                           881m     DOWNLOAD D1                                 ; read the record identifier and echo it back
0000047E                           882m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047E                           883m 
0000047E  1239 00C00003            884m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000484  0801 0000                885m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000488  6700 0010                886m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
0000048C                           887m  
0000048C                           888mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000048C                 TRUE      889mm     IFEQ DEBUG
0000048C  1239 00C00007            890mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
00000492                           891mm     ENDC
00000492                 FALSE     892mm     IFNE DEBUG
00000492                           893mm     ENDC
00000492                           894mm      
00000492  B23C 001B                895mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000496  6700 FB70                896mm     BEQ START
0000049A                           897mm     ENDM
0000049A                           898m CONTINUE_47
0000049A  1239 00C00013            899m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
000004A0  0801 0000                900m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000004A4  67D8                     901m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
000004A6                           902m     
000004A6  1239 00C00017            903m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
000004AC  13C1 00E00001            904m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
000004B2                           905m     
000004B2                           906m     ENDM
000004B2                           907m     PRINT_CHAR D1,D5
000004B2                           908m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B2                 TRUE      909m     IFEQ DEBUG
000004B2  1A39 00C00003            910m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004B8  0805 0002                911m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004BC  67F4                     912m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
000004BE  13C1 00C00007            913m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004C4                           914m     ENDC
000004C4                           915m     
000004C4                 FALSE     916m     IFNE DEBUG
000004C4                           917m     ENDC
000004C4                           918m 
000004C4                           919m     ENDM
000004C4                           920  
000004C4  7400                     921      MOVE.L #0,D2                                ; clear the checksum
000004C6                           922  
000004C6  7600                     923      MOVE.L #0,D3                                ; read the 2 digit byte count -> D3
000004C8                           924m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000004C8  1E3C 0002                925m     MOVE.B #2,D7
000004CC                           926m     WHILE.B D7 <GT> 0 DO
000004CC                           927ms _10000000
000004CC  BE38 0000                928ms     CMP.B   0,D7
000004D0  6F00 0064                929ms     BLE _10000001
000004D4  E98B                     930m         LSL.L #4,D3                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000004D6                           931mm         DOWNLOAD D5
000004D6                           932mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                           933mm 
000004D6  1A39 00C00003            934mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004DC  0805 0000                935mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004E0  6700 0010                936mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
000004E4                           937mm  
000004E4                           938mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004E4                 TRUE      939mmm     IFEQ DEBUG
000004E4  1A39 00C00007            940mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000004EA                           941mmm     ENDC
000004EA                 FALSE     942mmm     IFNE DEBUG
000004EA                           943mmm     ENDC
000004EA                           944mmm      
000004EA  BA3C 001B                945mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004EE  6700 FB18                946mmm     BEQ START
000004F2                           947mmm     ENDM
000004F2                           948mm CONTINUE_51
000004F2  1A39 00C00013            949mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000004F8  0805 0000                950mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004FC  67D8                     951mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
000004FE                           952mm     
000004FE  1A39 00C00017            953mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000504  13C5 00E00001            954mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000050A                           955mm     
0000050A                           956mm     ENDM
0000050A                           957mm         PRINT_CHAR D5,D6
0000050A                           958mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      959mm     IFEQ DEBUG
0000050A  1C39 00C00003            960mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000510  0806 0002                961mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000514  67F4                     962mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00000516  13C5 00C00007            963mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000051C                           964mm     ENDC
0000051C                           965mm     
0000051C                 FALSE     966mm     IFNE DEBUG
0000051C                           967mm     ENDC
0000051C                           968mm 
0000051C                           969mm     ENDM
0000051C                           970mm         HEX2BIN D5,D5,A4
0000051C  49F9 00000F8C            971mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000522  0405 0030                972mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000526  CABC 000000FF            973mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
0000052C  1A34 5000                974mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000530                           975mm     ENDM
00000530  8605                     976m         OR.B D5,D3
00000532  5307                     977m         SUB.B #1,D7
00000534                           978m     ENDW
00000534  6096                     979ms     BRA _10000000
00000536                           980ms _10000001
00000536                           981m     
00000536  7A00                     982m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000538  1A03                     983m     MOVE.B D3,D5
0000053A  D483                     984m     ADD.L D3,D2
0000053C                           985m 
0000053C                           986m     ENDM
0000053C                           987  
0000053C                           988      IF.B D1 <EQ> #'0' THEN.L                    ; header, just ignore it
0000053C  B23C 0030                989s     CMP.B   #'0',D1
00000540  6600 0032                990s     BNE.L   _00000002
00000544                           991m         PRINT_CRLF D5
00000544                           992mm     PRINT_CHAR #13,D5                           ; CR
00000544                           993mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                 TRUE      994mm     IFEQ DEBUG
00000544  1A39 00C00003            995mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000054A  0805 0002                996mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000054E  67F4                     997mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
00000550  13FC 000D 00C00007       998mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000558                           999mm     ENDC
00000558                          1000mm     
00000558                 FALSE    1001mm     IFNE DEBUG
00000558                          1002mm     ENDC
00000558                          1003mm 
00000558                          1004mm     ENDM
00000558                          1005mm     PRINT_CHAR #10,D5                           ; LF
00000558                          1006mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1007mm     IFEQ DEBUG
00000558  1A39 00C00003           1008mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000055E  0805 0002               1009mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000562  67F4                    1010mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
00000564  13FC 000A 00C00007      1011mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000056C                          1012mm     ENDC
0000056C                          1013mm     
0000056C                 FALSE    1014mm     IFNE DEBUG
0000056C                          1015mm     ENDC
0000056C                          1016mm 
0000056C                          1017mm     ENDM
0000056C                          1018m     ENDM
0000056C  6000 FEC0               1019          BRA WAIT_FOR_SRECORD
00000570                          1020      ELSE
00000570  6000 0408               1021s     BRA _00000003
00000574                          1022s _00000002
00000574                          1023          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00000574  B23C 0031               1024s     CMP.B   #'1',D1
00000578  6708                    1025s     BEQ.S   _00000004
0000057A  B23C 0032               1026s     CMP.B   #'2',D1
0000057E  6600 0200               1027s     BNE.L   _00000005
00000582                          1028s _00000004
00000582  5783                    1029              SUB.L #3,D3                         ; subtract three bytes for 16 bit address and 1 byte checksum
00000584                          1030      
00000584  7800                    1031              MOVE.L #0,D4                        ; read two bytes of address
00000586                          1032m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
00000586  1E3C 0002               1033m     MOVE.B #2,D7
0000058A                          1034m     WHILE.B D7 <GT> 0 DO
0000058A                          1035ms _10000002
0000058A  BE38 0000               1036ms     CMP.B   0,D7
0000058E  6F00 0064               1037ms     BLE _10000003
00000592  E98C                    1038m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000594                          1039mm         DOWNLOAD D5
00000594                          1040mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                          1041mm 
00000594  1A39 00C00003           1042mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000059A  0805 0000               1043mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000059E  6700 0010               1044mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
000005A2                          1045mm  
000005A2                          1046mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005A2                 TRUE     1047mmm     IFEQ DEBUG
000005A2  1A39 00C00007           1048mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000005A8                          1049mmm     ENDC
000005A8                 FALSE    1050mmm     IFNE DEBUG
000005A8                          1051mmm     ENDC
000005A8                          1052mmm      
000005A8  BA3C 001B               1053mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005AC  6700 FA5A               1054mmm     BEQ START
000005B0                          1055mmm     ENDM
000005B0                          1056mm CONTINUE_59
000005B0  1A39 00C00013           1057mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000005B6  0805 0000               1058mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005BA  67D8                    1059mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
000005BC                          1060mm     
000005BC  1A39 00C00017           1061mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000005C2  13C5 00E00001           1062mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000005C8                          1063mm     
000005C8                          1064mm     ENDM
000005C8                          1065mm         PRINT_CHAR D5,D6
000005C8                          1066mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005C8                 TRUE     1067mm     IFEQ DEBUG
000005C8  1C39 00C00003           1068mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005CE  0806 0002               1069mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005D2  67F4                    1070mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
000005D4  13C5 00C00007           1071mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005DA                          1072mm     ENDC
000005DA                          1073mm     
000005DA                 FALSE    1074mm     IFNE DEBUG
000005DA                          1075mm     ENDC
000005DA                          1076mm 
000005DA                          1077mm     ENDM
000005DA                          1078mm         HEX2BIN D5,D5,A4
000005DA  49F9 00000F8C           1079mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000005E0  0405 0030               1080mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005E4  CABC 000000FF           1081mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000005EA  1A34 5000               1082mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000005EE                          1083mm     ENDM
000005EE  8805                    1084m         OR.B D5,D4
000005F0  5307                    1085m         SUB.B #1,D7
000005F2                          1086m     ENDW
000005F2  6096                    1087ms     BRA _10000002
000005F4                          1088ms _10000003
000005F4                          1089m     
000005F4  7A00                    1090m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005F6  1A04                    1091m     MOVE.B D4,D5
000005F8  D484                    1092m     ADD.L D4,D2
000005FA                          1093m 
000005FA                          1094m     ENDM
000005FA                          1095m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
000005FA  1E3C 0002               1096m     MOVE.B #2,D7
000005FE                          1097m     WHILE.B D7 <GT> 0 DO
000005FE                          1098ms _10000004
000005FE  BE38 0000               1099ms     CMP.B   0,D7
00000602  6F00 0064               1100ms     BLE _10000005
00000606  E98C                    1101m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000608                          1102mm         DOWNLOAD D5
00000608                          1103mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1104mm 
00000608  1A39 00C00003           1105mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000060E  0805 0000               1106mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000612  6700 0010               1107mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
00000616                          1108mm  
00000616                          1109mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000616                 TRUE     1110mmm     IFEQ DEBUG
00000616  1A39 00C00007           1111mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000061C                          1112mmm     ENDC
0000061C                 FALSE    1113mmm     IFNE DEBUG
0000061C                          1114mmm     ENDC
0000061C                          1115mmm      
0000061C  BA3C 001B               1116mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000620  6700 F9E6               1117mmm     BEQ START
00000624                          1118mmm     ENDM
00000624                          1119mm CONTINUE_64
00000624  1A39 00C00013           1120mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000062A  0805 0000               1121mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000062E  67D8                    1122mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000630                          1123mm     
00000630  1A39 00C00017           1124mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000636  13C5 00E00001           1125mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000063C                          1126mm     
0000063C                          1127mm     ENDM
0000063C                          1128mm         PRINT_CHAR D5,D6
0000063C                          1129mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063C                 TRUE     1130mm     IFEQ DEBUG
0000063C  1C39 00C00003           1131mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000642  0806 0002               1132mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000646  67F4                    1133mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
00000648  13C5 00C00007           1134mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000064E                          1135mm     ENDC
0000064E                          1136mm     
0000064E                 FALSE    1137mm     IFNE DEBUG
0000064E                          1138mm     ENDC
0000064E                          1139mm 
0000064E                          1140mm     ENDM
0000064E                          1141mm         HEX2BIN D5,D5,A4
0000064E  49F9 00000F8C           1142mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000654  0405 0030               1143mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000658  CABC 000000FF           1144mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
0000065E  1A34 5000               1145mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000662                          1146mm     ENDM
00000662  8805                    1147m         OR.B D5,D4
00000664  5307                    1148m         SUB.B #1,D7
00000666                          1149m     ENDW
00000666  6096                    1150ms     BRA _10000004
00000668                          1151ms _10000005
00000668                          1152m     
00000668  7A00                    1153m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000066A  1A04                    1154m     MOVE.B D4,D5
0000066C  D484                    1155m     ADD.L D4,D2
0000066E                          1156m 
0000066E                          1157m     ENDM
0000066E                          1158              
0000066E                          1159              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
0000066E  B23C 0032               1160s     CMP.B   #'2',D1
00000672  6600 0078               1161s     BNE.L   _00000006
00000676  5383                    1162                  SUB.L #1,D3                     ; subtract an extra bytes for 24 bit address    
00000678                          1163m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00000678  1E3C 0002               1164m     MOVE.B #2,D7
0000067C                          1165m     WHILE.B D7 <GT> 0 DO
0000067C                          1166ms _10000006
0000067C  BE38 0000               1167ms     CMP.B   0,D7
00000680  6F00 0064               1168ms     BLE _10000007
00000684  E98C                    1169m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000686                          1170mm         DOWNLOAD D5
00000686                          1171mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000686                          1172mm 
00000686  1A39 00C00003           1173mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000068C  0805 0000               1174mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000690  6700 0010               1175mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00000694                          1176mm  
00000694                          1177mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000694                 TRUE     1178mmm     IFEQ DEBUG
00000694  1A39 00C00007           1179mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000069A                          1180mmm     ENDC
0000069A                 FALSE    1181mmm     IFNE DEBUG
0000069A                          1182mmm     ENDC
0000069A                          1183mmm      
0000069A  BA3C 001B               1184mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000069E  6700 F968               1185mmm     BEQ START
000006A2                          1186mmm     ENDM
000006A2                          1187mm CONTINUE_69
000006A2  1A39 00C00013           1188mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000006A8  0805 0000               1189mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006AC  67D8                    1190mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
000006AE                          1191mm     
000006AE  1A39 00C00017           1192mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000006B4  13C5 00E00001           1193mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000006BA                          1194mm     
000006BA                          1195mm     ENDM
000006BA                          1196mm         PRINT_CHAR D5,D6
000006BA                          1197mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BA                 TRUE     1198mm     IFEQ DEBUG
000006BA  1C39 00C00003           1199mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006C0  0806 0002               1200mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006C4  67F4                    1201mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
000006C6  13C5 00C00007           1202mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006CC                          1203mm     ENDC
000006CC                          1204mm     
000006CC                 FALSE    1205mm     IFNE DEBUG
000006CC                          1206mm     ENDC
000006CC                          1207mm 
000006CC                          1208mm     ENDM
000006CC                          1209mm         HEX2BIN D5,D5,A4
000006CC  49F9 00000F8C           1210mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000006D2  0405 0030               1211mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006D6  CABC 000000FF           1212mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000006DC  1A34 5000               1213mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000006E0                          1214mm     ENDM
000006E0  8805                    1215m         OR.B D5,D4
000006E2  5307                    1216m         SUB.B #1,D7
000006E4                          1217m     ENDW
000006E4  6096                    1218ms     BRA _10000006
000006E6                          1219ms _10000007
000006E6                          1220m     
000006E6  7A00                    1221m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006E8  1A04                    1222m     MOVE.B D4,D5
000006EA  D484                    1223m     ADD.L D4,D2
000006EC                          1224m 
000006EC                          1225m     ENDM
000006EC                          1226              ENDI
000006EC                          1227s _00000006
000006EC                          1228              
000006EC  2444                    1229              MOVE.L D4,A2                        ; put the address in an address register
000006EE  D5C9                    1230              ADD.L A1,A2                         ; add in the offset
000006F0                          1231  
000006F0                          1232              WHILE.L D3 <GT> #0 DO               ; read the data bytes                
000006F0                          1233s _10000008
000006F0  B6BC 00000000           1234s     CMP.L   #0,D3
000006F6  6F00 0080               1235s     BLE _10000009
000006FA  7200                    1236                  MOVE.L #0,D1                    ; D1 holds the byte
000006FC                          1237m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
000006FC  1E3C 0002               1238m     MOVE.B #2,D7
00000700                          1239m     WHILE.B D7 <GT> 0 DO
00000700                          1240ms _1000000A
00000700  BE38 0000               1241ms     CMP.B   0,D7
00000704  6F00 0064               1242ms     BLE _1000000B
00000708  E989                    1243m         LSL.L #4,D1                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000070A                          1244mm         DOWNLOAD D5
0000070A                          1245mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070A                          1246mm 
0000070A  1A39 00C00003           1247mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000710  0805 0000               1248mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000714  6700 0010               1249mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000718                          1250mm  
00000718                          1251mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000718                 TRUE     1252mmm     IFEQ DEBUG
00000718  1A39 00C00007           1253mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000071E                          1254mmm     ENDC
0000071E                 FALSE    1255mmm     IFNE DEBUG
0000071E                          1256mmm     ENDC
0000071E                          1257mmm      
0000071E  BA3C 001B               1258mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000722  6700 F8E4               1259mmm     BEQ START
00000726                          1260mmm     ENDM
00000726                          1261mm CONTINUE_74
00000726  1A39 00C00013           1262mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000072C  0805 0000               1263mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000730  67D8                    1264mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
00000732                          1265mm     
00000732  1A39 00C00017           1266mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000738  13C5 00E00001           1267mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000073E                          1268mm     
0000073E                          1269mm     ENDM
0000073E                          1270mm         PRINT_CHAR D5,D6
0000073E                          1271mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000073E                 TRUE     1272mm     IFEQ DEBUG
0000073E  1C39 00C00003           1273mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000744  0806 0002               1274mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000748  67F4                    1275mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
0000074A  13C5 00C00007           1276mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000750                          1277mm     ENDC
00000750                          1278mm     
00000750                 FALSE    1279mm     IFNE DEBUG
00000750                          1280mm     ENDC
00000750                          1281mm 
00000750                          1282mm     ENDM
00000750                          1283mm         HEX2BIN D5,D5,A4
00000750  49F9 00000F8C           1284mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000756  0405 0030               1285mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000075A  CABC 000000FF           1286mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000760  1A34 5000               1287mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000764                          1288mm     ENDM
00000764  8205                    1289m         OR.B D5,D1
00000766  5307                    1290m         SUB.B #1,D7
00000768                          1291m     ENDW
00000768  6096                    1292ms     BRA _1000000A
0000076A                          1293ms _1000000B
0000076A                          1294m     
0000076A  7A00                    1295m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000076C  1A01                    1296m     MOVE.B D1,D5
0000076E  D481                    1297m     ADD.L D1,D2
00000770                          1298m 
00000770                          1299m     ENDM
00000770                          1300                          
00000770  14C1                    1301                  MOVE.B D1,(A2)+                 ; store it!
00000772                          1302  
00000772  5383                    1303                  SUB.L #1,D3                     ; 1 less byte to go
00000774                          1304              ENDW
00000774  6000 FF7A               1305s     BRA _10000008
00000778                          1306s _10000009
00000778                          1307          
00000778  47F8 042E               1308              LEA WAIT_FOR_SRECORD,A3             ; next place to go
0000077C                          1309          ELSE
0000077C  6000 01FC               1310s     BRA _00000007
00000780                          1311s _00000005
00000780                          1312              IF.B D1 <EQ> #'8' THEN.L            ; termination record, exit
00000780  B23C 0038               1313s     CMP.B   #'8',D1
00000784  6600 016C               1314s     BNE.L   _00000008
00000788  7800                    1315                  MOVE.L #0,D4                    ; read the 24 bit start address
0000078A                          1316m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0000078A  1E3C 0002               1317m     MOVE.B #2,D7
0000078E                          1318m     WHILE.B D7 <GT> 0 DO
0000078E                          1319ms _1000000C
0000078E  BE38 0000               1320ms     CMP.B   0,D7
00000792  6F00 0064               1321ms     BLE _1000000D
00000796  E98C                    1322m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000798                          1323mm         DOWNLOAD D5
00000798                          1324mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                          1325mm 
00000798  1A39 00C00003           1326mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000079E  0805 0000               1327mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007A2  6700 0010               1328mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
000007A6                          1329mm  
000007A6                          1330mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007A6                 TRUE     1331mmm     IFEQ DEBUG
000007A6  1A39 00C00007           1332mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000007AC                          1333mmm     ENDC
000007AC                 FALSE    1334mmm     IFNE DEBUG
000007AC                          1335mmm     ENDC
000007AC                          1336mmm      
000007AC  BA3C 001B               1337mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007B0  6700 F856               1338mmm     BEQ START
000007B4                          1339mmm     ENDM
000007B4                          1340mm CONTINUE_79
000007B4  1A39 00C00013           1341mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000007BA  0805 0000               1342mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007BE  67D8                    1343mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
000007C0                          1344mm     
000007C0  1A39 00C00017           1345mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000007C6  13C5 00E00001           1346mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000007CC                          1347mm     
000007CC                          1348mm     ENDM
000007CC                          1349mm         PRINT_CHAR D5,D6
000007CC                          1350mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CC                 TRUE     1351mm     IFEQ DEBUG
000007CC  1C39 00C00003           1352mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007D2  0806 0002               1353mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007D6  67F4                    1354mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
000007D8  13C5 00C00007           1355mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007DE                          1356mm     ENDC
000007DE                          1357mm     
000007DE                 FALSE    1358mm     IFNE DEBUG
000007DE                          1359mm     ENDC
000007DE                          1360mm 
000007DE                          1361mm     ENDM
000007DE                          1362mm         HEX2BIN D5,D5,A4
000007DE  49F9 00000F8C           1363mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000007E4  0405 0030               1364mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007E8  CABC 000000FF           1365mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000007EE  1A34 5000               1366mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000007F2                          1367mm     ENDM
000007F2  8805                    1368m         OR.B D5,D4
000007F4  5307                    1369m         SUB.B #1,D7
000007F6                          1370m     ENDW
000007F6  6096                    1371ms     BRA _1000000C
000007F8                          1372ms _1000000D
000007F8                          1373m     
000007F8  7A00                    1374m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007FA  1A04                    1375m     MOVE.B D4,D5
000007FC  D484                    1376m     ADD.L D4,D2
000007FE                          1377m 
000007FE                          1378m     ENDM
000007FE                          1379m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
000007FE  1E3C 0002               1380m     MOVE.B #2,D7
00000802                          1381m     WHILE.B D7 <GT> 0 DO
00000802                          1382ms _1000000E
00000802  BE38 0000               1383ms     CMP.B   0,D7
00000806  6F00 0064               1384ms     BLE _1000000F
0000080A  E98C                    1385m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000080C                          1386mm         DOWNLOAD D5
0000080C                          1387mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                          1388mm 
0000080C  1A39 00C00003           1389mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000812  0805 0000               1390mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000816  6700 0010               1391mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
0000081A                          1392mm  
0000081A                          1393mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000081A                 TRUE     1394mmm     IFEQ DEBUG
0000081A  1A39 00C00007           1395mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000820                          1396mmm     ENDC
00000820                 FALSE    1397mmm     IFNE DEBUG
00000820                          1398mmm     ENDC
00000820                          1399mmm      
00000820  BA3C 001B               1400mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000824  6700 F7E2               1401mmm     BEQ START
00000828                          1402mmm     ENDM
00000828                          1403mm CONTINUE_84
00000828  1A39 00C00013           1404mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000082E  0805 0000               1405mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000832  67D8                    1406mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
00000834                          1407mm     
00000834  1A39 00C00017           1408mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000083A  13C5 00E00001           1409mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000840                          1410mm     
00000840                          1411mm     ENDM
00000840                          1412mm         PRINT_CHAR D5,D6
00000840                          1413mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                 TRUE     1414mm     IFEQ DEBUG
00000840  1C39 00C00003           1415mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000846  0806 0002               1416mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000084A  67F4                    1417mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
0000084C  13C5 00C00007           1418mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000852                          1419mm     ENDC
00000852                          1420mm     
00000852                 FALSE    1421mm     IFNE DEBUG
00000852                          1422mm     ENDC
00000852                          1423mm 
00000852                          1424mm     ENDM
00000852                          1425mm         HEX2BIN D5,D5,A4
00000852  49F9 00000F8C           1426mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000858  0405 0030               1427mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000085C  CABC 000000FF           1428mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000862  1A34 5000               1429mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000866                          1430mm     ENDM
00000866  8805                    1431m         OR.B D5,D4
00000868  5307                    1432m         SUB.B #1,D7
0000086A                          1433m     ENDW
0000086A  6096                    1434ms     BRA _1000000E
0000086C                          1435ms _1000000F
0000086C                          1436m     
0000086C  7A00                    1437m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000086E  1A04                    1438m     MOVE.B D4,D5
00000870  D484                    1439m     ADD.L D4,D2
00000872                          1440m 
00000872                          1441m     ENDM
00000872                          1442m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000872  1E3C 0002               1443m     MOVE.B #2,D7
00000876                          1444m     WHILE.B D7 <GT> 0 DO
00000876                          1445ms _10000010
00000876  BE38 0000               1446ms     CMP.B   0,D7
0000087A  6F00 0064               1447ms     BLE _10000011
0000087E  E98C                    1448m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000880                          1449mm         DOWNLOAD D5
00000880                          1450mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000880                          1451mm 
00000880  1A39 00C00003           1452mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000886  0805 0000               1453mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000088A  6700 0010               1454mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
0000088E                          1455mm  
0000088E                          1456mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000088E                 TRUE     1457mmm     IFEQ DEBUG
0000088E  1A39 00C00007           1458mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000894                          1459mmm     ENDC
00000894                 FALSE    1460mmm     IFNE DEBUG
00000894                          1461mmm     ENDC
00000894                          1462mmm      
00000894  BA3C 001B               1463mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000898  6700 F76E               1464mmm     BEQ START
0000089C                          1465mmm     ENDM
0000089C                          1466mm CONTINUE_89
0000089C  1A39 00C00013           1467mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000008A2  0805 0000               1468mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008A6  67D8                    1469mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
000008A8                          1470mm     
000008A8  1A39 00C00017           1471mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000008AE  13C5 00E00001           1472mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000008B4                          1473mm     
000008B4                          1474mm     ENDM
000008B4                          1475mm         PRINT_CHAR D5,D6
000008B4                          1476mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B4                 TRUE     1477mm     IFEQ DEBUG
000008B4  1C39 00C00003           1478mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008BA  0806 0002               1479mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008BE  67F4                    1480mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
000008C0  13C5 00C00007           1481mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008C6                          1482mm     ENDC
000008C6                          1483mm     
000008C6                 FALSE    1484mm     IFNE DEBUG
000008C6                          1485mm     ENDC
000008C6                          1486mm 
000008C6                          1487mm     ENDM
000008C6                          1488mm         HEX2BIN D5,D5,A4
000008C6  49F9 00000F8C           1489mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000008CC  0405 0030               1490mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D0  CABC 000000FF           1491mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000008D6  1A34 5000               1492mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000008DA                          1493mm     ENDM
000008DA  8805                    1494m         OR.B D5,D4
000008DC  5307                    1495m         SUB.B #1,D7
000008DE                          1496m     ENDW
000008DE  6096                    1497ms     BRA _10000010
000008E0                          1498ms _10000011
000008E0                          1499m     
000008E0  7A00                    1500m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008E2  1A04                    1501m     MOVE.B D4,D5
000008E4  D484                    1502m     ADD.L D4,D2
000008E6                          1503m 
000008E6                          1504m     ENDM
000008E6                          1505                    
000008E6  2044                    1506                  MOVE.L D4,A0                    ; start address -> A0
000008E8                          1507                  
000008E8  47F9 00000AC4           1508                  LEA DOWNLOAD_DONE,A3            ; next place to go
000008EE                          1509              ELSE
000008EE  6000 008A               1510s     BRA _00000009
000008F2                          1511s _00000008
000008F2                          1512m                 PRINT_CRLF D5
000008F2                          1513mm     PRINT_CHAR #13,D5                           ; CR
000008F2                          1514mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F2                 TRUE     1515mm     IFEQ DEBUG
000008F2  1A39 00C00003           1516mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008F8  0805 0002               1517mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008FC  67F4                    1518mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
000008FE  13FC 000D 00C00007      1519mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000906                          1520mm     ENDC
00000906                          1521mm     
00000906                 FALSE    1522mm     IFNE DEBUG
00000906                          1523mm     ENDC
00000906                          1524mm 
00000906                          1525mm     ENDM
00000906                          1526mm     PRINT_CHAR #10,D5                           ; LF
00000906                          1527mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000906                 TRUE     1528mm     IFEQ DEBUG
00000906  1A39 00C00003           1529mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000090C  0805 0002               1530mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000910  67F4                    1531mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00000912  13FC 000A 00C00007      1532mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000091A                          1533mm     ENDC
0000091A                          1534mm     
0000091A                 FALSE    1535mm     IFNE DEBUG
0000091A                          1536mm     ENDC
0000091A                          1537mm 
0000091A                          1538mm     ENDM
0000091A                          1539m     ENDM
0000091A                          1540              
0000091A  49F9 00000F41           1541                  LEA UNREC,A4                    ; warn for unrecognised type
00000920                          1542m                 PRINT_STR A4,D5
00000920                          1543m LOOP_96
00000920  0C14 0000               1544m     CMP.B #0,(A4)                               ; 0 -> DONE
00000924  6700 0016               1545m     BEQ EXIT_96
00000928                          1546mm     PRINT_CHAR (A4)+,D5
00000928                          1547mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000928                 TRUE     1548mm     IFEQ DEBUG
00000928  1A39 00C00003           1549mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000092E  0805 0002               1550mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000932  67F4                    1551mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
00000934  13DC 00C00007           1552mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000093A                          1553mm     ENDC
0000093A                          1554mm     
0000093A                 FALSE    1555mm     IFNE DEBUG
0000093A                          1556mm     ENDC
0000093A                          1557mm 
0000093A                          1558mm     ENDM
0000093A  60E4                    1559m     BRA LOOP_96
0000093C                          1560m EXIT_96
0000093C                          1561m     ENDM
0000093C                          1562m                 PRINT_CHAR D1,D5
0000093C                          1563m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000093C                 TRUE     1564m     IFEQ DEBUG
0000093C  1A39 00C00003           1565m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000942  0805 0002               1566m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000946  67F4                    1567m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00000948  13C1 00C00007           1568m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000094E                          1569m     ENDC
0000094E                          1570m     
0000094E                 FALSE    1571m     IFNE DEBUG
0000094E                          1572m     ENDC
0000094E                          1573m 
0000094E                          1574m     ENDM
0000094E                          1575m                 PRINT_CRLF D5
0000094E                          1576mm     PRINT_CHAR #13,D5                           ; CR
0000094E                          1577mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094E                 TRUE     1578mm     IFEQ DEBUG
0000094E  1A39 00C00003           1579mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000954  0805 0002               1580mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000958  67F4                    1581mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
0000095A  13FC 000D 00C00007      1582mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000962                          1583mm     ENDC
00000962                          1584mm     
00000962                 FALSE    1585mm     IFNE DEBUG
00000962                          1586mm     ENDC
00000962                          1587mm 
00000962                          1588mm     ENDM
00000962                          1589mm     PRINT_CHAR #10,D5                           ; LF
00000962                          1590mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1591mm     IFEQ DEBUG
00000962  1A39 00C00003           1592mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000968  0805 0002               1593mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1594mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0000096E  13FC 000A 00C00007      1595mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000976                          1596mm     ENDC
00000976                          1597mm     
00000976                 FALSE    1598mm     IFNE DEBUG
00000976                          1599mm     ENDC
00000976                          1600mm 
00000976                          1601mm     ENDM
00000976                          1602m     ENDM
00000976                          1603              
00000976  6000 FAB6               1604                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0000097A                          1605              ENDI
0000097A                          1606s _00000009
0000097A                          1607          ENDI
0000097A                          1608s _00000007
0000097A                          1609      ENDI
0000097A                          1610s _00000003
0000097A                          1611      
0000097A  7800                    1612      MOVE.L #0,D4                                ; read the checksum from the data stream add to our checksum: should make it FF
0000097C                          1613m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0000097C  1E3C 0002               1614m     MOVE.B #2,D7
00000980                          1615m     WHILE.B D7 <GT> 0 DO
00000980                          1616ms _10000012
00000980  BE38 0000               1617ms     CMP.B   0,D7
00000984  6F00 0064               1618ms     BLE _10000013
00000988  E98C                    1619m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000098A                          1620mm         DOWNLOAD D5
0000098A                          1621mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098A                          1622mm 
0000098A  1A39 00C00003           1623mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000990  0805 0000               1624mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000994  6700 0010               1625mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
00000998                          1626mm  
00000998                          1627mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000998                 TRUE     1628mmm     IFEQ DEBUG
00000998  1A39 00C00007           1629mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000099E                          1630mmm     ENDC
0000099E                 FALSE    1631mmm     IFNE DEBUG
0000099E                          1632mmm     ENDC
0000099E                          1633mmm      
0000099E  BA3C 001B               1634mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000009A2  6700 F664               1635mmm     BEQ START
000009A6                          1636mmm     ENDM
000009A6                          1637mm CONTINUE_103
000009A6  1A39 00C00013           1638mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000009AC  0805 0000               1639mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000009B0  67D8                    1640mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
000009B2                          1641mm     
000009B2  1A39 00C00017           1642mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000009B8  13C5 00E00001           1643mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000009BE                          1644mm     
000009BE                          1645mm     ENDM
000009BE                          1646mm         PRINT_CHAR D5,D6
000009BE                          1647mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BE                 TRUE     1648mm     IFEQ DEBUG
000009BE  1C39 00C00003           1649mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000009C4  0806 0002               1650mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000009C8  67F4                    1651mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
000009CA  13C5 00C00007           1652mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009D0                          1653mm     ENDC
000009D0                          1654mm     
000009D0                 FALSE    1655mm     IFNE DEBUG
000009D0                          1656mm     ENDC
000009D0                          1657mm 
000009D0                          1658mm     ENDM
000009D0                          1659mm         HEX2BIN D5,D5,A4
000009D0  49F9 00000F8C           1660mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000009D6  0405 0030               1661mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009DA  CABC 000000FF           1662mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000009E0  1A34 5000               1663mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000009E4                          1664mm     ENDM
000009E4  8805                    1665m         OR.B D5,D4
000009E6  5307                    1666m         SUB.B #1,D7
000009E8                          1667m     ENDW
000009E8  6096                    1668ms     BRA _10000012
000009EA                          1669ms _10000013
000009EA                          1670m     
000009EA  7A00                    1671m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009EC  1A04                    1672m     MOVE.B D4,D5
000009EE  D484                    1673m     ADD.L D4,D2
000009F0                          1674m 
000009F0                          1675m     ENDM
000009F0                          1676m     PRINT_CRLF D5
000009F0                          1677mm     PRINT_CHAR #13,D5                           ; CR
000009F0                          1678mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F0                 TRUE     1679mm     IFEQ DEBUG
000009F0  1A39 00C00003           1680mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009F6  0805 0002               1681mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009FA  67F4                    1682mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
000009FC  13FC 000D 00C00007      1683mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A04                          1684mm     ENDC
00000A04                          1685mm     
00000A04                 FALSE    1686mm     IFNE DEBUG
00000A04                          1687mm     ENDC
00000A04                          1688mm 
00000A04                          1689mm     ENDM
00000A04                          1690mm     PRINT_CHAR #10,D5                           ; LF
00000A04                          1691mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A04                 TRUE     1692mm     IFEQ DEBUG
00000A04  1A39 00C00003           1693mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A0A  0805 0002               1694mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0E  67F4                    1695mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A10  13FC 000A 00C00007      1696mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A18                          1697mm     ENDC
00000A18                          1698mm     
00000A18                 FALSE    1699mm     IFNE DEBUG
00000A18                          1700mm     ENDC
00000A18                          1701mm 
00000A18                          1702mm     ENDM
00000A18                          1703m     ENDM
00000A18                          1704          
00000A18                          1705      IF.B D2 <NE> #$FF THEN.L
00000A18  B43C 00FF               1706s     CMP.B   #$FF,D2
00000A1C  6700 00A4               1707s     BEQ.L   _0000000A
00000A20  49F9 00000F58           1708          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000A26                          1709m         PRINT_STR A4,D5
00000A26                          1710m LOOP_110
00000A26  0C14 0000               1711m     CMP.B #0,(A4)                               ; 0 -> DONE
00000A2A  6700 0016               1712m     BEQ EXIT_110
00000A2E                          1713mm     PRINT_CHAR (A4)+,D5
00000A2E                          1714mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2E                 TRUE     1715mm     IFEQ DEBUG
00000A2E  1A39 00C00003           1716mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A34  0805 0002               1717mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A38  67F4                    1718mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A3A  13DC 00C00007           1719mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A40                          1720mm     ENDC
00000A40                          1721mm     
00000A40                 FALSE    1722mm     IFNE DEBUG
00000A40                          1723mm     ENDC
00000A40                          1724mm 
00000A40                          1725mm     ENDM
00000A40  60E4                    1726m     BRA LOOP_110
00000A42                          1727m EXIT_110
00000A42                          1728m     ENDM
00000A42                          1729m         PRINT_REG D0,D5,D2,D6,A4
00000A42                          1730mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000A42                          1731mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A42                 TRUE     1732mm     IFEQ DEBUG
00000A42  1A39 00C00003           1733mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A48  0805 0002               1734mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A4C  67F4                    1735mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000A4E  13FC 0030 00C00007      1736mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A56                          1737mm     ENDC
00000A56                          1738mm     
00000A56                 FALSE    1739mm     IFNE DEBUG
00000A56                          1740mm     ENDC
00000A56                          1741mm 
00000A56                          1742mm     ENDM
00000A56                          1743mm     PRINT_CHAR #'x',D5
00000A56                          1744mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A56                 TRUE     1745mm     IFEQ DEBUG
00000A56  1A39 00C00003           1746mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A5C  0805 0002               1747mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A60  67F4                    1748mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000A62  13FC 0078 00C00007      1749mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A6A                          1750mm     ENDC
00000A6A                          1751mm     
00000A6A                 FALSE    1752mm     IFNE DEBUG
00000A6A                          1753mm     ENDC
00000A6A                          1754mm 
00000A6A                          1755mm     ENDM
00000A6A  7C07                    1756m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A6C                          1757m LOOP_112
00000A6C                          1758mm     BIN2HEX D0,D2,A4
00000A6C  49F9 00000F7C           1759mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000A72  E998                    1760mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A74  1400                    1761mm     MOVE.B D0,D2
00000A76  0282 0000000F           1762mm     ANDI.L #$F,D2
00000A7C  1434 2000               1763mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000A80                          1764mm     ENDM
00000A80                          1765mm     PRINT_CHAR D2,D5
00000A80                          1766mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1767mm     IFEQ DEBUG
00000A80  1A39 00C00003           1768mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A86  0805 0002               1769mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1770mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000A8C  13C2 00C00007           1771mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A92                          1772mm     ENDC
00000A92                          1773mm     
00000A92                 FALSE    1774mm     IFNE DEBUG
00000A92                          1775mm     ENDC
00000A92                          1776mm 
00000A92                          1777mm     ENDM
00000A92  57CE FFD8               1778m     DBEQ D6,LOOP_112
00000A96                          1779m     ENDM
00000A96                          1780m         PRINT_CRLF D5
00000A96                          1781mm     PRINT_CHAR #13,D5                           ; CR
00000A96                          1782mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A96                 TRUE     1783mm     IFEQ DEBUG
00000A96  1A39 00C00003           1784mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9C  0805 0002               1785mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA0  67F4                    1786mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AA2  13FC 000D 00C00007      1787mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000AAA                          1788mm     ENDC
00000AAA                          1789mm     
00000AAA                 FALSE    1790mm     IFNE DEBUG
00000AAA                          1791mm     ENDC
00000AAA                          1792mm 
00000AAA                          1793mm     ENDM
00000AAA                          1794mm     PRINT_CHAR #10,D5                           ; LF
00000AAA                          1795mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAA                 TRUE     1796mm     IFEQ DEBUG
00000AAA  1A39 00C00003           1797mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AB0  0805 0002               1798mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AB4  67F4                    1799mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000AB6  13FC 000A 00C00007      1800mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000ABE                          1801mm     ENDC
00000ABE                          1802mm     
00000ABE                 FALSE    1803mm     IFNE DEBUG
00000ABE                          1804mm     ENDC
00000ABE                          1805mm 
00000ABE                          1806mm     ENDM
00000ABE                          1807m     ENDM
00000ABE  6000 F6C4               1808          BRA MAIN_LOOP
00000AC2                          1809      ENDI
00000AC2                          1810s _0000000A
00000AC2                          1811      
00000AC2  4ED3                    1812      JMP (A3)
00000AC4                          1813  DOWNLOAD_DONE
00000AC4                          1814m     PRINT_REG D0,D5,D6,D2,A1                    ; print out number of Srecords read
00000AC4                          1815mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000AC4                          1816mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC4                 TRUE     1817mm     IFEQ DEBUG
00000AC4  1A39 00C00003           1818mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ACA  0805 0002               1819mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000ACE  67F4                    1820mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000AD0  13FC 0030 00C00007      1821mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AD8                          1822mm     ENDC
00000AD8                          1823mm     
00000AD8                 FALSE    1824mm     IFNE DEBUG
00000AD8                          1825mm     ENDC
00000AD8                          1826mm 
00000AD8                          1827mm     ENDM
00000AD8                          1828mm     PRINT_CHAR #'x',D5
00000AD8                          1829mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1830mm     IFEQ DEBUG
00000AD8  1A39 00C00003           1831mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ADE  0805 0002               1832mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1833mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000AE4  13FC 0078 00C00007      1834mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AEC                          1835mm     ENDC
00000AEC                          1836mm     
00000AEC                 FALSE    1837mm     IFNE DEBUG
00000AEC                          1838mm     ENDC
00000AEC                          1839mm 
00000AEC                          1840mm     ENDM
00000AEC  7407                    1841m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AEE                          1842m LOOP_120
00000AEE                          1843mm     BIN2HEX D0,D6,A1
00000AEE  43F9 00000F7C           1844mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000AF4  E998                    1845mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AF6  1C00                    1846mm     MOVE.B D0,D6
00000AF8  0286 0000000F           1847mm     ANDI.L #$F,D6
00000AFE  1C31 6000               1848mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000B02                          1849mm     ENDM
00000B02                          1850mm     PRINT_CHAR D6,D5
00000B02                          1851mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B02                 TRUE     1852mm     IFEQ DEBUG
00000B02  1A39 00C00003           1853mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B08  0805 0002               1854mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B0C  67F4                    1855mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B0E  13C6 00C00007           1856mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B14                          1857mm     ENDC
00000B14                          1858mm     
00000B14                 FALSE    1859mm     IFNE DEBUG
00000B14                          1860mm     ENDC
00000B14                          1861mm 
00000B14                          1862mm     ENDM
00000B14  57CA FFD8               1863m     DBEQ D2,LOOP_120
00000B18                          1864m     ENDM
00000B18  43F9 00000F1F           1865      LEA READ,A1
00000B1E                          1866m     PRINT_STR A1,D5
00000B1E                          1867m LOOP_125
00000B1E  0C11 0000               1868m     CMP.B #0,(A1)                               ; 0 -> DONE
00000B22  6700 0016               1869m     BEQ EXIT_125
00000B26                          1870mm     PRINT_CHAR (A1)+,D5
00000B26                          1871mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B26                 TRUE     1872mm     IFEQ DEBUG
00000B26  1A39 00C00003           1873mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B2C  0805 0002               1874mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B30  67F4                    1875mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B32  13D9 00C00007           1876mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B38                          1877mm     ENDC
00000B38                          1878mm     
00000B38                 FALSE    1879mm     IFNE DEBUG
00000B38                          1880mm     ENDC
00000B38                          1881mm 
00000B38                          1882mm     ENDM
00000B38  60E4                    1883m     BRA LOOP_125
00000B3A                          1884m EXIT_125
00000B3A                          1885m     ENDM
00000B3A  2E08                    1886      MOVE.L A0,D7                                ; set address accumulator to start address
00000B3C                          1887m     PRINT_REG D7,D5,D6,D2,A1                    ; print out start address
00000B3C                          1888mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000B3C                          1889mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     1890mm     IFEQ DEBUG
00000B3C  1A39 00C00003           1891mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B42  0805 0002               1892mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B46  67F4                    1893mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000B48  13FC 0030 00C00007      1894mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B50                          1895mm     ENDC
00000B50                          1896mm     
00000B50                 FALSE    1897mm     IFNE DEBUG
00000B50                          1898mm     ENDC
00000B50                          1899mm 
00000B50                          1900mm     ENDM
00000B50                          1901mm     PRINT_CHAR #'x',D5
00000B50                          1902mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B50                 TRUE     1903mm     IFEQ DEBUG
00000B50  1A39 00C00003           1904mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B56  0805 0002               1905mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B5A  67F4                    1906mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B5C  13FC 0078 00C00007      1907mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B64                          1908mm     ENDC
00000B64                          1909mm     
00000B64                 FALSE    1910mm     IFNE DEBUG
00000B64                          1911mm     ENDC
00000B64                          1912mm 
00000B64                          1913mm     ENDM
00000B64  7407                    1914m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B66                          1915m LOOP_127
00000B66                          1916mm     BIN2HEX D7,D6,A1
00000B66  43F9 00000F7C           1917mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B6C  E99F                    1918mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B6E  1C07                    1919mm     MOVE.B D7,D6
00000B70  0286 0000000F           1920mm     ANDI.L #$F,D6
00000B76  1C31 6000               1921mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000B7A                          1922mm     ENDM
00000B7A                          1923mm     PRINT_CHAR D6,D5
00000B7A                          1924mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7A                 TRUE     1925mm     IFEQ DEBUG
00000B7A  1A39 00C00003           1926mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B80  0805 0002               1927mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B84  67F4                    1928mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B86  13C6 00C00007           1929mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B8C                          1930mm     ENDC
00000B8C                          1931mm     
00000B8C                 FALSE    1932mm     IFNE DEBUG
00000B8C                          1933mm     ENDC
00000B8C                          1934mm 
00000B8C                          1935mm     ENDM
00000B8C  57CA FFD8               1936m     DBEQ D2,LOOP_127
00000B90                          1937m     ENDM
00000B90                          1938m     PRINT_CRLF D5     
00000B90                          1939mm     PRINT_CHAR #13,D5                           ; CR
00000B90                          1940mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     1941mm     IFEQ DEBUG
00000B90  1A39 00C00003           1942mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B96  0805 0002               1943mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    1944mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B9C  13FC 000D 00C00007      1945mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BA4                          1946mm     ENDC
00000BA4                          1947mm     
00000BA4                 FALSE    1948mm     IFNE DEBUG
00000BA4                          1949mm     ENDC
00000BA4                          1950mm 
00000BA4                          1951mm     ENDM
00000BA4                          1952mm     PRINT_CHAR #10,D5                           ; LF
00000BA4                          1953mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     1954mm     IFEQ DEBUG
00000BA4  1A39 00C00003           1955mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000BAA  0805 0002               1956mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    1957mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000BB0  13FC 000A 00C00007      1958mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BB8                          1959mm     ENDC
00000BB8                          1960mm     
00000BB8                 FALSE    1961mm     IFNE DEBUG
00000BB8                          1962mm     ENDC
00000BB8                          1963mm 
00000BB8                          1964mm     ENDM
00000BB8                          1965m     ENDM
00000BB8                          1966          
00000BB8  6000 F5CA               1967      BRA MAIN_LOOP
00000BBC                          1968      
00000BBC                          1969  G
00000BBC  2047                    1970      MOVE.L D7,A0                                ; address accumulator -> address register
00000BBE  3E3C 0000               1971      MOVE #0,D7                                  ; clear the now used address accumulator
00000BC2  4ED0                    1972      JMP (A0)                                    ; jump to it!
00000BC4                          1973      
00000BC4                          1974  Z
00000BC4  207C 00200000           1975      MOVE.L #RAM,A0                              ; address of RAM
00000BCA  7000                    1976      MOVE.L #0,D0                                ; number of bytes
00000BCC                          1977     
00000BCC                          1978      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000BCC                          1979s _10000014
00000BCC  B0BC 00040000           1980s     CMP.L   #$40000,D0
00000BD2  6E00 001A               1981s     BGT _10000015
00000BD6  2200                    1982          MOVE.L D0,D1                            ; progress update
00000BD8  E089                    1983          LSR.L #8,D1 
00000BDA  E089                    1984          LSR.L #8,D1
00000BDC  0281 0000000F           1985          ANDI.L #$F,D1
00000BE2  13C1 00E00001           1986          MOVE.B D1,DISPLAY
00000BE8                          1987  
00000BE8  20C0                    1988          MOVE.L D0,(A0)+ 
00000BEA  5880                    1989          ADD.L #4,D0
00000BEC                          1990      ENDW
00000BEC  60DE                    1991s     BRA _10000014
00000BEE                          1992s _10000015
00000BEE                          1993   
00000BEE  207C 00200000           1994      MOVE.L #RAM,A0                              ; address of RAM
00000BF4  7000                    1995      MOVE.L #0,D0                                ; number of bytes
00000BF6                          1996     
00000BF6                          1997      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000BF6                          1998s _10000016
00000BF6  B0BC 00040000           1999s     CMP.L   #$40000,D0
00000BFC  6E00 00C8               2000s     BGT _10000017
00000C00  2200                    2001          MOVE.L D0,D1                            ; progress update
00000C02  E089                    2002          LSR.L #8,D1
00000C04  E089                    2003          LSR.L #8,D1
00000C06  0281 0000000F           2004          ANDI.L #$F,D1
00000C0C  13C1 00E00001           2005          MOVE.B D1,DISPLAY
00000C12                          2006  
00000C12  2218                    2007          MOVE.L (A0)+,D1
00000C14                          2008            
00000C14                          2009          IF.L D0 <EQ> D1 THEN
00000C14  B081                    2010s     CMP.L   D1,D0
00000C16  6600 0006               2011s     BNE _0000000B
00000C1A  6000 00A4               2012              BRA OK
00000C1E                          2013          ENDI 
00000C1E                          2014s _0000000B
00000C1E                          2015            
00000C1E  43F9 00000F6A           2016          LEA RAM_ERROR,A1
00000C24                          2017m         PRINT_STR A1,D1
00000C24                          2018m LOOP_135
00000C24  0C11 0000               2019m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C28  6700 0016               2020m     BEQ EXIT_135
00000C2C                          2021mm     PRINT_CHAR (A1)+,D1
00000C2C                          2022mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2C                 TRUE     2023mm     IFEQ DEBUG
00000C2C  1239 00C00003           2024mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C32  0801 0002               2025mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C36  67F4                    2026mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C38  13D9 00C00007           2027mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C3E                          2028mm     ENDC
00000C3E                          2029mm     
00000C3E                 FALSE    2030mm     IFNE DEBUG
00000C3E                          2031mm     ENDC
00000C3E                          2032mm 
00000C3E                          2033mm     ENDM
00000C3E  60E4                    2034m     BRA LOOP_135
00000C40                          2035m EXIT_135
00000C40                          2036m     ENDM
00000C40  2208                    2037          MOVE.L A0,D1
00000C42  5981                    2038          SUB.L #4,D1
00000C44                          2039m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C44                          2040mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000C44                          2041mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C44                 TRUE     2042mm     IFEQ DEBUG
00000C44  1639 00C00003           2043mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C4A  0803 0002               2044mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C4E  67F4                    2045mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000C50  13FC 0030 00C00007      2046mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000C58                          2047mm     ENDC
00000C58                          2048mm     
00000C58                 FALSE    2049mm     IFNE DEBUG
00000C58                          2050mm     ENDC
00000C58                          2051mm 
00000C58                          2052mm     ENDM
00000C58                          2053mm     PRINT_CHAR #'x',D3
00000C58                          2054mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C58                 TRUE     2055mm     IFEQ DEBUG
00000C58  1639 00C00003           2056mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5E  0803 0002               2057mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C62  67F4                    2058mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000C64  13FC 0078 00C00007      2059mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000C6C                          2060mm     ENDC
00000C6C                          2061mm     
00000C6C                 FALSE    2062mm     IFNE DEBUG
00000C6C                          2063mm     ENDC
00000C6C                          2064mm 
00000C6C                          2065mm     ENDM
00000C6C  7C07                    2066m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C6E                          2067m LOOP_137
00000C6E                          2068mm     BIN2HEX D1,D2,A1
00000C6E  43F9 00000F7C           2069mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000C74  E999                    2070mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C76  1401                    2071mm     MOVE.B D1,D2
00000C78  0282 0000000F           2072mm     ANDI.L #$F,D2
00000C7E  1431 2000               2073mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000C82                          2074mm     ENDM
00000C82                          2075mm     PRINT_CHAR D2,D3
00000C82                          2076mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C82                 TRUE     2077mm     IFEQ DEBUG
00000C82  1639 00C00003           2078mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C88  0803 0002               2079mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C8C  67F4                    2080mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000C8E  13C2 00C00007           2081mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C94                          2082mm     ENDC
00000C94                          2083mm     
00000C94                 FALSE    2084mm     IFNE DEBUG
00000C94                          2085mm     ENDC
00000C94                          2086mm 
00000C94                          2087mm     ENDM
00000C94  57CE FFD8               2088m     DBEQ D6,LOOP_137
00000C98                          2089m     ENDM
00000C98                          2090m         PRINT_CRLF D3
00000C98                          2091mm     PRINT_CHAR #13,D3                           ; CR
00000C98                          2092mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C98                 TRUE     2093mm     IFEQ DEBUG
00000C98  1639 00C00003           2094mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C9E  0803 0002               2095mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA2  67F4                    2096mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CA4  13FC 000D 00C00007      2097mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000CAC                          2098mm     ENDC
00000CAC                          2099mm     
00000CAC                 FALSE    2100mm     IFNE DEBUG
00000CAC                          2101mm     ENDC
00000CAC                          2102mm 
00000CAC                          2103mm     ENDM
00000CAC                          2104mm     PRINT_CHAR #10,D3                           ; LF
00000CAC                          2105mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAC                 TRUE     2106mm     IFEQ DEBUG
00000CAC  1639 00C00003           2107mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB2  0803 0002               2108mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB6  67F4                    2109mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000CB8  13FC 000A 00C00007      2110mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000CC0                          2111mm     ENDC
00000CC0                          2112mm     
00000CC0                 FALSE    2113mm     IFNE DEBUG
00000CC0                          2114mm     ENDC
00000CC0                          2115mm 
00000CC0                          2116mm     ENDM
00000CC0                          2117m     ENDM
00000CC0                          2118  OK    
00000CC0  5880                    2119          ADD.L #4,D0
00000CC2                          2120      ENDW
00000CC2  6000 FF32               2121s     BRA _10000016
00000CC6                          2122s _10000017
00000CC6                          2123      
00000CC6  6000 F4BC               2124      BRA MAIN_LOOP
00000CCA                          2125    
00000CCA                          2126  L
00000CCA  7A00                    2127      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000CCC                          2128  
00000CCC                          2129m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000CCC                          2130m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                 TRUE     2131m     IFEQ DEBUG
00000CCC  1639 00C00003           2132m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CD2  0803 0000               2133m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000CD6  67F4                    2134m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000CD8                          2135m     ENDC
00000CD8                          2136m     
00000CD8                          2137mm     READ_CHAR D2
00000CD8                 TRUE     2138mm     IFEQ DEBUG
00000CD8  1439 00C00007           2139mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000CDE                          2140mm     ENDC
00000CDE                 FALSE    2141mm     IFNE DEBUG
00000CDE                          2142mm     ENDC
00000CDE                          2143mm      
00000CDE  B43C 001B               2144mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000CE2  6700 F324               2145mm     BEQ START
00000CE6                          2146mm     ENDM
00000CE6                          2147m 
00000CE6                 TRUE     2148m     IFEQ DEBUG
00000CE6                          2149mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000CE6                          2150mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE6                 TRUE     2151mm     IFEQ DEBUG
00000CE6  1639 00C00003           2152mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CEC  0803 0002               2153mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CF0  67F4                    2154mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000CF2  13C2 00C00007           2155mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CF8                          2156mm     ENDC
00000CF8                          2157mm     
00000CF8                 FALSE    2158mm     IFNE DEBUG
00000CF8                          2159mm     ENDC
00000CF8                          2160mm 
00000CF8                          2161mm     ENDM
00000CF8                          2162m     ENDC
00000CF8                          2163m     ENDM
00000CF8                          2164m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000CF8  41F9 00000F8C           2165m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000CFE  0402 0030               2166m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D02  C4BC 000000FF           2167m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D08  1430 2000               2168m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D0C                          2169m     ENDM
00000D0C  1A02                    2170      MOVE.B D2,D5                                ; put at bottom of D5
00000D0E                          2171  
00000D0E  3C3C 0002               2172      MOVE #2,D6                                  ; 3 bytes left to read
00000D12                          2173      
00000D12                          2174  READ_LENGTH
00000D12  E98D                    2175      LSL.L #4,D5                                 ; make what we have so far more significant
00000D14                          2176m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D14                          2177m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D14                 TRUE     2178m     IFEQ DEBUG
00000D14  1639 00C00003           2179m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D1A  0803 0000               2180m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D1E  67F4                    2181m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D20                          2182m     ENDC
00000D20                          2183m     
00000D20                          2184mm     READ_CHAR D2
00000D20                 TRUE     2185mm     IFEQ DEBUG
00000D20  1439 00C00007           2186mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D26                          2187mm     ENDC
00000D26                 FALSE    2188mm     IFNE DEBUG
00000D26                          2189mm     ENDC
00000D26                          2190mm      
00000D26  B43C 001B               2191mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D2A  6700 F2DC               2192mm     BEQ START
00000D2E                          2193mm     ENDM
00000D2E                          2194m 
00000D2E                 TRUE     2195m     IFEQ DEBUG
00000D2E                          2196mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D2E                          2197mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D2E                 TRUE     2198mm     IFEQ DEBUG
00000D2E  1639 00C00003           2199mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D34  0803 0002               2200mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D38  67F4                    2201mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000D3A  13C2 00C00007           2202mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D40                          2203mm     ENDC
00000D40                          2204mm     
00000D40                 FALSE    2205mm     IFNE DEBUG
00000D40                          2206mm     ENDC
00000D40                          2207mm 
00000D40                          2208mm     ENDM
00000D40                          2209m     ENDC
00000D40                          2210m     ENDM
00000D40                          2211m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D40  41F9 00000F8C           2212m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D46  0402 0030               2213m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D4A  C4BC 000000FF           2214m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D50  1430 2000               2215m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D54                          2216m     ENDM
00000D54  8A02                    2217      OR.B D2,D5
00000D56  023C 00FB               2218      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000D5A  57CE FFB6               2219      DBEQ D6,READ_LENGTH
00000D5E                          2220          
00000D5E                          2221m     PRINT_CRLF D3
00000D5E                          2222mm     PRINT_CHAR #13,D3                           ; CR
00000D5E                          2223mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5E                 TRUE     2224mm     IFEQ DEBUG
00000D5E  1639 00C00003           2225mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D64  0803 0002               2226mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D68  67F4                    2227mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000D6A  13FC 000D 00C00007      2228mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D72                          2229mm     ENDC
00000D72                          2230mm     
00000D72                 FALSE    2231mm     IFNE DEBUG
00000D72                          2232mm     ENDC
00000D72                          2233mm 
00000D72                          2234mm     ENDM
00000D72                          2235mm     PRINT_CHAR #10,D3                           ; LF
00000D72                          2236mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     2237mm     IFEQ DEBUG
00000D72  1639 00C00003           2238mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D78  0803 0002               2239mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    2240mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000D7E  13FC 000A 00C00007      2241mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D86                          2242mm     ENDC
00000D86                          2243mm     
00000D86                 FALSE    2244mm     IFNE DEBUG
00000D86                          2245mm     ENDC
00000D86                          2246mm 
00000D86                          2247mm     ENDM
00000D86                          2248m     ENDM
00000D86                          2249  
00000D86  207C 00000000           2250      MOVE.L #ROM,A0                              ; start of ROM
00000D8C                          2251      
00000D8C  2247                    2252      MOVE.L D7,A1                                ; address accumulator -> address register
00000D8E  7E00                    2253      MOVE.L #0,D7                                ; clear the now used address accumulator
00000D90                          2254      
00000D90  267C 00002AAA           2255      MOVE.L #$2AAA,A3
00000D96  36BC AAAA               2256      MOVE.W #$AAAA,(A3)
00000D9A  267C 00001554           2257      MOVE.L #$1554,A3
00000DA0  36BC 5555               2258      MOVE.W #$5555,(A3)
00000DA4  267C 00002AAA           2259      MOVE.L #$2AAA,A3
00000DAA  36BC 8080               2260      MOVE.W #$8080,(A3)
00000DAE  267C 00002AAA           2261      MOVE.L #$2AAA,A3
00000DB4  36BC AAAA               2262      MOVE.W #$AAAA,(A3)
00000DB8  267C 00001554           2263      MOVE.L #$1554,A3
00000DBE  36BC 5555               2264      MOVE.W #$5555,(A3)
00000DC2  267C 00002AAA           2265      MOVE.L #$2AAA,A3
00000DC8  36BC 2020               2266      MOVE.W #$2020,(A3)
00000DCC                          2267      
00000DCC  45F9 00000FA3           2268      LEA LOADING,A2                              ; important for timing
00000DD2                          2269m     PRINT_STR A2,D3
00000DD2                          2270m LOOP_156
00000DD2  0C12 0000               2271m     CMP.B #0,(A2)                               ; 0 -> DONE
00000DD6  6700 0016               2272m     BEQ EXIT_156
00000DDA                          2273mm     PRINT_CHAR (A2)+,D3
00000DDA                          2274mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDA                 TRUE     2275mm     IFEQ DEBUG
00000DDA  1639 00C00003           2276mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DE0  0803 0002               2277mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DE4  67F4                    2278mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000DE6  13DA 00C00007           2279mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000DEC                          2280mm     ENDC
00000DEC                          2281mm     
00000DEC                 FALSE    2282mm     IFNE DEBUG
00000DEC                          2283mm     ENDC
00000DEC                          2284mm 
00000DEC                          2285mm     ENDM
00000DEC  60E4                    2286m     BRA LOOP_156
00000DEE                          2287m EXIT_156
00000DEE                          2288m     ENDM
00000DEE                          2289  
00000DEE  023C 00FB               2290      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DF2                          2291      
00000DF2                          2292      WHILE D5 <GT> #0 DO
00000DF2                          2293s _10000018
00000DF2  BA7C 0000               2294s     CMP.W   #0,D5
00000DF6  6F00 001C               2295s     BLE _10000019
00000DFA  5585                    2296          SUB.L #2,D5
00000DFC                          2297            
00000DFC  13D1 00E00001           2298          MOVE.B (A1),DISPLAY
00000E02  3091                    2299          MOVE.W (A1),(A0)                        ; write the data
00000E04                          2300        
00000E04                          2301  WAIT_FOR_COMPLETE
00000E04  3410                    2302          MOVE.W (A0),D2
00000E06                          2303  
00000E06                          2304          IF D2 <NE> (A1) THEN
00000E06  B451                    2305s     CMP.W   (A1),D2
00000E08  6700 0004               2306s     BEQ _0000000C
00000E0C  60F6                    2307              BRA WAIT_FOR_COMPLETE
00000E0E                          2308          ENDI
00000E0E                          2309s _0000000C
00000E0E                          2310        
00000E0E  5488                    2311          ADD.L #2,A0
00000E10  5489                    2312          ADD.L #2,A1
00000E12                          2313      ENDW  
00000E12  60DE                    2314s     BRA _10000018
00000E14                          2315s _10000019
00000E14                          2316      
00000E14  267C 00002AAA           2317      MOVE.L #$2AAA,A3
00000E1A  36BC AAAA               2318      MOVE.W #$AAAA,(A3)
00000E1E  267C 00001554           2319      MOVE.L #$1554,A3
00000E24  36BC 5555               2320      MOVE.W #$5555,(A3)
00000E28  267C 00002AAA           2321      MOVE.L #$2AAA,A3
00000E2E  36BC A0A0               2322      MOVE.W #$A0A0,(A3)
00000E32                          2323              
00000E32  6000 F350               2324      BRA MAIN_LOOP
00000E36                          2325          
00000E36                          2326  HEX_DIGIT
00000E36  E98F                    2327      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000E38                          2328m     HEX2BIN D2,D2,A0
00000E38  41F9 00000F8C           2329m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000E3E  0402 0030               2330m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E42  C4BC 000000FF           2331m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000E48  1430 2000               2332m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000E4C                          2333m     ENDM
00000E4C  8E02                    2334      OR.B D2,D7  
00000E4E  6000 F35C               2335      BRA GET_INPUT
00000E52                          2336  
00000E52  FFFF FFFF               2337      SIMHALT                                     ; halt simulator
00000E56                          2338  
00000E56                          2339  ; strings
00000E56= 4D 44 46 2D 6D 6F ...   2340  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',13,10,0
00000E73= 3F 20 48 65 6C 70 ...   2341  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00000F18= 48 75 68 3F 0D 0A 00    2342  HUH     DC.B 'Huh?',13,10,0
00000F1F= 20 53 20 72 65 63 ...   2343  READ    DC.B ' S records read, start address = ',0
00000F41= 57 3A 20 55 6E 6B ...   2344  UNREC   DC.B 'W: Unknown Srec type: ',0
00000F58= 57 3A 20 43 53 20 ...   2345  CS_FAILURE   DC.B 'W: CS failure at ',0
00000F6A= 57 3A 20 52 41 4D ...   2346  RAM_ERROR DC.B 'W: RAM error at: ',0
00000F7C= 30 31 32 33 34 35 ...   2347  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000F8C= 00 01 02 03 04 05 ...   2348  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000FA3= 4C 6F 61 64 69 6E ...   2349  LOADING  DC.B 'Loading EEPROM...',13,11,0
00000FB7                          2350      
00000FB7                          2351      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         F7C
CONTINUE_103        9A6
CONTINUE_44         44A
CONTINUE_47         49A
CONTINUE_51         4F2
CONTINUE_59         5B0
CONTINUE_64         624
CONTINUE_69         6A2
CONTINUE_74         726
CONTINUE_79         7B4
CONTINUE_84         828
CONTINUE_89         89C
CS_FAILURE          F58
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            95E
DOWNLOAD_BYTE       C2F
DOWNLOAD_DONE       AC4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            A42
EXIT_125            B3A
EXIT_135            C40
EXIT_156            DEE
EXIT_19             28A
EXIT_21             2B0
EXIT_23             2D6
EXIT_5              13E
EXIT_96             93C
G                   BBC
GET_INPUT           1AC
H                   28E
HELP                E73
HEX2BIN             134
HEX2BIN_LUT         F8C
HEX_DIGIT           E36
HUH                 F18
L                   CCA
LOADING             FA3
LOOP_110            A26
LOOP_112            A6C
LOOP_120            AEE
LOOP_125            B1E
LOOP_127            B66
LOOP_135            C24
LOOP_137            C6E
LOOP_156            DD2
LOOP_19             26E
LOOP_21             294
LOOP_23             2BA
LOOP_25             308
LOOP_5              122
LOOP_96             920
MAIN_LOOP           184
OK                  CC0
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   2DA
RAM                 200000
RAM_ERROR           F6A
READ                F1F
READ_CHAR           803
READ_DATA_TO_POKE   3A8
READ_LENGTH         D12
RESET               4
ROM                 0
S                   426
STACK               0
START               8
UNREC               F41
V                   2B4
VERSION             E56
W                   360
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E04
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   166
WAIT_FOR_READY_100  94E
WAIT_FOR_READY_101  962
WAIT_FOR_READY_103  98A
WAIT_FOR_READY_105  9BE
WAIT_FOR_READY_108  9F0
WAIT_FOR_READY_109  A04
WAIT_FOR_READY_11   184
WAIT_FOR_READY_111  A2E
WAIT_FOR_READY_113  A42
WAIT_FOR_READY_114  A56
WAIT_FOR_READY_116  A80
WAIT_FOR_READY_118  A96
WAIT_FOR_READY_119  AAA
WAIT_FOR_READY_12   198
WAIT_FOR_READY_121  AC4
WAIT_FOR_READY_122  AD8
WAIT_FOR_READY_124  B02
WAIT_FOR_READY_126  B26
WAIT_FOR_READY_128  B3C
WAIT_FOR_READY_129  B50
WAIT_FOR_READY_13   1AC
WAIT_FOR_READY_131  B7A
WAIT_FOR_READY_133  B90
WAIT_FOR_READY_134  BA4
WAIT_FOR_READY_136  C2C
WAIT_FOR_READY_138  C44
WAIT_FOR_READY_139  C58
WAIT_FOR_READY_141  C82
WAIT_FOR_READY_143  C98
WAIT_FOR_READY_144  CAC
WAIT_FOR_READY_145  CCC
WAIT_FOR_READY_147  CE6
WAIT_FOR_READY_149  D14
WAIT_FOR_READY_15   1C6
WAIT_FOR_READY_151  D2E
WAIT_FOR_READY_154  D5E
WAIT_FOR_READY_155  D72
WAIT_FOR_READY_157  DDA
WAIT_FOR_READY_17   210
WAIT_FOR_READY_18   224
WAIT_FOR_READY_20   276
WAIT_FOR_READY_22   29C
WAIT_FOR_READY_24   2C2
WAIT_FOR_READY_26   2DE
WAIT_FOR_READY_27   2F2
WAIT_FOR_READY_29   31C
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   332
WAIT_FOR_READY_32   346
WAIT_FOR_READY_33   362
WAIT_FOR_READY_35   37C
WAIT_FOR_READY_37   3AA
WAIT_FOR_READY_39   3C4
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   3FA
WAIT_FOR_READY_43   40E
WAIT_FOR_READY_44   42E
WAIT_FOR_READY_46   468
WAIT_FOR_READY_47   47E
WAIT_FOR_READY_49   4B2
WAIT_FOR_READY_51   4D6
WAIT_FOR_READY_53   50A
WAIT_FOR_READY_56   544
WAIT_FOR_READY_57   558
WAIT_FOR_READY_59   594
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   5C8
WAIT_FOR_READY_64   608
WAIT_FOR_READY_66   63C
WAIT_FOR_READY_69   686
WAIT_FOR_READY_71   6BA
WAIT_FOR_READY_74   70A
WAIT_FOR_READY_76   73E
WAIT_FOR_READY_79   798
WAIT_FOR_READY_8    13E
WAIT_FOR_READY_81   7CC
WAIT_FOR_READY_84   80C
WAIT_FOR_READY_86   840
WAIT_FOR_READY_89   880
WAIT_FOR_READY_9    152
WAIT_FOR_READY_91   8B4
WAIT_FOR_READY_94   8F2
WAIT_FOR_READY_95   906
WAIT_FOR_READY_97   928
WAIT_FOR_READY_98   93C
WAIT_FOR_SRECORD    42E
Z                   BC4
_00000000           1EC
_00000001           200
_00000002           574
_00000003           97A
_00000004           582
_00000005           780
_00000006           6EC
_00000007           97A
_00000008           8F2
_00000009           97A
_0000000A           AC2
_0000000B           C1E
_0000000C           E0E
_10000000           4CC
_10000001           536
_10000002           58A
_10000003           5F4
_10000004           5FE
_10000005           668
_10000006           67C
_10000007           6E6
_10000008           6F0
_10000009           778
_1000000A           700
_1000000B           76A
_1000000C           78E
_1000000D           7F8
_1000000E           802
_1000000F           86C
_10000010           876
_10000011           8E0
_10000012           980
_10000013           9EA
_10000014           BCC
_10000015           BEE
_10000016           BF6
_10000017           CC6
_10000018           DF2
_10000019           E14
