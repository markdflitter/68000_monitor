00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/03/2021 18:13:39

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000  =00000000                  9  DEBUG               EQU 0
00000000                            10  
00000000                            11  ; constants
00000000  =00E00000                 12  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 13  DISPLAY_            EQU $0
00000000  =00E00000                 14  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_
00000000                            15  
00000000  =00D30000                 16  DUART_BASE          EQU $D30000
00000000  =00000000                 17  DUART_MRA_          EQU $0
00000000  =00000001                 18  DUART_CSRA_         EQU $1
00000000  =00000001                 19  DUART_SRA_          EQU $1
00000000  =00000002                 20  DUART_CRA_          EQU $2
00000000  =00000003                 21  DUART_TXA_          EQU $3
00000000  =00000003                 22  DUART_RXA_          EQU $3
00000000  =00000004                 23  DUART_ACR_          EQU $4
00000000  =00000005                 24  DUART_IMR_          EQU $5
00000000  =00000008                 25  DUART_MRB_          EQU $8
00000000  =00000009                 26  DUART_CSRB_         EQU $9
00000000  =00000009                 27  DUART_SRB_          EQU $9
00000000  =0000000A                 28  DUART_CRB_          EQU $A
00000000  =0000000B                 29  DUART_TXB_          EQU $B
00000000  =0000000B                 30  DUART_RXB_          EQU $B
00000000  =0000000C                 31  DUART_IVR_          EQU $C
00000000  =0000000D                 32  DUART_OPCR_         EQU $D
00000000  =0000000E                 33  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 34  DUART_RESET_OPR_    EQU $F
00000000                            35  
00000000  =00D30001                 36  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 37  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 38  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 39  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 40  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 41  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            42  
00000000  =00D30011                 43  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 44  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 45  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 46  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 47  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 48  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            49  
00000000  =00D30009                 50  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 51  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 52  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 53  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 54  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 55  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            56  
00000000                            57  ; macros
00000000                            58  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            59  ; the input register is changed during the process
00000000                            60  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            61  BIN2HEX MACRO
00000000                            62    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            63    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            64    MOVE.B \1,\2
00000000                            65    ANDI.B #$F,\2
00000000                            66    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            67    ENDM
00000000                            68  
00000000                            69  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            70  ; the input register is changed during the process
00000000                            71  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            72  HEX2BIN MACRO
00000000                            73    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            74    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            75    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            76    ENDM
00000000                            77  
00000000                            78  ; send a single char to the serial port
00000000                            79  ; \1 = char to send, \2 = data register to use for status poll
00000000                            80  ; will stamp on D3 and D2 in debug mode
00000000                            81  PRINT_CHAR MACRO
00000000                            82  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            83      IFEQ DEBUG
00000000                            84        MOVE.B DUART_SRA,\2           ; read status register
00000000                            85        BTST #2,\2                    ; check for space to send
00000000                            86        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            87        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            88      ENDC
00000000                            89      
00000000                            90      IFNE DEBUG
00000000                            91        MOVE.B \1,D1
00000000                            92        MOVE.L #6,D0   
00000000                            93        TRAP #15                      ; write to terminal in simulator
00000000                            94      ENDC
00000000                            95  
00000000                            96      ENDM
00000000                            97  
00000000                            98  ; send CR,LF to the serial port
00000000                            99  ; \1 = data register to use for status poll
00000000                           100  PRINT_CRLF MACRO                  
00000000                           101      PRINT_CHAR #13,\1             ; CR
00000000                           102      PRINT_CHAR #10,\1             ; LF
00000000                           103      ENDM
00000000                           104  
00000000                           105  ; send C-style, zero terminated string to the serial port
00000000                           106  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           107  PRINT_STR MACRO
00000000                           108  LOOP\@
00000000                           109      CMP.B #0,(\1)                 ; 0 -> done
00000000                           110      BEQ EXIT\@
00000000                           111      PRINT_CHAR (\1)+,\2
00000000                           112      JMP LOOP\@
00000000                           113  EXIT\@
00000000                           114      ENDM
00000000                           115    
00000000                           116  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           117  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           118  PRINT_REG MACRO
00000000                           119      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           120  LOOP\@
00000000                           121      BIN2HEX \1,\3,\5
00000000                           122      PRINT_CHAR \3,\2
00000000                           123      DBEQ \4,LOOP\@
00000000                           124      ENDM
00000000                           125    
00000000                           126  ; read a char from the serial port
00000000                           127  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           128  ; will stamp on D3 and D2 in debug mode
00000000                           129  READ_CHAR MACRO
00000000                           130  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           131  
00000000                           132      IFEQ DEBUG
00000000                           133        MOVE.B DUART_SRA,\2         ; read status register
00000000                           134        BTST #0,\2                    ; check for character
00000000                           135        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           136      ENDC
00000000                           137  
00000000                           138      IFEQ DEBUG
00000000                           139        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           140      ENDC
00000000                           141      IFNE DEBUG
00000000                           142        MOVE.L #5,D0    
00000000                           143        TRAP #15                    ; read from keyboard in simulator
00000000                           144        MOVE.L D1,\1
00000000                           145      ENDC
00000000                           146       
00000000                           147      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           148      BEQ RESTART
00000000                           149  
00000000                           150      IFEQ DEBUG
00000000                           151        PRINT_CHAR \1,\2            ; echo it back
00000000                           152      ENDC
00000000                           153      ENDM
00000000                           154  
00000000                           155  ; register catalogue
00000000                           156  ; D0 - used for simulator I/O
00000000                           157  ; D1 - used for simulator I/O
00000000                           158  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           159  ; D4 - read character
00000000                           160  ; D5 - byte to W
00000000                           161  ; D6 - working register used in R/W
00000000                           162  ; D7 - address accumulator
00000000                           163  ; A0 - address of string to print / address for R or W
00000000                           164  
00000000                           165  ; start vector
00000000                           166      ORG  $0
00000000= 00000000                 167      DC.L $00000000              ; PC
00000004= 00000000                 168      DC.L $00000000              ; SP
00000008                           169      
00000008                           170  ; start of program  
00000008                           171  START
00000008  13FC 0000 00E00000       172      MOVE.B #0,DISPLAY
00000010                           173  
00000010                           174  ;initialise UART
00000010  13FC 0000 00D30009       175      MOVE.B #$0,DUART_ACR            
00000018  13FC 0000 00D3000B       176      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000020  13FC 0000 00D3001B       177      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000028                           178  
00000028                           179  ; channel A
00000028  13FC 0003 00D30001       180      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000030  13FC 0007 00D30001       181      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000038  13FC 00BB 00D30003       182      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
00000040  13FC 0005 00D30005       183      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000048                           184  
00000048                           185  ; channel B
00000048  13FC 0003 00D30011       186      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
00000050  13FC 0047 00D30011       187      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
00000058  13FC 00BB 00D30013       188      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
00000060  13FC 0005 00D30015       189      MOVE.B #$5,DUART_CRB            ; enable rx & tx
00000068                           190  
00000068  13FC 0001 00E00000       191      MOVE.B #1,DISPLAY
00000070                           192         
00000070  41F9 00000422            193      LEA VERSION,A0
00000076                           194m     PRINT_STR A0,D3
00000094                           195m     PRINT_CRLF D3
000000BC                           196m     PRINT_CHAR #7,D3
000000D0                           197      
000000D0  7E00                     198      MOVE.L #0,D7                    ; address accumulator
000000D2                           199  
000000D2  13FC 0002 00E00000       200      MOVE.B #2,DISPLAY
000000DA                           201  MAIN_LOOP
000000DA  13FC 0003 00E00000       202      MOVE.B #3,DISPLAY
000000E2                           203  
000000E2                           204m     PRINT_CHAR #'>',D3               ; prompt
000000F6                           205m     PRINT_CHAR #32,D3                ; space
0000010A                           206      
0000010A                           207  GET_INPUT
0000010A  13FC 0004 00E00000       208      MOVE.B #4,DISPLAY
00000112                           209  
00000112                           210m     READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000013E                           211      
0000013E  B83C 0030                212      CMP.B #'0',D4
00000142  6700 02C4                213      BEQ HEX_DIGIT
00000146  B83C 0031                214      CMP.B #'1',D4
0000014A  6700 02BC                215      BEQ HEX_DIGIT
0000014E  B83C 0032                216      CMP.B #'2',D4
00000152  6700 02B4                217      BEQ HEX_DIGIT
00000156  B83C 0033                218      CMP.B #'3',D4
0000015A  6700 02AC                219      BEQ HEX_DIGIT
0000015E  B83C 0034                220      CMP.B #'4',D4
00000162  6700 02A4                221      BEQ HEX_DIGIT
00000166  B83C 0035                222      CMP.B #'5',D4
0000016A  6700 029C                223      BEQ HEX_DIGIT
0000016E  B83C 0036                224      CMP.B #'6',D4
00000172  6700 0294                225      BEQ HEX_DIGIT
00000176  B83C 0037                226      CMP.B #'7',D4
0000017A  6700 028C                227      BEQ HEX_DIGIT
0000017E  B83C 0038                228      CMP.B #'8',D4
00000182  6700 0284                229      BEQ HEX_DIGIT
00000186  B83C 0039                230      CMP.B #'9',D4
0000018A  6700 027C                231      BEQ HEX_DIGIT
0000018E  B83C 0041                232      CMP.B #'A',D4
00000192  6700 0274                233      BEQ HEX_DIGIT
00000196  B83C 0042                234      CMP.B #'B',D4
0000019A  6700 026C                235      BEQ HEX_DIGIT
0000019E  B83C 0043                236      CMP.B #'C',D4
000001A2  6700 0264                237      BEQ HEX_DIGIT
000001A6  B83C 0044                238      CMP.B #'D',D4
000001AA  6700 025C                239      BEQ HEX_DIGIT
000001AE  B83C 0045                240      CMP.B #'E',D4
000001B2  6700 0254                241      BEQ HEX_DIGIT
000001B6  B83C 0046                242      CMP.B #'F',D4
000001BA  6700 024C                243      BEQ HEX_DIGIT
000001BE                           244      
000001BE  B83C 0057                245      CMP.B #'W',D4
000001C2  6700 0152                246      BEQ W
000001C6                           247  
000001C6                           248m     PRINT_CRLF D3
000001EE                           249   
000001EE  B83C 003F                250      CMP.B #'?',D4
000001F2  6700 0076                251      BEQ H
000001F6                           252  
000001F6  B83C 0056                253      CMP.B #'V',D4
000001FA  6700 0096                254      BEQ V
000001FE                           255      
000001FE  B83C 0052                256      CMP.B #'R',D4
00000202  6700 00B6                257      BEQ R
00000206                           258  
00000206  B83C 0053                259      CMP.B #'S',D4
0000020A  6700 01C4                260      BEQ S
0000020E                           261  
0000020E  B83C 0047                262      CMP.B #'G',D4
00000212  6700 01EC                263      BEQ G   
00000216                           264  
00000216  41F9 0000048A            265      LEA HUH,A0
0000021C                           266m     PRINT_STR A0,D3
0000023A                           267                         
0000023A  4EF8 00DA                268      JMP MAIN_LOOP
0000023E                           269  
0000023E                           270  RESTART
0000023E                           271m     PRINT_CRLF D3
00000266  4EF8 0008                272      JMP START
0000026A                           273  
0000026A                           274  ; commands
0000026A  41F9 0000043E            275  H   LEA HELP,A0
00000270                           276m     PRINT_STR A0,D3
0000028E  4EF8 00DA                277      JMP MAIN_LOOP
00000292                           278  
00000292  41F9 00000422            279  V   LEA VERSION,A0
00000298                           280m     PRINT_STR A0,D3       
000002B6  4EF8 00DA                281      JMP MAIN_LOOP
000002BA                           282      
000002BA  2047                     283  R   MOVE.L D7,A0                    ; address accumulator -> address register
000002BC  2810                     284      MOVE.L (A0),D4                  ; read the memory and print it
000002BE                           285m     PRINT_REG D4,D3,D7,D6,A0
000002E8                           286m     PRINT_CRLF D3
00000310  7E00                     287      MOVE.L #0,D7                    ; clear the now used address accumulator
00000312  4EF8 00DA                288      JMP MAIN_LOOP
00000316                           289  
00000316  7A00                     290  W   MOVE.L #0,D5                    ; D5 will be the value to write            
00000318                           291  
00000318                           292m     READ_CHAR D4,D3                 ; read most significant character -> D4
00000344                           293m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000352  1A04                     294      MOVE.B D4,D5                    ; put at bottom of D5
00000354                           295  
00000354  3C3C 0006                296      MOVE #6,D6                      ; 7 bytes left to read
00000358                           297      
00000358                           298  READ_DATA
00000358  E98D                     299      LSL.L #4,D5                     ; make what we have so far more significant
0000035A                           300m     READ_CHAR D4,D3                 ; next character -> D4
00000386                           301m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000394  8A04                     302      OR.B D4,D5
00000396  023C 00FB                303      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
0000039A  57CE FFBC                304      DBEQ D6,READ_DATA
0000039E                           305      
0000039E  2047                     306      MOVE.L D7,A0                    ; address accumulator -> address register
000003A0  7E00                     307      MOVE.L #0,D7                    ; clear the now used address accumulator
000003A2  2085                     308      MOVE.L D5,(A0)                  ; write the byte
000003A4                           309  
000003A4                           310m     PRINT_CRLF D3
000003CC  4EF8 00DA                311      JMP MAIN_LOOP
000003D0                           312  
000003D0                           313m S   READ_CHAR D4,D3                  ; fetch character from serial port -> D4
000003FC  4EF8 03D0                314      JMP S
00000400                           315  
00000400  2047                     316  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000402  3E3C 0000                317      MOVE #0,D7                      ; clear the now used address accumulator
00000406  4ED0                     318      JMP (A0)                        ; jump to it!
00000408                           319          
00000408                           320  HEX_DIGIT
00000408  E98F                     321      LSL.L #4,D7                    ; add the next digit in the next 4 bits
0000040A                           322m     HEX2BIN D4,D4,A0
00000418  8E84                     323      OR.L D4,D7
0000041A  4EF8 010A                324      JMP GET_INPUT
0000041E                           325  
0000041E  FFFF FFFF                326      SIMHALT                         ; halt simulator
00000422                           327  
00000422                           328  ; strings
00000422= 4D 44 46 2D 6D 6F ...    329  VERSION DC.B 'MDF-mon V1.3 (30/03/2021)',13,10,0
0000043E= 3F 0D 0A 56 28 65 ...    330  HELP    DC.B '?',13,10,'V(ersion)',13,10,'nnnnnnnnR(ead)',13,10,'nnnnnnnnW(rite)nn',13,10,'S(records)',13,10,'nnnnnnnnG(o)',13,10,0
0000048A= 48 75 68 3F 0D 0A 00     331  HUH     DC.B 'Huh?',13,10,0
00000491= 55 6E 69 6D 70 6C ...    332  UNIMP   DC.B 'Unimplemented',13,10,0
000004A1= 30 31 32 33 34 35 ...    333  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000004B1= 00 01 02 03 04 05 ...    334  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000004C8                           335      
000004C8                           336      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         4A1
DEBUG               0
DISPLAY             E00000
DISPLAY_            0
DISPLAY_BASE        E00000
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_1              94
EXIT_14             23A
EXIT_19             28E
EXIT_21             2B6
G                   400
GET_INPUT           10A
H                   26A
HELP                43E
HEX2BIN             12B
HEX2BIN_LUT         4B1
HEX_DIGIT           408
HUH                 48A
LOOP_1              76
LOOP_14             21C
LOOP_19             270
LOOP_21             298
LOOP_23             2C0
MAIN_LOOP           DA
PRINT_CHAR          218
PRINT_CRLF          411
PRINT_REG           4ED
PRINT_STR           46B
R                   2BA
READ_CHAR           591
READ_DATA           358
RESTART             23E
S                   3D0
START               8
UNIMP               491
V                   292
VERSION             422
W                   316
WAIT_FOR_READY_10   12C
WAIT_FOR_READY_12   1C6
WAIT_FOR_READY_13   1DA
WAIT_FOR_READY_15   224
WAIT_FOR_READY_17   23E
WAIT_FOR_READY_18   252
WAIT_FOR_READY_2    7E
WAIT_FOR_READY_20   278
WAIT_FOR_READY_22   2A0
WAIT_FOR_READY_25   2D2
WAIT_FOR_READY_27   2E8
WAIT_FOR_READY_28   2FC
WAIT_FOR_READY_29   318
WAIT_FOR_READY_30   332
WAIT_FOR_READY_32   35A
WAIT_FOR_READY_33   374
WAIT_FOR_READY_36   3A4
WAIT_FOR_READY_37   3B8
WAIT_FOR_READY_38   3D0
WAIT_FOR_READY_39   3EA
WAIT_FOR_READY_4    94
WAIT_FOR_READY_5    A8
WAIT_FOR_READY_6    BC
WAIT_FOR_READY_7    E2
WAIT_FOR_READY_8    F6
WAIT_FOR_READY_9    112
