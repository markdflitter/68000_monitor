00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/04/2021 20:17:16

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 00000000                 270  STACK   DC.L $00000000                              ; STACK
00000004= 00000008                 271  RESET   DC.L START                                  ; RESET
00000008                           272  
00000008                           273  ; start of program  
00000008                           274  START
00000008  13FC 0000 00E00001       275      MOVE.B #0,DISPLAY
00000010                           276  
00000010                           277  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       278      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       279      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           280      
00000020                           281      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                282s     MOVE.W  #$50,D1
00000024  6000 000E                283s     BRA _20000001
00000028                           284s _20000000
00000028  13C1 00C00005            285          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     286          NOP
00000030                           287      ENDF
00000030  0441 0010                288s     SUB.W   #$10,D1
00000034                           289s _20000001
00000034  B27C 0010                290s     CMP.W   #$10,D1
00000038  6CEE                     291s     BGE _20000000
0000003A                           292  
0000003A                           293      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                294s     MOVE.W  #$50,D1
0000003E  6000 000E                295s     BRA _20000003
00000042                           296s _20000002
00000042  13C1 00C00015            297          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     298          NOP
0000004A                           299      ENDF
0000004A  0441 0010                300s     SUB.W   #$10,D1
0000004E                           301s _20000003
0000004E  B27C 0010                302s     CMP.W   #$10,D1
00000052  6CEE                     303s     BGE _20000002
00000054                           304      
00000054                           305  ;initialise UART
00000054  13FC 0000 00C00009       306      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       307      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       308      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           309  
0000006C                           310  ; channel A
0000006C  13FC 0013 00C00001       311      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       312      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       313      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       314      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           315  
0000008C                           316  ; channel B
0000008C  13FC 0013 00C00011       317      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       318      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       319      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       320      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           321  
000000AC                           322m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           323m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      324m     IFEQ DEBUG
000000AC  1239 00C00003            325m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                326m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     327m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       328m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           329m     ENDC
000000C0                           330m 
000000C0                 FALSE     331m     IFNE DEBUG
000000C0                           332m     ENDC
000000C0                           333m 
000000C0                           334m     ENDM
000000C0                           335m     PRINT_CHAR #0,D1
000000C0                           336m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      337m     IFEQ DEBUG
000000C0  1239 00C00003            338m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                339m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     340m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       341m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           342m     ENDC
000000D4                           343m 
000000D4                 FALSE     344m     IFNE DEBUG
000000D4                           345m     ENDC
000000D4                           346m 
000000D4                           347m     ENDM
000000D4                           348m     PRINT_CHAR #0,D1
000000D4                           349m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      350m     IFEQ DEBUG
000000D4  1239 00C00003            351m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                352m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     353m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       354m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           355m     ENDC
000000E8                           356m 
000000E8                 FALSE     357m     IFNE DEBUG
000000E8                           358m     ENDC
000000E8                           359m 
000000E8                           360m     ENDM
000000E8                           361  
000000E8  13FC 0001 00E00001       362      MOVE.B #1,DISPLAY
000000F0                           363  
000000F0                           364m     PRINT_CRLF D1,A0
000000F0  41FA 1186                365m     LEA CRLF(PC),A0
000000F4                           366mm     PRINT_STR A0,D1
000000F4                           367mm LOOP_5
000000F4  0C10 0000                368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                369mm     BEQ EXIT_5
000000FC                           370mmm     PRINT_CHAR (A0)+,D1
000000FC                           371mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      372mmm     IFEQ DEBUG
000000FC  1239 00C00003            373mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                374mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     375mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           377mmm     ENDC
0000010E                           378mmm 
0000010E                 FALSE     379mmm     IFNE DEBUG
0000010E                           380mmm     ENDC
0000010E                           381mmm 
0000010E                           382mmm     ENDM
0000010E  60E4                     383mm     BRA LOOP_5
00000110                           384mm EXIT_5
00000110                           385mm     ENDM
00000110                           386m     ENDM
00000110  41FA 1174                387      LEA VERSION(PC),A0
00000114                           388m     PRINT_STR A0,D3
00000114                           389m LOOP_7
00000114  0C10 0000                390m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                391m     BEQ EXIT_7
0000011C                           392mm     PRINT_CHAR (A0)+,D3
0000011C                           393mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      394mm     IFEQ DEBUG
0000011C  1639 00C00003            395mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                396mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     397mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            398mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           399mm     ENDC
0000012E                           400mm 
0000012E                 FALSE     401mm     IFNE DEBUG
0000012E                           402mm     ENDC
0000012E                           403mm 
0000012E                           404mm     ENDM
0000012E  60E4                     405m     BRA LOOP_7
00000130                           406m EXIT_7
00000130                           407m     ENDM
00000130                           408  
00000130  41FA 0F98                409      LEA HELPPROMPT(PC),A0
00000134                           410m     PRINT_STR A0,D3
00000134                           411m LOOP_9
00000134  0C10 0000                412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                413m     BEQ EXIT_9
0000013C                           414mm     PRINT_CHAR (A0)+,D3
0000013C                           415mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      416mm     IFEQ DEBUG
0000013C  1639 00C00003            417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     419mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           421mm     ENDC
0000014E                           422mm 
0000014E                 FALSE     423mm     IFNE DEBUG
0000014E                           424mm     ENDC
0000014E                           425mm 
0000014E                           426mm     ENDM
0000014E  60E4                     427m     BRA LOOP_9
00000150                           428m EXIT_9
00000150                           429m     ENDM
00000150                           430  
00000150                           431m     PRINT_CRLF D3,A0
00000150  41FA 1126                432m     LEA CRLF(PC),A0
00000154                           433mm     PRINT_STR A0,D3
00000154                           434mm LOOP_12
00000154  0C10 0000                435mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                436mm     BEQ EXIT_12
0000015C                           437mmm     PRINT_CHAR (A0)+,D3
0000015C                           438mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      439mmm     IFEQ DEBUG
0000015C  1639 00C00003            440mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                441mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     442mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            443mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           444mmm     ENDC
0000016E                           445mmm 
0000016E                 FALSE     446mmm     IFNE DEBUG
0000016E                           447mmm     ENDC
0000016E                           448mmm 
0000016E                           449mmm     ENDM
0000016E  60E4                     450mm     BRA LOOP_12
00000170                           451mm EXIT_12
00000170                           452mm     ENDM
00000170                           453m     ENDM
00000170                           454  
00000170  7E00                     455      MOVE.L #0,D7                                    ; address accumulator
00000172                           456  
00000172  13FC 0002 00E00001       457      MOVE.B #2,DISPLAY
0000017A                           458  MAIN_LOOP
0000017A  41FA 10FF                459      LEA PROMPT(PC),A0
0000017E                           460m     PRINT_STR A0,D3
0000017E                           461m LOOP_14
0000017E  0C10 0000                462m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                463m     BEQ EXIT_14
00000186                           464mm     PRINT_CHAR (A0)+,D3
00000186                           465mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      466mm     IFEQ DEBUG
00000186  1639 00C00003            467mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                468mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     469mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            470mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           471mm     ENDC
00000198                           472mm 
00000198                 FALSE     473mm     IFNE DEBUG
00000198                           474mm     ENDC
00000198                           475mm 
00000198                           476mm     ENDM
00000198  60E4                     477m     BRA LOOP_14
0000019A                           478m EXIT_14
0000019A                           479m     ENDM
0000019A                           480  
0000019A                           481  GET_INPUT
0000019A                           482m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           483m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      484m     IFEQ DEBUG
0000019A  1639 00C00003            485m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                486m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     487m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           488m     ENDC
000001A6                           489m 
000001A6                           490mm     READ_CHAR D2
000001A6                 TRUE      491mm     IFEQ DEBUG
000001A6  1439 00C00007            492mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           493mm     ENDC
000001AC                 FALSE     494mm     IFNE DEBUG
000001AC                           495mm     ENDC
000001AC                           496mm 
000001AC  B43C 001B                497mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                498mm     BEQ START
000001B4                           499mm     ENDM
000001B4                           500m 
000001B4                 TRUE      501m     IFEQ DEBUG
000001B4                           502mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           503mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      504mm     IFEQ DEBUG
000001B4  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                506mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     507mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            508mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           509mm     ENDC
000001C6                           510mm 
000001C6                 FALSE     511mm     IFNE DEBUG
000001C6                           512mm     ENDC
000001C6                           513mm 
000001C6                           514mm     ENDM
000001C6                           515m     ENDC
000001C6                           516m     ENDM
000001C6                           517  
000001C6                           518      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                519s     CMP.B   #'0',D2
000001CA  6D00 000E                520s     BLT _00000000
000001CE  B43C 0039                521s     CMP.B   #'9',D2
000001D2  6E00 0006                522s     BGT _00000000
000001D6  6000 0ED4                523          BRA HEX_DIGIT
000001DA                           524      ENDI
000001DA                           525s _00000000
000001DA                           526      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                527s     CMP.B   #'A',D2
000001DE  6D00 000E                528s     BLT _00000001
000001E2  B43C 0046                529s     CMP.B   #'F',D2
000001E6  6E00 0006                530s     BGT _00000001
000001EA  6000 0EC0                531          BRA HEX_DIGIT
000001EE                           532      ENDI
000001EE                           533s _00000001
000001EE                           534  
000001EE  B43C 0077                535      CMP.B #'w',D2
000001F2  6700 0192                536      BEQ W
000001F6                           537  
000001F6  B43C 006C                538      CMP.B #'l',D2
000001FA  6700 0A16                539      BEQ L 
000001FE                           540  
000001FE  B43C 0070                541      CMP.B #'p',D2
00000202  6700 0C3E                542      BEQ P
00000206                           543  
00000206  B43C 006D                544      CMP.B #'m',D2
0000020A  6700 0E08                545      BEQ M
0000020E                           546  
0000020E                           547m     PRINT_CRLF D3,A0
0000020E  41FA 1068                548m     LEA CRLF(PC),A0
00000212                           549mm     PRINT_STR A0,D3
00000212                           550mm LOOP_20
00000212  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                552mm     BEQ EXIT_20
0000021A                           553mmm     PRINT_CHAR (A0)+,D3
0000021A                           554mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      555mmm     IFEQ DEBUG
0000021A  1639 00C00003            556mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                557mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     558mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            559mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           560mmm     ENDC
0000022C                           561mmm 
0000022C                 FALSE     562mmm     IFNE DEBUG
0000022C                           563mmm     ENDC
0000022C                           564mmm 
0000022C                           565mmm     ENDM
0000022C  60E4                     566mm     BRA LOOP_20
0000022E                           567mm EXIT_20
0000022E                           568mm     ENDM
0000022E                           569m     ENDM
0000022E                           570   
0000022E  B43C 003F                571      CMP.B #'?',D2
00000232  6700 004E                572      BEQ H
00000236                           573   
00000236  B43C 0076                574      CMP.B #'v',D2
0000023A  6700 004E                575      BEQ V
0000023E                           576      
0000023E  B43C 0072                577      CMP.B #'r',D2
00000242  6700 006A                578      BEQ R
00000246                           579  
00000246  B43C 0073                580      CMP.B #'s',D2
0000024A  6700 01AE                581      BEQ S
0000024E                           582  
0000024E  B43C 0067                583      CMP.B #'g',D2
00000252  6700 08D2                584      BEQ G   
00000256                           585  
00000256  B43C 007A                586      CMP.B #'z',D2
0000025A  6700 08D2                587      BEQ Z   
0000025E                           588  
0000025E  41FA 0F79                589      LEA HUH(PC),A0
00000262                           590m     PRINT_STR A0,D3
00000262                           591m LOOP_22
00000262  0C10 0000                592m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000266  6700 0016                593m     BEQ EXIT_22
0000026A                           594mm     PRINT_CHAR (A0)+,D3
0000026A                           595mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      596mm     IFEQ DEBUG
0000026A  1639 00C00003            597mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000270  0803 0002                598mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000274  67F4                     599mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000276  13D8 00C00007            600mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000027C                           601mm     ENDC
0000027C                           602mm 
0000027C                 FALSE     603mm     IFNE DEBUG
0000027C                           604mm     ENDC
0000027C                           605mm 
0000027C                           606mm     ENDM
0000027C  60E4                     607m     BRA LOOP_22
0000027E                           608m EXIT_22
0000027E                           609m     ENDM
0000027E                           610  
0000027E  6000 FEFA                611      BRA MAIN_LOOP
00000282                           612  
00000282                           613  ; commands
00000282                           614  H
00000282  41FA 0E59                615      LEA HELP(PC),A0
00000286  6000 0006                616      BRA PRINTSTR
0000028A                           617  
0000028A                           618  V
0000028A  41FA 0FFA                619      LEA VERSION(PC),A0
0000028E                           620  PRINTSTR
0000028E                           621m     PRINT_STR A0,D3    
0000028E                           622m LOOP_24
0000028E  0C10 0000                623m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000292  6700 0016                624m     BEQ EXIT_24
00000296                           625mm     PRINT_CHAR (A0)+,D3
00000296                           626mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000296                 TRUE      627mm     IFEQ DEBUG
00000296  1639 00C00003            628mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000029C  0803 0002                629mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A0  67F4                     630mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002A2  13D8 00C00007            631mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A8                           632mm     ENDC
000002A8                           633mm 
000002A8                 FALSE     634mm     IFNE DEBUG
000002A8                           635mm     ENDC
000002A8                           636mm 
000002A8                           637mm     ENDM
000002A8  60E4                     638m     BRA LOOP_24
000002AA                           639m EXIT_24
000002AA                           640m     ENDM
000002AA  6000 FECE                641      BRA MAIN_LOOP
000002AE                           642  
000002AE                           643  R
000002AE  2047                     644      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B0  7E00                     645      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002B2  2410                     646      MOVE.L (A0),D2                                  ; read the memory and print it
000002B4                           647m     PRINT_REG D2,D3,D4,D5,A0
000002B4  41FA 0FC8                648m     LEA OX(PC),A0
000002B8                           649mm     PRINT_STR A0,D3
000002B8                           650mm LOOP_27
000002B8  0C10 0000                651mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BC  6700 0016                652mm     BEQ EXIT_27
000002C0                           653mmm     PRINT_CHAR (A0)+,D3
000002C0                           654mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      655mmm     IFEQ DEBUG
000002C0  1639 00C00003            656mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002C6  0803 0002                657mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002CA  67F4                     658mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002CC  13D8 00C00007            659mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D2                           660mmm     ENDC
000002D2                           661mmm 
000002D2                 FALSE     662mmm     IFNE DEBUG
000002D2                           663mmm     ENDC
000002D2                           664mmm 
000002D2                           665mmm     ENDM
000002D2  60E4                     666mm     BRA LOOP_27
000002D4                           667mm EXIT_27
000002D4                           668mm     ENDM
000002D4  7A07                     669m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002D6                           670m LOOP_26
000002D6                           671mm     BIN2HEX D2,D4,A0
000002D6  41FA 0F65                672mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002DA  E99A                     673mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002DC  1802                     674mm     MOVE.B D2,D4
000002DE  0284 0000000F            675mm     ANDI.L #$F,D4
000002E4  1830 4000                676mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002E8                           677mm     ENDM
000002E8                           678mm     PRINT_CHAR D4,D3
000002E8                           679mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      680mm     IFEQ DEBUG
000002E8  1639 00C00003            681mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EE  0803 0002                682mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002F2  67F4                     683mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002F4  13C4 00C00007            684mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002FA                           685mm     ENDC
000002FA                           686mm 
000002FA                 FALSE     687mm     IFNE DEBUG
000002FA                           688mm     ENDC
000002FA                           689mm 
000002FA                           690mm     ENDM
000002FA  57CD FFDA                691m     DBEQ D5,LOOP_26
000002FE                           692m     ENDM
000002FE                           693      
000002FE                           694m     PRINT_CHAR #32,D3
000002FE                           695m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      696m     IFEQ DEBUG
000002FE  1639 00C00003            697m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                698m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     699m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
0000030A  13FC 0020 00C00007       700m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000312                           701m     ENDC
00000312                           702m 
00000312                 FALSE     703m     IFNE DEBUG
00000312                           704m     ENDC
00000312                           705m 
00000312                           706m     ENDM
00000312                           707  
00000312  E19A                     708      ROL.L #8,D2
00000314                           709m     PRINT_CHAR D2,D3
00000314                           710m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000314                 TRUE      711m     IFEQ DEBUG
00000314  1639 00C00003            712m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000031A  0803 0002                713m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000031E  67F4                     714m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000320  13C2 00C00007            715m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000326                           716m     ENDC
00000326                           717m 
00000326                 FALSE     718m     IFNE DEBUG
00000326                           719m     ENDC
00000326                           720m 
00000326                           721m     ENDM
00000326  E19A                     722      ROL.L #8,D2
00000328                           723m     PRINT_CHAR D2,D3
00000328                           724m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      725m     IFEQ DEBUG
00000328  1639 00C00003            726m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                727m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     728m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000334  13C2 00C00007            729m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000033A                           730m     ENDC
0000033A                           731m 
0000033A                 FALSE     732m     IFNE DEBUG
0000033A                           733m     ENDC
0000033A                           734m 
0000033A                           735m     ENDM
0000033A  E19A                     736      ROL.L #8,D2
0000033C                           737m     PRINT_CHAR D2,D3
0000033C                           738m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      739m     IFEQ DEBUG
0000033C  1639 00C00003            740m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0002                741m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000346  67F4                     742m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000348  13C2 00C00007            743m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000034E                           744m     ENDC
0000034E                           745m 
0000034E                 FALSE     746m     IFNE DEBUG
0000034E                           747m     ENDC
0000034E                           748m 
0000034E                           749m     ENDM
0000034E  E19A                     750      ROL.L #8,D2
00000350                           751m     PRINT_CHAR D2,D3
00000350                           752m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      753m     IFEQ DEBUG
00000350  1639 00C00003            754m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                755m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     756m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
0000035C  13C2 00C00007            757m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000362                           758m     ENDC
00000362                           759m 
00000362                 FALSE     760m     IFNE DEBUG
00000362                           761m     ENDC
00000362                           762m 
00000362                           763m     ENDM
00000362                           764  
00000362                           765m     PRINT_CRLF D3,A0
00000362  41FA 0F14                766m     LEA CRLF(PC),A0
00000366                           767mm     PRINT_STR A0,D3
00000366                           768mm LOOP_37
00000366  0C10 0000                769mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000036A  6700 0016                770mm     BEQ EXIT_37
0000036E                           771mmm     PRINT_CHAR (A0)+,D3
0000036E                           772mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      773mmm     IFEQ DEBUG
0000036E  1639 00C00003            774mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000374  0803 0002                775mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000378  67F4                     776mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000037A  13D8 00C00007            777mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000380                           778mmm     ENDC
00000380                           779mmm 
00000380                 FALSE     780mmm     IFNE DEBUG
00000380                           781mmm     ENDC
00000380                           782mmm 
00000380                           783mmm     ENDM
00000380  60E4                     784mm     BRA LOOP_37
00000382                           785mm EXIT_37
00000382                           786mm     ENDM
00000382                           787m     ENDM
00000382                           788      
00000382  6000 FDF6                789      BRA MAIN_LOOP
00000386                           790  
00000386                           791  W
00000386  3C3C 0007                792      MOVE #7,D6                                      ; 7 bytes left to read
0000038A                           793      
0000038A                           794  READ_DATA_TO_POKE
0000038A  E98D                     795      LSL.L #4,D5                                     ; make what we have so far more significant
0000038C                           796m     WAIT_CHAR D2,D3                                 ; next character -> D2
0000038C                           797m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038C                 TRUE      798m     IFEQ DEBUG
0000038C  1639 00C00003            799m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000392  0803 0000                800m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000396  67F4                     801m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
00000398                           802m     ENDC
00000398                           803m 
00000398                           804mm     READ_CHAR D2
00000398                 TRUE      805mm     IFEQ DEBUG
00000398  1439 00C00007            806mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000039E                           807mm     ENDC
0000039E                 FALSE     808mm     IFNE DEBUG
0000039E                           809mm     ENDC
0000039E                           810mm 
0000039E  B43C 001B                811mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003A2  6700 FC64                812mm     BEQ START
000003A6                           813mm     ENDM
000003A6                           814m 
000003A6                 TRUE      815m     IFEQ DEBUG
000003A6                           816mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003A6                           817mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A6                 TRUE      818mm     IFEQ DEBUG
000003A6  1639 00C00003            819mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003AC  0803 0002                820mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B0  67F4                     821mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003B2  13C2 00C00007            822mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003B8                           823mm     ENDC
000003B8                           824mm 
000003B8                 FALSE     825mm     IFNE DEBUG
000003B8                           826mm     ENDC
000003B8                           827mm 
000003B8                           828mm     ENDM
000003B8                           829m     ENDC
000003B8                           830m     ENDM
000003B8                           831m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003B8  41FA 0E93                832m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003BC  0402 0030                833m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C4BC 000000FF            834m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003C6  1430 2000                835m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003CA                           836m     ENDM
000003CA  8A02                     837      OR.B D2,D5
000003CC  57CE FFBC                838      DBEQ D6,READ_DATA_TO_POKE
000003D0                           839      
000003D0  2047                     840      MOVE.L D7,A0                                    ; address accumulator -> address register
000003D2  7E00                     841      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003D4                           842      
000003D4  2085                     843      MOVE.L D5,(A0)                                  ; write the data
000003D6                           844  
000003D6                           845m     PRINT_CRLF D3,A0
000003D6  41FA 0EA0                846m     LEA CRLF(PC),A0
000003DA                           847mm     PRINT_STR A0,D3
000003DA                           848mm LOOP_44
000003DA  0C10 0000                849mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003DE  6700 0016                850mm     BEQ EXIT_44
000003E2                           851mmm     PRINT_CHAR (A0)+,D3
000003E2                           852mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E2                 TRUE      853mmm     IFEQ DEBUG
000003E2  1639 00C00003            854mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E8  0803 0002                855mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003EC  67F4                     856mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003EE  13D8 00C00007            857mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003F4                           858mmm     ENDC
000003F4                           859mmm 
000003F4                 FALSE     860mmm     IFNE DEBUG
000003F4                           861mmm     ENDC
000003F4                           862mmm 
000003F4                           863mmm     ENDM
000003F4  60E4                     864mm     BRA LOOP_44
000003F6                           865mm EXIT_44
000003F6                           866mm     ENDM
000003F6                           867m     ENDM
000003F6  6000 FD82                868      BRA MAIN_LOOP
000003FA                           869  
000003FA                           870  ; register map for S
000003FA                           871  ; A0 - start address
000003FA                           872  ; A1 - offset
000003FA                           873  ; A2 - next address to write
000003FA                           874  ; A3 - next location (jmp)
000003FA                           875  ; A4 - Working Address Register
000003FA                           876  ; D0 - record count
000003FA                           877  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000003FA                           878  ; D2 - checksum
000003FA                           879  ; D3 - data byte count
000003FA                           880  ; D4 - read address, moved into A2
000003FA                           881  ; D5 - temp
000003FA                           882  ; D6 - temp
000003FA                           883  ; D7 - temp
000003FA                           884  S
000003FA  2078 0000                885      MOVE.L 0,A0                                     ; start address -> A0
000003FE  2247                     886      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000400                           887      
00000400  7000                     888      MOVE.L #0,D0                                    ; count of records read -> D0
00000402                           889          
00000402                           890  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000402                           891m     DOWNLOAD D1
00000402                           892m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           893m 
00000402  1239 00C00003            894m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000408  0801 0000                895m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000040C  6700 0010                896m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000410                           897m 
00000410                           898mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000410                 TRUE      899mm     IFEQ DEBUG
00000410  1239 00C00007            900mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000416                           901mm     ENDC
00000416                 FALSE     902mm     IFNE DEBUG
00000416                           903mm     ENDC
00000416                           904mm 
00000416  B23C 001B                905mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000041A  6700 FBEC                906mm     BEQ START
0000041E                           907mm     ENDM
0000041E                           908m CONTINUE_46
0000041E  1239 00C00013            909m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000424  0801 0000                910m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000428  67D8                     911m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
0000042A                           912m     
0000042A  1239 00C00017            913m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000430  13C1 00E00001            914m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000436                           915m 
00000436                           916m     ENDM
00000436  B23C 0053                917      CMP.B #'S',D1                                   ; found S?
0000043A  66C6                     918      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000043C                           919      
0000043C                           920m     PRINT_CHAR #'S',D5                              ; print the S
0000043C                           921m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043C                 TRUE      922m     IFEQ DEBUG
0000043C  1A39 00C00003            923m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000442  0805 0002                924m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000446  67F4                     925m         BEQ WAIT_FOR_READY_48                       ; NO SPACE, CHECK AGAIN
00000448  13FC 0053 00C00007       926m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000450                           927m     ENDC
00000450                           928m 
00000450                 FALSE     929m     IFNE DEBUG
00000450                           930m     ENDC
00000450                           931m 
00000450                           932m     ENDM
00000450  5280                     933      ADD.L #1,D0                                     ; read another S record, increment count
00000452                           934      
00000452                           935m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000452                           936m WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                           937m 
00000452  1239 00C00003            938m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000458  0801 0000                939m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000045C  6700 0010                940m     BEQ CONTINUE_49                                 ; NOTHING, CONTINUE
00000460                           941m 
00000460                           942mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000460                 TRUE      943mm     IFEQ DEBUG
00000460  1239 00C00007            944mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000466                           945mm     ENDC
00000466                 FALSE     946mm     IFNE DEBUG
00000466                           947mm     ENDC
00000466                           948mm 
00000466  B23C 001B                949mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000046A  6700 FB9C                950mm     BEQ START
0000046E                           951mm     ENDM
0000046E                           952m CONTINUE_49
0000046E  1239 00C00013            953m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000474  0801 0000                954m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000478  67D8                     955m     BEQ WAIT_FOR_READY_49                           ; NOTHING, CHECK AGAIN
0000047A                           956m     
0000047A  1239 00C00017            957m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000480  13C1 00E00001            958m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000486                           959m 
00000486                           960m     ENDM
00000486                           961m     PRINT_CHAR D1,D5
00000486                           962m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                 TRUE      963m     IFEQ DEBUG
00000486  1A39 00C00003            964m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000048C  0805 0002                965m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000490  67F4                     966m         BEQ WAIT_FOR_READY_51                       ; NO SPACE, CHECK AGAIN
00000492  13C1 00C00007            967m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000498                           968m     ENDC
00000498                           969m 
00000498                 FALSE     970m     IFNE DEBUG
00000498                           971m     ENDC
00000498                           972m 
00000498                           973m     ENDM
00000498                           974  
00000498  7400                     975      MOVE.L #0,D2                                    ; clear the checksum
0000049A                           976  
0000049A                           977m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000049A  1E3C 0002                978m     MOVE.B #2,D7
0000049E                           979m     WHILE.B D7 <GT> 0 DO
0000049E                           980ms _10000000
0000049E  BE38 0000                981ms     CMP.B   0,D7
000004A2  6F00 0062                982ms     BLE _10000001
000004A6  E98B                     983m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000004A8                           984mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004A8                           985mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A8                           986mm 
000004A8  1A39 00C00003            987mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004AE  0805 0000                988mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004B2  6700 0010                989mm     BEQ CONTINUE_53                                 ; NOTHING, CONTINUE
000004B6                           990mm 
000004B6                           991mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000004B6                 TRUE      992mmm     IFEQ DEBUG
000004B6  1A39 00C00007            993mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004BC                           994mmm     ENDC
000004BC                 FALSE     995mmm     IFNE DEBUG
000004BC                           996mmm     ENDC
000004BC                           997mmm 
000004BC  BA3C 001B                998mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000004C0  6700 FB46                999mmm     BEQ START
000004C4                          1000mmm     ENDM
000004C4                          1001mm CONTINUE_53
000004C4  1A39 00C00013           1002mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004CA  0805 0000               1003mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004CE  67D8                    1004mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D0                          1005mm     
000004D0  1A39 00C00017           1006mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004D6  13C5 00E00001           1007mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004DC                          1008mm 
000004DC                          1009mm     ENDM
000004DC                          1010mm         PRINT_CHAR D5,D6
000004DC                          1011mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DC                 TRUE     1012mm     IFEQ DEBUG
000004DC  1C39 00C00003           1013mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000004E2  0806 0002               1014mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000004E6  67F4                    1015mm         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
000004E8  13C5 00C00007           1016mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004EE                          1017mm     ENDC
000004EE                          1018mm 
000004EE                 FALSE    1019mm     IFNE DEBUG
000004EE                          1020mm     ENDC
000004EE                          1021mm 
000004EE                          1022mm     ENDM
000004EE                          1023mm         HEX2BIN D5,D5,A4
000004EE  49FA 0D5D               1024mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004F2  0405 0030               1025mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004F6  CABC 000000FF           1026mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000004FC  1A34 5000               1027mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000500                          1028mm     ENDM
00000500  8605                    1029m         OR.B D5,D3
00000502  5307                    1030m         SUB.B #1,D7
00000504                          1031m     ENDW
00000504  6098                    1032ms     BRA _10000000
00000506                          1033ms _10000001
00000506                          1034m 
00000506  7A00                    1035m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000508  1A03                    1036m     MOVE.B D3,D5
0000050A  D483                    1037m     ADD.L D3,D2
0000050C                          1038m 
0000050C                          1039m     ENDM
0000050C                          1040  
0000050C                          1041      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000050C  B23C 0030               1042s     CMP.B   #'0',D1
00000510  6600 002A               1043s     BNE.L   _00000002
00000514                          1044m         PRINT_CRLF D5,A4
00000514  49FA 0D62               1045m     LEA CRLF(PC),A4
00000518                          1046mm     PRINT_STR A4,D5
00000518                          1047mm LOOP_58
00000518  0C14 0000               1048mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000051C  6700 0016               1049mm     BEQ EXIT_58
00000520                          1050mmm     PRINT_CHAR (A4)+,D5
00000520                          1051mmm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000520                 TRUE     1052mmm     IFEQ DEBUG
00000520  1A39 00C00003           1053mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000526  0805 0002               1054mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000052A  67F4                    1055mmm         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
0000052C  13DC 00C00007           1056mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000532                          1057mmm     ENDC
00000532                          1058mmm 
00000532                 FALSE    1059mmm     IFNE DEBUG
00000532                          1060mmm     ENDC
00000532                          1061mmm 
00000532                          1062mmm     ENDM
00000532  60E4                    1063mm     BRA LOOP_58
00000534                          1064mm EXIT_58
00000534                          1065mm     ENDM
00000534                          1066m     ENDM
00000534  6000 FECC               1067          BRA WAIT_FOR_SRECORD
00000538                          1068      ELSE
00000538  6000 03DE               1069s     BRA _00000003
0000053C                          1070s _00000002
0000053C                          1071          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000053C  B23C 0031               1072s     CMP.B   #'1',D1
00000540  6708                    1073s     BEQ.S   _00000004
00000542  B23C 0032               1074s     CMP.B   #'2',D1
00000546  6600 01F0               1075s     BNE.L   _00000005
0000054A                          1076s _00000004
0000054A  5783                    1077              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000054C                          1078  
0000054C  7800                    1079              MOVE.L #0,D4                            ; read two bytes of address
0000054E                          1080m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
0000054E  1E3C 0002               1081m     MOVE.B #2,D7
00000552                          1082m     WHILE.B D7 <GT> 0 DO
00000552                          1083ms _10000002
00000552  BE38 0000               1084ms     CMP.B   0,D7
00000556  6F00 0062               1085ms     BLE _10000003
0000055A  E98C                    1086m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000055C                          1087mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000055C                          1088mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000055C                          1089mm 
0000055C  1A39 00C00003           1090mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000562  0805 0000               1091mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000566  6700 0010               1092mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000056A                          1093mm 
0000056A                          1094mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000056A                 TRUE     1095mmm     IFEQ DEBUG
0000056A  1A39 00C00007           1096mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000570                          1097mmm     ENDC
00000570                 FALSE    1098mmm     IFNE DEBUG
00000570                          1099mmm     ENDC
00000570                          1100mmm 
00000570  BA3C 001B               1101mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000574  6700 FA92               1102mmm     BEQ START
00000578                          1103mmm     ENDM
00000578                          1104mm CONTINUE_61
00000578  1A39 00C00013           1105mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000057E  0805 0000               1106mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000582  67D8                    1107mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000584                          1108mm     
00000584  1A39 00C00017           1109mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000058A  13C5 00E00001           1110mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000590                          1111mm 
00000590                          1112mm     ENDM
00000590                          1113mm         PRINT_CHAR D5,D6
00000590                          1114mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000590                 TRUE     1115mm     IFEQ DEBUG
00000590  1C39 00C00003           1116mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000596  0806 0002               1117mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000059A  67F4                    1118mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
0000059C  13C5 00C00007           1119mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A2                          1120mm     ENDC
000005A2                          1121mm 
000005A2                 FALSE    1122mm     IFNE DEBUG
000005A2                          1123mm     ENDC
000005A2                          1124mm 
000005A2                          1125mm     ENDM
000005A2                          1126mm         HEX2BIN D5,D5,A4
000005A2  49FA 0CA9               1127mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005A6  0405 0030               1128mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AA  CABC 000000FF           1129mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005B0  1A34 5000               1130mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B4                          1131mm     ENDM
000005B4  8805                    1132m         OR.B D5,D4
000005B6  5307                    1133m         SUB.B #1,D7
000005B8                          1134m     ENDW
000005B8  6098                    1135ms     BRA _10000002
000005BA                          1136ms _10000003
000005BA                          1137m 
000005BA  7A00                    1138m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005BC  1A04                    1139m     MOVE.B D4,D5
000005BE  D484                    1140m     ADD.L D4,D2
000005C0                          1141m 
000005C0                          1142m     ENDM
000005C0                          1143m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000005C0  1E3C 0002               1144m     MOVE.B #2,D7
000005C4                          1145m     WHILE.B D7 <GT> 0 DO
000005C4                          1146ms _10000004
000005C4  BE38 0000               1147ms     CMP.B   0,D7
000005C8  6F00 0062               1148ms     BLE _10000005
000005CC  E98C                    1149m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005CE                          1150mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005CE                          1151mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                          1152mm 
000005CE  1A39 00C00003           1153mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005D4  0805 0000               1154mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D8  6700 0010               1155mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005DC                          1156mm 
000005DC                          1157mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005DC                 TRUE     1158mmm     IFEQ DEBUG
000005DC  1A39 00C00007           1159mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005E2                          1160mmm     ENDC
000005E2                 FALSE    1161mmm     IFNE DEBUG
000005E2                          1162mmm     ENDC
000005E2                          1163mmm 
000005E2  BA3C 001B               1164mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005E6  6700 FA20               1165mmm     BEQ START
000005EA                          1166mmm     ENDM
000005EA                          1167mm CONTINUE_66
000005EA  1A39 00C00013           1168mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F0  0805 0000               1169mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005F4  67D8                    1170mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
000005F6                          1171mm     
000005F6  1A39 00C00017           1172mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005FC  13C5 00E00001           1173mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000602                          1174mm 
00000602                          1175mm     ENDM
00000602                          1176mm         PRINT_CHAR D5,D6
00000602                          1177mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000602                 TRUE     1178mm     IFEQ DEBUG
00000602  1C39 00C00003           1179mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000608  0806 0002               1180mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000060C  67F4                    1181mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
0000060E  13C5 00C00007           1182mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000614                          1183mm     ENDC
00000614                          1184mm 
00000614                 FALSE    1185mm     IFNE DEBUG
00000614                          1186mm     ENDC
00000614                          1187mm 
00000614                          1188mm     ENDM
00000614                          1189mm         HEX2BIN D5,D5,A4
00000614  49FA 0C37               1190mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000618  0405 0030               1191mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000061C  CABC 000000FF           1192mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000622  1A34 5000               1193mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000626                          1194mm     ENDM
00000626  8805                    1195m         OR.B D5,D4
00000628  5307                    1196m         SUB.B #1,D7
0000062A                          1197m     ENDW
0000062A  6098                    1198ms     BRA _10000004
0000062C                          1199ms _10000005
0000062C                          1200m 
0000062C  7A00                    1201m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000062E  1A04                    1202m     MOVE.B D4,D5
00000630  D484                    1203m     ADD.L D4,D2
00000632                          1204m 
00000632                          1205m     ENDM
00000632                          1206  
00000632                          1207              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000632  B23C 0032               1208s     CMP.B   #'2',D1
00000636  6600 0076               1209s     BNE.L   _00000006
0000063A  5383                    1210                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000063C                          1211m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000063C  1E3C 0002               1212m     MOVE.B #2,D7
00000640                          1213m     WHILE.B D7 <GT> 0 DO
00000640                          1214ms _10000006
00000640  BE38 0000               1215ms     CMP.B   0,D7
00000644  6F00 0062               1216ms     BLE _10000007
00000648  E98C                    1217m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000064A                          1218mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000064A                          1219mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000064A                          1220mm 
0000064A  1A39 00C00003           1221mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000650  0805 0000               1222mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000654  6700 0010               1223mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
00000658                          1224mm 
00000658                          1225mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000658                 TRUE     1226mmm     IFEQ DEBUG
00000658  1A39 00C00007           1227mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000065E                          1228mmm     ENDC
0000065E                 FALSE    1229mmm     IFNE DEBUG
0000065E                          1230mmm     ENDC
0000065E                          1231mmm 
0000065E  BA3C 001B               1232mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000662  6700 F9A4               1233mmm     BEQ START
00000666                          1234mmm     ENDM
00000666                          1235mm CONTINUE_71
00000666  1A39 00C00013           1236mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000066C  0805 0000               1237mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000670  67D8                    1238mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
00000672                          1239mm     
00000672  1A39 00C00017           1240mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000678  13C5 00E00001           1241mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000067E                          1242mm 
0000067E                          1243mm     ENDM
0000067E                          1244mm         PRINT_CHAR D5,D6
0000067E                          1245mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000067E                 TRUE     1246mm     IFEQ DEBUG
0000067E  1C39 00C00003           1247mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000684  0806 0002               1248mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000688  67F4                    1249mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
0000068A  13C5 00C00007           1250mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000690                          1251mm     ENDC
00000690                          1252mm 
00000690                 FALSE    1253mm     IFNE DEBUG
00000690                          1254mm     ENDC
00000690                          1255mm 
00000690                          1256mm     ENDM
00000690                          1257mm         HEX2BIN D5,D5,A4
00000690  49FA 0BBB               1258mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000694  0405 0030               1259mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000698  CABC 000000FF           1260mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000069E  1A34 5000               1261mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006A2                          1262mm     ENDM
000006A2  8805                    1263m         OR.B D5,D4
000006A4  5307                    1264m         SUB.B #1,D7
000006A6                          1265m     ENDW
000006A6  6098                    1266ms     BRA _10000006
000006A8                          1267ms _10000007
000006A8                          1268m 
000006A8  7A00                    1269m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006AA  1A04                    1270m     MOVE.B D4,D5
000006AC  D484                    1271m     ADD.L D4,D2
000006AE                          1272m 
000006AE                          1273m     ENDM
000006AE                          1274              ENDI
000006AE                          1275s _00000006
000006AE                          1276  
000006AE  2444                    1277              MOVE.L D4,A2                            ; put the address in an address register
000006B0  D5C9                    1278              ADD.L A1,A2                             ; add in the offset
000006B2                          1279  
000006B2                          1280              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000006B2                          1281s _10000008
000006B2  B63C 0000               1282s     CMP.B   #0,D3
000006B6  6F00 007A               1283s     BLE _10000009
000006BA                          1284m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000006BA  1E3C 0002               1285m     MOVE.B #2,D7
000006BE                          1286m     WHILE.B D7 <GT> 0 DO
000006BE                          1287ms _1000000A
000006BE  BE38 0000               1288ms     CMP.B   0,D7
000006C2  6F00 0062               1289ms     BLE _1000000B
000006C6  E989                    1290m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000006C8                          1291mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006C8                          1292mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006C8                          1293mm 
000006C8  1A39 00C00003           1294mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006CE  0805 0000               1295mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006D2  6700 0010               1296mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006D6                          1297mm 
000006D6                          1298mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006D6                 TRUE     1299mmm     IFEQ DEBUG
000006D6  1A39 00C00007           1300mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006DC                          1301mmm     ENDC
000006DC                 FALSE    1302mmm     IFNE DEBUG
000006DC                          1303mmm     ENDC
000006DC                          1304mmm 
000006DC  BA3C 001B               1305mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006E0  6700 F926               1306mmm     BEQ START
000006E4                          1307mmm     ENDM
000006E4                          1308mm CONTINUE_76
000006E4  1A39 00C00013           1309mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006EA  0805 0000               1310mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006EE  67D8                    1311mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
000006F0                          1312mm     
000006F0  1A39 00C00017           1313mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006F6  13C5 00E00001           1314mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006FC                          1315mm 
000006FC                          1316mm     ENDM
000006FC                          1317mm         PRINT_CHAR D5,D6
000006FC                          1318mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                 TRUE     1319mm     IFEQ DEBUG
000006FC  1C39 00C00003           1320mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000702  0806 0002               1321mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000706  67F4                    1322mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
00000708  13C5 00C00007           1323mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000070E                          1324mm     ENDC
0000070E                          1325mm 
0000070E                 FALSE    1326mm     IFNE DEBUG
0000070E                          1327mm     ENDC
0000070E                          1328mm 
0000070E                          1329mm     ENDM
0000070E                          1330mm         HEX2BIN D5,D5,A4
0000070E  49FA 0B3D               1331mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000712  0405 0030               1332mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000716  CABC 000000FF           1333mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000071C  1A34 5000               1334mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000720                          1335mm     ENDM
00000720  8205                    1336m         OR.B D5,D1
00000722  5307                    1337m         SUB.B #1,D7
00000724                          1338m     ENDW
00000724  6098                    1339ms     BRA _1000000A
00000726                          1340ms _1000000B
00000726                          1341m 
00000726  7A00                    1342m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000728  1A01                    1343m     MOVE.B D1,D5
0000072A  D481                    1344m     ADD.L D1,D2
0000072C                          1345m 
0000072C                          1346m     ENDM
0000072C                          1347   
0000072C  14C1                    1348                  MOVE.B D1,(A2)+                     ; store it!
0000072E                          1349  
0000072E  5303                    1350                  SUB.B #1,D3                         ; 1 less byte to go
00000730                          1351              ENDW
00000730  6080                    1352s     BRA _10000008
00000732                          1353s _10000009
00000732                          1354  
00000732  7200                    1355              MOVE.L #0,D1                            ; not done yet
00000734                          1356          ELSE
00000734  6000 01E2               1357s     BRA _00000007
00000738                          1358s _00000005
00000738                          1359              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000738  B23C 0038               1360s     CMP.B   #'8',D1
0000073C  6600 0164               1361s     BNE.L   _00000008
00000740  7800                    1362                  MOVE.L #0,D4                        ; read the 24 bit start address
00000742                          1363m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000742  1E3C 0002               1364m     MOVE.B #2,D7
00000746                          1365m     WHILE.B D7 <GT> 0 DO
00000746                          1366ms _1000000C
00000746  BE38 0000               1367ms     CMP.B   0,D7
0000074A  6F00 0062               1368ms     BLE _1000000D
0000074E  E98C                    1369m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000750                          1370mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000750                          1371mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000750                          1372mm 
00000750  1A39 00C00003           1373mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000756  0805 0000               1374mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000075A  6700 0010               1375mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
0000075E                          1376mm 
0000075E                          1377mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075E                 TRUE     1378mmm     IFEQ DEBUG
0000075E  1A39 00C00007           1379mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000764                          1380mmm     ENDC
00000764                 FALSE    1381mmm     IFNE DEBUG
00000764                          1382mmm     ENDC
00000764                          1383mmm 
00000764  BA3C 001B               1384mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000768  6700 F89E               1385mmm     BEQ START
0000076C                          1386mmm     ENDM
0000076C                          1387mm CONTINUE_81
0000076C  1A39 00C00013           1388mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000772  0805 0000               1389mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000776  67D8                    1390mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00000778                          1391mm     
00000778  1A39 00C00017           1392mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077E  13C5 00E00001           1393mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000784                          1394mm 
00000784                          1395mm     ENDM
00000784                          1396mm         PRINT_CHAR D5,D6
00000784                          1397mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                 TRUE     1398mm     IFEQ DEBUG
00000784  1C39 00C00003           1399mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000078A  0806 0002               1400mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078E  67F4                    1401mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000790  13C5 00C00007           1402mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000796                          1403mm     ENDC
00000796                          1404mm 
00000796                 FALSE    1405mm     IFNE DEBUG
00000796                          1406mm     ENDC
00000796                          1407mm 
00000796                          1408mm     ENDM
00000796                          1409mm         HEX2BIN D5,D5,A4
00000796  49FA 0AB5               1410mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000079A  0405 0030               1411mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079E  CABC 000000FF           1412mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A4  1A34 5000               1413mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A8                          1414mm     ENDM
000007A8  8805                    1415m         OR.B D5,D4
000007AA  5307                    1416m         SUB.B #1,D7
000007AC                          1417m     ENDW
000007AC  6098                    1418ms     BRA _1000000C
000007AE                          1419ms _1000000D
000007AE                          1420m 
000007AE  7A00                    1421m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B0  1A04                    1422m     MOVE.B D4,D5
000007B2  D484                    1423m     ADD.L D4,D2
000007B4                          1424m 
000007B4                          1425m     ENDM
000007B4                          1426m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000007B4  1E3C 0002               1427m     MOVE.B #2,D7
000007B8                          1428m     WHILE.B D7 <GT> 0 DO
000007B8                          1429ms _1000000E
000007B8  BE38 0000               1430ms     CMP.B   0,D7
000007BC  6F00 0062               1431ms     BLE _1000000F
000007C0  E98C                    1432m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C2                          1433mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C2                          1434mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C2                          1435mm 
000007C2  1A39 00C00003           1436mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007C8  0805 0000               1437mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CC  6700 0010               1438mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007D0                          1439mm 
000007D0                          1440mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007D0                 TRUE     1441mmm     IFEQ DEBUG
000007D0  1A39 00C00007           1442mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007D6                          1443mmm     ENDC
000007D6                 FALSE    1444mmm     IFNE DEBUG
000007D6                          1445mmm     ENDC
000007D6                          1446mmm 
000007D6  BA3C 001B               1447mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007DA  6700 F82C               1448mmm     BEQ START
000007DE                          1449mmm     ENDM
000007DE                          1450mm CONTINUE_86
000007DE  1A39 00C00013           1451mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E4  0805 0000               1452mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E8  67D8                    1453mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007EA                          1454mm     
000007EA  1A39 00C00017           1455mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007F0  13C5 00E00001           1456mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F6                          1457mm 
000007F6                          1458mm     ENDM
000007F6                          1459mm         PRINT_CHAR D5,D6
000007F6                          1460mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F6                 TRUE     1461mm     IFEQ DEBUG
000007F6  1C39 00C00003           1462mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007FC  0806 0002               1463mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000800  67F4                    1464mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
00000802  13C5 00C00007           1465mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000808                          1466mm     ENDC
00000808                          1467mm 
00000808                 FALSE    1468mm     IFNE DEBUG
00000808                          1469mm     ENDC
00000808                          1470mm 
00000808                          1471mm     ENDM
00000808                          1472mm         HEX2BIN D5,D5,A4
00000808  49FA 0A43               1473mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080C  0405 0030               1474mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000810  CABC 000000FF           1475mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000816  1A34 5000               1476mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000081A                          1477mm     ENDM
0000081A  8805                    1478m         OR.B D5,D4
0000081C  5307                    1479m         SUB.B #1,D7
0000081E                          1480m     ENDW
0000081E  6098                    1481ms     BRA _1000000E
00000820                          1482ms _1000000F
00000820                          1483m 
00000820  7A00                    1484m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000822  1A04                    1485m     MOVE.B D4,D5
00000824  D484                    1486m     ADD.L D4,D2
00000826                          1487m 
00000826                          1488m     ENDM
00000826                          1489m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000826  1E3C 0002               1490m     MOVE.B #2,D7
0000082A                          1491m     WHILE.B D7 <GT> 0 DO
0000082A                          1492ms _10000010
0000082A  BE38 0000               1493ms     CMP.B   0,D7
0000082E  6F00 0062               1494ms     BLE _10000011
00000832  E98C                    1495m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000834                          1496mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000834                          1497mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000834                          1498mm 
00000834  1A39 00C00003           1499mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000083A  0805 0000               1500mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000083E  6700 0010               1501mm     BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
00000842                          1502mm 
00000842                          1503mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000842                 TRUE     1504mmm     IFEQ DEBUG
00000842  1A39 00C00007           1505mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000848                          1506mmm     ENDC
00000848                 FALSE    1507mmm     IFNE DEBUG
00000848                          1508mmm     ENDC
00000848                          1509mmm 
00000848  BA3C 001B               1510mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000084C  6700 F7BA               1511mmm     BEQ START
00000850                          1512mmm     ENDM
00000850                          1513mm CONTINUE_91
00000850  1A39 00C00013           1514mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000856  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085A  67D8                    1516mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
0000085C                          1517mm     
0000085C  1A39 00C00017           1518mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000862  13C5 00E00001           1519mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000868                          1520mm 
00000868                          1521mm     ENDM
00000868                          1522mm         PRINT_CHAR D5,D6
00000868                          1523mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000868                 TRUE     1524mm     IFEQ DEBUG
00000868  1C39 00C00003           1525mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000086E  0806 0002               1526mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000872  67F4                    1527mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
00000874  13C5 00C00007           1528mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000087A                          1529mm     ENDC
0000087A                          1530mm 
0000087A                 FALSE    1531mm     IFNE DEBUG
0000087A                          1532mm     ENDC
0000087A                          1533mm 
0000087A                          1534mm     ENDM
0000087A                          1535mm         HEX2BIN D5,D5,A4
0000087A  49FA 09D1               1536mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000087E  0405 0030               1537mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000882  CABC 000000FF           1538mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000888  1A34 5000               1539mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000088C                          1540mm     ENDM
0000088C  8805                    1541m         OR.B D5,D4
0000088E  5307                    1542m         SUB.B #1,D7
00000890                          1543m     ENDW
00000890  6098                    1544ms     BRA _10000010
00000892                          1545ms _10000011
00000892                          1546m 
00000892  7A00                    1547m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000894  1A04                    1548m     MOVE.B D4,D5
00000896  D484                    1549m     ADD.L D4,D2
00000898                          1550m 
00000898                          1551m     ENDM
00000898                          1552  
00000898  2044                    1553                  MOVE.L D4,A0                        ; start address -> A0
0000089A  D1C9                    1554                  ADD.L A1,A0                         ; add in the offset
0000089C                          1555  
0000089C  72FF                    1556                  MOVE.L #$FFFFFFFF,D1                ; done
0000089E                          1557              ELSE
0000089E  6000 0078               1558s     BRA _00000009
000008A2                          1559s _00000008
000008A2                          1560m                 PRINT_CRLF D5,A4
000008A2  49FA 09D4               1561m     LEA CRLF(PC),A4
000008A6                          1562mm     PRINT_STR A4,D5
000008A6                          1563mm LOOP_96
000008A6  0C14 0000               1564mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008AA  6700 0016               1565mm     BEQ EXIT_96
000008AE                          1566mmm     PRINT_CHAR (A4)+,D5
000008AE                          1567mmm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AE                 TRUE     1568mmm     IFEQ DEBUG
000008AE  1A39 00C00003           1569mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008B4  0805 0002               1570mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008B8  67F4                    1571mmm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
000008BA  13DC 00C00007           1572mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008C0                          1573mmm     ENDC
000008C0                          1574mmm 
000008C0                 FALSE    1575mmm     IFNE DEBUG
000008C0                          1576mmm     ENDC
000008C0                          1577mmm 
000008C0                          1578mmm     ENDM
000008C0  60E4                    1579mm     BRA LOOP_96
000008C2                          1580mm EXIT_96
000008C2                          1581mm     ENDM
000008C2                          1582m     ENDM
000008C2                          1583  
000008C2  49FA 093E               1584                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008C6                          1585m                 PRINT_STR A4,D5
000008C6                          1586m LOOP_98
000008C6  0C14 0000               1587m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008CA  6700 0016               1588m     BEQ EXIT_98
000008CE                          1589mm     PRINT_CHAR (A4)+,D5
000008CE                          1590mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008CE                 TRUE     1591mm     IFEQ DEBUG
000008CE  1A39 00C00003           1592mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008D4  0805 0002               1593mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008D8  67F4                    1594mm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
000008DA  13DC 00C00007           1595mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008E0                          1596mm     ENDC
000008E0                          1597mm 
000008E0                 FALSE    1598mm     IFNE DEBUG
000008E0                          1599mm     ENDC
000008E0                          1600mm 
000008E0                          1601mm     ENDM
000008E0  60E4                    1602m     BRA LOOP_98
000008E2                          1603m EXIT_98
000008E2                          1604m     ENDM
000008E2                          1605m                 PRINT_CHAR D1,D5
000008E2                          1606m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E2                 TRUE     1607m     IFEQ DEBUG
000008E2  1A39 00C00003           1608m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008E8  0805 0002               1609m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008EC  67F4                    1610m         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000008EE  13C1 00C00007           1611m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008F4                          1612m     ENDC
000008F4                          1613m 
000008F4                 FALSE    1614m     IFNE DEBUG
000008F4                          1615m     ENDC
000008F4                          1616m 
000008F4                          1617m     ENDM
000008F4                          1618m                 PRINT_CRLF D5,A4
000008F4  49FA 0982               1619m     LEA CRLF(PC),A4
000008F8                          1620mm     PRINT_STR A4,D5
000008F8                          1621mm LOOP_102
000008F8  0C14 0000               1622mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008FC  6700 0016               1623mm     BEQ EXIT_102
00000900                          1624mmm     PRINT_CHAR (A4)+,D5
00000900                          1625mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000900                 TRUE     1626mmm     IFEQ DEBUG
00000900  1A39 00C00003           1627mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000906  0805 0002               1628mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000090A  67F4                    1629mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
0000090C  13DC 00C00007           1630mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000912                          1631mmm     ENDC
00000912                          1632mmm 
00000912                 FALSE    1633mmm     IFNE DEBUG
00000912                          1634mmm     ENDC
00000912                          1635mmm 
00000912                          1636mmm     ENDM
00000912  60E4                    1637mm     BRA LOOP_102
00000914                          1638mm EXIT_102
00000914                          1639mm     ENDM
00000914                          1640m     ENDM
00000914                          1641  
00000914  6000 FAEC               1642                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000918                          1643              ENDI
00000918                          1644s _00000009
00000918                          1645          ENDI
00000918                          1646s _00000007
00000918                          1647      ENDI
00000918                          1648s _00000003
00000918                          1649  
00000918                          1650m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000918  1E3C 0002               1651m     MOVE.B #2,D7
0000091C                          1652m     WHILE.B D7 <GT> 0 DO
0000091C                          1653ms _10000012
0000091C  BE38 0000               1654ms     CMP.B   0,D7
00000920  6F00 0062               1655ms     BLE _10000013
00000924  E98C                    1656m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000926                          1657mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000926                          1658mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000926                          1659mm 
00000926  1A39 00C00003           1660mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000092C  0805 0000               1661mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000930  6700 0010               1662mm     BEQ CONTINUE_105                                    ; NOTHING, CONTINUE
00000934                          1663mm 
00000934                          1664mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000934                 TRUE     1665mmm     IFEQ DEBUG
00000934  1A39 00C00007           1666mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000093A                          1667mmm     ENDC
0000093A                 FALSE    1668mmm     IFNE DEBUG
0000093A                          1669mmm     ENDC
0000093A                          1670mmm 
0000093A  BA3C 001B               1671mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000093E  6700 F6C8               1672mmm     BEQ START
00000942                          1673mmm     ENDM
00000942                          1674mm CONTINUE_105
00000942  1A39 00C00013           1675mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000948  0805 0000               1676mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094C  67D8                    1677mm     BEQ WAIT_FOR_READY_105                          ; NOTHING, CHECK AGAIN
0000094E                          1678mm     
0000094E  1A39 00C00017           1679mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000954  13C5 00E00001           1680mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000095A                          1681mm 
0000095A                          1682mm     ENDM
0000095A                          1683mm         PRINT_CHAR D5,D6
0000095A                          1684mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095A                 TRUE     1685mm     IFEQ DEBUG
0000095A  1C39 00C00003           1686mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000960  0806 0002               1687mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000964  67F4                    1688mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000966  13C5 00C00007           1689mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000096C                          1690mm     ENDC
0000096C                          1691mm 
0000096C                 FALSE    1692mm     IFNE DEBUG
0000096C                          1693mm     ENDC
0000096C                          1694mm 
0000096C                          1695mm     ENDM
0000096C                          1696mm         HEX2BIN D5,D5,A4
0000096C  49FA 08DF               1697mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000970  0405 0030               1698mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000974  CABC 000000FF           1699mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000097A  1A34 5000               1700mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000097E                          1701mm     ENDM
0000097E  8805                    1702m         OR.B D5,D4
00000980  5307                    1703m         SUB.B #1,D7
00000982                          1704m     ENDW
00000982  6098                    1705ms     BRA _10000012
00000984                          1706ms _10000013
00000984                          1707m 
00000984  7A00                    1708m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000986  1A04                    1709m     MOVE.B D4,D5
00000988  D484                    1710m     ADD.L D4,D2
0000098A                          1711m 
0000098A                          1712m     ENDM
0000098A                          1713m     PRINT_CRLF D5,A4
0000098A  49FA 08EC               1714m     LEA CRLF(PC),A4
0000098E                          1715mm     PRINT_STR A4,D5
0000098E                          1716mm LOOP_110
0000098E  0C14 0000               1717mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000992  6700 0016               1718mm     BEQ EXIT_110
00000996                          1719mmm     PRINT_CHAR (A4)+,D5
00000996                          1720mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000996                 TRUE     1721mmm     IFEQ DEBUG
00000996  1A39 00C00003           1722mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000099C  0805 0002               1723mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A0  67F4                    1724mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009A2  13DC 00C00007           1725mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009A8                          1726mmm     ENDC
000009A8                          1727mmm 
000009A8                 FALSE    1728mmm     IFNE DEBUG
000009A8                          1729mmm     ENDC
000009A8                          1730mmm 
000009A8                          1731mmm     ENDM
000009A8  60E4                    1732mm     BRA LOOP_110
000009AA                          1733mm EXIT_110
000009AA                          1734mm     ENDM
000009AA                          1735m     ENDM
000009AA                          1736  
000009AA                          1737      IF.B D2 <NE> #$FF THEN.L
000009AA  B43C 00FF               1738s     CMP.B   #$FF,D2
000009AE  6700 0090               1739s     BEQ.L   _0000000A
000009B2  49FA 0865               1740          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009B6                          1741m         PRINT_STR A4,D5
000009B6                          1742m LOOP_112
000009B6  0C14 0000               1743m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009BA  6700 0016               1744m     BEQ EXIT_112
000009BE                          1745mm     PRINT_CHAR (A4)+,D5
000009BE                          1746mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BE                 TRUE     1747mm     IFEQ DEBUG
000009BE  1A39 00C00003           1748mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009C4  0805 0002               1749mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009C8  67F4                    1750mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009CA  13DC 00C00007           1751mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009D0                          1752mm     ENDC
000009D0                          1753mm 
000009D0                 FALSE    1754mm     IFNE DEBUG
000009D0                          1755mm     ENDC
000009D0                          1756mm 
000009D0                          1757mm     ENDM
000009D0  60E4                    1758m     BRA LOOP_112
000009D2                          1759m EXIT_112
000009D2                          1760m     ENDM
000009D2                          1761m         PRINT_REG D0,D5,D2,D6,A4
000009D2  49FA 08AA               1762m     LEA OX(PC),A4
000009D6                          1763mm     PRINT_STR A4,D5
000009D6                          1764mm LOOP_115
000009D6  0C14 0000               1765mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009DA  6700 0016               1766mm     BEQ EXIT_115
000009DE                          1767mmm     PRINT_CHAR (A4)+,D5
000009DE                          1768mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009DE                 TRUE     1769mmm     IFEQ DEBUG
000009DE  1A39 00C00003           1770mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009E4  0805 0002               1771mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009E8  67F4                    1772mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009EA  13DC 00C00007           1773mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F0                          1774mmm     ENDC
000009F0                          1775mmm 
000009F0                 FALSE    1776mmm     IFNE DEBUG
000009F0                          1777mmm     ENDC
000009F0                          1778mmm 
000009F0                          1779mmm     ENDM
000009F0  60E4                    1780mm     BRA LOOP_115
000009F2                          1781mm EXIT_115
000009F2                          1782mm     ENDM
000009F2  7C07                    1783m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009F4                          1784m LOOP_114
000009F4                          1785mm     BIN2HEX D0,D2,A4
000009F4  49FA 0847               1786mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009F8  E998                    1787mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009FA  1400                    1788mm     MOVE.B D0,D2
000009FC  0282 0000000F           1789mm     ANDI.L #$F,D2
00000A02  1434 2000               1790mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000A06                          1791mm     ENDM
00000A06                          1792mm     PRINT_CHAR D2,D5
00000A06                          1793mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A06                 TRUE     1794mm     IFEQ DEBUG
00000A06  1A39 00C00003           1795mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A0C  0805 0002               1796mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A10  67F4                    1797mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A12  13C2 00C00007           1798mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A18                          1799mm     ENDC
00000A18                          1800mm 
00000A18                 FALSE    1801mm     IFNE DEBUG
00000A18                          1802mm     ENDC
00000A18                          1803mm 
00000A18                          1804mm     ENDM
00000A18  57CE FFDA               1805m     DBEQ D6,LOOP_114
00000A1C                          1806m     ENDM
00000A1C                          1807m         PRINT_CRLF D5,A4
00000A1C  49FA 085A               1808m     LEA CRLF(PC),A4
00000A20                          1809mm     PRINT_STR A4,D5
00000A20                          1810mm LOOP_120
00000A20  0C14 0000               1811mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A24  6700 0016               1812mm     BEQ EXIT_120
00000A28                          1813mmm     PRINT_CHAR (A4)+,D5
00000A28                          1814mmm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A28                 TRUE     1815mmm     IFEQ DEBUG
00000A28  1A39 00C00003           1816mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2E  0805 0002               1817mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A32  67F4                    1818mmm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A34  13DC 00C00007           1819mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A3A                          1820mmm     ENDC
00000A3A                          1821mmm 
00000A3A                 FALSE    1822mmm     IFNE DEBUG
00000A3A                          1823mmm     ENDC
00000A3A                          1824mmm 
00000A3A                          1825mmm     ENDM
00000A3A  60E4                    1826mm     BRA LOOP_120
00000A3C                          1827mm EXIT_120
00000A3C                          1828mm     ENDM
00000A3C                          1829m     ENDM
00000A3C  6000 F73C               1830          BRA MAIN_LOOP
00000A40                          1831      ENDI
00000A40                          1832s _0000000A
00000A40                          1833  
00000A40                          1834      IF D1 <EQ> #0 THEN
00000A40  B27C 0000               1835s     CMP.W   #0,D1
00000A44  6600 0006               1836s     BNE _0000000B
00000A48  6000 F9B8               1837        BRA WAIT_FOR_SRECORD
00000A4C                          1838      ENDI
00000A4C                          1839s _0000000B
00000A4C                          1840  DOWNLOAD_DONE
00000A4C                          1841m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A4C  43FA 0830               1842m     LEA OX(PC),A1
00000A50                          1843mm     PRINT_STR A1,D5
00000A50                          1844mm LOOP_123
00000A50  0C11 0000               1845mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A54  6700 0016               1846mm     BEQ EXIT_123
00000A58                          1847mmm     PRINT_CHAR (A1)+,D5
00000A58                          1848mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A58                 TRUE     1849mmm     IFEQ DEBUG
00000A58  1A39 00C00003           1850mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A5E  0805 0002               1851mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A62  67F4                    1852mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A64  13D9 00C00007           1853mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A6A                          1854mmm     ENDC
00000A6A                          1855mmm 
00000A6A                 FALSE    1856mmm     IFNE DEBUG
00000A6A                          1857mmm     ENDC
00000A6A                          1858mmm 
00000A6A                          1859mmm     ENDM
00000A6A  60E4                    1860mm     BRA LOOP_123
00000A6C                          1861mm EXIT_123
00000A6C                          1862mm     ENDM
00000A6C  7407                    1863m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A6E                          1864m LOOP_122
00000A6E                          1865mm     BIN2HEX D0,D6,A1
00000A6E  43FA 07CD               1866mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A72  E998                    1867mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A74  1C00                    1868mm     MOVE.B D0,D6
00000A76  0286 0000000F           1869mm     ANDI.L #$F,D6
00000A7C  1C31 6000               1870mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A80                          1871mm     ENDM
00000A80                          1872mm     PRINT_CHAR D6,D5
00000A80                          1873mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1874mm     IFEQ DEBUG
00000A80  1A39 00C00003           1875mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A86  0805 0002               1876mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1877mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A8C  13C6 00C00007           1878mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A92                          1879mm     ENDC
00000A92                          1880mm 
00000A92                 FALSE    1881mm     IFNE DEBUG
00000A92                          1882mm     ENDC
00000A92                          1883mm 
00000A92                          1884mm     ENDM
00000A92  57CA FFDA               1885m     DBEQ D2,LOOP_122
00000A96                          1886m     ENDM
00000A96  43FA 0748               1887      LEA READ(PC),A1
00000A9A                          1888m     PRINT_STR A1,D5
00000A9A                          1889m LOOP_127
00000A9A  0C11 0000               1890m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A9E  6700 0016               1891m     BEQ EXIT_127
00000AA2                          1892mm     PRINT_CHAR (A1)+,D5
00000AA2                          1893mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA2                 TRUE     1894mm     IFEQ DEBUG
00000AA2  1A39 00C00003           1895mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA8  0805 0002               1896mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAC  67F4                    1897mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000AAE  13D9 00C00007           1898mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB4                          1899mm     ENDC
00000AB4                          1900mm 
00000AB4                 FALSE    1901mm     IFNE DEBUG
00000AB4                          1902mm     ENDC
00000AB4                          1903mm 
00000AB4                          1904mm     ENDM
00000AB4  60E4                    1905m     BRA LOOP_127
00000AB6                          1906m EXIT_127
00000AB6                          1907m     ENDM
00000AB6  2E08                    1908      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AB8                          1909m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000AB8  43FA 07C4               1910m     LEA OX(PC),A1
00000ABC                          1911mm     PRINT_STR A1,D5
00000ABC                          1912mm LOOP_130
00000ABC  0C11 0000               1913mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AC0  6700 0016               1914mm     BEQ EXIT_130
00000AC4                          1915mmm     PRINT_CHAR (A1)+,D5
00000AC4                          1916mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC4                 TRUE     1917mmm     IFEQ DEBUG
00000AC4  1A39 00C00003           1918mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ACA  0805 0002               1919mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACE  67F4                    1920mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AD0  13D9 00C00007           1921mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD6                          1922mmm     ENDC
00000AD6                          1923mmm 
00000AD6                 FALSE    1924mmm     IFNE DEBUG
00000AD6                          1925mmm     ENDC
00000AD6                          1926mmm 
00000AD6                          1927mmm     ENDM
00000AD6  60E4                    1928mm     BRA LOOP_130
00000AD8                          1929mm EXIT_130
00000AD8                          1930mm     ENDM
00000AD8  7407                    1931m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000ADA                          1932m LOOP_129
00000ADA                          1933mm     BIN2HEX D7,D6,A1
00000ADA  43FA 0761               1934mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000ADE  E99F                    1935mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AE0  1C07                    1936mm     MOVE.B D7,D6
00000AE2  0286 0000000F           1937mm     ANDI.L #$F,D6
00000AE8  1C31 6000               1938mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AEC                          1939mm     ENDM
00000AEC                          1940mm     PRINT_CHAR D6,D5
00000AEC                          1941mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEC                 TRUE     1942mm     IFEQ DEBUG
00000AEC  1A39 00C00003           1943mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF2  0805 0002               1944mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AF6  67F4                    1945mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000AF8  13C6 00C00007           1946mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AFE                          1947mm     ENDC
00000AFE                          1948mm 
00000AFE                 FALSE    1949mm     IFNE DEBUG
00000AFE                          1950mm     ENDC
00000AFE                          1951mm 
00000AFE                          1952mm     ENDM
00000AFE  57CA FFDA               1953m     DBEQ D2,LOOP_129
00000B02                          1954m     ENDM
00000B02                          1955m     PRINT_CRLF D5,A4
00000B02  49FA 0774               1956m     LEA CRLF(PC),A4
00000B06                          1957mm     PRINT_STR A4,D5
00000B06                          1958mm LOOP_135
00000B06  0C14 0000               1959mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B0A  6700 0016               1960mm     BEQ EXIT_135
00000B0E                          1961mmm     PRINT_CHAR (A4)+,D5
00000B0E                          1962mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0E                 TRUE     1963mmm     IFEQ DEBUG
00000B0E  1A39 00C00003           1964mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B14  0805 0002               1965mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B18  67F4                    1966mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B1A  13DC 00C00007           1967mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B20                          1968mmm     ENDC
00000B20                          1969mmm 
00000B20                 FALSE    1970mmm     IFNE DEBUG
00000B20                          1971mmm     ENDC
00000B20                          1972mmm 
00000B20                          1973mmm     ENDM
00000B20  60E4                    1974mm     BRA LOOP_135
00000B22                          1975mm EXIT_135
00000B22                          1976mm     ENDM
00000B22                          1977m     ENDM
00000B22                          1978  
00000B22  6000 F656               1979      BRA MAIN_LOOP
00000B26                          1980  
00000B26                          1981  G
00000B26  2047                    1982      MOVE.L D7,A0                                    ; address accumulator -> address register
00000B28  3E3C 0000               1983      MOVE #0,D7                                      ; clear the now used address accumulator
00000B2C  4ED0                    1984      JMP (A0)                                        ; jump to it!
00000B2E                          1985  
00000B2E                          1986  Z
00000B2E  207C 00200000           1987      MOVE.L #RAM,A0                                  ; address of RAM
00000B34                          1988      
00000B34                          1989      FOR.L D0 = #0 TO #$FFFFB BY #4 DO               ; write
00000B34  7000                    1990s     MOVE.L  #0,D0
00000B36  6000 0012               1991s     BRA _20000005
00000B3A                          1992s _20000004
00000B3A  2200                    1993          MOVE.L D0,D1                                ; progress update
00000B3C  E089                    1994          LSR.L #8,D1 
00000B3E  E089                    1995          LSR.L #8,D1
00000B40  13C1 00E00001           1996          MOVE.B D1,DISPLAY
00000B46                          1997          
00000B46  20C8                    1998          MOVE.L A0,(A0)+
00000B48                          1999      ENDF
00000B48  5880                    2000s     ADD.L   #4,D0
00000B4A                          2001s _20000005
00000B4A  B0BC 000FFFFB           2002s     CMP.L   #$FFFFB,D0
00000B50  6FE8                    2003s     BLE _20000004
00000B52                          2004  
00000B52  207C 00200000           2005      MOVE.L #RAM,A0                                  ; address of RAM
00000B58                          2006  
00000B58                          2007      FOR.L D0 = #0 TO #$FFFFB BY #4 DO               ; read back and check 
00000B58  7000                    2008s     MOVE.L  #0,D0
00000B5A  6000 00A8               2009s     BRA _20000007
00000B5E                          2010s _20000006
00000B5E  2200                    2011          MOVE.L D0,D1                                ; progress update
00000B60  E089                    2012          LSR.L #8,D1
00000B62  E089                    2013          LSR.L #8,D1
00000B64  13C1 00E00001           2014          MOVE.B D1,DISPLAY
00000B6A                          2015  
00000B6A  2408                    2016          MOVE.L A0,D2
00000B6C  2218                    2017          MOVE.L (A0)+,D1
00000B6E                          2018  
00000B6E                          2019          IF.L D2 <NE> D1 THEN
00000B6E  B481                    2020s     CMP.L   D1,D2
00000B70  6700 0090               2021s     BEQ _0000000C
00000B74  43FA 06B5               2022              LEA RAM_ERROR(PC),A1
00000B78                          2023m             PRINT_STR A1,D1
00000B78                          2024m LOOP_137
00000B78  0C11 0000               2025m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B7C  6700 0016               2026m     BEQ EXIT_137
00000B80                          2027mm     PRINT_CHAR (A1)+,D1
00000B80                          2028mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B80                 TRUE     2029mm     IFEQ DEBUG
00000B80  1239 00C00003           2030mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B86  0801 0002               2031mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B8A  67F4                    2032mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B8C  13D9 00C00007           2033mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B92                          2034mm     ENDC
00000B92                          2035mm 
00000B92                 FALSE    2036mm     IFNE DEBUG
00000B92                          2037mm     ENDC
00000B92                          2038mm 
00000B92                          2039mm     ENDM
00000B92  60E4                    2040m     BRA LOOP_137
00000B94                          2041m EXIT_137
00000B94                          2042m     ENDM
00000B94  2208                    2043              MOVE.L A0,D1
00000B96  5981                    2044              SUB.L #4,D1
00000B98                          2045m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B98  43FA 06E4               2046m     LEA OX(PC),A1
00000B9C                          2047mm     PRINT_STR A1,D3
00000B9C                          2048mm LOOP_140
00000B9C  0C11 0000               2049mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BA0  6700 0016               2050mm     BEQ EXIT_140
00000BA4                          2051mmm     PRINT_CHAR (A1)+,D3
00000BA4                          2052mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     2053mmm     IFEQ DEBUG
00000BA4  1639 00C00003           2054mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BAA  0803 0002               2055mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    2056mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000BB0  13D9 00C00007           2057mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB6                          2058mmm     ENDC
00000BB6                          2059mmm 
00000BB6                 FALSE    2060mmm     IFNE DEBUG
00000BB6                          2061mmm     ENDC
00000BB6                          2062mmm 
00000BB6                          2063mmm     ENDM
00000BB6  60E4                    2064mm     BRA LOOP_140
00000BB8                          2065mm EXIT_140
00000BB8                          2066mm     ENDM
00000BB8  7C07                    2067m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBA                          2068m LOOP_139
00000BBA                          2069mm     BIN2HEX D1,D2,A1
00000BBA  43FA 0681               2070mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BBE  E999                    2071mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC0  1401                    2072mm     MOVE.B D1,D2
00000BC2  0282 0000000F           2073mm     ANDI.L #$F,D2
00000BC8  1431 2000               2074mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000BCC                          2075mm     ENDM
00000BCC                          2076mm     PRINT_CHAR D2,D3
00000BCC                          2077mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCC                 TRUE     2078mm     IFEQ DEBUG
00000BCC  1639 00C00003           2079mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BD2  0803 0002               2080mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BD6  67F4                    2081mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000BD8  13C2 00C00007           2082mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BDE                          2083mm     ENDC
00000BDE                          2084mm 
00000BDE                 FALSE    2085mm     IFNE DEBUG
00000BDE                          2086mm     ENDC
00000BDE                          2087mm 
00000BDE                          2088mm     ENDM
00000BDE  57CE FFDA               2089m     DBEQ D6,LOOP_139
00000BE2                          2090m     ENDM
00000BE2                          2091m             PRINT_CRLF D3,A1
00000BE2  43FA 0694               2092m     LEA CRLF(PC),A1
00000BE6                          2093mm     PRINT_STR A1,D3
00000BE6                          2094mm LOOP_145
00000BE6  0C11 0000               2095mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BEA  6700 0016               2096mm     BEQ EXIT_145
00000BEE                          2097mmm     PRINT_CHAR (A1)+,D3
00000BEE                          2098mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEE                 TRUE     2099mmm     IFEQ DEBUG
00000BEE  1639 00C00003           2100mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BF4  0803 0002               2101mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BF8  67F4                    2102mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000BFA  13D9 00C00007           2103mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C00                          2104mmm     ENDC
00000C00                          2105mmm 
00000C00                 FALSE    2106mmm     IFNE DEBUG
00000C00                          2107mmm     ENDC
00000C00                          2108mmm 
00000C00                          2109mmm     ENDM
00000C00  60E4                    2110mm     BRA LOOP_145
00000C02                          2111mm EXIT_145
00000C02                          2112mm     ENDM
00000C02                          2113m     ENDM
00000C02                          2114          ENDI 
00000C02                          2115s _0000000C
00000C02                          2116      ENDF
00000C02  5880                    2117s     ADD.L   #4,D0
00000C04                          2118s _20000007
00000C04  B0BC 000FFFFB           2119s     CMP.L   #$FFFFB,D0
00000C0A  6F00 FF52               2120s     BLE _20000006
00000C0E                          2121  
00000C0E  6000 F56A               2122      BRA MAIN_LOOP
00000C12                          2123  
00000C12                          2124  L
00000C12  7000                    2125      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C14  7200                    2126      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C16                          2127  
00000C16                          2128      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C16  343C 0000               2129s     MOVE.W  #0,D2
00000C1A  6000 0046               2130s     BRA _20000009
00000C1E                          2131s _20000008
00000C1E  E989                    2132          LSL.L #4,D1                                 ; make what we have so far more significant
00000C20                          2133m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C20                          2134m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C20                 TRUE     2135m     IFEQ DEBUG
00000C20  1839 00C00003           2136m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C26  0804 0000               2137m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000C2A  67F4                    2138m         BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00000C2C                          2139m     ENDC
00000C2C                          2140m 
00000C2C                          2141mm     READ_CHAR D3
00000C2C                 TRUE     2142mm     IFEQ DEBUG
00000C2C  1639 00C00007           2143mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000C32                          2144mm     ENDC
00000C32                 FALSE    2145mm     IFNE DEBUG
00000C32                          2146mm     ENDC
00000C32                          2147mm 
00000C32  B63C 001B               2148mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000C36  6700 F3D0               2149mm     BEQ START
00000C3A                          2150mm     ENDM
00000C3A                          2151m 
00000C3A                 TRUE     2152m     IFEQ DEBUG
00000C3A                          2153mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000C3A                          2154mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C3A                 TRUE     2155mm     IFEQ DEBUG
00000C3A  1839 00C00003           2156mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C40  0804 0002               2157mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000C44  67F4                    2158mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C46  13C3 00C00007           2159mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C4C                          2160mm     ENDC
00000C4C                          2161mm 
00000C4C                 FALSE    2162mm     IFNE DEBUG
00000C4C                          2163mm     ENDC
00000C4C                          2164mm 
00000C4C                          2165mm     ENDM
00000C4C                          2166m     ENDC
00000C4C                          2167m     ENDM
00000C4C                          2168m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C4C  41FA 05FF               2169m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C50  0403 0030               2170m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C54  C6BC 000000FF           2171m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000C5A  1630 3000               2172m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C5E                          2173m     ENDM
00000C5E  8203                    2174          OR.B D3,D1
00000C60                          2175      ENDF
00000C60  5242                    2176s     ADD.W   #1,D2
00000C62                          2177s _20000009
00000C62  B47C 0007               2178s     CMP.W   #7,D2
00000C66  6FB6                    2179s     BLE _20000008
00000C68                          2180  
00000C68  3001                    2181      MOVE.W D1,D0                                    ; extract the LSword for the length
00000C6A  E089                    2182      LSR.L #8,D1                                     ; extract the MSword for the address
00000C6C  E089                    2183      LSR.L #8,D1
00000C6E                          2184  
00000C6E                          2185m     PRINT_CRLF D2,A1
00000C6E  43FA 0608               2186m     LEA CRLF(PC),A1
00000C72                          2187mm     PRINT_STR A1,D2
00000C72                          2188mm LOOP_152
00000C72  0C11 0000               2189mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C76  6700 0016               2190mm     BEQ EXIT_152
00000C7A                          2191mmm     PRINT_CHAR (A1)+,D2
00000C7A                          2192mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C7A                 TRUE     2193mmm     IFEQ DEBUG
00000C7A  1439 00C00003           2194mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C80  0802 0002               2195mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C84  67F4                    2196mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C86  13D9 00C00007           2197mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C8C                          2198mmm     ENDC
00000C8C                          2199mmm 
00000C8C                 FALSE    2200mmm     IFNE DEBUG
00000C8C                          2201mmm     ENDC
00000C8C                          2202mmm 
00000C8C                          2203mmm     ENDM
00000C8C  60E4                    2204mm     BRA LOOP_152
00000C8E                          2205mm EXIT_152
00000C8E                          2206mm     ENDM
00000C8E                          2207m     ENDM
00000C8E                          2208  
00000C8E  2041                    2209      MOVE.L D1,A0                                    ; target address
00000C90                          2210  
00000C90  2247                    2211      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C92  7E00                    2212      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C94                          2213  
00000C94  5089                    2214      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000C96  5180                    2215      SUB.L #8,D0
00000C98                          2216  
00000C98                          2217m     UNPROTECT
00000C98  31FC AAAA 2AAA          2218m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000C9E  4E71                    2219m     NOP
00000CA0  31FC 5555 1554          2220m     MOVE.W #$5555,$1554
00000CA6  4E71                    2221m     NOP
00000CA8  31FC 8080 2AAA          2222m     MOVE.W #$8080,$2AAA
00000CAE  4E71                    2223m     NOP
00000CB0  31FC AAAA 2AAA          2224m     MOVE.W #$AAAA,$2AAA
00000CB6  4E71                    2225m     NOP
00000CB8  31FC 5555 1554          2226m     MOVE.W #$5555,$1554
00000CBE  4E71                    2227m     NOP
00000CC0  31FC 2020 2AAA          2228m     MOVE.W #$2020,$2AAA
00000CC6                          2229m     ENDM
00000CC6                          2230  
00000CC6  45FA 059C               2231      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000CCA                          2232m     PRINT_STR A2,D2
00000CCA                          2233m LOOP_155
00000CCA  0C12 0000               2234m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CCE  6700 0016               2235m     BEQ EXIT_155
00000CD2                          2236mm     PRINT_CHAR (A2)+,D2
00000CD2                          2237mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD2                 TRUE     2238mm     IFEQ DEBUG
00000CD2  1439 00C00003           2239mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CD8  0802 0002               2240mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CDC  67F4                    2241mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CDE  13DA 00C00007           2242mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE4                          2243mm     ENDC
00000CE4                          2244mm 
00000CE4                 FALSE    2245mm     IFNE DEBUG
00000CE4                          2246mm     ENDC
00000CE4                          2247mm 
00000CE4                          2248mm     ENDM
00000CE4  60E4                    2249m     BRA LOOP_155
00000CE6                          2250m EXIT_155
00000CE6                          2251m     ENDM
00000CE6                          2252  
00000CE6  2409                    2253      MOVE.L A1,D2
00000CE8                          2254m     PRINT_REG D2,D3,D4,D5,A2
00000CE8  45FA 0594               2255m     LEA OX(PC),A2
00000CEC                          2256mm     PRINT_STR A2,D3
00000CEC                          2257mm LOOP_158
00000CEC  0C12 0000               2258mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CF0  6700 0016               2259mm     BEQ EXIT_158
00000CF4                          2260mmm     PRINT_CHAR (A2)+,D3
00000CF4                          2261mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF4                 TRUE     2262mmm     IFEQ DEBUG
00000CF4  1639 00C00003           2263mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CFA  0803 0002               2264mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CFE  67F4                    2265mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000D00  13DA 00C00007           2266mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D06                          2267mmm     ENDC
00000D06                          2268mmm 
00000D06                 FALSE    2269mmm     IFNE DEBUG
00000D06                          2270mmm     ENDC
00000D06                          2271mmm 
00000D06                          2272mmm     ENDM
00000D06  60E4                    2273mm     BRA LOOP_158
00000D08                          2274mm EXIT_158
00000D08                          2275mm     ENDM
00000D08  7A07                    2276m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D0A                          2277m LOOP_157
00000D0A                          2278mm     BIN2HEX D2,D4,A2
00000D0A  45FA 0531               2279mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D0E  E99A                    2280mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D10  1802                    2281mm     MOVE.B D2,D4
00000D12  0284 0000000F           2282mm     ANDI.L #$F,D4
00000D18  1832 4000               2283mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D1C                          2284mm     ENDM
00000D1C                          2285mm     PRINT_CHAR D4,D3
00000D1C                          2286mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D1C                 TRUE     2287mm     IFEQ DEBUG
00000D1C  1639 00C00003           2288mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D22  0803 0002               2289mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D26  67F4                    2290mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D28  13C4 00C00007           2291mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D2E                          2292mm     ENDC
00000D2E                          2293mm 
00000D2E                 FALSE    2294mm     IFNE DEBUG
00000D2E                          2295mm     ENDC
00000D2E                          2296mm 
00000D2E                          2297mm     ENDM
00000D2E  57CD FFDA               2298m     DBEQ D5,LOOP_157
00000D32                          2299m     ENDM
00000D32                          2300  
00000D32  45FA 054D               2301      LEA TO(PC),A2
00000D36                          2302m     PRINT_STR A2,D3
00000D36                          2303m LOOP_162
00000D36  0C12 0000               2304m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D3A  6700 0016               2305m     BEQ EXIT_162
00000D3E                          2306mm     PRINT_CHAR (A2)+,D3
00000D3E                          2307mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                 TRUE     2308mm     IFEQ DEBUG
00000D3E  1639 00C00003           2309mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D44  0803 0002               2310mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D48  67F4                    2311mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D4A  13DA 00C00007           2312mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D50                          2313mm     ENDC
00000D50                          2314mm 
00000D50                 FALSE    2315mm     IFNE DEBUG
00000D50                          2316mm     ENDC
00000D50                          2317mm 
00000D50                          2318mm     ENDM
00000D50  60E4                    2319m     BRA LOOP_162
00000D52                          2320m EXIT_162
00000D52                          2321m     ENDM
00000D52                          2322  
00000D52  2408                    2323      MOVE.L A0,D2
00000D54                          2324m     PRINT_REG D2,D3,D4,D5,A2
00000D54  45FA 0528               2325m     LEA OX(PC),A2
00000D58                          2326mm     PRINT_STR A2,D3
00000D58                          2327mm LOOP_165
00000D58  0C12 0000               2328mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D5C  6700 0016               2329mm     BEQ EXIT_165
00000D60                          2330mmm     PRINT_CHAR (A2)+,D3
00000D60                          2331mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D60                 TRUE     2332mmm     IFEQ DEBUG
00000D60  1639 00C00003           2333mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D66  0803 0002               2334mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D6A  67F4                    2335mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D6C  13DA 00C00007           2336mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D72                          2337mmm     ENDC
00000D72                          2338mmm 
00000D72                 FALSE    2339mmm     IFNE DEBUG
00000D72                          2340mmm     ENDC
00000D72                          2341mmm 
00000D72                          2342mmm     ENDM
00000D72  60E4                    2343mm     BRA LOOP_165
00000D74                          2344mm EXIT_165
00000D74                          2345mm     ENDM
00000D74  7A07                    2346m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D76                          2347m LOOP_164
00000D76                          2348mm     BIN2HEX D2,D4,A2
00000D76  45FA 04C5               2349mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D7A  E99A                    2350mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D7C  1802                    2351mm     MOVE.B D2,D4
00000D7E  0284 0000000F           2352mm     ANDI.L #$F,D4
00000D84  1832 4000               2353mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D88                          2354mm     ENDM
00000D88                          2355mm     PRINT_CHAR D4,D3
00000D88                          2356mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D88                 TRUE     2357mm     IFEQ DEBUG
00000D88  1639 00C00003           2358mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D8E  0803 0002               2359mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D92  67F4                    2360mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000D94  13C4 00C00007           2361mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D9A                          2362mm     ENDC
00000D9A                          2363mm 
00000D9A                 FALSE    2364mm     IFNE DEBUG
00000D9A                          2365mm     ENDC
00000D9A                          2366mm 
00000D9A                          2367mm     ENDM
00000D9A  57CD FFDA               2368m     DBEQ D5,LOOP_164
00000D9E                          2369m     ENDM
00000D9E                          2370  
00000D9E                          2371m     PRINT_CRLF D3,A2
00000D9E  45FA 04D8               2372m     LEA CRLF(PC),A2
00000DA2                          2373mm     PRINT_STR A2,D3
00000DA2                          2374mm LOOP_170
00000DA2  0C12 0000               2375mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DA6  6700 0016               2376mm     BEQ EXIT_170
00000DAA                          2377mmm     PRINT_CHAR (A2)+,D3
00000DAA                          2378mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DAA                 TRUE     2379mmm     IFEQ DEBUG
00000DAA  1639 00C00003           2380mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DB0  0803 0002               2381mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DB4  67F4                    2382mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DB6  13DA 00C00007           2383mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DBC                          2384mmm     ENDC
00000DBC                          2385mmm 
00000DBC                 FALSE    2386mmm     IFNE DEBUG
00000DBC                          2387mmm     ENDC
00000DBC                          2388mmm 
00000DBC                          2389mmm     ENDM
00000DBC  60E4                    2390mm     BRA LOOP_170
00000DBE                          2391mm EXIT_170
00000DBE                          2392mm     ENDM
00000DBE                          2393m     ENDM
00000DBE                          2394  
00000DBE                          2395      WHILE D0 <GT> #0 DO
00000DBE                          2396s _10000014
00000DBE  B07C 0000               2397s     CMP.W   #0,D0
00000DC2  6F00 001C               2398s     BLE _10000015
00000DC6  5580                    2399          SUB.L #2,D0
00000DC8                          2400  
00000DC8  13D1 00E00001           2401          MOVE.B (A1),DISPLAY
00000DCE                          2402m         PROGRAM (A1),(A0),D2
00000DCE  3091                    2403m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000DD0                          2404m 
00000DD0                          2405m WAIT_FOR_COMPLETE_172
00000DD0  3410                    2406m         MOVE.W (A0),D2
00000DD2                          2407m 
00000DD2                          2408m         IF.W D2 <NE> (A1) THEN
00000DD2  B451                    2409ms     CMP.W   (A1),D2
00000DD4  6700 0004               2410ms     BEQ _0000000D
00000DD8  60F6                    2411m             BRA WAIT_FOR_COMPLETE_172
00000DDA                          2412m         ENDI
00000DDA                          2413ms _0000000D
00000DDA                          2414m         ENDM
00000DDA                          2415  
00000DDA  5488                    2416          ADD.L #2,A0
00000DDC  5489                    2417          ADD.L #2,A1
00000DDE                          2418      ENDW
00000DDE  60DE                    2419s     BRA _10000014
00000DE0                          2420s _10000015
00000DE0                          2421  
00000DE0                          2422m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000DE0  31FC 0000 0000          2423m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000DE6                          2424m 
00000DE6                          2425m WAIT_FOR_COMPLETE_173
00000DE6  3438 0000               2426m         MOVE.W $0,D2
00000DEA                          2427m 
00000DEA                          2428m         IF.W D2 <NE> #0 THEN
00000DEA  B47C 0000               2429ms     CMP.W   #0,D2
00000DEE  6700 0004               2430ms     BEQ _0000000E
00000DF2  60F2                    2431m             BRA WAIT_FOR_COMPLETE_173
00000DF4                          2432m         ENDI
00000DF4                          2433ms _0000000E
00000DF4                          2434m         ENDM
00000DF4                          2435m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000DF4  31FC 0000 0002          2436m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000DFA                          2437m 
00000DFA                          2438m WAIT_FOR_COMPLETE_174
00000DFA  3438 0002               2439m         MOVE.W $2,D2
00000DFE                          2440m 
00000DFE                          2441m         IF.W D2 <NE> #0 THEN
00000DFE  B47C 0000               2442ms     CMP.W   #0,D2
00000E02  6700 0004               2443ms     BEQ _0000000F
00000E06  60F2                    2444m             BRA WAIT_FOR_COMPLETE_174
00000E08                          2445m         ENDI
00000E08                          2446ms _0000000F
00000E08                          2447m         ENDM
00000E08                          2448  
00000E08                          2449m     PROGRAM D1, $6, D2
00000E08  31C1 0006               2450m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000E0C                          2451m 
00000E0C                          2452m WAIT_FOR_COMPLETE_175
00000E0C  3438 0006               2453m         MOVE.W $6,D2
00000E10                          2454m 
00000E10                          2455m         IF.W D2 <NE> D1 THEN
00000E10  B441                    2456ms     CMP.W   D1,D2
00000E12  6700 0004               2457ms     BEQ _00000010
00000E16  60F4                    2458m             BRA WAIT_FOR_COMPLETE_175
00000E18                          2459m         ENDI
00000E18                          2460ms _00000010
00000E18                          2461m         ENDM
00000E18  E089                    2462      LSR.L #8,D1
00000E1A  E089                    2463      LSR.L #8,D1
00000E1C                          2464m     PROGRAM D1, $4, D2
00000E1C  31C1 0004               2465m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000E20                          2466m 
00000E20                          2467m WAIT_FOR_COMPLETE_176
00000E20  3438 0004               2468m         MOVE.W $4,D2
00000E24                          2469m 
00000E24                          2470m         IF.W D2 <NE> D1 THEN
00000E24  B441                    2471ms     CMP.W   D1,D2
00000E26  6700 0004               2472ms     BEQ _00000011
00000E2A  60F4                    2473m             BRA WAIT_FOR_COMPLETE_176
00000E2C                          2474m         ENDI
00000E2C                          2475ms _00000011
00000E2C                          2476m         ENDM
00000E2C                          2477  
00000E2C                          2478m     PROTECT
00000E2C  31FC AAAA 2AAA          2479m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000E32  31FC 5555 1554          2480m     MOVE.W #$5555,$1554
00000E38  31FC A0A0 2AAA          2481m     MOVE.W #$A0A0,$2AAA
00000E3E                          2482m     ENDM
00000E3E                          2483  
00000E3E  6000 F33A               2484      BRA MAIN_LOOP
00000E42                          2485  
00000E42                          2486  P
00000E42  7000                    2487      MOVE.L #0,D0                                    ; D0 will be the data to write
00000E44                          2488  
00000E44                          2489      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000E44  323C 0000               2490s     MOVE.W  #0,D1
00000E48  6000 0046               2491s     BRA _2000000B
00000E4C                          2492s _2000000A
00000E4C  E988                    2493          LSL.L #4,D0                                 ; make what we have so far more significant
00000E4E                          2494m         WAIT_CHAR D2,D3                             ; next character -> D2
00000E4E                          2495m WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4E                 TRUE     2496m     IFEQ DEBUG
00000E4E  1639 00C00003           2497m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E54  0803 0000               2498m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E58  67F4                    2499m         BEQ WAIT_FOR_READY_178                      ; NOTHING, CHECK AGAIN
00000E5A                          2500m     ENDC
00000E5A                          2501m 
00000E5A                          2502mm     READ_CHAR D2
00000E5A                 TRUE     2503mm     IFEQ DEBUG
00000E5A  1439 00C00007           2504mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000E60                          2505mm     ENDC
00000E60                 FALSE    2506mm     IFNE DEBUG
00000E60                          2507mm     ENDC
00000E60                          2508mm 
00000E60  B43C 001B               2509mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000E64  6700 F1A2               2510mm     BEQ START
00000E68                          2511mm     ENDM
00000E68                          2512m 
00000E68                 TRUE     2513m     IFEQ DEBUG
00000E68                          2514mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000E68                          2515mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E68                 TRUE     2516mm     IFEQ DEBUG
00000E68  1639 00C00003           2517mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E6E  0803 0002               2518mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E72  67F4                    2519mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E74  13C2 00C00007           2520mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E7A                          2521mm     ENDC
00000E7A                          2522mm 
00000E7A                 FALSE    2523mm     IFNE DEBUG
00000E7A                          2524mm     ENDC
00000E7A                          2525mm 
00000E7A                          2526mm     ENDM
00000E7A                          2527m     ENDC
00000E7A                          2528m     ENDM
00000E7A                          2529m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E7A  41FA 03D1               2530m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E7E  0402 0030               2531m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E82  C4BC 000000FF           2532m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E88  1430 2000               2533m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E8C                          2534m     ENDM
00000E8C  8002                    2535          OR.B D2,D0
00000E8E                          2536      ENDF
00000E8E  5241                    2537s     ADD.W   #1,D1
00000E90                          2538s _2000000B
00000E90  B27C 0003               2539s     CMP.W   #3,D1
00000E94  6FB6                    2540s     BLE _2000000A
00000E96                          2541  
00000E96                          2542m     PRINT_CRLF D2,A1
00000E96  43FA 03E0               2543m     LEA CRLF(PC),A1
00000E9A                          2544mm     PRINT_STR A1,D2
00000E9A                          2545mm LOOP_183
00000E9A  0C11 0000               2546mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E9E  6700 0016               2547mm     BEQ EXIT_183
00000EA2                          2548mmm     PRINT_CHAR (A1)+,D2
00000EA2                          2549mmm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA2                 TRUE     2550mmm     IFEQ DEBUG
00000EA2  1439 00C00003           2551mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EA8  0802 0002               2552mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EAC  67F4                    2553mmm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00000EAE  13D9 00C00007           2554mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB4                          2555mmm     ENDC
00000EB4                          2556mmm 
00000EB4                 FALSE    2557mmm     IFNE DEBUG
00000EB4                          2558mmm     ENDC
00000EB4                          2559mmm 
00000EB4                          2560mmm     ENDM
00000EB4  60E4                    2561mm     BRA LOOP_183
00000EB6                          2562mm EXIT_183
00000EB6                          2563mm     ENDM
00000EB6                          2564m     ENDM
00000EB6                          2565  
00000EB6  2047                    2566      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000EB8  7E00                    2567      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EBA                          2568  
00000EBA                          2569m     UNPROTECT
00000EBA  31FC AAAA 2AAA          2570m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EC0  4E71                    2571m     NOP
00000EC2  31FC 5555 1554          2572m     MOVE.W #$5555,$1554
00000EC8  4E71                    2573m     NOP
00000ECA  31FC 8080 2AAA          2574m     MOVE.W #$8080,$2AAA
00000ED0  4E71                    2575m     NOP
00000ED2  31FC AAAA 2AAA          2576m     MOVE.W #$AAAA,$2AAA
00000ED8  4E71                    2577m     NOP
00000EDA  31FC 5555 1554          2578m     MOVE.W #$5555,$1554
00000EE0  4E71                    2579m     NOP
00000EE2  31FC 2020 2AAA          2580m     MOVE.W #$2020,$2AAA
00000EE8                          2581m     ENDM
00000EE8                          2582               
00000EE8  45FA 037A               2583      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000EEC                          2584m     PRINT_STR A2,D2
00000EEC                          2585m LOOP_186
00000EEC  0C12 0000               2586m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EF0  6700 0016               2587m     BEQ EXIT_186
00000EF4                          2588mm     PRINT_CHAR (A2)+,D2
00000EF4                          2589mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF4                 TRUE     2590mm     IFEQ DEBUG
00000EF4  1439 00C00003           2591mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EFA  0802 0002               2592mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EFE  67F4                    2593mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000F00  13DA 00C00007           2594mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F06                          2595mm     ENDC
00000F06                          2596mm 
00000F06                 FALSE    2597mm     IFNE DEBUG
00000F06                          2598mm     ENDC
00000F06                          2599mm 
00000F06                          2600mm     ENDM
00000F06  60E4                    2601m     BRA LOOP_186
00000F08                          2602m EXIT_186
00000F08                          2603m     ENDM
00000F08                          2604  
00000F08                          2605m     PRINT_CHAR '#',D3
00000F08                          2606m WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F08                 TRUE     2607m     IFEQ DEBUG
00000F08  1639 00C00003           2608m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F0E  0803 0002               2609m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F12  67F4                    2610m         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000F14  13F8 0023 00C00007      2611m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000F1C                          2612m     ENDC
00000F1C                          2613m 
00000F1C                 FALSE    2614m     IFNE DEBUG
00000F1C                          2615m     ENDC
00000F1C                          2616m 
00000F1C                          2617m     ENDM
00000F1C                          2618m     PRINT_REG D0,D3,D4,D5,A2
00000F1C  45FA 0360               2619m     LEA OX(PC),A2
00000F20                          2620mm     PRINT_STR A2,D3
00000F20                          2621mm LOOP_190
00000F20  0C12 0000               2622mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F24  6700 0016               2623mm     BEQ EXIT_190
00000F28                          2624mmm     PRINT_CHAR (A2)+,D3
00000F28                          2625mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F28                 TRUE     2626mmm     IFEQ DEBUG
00000F28  1639 00C00003           2627mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2E  0803 0002               2628mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F32  67F4                    2629mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
00000F34  13DA 00C00007           2630mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F3A                          2631mmm     ENDC
00000F3A                          2632mmm 
00000F3A                 FALSE    2633mmm     IFNE DEBUG
00000F3A                          2634mmm     ENDC
00000F3A                          2635mmm 
00000F3A                          2636mmm     ENDM
00000F3A  60E4                    2637mm     BRA LOOP_190
00000F3C                          2638mm EXIT_190
00000F3C                          2639mm     ENDM
00000F3C  7A07                    2640m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F3E                          2641m LOOP_189
00000F3E                          2642mm     BIN2HEX D0,D4,A2
00000F3E  45FA 02FD               2643mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F42  E998                    2644mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F44  1800                    2645mm     MOVE.B D0,D4
00000F46  0284 0000000F           2646mm     ANDI.L #$F,D4
00000F4C  1832 4000               2647mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F50                          2648mm     ENDM
00000F50                          2649mm     PRINT_CHAR D4,D3
00000F50                          2650mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F50                 TRUE     2651mm     IFEQ DEBUG
00000F50  1639 00C00003           2652mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F56  0803 0002               2653mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F5A  67F4                    2654mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F5C  13C4 00C00007           2655mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F62                          2656mm     ENDC
00000F62                          2657mm 
00000F62                 FALSE    2658mm     IFNE DEBUG
00000F62                          2659mm     ENDC
00000F62                          2660mm 
00000F62                          2661mm     ENDM
00000F62  57CD FFDA               2662m     DBEQ D5,LOOP_189
00000F66                          2663m     ENDM
00000F66                          2664  
00000F66  45FA 0319               2665      LEA TO(PC),A2
00000F6A                          2666m     PRINT_STR A2,D3
00000F6A                          2667m LOOP_194
00000F6A  0C12 0000               2668m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F6E  6700 0016               2669m     BEQ EXIT_194
00000F72                          2670mm     PRINT_CHAR (A2)+,D3
00000F72                          2671mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F72                 TRUE     2672mm     IFEQ DEBUG
00000F72  1639 00C00003           2673mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F78  0803 0002               2674mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F7C  67F4                    2675mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F7E  13DA 00C00007           2676mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F84                          2677mm     ENDC
00000F84                          2678mm 
00000F84                 FALSE    2679mm     IFNE DEBUG
00000F84                          2680mm     ENDC
00000F84                          2681mm 
00000F84                          2682mm     ENDM
00000F84  60E4                    2683m     BRA LOOP_194
00000F86                          2684m EXIT_194
00000F86                          2685m     ENDM
00000F86                          2686  
00000F86  2408                    2687      MOVE.L A0,D2
00000F88                          2688m     PRINT_REG D2,D3,D4,D5,A2
00000F88  45FA 02F4               2689m     LEA OX(PC),A2
00000F8C                          2690mm     PRINT_STR A2,D3
00000F8C                          2691mm LOOP_197
00000F8C  0C12 0000               2692mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F90  6700 0016               2693mm     BEQ EXIT_197
00000F94                          2694mmm     PRINT_CHAR (A2)+,D3
00000F94                          2695mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F94                 TRUE     2696mmm     IFEQ DEBUG
00000F94  1639 00C00003           2697mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F9A  0803 0002               2698mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F9E  67F4                    2699mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000FA0  13DA 00C00007           2700mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA6                          2701mmm     ENDC
00000FA6                          2702mmm 
00000FA6                 FALSE    2703mmm     IFNE DEBUG
00000FA6                          2704mmm     ENDC
00000FA6                          2705mmm 
00000FA6                          2706mmm     ENDM
00000FA6  60E4                    2707mm     BRA LOOP_197
00000FA8                          2708mm EXIT_197
00000FA8                          2709mm     ENDM
00000FA8  7A07                    2710m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FAA                          2711m LOOP_196
00000FAA                          2712mm     BIN2HEX D2,D4,A2
00000FAA  45FA 0291               2713mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FAE  E99A                    2714mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FB0  1802                    2715mm     MOVE.B D2,D4
00000FB2  0284 0000000F           2716mm     ANDI.L #$F,D4
00000FB8  1832 4000               2717mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FBC                          2718mm     ENDM
00000FBC                          2719mm     PRINT_CHAR D4,D3
00000FBC                          2720mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FBC                 TRUE     2721mm     IFEQ DEBUG
00000FBC  1639 00C00003           2722mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FC2  0803 0002               2723mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FC6  67F4                    2724mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00000FC8  13C4 00C00007           2725mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FCE                          2726mm     ENDC
00000FCE                          2727mm 
00000FCE                 FALSE    2728mm     IFNE DEBUG
00000FCE                          2729mm     ENDC
00000FCE                          2730mm 
00000FCE                          2731mm     ENDM
00000FCE  57CD FFDA               2732m     DBEQ D5,LOOP_196
00000FD2                          2733m     ENDM
00000FD2                          2734  
00000FD2                          2735m     PRINT_CRLF D3,A2
00000FD2  45FA 02A4               2736m     LEA CRLF(PC),A2
00000FD6                          2737mm     PRINT_STR A2,D3
00000FD6                          2738mm LOOP_202
00000FD6  0C12 0000               2739mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FDA  6700 0016               2740mm     BEQ EXIT_202
00000FDE                          2741mmm     PRINT_CHAR (A2)+,D3
00000FDE                          2742mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FDE                 TRUE     2743mmm     IFEQ DEBUG
00000FDE  1639 00C00003           2744mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FE4  0803 0002               2745mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FE8  67F4                    2746mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00000FEA  13DA 00C00007           2747mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FF0                          2748mmm     ENDC
00000FF0                          2749mmm 
00000FF0                 FALSE    2750mmm     IFNE DEBUG
00000FF0                          2751mmm     ENDC
00000FF0                          2752mmm 
00000FF0                          2753mmm     ENDM
00000FF0  60E4                    2754mm     BRA LOOP_202
00000FF2                          2755mm EXIT_202
00000FF2                          2756mm     ENDM
00000FF2                          2757m     ENDM
00000FF2                          2758  
00000FF2                          2759m     PROGRAM D0,(A0),D2
00000FF2  3080                    2760m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FF4                          2761m 
00000FF4                          2762m WAIT_FOR_COMPLETE_204
00000FF4  3410                    2763m         MOVE.W (A0),D2
00000FF6                          2764m 
00000FF6                          2765m         IF.W D2 <NE> D0 THEN
00000FF6  B440                    2766ms     CMP.W   D0,D2
00000FF8  6700 0004               2767ms     BEQ _00000012
00000FFC  60F6                    2768m             BRA WAIT_FOR_COMPLETE_204
00000FFE                          2769m         ENDI
00000FFE                          2770ms _00000012
00000FFE                          2771m         ENDM
00000FFE                          2772  
00000FFE                          2773m     PROTECT
00000FFE  31FC AAAA 2AAA          2774m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001004  31FC 5555 1554          2775m     MOVE.W #$5555,$1554
0000100A  31FC A0A0 2AAA          2776m     MOVE.W #$A0A0,$2AAA
00001010                          2777m     ENDM
00001010                          2778  
00001010  6000 F168               2779      BRA MAIN_LOOP
00001014                          2780      
00001014                          2781  M
00001014  7000                    2782      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001016  7200                    2783      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001018                          2784  
00001018                          2785      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001018  343C 0000               2786s     MOVE.W  #0,D2
0000101C  6000 0046               2787s     BRA _2000000D
00001020                          2788s _2000000C
00001020  E989                    2789          LSL.L #4,D1                                     ; make what we have so far more significant
00001022                          2790m         WAIT_CHAR D3,D4                                 ; next character -> D2
00001022                          2791m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001022                 TRUE     2792m     IFEQ DEBUG
00001022  1839 00C00003           2793m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001028  0804 0000               2794m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000102C  67F4                    2795m         BEQ WAIT_FOR_READY_206                      ; NOTHING, CHECK AGAIN
0000102E                          2796m     ENDC
0000102E                          2797m 
0000102E                          2798mm     READ_CHAR D3
0000102E                 TRUE     2799mm     IFEQ DEBUG
0000102E  1639 00C00007           2800mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001034                          2801mm     ENDC
00001034                 FALSE    2802mm     IFNE DEBUG
00001034                          2803mm     ENDC
00001034                          2804mm 
00001034  B63C 001B               2805mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001038  6700 EFCE               2806mm     BEQ START
0000103C                          2807mm     ENDM
0000103C                          2808m 
0000103C                 TRUE     2809m     IFEQ DEBUG
0000103C                          2810mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000103C                          2811mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103C                 TRUE     2812mm     IFEQ DEBUG
0000103C  1839 00C00003           2813mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001042  0804 0002               2814mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001046  67F4                    2815mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
00001048  13C3 00C00007           2816mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000104E                          2817mm     ENDC
0000104E                          2818mm 
0000104E                 FALSE    2819mm     IFNE DEBUG
0000104E                          2820mm     ENDC
0000104E                          2821mm 
0000104E                          2822mm     ENDM
0000104E                          2823m     ENDC
0000104E                          2824m     ENDM
0000104E                          2825m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
0000104E  41FA 01FD               2826m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001052  0403 0030               2827m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001056  C6BC 000000FF           2828m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
0000105C  1630 3000               2829m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001060                          2830m     ENDM
00001060  8203                    2831          OR.B D3,D1
00001062                          2832      ENDF
00001062  5242                    2833s     ADD.W   #1,D2
00001064                          2834s _2000000D
00001064  B47C 0007               2835s     CMP.W   #7,D2
00001068  6FB6                    2836s     BLE _2000000C
0000106A                          2837m     PRINT_CRLF D2,A1
0000106A  43FA 020C               2838m     LEA CRLF(PC),A1
0000106E                          2839mm     PRINT_STR A1,D2
0000106E                          2840mm LOOP_211
0000106E  0C11 0000               2841mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001072  6700 0016               2842mm     BEQ EXIT_211
00001076                          2843mmm     PRINT_CHAR (A1)+,D2
00001076                          2844mmm WAIT_FOR_READY_212                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001076                 TRUE     2845mmm     IFEQ DEBUG
00001076  1439 00C00003           2846mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000107C  0802 0002               2847mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001080  67F4                    2848mmm         BEQ WAIT_FOR_READY_212                      ; NO SPACE, CHECK AGAIN
00001082  13D9 00C00007           2849mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001088                          2850mmm     ENDC
00001088                          2851mmm 
00001088                 FALSE    2852mmm     IFNE DEBUG
00001088                          2853mmm     ENDC
00001088                          2854mmm 
00001088                          2855mmm     ENDM
00001088  60E4                    2856mm     BRA LOOP_211
0000108A                          2857mm EXIT_211
0000108A                          2858mm     ENDM
0000108A                          2859m     ENDM
0000108A                          2860  
0000108A  3001                    2861      MOVE.W D1,D0                                        ; extract the LSword for the length
0000108C  E089                    2862      LSR.L #8,D1                                         ; extract the MSword for the address
0000108E  E089                    2863      LSR.L #8,D1
00001090                          2864  
00001090  2241                    2865      MOVE.L D1,A1
00001092                          2866      
00001092  2047                    2867      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001094                          2868      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001094                          2869  
00001094                          2870      WHILE D0 <GT> #0 DO
00001094                          2871s _10000016
00001094  B07C 0000               2872s     CMP.W   #0,D0
00001098  6F00 000E               2873s     BLE _10000017
0000109C  5580                    2874          SUB.L #2,D0
0000109E                          2875  
0000109E  13D1 00E00001           2876          MOVE.B (A1),DISPLAY
000010A4  30D9                    2877          MOVE.W (A1)+,(A0)+
000010A6                          2878      ENDW
000010A6  60EC                    2879s     BRA _10000016
000010A8                          2880s _10000017
000010A8                          2881      
000010A8  6000 F0D0               2882      BRA MAIN_LOOP
000010AC                          2883  
000010AC                          2884  HEX_DIGIT
000010AC  E98F                    2885      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000010AE                          2886m     HEX2BIN D2,D2,A0
000010AE  41FA 019D               2887m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000010B2  0402 0030               2888m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010B6  C4BC 000000FF           2889m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000010BC  1430 2000               2890m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000010C0                          2891m     ENDM
000010C0  8E02                    2892      OR.B D2,D7  
000010C2  6000 F0D6               2893      BRA GET_INPUT
000010C6                          2894  
000010C6  FFFF FFFF               2895      SIMHALT                                             ; halt simulator
000010CA                          2896  
000010CA                          2897  ; strings
000010CA= 50 72 65 73 73 20 ...   2898  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
000010DD= 5B 3F 5D 09 09 09 ...   2899  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
000010E9= 5B 76 5D 09 09 09 ...   2900          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
000010F8= 78 78 78 78 78 78 ...   2901          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001110= 78 78 78 78 78 78 ...   2902          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001130= 78 78 78 78 78 78 ...   2903          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001151= 78 78 78 78 78 78 ...   2904          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001162= 5B 7A 5D 09 09 09 ...   2905          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001174= 78 78 78 78 78 78 ...   2906          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001195= 78 78 78 78 78 78 ...   2907          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000011B4= 78 78 78 78 78 78 ...   2908          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF,NULL
000011D9= 48 75 68 3F 0D 0A 00    2909  HUH  DC.B 'Huh?',CR,LF,NULL
000011E0= 20 53 20 72 65 63 ...   2910  READ    DC.B ' S records read, start address = ',NULL
00001202= 57 3A 20 55 6E 6B ...   2911  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001219= 57 3A 20 43 53 20 ...   2912  CS_FAILURE  DC.B 'W: CS failure at ',NULL
0000122B= 57 3A 20 52 41 4D ...   2913  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
0000123D= 30 31 32 33 34 35 ...   2914  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000124D= 00 01 02 03 04 05 ...   2915  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001264= 4C 6F 61 64 69 6E ...   2916  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001278= 0D 0A 00                2917  CRLF    DC.B CR,LF,NULL
0000127B= 3E 20 00                2918  PROMPT  DC.B '> ',NULL
0000127E= 30 78 00                2919  ox      DC.B '0x',NULL
00001281= 20 2D 3E 20 00          2920  to      DC.B ' -> ',NULL
00001286= 4D 44 46 2D 6D 6F ...   2921  VERSION DC.B 'MDF-mon V1.76 (12/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
000012A3                          2922  
000012A3                          2923      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         123D
CONTINUE_105        942
CONTINUE_46         41E
CONTINUE_49         46E
CONTINUE_53         4C4
CONTINUE_61         578
CONTINUE_66         5EA
CONTINUE_71         666
CONTINUE_76         6E4
CONTINUE_81         76C
CONTINUE_86         7DE
CONTINUE_91         850
CR                  D
CRLF                1278
CS_FAILURE          1219
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A4C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            914
EXIT_110            9AA
EXIT_112            9D2
EXIT_115            9F2
EXIT_12             170
EXIT_120            A3C
EXIT_123            A6C
EXIT_127            AB6
EXIT_130            AD8
EXIT_135            B22
EXIT_137            B94
EXIT_14             19A
EXIT_140            BB8
EXIT_145            C02
EXIT_152            C8E
EXIT_155            CE6
EXIT_158            D08
EXIT_162            D52
EXIT_165            D74
EXIT_170            DBE
EXIT_183            EB6
EXIT_186            F08
EXIT_190            F3C
EXIT_194            F86
EXIT_197            FA8
EXIT_20             22E
EXIT_202            FF2
EXIT_211            108A
EXIT_22             27E
EXIT_24             2AA
EXIT_27             2D4
EXIT_37             382
EXIT_44             3F6
EXIT_5              110
EXIT_58             534
EXIT_7              130
EXIT_9              150
EXIT_96             8C2
EXIT_98             8E2
G                   B26
GET_INPUT           19A
H                   282
HELP                10DD
HELPPROMPT          10CA
HEX2BIN             10B
HEX2BIN_LUT         124D
HEX_DIGIT           10AC
HUH                 11D9
L                   C12
LF                  A
LOADING             1264
LOOP_102            8F8
LOOP_110            98E
LOOP_112            9B6
LOOP_114            9F4
LOOP_115            9D6
LOOP_12             154
LOOP_120            A20
LOOP_122            A6E
LOOP_123            A50
LOOP_127            A9A
LOOP_129            ADA
LOOP_130            ABC
LOOP_135            B06
LOOP_137            B78
LOOP_139            BBA
LOOP_14             17E
LOOP_140            B9C
LOOP_145            BE6
LOOP_152            C72
LOOP_155            CCA
LOOP_157            D0A
LOOP_158            CEC
LOOP_162            D36
LOOP_164            D76
LOOP_165            D58
LOOP_170            DA2
LOOP_183            E9A
LOOP_186            EEC
LOOP_189            F3E
LOOP_190            F20
LOOP_194            F6A
LOOP_196            FAA
LOOP_197            F8C
LOOP_20             212
LOOP_202            FD6
LOOP_211            106E
LOOP_22             262
LOOP_24             28E
LOOP_26             2D6
LOOP_27             2B8
LOOP_37             366
LOOP_44             3DA
LOOP_5              F4
LOOP_58             518
LOOP_7              114
LOOP_9              134
LOOP_96             8A6
LOOP_98             8C6
M                   1014
MAIN_LOOP           17A
NULL                0
OX                  127E
P                   E42
PRINTSTR            28E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              127B
PROTECT             A40
R                   2AE
RAM                 200000
RAM_ERROR           122B
READ                11E0
READ_CHAR           62D
READ_DATA_TO_POKE   38A
RESET               4
ROM                 0
S                   3FA
STACK               0
START               8
TAB                 9
TO                  1281
UNPROTECT           979
UNREC               1202
V                   28A
VERSION             1286
W                   386
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_172  DD0
WAIT_FOR_COMPLETE_173  DE6
WAIT_FOR_COMPLETE_174  DFA
WAIT_FOR_COMPLETE_175  E0C
WAIT_FOR_COMPLETE_176  E20
WAIT_FOR_COMPLETE_204  FF4
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8E2
WAIT_FOR_READY_103  900
WAIT_FOR_READY_105  926
WAIT_FOR_READY_107  95A
WAIT_FOR_READY_111  996
WAIT_FOR_READY_113  9BE
WAIT_FOR_READY_116  9DE
WAIT_FOR_READY_118  A06
WAIT_FOR_READY_121  A28
WAIT_FOR_READY_124  A58
WAIT_FOR_READY_126  A80
WAIT_FOR_READY_128  AA2
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  AC4
WAIT_FOR_READY_133  AEC
WAIT_FOR_READY_136  B0E
WAIT_FOR_READY_138  B80
WAIT_FOR_READY_141  BA4
WAIT_FOR_READY_143  BCC
WAIT_FOR_READY_146  BEE
WAIT_FOR_READY_147  C20
WAIT_FOR_READY_149  C3A
WAIT_FOR_READY_15   186
WAIT_FOR_READY_153  C7A
WAIT_FOR_READY_156  CD2
WAIT_FOR_READY_159  CF4
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  D1C
WAIT_FOR_READY_163  D3E
WAIT_FOR_READY_166  D60
WAIT_FOR_READY_168  D88
WAIT_FOR_READY_171  DAA
WAIT_FOR_READY_178  E4E
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  E68
WAIT_FOR_READY_184  EA2
WAIT_FOR_READY_187  EF4
WAIT_FOR_READY_188  F08
WAIT_FOR_READY_191  F28
WAIT_FOR_READY_193  F50
WAIT_FOR_READY_195  F72
WAIT_FOR_READY_198  F94
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_200  FBC
WAIT_FOR_READY_203  FDE
WAIT_FOR_READY_206  1022
WAIT_FOR_READY_208  103C
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_212  1076
WAIT_FOR_READY_23   26A
WAIT_FOR_READY_25   296
WAIT_FOR_READY_28   2C0
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2E8
WAIT_FOR_READY_31   2FE
WAIT_FOR_READY_32   314
WAIT_FOR_READY_33   328
WAIT_FOR_READY_34   33C
WAIT_FOR_READY_35   350
WAIT_FOR_READY_38   36E
WAIT_FOR_READY_39   38C
WAIT_FOR_READY_41   3A6
WAIT_FOR_READY_45   3E2
WAIT_FOR_READY_46   402
WAIT_FOR_READY_48   43C
WAIT_FOR_READY_49   452
WAIT_FOR_READY_51   486
WAIT_FOR_READY_53   4A8
WAIT_FOR_READY_55   4DC
WAIT_FOR_READY_59   520
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   55C
WAIT_FOR_READY_63   590
WAIT_FOR_READY_66   5CE
WAIT_FOR_READY_68   602
WAIT_FOR_READY_71   64A
WAIT_FOR_READY_73   67E
WAIT_FOR_READY_76   6C8
WAIT_FOR_READY_78   6FC
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   750
WAIT_FOR_READY_83   784
WAIT_FOR_READY_86   7C2
WAIT_FOR_READY_88   7F6
WAIT_FOR_READY_91   834
WAIT_FOR_READY_93   868
WAIT_FOR_READY_97   8AE
WAIT_FOR_READY_99   8CE
WAIT_FOR_SRECORD    402
Z                   B2E
_00000000           1DA
_00000001           1EE
_00000002           53C
_00000003           918
_00000004           54A
_00000005           738
_00000006           6AE
_00000007           918
_00000008           8A2
_00000009           918
_0000000A           A40
_0000000B           A4C
_0000000C           C02
_0000000D           DDA
_0000000E           DF4
_0000000F           E08
_00000010           E18
_00000011           E2C
_00000012           FFE
_10000000           49E
_10000001           506
_10000002           552
_10000003           5BA
_10000004           5C4
_10000005           62C
_10000006           640
_10000007           6A8
_10000008           6B2
_10000009           732
_1000000A           6BE
_1000000B           726
_1000000C           746
_1000000D           7AE
_1000000E           7B8
_1000000F           820
_10000010           82A
_10000011           892
_10000012           91C
_10000013           984
_10000014           DBE
_10000015           DE0
_10000016           1094
_10000017           10A8
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           B3A
_20000005           B4A
_20000006           B5E
_20000007           C04
_20000008           C1E
_20000009           C62
_2000000A           E4C
_2000000B           E90
_2000000C           1020
_2000000D           1064
