00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 07:04:26

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Maybe we should also print the record type and the S?
00000000                             9  ; use DOWNLOAD_BYTE to read checksum
00000000                            10  ; lots of repeated code in download between the two S record types (S1 and S2)
00000000                            11  ; give DOWNLOAD_BYTE a loop to remove loop unrolling and doubling of code
00000000                            12  ; include the checksum in download_byte
00000000                            13  ; stop using two registers in download
00000000                            14  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            15  ; Review for any other savings
00000000                            16  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            17  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            18  
00000000                            19  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            20  ; keep track of highest address hit during srec download
00000000                            21  ; fix the reset vector so that it jumps to the start
00000000                            22  ; Replace JMP -> BRA
00000000                            23  ; implement backspace
00000000                            24  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            25  ; fix being able to enter random chars when W'ing
00000000                            26  ; ram check at startup?  Not sure if this is a good idea!
00000000                            27  ; byte W?
00000000                            28  
00000000                            29      ;ORG  $0
00200000                            30      ORG  $200000
00200000                            31  
00200000  =00000000                 32  DEBUG               EQU 0
00200000                            33  
00200000                            34  ; constants
00200000  =00000000                 35  ROM                 EQU $0
00200000  =00200000                 36  RAM                 EQU $200000
00200000                            37     
00200000  =00C00000                 38  DUART_BASE          EQU $C00000
00200000  =00000000                 39  DUART_MRA_          EQU $0
00200000  =00000001                 40  DUART_CSRA_         EQU $1
00200000  =00000001                 41  DUART_SRA_          EQU $1
00200000  =00000002                 42  DUART_CRA_          EQU $2
00200000  =00000003                 43  DUART_TXA_          EQU $3
00200000  =00000003                 44  DUART_RXA_          EQU $3
00200000  =00000004                 45  DUART_ACR_          EQU $4
00200000  =00000005                 46  DUART_IMR_          EQU $5
00200000  =00000008                 47  DUART_MRB_          EQU $8
00200000  =00000009                 48  DUART_CSRB_         EQU $9
00200000  =00000009                 49  DUART_SRB_          EQU $9
00200000  =0000000A                 50  DUART_CRB_          EQU $A
00200000  =0000000B                 51  DUART_TXB_          EQU $B
00200000  =0000000B                 52  DUART_RXB_          EQU $B
00200000  =0000000C                 53  DUART_IVR_          EQU $C
00200000  =0000000D                 54  DUART_OPCR_         EQU $D
00200000  =0000000E                 55  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 56  DUART_RESET_OPR_    EQU $F
00200000                            57  
00200000  =00C00001                 58  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 59  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 60  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 61  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 62  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 63  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            64  
00200000  =00C00011                 65  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 66  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 67  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 68  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 69  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 70  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            71  
00200000  =00C00009                 72  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 73  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 74  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 75  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 76  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 77  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            78  
00200000  =00E00000                 79  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 80  DISPLAY_            EQU $0
00200000  =00E00001                 81  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            82  
00200000                            83  ; macros
00200000                            84  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            85  ; the input register is changed during the process
00200000                            86  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            87  BIN2HEX MACRO
00200000                            88      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            89      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            90      MOVE.B \1,\2
00200000                            91      ANDI.L #$F,\2
00200000                            92      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            93      ENDM
00200000                            94  
00200000                            95  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            96  ; the input register is changed during the process
00200000                            97  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            98  HEX2BIN MACRO
00200000                            99      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                           100      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                           101      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                           102      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           103      ENDM
00200000                           104  
00200000                           105  ; send a single char to the serial port
00200000                           106  ; \1 = char to send, \2 = data register to use for status poll
00200000                           107  ; will stamp on D0 and D1 in debug mode
00200000                           108  PRINT_CHAR MACRO
00200000                           109  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           110      IFEQ DEBUG
00200000                           111          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           112          BTST #2,\2                              ; check for space to send
00200000                           113          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           114          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           115      ENDC
00200000                           116      
00200000                           117      IFNE DEBUG
00200000                           118          MOVE.B \1,D1
00200000                           119          MOVE.L #6,D0   
00200000                           120          TRAP #15                                ; write to terminal in simulator
00200000                           121      ENDC
00200000                           122  
00200000                           123      ENDM
00200000                           124  
00200000                           125  ; send CR,LF to the serial port
00200000                           126  ; \1 = data register to use for status poll
00200000                           127  PRINT_CRLF MACRO
00200000                           128      PRINT_CHAR #13,\1                           ; CR
00200000                           129      PRINT_CHAR #10,\1                           ; LF
00200000                           130      ENDM
00200000                           131  
00200000                           132  ; send C-style, zero terminated string to the serial port
00200000                           133  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           134  PRINT_STR MACRO
00200000                           135  LOOP\@
00200000                           136      CMP.B #0,(\1)                               ; 0 -> done
00200000                           137      BEQ EXIT\@
00200000                           138      PRINT_CHAR (\1)+,\2
00200000                           139      JMP LOOP\@
00200000                           140  EXIT\@
00200000                           141      ENDM
00200000                           142    
00200000                           143  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           144  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           145  PRINT_REG MACRO
00200000                           146      PRINT_CHAR #'0',\2                          ;0x header
00200000                           147      PRINT_CHAR #'x',\2
00200000                           148      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           149  LOOP\@
00200000                           150      BIN2HEX \1,\3,\5
00200000                           151      PRINT_CHAR \3,\2
00200000                           152      DBEQ \4,LOOP\@
00200000                           153      ENDM
00200000                           154    
00200000                           155  ; wait for a char from the serial port
00200000                           156  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           157  ; will stamp on D0 and D1 in debug mode
00200000                           158  WAIT_CHAR MACRO
00200000                           159  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           160  
00200000                           161      IFEQ DEBUG
00200000                           162          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           163          BTST #0,\2                              ; check for character
00200000                           164          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           165      ENDC
00200000                           166      
00200000                           167      READ_CHAR \1
00200000                           168  
00200000                           169      IFEQ DEBUG
00200000                           170          PRINT_CHAR \1,\2                        ; echo it back
00200000                           171      ENDC
00200000                           172      ENDM
00200000                           173      
00200000                           174  ; read a char from the serial port - assumes that there is one!
00200000                           175  ; \ 1= data register for read char
00200000                           176  ; will stamp on D0 and D1 in debug mode
00200000                           177  READ_CHAR MACRO
00200000                           178      IFEQ DEBUG
00200000                           179          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           180      ENDC
00200000                           181      IFNE DEBUG
00200000                           182          MOVE.L #5,D0    
00200000                           183          TRAP #15                                ; read from keyboard in simulator
00200000                           184          MOVE.L D1,\1
00200000                           185      ENDC
00200000                           186       
00200000                           187      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           188      BEQ START
00200000                           189      ENDM
00200000                           190      
00200000                           191      
00200000                           192  ; read data from the download serial port
00200000                           193  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           194  DOWNLOAD MACRO
00200000                           195  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           196  
00200000                           197      MOVE.B DUART_SRA,\2                         ; check for command
00200000                           198      BTST #0,\2                                  ; check for character
00200000                           199      BEQ CONTINUE\@                              ; nothing, continue
00200000                           200   
00200000                           201      READ_CHAR \1
00200000                           202  CONTINUE\@
00200000                           203      MOVE.B DUART_SRB,\2                         ; read status register
00200000                           204      BTST #0,\2                                  ; check for character
00200000                           205      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           206      
00200000                           207      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           208      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           209      
00200000                           210      ENDM
00200000                           211      
00200000                           212  ; read two hex digits from the download serial port and convert to a byte
00200000                           213  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working address register
00200000                           214  DOWNLOAD_BYTE MACRO
00200000                           215      DOWNLOAD \1,\3                              ; read first (most significant) char, convert to 4 bits and shift to top
00200000                           216      PRINT_CHAR \1,\3
00200000                           217      HEX2BIN \1,\1,\4
00200000                           218      OR.B \1,\2
00200000                           219      LSL.L #4,\2
00200000                           220          
00200000                           221      DOWNLOAD \1,\3                              ; now the second (least significant) char, convert to binary
00200000                           222      PRINT_CHAR \1,\3
00200000                           223      HEX2BIN \1,\1,\4
00200000                           224      OR.B \1,\2    
00200000                           225      ENDM
00200000                           226      
00200000                           227  
00200000                           228  ; register catalogue
00200000                           229  ; D0 - used for simulator I/O
00200000                           230  ; D1 - used for simulator I/O
00200000                           231  ; D2 - read character
00200000                           232  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           233  ; D4 - count of S records read
00200000                           234  ; D5 - data to write / data read / byte count for S record load
00200000                           235  ; D6 - working register used in R/W and download
00200000                           236  ; D7 - address accumulator / reset by download
00200000                           237  ; A0 - address of string to print 
00200000                           238  
00200000                           239  ; start vector
00200000= 00000000                 240  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 241  RESET    DC.L START                             ; RESET
00200008                           242      
00200008                           243  ; start of program  
00200008                           244  START
00200008  13FC 0000 00E00001       245      MOVE.B #0,DISPLAY
00200010                           246  
00200010                           247  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       248      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       249      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     250      NOP
00200022  13FC 0040 00C00005       251      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     252      NOP
0020002C  13FC 0030 00C00005       253      MOVE.B #$30,DUART_CRA
00200034  4E71                     254      NOP
00200036  13FC 0020 00C00005       255      MOVE.B #$20,DUART_CRA
0020003E  4E71                     256      NOP
00200040  13FC 0010 00C00005       257      MOVE.B #$10,DUART_CRA   
00200048                           258  
00200048  13FC 000A 00C00015       259      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       260      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     261      NOP
0020005A  13FC 0040 00C00015       262      MOVE.B #$40,DUART_CRB           
00200062  4E71                     263      NOP
00200064  13FC 0030 00C00015       264      MOVE.B #$30,DUART_CRB
0020006C  4E71                     265      NOP
0020006E  13FC 0020 00C00015       266      MOVE.B #$20,DUART_CRB
00200076  4E71                     267      NOP
00200078  13FC 0010 00C00015       268      MOVE.B #$10,DUART_CRB   
00200080                           269  
00200080                           270  ;initialise UART
00200080  13FC 0000 00C00009       271      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       272      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       273      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           274  
00200098                           275  ; channel A
00200098  13FC 0013 00C00001       276      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       277      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       278      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       279      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           280  
002000B8                           281  ; channel B
002000B8  13FC 0013 00C00011       282      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       283      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       284      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       285      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           286  
002000D8                           287m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           288m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      289m     IFEQ DEBUG
002000D8  1639 00C00003            290m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                291m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     292m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       293m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           294m     ENDC
002000EC                           295m     
002000EC                 FALSE     296m     IFNE DEBUG
002000EC                           297m     ENDC
002000EC                           298m 
002000EC                           299m     ENDM
002000EC                           300  
002000EC  13FC 0001 00E00001       301      MOVE.B #1,DISPLAY
002000F4                           302         
002000F4                           303m     PRINT_CRLF D3
002000F4                           304mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           305mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      306mm     IFEQ DEBUG
002000F4  1639 00C00003            307mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                308mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     309mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       310mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           311mm     ENDC
00200108                           312mm     
00200108                 FALSE     313mm     IFNE DEBUG
00200108                           314mm     ENDC
00200108                           315mm 
00200108                           316mm     ENDM
00200108                           317mm     PRINT_CHAR #10,D3                           ; LF
00200108                           318mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      319mm     IFEQ DEBUG
00200108  1639 00C00003            320mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                321mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     322mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       323mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           324mm     ENDC
0020011C                           325mm     
0020011C                 FALSE     326mm     IFNE DEBUG
0020011C                           327mm     ENDC
0020011C                           328mm 
0020011C                           329mm     ENDM
0020011C                           330m     ENDM
0020011C                           331  
0020011C  41F9 002013C2            332      LEA VERSION,A0
00200122                           333m     PRINT_STR A0,D3
00200122                           334m LOOP_5
00200122  0C10 0000                335m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                336m     BEQ EXIT_5
0020012A                           337mm     PRINT_CHAR (A0)+,D3
0020012A                           338mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      339mm     IFEQ DEBUG
0020012A  1639 00C00003            340mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                341mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     342mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            343mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           344mm     ENDC
0020013C                           345mm     
0020013C                 FALSE     346mm     IFNE DEBUG
0020013C                           347mm     ENDC
0020013C                           348mm 
0020013C                           349mm     ENDM
0020013C  4EF9 00200122            350m     JMP LOOP_5
00200142                           351m EXIT_5
00200142                           352m     ENDM
00200142                           353m     PRINT_CRLF D3
00200142                           354mm     PRINT_CHAR #13,D3                           ; CR
00200142                           355mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      356mm     IFEQ DEBUG
00200142  1639 00C00003            357mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                358mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     359mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       360mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           361mm     ENDC
00200156                           362mm     
00200156                 FALSE     363mm     IFNE DEBUG
00200156                           364mm     ENDC
00200156                           365mm 
00200156                           366mm     ENDM
00200156                           367mm     PRINT_CHAR #10,D3                           ; LF
00200156                           368mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      369mm     IFEQ DEBUG
00200156  1639 00C00003            370mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                371mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     372mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       373mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           374mm     ENDC
0020016A                           375mm     
0020016A                 FALSE     376mm     IFNE DEBUG
0020016A                           377mm     ENDC
0020016A                           378mm 
0020016A                           379mm     ENDM
0020016A                           380m     ENDM
0020016A                           381m     PRINT_CHAR #7,D3
0020016A                           382m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      383m     IFEQ DEBUG
0020016A  1639 00C00003            384m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                385m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     386m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       387m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           388m     ENDC
0020017E                           389m     
0020017E                 FALSE     390m     IFNE DEBUG
0020017E                           391m     ENDC
0020017E                           392m 
0020017E                           393m     ENDM
0020017E                           394  
0020017E  7E00                     395      MOVE.L #0,D7                                ; address accumulator
00200180                           396  
00200180  13FC 0002 00E00001       397      MOVE.B #2,DISPLAY
00200188                           398  MAIN_LOOP
00200188                           399m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           400m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      401m     IFEQ DEBUG
00200188  1639 00C00003            402m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                403m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     404m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       405m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           406m     ENDC
0020019C                           407m     
0020019C                 FALSE     408m     IFNE DEBUG
0020019C                           409m     ENDC
0020019C                           410m 
0020019C                           411m     ENDM
0020019C                           412m     PRINT_CHAR #32,D3                           ; space
0020019C                           413m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      414m     IFEQ DEBUG
0020019C  1639 00C00003            415m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                416m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     417m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       418m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           419m     ENDC
002001B0                           420m     
002001B0                 FALSE     421m     IFNE DEBUG
002001B0                           422m     ENDC
002001B0                           423m 
002001B0                           424m     ENDM
002001B0                           425      
002001B0                           426  GET_INPUT
002001B0                           427m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           428m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           429m 
002001B0                 TRUE      430m     IFEQ DEBUG
002001B0  1639 00C00003            431m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                432m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     433m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           434m     ENDC
002001BC                           435m     
002001BC                           436mm     READ_CHAR D2
002001BC                 TRUE      437mm     IFEQ DEBUG
002001BC  1439 00C00007            438mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           439mm     ENDC
002001C2                 FALSE     440mm     IFNE DEBUG
002001C2                           441mm     ENDC
002001C2                           442mm      
002001C2  B43C 001B                443mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                444mm     BEQ START
002001CA                           445mm     ENDM
002001CA                           446m 
002001CA                 TRUE      447m     IFEQ DEBUG
002001CA                           448mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           449mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      450mm     IFEQ DEBUG
002001CA  1639 00C00003            451mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                452mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     453mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            454mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           455mm     ENDC
002001DC                           456mm     
002001DC                 FALSE     457mm     IFNE DEBUG
002001DC                           458mm     ENDC
002001DC                           459mm 
002001DC                           460mm     ENDM
002001DC                           461m     ENDC
002001DC                           462m     ENDM
002001DC                           463      
002001DC  B43C 0030                464      CMP.B #'0',D2
002001E0  6700 11BE                465      BEQ HEX_DIGIT
002001E4  B43C 0031                466      CMP.B #'1',D2
002001E8  6700 11B6                467      BEQ HEX_DIGIT
002001EC  B43C 0032                468      CMP.B #'2',D2
002001F0  6700 11AE                469      BEQ HEX_DIGIT
002001F4  B43C 0033                470      CMP.B #'3',D2
002001F8  6700 11A6                471      BEQ HEX_DIGIT
002001FC  B43C 0034                472      CMP.B #'4',D2
00200200  6700 119E                473      BEQ HEX_DIGIT
00200204  B43C 0035                474      CMP.B #'5',D2
00200208  6700 1196                475      BEQ HEX_DIGIT
0020020C  B43C 0036                476      CMP.B #'6',D2
00200210  6700 118E                477      BEQ HEX_DIGIT
00200214  B43C 0037                478      CMP.B #'7',D2
00200218  6700 1186                479      BEQ HEX_DIGIT
0020021C  B43C 0038                480      CMP.B #'8',D2
00200220  6700 117E                481      BEQ HEX_DIGIT
00200224  B43C 0039                482      CMP.B #'9',D2
00200228  6700 1176                483      BEQ HEX_DIGIT
0020022C  B43C 0041                484      CMP.B #'A',D2
00200230  6700 116E                485      BEQ HEX_DIGIT
00200234  B43C 0042                486      CMP.B #'B',D2
00200238  6700 1166                487      BEQ HEX_DIGIT
0020023C  B43C 0043                488      CMP.B #'C',D2
00200240  6700 115E                489      BEQ HEX_DIGIT
00200244  B43C 0044                490      CMP.B #'D',D2
00200248  6700 1156                491      BEQ HEX_DIGIT
0020024C  B43C 0045                492      CMP.B #'E',D2
00200250  6700 114E                493      BEQ HEX_DIGIT
00200254  B43C 0046                494      CMP.B #'F',D2
00200258  6700 1146                495      BEQ HEX_DIGIT
0020025C                           496      
0020025C  B43C 0057                497      CMP.B #'W',D2
00200260  6700 016E                498      BEQ W
00200264                           499      
00200264  B43C 004C                500      CMP.B #'L',D2
00200268  6700 0FC0                501      BEQ L 
0020026C                           502  
0020026C                           503m     PRINT_CRLF D3
0020026C                           504mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           505mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      506mm     IFEQ DEBUG
0020026C  1639 00C00003            507mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                508mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     509mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       510mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           511mm     ENDC
00200280                           512mm     
00200280                 FALSE     513mm     IFNE DEBUG
00200280                           514mm     ENDC
00200280                           515mm 
00200280                           516mm     ENDM
00200280                           517mm     PRINT_CHAR #10,D3                           ; LF
00200280                           518mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      519mm     IFEQ DEBUG
00200280  1639 00C00003            520mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                521mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     522mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       523mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           524mm     ENDC
00200294                           525mm     
00200294                 FALSE     526mm     IFNE DEBUG
00200294                           527mm     ENDC
00200294                           528mm 
00200294                           529mm     ENDM
00200294                           530m     ENDM
00200294                           531   
00200294  B43C 003F                532      CMP.B #'?',D2
00200298  6700 0056                533      BEQ H
0020029C                           534  
0020029C  B43C 0056                535      CMP.B #'V',D2
002002A0  6700 007A                536      BEQ V
002002A4                           537      
002002A4  B43C 0052                538      CMP.B #'R',D2
002002A8  6700 009E                539      BEQ R
002002AC                           540  
002002AC  B43C 0053                541      CMP.B #'S',D2
002002B0  6700 01E6                542      BEQ S
002002B4                           543  
002002B4  B43C 0047                544      CMP.B #'G',D2
002002B8  6700 0E5C                545      BEQ G   
002002BC                           546  
002002BC  B43C 005A                547      CMP.B #'Z',D2
002002C0  6700 0E5C                548      BEQ Z   
002002C4                           549  
002002C4  41F9 00201476            550      LEA HUH,A0
002002CA                           551m     PRINT_STR A0,D3
002002CA                           552m LOOP_19
002002CA  0C10 0000                553m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                554m     BEQ EXIT_19
002002D2                           555mm     PRINT_CHAR (A0)+,D3
002002D2                           556mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      557mm     IFEQ DEBUG
002002D2  1639 00C00003            558mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                559mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     560mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            561mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           562mm     ENDC
002002E4                           563mm     
002002E4                 FALSE     564mm     IFNE DEBUG
002002E4                           565mm     ENDC
002002E4                           566mm 
002002E4                           567mm     ENDM
002002E4  4EF9 002002CA            568m     JMP LOOP_19
002002EA                           569m EXIT_19
002002EA                           570m     ENDM
002002EA                           571                         
002002EA  4EF9 00200188            572      JMP MAIN_LOOP
002002F0                           573      
002002F0                           574  ; commands
002002F0                           575  H   
002002F0  41F9 002013DF            576      LEA HELP,A0
002002F6                           577m     PRINT_STR A0,D3
002002F6                           578m LOOP_21
002002F6  0C10 0000                579m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                580m     BEQ EXIT_21
002002FE                           581mm     PRINT_CHAR (A0)+,D3
002002FE                           582mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      583mm     IFEQ DEBUG
002002FE  1639 00C00003            584mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                585mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     586mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            587mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           588mm     ENDC
00200310                           589mm     
00200310                 FALSE     590mm     IFNE DEBUG
00200310                           591mm     ENDC
00200310                           592mm 
00200310                           593mm     ENDM
00200310  4EF9 002002F6            594m     JMP LOOP_21
00200316                           595m EXIT_21
00200316                           596m     ENDM
00200316  4EF9 00200188            597      JMP MAIN_LOOP
0020031C                           598  
0020031C                           599  V   
0020031C  41F9 002013C2            600      LEA VERSION,A0
00200322                           601m     PRINT_STR A0,D3       
00200322                           602m LOOP_23
00200322  0C10 0000                603m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                604m     BEQ EXIT_23
0020032A                           605mm     PRINT_CHAR (A0)+,D3
0020032A                           606mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      607mm     IFEQ DEBUG
0020032A  1639 00C00003            608mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                609mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     610mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            611mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           612mm     ENDC
0020033C                           613mm     
0020033C                 FALSE     614mm     IFNE DEBUG
0020033C                           615mm     ENDC
0020033C                           616mm 
0020033C                           617mm     ENDM
0020033C  4EF9 00200322            618m     JMP LOOP_23
00200342                           619m EXIT_23
00200342                           620m     ENDM
00200342  4EF9 00200188            621      JMP MAIN_LOOP
00200348                           622      
00200348                           623  R   
00200348  2047                     624      MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     625      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           626m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           627mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           628mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      629mm     IFEQ DEBUG
0020034C  1639 00C00003            630mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                631mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     632mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       633mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           634mm     ENDC
00200360                           635mm     
00200360                 FALSE     636mm     IFNE DEBUG
00200360                           637mm     ENDC
00200360                           638mm 
00200360                           639mm     ENDM
00200360                           640mm     PRINT_CHAR #'x',D3
00200360                           641mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      642mm     IFEQ DEBUG
00200360  1639 00C00003            643mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                644mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     645mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       646mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           647mm     ENDC
00200374                           648mm     
00200374                 FALSE     649mm     IFNE DEBUG
00200374                           650mm     ENDC
00200374                           651mm 
00200374                           652mm     ENDM
00200374  7C07                     653m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           654m LOOP_25
00200376                           655mm     BIN2HEX D5,D7,A0
00200376  41F9 002014DA            656mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     657mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     658mm     MOVE.B D5,D7
00200380  0287 0000000F            659mm     ANDI.L #$F,D7
00200386  1E30 7000                660mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           661mm     ENDM
0020038A                           662mm     PRINT_CHAR D7,D3
0020038A                           663mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      664mm     IFEQ DEBUG
0020038A  1639 00C00003            665mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                666mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     667mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            668mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           669mm     ENDC
0020039C                           670mm     
0020039C                 FALSE     671mm     IFNE DEBUG
0020039C                           672mm     ENDC
0020039C                           673mm 
0020039C                           674mm     ENDM
0020039C  57CE FFD8                675m     DBEQ D6,LOOP_25
002003A0                           676m     ENDM
002003A0                           677m     PRINT_CRLF D3
002003A0                           678mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           679mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      680mm     IFEQ DEBUG
002003A0  1639 00C00003            681mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                682mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     683mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       684mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           685mm     ENDC
002003B4                           686mm     
002003B4                 FALSE     687mm     IFNE DEBUG
002003B4                           688mm     ENDC
002003B4                           689mm 
002003B4                           690mm     ENDM
002003B4                           691mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           692mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      693mm     IFEQ DEBUG
002003B4  1639 00C00003            694mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                695mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     696mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       697mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           698mm     ENDC
002003C8                           699mm     
002003C8                 FALSE     700mm     IFNE DEBUG
002003C8                           701mm     ENDC
002003C8                           702mm 
002003C8                           703mm     ENDM
002003C8                           704m     ENDM
002003C8  7E00                     705      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            706      JMP MAIN_LOOP
002003D0                           707  
002003D0                           708  W
002003D0  7A00                     709      MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           710  
002003D2                           711m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           712m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           713m 
002003D2                 TRUE      714m     IFEQ DEBUG
002003D2  1639 00C00003            715m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                716m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     717m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           718m     ENDC
002003DE                           719m     
002003DE                           720mm     READ_CHAR D2
002003DE                 TRUE      721mm     IFEQ DEBUG
002003DE  1439 00C00007            722mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           723mm     ENDC
002003E4                 FALSE     724mm     IFNE DEBUG
002003E4                           725mm     ENDC
002003E4                           726mm      
002003E4  B43C 001B                727mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                728mm     BEQ START
002003EC                           729mm     ENDM
002003EC                           730m 
002003EC                 TRUE      731m     IFEQ DEBUG
002003EC                           732mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           733mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      734mm     IFEQ DEBUG
002003EC  1639 00C00003            735mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                736mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     737mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            738mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           739mm     ENDC
002003FE                           740mm     
002003FE                 FALSE     741mm     IFNE DEBUG
002003FE                           742mm     ENDC
002003FE                           743mm 
002003FE                           744mm     ENDM
002003FE                           745m     ENDC
002003FE                           746m     ENDM
002003FE                           747m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 002014EA            748m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                749m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            750m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                751m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           752m     ENDM
00200412  1A02                     753      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           754  
00200414  3C3C 0006                755      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           756      
00200418                           757  READ_DATA_TO_POKE
00200418  E98D                     758      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           759m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           760m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           761m 
0020041A                 TRUE      762m     IFEQ DEBUG
0020041A  1639 00C00003            763m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                764m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     765m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           766m     ENDC
00200426                           767m     
00200426                           768mm     READ_CHAR D2
00200426                 TRUE      769mm     IFEQ DEBUG
00200426  1439 00C00007            770mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           771mm     ENDC
0020042C                 FALSE     772mm     IFNE DEBUG
0020042C                           773mm     ENDC
0020042C                           774mm      
0020042C  B43C 001B                775mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                776mm     BEQ START
00200434                           777mm     ENDM
00200434                           778m 
00200434                 TRUE      779m     IFEQ DEBUG
00200434                           780mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           781mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      782mm     IFEQ DEBUG
00200434  1639 00C00003            783mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                784mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     785mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            786mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           787mm     ENDC
00200446                           788mm     
00200446                 FALSE     789mm     IFNE DEBUG
00200446                           790mm     ENDC
00200446                           791mm 
00200446                           792mm     ENDM
00200446                           793m     ENDC
00200446                           794m     ENDM
00200446                           795m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 002014EA            796m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                797m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            798m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                799m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           800m     ENDM
0020045A  8A02                     801      OR.B D2,D5
0020045C  023C 00FB                802      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                803      DBEQ D6,READ_DATA_TO_POKE
00200464                           804      
00200464  2047                     805      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     806      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           807      
00200468  2085                     808      MOVE.L D5,(A0)                              ; write the data
0020046A                           809  
0020046A                           810m     PRINT_CRLF D3
0020046A                           811mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           812mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      813mm     IFEQ DEBUG
0020046A  1639 00C00003            814mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                815mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     816mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       817mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           818mm     ENDC
0020047E                           819mm     
0020047E                 FALSE     820mm     IFNE DEBUG
0020047E                           821mm     ENDC
0020047E                           822mm 
0020047E                           823mm     ENDM
0020047E                           824mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           825mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      826mm     IFEQ DEBUG
0020047E  1639 00C00003            827mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                828mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     829mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       830mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           831mm     ENDC
00200492                           832mm     
00200492                 FALSE     833mm     IFNE DEBUG
00200492                           834mm     ENDC
00200492                           835mm 
00200492                           836mm     ENDM
00200492                           837m     ENDM
00200492  4EF9 00200188            838      JMP MAIN_LOOP
00200498                           839  
00200498                           840          
00200498                           841  S
00200498  2647                     842      MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     843      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                844      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           845      
002004A0                           846  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           847m     DOWNLOAD D2,D3                  
002004A0                           848m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           849m 
002004A0  1639 00C00003            850m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004A6  0803 0000                851m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                852m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           853m  
002004AE                           854mm     READ_CHAR D2
002004AE                 TRUE      855mm     IFEQ DEBUG
002004AE  1439 00C00007            856mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           857mm     ENDC
002004B4                 FALSE     858mm     IFNE DEBUG
002004B4                           859mm     ENDC
002004B4                           860mm      
002004B4  B43C 001B                861mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                862mm     BEQ START
002004BC                           863mm     ENDM
002004BC                           864m CONTINUE_44
002004BC  1639 00C00013            865m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002004C2  0803 0000                866m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004C6  67D8                     867m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           868m     
002004C8  1439 00C00017            869m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            870m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           871m     
002004D4                           872m     ENDM
002004D4  B43C 0053                873      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     874      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           875      
002004DA                           876m     PRINT_CHAR #'S',D3                            ; print it
002004DA                           877m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      878m     IFEQ DEBUG
002004DA  1639 00C00003            879m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002004E0  0803 0002                880m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     881m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004E6  13FC 0053 00C00007       882m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004EE                           883m     ENDC
002004EE                           884m     
002004EE                 FALSE     885m     IFNE DEBUG
002004EE                           886m     ENDC
002004EE                           887m 
002004EE                           888m     ENDM
002004EE  5284                     889      ADD.L #1,D4                                 ; read another S record, increment count
002004F0                           890      
002004F0                           891m     DOWNLOAD D7,D3                              ; read the record identifier
002004F0                           892m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004F0                           893m 
002004F0  1639 00C00003            894m     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002004F6  0803 0000                895m     BTST #0,D3                                  ; CHECK FOR CHARACTER
002004FA  6700 0010                896m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004FE                           897m  
002004FE                           898mm     READ_CHAR D7
002004FE                 TRUE      899mm     IFEQ DEBUG
002004FE  1E39 00C00007            900mm         MOVE.B DUART_RXA,D7                     ; GOT A CHARACTER, READ IT
00200504                           901mm     ENDC
00200504                 FALSE     902mm     IFNE DEBUG
00200504                           903mm     ENDC
00200504                           904mm      
00200504  BE3C 001B                905mm     CMP.B #$1B,D7                               ; CHECK FOR ESCAPE AND GO TO START
00200508  6700 FAFE                906mm     BEQ START
0020050C                           907mm     ENDM
0020050C                           908m CONTINUE_47
0020050C  1639 00C00013            909m     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200512  0803 0000                910m     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200516  67D8                     911m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00200518                           912m     
00200518  1E39 00C00017            913m     MOVE.B DUART_RXB,D7                         ; GOT A CHARACTER, READ IT
0020051E  13C7 00E00001            914m     MOVE.B D7,DISPLAY                           ; ECHO TO THE DISPLAY
00200524                           915m     
00200524                           916m     ENDM
00200524                           917m     PRINT_CHAR D7,D3                            ; print it
00200524                           918m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200524                 TRUE      919m     IFEQ DEBUG
00200524  1639 00C00003            920m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020052A  0803 0002                921m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020052E  67F4                     922m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200530  13C7 00C00007            923m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200536                           924m     ENDC
00200536                           925m     
00200536                 FALSE     926m     IFNE DEBUG
00200536                           927m     ENDC
00200536                           928m 
00200536                           929m     ENDM
00200536                           930  
00200536  7C00                     931      MOVE.L #0,D6                                ; clear the checksum
00200538                           932  
00200538  7A00                     933      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
0020053A                           934m     DOWNLOAD_BYTE D2,D5,D3,A0                               
0020053A                           935mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
0020053A                           936mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020053A                           937mm 
0020053A  1639 00C00003            938mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200540  0803 0000                939mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200544  6700 0010                940mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
00200548                           941mm  
00200548                           942mmm     READ_CHAR D2
00200548                 TRUE      943mmm     IFEQ DEBUG
00200548  1439 00C00007            944mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020054E                           945mmm     ENDC
0020054E                 FALSE     946mmm     IFNE DEBUG
0020054E                           947mmm     ENDC
0020054E                           948mmm      
0020054E  B43C 001B                949mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200552  6700 FAB4                950mmm     BEQ START
00200556                           951mmm     ENDM
00200556                           952mm CONTINUE_51
00200556  1639 00C00013            953mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020055C  0803 0000                954mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200560  67D8                     955mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200562                           956mm     
00200562  1439 00C00017            957mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200568  13C2 00E00001            958mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020056E                           959mm     
0020056E                           960mm     ENDM
0020056E                           961mm     PRINT_CHAR D2,D3
0020056E                           962mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020056E                 TRUE      963mm     IFEQ DEBUG
0020056E  1639 00C00003            964mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200574  0803 0002                965mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200578  67F4                     966mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0020057A  13C2 00C00007            967mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200580                           968mm     ENDC
00200580                           969mm     
00200580                 FALSE     970mm     IFNE DEBUG
00200580                           971mm     ENDC
00200580                           972mm 
00200580                           973mm     ENDM
00200580                           974mm     HEX2BIN D2,D2,A0
00200580  41F9 002014EA            975mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200586  0402 0030                976mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020058A  C4BC 000000FF            977mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200590  1430 2000                978mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200594                           979mm     ENDM
00200594  8A02                     980m     OR.B D2,D5
00200596  E98D                     981m     LSL.L #4,D5
00200598                           982m         
00200598                           983mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200598                           984mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200598                           985mm 
00200598  1639 00C00003            986mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
0020059E  0803 0000                987mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005A2  6700 0010                988mm     BEQ CONTINUE_55                             ; NOTHING, CONTINUE
002005A6                           989mm  
002005A6                           990mmm     READ_CHAR D2
002005A6                 TRUE      991mmm     IFEQ DEBUG
002005A6  1439 00C00007            992mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002005AC                           993mmm     ENDC
002005AC                 FALSE     994mmm     IFNE DEBUG
002005AC                           995mmm     ENDC
002005AC                           996mmm      
002005AC  B43C 001B                997mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002005B0  6700 FA56                998mmm     BEQ START
002005B4                           999mmm     ENDM
002005B4                          1000mm CONTINUE_55
002005B4  1639 00C00013           1001mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002005BA  0803 0000               1002mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002005BE  67D8                    1003mm     BEQ WAIT_FOR_READY_55                       ; NOTHING, CHECK AGAIN
002005C0                          1004mm     
002005C0  1439 00C00017           1005mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002005C6  13C2 00E00001           1006mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002005CC                          1007mm     
002005CC                          1008mm     ENDM
002005CC                          1009mm     PRINT_CHAR D2,D3
002005CC                          1010mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005CC                 TRUE     1011mm     IFEQ DEBUG
002005CC  1639 00C00003           1012mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005D2  0803 0002               1013mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005D6  67F4                    1014mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005D8  13C2 00C00007           1015mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002005DE                          1016mm     ENDC
002005DE                          1017mm     
002005DE                 FALSE    1018mm     IFNE DEBUG
002005DE                          1019mm     ENDC
002005DE                          1020mm 
002005DE                          1021mm     ENDM
002005DE                          1022mm     HEX2BIN D2,D2,A0
002005DE  41F9 002014EA           1023mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002005E4  0402 0030               1024mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005E8  C4BC 000000FF           1025mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002005EE  1430 2000               1026mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005F2                          1027mm     ENDM
002005F2  8A02                    1028m     OR.B D2,D5    
002005F4                          1029m     ENDM
002005F4  DC85                    1030      ADD.L D5,D6                                 ; add to checksum
002005F6                          1031  
002005F6                          1032      IF.B D7 <EQ> #'0' THEN.L                    ; header, just ignore it
002005F6  BE3C 0030               1033s     CMP.B   #'0',D7
002005FA  6600 000A               1034s     BNE.L   _00000000
002005FE  6000 FEA0               1035          BRA WAIT_FOR_SRECORD
00200602                          1036      ELSE
00200602  6000 0878               1037s     BRA _00000001
00200606                          1038s _00000000
00200606                          1039          IF.B D7 <EQ> #'1' THEN.L                ; 16 bit address data record
00200606  BE3C 0031               1040s     CMP.B   #'1',D7
0020060A  6600 028A               1041s     BNE.L   _00000002
0020060E  7E00                    1042              MOVE.L #0,D7                        ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200610                          1043m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte                           
00200610                          1044mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200610                          1045mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200610                          1046mm 
00200610  1639 00C00003           1047mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200616  0803 0000               1048mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
0020061A  6700 0010               1049mm     BEQ CONTINUE_60                             ; NOTHING, CONTINUE
0020061E                          1050mm  
0020061E                          1051mmm     READ_CHAR D2
0020061E                 TRUE     1052mmm     IFEQ DEBUG
0020061E  1439 00C00007           1053mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200624                          1054mmm     ENDC
00200624                 FALSE    1055mmm     IFNE DEBUG
00200624                          1056mmm     ENDC
00200624                          1057mmm      
00200624  B43C 001B               1058mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200628  6700 F9DE               1059mmm     BEQ START
0020062C                          1060mmm     ENDM
0020062C                          1061mm CONTINUE_60
0020062C  1639 00C00013           1062mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200632  0803 0000               1063mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200636  67D8                    1064mm     BEQ WAIT_FOR_READY_60                       ; NOTHING, CHECK AGAIN
00200638                          1065mm     
00200638  1439 00C00017           1066mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020063E  13C2 00E00001           1067mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200644                          1068mm     
00200644                          1069mm     ENDM
00200644                          1070mm     PRINT_CHAR D2,D3
00200644                          1071mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200644                 TRUE     1072mm     IFEQ DEBUG
00200644  1639 00C00003           1073mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020064A  0803 0002               1074mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020064E  67F4                    1075mm         BEQ WAIT_FOR_READY_62                   ; NO SPACE, CHECK AGAIN
00200650  13C2 00C00007           1076mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200656                          1077mm     ENDC
00200656                          1078mm     
00200656                 FALSE    1079mm     IFNE DEBUG
00200656                          1080mm     ENDC
00200656                          1081mm 
00200656                          1082mm     ENDM
00200656                          1083mm     HEX2BIN D2,D2,A0
00200656  41F9 002014EA           1084mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020065C  0402 0030               1085mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200660  C4BC 000000FF           1086mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200666  1430 2000               1087mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020066A                          1088mm     ENDM
0020066A  8E02                    1089m     OR.B D2,D7
0020066C  E98F                    1090m     LSL.L #4,D7
0020066E                          1091m         
0020066E                          1092mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
0020066E                          1093mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020066E                          1094mm 
0020066E  1639 00C00003           1095mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200674  0803 0000               1096mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200678  6700 0010               1097mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0020067C                          1098mm  
0020067C                          1099mmm     READ_CHAR D2
0020067C                 TRUE     1100mmm     IFEQ DEBUG
0020067C  1439 00C00007           1101mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200682                          1102mmm     ENDC
00200682                 FALSE    1103mmm     IFNE DEBUG
00200682                          1104mmm     ENDC
00200682                          1105mmm      
00200682  B43C 001B               1106mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200686  6700 F980               1107mmm     BEQ START
0020068A                          1108mmm     ENDM
0020068A                          1109mm CONTINUE_64
0020068A  1639 00C00013           1110mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200690  0803 0000               1111mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200694  67D8                    1112mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00200696                          1113mm     
00200696  1439 00C00017           1114mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020069C  13C2 00E00001           1115mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006A2                          1116mm     
002006A2                          1117mm     ENDM
002006A2                          1118mm     PRINT_CHAR D2,D3
002006A2                          1119mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006A2                 TRUE     1120mm     IFEQ DEBUG
002006A2  1639 00C00003           1121mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002006A8  0803 0002               1122mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002006AC  67F4                    1123mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006AE  13C2 00C00007           1124mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006B4                          1125mm     ENDC
002006B4                          1126mm     
002006B4                 FALSE    1127mm     IFNE DEBUG
002006B4                          1128mm     ENDC
002006B4                          1129mm 
002006B4                          1130mm     ENDM
002006B4                          1131mm     HEX2BIN D2,D2,A0
002006B4  41F9 002014EA           1132mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006BA  0402 0030               1133mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006BE  C4BC 000000FF           1134mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006C4  1430 2000               1135mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006C8                          1136mm     ENDM
002006C8  8E02                    1137m     OR.B D2,D7    
002006CA                          1138m     ENDM
002006CA  DC87                    1139              ADD.L D7,D6                         ; add into checksum
002006CC                          1140  
002006CC  E98F                    1141              LSL.L #4,D7                         ; bottom byte
002006CE                          1142m             DOWNLOAD_BYTE D2,D7,D3,A0           ; top byte       
002006CE                          1143mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002006CE                          1144mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006CE                          1145mm 
002006CE  1639 00C00003           1146mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002006D4  0803 0000               1147mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006D8  6700 0010               1148mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
002006DC                          1149mm  
002006DC                          1150mmm     READ_CHAR D2
002006DC                 TRUE     1151mmm     IFEQ DEBUG
002006DC  1439 00C00007           1152mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002006E2                          1153mmm     ENDC
002006E2                 FALSE    1154mmm     IFNE DEBUG
002006E2                          1155mmm     ENDC
002006E2                          1156mmm      
002006E2  B43C 001B               1157mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002006E6  6700 F920               1158mmm     BEQ START
002006EA                          1159mmm     ENDM
002006EA                          1160mm CONTINUE_69
002006EA  1639 00C00013           1161mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002006F0  0803 0000               1162mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002006F4  67D8                    1163mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
002006F6                          1164mm     
002006F6  1439 00C00017           1165mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006FC  13C2 00E00001           1166mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200702                          1167mm     
00200702                          1168mm     ENDM
00200702                          1169mm     PRINT_CHAR D2,D3
00200702                          1170mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200702                 TRUE     1171mm     IFEQ DEBUG
00200702  1639 00C00003           1172mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200708  0803 0002               1173mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020070C  67F4                    1174mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0020070E  13C2 00C00007           1175mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200714                          1176mm     ENDC
00200714                          1177mm     
00200714                 FALSE    1178mm     IFNE DEBUG
00200714                          1179mm     ENDC
00200714                          1180mm 
00200714                          1181mm     ENDM
00200714                          1182mm     HEX2BIN D2,D2,A0
00200714  41F9 002014EA           1183mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020071A  0402 0030               1184mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020071E  C4BC 000000FF           1185mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200724  1430 2000               1186mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200728                          1187mm     ENDM
00200728  8E02                    1188m     OR.B D2,D7
0020072A  E98F                    1189m     LSL.L #4,D7
0020072C                          1190m         
0020072C                          1191mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
0020072C                          1192mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020072C                          1193mm 
0020072C  1639 00C00003           1194mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200732  0803 0000               1195mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200736  6700 0010               1196mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
0020073A                          1197mm  
0020073A                          1198mmm     READ_CHAR D2
0020073A                 TRUE     1199mmm     IFEQ DEBUG
0020073A  1439 00C00007           1200mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200740                          1201mmm     ENDC
00200740                 FALSE    1202mmm     IFNE DEBUG
00200740                          1203mmm     ENDC
00200740                          1204mmm      
00200740  B43C 001B               1205mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200744  6700 F8C2               1206mmm     BEQ START
00200748                          1207mmm     ENDM
00200748                          1208mm CONTINUE_73
00200748  1639 00C00013           1209mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
0020074E  0803 0000               1210mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200752  67D8                    1211mm     BEQ WAIT_FOR_READY_73                       ; NOTHING, CHECK AGAIN
00200754                          1212mm     
00200754  1439 00C00017           1213mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020075A  13C2 00E00001           1214mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200760                          1215mm     
00200760                          1216mm     ENDM
00200760                          1217mm     PRINT_CHAR D2,D3
00200760                          1218mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200760                 TRUE     1219mm     IFEQ DEBUG
00200760  1639 00C00003           1220mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200766  0803 0002               1221mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020076A  67F4                    1222mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
0020076C  13C2 00C00007           1223mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200772                          1224mm     ENDC
00200772                          1225mm     
00200772                 FALSE    1226mm     IFNE DEBUG
00200772                          1227mm     ENDC
00200772                          1228mm 
00200772                          1229mm     ENDM
00200772                          1230mm     HEX2BIN D2,D2,A0
00200772  41F9 002014EA           1231mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200778  0402 0030               1232mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020077C  C4BC 000000FF           1233mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200782  1430 2000               1234mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200786                          1235mm     ENDM
00200786  8E02                    1236m     OR.B D2,D7    
00200788                          1237m     ENDM
00200788  7400                    1238              MOVE.L #0,D2                        ; rextract bottom byte of address and add into checksum
0020078A  1407                    1239              MOVE.B D7,D2
0020078C  DC82                    1240              ADD.L D2,D6
0020078E                          1241          
0020078E  2247                    1242              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00200790  D3CB                    1243              ADD.L A3,A1                         ; add in the offset
00200792                          1244          
00200792  5785                    1245              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
00200794                          1246          
00200794                          1247              WHILE.L D5 <GT> #0 DO               ; read the data bytes
00200794                          1248s _10000000
00200794  BABC 00000000           1249s     CMP.L   #0,D5
0020079A  6F00 00C8               1250s     BLE _10000001
0020079E  7E00                    1251                  MOVE.L #0,D7                    ; D7 holds the byte
002007A0                          1252m                 DOWNLOAD_BYTE D2,D7,D3,A0       ; read it                               
002007A0                          1253mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002007A0                          1254mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007A0                          1255mm 
002007A0  1639 00C00003           1256mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002007A6  0803 0000               1257mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002007AA  6700 0010               1258mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
002007AE                          1259mm  
002007AE                          1260mmm     READ_CHAR D2
002007AE                 TRUE     1261mmm     IFEQ DEBUG
002007AE  1439 00C00007           1262mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002007B4                          1263mmm     ENDC
002007B4                 FALSE    1264mmm     IFNE DEBUG
002007B4                          1265mmm     ENDC
002007B4                          1266mmm      
002007B4  B43C 001B               1267mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002007B8  6700 F84E               1268mmm     BEQ START
002007BC                          1269mmm     ENDM
002007BC                          1270mm CONTINUE_78
002007BC  1639 00C00013           1271mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002007C2  0803 0000               1272mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002007C6  67D8                    1273mm     BEQ WAIT_FOR_READY_78                       ; NOTHING, CHECK AGAIN
002007C8                          1274mm     
002007C8  1439 00C00017           1275mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002007CE  13C2 00E00001           1276mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002007D4                          1277mm     
002007D4                          1278mm     ENDM
002007D4                          1279mm     PRINT_CHAR D2,D3
002007D4                          1280mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007D4                 TRUE     1281mm     IFEQ DEBUG
002007D4  1639 00C00003           1282mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007DA  0803 0002               1283mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007DE  67F4                    1284mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
002007E0  13C2 00C00007           1285mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007E6                          1286mm     ENDC
002007E6                          1287mm     
002007E6                 FALSE    1288mm     IFNE DEBUG
002007E6                          1289mm     ENDC
002007E6                          1290mm 
002007E6                          1291mm     ENDM
002007E6                          1292mm     HEX2BIN D2,D2,A0
002007E6  41F9 002014EA           1293mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002007EC  0402 0030               1294mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007F0  C4BC 000000FF           1295mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002007F6  1430 2000               1296mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002007FA                          1297mm     ENDM
002007FA  8E02                    1298m     OR.B D2,D7
002007FC  E98F                    1299m     LSL.L #4,D7
002007FE                          1300m         
002007FE                          1301mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002007FE                          1302mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007FE                          1303mm 
002007FE  1639 00C00003           1304mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200804  0803 0000               1305mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200808  6700 0010               1306mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
0020080C                          1307mm  
0020080C                          1308mmm     READ_CHAR D2
0020080C                 TRUE     1309mmm     IFEQ DEBUG
0020080C  1439 00C00007           1310mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200812                          1311mmm     ENDC
00200812                 FALSE    1312mmm     IFNE DEBUG
00200812                          1313mmm     ENDC
00200812                          1314mmm      
00200812  B43C 001B               1315mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200816  6700 F7F0               1316mmm     BEQ START
0020081A                          1317mmm     ENDM
0020081A                          1318mm CONTINUE_82
0020081A  1639 00C00013           1319mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200820  0803 0000               1320mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200824  67D8                    1321mm     BEQ WAIT_FOR_READY_82                       ; NOTHING, CHECK AGAIN
00200826                          1322mm     
00200826  1439 00C00017           1323mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020082C  13C2 00E00001           1324mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200832                          1325mm     
00200832                          1326mm     ENDM
00200832                          1327mm     PRINT_CHAR D2,D3
00200832                          1328mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200832                 TRUE     1329mm     IFEQ DEBUG
00200832  1639 00C00003           1330mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200838  0803 0002               1331mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020083C  67F4                    1332mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
0020083E  13C2 00C00007           1333mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200844                          1334mm     ENDC
00200844                          1335mm     
00200844                 FALSE    1336mm     IFNE DEBUG
00200844                          1337mm     ENDC
00200844                          1338mm 
00200844                          1339mm     ENDM
00200844                          1340mm     HEX2BIN D2,D2,A0
00200844  41F9 002014EA           1341mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020084A  0402 0030               1342mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020084E  C4BC 000000FF           1343mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200854  1430 2000               1344mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200858                          1345mm     ENDM
00200858  8E02                    1346m     OR.B D2,D7    
0020085A                          1347m     ENDM
0020085A  DC87                    1348                  ADD.L D7,D6                     ; add into checksum
0020085C                          1349                          
0020085C  12C7                    1350                  MOVE.B D7,(A1)+                 ; store it!
0020085E                          1351  
0020085E  5385                    1352                  SUB.L #1,D5                     ; 1 less byte to go
00200860                          1353              ENDW
00200860  6000 FF32               1354s     BRA _10000000
00200864                          1355s _10000001
00200864                          1356          
00200864                          1357m             PRINT_CRLF D3
00200864                          1358mm     PRINT_CHAR #13,D3                           ; CR
00200864                          1359mm WAIT_FOR_READY_87                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200864                 TRUE     1360mm     IFEQ DEBUG
00200864  1639 00C00003           1361mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020086A  0803 0002               1362mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020086E  67F4                    1363mm         BEQ WAIT_FOR_READY_87                   ; NO SPACE, CHECK AGAIN
00200870  13FC 000D 00C00007      1364mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200878                          1365mm     ENDC
00200878                          1366mm     
00200878                 FALSE    1367mm     IFNE DEBUG
00200878                          1368mm     ENDC
00200878                          1369mm 
00200878                          1370mm     ENDM
00200878                          1371mm     PRINT_CHAR #10,D3                           ; LF
00200878                          1372mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200878                 TRUE     1373mm     IFEQ DEBUG
00200878  1639 00C00003           1374mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020087E  0803 0002               1375mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200882  67F4                    1376mm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00200884  13FC 000A 00C00007      1377mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020088C                          1378mm     ENDC
0020088C                          1379mm     
0020088C                 FALSE    1380mm     IFNE DEBUG
0020088C                          1381mm     ENDC
0020088C                          1382mm 
0020088C                          1383mm     ENDM
0020088C                          1384m     ENDM
0020088C  43F9 002004A0           1385              LEA WAIT_FOR_SRECORD,A1             ; next place to go
00200892                          1386        ELSE
00200892  6000 05E8               1387s     BRA _00000003
00200896                          1388s _00000002
00200896                          1389              IF.B D7 <EQ> #'2' THEN.L            ; 24 bit address data record
00200896  BE3C 0032               1390s     CMP.B   #'2',D7
0020089A  6600 0324               1391s     BNE.L   _00000004
0020089E  7E00                    1392                  MOVE.L #0,D7                    ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
002008A0                          1393m                 DOWNLOAD_BYTE D2,D7,D3,A0               
002008A0                          1394mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002008A0                          1395mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A0                          1396mm 
002008A0  1639 00C00003           1397mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002008A6  0803 0000               1398mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008AA  6700 0010               1399mm     BEQ CONTINUE_90                             ; NOTHING, CONTINUE
002008AE                          1400mm  
002008AE                          1401mmm     READ_CHAR D2
002008AE                 TRUE     1402mmm     IFEQ DEBUG
002008AE  1439 00C00007           1403mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008B4                          1404mmm     ENDC
002008B4                 FALSE    1405mmm     IFNE DEBUG
002008B4                          1406mmm     ENDC
002008B4                          1407mmm      
002008B4  B43C 001B               1408mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002008B8  6700 F74E               1409mmm     BEQ START
002008BC                          1410mmm     ENDM
002008BC                          1411mm CONTINUE_90
002008BC  1639 00C00013           1412mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002008C2  0803 0000               1413mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002008C6  67D8                    1414mm     BEQ WAIT_FOR_READY_90                       ; NOTHING, CHECK AGAIN
002008C8                          1415mm     
002008C8  1439 00C00017           1416mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008CE  13C2 00E00001           1417mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008D4                          1418mm     
002008D4                          1419mm     ENDM
002008D4                          1420mm     PRINT_CHAR D2,D3
002008D4                          1421mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008D4                 TRUE     1422mm     IFEQ DEBUG
002008D4  1639 00C00003           1423mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008DA  0803 0002               1424mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008DE  67F4                    1425mm         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
002008E0  13C2 00C00007           1426mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008E6                          1427mm     ENDC
002008E6                          1428mm     
002008E6                 FALSE    1429mm     IFNE DEBUG
002008E6                          1430mm     ENDC
002008E6                          1431mm 
002008E6                          1432mm     ENDM
002008E6                          1433mm     HEX2BIN D2,D2,A0
002008E6  41F9 002014EA           1434mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008EC  0402 0030               1435mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008F0  C4BC 000000FF           1436mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008F6  1430 2000               1437mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008FA                          1438mm     ENDM
002008FA  8E02                    1439m     OR.B D2,D7
002008FC  E98F                    1440m     LSL.L #4,D7
002008FE                          1441m         
002008FE                          1442mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002008FE                          1443mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008FE                          1444mm 
002008FE  1639 00C00003           1445mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200904  0803 0000               1446mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200908  6700 0010               1447mm     BEQ CONTINUE_94                             ; NOTHING, CONTINUE
0020090C                          1448mm  
0020090C                          1449mmm     READ_CHAR D2
0020090C                 TRUE     1450mmm     IFEQ DEBUG
0020090C  1439 00C00007           1451mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200912                          1452mmm     ENDC
00200912                 FALSE    1453mmm     IFNE DEBUG
00200912                          1454mmm     ENDC
00200912                          1455mmm      
00200912  B43C 001B               1456mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200916  6700 F6F0               1457mmm     BEQ START
0020091A                          1458mmm     ENDM
0020091A                          1459mm CONTINUE_94
0020091A  1639 00C00013           1460mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200920  0803 0000               1461mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200924  67D8                    1462mm     BEQ WAIT_FOR_READY_94                       ; NOTHING, CHECK AGAIN
00200926                          1463mm     
00200926  1439 00C00017           1464mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020092C  13C2 00E00001           1465mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200932                          1466mm     
00200932                          1467mm     ENDM
00200932                          1468mm     PRINT_CHAR D2,D3
00200932                          1469mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200932                 TRUE     1470mm     IFEQ DEBUG
00200932  1639 00C00003           1471mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200938  0803 0002               1472mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020093C  67F4                    1473mm         BEQ WAIT_FOR_READY_96                   ; NO SPACE, CHECK AGAIN
0020093E  13C2 00C00007           1474mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200944                          1475mm     ENDC
00200944                          1476mm     
00200944                 FALSE    1477mm     IFNE DEBUG
00200944                          1478mm     ENDC
00200944                          1479mm 
00200944                          1480mm     ENDM
00200944                          1481mm     HEX2BIN D2,D2,A0
00200944  41F9 002014EA           1482mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020094A  0402 0030               1483mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020094E  C4BC 000000FF           1484mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200954  1430 2000               1485mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200958                          1486mm     ENDM
00200958  8E02                    1487m     OR.B D2,D7    
0020095A                          1488m     ENDM
0020095A  DC87                    1489                  ADD.L D7,D6                     ; add into checksum
0020095C                          1490  
0020095C  E98F                    1491                  LSL.L #4,D7                     ; middle byte
0020095E                          1492m                 DOWNLOAD_BYTE D2,D7,D3,A0               
0020095E                          1493mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
0020095E                          1494mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020095E                          1495mm 
0020095E  1639 00C00003           1496mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200964  0803 0000               1497mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200968  6700 0010               1498mm     BEQ CONTINUE_99                             ; NOTHING, CONTINUE
0020096C                          1499mm  
0020096C                          1500mmm     READ_CHAR D2
0020096C                 TRUE     1501mmm     IFEQ DEBUG
0020096C  1439 00C00007           1502mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200972                          1503mmm     ENDC
00200972                 FALSE    1504mmm     IFNE DEBUG
00200972                          1505mmm     ENDC
00200972                          1506mmm      
00200972  B43C 001B               1507mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200976  6700 F690               1508mmm     BEQ START
0020097A                          1509mmm     ENDM
0020097A                          1510mm CONTINUE_99
0020097A  1639 00C00013           1511mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200980  0803 0000               1512mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200984  67D8                    1513mm     BEQ WAIT_FOR_READY_99                       ; NOTHING, CHECK AGAIN
00200986                          1514mm     
00200986  1439 00C00017           1515mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020098C  13C2 00E00001           1516mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200992                          1517mm     
00200992                          1518mm     ENDM
00200992                          1519mm     PRINT_CHAR D2,D3
00200992                          1520mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200992                 TRUE     1521mm     IFEQ DEBUG
00200992  1639 00C00003           1522mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200998  0803 0002               1523mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020099C  67F4                    1524mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0020099E  13C2 00C00007           1525mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A4                          1526mm     ENDC
002009A4                          1527mm     
002009A4                 FALSE    1528mm     IFNE DEBUG
002009A4                          1529mm     ENDC
002009A4                          1530mm 
002009A4                          1531mm     ENDM
002009A4                          1532mm     HEX2BIN D2,D2,A0
002009A4  41F9 002014EA           1533mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002009AA  0402 0030               1534mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002009AE  C4BC 000000FF           1535mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002009B4  1430 2000               1536mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002009B8                          1537mm     ENDM
002009B8  8E02                    1538m     OR.B D2,D7
002009BA  E98F                    1539m     LSL.L #4,D7
002009BC                          1540m         
002009BC                          1541mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
002009BC                          1542mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BC                          1543mm 
002009BC  1639 00C00003           1544mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
002009C2  0803 0000               1545mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009C6  6700 0010               1546mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
002009CA                          1547mm  
002009CA                          1548mmm     READ_CHAR D2
002009CA                 TRUE     1549mmm     IFEQ DEBUG
002009CA  1439 00C00007           1550mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002009D0                          1551mmm     ENDC
002009D0                 FALSE    1552mmm     IFNE DEBUG
002009D0                          1553mmm     ENDC
002009D0                          1554mmm      
002009D0  B43C 001B               1555mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002009D4  6700 F632               1556mmm     BEQ START
002009D8                          1557mmm     ENDM
002009D8                          1558mm CONTINUE_103
002009D8  1639 00C00013           1559mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
002009DE  0803 0000               1560mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
002009E2  67D8                    1561mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
002009E4                          1562mm     
002009E4  1439 00C00017           1563mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002009EA  13C2 00E00001           1564mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002009F0                          1565mm     
002009F0                          1566mm     ENDM
002009F0                          1567mm     PRINT_CHAR D2,D3
002009F0                          1568mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009F0                 TRUE     1569mm     IFEQ DEBUG
002009F0  1639 00C00003           1570mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009F6  0803 0002               1571mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009FA  67F4                    1572mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
002009FC  13C2 00C00007           1573mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A02                          1574mm     ENDC
00200A02                          1575mm     
00200A02                 FALSE    1576mm     IFNE DEBUG
00200A02                          1577mm     ENDC
00200A02                          1578mm 
00200A02                          1579mm     ENDM
00200A02                          1580mm     HEX2BIN D2,D2,A0
00200A02  41F9 002014EA           1581mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A08  0402 0030               1582mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A0C  C4BC 000000FF           1583mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A12  1430 2000               1584mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A16                          1585mm     ENDM
00200A16  8E02                    1586m     OR.B D2,D7    
00200A18                          1587m     ENDM
00200A18  7400                    1588                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
00200A1A  1407                    1589                  MOVE.B D7,D2
00200A1C  DC82                    1590                  ADD.L D2,D6
00200A1E                          1591            
00200A1E  E98F                    1592                  LSL.L #4,D7                     ; bottom byte
00200A20                          1593m                 DOWNLOAD_BYTE D2,D7,D3,A0                       
00200A20                          1594mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200A20                          1595mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A20                          1596mm 
00200A20  1639 00C00003           1597mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200A26  0803 0000               1598mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A2A  6700 0010               1599mm     BEQ CONTINUE_108                                ; NOTHING, CONTINUE
00200A2E                          1600mm  
00200A2E                          1601mmm     READ_CHAR D2
00200A2E                 TRUE     1602mmm     IFEQ DEBUG
00200A2E  1439 00C00007           1603mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A34                          1604mmm     ENDC
00200A34                 FALSE    1605mmm     IFNE DEBUG
00200A34                          1606mmm     ENDC
00200A34                          1607mmm      
00200A34  B43C 001B               1608mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A38  6700 F5CE               1609mmm     BEQ START
00200A3C                          1610mmm     ENDM
00200A3C                          1611mm CONTINUE_108
00200A3C  1639 00C00013           1612mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200A42  0803 0000               1613mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A46  67D8                    1614mm     BEQ WAIT_FOR_READY_108                      ; NOTHING, CHECK AGAIN
00200A48                          1615mm     
00200A48  1439 00C00017           1616mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A4E  13C2 00E00001           1617mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A54                          1618mm     
00200A54                          1619mm     ENDM
00200A54                          1620mm     PRINT_CHAR D2,D3
00200A54                          1621mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A54                 TRUE     1622mm     IFEQ DEBUG
00200A54  1639 00C00003           1623mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A5A  0803 0002               1624mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A5E  67F4                    1625mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00200A60  13C2 00C00007           1626mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A66                          1627mm     ENDC
00200A66                          1628mm     
00200A66                 FALSE    1629mm     IFNE DEBUG
00200A66                          1630mm     ENDC
00200A66                          1631mm 
00200A66                          1632mm     ENDM
00200A66                          1633mm     HEX2BIN D2,D2,A0
00200A66  41F9 002014EA           1634mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A6C  0402 0030               1635mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A70  C4BC 000000FF           1636mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A76  1430 2000               1637mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A7A                          1638mm     ENDM
00200A7A  8E02                    1639m     OR.B D2,D7
00200A7C  E98F                    1640m     LSL.L #4,D7
00200A7E                          1641m         
00200A7E                          1642mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200A7E                          1643mm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A7E                          1644mm 
00200A7E  1639 00C00003           1645mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200A84  0803 0000               1646mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200A88  6700 0010               1647mm     BEQ CONTINUE_112                                ; NOTHING, CONTINUE
00200A8C                          1648mm  
00200A8C                          1649mmm     READ_CHAR D2
00200A8C                 TRUE     1650mmm     IFEQ DEBUG
00200A8C  1439 00C00007           1651mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A92                          1652mmm     ENDC
00200A92                 FALSE    1653mmm     IFNE DEBUG
00200A92                          1654mmm     ENDC
00200A92                          1655mmm      
00200A92  B43C 001B               1656mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A96  6700 F570               1657mmm     BEQ START
00200A9A                          1658mmm     ENDM
00200A9A                          1659mm CONTINUE_112
00200A9A  1639 00C00013           1660mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200AA0  0803 0000               1661mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AA4  67D8                    1662mm     BEQ WAIT_FOR_READY_112                      ; NOTHING, CHECK AGAIN
00200AA6                          1663mm     
00200AA6  1439 00C00017           1664mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200AAC  13C2 00E00001           1665mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200AB2                          1666mm     
00200AB2                          1667mm     ENDM
00200AB2                          1668mm     PRINT_CHAR D2,D3
00200AB2                          1669mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB2                 TRUE     1670mm     IFEQ DEBUG
00200AB2  1639 00C00003           1671mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AB8  0803 0002               1672mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200ABC  67F4                    1673mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200ABE  13C2 00C00007           1674mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AC4                          1675mm     ENDC
00200AC4                          1676mm     
00200AC4                 FALSE    1677mm     IFNE DEBUG
00200AC4                          1678mm     ENDC
00200AC4                          1679mm 
00200AC4                          1680mm     ENDM
00200AC4                          1681mm     HEX2BIN D2,D2,A0
00200AC4  41F9 002014EA           1682mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ACA  0402 0030               1683mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200ACE  C4BC 000000FF           1684mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200AD4  1430 2000               1685mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200AD8                          1686mm     ENDM
00200AD8  8E02                    1687m     OR.B D2,D7    
00200ADA                          1688m     ENDM
00200ADA  7400                    1689                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
00200ADC  1407                    1690                  MOVE.B D7,D2
00200ADE  DC82                    1691                  ADD.L D2,D6
00200AE0                          1692                  
00200AE0  2247                    1693                  MOVE.L D7,A1                    ; put the address in an address register, and we can now re-use D7
00200AE2  D3CB                    1694                  ADD.L A3,A1                     ; add in the offset
00200AE4                          1695          
00200AE4  5985                    1696                  SUB.L #4,D5                     ; subtract four bytes for 24 bit address and 1 byte checksum
00200AE6                          1697                  WHILE.L D5 <GT> #0 DO           ; read the data bytes                   
00200AE6                          1698s _10000002
00200AE6  BABC 00000000           1699s     CMP.L   #0,D5
00200AEC  6F00 00C8               1700s     BLE _10000003
00200AF0  7E00                    1701                      MOVE.L #0,D7                ; D7 holds the byte
00200AF2                          1702m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                        
00200AF2                          1703mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200AF2                          1704mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF2                          1705mm 
00200AF2  1639 00C00003           1706mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200AF8  0803 0000               1707mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200AFC  6700 0010               1708mm     BEQ CONTINUE_117                                ; NOTHING, CONTINUE
00200B00                          1709mm  
00200B00                          1710mmm     READ_CHAR D2
00200B00                 TRUE     1711mmm     IFEQ DEBUG
00200B00  1439 00C00007           1712mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B06                          1713mmm     ENDC
00200B06                 FALSE    1714mmm     IFNE DEBUG
00200B06                          1715mmm     ENDC
00200B06                          1716mmm      
00200B06  B43C 001B               1717mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B0A  6700 F4FC               1718mmm     BEQ START
00200B0E                          1719mmm     ENDM
00200B0E                          1720mm CONTINUE_117
00200B0E  1639 00C00013           1721mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B14  0803 0000               1722mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B18  67D8                    1723mm     BEQ WAIT_FOR_READY_117                      ; NOTHING, CHECK AGAIN
00200B1A                          1724mm     
00200B1A  1439 00C00017           1725mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B20  13C2 00E00001           1726mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B26                          1727mm     
00200B26                          1728mm     ENDM
00200B26                          1729mm     PRINT_CHAR D2,D3
00200B26                          1730mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B26                 TRUE     1731mm     IFEQ DEBUG
00200B26  1639 00C00003           1732mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B2C  0803 0002               1733mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B30  67F4                    1734mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B32  13C2 00C00007           1735mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B38                          1736mm     ENDC
00200B38                          1737mm     
00200B38                 FALSE    1738mm     IFNE DEBUG
00200B38                          1739mm     ENDC
00200B38                          1740mm 
00200B38                          1741mm     ENDM
00200B38                          1742mm     HEX2BIN D2,D2,A0
00200B38  41F9 002014EA           1743mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B3E  0402 0030               1744mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200B42  C4BC 000000FF           1745mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200B48  1430 2000               1746mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200B4C                          1747mm     ENDM
00200B4C  8E02                    1748m     OR.B D2,D7
00200B4E  E98F                    1749m     LSL.L #4,D7
00200B50                          1750m         
00200B50                          1751mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200B50                          1752mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B50                          1753mm 
00200B50  1639 00C00003           1754mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200B56  0803 0000               1755mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B5A  6700 0010               1756mm     BEQ CONTINUE_121                                ; NOTHING, CONTINUE
00200B5E                          1757mm  
00200B5E                          1758mmm     READ_CHAR D2
00200B5E                 TRUE     1759mmm     IFEQ DEBUG
00200B5E  1439 00C00007           1760mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200B64                          1761mmm     ENDC
00200B64                 FALSE    1762mmm     IFNE DEBUG
00200B64                          1763mmm     ENDC
00200B64                          1764mmm      
00200B64  B43C 001B               1765mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200B68  6700 F49E               1766mmm     BEQ START
00200B6C                          1767mmm     ENDM
00200B6C                          1768mm CONTINUE_121
00200B6C  1639 00C00013           1769mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200B72  0803 0000               1770mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200B76  67D8                    1771mm     BEQ WAIT_FOR_READY_121                      ; NOTHING, CHECK AGAIN
00200B78                          1772mm     
00200B78  1439 00C00017           1773mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200B7E  13C2 00E00001           1774mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200B84                          1775mm     
00200B84                          1776mm     ENDM
00200B84                          1777mm     PRINT_CHAR D2,D3
00200B84                          1778mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B84                 TRUE     1779mm     IFEQ DEBUG
00200B84  1639 00C00003           1780mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B8A  0803 0002               1781mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B8E  67F4                    1782mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00200B90  13C2 00C00007           1783mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B96                          1784mm     ENDC
00200B96                          1785mm     
00200B96                 FALSE    1786mm     IFNE DEBUG
00200B96                          1787mm     ENDC
00200B96                          1788mm 
00200B96                          1789mm     ENDM
00200B96                          1790mm     HEX2BIN D2,D2,A0
00200B96  41F9 002014EA           1791mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B9C  0402 0030               1792mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200BA0  C4BC 000000FF           1793mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200BA6  1430 2000               1794mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200BAA                          1795mm     ENDM
00200BAA  8E02                    1796m     OR.B D2,D7    
00200BAC                          1797m     ENDM
00200BAC  DC87                    1798                      ADD.L D7,D6                 ; add into checksum
00200BAE                          1799                      
00200BAE  12C7                    1800                      MOVE.B D7,(A1)+             ; store it!
00200BB0                          1801  
00200BB0  5385                    1802                      SUB.L #1,D5                 ; 1 less byte to go
00200BB2                          1803                  ENDW
00200BB2  6000 FF32               1804s     BRA _10000002
00200BB6                          1805s _10000003
00200BB6                          1806              
00200BB6  43F9 002004A0           1807                  LEA WAIT_FOR_SRECORD,A1         ; next place to go
00200BBC                          1808              ELSE
00200BBC  6000 02BE               1809s     BRA _00000005
00200BC0                          1810s _00000004
00200BC0                          1811                  IF.B D7 <EQ> #'8' THEN.L        ; termination record, exit
00200BC0  BE3C 0038               1812s     CMP.B   #'8',D7
00200BC4  6600 0250               1813s     BNE.L   _00000006
00200BC8  7E00                    1814                      MOVE.L #0,D7                ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
00200BCA                          1815m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00200BCA                          1816mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200BCA                          1817mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BCA                          1818mm 
00200BCA  1639 00C00003           1819mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200BD0  0803 0000               1820mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200BD4  6700 0010               1821mm     BEQ CONTINUE_126                                ; NOTHING, CONTINUE
00200BD8                          1822mm  
00200BD8                          1823mmm     READ_CHAR D2
00200BD8                 TRUE     1824mmm     IFEQ DEBUG
00200BD8  1439 00C00007           1825mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200BDE                          1826mmm     ENDC
00200BDE                 FALSE    1827mmm     IFNE DEBUG
00200BDE                          1828mmm     ENDC
00200BDE                          1829mmm      
00200BDE  B43C 001B               1830mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200BE2  6700 F424               1831mmm     BEQ START
00200BE6                          1832mmm     ENDM
00200BE6                          1833mm CONTINUE_126
00200BE6  1639 00C00013           1834mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200BEC  0803 0000               1835mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200BF0  67D8                    1836mm     BEQ WAIT_FOR_READY_126                      ; NOTHING, CHECK AGAIN
00200BF2                          1837mm     
00200BF2  1439 00C00017           1838mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200BF8  13C2 00E00001           1839mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200BFE                          1840mm     
00200BFE                          1841mm     ENDM
00200BFE                          1842mm     PRINT_CHAR D2,D3
00200BFE                          1843mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1844mm     IFEQ DEBUG
00200BFE  1639 00C00003           1845mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C04  0803 0002               1846mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1847mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200C0A  13C2 00C00007           1848mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C10                          1849mm     ENDC
00200C10                          1850mm     
00200C10                 FALSE    1851mm     IFNE DEBUG
00200C10                          1852mm     ENDC
00200C10                          1853mm 
00200C10                          1854mm     ENDM
00200C10                          1855mm     HEX2BIN D2,D2,A0
00200C10  41F9 002014EA           1856mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C16  0402 0030               1857mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C1A  C4BC 000000FF           1858mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C20  1430 2000               1859mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C24                          1860mm     ENDM
00200C24  8E02                    1861m     OR.B D2,D7
00200C26  E98F                    1862m     LSL.L #4,D7
00200C28                          1863m         
00200C28                          1864mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200C28                          1865mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C28                          1866mm 
00200C28  1639 00C00003           1867mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200C2E  0803 0000               1868mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C32  6700 0010               1869mm     BEQ CONTINUE_130                                ; NOTHING, CONTINUE
00200C36                          1870mm  
00200C36                          1871mmm     READ_CHAR D2
00200C36                 TRUE     1872mmm     IFEQ DEBUG
00200C36  1439 00C00007           1873mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C3C                          1874mmm     ENDC
00200C3C                 FALSE    1875mmm     IFNE DEBUG
00200C3C                          1876mmm     ENDC
00200C3C                          1877mmm      
00200C3C  B43C 001B               1878mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200C40  6700 F3C6               1879mmm     BEQ START
00200C44                          1880mmm     ENDM
00200C44                          1881mm CONTINUE_130
00200C44  1639 00C00013           1882mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200C4A  0803 0000               1883mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C4E  67D8                    1884mm     BEQ WAIT_FOR_READY_130                      ; NOTHING, CHECK AGAIN
00200C50                          1885mm     
00200C50  1439 00C00017           1886mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200C56  13C2 00E00001           1887mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200C5C                          1888mm     
00200C5C                          1889mm     ENDM
00200C5C                          1890mm     PRINT_CHAR D2,D3
00200C5C                          1891mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C5C                 TRUE     1892mm     IFEQ DEBUG
00200C5C  1639 00C00003           1893mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C62  0803 0002               1894mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C66  67F4                    1895mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00200C68  13C2 00C00007           1896mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C6E                          1897mm     ENDC
00200C6E                          1898mm     
00200C6E                 FALSE    1899mm     IFNE DEBUG
00200C6E                          1900mm     ENDC
00200C6E                          1901mm 
00200C6E                          1902mm     ENDM
00200C6E                          1903mm     HEX2BIN D2,D2,A0
00200C6E  41F9 002014EA           1904mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200C74  0402 0030               1905mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C78  C4BC 000000FF           1906mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200C7E  1430 2000               1907mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200C82                          1908mm     ENDM
00200C82  8E02                    1909m     OR.B D2,D7    
00200C84                          1910m     ENDM
00200C84  DC87                    1911                      ADD.L D7,D6                 ; add top byte of address into checksum
00200C86                          1912  
00200C86  E98F                    1913                      LSL.L #4,D7                 ; middle byte
00200C88                          1914m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte             
00200C88                          1915mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200C88                          1916mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C88                          1917mm 
00200C88  1639 00C00003           1918mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200C8E  0803 0000               1919mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200C92  6700 0010               1920mm     BEQ CONTINUE_135                                ; NOTHING, CONTINUE
00200C96                          1921mm  
00200C96                          1922mmm     READ_CHAR D2
00200C96                 TRUE     1923mmm     IFEQ DEBUG
00200C96  1439 00C00007           1924mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200C9C                          1925mmm     ENDC
00200C9C                 FALSE    1926mmm     IFNE DEBUG
00200C9C                          1927mmm     ENDC
00200C9C                          1928mmm      
00200C9C  B43C 001B               1929mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CA0  6700 F366               1930mmm     BEQ START
00200CA4                          1931mmm     ENDM
00200CA4                          1932mm CONTINUE_135
00200CA4  1639 00C00013           1933mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200CAA  0803 0000               1934mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200CAE  67D8                    1935mm     BEQ WAIT_FOR_READY_135                      ; NOTHING, CHECK AGAIN
00200CB0                          1936mm     
00200CB0  1439 00C00017           1937mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200CB6  13C2 00E00001           1938mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200CBC                          1939mm     
00200CBC                          1940mm     ENDM
00200CBC                          1941mm     PRINT_CHAR D2,D3
00200CBC                          1942mm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBC                 TRUE     1943mm     IFEQ DEBUG
00200CBC  1639 00C00003           1944mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CC2  0803 0002               1945mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC6  67F4                    1946mm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00200CC8  13C2 00C00007           1947mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CCE                          1948mm     ENDC
00200CCE                          1949mm     
00200CCE                 FALSE    1950mm     IFNE DEBUG
00200CCE                          1951mm     ENDC
00200CCE                          1952mm 
00200CCE                          1953mm     ENDM
00200CCE                          1954mm     HEX2BIN D2,D2,A0
00200CCE  41F9 002014EA           1955mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200CD4  0402 0030               1956mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200CD8  C4BC 000000FF           1957mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200CDE  1430 2000               1958mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200CE2                          1959mm     ENDM
00200CE2  8E02                    1960m     OR.B D2,D7
00200CE4  E98F                    1961m     LSL.L #4,D7
00200CE6                          1962m         
00200CE6                          1963mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200CE6                          1964mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CE6                          1965mm 
00200CE6  1639 00C00003           1966mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200CEC  0803 0000               1967mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200CF0  6700 0010               1968mm     BEQ CONTINUE_139                                ; NOTHING, CONTINUE
00200CF4                          1969mm  
00200CF4                          1970mmm     READ_CHAR D2
00200CF4                 TRUE     1971mmm     IFEQ DEBUG
00200CF4  1439 00C00007           1972mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200CFA                          1973mmm     ENDC
00200CFA                 FALSE    1974mmm     IFNE DEBUG
00200CFA                          1975mmm     ENDC
00200CFA                          1976mmm      
00200CFA  B43C 001B               1977mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CFE  6700 F308               1978mmm     BEQ START
00200D02                          1979mmm     ENDM
00200D02                          1980mm CONTINUE_139
00200D02  1639 00C00013           1981mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D08  0803 0000               1982mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D0C  67D8                    1983mm     BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00200D0E                          1984mm     
00200D0E  1439 00C00017           1985mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D14  13C2 00E00001           1986mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D1A                          1987mm     
00200D1A                          1988mm     ENDM
00200D1A                          1989mm     PRINT_CHAR D2,D3
00200D1A                          1990mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D1A                 TRUE     1991mm     IFEQ DEBUG
00200D1A  1639 00C00003           1992mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D20  0803 0002               1993mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D24  67F4                    1994mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200D26  13C2 00C00007           1995mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D2C                          1996mm     ENDC
00200D2C                          1997mm     
00200D2C                 FALSE    1998mm     IFNE DEBUG
00200D2C                          1999mm     ENDC
00200D2C                          2000mm 
00200D2C                          2001mm     ENDM
00200D2C                          2002mm     HEX2BIN D2,D2,A0
00200D2C  41F9 002014EA           2003mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D32  0402 0030               2004mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D36  C4BC 000000FF           2005mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D3C  1430 2000               2006mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D40                          2007mm     ENDM
00200D40  8E02                    2008m     OR.B D2,D7    
00200D42                          2009m     ENDM
00200D42  7400                    2010                      MOVE.L #0,D2                ; rextract middle byte of address and add into checksum
00200D44  1407                    2011                      MOVE.B D7,D2
00200D46  DC82                    2012                      ADD.L D2,D6
00200D48                          2013                    
00200D48  E98F                    2014                      LSL.L #4,D7                 ; bottom byte
00200D4A                          2015m                     DOWNLOAD_BYTE D2,D7,D3,A0   ; read byte                             
00200D4A                          2016mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200D4A                          2017mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D4A                          2018mm 
00200D4A  1639 00C00003           2019mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200D50  0803 0000               2020mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D54  6700 0010               2021mm     BEQ CONTINUE_144                                ; NOTHING, CONTINUE
00200D58                          2022mm  
00200D58                          2023mmm     READ_CHAR D2
00200D58                 TRUE     2024mmm     IFEQ DEBUG
00200D58  1439 00C00007           2025mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D5E                          2026mmm     ENDC
00200D5E                 FALSE    2027mmm     IFNE DEBUG
00200D5E                          2028mmm     ENDC
00200D5E                          2029mmm      
00200D5E  B43C 001B               2030mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D62  6700 F2A4               2031mmm     BEQ START
00200D66                          2032mmm     ENDM
00200D66                          2033mm CONTINUE_144
00200D66  1639 00C00013           2034mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200D6C  0803 0000               2035mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200D70  67D8                    2036mm     BEQ WAIT_FOR_READY_144                      ; NOTHING, CHECK AGAIN
00200D72                          2037mm     
00200D72  1439 00C00017           2038mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200D78  13C2 00E00001           2039mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200D7E                          2040mm     
00200D7E                          2041mm     ENDM
00200D7E                          2042mm     PRINT_CHAR D2,D3
00200D7E                          2043mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D7E                 TRUE     2044mm     IFEQ DEBUG
00200D7E  1639 00C00003           2045mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D84  0803 0002               2046mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D88  67F4                    2047mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00200D8A  13C2 00C00007           2048mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D90                          2049mm     ENDC
00200D90                          2050mm     
00200D90                 FALSE    2051mm     IFNE DEBUG
00200D90                          2052mm     ENDC
00200D90                          2053mm 
00200D90                          2054mm     ENDM
00200D90                          2055mm     HEX2BIN D2,D2,A0
00200D90  41F9 002014EA           2056mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D96  0402 0030               2057mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D9A  C4BC 000000FF           2058mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DA0  1430 2000               2059mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DA4                          2060mm     ENDM
00200DA4  8E02                    2061m     OR.B D2,D7
00200DA6  E98F                    2062m     LSL.L #4,D7
00200DA8                          2063m         
00200DA8                          2064mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200DA8                          2065mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DA8                          2066mm 
00200DA8  1639 00C00003           2067mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200DAE  0803 0000               2068mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DB2  6700 0010               2069mm     BEQ CONTINUE_148                                ; NOTHING, CONTINUE
00200DB6                          2070mm  
00200DB6                          2071mmm     READ_CHAR D2
00200DB6                 TRUE     2072mmm     IFEQ DEBUG
00200DB6  1439 00C00007           2073mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DBC                          2074mmm     ENDC
00200DBC                 FALSE    2075mmm     IFNE DEBUG
00200DBC                          2076mmm     ENDC
00200DBC                          2077mmm      
00200DBC  B43C 001B               2078mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DC0  6700 F246               2079mmm     BEQ START
00200DC4                          2080mmm     ENDM
00200DC4                          2081mm CONTINUE_148
00200DC4  1639 00C00013           2082mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200DCA  0803 0000               2083mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200DCE  67D8                    2084mm     BEQ WAIT_FOR_READY_148                      ; NOTHING, CHECK AGAIN
00200DD0                          2085mm     
00200DD0  1439 00C00017           2086mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200DD6  13C2 00E00001           2087mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200DDC                          2088mm     
00200DDC                          2089mm     ENDM
00200DDC                          2090mm     PRINT_CHAR D2,D3
00200DDC                          2091mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DDC                 TRUE     2092mm     IFEQ DEBUG
00200DDC  1639 00C00003           2093mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DE2  0803 0002               2094mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DE6  67F4                    2095mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00200DE8  13C2 00C00007           2096mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DEE                          2097mm     ENDC
00200DEE                          2098mm     
00200DEE                 FALSE    2099mm     IFNE DEBUG
00200DEE                          2100mm     ENDC
00200DEE                          2101mm 
00200DEE                          2102mm     ENDM
00200DEE                          2103mm     HEX2BIN D2,D2,A0
00200DEE  41F9 002014EA           2104mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DF4  0402 0030               2105mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DF8  C4BC 000000FF           2106mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DFE  1430 2000               2107mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200E02                          2108mm     ENDM
00200E02  8E02                    2109m     OR.B D2,D7    
00200E04                          2110m     ENDM
00200E04  7400                    2111                      MOVE.L #0,D2                ; rextract bottom byte of address and add into checksum
00200E06  1407                    2112                      MOVE.B D7,D2
00200E08  DC82                    2113                      ADD.L D2,D6
00200E0A                          2114                    
00200E0A  2447                    2115                      MOVE.L D7,A2                ; start address -> A2
00200E0C                          2116                      
00200E0C  43F9 00201018           2117                      LEA DOWNLOAD_DONE,A1        ; next place to go
00200E12                          2118                  ELSE
00200E12  6000 0068               2119s     BRA _00000007
00200E16                          2120s _00000006
00200E16  41F9 0020149F           2121                      LEA UNREC,A0                ; warn for unrecognised type
00200E1C                          2122m                     PRINT_STR A0,D3
00200E1C                          2123m LOOP_152
00200E1C  0C10 0000               2124m     CMP.B #0,(A0)                               ; 0 -> DONE
00200E20  6700 001A               2125m     BEQ EXIT_152
00200E24                          2126mm     PRINT_CHAR (A0)+,D3
00200E24                          2127mm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E24                 TRUE     2128mm     IFEQ DEBUG
00200E24  1639 00C00003           2129mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E2A  0803 0002               2130mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E2E  67F4                    2131mm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00200E30  13D8 00C00007           2132mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200E36                          2133mm     ENDC
00200E36                          2134mm     
00200E36                 FALSE    2135mm     IFNE DEBUG
00200E36                          2136mm     ENDC
00200E36                          2137mm 
00200E36                          2138mm     ENDM
00200E36  4EF9 00200E1C           2139m     JMP LOOP_152
00200E3C                          2140m EXIT_152
00200E3C                          2141m     ENDM
00200E3C                          2142m                     PRINT_CHAR D7,D3
00200E3C                          2143m WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E3C                 TRUE     2144m     IFEQ DEBUG
00200E3C  1639 00C00003           2145m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E42  0803 0002               2146m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E46  67F4                    2147m         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200E48  13C7 00C00007           2148m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200E4E                          2149m     ENDC
00200E4E                          2150m     
00200E4E                 FALSE    2151m     IFNE DEBUG
00200E4E                          2152m     ENDC
00200E4E                          2153m 
00200E4E                          2154m     ENDM
00200E4E                          2155m                     PRINT_CRLF D3
00200E4E                          2156mm     PRINT_CHAR #13,D3                           ; CR
00200E4E                          2157mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E4E                 TRUE     2158mm     IFEQ DEBUG
00200E4E  1639 00C00003           2159mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E54  0803 0002               2160mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E58  67F4                    2161mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00200E5A  13FC 000D 00C00007      2162mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E62                          2163mm     ENDC
00200E62                          2164mm     
00200E62                 FALSE    2165mm     IFNE DEBUG
00200E62                          2166mm     ENDC
00200E62                          2167mm 
00200E62                          2168mm     ENDM
00200E62                          2169mm     PRINT_CHAR #10,D3                           ; LF
00200E62                          2170mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E62                 TRUE     2171mm     IFEQ DEBUG
00200E62  1639 00C00003           2172mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E68  0803 0002               2173mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E6C  67F4                    2174mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200E6E  13FC 000A 00C00007      2175mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E76                          2176mm     ENDC
00200E76                          2177mm     
00200E76                 FALSE    2178mm     IFNE DEBUG
00200E76                          2179mm     ENDC
00200E76                          2180mm 
00200E76                          2181mm     ENDM
00200E76                          2182m     ENDM
00200E76                          2183              
00200E76  4EF9 002004A0           2184                      JMP WAIT_FOR_SRECORD        ; ignore any other type    
00200E7C                          2185                  ENDI
00200E7C                          2186s _00000007
00200E7C                          2187              ENDI
00200E7C                          2188s _00000005
00200E7C                          2189          ENDI
00200E7C                          2190s _00000003
00200E7C                          2191      ENDI
00200E7C                          2192s _00000001
00200E7C                          2193      
00200E7C  4686                    2194      NOT.L D6                                    ; ones complement the checksum
00200E7E  0286 000000FF           2195      ANDI.L #$FF,D6                              ; and take the LSByte
00200E84                          2196          
00200E84  7E00                    2197      MOVE.L #0,D7                                ; read the checksum from the data stream
00200E86                          2198m     DOWNLOAD_BYTE D2,D7,D3,A0                           
00200E86                          2199mm     DOWNLOAD D2,D3                              ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200E86                          2200mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E86                          2201mm 
00200E86  1639 00C00003           2202mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200E8C  0803 0000               2203mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200E90  6700 0010               2204mm     BEQ CONTINUE_159                                ; NOTHING, CONTINUE
00200E94                          2205mm  
00200E94                          2206mmm     READ_CHAR D2
00200E94                 TRUE     2207mmm     IFEQ DEBUG
00200E94  1439 00C00007           2208mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200E9A                          2209mmm     ENDC
00200E9A                 FALSE    2210mmm     IFNE DEBUG
00200E9A                          2211mmm     ENDC
00200E9A                          2212mmm      
00200E9A  B43C 001B               2213mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200E9E  6700 F168               2214mmm     BEQ START
00200EA2                          2215mmm     ENDM
00200EA2                          2216mm CONTINUE_159
00200EA2  1639 00C00013           2217mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200EA8  0803 0000               2218mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200EAC  67D8                    2219mm     BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00200EAE                          2220mm     
00200EAE  1439 00C00017           2221mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200EB4  13C2 00E00001           2222mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200EBA                          2223mm     
00200EBA                          2224mm     ENDM
00200EBA                          2225mm     PRINT_CHAR D2,D3
00200EBA                          2226mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EBA                 TRUE     2227mm     IFEQ DEBUG
00200EBA  1639 00C00003           2228mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200EC0  0803 0002               2229mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200EC4  67F4                    2230mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00200EC6  13C2 00C00007           2231mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200ECC                          2232mm     ENDC
00200ECC                          2233mm     
00200ECC                 FALSE    2234mm     IFNE DEBUG
00200ECC                          2235mm     ENDC
00200ECC                          2236mm 
00200ECC                          2237mm     ENDM
00200ECC                          2238mm     HEX2BIN D2,D2,A0
00200ECC  41F9 002014EA           2239mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ED2  0402 0030               2240mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200ED6  C4BC 000000FF           2241mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EDC  1430 2000               2242mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EE0                          2243mm     ENDM
00200EE0  8E02                    2244m     OR.B D2,D7
00200EE2  E98F                    2245m     LSL.L #4,D7
00200EE4                          2246m         
00200EE4                          2247mm     DOWNLOAD D2,D3                              ; NOW THE SECOND (LEAST SIGNIFICANT) CHAR, CONVERT TO BINARY
00200EE4                          2248mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200EE4                          2249mm 
00200EE4  1639 00C00003           2250mm     MOVE.B DUART_SRA,D3                         ; CHECK FOR COMMAND
00200EEA  0803 0000               2251mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200EEE  6700 0010               2252mm     BEQ CONTINUE_163                                ; NOTHING, CONTINUE
00200EF2                          2253mm  
00200EF2                          2254mmm     READ_CHAR D2
00200EF2                 TRUE     2255mmm     IFEQ DEBUG
00200EF2  1439 00C00007           2256mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200EF8                          2257mmm     ENDC
00200EF8                 FALSE    2258mmm     IFNE DEBUG
00200EF8                          2259mmm     ENDC
00200EF8                          2260mmm      
00200EF8  B43C 001B               2261mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200EFC  6700 F10A               2262mmm     BEQ START
00200F00                          2263mmm     ENDM
00200F00                          2264mm CONTINUE_163
00200F00  1639 00C00013           2265mm     MOVE.B DUART_SRB,D3                         ; READ STATUS REGISTER
00200F06  0803 0000               2266mm     BTST #0,D3                                  ; CHECK FOR CHARACTER
00200F0A  67D8                    2267mm     BEQ WAIT_FOR_READY_163                      ; NOTHING, CHECK AGAIN
00200F0C                          2268mm     
00200F0C  1439 00C00017           2269mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200F12  13C2 00E00001           2270mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200F18                          2271mm     
00200F18                          2272mm     ENDM
00200F18                          2273mm     PRINT_CHAR D2,D3
00200F18                          2274mm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F18                 TRUE     2275mm     IFEQ DEBUG
00200F18  1639 00C00003           2276mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F1E  0803 0002               2277mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F22  67F4                    2278mm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
00200F24  13C2 00C00007           2279mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200F2A                          2280mm     ENDC
00200F2A                          2281mm     
00200F2A                 FALSE    2282mm     IFNE DEBUG
00200F2A                          2283mm     ENDC
00200F2A                          2284mm 
00200F2A                          2285mm     ENDM
00200F2A                          2286mm     HEX2BIN D2,D2,A0
00200F2A  41F9 002014EA           2287mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200F30  0402 0030               2288mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200F34  C4BC 000000FF           2289mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200F3A  1430 2000               2290mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200F3E                          2291mm     ENDM
00200F3E  8E02                    2292m     OR.B D2,D7    
00200F40                          2293m     ENDM
00200F40                          2294m     PRINT_CRLF D3
00200F40                          2295mm     PRINT_CHAR #13,D3                           ; CR
00200F40                          2296mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F40                 TRUE     2297mm     IFEQ DEBUG
00200F40  1639 00C00003           2298mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F46  0803 0002               2299mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F4A  67F4                    2300mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00200F4C  13FC 000D 00C00007      2301mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200F54                          2302mm     ENDC
00200F54                          2303mm     
00200F54                 FALSE    2304mm     IFNE DEBUG
00200F54                          2305mm     ENDC
00200F54                          2306mm 
00200F54                          2307mm     ENDM
00200F54                          2308mm     PRINT_CHAR #10,D3                           ; LF
00200F54                          2309mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F54                 TRUE     2310mm     IFEQ DEBUG
00200F54  1639 00C00003           2311mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F5A  0803 0002               2312mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F5E  67F4                    2313mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00200F60  13FC 000A 00C00007      2314mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200F68                          2315mm     ENDC
00200F68                          2316mm     
00200F68                 FALSE    2317mm     IFNE DEBUG
00200F68                          2318mm     ENDC
00200F68                          2319mm 
00200F68                          2320mm     ENDM
00200F68                          2321m     ENDM
00200F68                          2322  
00200F68                          2323      IF.B D7 <NE> D6 THEN.L
00200F68  BE06                    2324s     CMP.B   D6,D7
00200F6A  6700 00AA               2325s     BEQ.L   _00000008
00200F6E  41F9 002014B6           2326          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00200F74                          2327m         PRINT_STR A0,D3
00200F74                          2328m LOOP_170
00200F74  0C10 0000               2329m     CMP.B #0,(A0)                               ; 0 -> DONE
00200F78  6700 001A               2330m     BEQ EXIT_170
00200F7C                          2331mm     PRINT_CHAR (A0)+,D3
00200F7C                          2332mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F7C                 TRUE     2333mm     IFEQ DEBUG
00200F7C  1639 00C00003           2334mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F82  0803 0002               2335mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F86  67F4                    2336mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00200F88  13D8 00C00007           2337mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200F8E                          2338mm     ENDC
00200F8E                          2339mm     
00200F8E                 FALSE    2340mm     IFNE DEBUG
00200F8E                          2341mm     ENDC
00200F8E                          2342mm 
00200F8E                          2343mm     ENDM
00200F8E  4EF9 00200F74           2344m     JMP LOOP_170
00200F94                          2345m EXIT_170
00200F94                          2346m     ENDM
00200F94                          2347m         PRINT_REG D4,D3,D6,D7,A0
00200F94                          2348mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200F94                          2349mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200F94                 TRUE     2350mm     IFEQ DEBUG
00200F94  1639 00C00003           2351mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200F9A  0803 0002               2352mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200F9E  67F4                    2353mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00200FA0  13FC 0030 00C00007      2354mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200FA8                          2355mm     ENDC
00200FA8                          2356mm     
00200FA8                 FALSE    2357mm     IFNE DEBUG
00200FA8                          2358mm     ENDC
00200FA8                          2359mm 
00200FA8                          2360mm     ENDM
00200FA8                          2361mm     PRINT_CHAR #'x',D3
00200FA8                          2362mm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FA8                 TRUE     2363mm     IFEQ DEBUG
00200FA8  1639 00C00003           2364mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FAE  0803 0002               2365mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FB2  67F4                    2366mm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00200FB4  13FC 0078 00C00007      2367mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200FBC                          2368mm     ENDC
00200FBC                          2369mm     
00200FBC                 FALSE    2370mm     IFNE DEBUG
00200FBC                          2371mm     ENDC
00200FBC                          2372mm 
00200FBC                          2373mm     ENDM
00200FBC  7E07                    2374m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200FBE                          2375m LOOP_172
00200FBE                          2376mm     BIN2HEX D4,D6,A0
00200FBE  41F9 002014DA           2377mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200FC4  E99C                    2378mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200FC6  1C04                    2379mm     MOVE.B D4,D6
00200FC8  0286 0000000F           2380mm     ANDI.L #$F,D6
00200FCE  1C30 6000               2381mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200FD2                          2382mm     ENDM
00200FD2                          2383mm     PRINT_CHAR D6,D3
00200FD2                          2384mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FD2                 TRUE     2385mm     IFEQ DEBUG
00200FD2  1639 00C00003           2386mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FD8  0803 0002               2387mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FDC  67F4                    2388mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00200FDE  13C6 00C00007           2389mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200FE4                          2390mm     ENDC
00200FE4                          2391mm     
00200FE4                 FALSE    2392mm     IFNE DEBUG
00200FE4                          2393mm     ENDC
00200FE4                          2394mm 
00200FE4                          2395mm     ENDM
00200FE4  57CF FFD8               2396m     DBEQ D7,LOOP_172
00200FE8                          2397m     ENDM
00200FE8                          2398m         PRINT_CRLF D3
00200FE8                          2399mm     PRINT_CHAR #13,D3                           ; CR
00200FE8                          2400mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FE8                 TRUE     2401mm     IFEQ DEBUG
00200FE8  1639 00C00003           2402mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200FEE  0803 0002               2403mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200FF2  67F4                    2404mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00200FF4  13FC 000D 00C00007      2405mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200FFC                          2406mm     ENDC
00200FFC                          2407mm     
00200FFC                 FALSE    2408mm     IFNE DEBUG
00200FFC                          2409mm     ENDC
00200FFC                          2410mm 
00200FFC                          2411mm     ENDM
00200FFC                          2412mm     PRINT_CHAR #10,D3                           ; LF
00200FFC                          2413mm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200FFC                 TRUE     2414mm     IFEQ DEBUG
00200FFC  1639 00C00003           2415mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201002  0803 0002               2416mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201006  67F4                    2417mm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00201008  13FC 000A 00C00007      2418mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201010                          2419mm     ENDC
00201010                          2420mm     
00201010                 FALSE    2421mm     IFNE DEBUG
00201010                          2422mm     ENDC
00201010                          2423mm 
00201010                          2424mm     ENDM
00201010                          2425m     ENDM
00201010  4EF9 00200188           2426          JMP MAIN_LOOP
00201016                          2427      ENDI
00201016                          2428s _00000008
00201016                          2429      
00201016  4ED1                    2430      JMP (A1)
00201018                          2431  DOWNLOAD_DONE
00201018                          2432m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00201018                          2433mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201018                          2434mm WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201018                 TRUE     2435mm     IFEQ DEBUG
00201018  1639 00C00003           2436mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020101E  0803 0002               2437mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201022  67F4                    2438mm         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
00201024  13FC 0030 00C00007      2439mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020102C                          2440mm     ENDC
0020102C                          2441mm     
0020102C                 FALSE    2442mm     IFNE DEBUG
0020102C                          2443mm     ENDC
0020102C                          2444mm 
0020102C                          2445mm     ENDM
0020102C                          2446mm     PRINT_CHAR #'x',D3
0020102C                          2447mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020102C                 TRUE     2448mm     IFEQ DEBUG
0020102C  1639 00C00003           2449mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201032  0803 0002               2450mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201036  67F4                    2451mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00201038  13FC 0078 00C00007      2452mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00201040                          2453mm     ENDC
00201040                          2454mm     
00201040                 FALSE    2455mm     IFNE DEBUG
00201040                          2456mm     ENDC
00201040                          2457mm 
00201040                          2458mm     ENDM
00201040  7C07                    2459m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00201042                          2460m LOOP_180
00201042                          2461mm     BIN2HEX D4,D7,A0
00201042  41F9 002014DA           2462mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00201048  E99C                    2463mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020104A  1E04                    2464mm     MOVE.B D4,D7
0020104C  0287 0000000F           2465mm     ANDI.L #$F,D7
00201052  1E30 7000               2466mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00201056                          2467mm     ENDM
00201056                          2468mm     PRINT_CHAR D7,D3
00201056                          2469mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201056                 TRUE     2470mm     IFEQ DEBUG
00201056  1639 00C00003           2471mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020105C  0803 0002               2472mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201060  67F4                    2473mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00201062  13C7 00C00007           2474mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201068                          2475mm     ENDC
00201068                          2476mm     
00201068                 FALSE    2477mm     IFNE DEBUG
00201068                          2478mm     ENDC
00201068                          2479mm 
00201068                          2480mm     ENDM
00201068  57CE FFD8               2481m     DBEQ D6,LOOP_180
0020106C                          2482m     ENDM
0020106C  41F9 0020147D           2483      LEA READ,A0
00201072                          2484m     PRINT_STR A0,D3
00201072                          2485m LOOP_185
00201072  0C10 0000               2486m     CMP.B #0,(A0)                               ; 0 -> DONE
00201076  6700 001A               2487m     BEQ EXIT_185
0020107A                          2488mm     PRINT_CHAR (A0)+,D3
0020107A                          2489mm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020107A                 TRUE     2490mm     IFEQ DEBUG
0020107A  1639 00C00003           2491mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201080  0803 0002               2492mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201084  67F4                    2493mm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00201086  13D8 00C00007           2494mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020108C                          2495mm     ENDC
0020108C                          2496mm     
0020108C                 FALSE    2497mm     IFNE DEBUG
0020108C                          2498mm     ENDC
0020108C                          2499mm 
0020108C                          2500mm     ENDM
0020108C  4EF9 00201072           2501m     JMP LOOP_185
00201092                          2502m EXIT_185
00201092                          2503m     ENDM
00201092  2E0A                    2504      MOVE.L A2,D7                                ; set address accumulator to start address
00201094                          2505m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00201094                          2506mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00201094                          2507mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201094                 TRUE     2508mm     IFEQ DEBUG
00201094  1639 00C00003           2509mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020109A  0803 0002               2510mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020109E  67F4                    2511mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
002010A0  13FC 0030 00C00007      2512mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002010A8                          2513mm     ENDC
002010A8                          2514mm     
002010A8                 FALSE    2515mm     IFNE DEBUG
002010A8                          2516mm     ENDC
002010A8                          2517mm 
002010A8                          2518mm     ENDM
002010A8                          2519mm     PRINT_CHAR #'x',D3
002010A8                          2520mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010A8                 TRUE     2521mm     IFEQ DEBUG
002010A8  1639 00C00003           2522mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010AE  0803 0002               2523mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010B2  67F4                    2524mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
002010B4  13FC 0078 00C00007      2525mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002010BC                          2526mm     ENDC
002010BC                          2527mm     
002010BC                 FALSE    2528mm     IFNE DEBUG
002010BC                          2529mm     ENDC
002010BC                          2530mm 
002010BC                          2531mm     ENDM
002010BC  7C07                    2532m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002010BE                          2533m LOOP_187
002010BE                          2534mm     BIN2HEX D7,D2,A0
002010BE  41F9 002014DA           2535mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002010C4  E99F                    2536mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002010C6  1407                    2537mm     MOVE.B D7,D2
002010C8  0282 0000000F           2538mm     ANDI.L #$F,D2
002010CE  1430 2000               2539mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002010D2                          2540mm     ENDM
002010D2                          2541mm     PRINT_CHAR D2,D3
002010D2                          2542mm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010D2                 TRUE     2543mm     IFEQ DEBUG
002010D2  1639 00C00003           2544mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010D8  0803 0002               2545mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010DC  67F4                    2546mm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
002010DE  13C2 00C00007           2547mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002010E4                          2548mm     ENDC
002010E4                          2549mm     
002010E4                 FALSE    2550mm     IFNE DEBUG
002010E4                          2551mm     ENDC
002010E4                          2552mm 
002010E4                          2553mm     ENDM
002010E4  57CE FFD8               2554m     DBEQ D6,LOOP_187
002010E8                          2555m     ENDM
002010E8                          2556m     PRINT_CRLF D3     
002010E8                          2557mm     PRINT_CHAR #13,D3                           ; CR
002010E8                          2558mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010E8                 TRUE     2559mm     IFEQ DEBUG
002010E8  1639 00C00003           2560mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002010EE  0803 0002               2561mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002010F2  67F4                    2562mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
002010F4  13FC 000D 00C00007      2563mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002010FC                          2564mm     ENDC
002010FC                          2565mm     
002010FC                 FALSE    2566mm     IFNE DEBUG
002010FC                          2567mm     ENDC
002010FC                          2568mm 
002010FC                          2569mm     ENDM
002010FC                          2570mm     PRINT_CHAR #10,D3                           ; LF
002010FC                          2571mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002010FC                 TRUE     2572mm     IFEQ DEBUG
002010FC  1639 00C00003           2573mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201102  0803 0002               2574mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201106  67F4                    2575mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00201108  13FC 000A 00C00007      2576mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00201110                          2577mm     ENDC
00201110                          2578mm     
00201110                 FALSE    2579mm     IFNE DEBUG
00201110                          2580mm     ENDC
00201110                          2581mm 
00201110                          2582mm     ENDM
00201110                          2583m     ENDM
00201110                          2584          
00201110  4EF9 00200188           2585      JMP MAIN_LOOP
00201116                          2586      
00201116                          2587  G
00201116  2047                    2588      MOVE.L D7,A0                                ; address accumulator -> address register
00201118  3E3C 0000               2589      MOVE #0,D7                                  ; clear the now used address accumulator
0020111C  4ED0                    2590      JMP (A0)                                    ; jump to it!
0020111E                          2591      
0020111E                          2592  Z
0020111E  207C 00200000           2593      MOVE.L #RAM,A0                              ; address of RAM
00201124  7000                    2594      MOVE.L #0,D0                                ; number of bytes
00201126                          2595     
00201126                          2596      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201126                          2597s _10000004
00201126  B0BC 00040000           2598s     CMP.L   #$40000,D0
0020112C  6E00 001A               2599s     BGT _10000005
00201130  2200                    2600          MOVE.L D0,D1                            ; progress update
00201132  E089                    2601          LSR.L #8,D1 
00201134  E089                    2602          LSR.L #8,D1
00201136  0281 0000000F           2603          ANDI.L #$F,D1
0020113C  13C1 00E00001           2604          MOVE.B D1,DISPLAY
00201142                          2605  
00201142  20C0                    2606          MOVE.L D0,(A0)+ 
00201144  5880                    2607          ADD.L #4,D0
00201146                          2608      ENDW
00201146  60DE                    2609s     BRA _10000004
00201148                          2610s _10000005
00201148                          2611   
00201148  207C 00200000           2612      MOVE.L #RAM,A0                              ; address of RAM
0020114E  7000                    2613      MOVE.L #0,D0                                ; number of bytes
00201150                          2614     
00201150                          2615      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00201150                          2616s _10000006
00201150  B0BC 00040000           2617s     CMP.L   #$40000,D0
00201156  6E00 00CC               2618s     BGT _10000007
0020115A  2200                    2619          MOVE.L D0,D1                            ; progress update
0020115C  E089                    2620          LSR.L #8,D1
0020115E  E089                    2621          LSR.L #8,D1
00201160  0281 0000000F           2622          ANDI.L #$F,D1
00201166  13C1 00E00001           2623          MOVE.B D1,DISPLAY
0020116C                          2624  
0020116C  2218                    2625          MOVE.L (A0)+,D1
0020116E                          2626            
0020116E                          2627          IF.L D0 <EQ> D1 THEN
0020116E  B081                    2628s     CMP.L   D1,D0
00201170  6600 0006               2629s     BNE _00000009
00201174  6000 00A8               2630              BRA OK
00201178                          2631          ENDI 
00201178                          2632s _00000009
00201178                          2633            
00201178  43F9 002014C8           2634          LEA RAM_ERROR,A1
0020117E                          2635m         PRINT_STR A1,D1
0020117E                          2636m LOOP_195
0020117E  0C11 0000               2637m     CMP.B #0,(A1)                               ; 0 -> DONE
00201182  6700 001A               2638m     BEQ EXIT_195
00201186                          2639mm     PRINT_CHAR (A1)+,D1
00201186                          2640mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201186                 TRUE     2641mm     IFEQ DEBUG
00201186  1239 00C00003           2642mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
0020118C  0801 0002               2643mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00201190  67F4                    2644mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00201192  13D9 00C00007           2645mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00201198                          2646mm     ENDC
00201198                          2647mm     
00201198                 FALSE    2648mm     IFNE DEBUG
00201198                          2649mm     ENDC
00201198                          2650mm 
00201198                          2651mm     ENDM
00201198  4EF9 0020117E           2652m     JMP LOOP_195
0020119E                          2653m EXIT_195
0020119E                          2654m     ENDM
0020119E  2208                    2655          MOVE.L A0,D1
002011A0  5981                    2656          SUB.L #4,D1
002011A2                          2657m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
002011A2                          2658mm     PRINT_CHAR #'0',D3                          ;0X HEADER
002011A2                          2659mm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011A2                 TRUE     2660mm     IFEQ DEBUG
002011A2  1639 00C00003           2661mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011A8  0803 0002               2662mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011AC  67F4                    2663mm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
002011AE  13FC 0030 00C00007      2664mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002011B6                          2665mm     ENDC
002011B6                          2666mm     
002011B6                 FALSE    2667mm     IFNE DEBUG
002011B6                          2668mm     ENDC
002011B6                          2669mm 
002011B6                          2670mm     ENDM
002011B6                          2671mm     PRINT_CHAR #'x',D3
002011B6                          2672mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011B6                 TRUE     2673mm     IFEQ DEBUG
002011B6  1639 00C00003           2674mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011BC  0803 0002               2675mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011C0  67F4                    2676mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
002011C2  13FC 0078 00C00007      2677mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002011CA                          2678mm     ENDC
002011CA                          2679mm     
002011CA                 FALSE    2680mm     IFNE DEBUG
002011CA                          2681mm     ENDC
002011CA                          2682mm 
002011CA                          2683mm     ENDM
002011CA  7C07                    2684m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002011CC                          2685m LOOP_197
002011CC                          2686mm     BIN2HEX D1,D2,A1
002011CC  43F9 002014DA           2687mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
002011D2  E999                    2688mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002011D4  1401                    2689mm     MOVE.B D1,D2
002011D6  0282 0000000F           2690mm     ANDI.L #$F,D2
002011DC  1431 2000               2691mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
002011E0                          2692mm     ENDM
002011E0                          2693mm     PRINT_CHAR D2,D3
002011E0                          2694mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011E0                 TRUE     2695mm     IFEQ DEBUG
002011E0  1639 00C00003           2696mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011E6  0803 0002               2697mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002011EA  67F4                    2698mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
002011EC  13C2 00C00007           2699mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002011F2                          2700mm     ENDC
002011F2                          2701mm     
002011F2                 FALSE    2702mm     IFNE DEBUG
002011F2                          2703mm     ENDC
002011F2                          2704mm 
002011F2                          2705mm     ENDM
002011F2  57CE FFD8               2706m     DBEQ D6,LOOP_197
002011F6                          2707m     ENDM
002011F6                          2708m         PRINT_CRLF D3
002011F6                          2709mm     PRINT_CHAR #13,D3                           ; CR
002011F6                          2710mm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002011F6                 TRUE     2711mm     IFEQ DEBUG
002011F6  1639 00C00003           2712mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002011FC  0803 0002               2713mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201200  67F4                    2714mm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00201202  13FC 000D 00C00007      2715mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020120A                          2716mm     ENDC
0020120A                          2717mm     
0020120A                 FALSE    2718mm     IFNE DEBUG
0020120A                          2719mm     ENDC
0020120A                          2720mm 
0020120A                          2721mm     ENDM
0020120A                          2722mm     PRINT_CHAR #10,D3                           ; LF
0020120A                          2723mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020120A                 TRUE     2724mm     IFEQ DEBUG
0020120A  1639 00C00003           2725mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201210  0803 0002               2726mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201214  67F4                    2727mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00201216  13FC 000A 00C00007      2728mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020121E                          2729mm     ENDC
0020121E                          2730mm     
0020121E                 FALSE    2731mm     IFNE DEBUG
0020121E                          2732mm     ENDC
0020121E                          2733mm 
0020121E                          2734mm     ENDM
0020121E                          2735m     ENDM
0020121E                          2736  OK    
0020121E  5880                    2737          ADD.L #4,D0
00201220                          2738      ENDW
00201220  6000 FF2E               2739s     BRA _10000006
00201224                          2740s _10000007
00201224                          2741      
00201224  4EF9 00200188           2742      JMP MAIN_LOOP
0020122A                          2743    
0020122A                          2744  L
0020122A  7A00                    2745      MOVE.L #0,D5                                ; D5 will be the length  to write            
0020122C                          2746  
0020122C                          2747m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
0020122C                          2748m WAIT_FOR_READY_205                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020122C                          2749m 
0020122C                 TRUE     2750m     IFEQ DEBUG
0020122C  1639 00C00003           2751m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201232  0803 0000               2752m         BTST #0,D3                              ; CHECK FOR CHARACTER
00201236  67F4                    2753m         BEQ WAIT_FOR_READY_205                      ; NOTHING, CHECK AGAIN
00201238                          2754m     ENDC
00201238                          2755m     
00201238                          2756mm     READ_CHAR D2
00201238                 TRUE     2757mm     IFEQ DEBUG
00201238  1439 00C00007           2758mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020123E                          2759mm     ENDC
0020123E                 FALSE    2760mm     IFNE DEBUG
0020123E                          2761mm     ENDC
0020123E                          2762mm      
0020123E  B43C 001B               2763mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00201242  6700 EDC4               2764mm     BEQ START
00201246                          2765mm     ENDM
00201246                          2766m 
00201246                 TRUE     2767m     IFEQ DEBUG
00201246                          2768mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00201246                          2769mm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201246                 TRUE     2770mm     IFEQ DEBUG
00201246  1639 00C00003           2771mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020124C  0803 0002               2772mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201250  67F4                    2773mm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
00201252  13C2 00C00007           2774mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00201258                          2775mm     ENDC
00201258                          2776mm     
00201258                 FALSE    2777mm     IFNE DEBUG
00201258                          2778mm     ENDC
00201258                          2779mm 
00201258                          2780mm     ENDM
00201258                          2781m     ENDC
00201258                          2782m     ENDM
00201258                          2783m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00201258  41F9 002014EA           2784m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020125E  0402 0030               2785m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00201262  C4BC 000000FF           2786m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00201268  1430 2000               2787m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020126C                          2788m     ENDM
0020126C  1A02                    2789      MOVE.B D2,D5                                ; put at bottom of D5
0020126E                          2790  
0020126E  3C3C 0002               2791      MOVE #2,D6                                  ; 3 bytes left to read
00201272                          2792      
00201272                          2793  READ_LENGTH
00201272  E98D                    2794      LSL.L #4,D5                                 ; make what we have so far more significant
00201274                          2795m     WAIT_CHAR D2,D3                             ; next character -> D2
00201274                          2796m WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00201274                          2797m 
00201274                 TRUE     2798m     IFEQ DEBUG
00201274  1639 00C00003           2799m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020127A  0803 0000               2800m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020127E  67F4                    2801m         BEQ WAIT_FOR_READY_209                      ; NOTHING, CHECK AGAIN
00201280                          2802m     ENDC
00201280                          2803m     
00201280                          2804mm     READ_CHAR D2
00201280                 TRUE     2805mm     IFEQ DEBUG
00201280  1439 00C00007           2806mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00201286                          2807mm     ENDC
00201286                 FALSE    2808mm     IFNE DEBUG
00201286                          2809mm     ENDC
00201286                          2810mm      
00201286  B43C 001B               2811mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020128A  6700 ED7C               2812mm     BEQ START
0020128E                          2813mm     ENDM
0020128E                          2814m 
0020128E                 TRUE     2815m     IFEQ DEBUG
0020128E                          2816mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0020128E                          2817mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020128E                 TRUE     2818mm     IFEQ DEBUG
0020128E  1639 00C00003           2819mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201294  0803 0002               2820mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201298  67F4                    2821mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0020129A  13C2 00C00007           2822mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002012A0                          2823mm     ENDC
002012A0                          2824mm     
002012A0                 FALSE    2825mm     IFNE DEBUG
002012A0                          2826mm     ENDC
002012A0                          2827mm 
002012A0                          2828mm     ENDM
002012A0                          2829m     ENDC
002012A0                          2830m     ENDM
002012A0                          2831m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002012A0  41F9 002014EA           2832m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002012A6  0402 0030               2833m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002012AA  C4BC 000000FF           2834m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002012B0  1430 2000               2835m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002012B4                          2836m     ENDM
002012B4  8A02                    2837      OR.B D2,D5
002012B6  023C 00FB               2838      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
002012BA  57CE FFB6               2839      DBEQ D6,READ_LENGTH
002012BE                          2840          
002012BE                          2841m     PRINT_CRLF D3
002012BE                          2842mm     PRINT_CHAR #13,D3                           ; CR
002012BE                          2843mm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012BE                 TRUE     2844mm     IFEQ DEBUG
002012BE  1639 00C00003           2845mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002012C4  0803 0002               2846mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002012C8  67F4                    2847mm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
002012CA  13FC 000D 00C00007      2848mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002012D2                          2849mm     ENDC
002012D2                          2850mm     
002012D2                 FALSE    2851mm     IFNE DEBUG
002012D2                          2852mm     ENDC
002012D2                          2853mm 
002012D2                          2854mm     ENDM
002012D2                          2855mm     PRINT_CHAR #10,D3                           ; LF
002012D2                          2856mm WAIT_FOR_READY_215                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002012D2                 TRUE     2857mm     IFEQ DEBUG
002012D2  1639 00C00003           2858mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002012D8  0803 0002               2859mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002012DC  67F4                    2860mm         BEQ WAIT_FOR_READY_215                      ; NO SPACE, CHECK AGAIN
002012DE  13FC 000A 00C00007      2861mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002012E6                          2862mm     ENDC
002012E6                          2863mm     
002012E6                 FALSE    2864mm     IFNE DEBUG
002012E6                          2865mm     ENDC
002012E6                          2866mm 
002012E6                          2867mm     ENDM
002012E6                          2868m     ENDM
002012E6                          2869  
002012E6  207C 00000000           2870      MOVE.L #ROM,A0                              ; start of ROM
002012EC                          2871      
002012EC  2247                    2872      MOVE.L D7,A1                                ; address accumulator -> address register
002012EE  7E00                    2873      MOVE.L #0,D7                                ; clear the now used address accumulator
002012F0                          2874      
002012F0  267C 00002AAA           2875      MOVE.L #$2AAA,A3
002012F6  36BC AAAA               2876      MOVE.W #$AAAA,(A3)
002012FA  267C 00001554           2877      MOVE.L #$1554,A3
00201300  36BC 5555               2878      MOVE.W #$5555,(A3)
00201304  267C 00002AAA           2879      MOVE.L #$2AAA,A3
0020130A  36BC 8080               2880      MOVE.W #$8080,(A3)
0020130E  267C 00002AAA           2881      MOVE.L #$2AAA,A3
00201314  36BC AAAA               2882      MOVE.W #$AAAA,(A3)
00201318  267C 00001554           2883      MOVE.L #$1554,A3
0020131E  36BC 5555               2884      MOVE.W #$5555,(A3)
00201322  267C 00002AAA           2885      MOVE.L #$2AAA,A3
00201328  36BC 2020               2886      MOVE.W #$2020,(A3)
0020132C                          2887      
0020132C  45F9 00201501           2888      LEA LOADING,A2                              ; important for timing
00201332                          2889m     PRINT_STR A2,D3
00201332                          2890m LOOP_216
00201332  0C12 0000               2891m     CMP.B #0,(A2)                               ; 0 -> DONE
00201336  6700 001A               2892m     BEQ EXIT_216
0020133A                          2893mm     PRINT_CHAR (A2)+,D3
0020133A                          2894mm WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020133A                 TRUE     2895mm     IFEQ DEBUG
0020133A  1639 00C00003           2896mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00201340  0803 0002               2897mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00201344  67F4                    2898mm         BEQ WAIT_FOR_READY_217                      ; NO SPACE, CHECK AGAIN
00201346  13DA 00C00007           2899mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020134C                          2900mm     ENDC
0020134C                          2901mm     
0020134C                 FALSE    2902mm     IFNE DEBUG
0020134C                          2903mm     ENDC
0020134C                          2904mm 
0020134C                          2905mm     ENDM
0020134C  4EF9 00201332           2906m     JMP LOOP_216
00201352                          2907m EXIT_216
00201352                          2908m     ENDM
00201352                          2909  
00201352  023C 00FB               2910      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00201356                          2911      
00201356                          2912      WHILE D5 <GT> #0 DO
00201356                          2913s _10000008
00201356  BA7C 0000               2914s     CMP.W   #0,D5
0020135A  6F00 0020               2915s     BLE _10000009
0020135E  5585                    2916          SUB.L #2,D5
00201360                          2917            
00201360  13D1 00E00001           2918          MOVE.B (A1),DISPLAY
00201366  3091                    2919          MOVE.W (A1),(A0)                        ; write the data
00201368                          2920        
00201368                          2921  WAIT_FOR_COMPLETE
00201368  3410                    2922          MOVE.W (A0),D2
0020136A                          2923  
0020136A                          2924          IF D2 <NE> (A1) THEN
0020136A  B451                    2925s     CMP.W   (A1),D2
0020136C  6700 0008               2926s     BEQ _0000000A
00201370  4EF9 00201368           2927              JMP WAIT_FOR_COMPLETE
00201376                          2928          ENDI
00201376                          2929s _0000000A
00201376                          2930        
00201376  5488                    2931          ADD.L #2,A0
00201378  5489                    2932          ADD.L #2,A1
0020137A                          2933      ENDW  
0020137A  60DA                    2934s     BRA _10000008
0020137C                          2935s _10000009
0020137C                          2936      
0020137C  267C 00002AAA           2937      MOVE.L #$2AAA,A3
00201382  36BC AAAA               2938      MOVE.W #$AAAA,(A3)
00201386  267C 00001554           2939      MOVE.L #$1554,A3
0020138C  36BC 5555               2940      MOVE.W #$5555,(A3)
00201390  267C 00002AAA           2941      MOVE.L #$2AAA,A3
00201396  36BC A0A0               2942      MOVE.W #$A0A0,(A3)
0020139A                          2943              
0020139A  4EF9 00200188           2944      JMP MAIN_LOOP
002013A0                          2945          
002013A0                          2946  HEX_DIGIT
002013A0  E98F                    2947      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
002013A2                          2948m     HEX2BIN D2,D2,A0
002013A2  41F9 002014EA           2949m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002013A8  0402 0030               2950m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002013AC  C4BC 000000FF           2951m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002013B2  1430 2000               2952m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002013B6                          2953m     ENDM
002013B6  8E02                    2954      OR.B D2,D7  
002013B8  4EF9 002001B0           2955      JMP GET_INPUT
002013BE                          2956  
002013BE  FFFF FFFF               2957      SIMHALT                                     ; halt simulator
002013C2                          2958  
002013C2                          2959  ; strings
002013C2= 4D 44 46 2D 6D 6F ...   2960  VERSION DC.B 'MDF-mon V1.44 (09/04/2021)',13,10,0
002013DF= 3F 20 48 65 6C 70 ...   2961  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00201476= 48 75 68 3F 0D 0A 00    2962  HUH     DC.B 'Huh?',13,10,0
0020147D= 20 53 20 72 65 63 ...   2963  READ    DC.B ' S records read, start address = ',0
0020149F= 57 3A 20 55 6E 6B ...   2964  UNREC   DC.B 'W: Unknown Srec type: ',0
002014B6= 57 3A 20 43 53 20 ...   2965  CS_FAILURE   DC.B 'W: CS failure at ',0
002014C8= 57 3A 20 52 41 4D ...   2966  RAM_ERROR DC.B 'W: RAM error at: ',0
002014DA= 30 31 32 33 34 35 ...   2967  BIN2HEX_LUT DC.B '0123456789ABCDEF'
002014EA= 00 01 02 03 04 05 ...   2968  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201501= 4C 6F 61 64 69 6E ...   2969  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201515                          2970      
00201515                          2971      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         2014DA
CONTINUE_103        2009D8
CONTINUE_108        200A3C
CONTINUE_112        200A9A
CONTINUE_117        200B0E
CONTINUE_121        200B6C
CONTINUE_126        200BE6
CONTINUE_130        200C44
CONTINUE_135        200CA4
CONTINUE_139        200D02
CONTINUE_144        200D66
CONTINUE_148        200DC4
CONTINUE_159        200EA2
CONTINUE_163        200F00
CONTINUE_44         2004BC
CONTINUE_47         20050C
CONTINUE_51         200556
CONTINUE_55         2005B4
CONTINUE_60         20062C
CONTINUE_64         20068A
CONTINUE_69         2006EA
CONTINUE_73         200748
CONTINUE_78         2007BC
CONTINUE_82         20081A
CONTINUE_90         2008BC
CONTINUE_94         20091A
CONTINUE_99         20097A
CS_FAILURE          2014B6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       BC9
DOWNLOAD_DONE       201018
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_152            200E3C
EXIT_170            200F94
EXIT_185            201092
EXIT_19             2002EA
EXIT_195            20119E
EXIT_21             200316
EXIT_216            201352
EXIT_23             200342
EXIT_5              200142
G                   201116
GET_INPUT           2001B0
H                   2002F0
HELP                2013DF
HEX2BIN             134
HEX2BIN_LUT         2014EA
HEX_DIGIT           2013A0
HUH                 201476
L                   20122A
LOADING             201501
LOOP_152            200E1C
LOOP_170            200F74
LOOP_172            200FBE
LOOP_180            201042
LOOP_185            201072
LOOP_187            2010BE
LOOP_19             2002CA
LOOP_195            20117E
LOOP_197            2011CC
LOOP_21             2002F6
LOOP_216            201332
LOOP_23             200322
LOOP_25             200376
LOOP_5              200122
MAIN_LOOP           200188
OK                  20121E
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           2014C8
READ                20147D
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         201272
RESET               200004
ROM                 0
S                   200498
STACK               200000
START               200008
UNREC               20149F
V                   20031C
VERSION             2013C2
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   201368
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_101  200992
WAIT_FOR_READY_103  2009BC
WAIT_FOR_READY_105  2009F0
WAIT_FOR_READY_108  200A20
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_110  200A54
WAIT_FOR_READY_112  200A7E
WAIT_FOR_READY_114  200AB2
WAIT_FOR_READY_117  200AF2
WAIT_FOR_READY_119  200B26
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_121  200B50
WAIT_FOR_READY_123  200B84
WAIT_FOR_READY_126  200BCA
WAIT_FOR_READY_128  200BFE
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_130  200C28
WAIT_FOR_READY_132  200C5C
WAIT_FOR_READY_135  200C88
WAIT_FOR_READY_137  200CBC
WAIT_FOR_READY_139  200CE6
WAIT_FOR_READY_141  200D1A
WAIT_FOR_READY_144  200D4A
WAIT_FOR_READY_146  200D7E
WAIT_FOR_READY_148  200DA8
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_150  200DDC
WAIT_FOR_READY_153  200E24
WAIT_FOR_READY_154  200E3C
WAIT_FOR_READY_156  200E4E
WAIT_FOR_READY_157  200E62
WAIT_FOR_READY_159  200E86
WAIT_FOR_READY_161  200EBA
WAIT_FOR_READY_163  200EE4
WAIT_FOR_READY_165  200F18
WAIT_FOR_READY_168  200F40
WAIT_FOR_READY_169  200F54
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_171  200F7C
WAIT_FOR_READY_173  200F94
WAIT_FOR_READY_174  200FA8
WAIT_FOR_READY_176  200FD2
WAIT_FOR_READY_178  200FE8
WAIT_FOR_READY_179  200FFC
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_181  201018
WAIT_FOR_READY_182  20102C
WAIT_FOR_READY_184  201056
WAIT_FOR_READY_186  20107A
WAIT_FOR_READY_188  201094
WAIT_FOR_READY_189  2010A8
WAIT_FOR_READY_191  2010D2
WAIT_FOR_READY_193  2010E8
WAIT_FOR_READY_194  2010FC
WAIT_FOR_READY_196  201186
WAIT_FOR_READY_198  2011A2
WAIT_FOR_READY_199  2011B6
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_201  2011E0
WAIT_FOR_READY_203  2011F6
WAIT_FOR_READY_204  20120A
WAIT_FOR_READY_205  20122C
WAIT_FOR_READY_207  201246
WAIT_FOR_READY_209  201274
WAIT_FOR_READY_211  20128E
WAIT_FOR_READY_214  2012BE
WAIT_FOR_READY_215  2012D2
WAIT_FOR_READY_217  20133A
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DA
WAIT_FOR_READY_47   2004F0
WAIT_FOR_READY_49   200524
WAIT_FOR_READY_51   20053A
WAIT_FOR_READY_53   20056E
WAIT_FOR_READY_55   200598
WAIT_FOR_READY_57   2005CC
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_60   200610
WAIT_FOR_READY_62   200644
WAIT_FOR_READY_64   20066E
WAIT_FOR_READY_66   2006A2
WAIT_FOR_READY_69   2006CE
WAIT_FOR_READY_71   200702
WAIT_FOR_READY_73   20072C
WAIT_FOR_READY_75   200760
WAIT_FOR_READY_78   2007A0
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_80   2007D4
WAIT_FOR_READY_82   2007FE
WAIT_FOR_READY_84   200832
WAIT_FOR_READY_87   200864
WAIT_FOR_READY_88   200878
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_90   2008A0
WAIT_FOR_READY_92   2008D4
WAIT_FOR_READY_94   2008FE
WAIT_FOR_READY_96   200932
WAIT_FOR_READY_99   20095E
WAIT_FOR_SRECORD    2004A0
Z                   20111E
_00000000           200606
_00000001           200E7C
_00000002           200896
_00000003           200E7C
_00000004           200BC0
_00000005           200E7C
_00000006           200E16
_00000007           200E7C
_00000008           201016
_00000009           201178
_0000000A           201376
_10000000           200794
_10000001           200864
_10000002           200AE6
_10000003           200BB6
_10000004           201126
_10000005           201148
_10000006           201150
_10000007           201224
_10000008           201356
_10000009           20137C
