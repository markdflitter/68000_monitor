00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 14:04:41

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Replace JMP -> BRA, THEN.L
00000000                             9  ; revisit register usage in S record download
00000000                            10  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            11  ; revisit use of bytes and longs
00000000                            12  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            13  ; Review for any other savings
00000000                            14  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            15  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            16  
00000000                            17  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            18  ; keep track of highest address hit during srec download
00000000                            19  ; fix the reset vector so that it jumps to the start
00000000                            20  ; implement backspace
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  ; fix being able to enter random chars when W'ing
00000000                            23  ; ram check at startup?  Not sure if this is a good idea!
00000000                            24  ; byte W?
00000000                            25  
00000000                            26      ;ORG  $0
00200000                            27      ORG  $200000
00200000                            28  
00200000  =00000000                 29  DEBUG               EQU 0
00200000                            30  
00200000                            31  ; constants
00200000  =00000000                 32  ROM                 EQU $0
00200000  =00200000                 33  RAM                 EQU $200000
00200000                            34     
00200000  =00C00000                 35  DUART_BASE          EQU $C00000
00200000  =00000000                 36  DUART_MRA_          EQU $0
00200000  =00000001                 37  DUART_CSRA_         EQU $1
00200000  =00000001                 38  DUART_SRA_          EQU $1
00200000  =00000002                 39  DUART_CRA_          EQU $2
00200000  =00000003                 40  DUART_TXA_          EQU $3
00200000  =00000003                 41  DUART_RXA_          EQU $3
00200000  =00000004                 42  DUART_ACR_          EQU $4
00200000  =00000005                 43  DUART_IMR_          EQU $5
00200000  =00000008                 44  DUART_MRB_          EQU $8
00200000  =00000009                 45  DUART_CSRB_         EQU $9
00200000  =00000009                 46  DUART_SRB_          EQU $9
00200000  =0000000A                 47  DUART_CRB_          EQU $A
00200000  =0000000B                 48  DUART_TXB_          EQU $B
00200000  =0000000B                 49  DUART_RXB_          EQU $B
00200000  =0000000C                 50  DUART_IVR_          EQU $C
00200000  =0000000D                 51  DUART_OPCR_         EQU $D
00200000  =0000000E                 52  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 53  DUART_RESET_OPR_    EQU $F
00200000                            54  
00200000  =00C00001                 55  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 56  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 57  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 58  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 59  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 60  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            61  
00200000  =00C00011                 62  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 63  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 64  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 65  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 66  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 67  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            68  
00200000  =00C00009                 69  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 70  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 71  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 72  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 73  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 74  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            75  
00200000  =00E00000                 76  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 77  DISPLAY_            EQU $0
00200000  =00E00001                 78  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            79  
00200000                            80  ; macros
00200000                            81  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            82  ; the input register is changed during the process
00200000                            83  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            84  BIN2HEX MACRO
00200000                            85      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            86      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            87      MOVE.B \1,\2
00200000                            88      ANDI.L #$F,\2
00200000                            89      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            90      ENDM
00200000                            91  
00200000                            92  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            93  ; the input register is changed during the process
00200000                            94  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            95  HEX2BIN MACRO
00200000                            96      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            97      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                            98      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                            99      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                           100      ENDM
00200000                           101  
00200000                           102  ; send a single char to the serial port
00200000                           103  ; \1 = char to send, \2 = data register to use for status poll
00200000                           104  ; will stamp on D0 and D1 in debug mode
00200000                           105  PRINT_CHAR MACRO
00200000                           106  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           107      IFEQ DEBUG
00200000                           108          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           109          BTST #2,\2                              ; check for space to send
00200000                           110          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           111          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           112      ENDC
00200000                           113      
00200000                           114      IFNE DEBUG
00200000                           115          MOVE.B \1,D1
00200000                           116          MOVE.L #6,D0   
00200000                           117          TRAP #15                                ; write to terminal in simulator
00200000                           118      ENDC
00200000                           119  
00200000                           120      ENDM
00200000                           121  
00200000                           122  ; send CR,LF to the serial port
00200000                           123  ; \1 = data register to use for status poll
00200000                           124  PRINT_CRLF MACRO
00200000                           125      PRINT_CHAR #13,\1                           ; CR
00200000                           126      PRINT_CHAR #10,\1                           ; LF
00200000                           127      ENDM
00200000                           128  
00200000                           129  ; send C-style, zero terminated string to the serial port
00200000                           130  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           131  PRINT_STR MACRO
00200000                           132  LOOP\@
00200000                           133      CMP.B #0,(\1)                               ; 0 -> done
00200000                           134      BEQ EXIT\@
00200000                           135      PRINT_CHAR (\1)+,\2
00200000                           136      BRA LOOP\@
00200000                           137  EXIT\@
00200000                           138      ENDM
00200000                           139    
00200000                           140  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           141  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           142  PRINT_REG MACRO
00200000                           143      PRINT_CHAR #'0',\2                          ;0x header
00200000                           144      PRINT_CHAR #'x',\2
00200000                           145      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           146  LOOP\@
00200000                           147      BIN2HEX \1,\3,\5
00200000                           148      PRINT_CHAR \3,\2
00200000                           149      DBEQ \4,LOOP\@
00200000                           150      ENDM
00200000                           151    
00200000                           152  ; wait for a char from the serial port
00200000                           153  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           154  ; will stamp on D0 and D1 in debug mode
00200000                           155  WAIT_CHAR MACRO
00200000                           156  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           157  
00200000                           158      IFEQ DEBUG
00200000                           159          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           160          BTST #0,\2                              ; check for character
00200000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           162      ENDC
00200000                           163      
00200000                           164      READ_CHAR \1
00200000                           165  
00200000                           166      IFEQ DEBUG
00200000                           167          PRINT_CHAR \1,\2                        ; echo it back
00200000                           168      ENDC
00200000                           169      ENDM
00200000                           170      
00200000                           171  ; read a char from the serial port - assumes that there is one!
00200000                           172  ; \ 1= data register for read char
00200000                           173  ; will stamp on D0 and D1 in debug mode
00200000                           174  READ_CHAR MACRO
00200000                           175      IFEQ DEBUG
00200000                           176          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           177      ENDC
00200000                           178      IFNE DEBUG
00200000                           179          MOVE.L #5,D0    
00200000                           180          TRAP #15                                ; read from keyboard in simulator
00200000                           181          MOVE.L D1,\1
00200000                           182      ENDC
00200000                           183       
00200000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           185      BEQ START
00200000                           186      ENDM
00200000                           187      
00200000                           188      
00200000                           189  ; read data from the download serial port
00200000                           190  ; \ 1= data register for read char
00200000                           191  DOWNLOAD MACRO
00200000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           193  
00200000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           195      BTST #0,\1                                  ; check for character
00200000                           196      BEQ CONTINUE\@                              ; nothing, continue
00200000                           197   
00200000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           199  CONTINUE\@
00200000                           200      MOVE.B DUART_SRB,\1                         ; read download status register
00200000                           201      BTST #0,\1                                  ; check for character
00200000                           202      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           203      
00200000                           204      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           205      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           206      
00200000                           207      ENDM
00200000                           208      
00200000                           209  ; read two hex digits from the download serial port and convert to a byte
00200000                           210  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           211  DOWNLOAD_BYTE MACRO
00200000                           212      MOVE.B #2,\4
00200000                           213      WHILE.B \4 <GT> 0 DO
00200000                           214          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200000                           215          DOWNLOAD \1
00200000                           216          PRINT_CHAR \1,\3
00200000                           217          HEX2BIN \1,\1,\6
00200000                           218          OR.B \1,\2
00200000                           219          SUB.B #1,\4
00200000                           220      ENDW
00200000                           221      
00200000                           222      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00200000                           223      MOVE.B \2,\1
00200000                           224      ADD.L \2,\5
00200000                           225  
00200000                           226      ENDM
00200000                           227      
00200000                           228  
00200000                           229  ; register catalogue
00200000                           230  ; D0 - used for simulator I/O
00200000                           231  ; D1 - used for simulator I/O
00200000                           232  ; D2 - read character
00200000                           233  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           234  ; D4 - count of S records read
00200000                           235  ; D5 - data to write / data read / byte count for S record load
00200000                           236  ; D6 - working register used in R/W and download
00200000                           237  ; D7 - address accumulator / reset by download
00200000                           238  ; A0 - address of string to print 
00200000                           239  
00200000                           240  ; start vector
00200000= 00000000                 241  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 242  RESET    DC.L START                             ; RESET
00200008                           243      
00200008                           244  ; start of program  
00200008                           245  START
00200008  13FC 0000 00E00001       246      MOVE.B #0,DISPLAY
00200010                           247  
00200010                           248  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       249      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       250      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     251      NOP
00200022  13FC 0040 00C00005       252      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     253      NOP
0020002C  13FC 0030 00C00005       254      MOVE.B #$30,DUART_CRA
00200034  4E71                     255      NOP
00200036  13FC 0020 00C00005       256      MOVE.B #$20,DUART_CRA
0020003E  4E71                     257      NOP
00200040  13FC 0010 00C00005       258      MOVE.B #$10,DUART_CRA   
00200048                           259  
00200048  13FC 000A 00C00015       260      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       261      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     262      NOP
0020005A  13FC 0040 00C00015       263      MOVE.B #$40,DUART_CRB           
00200062  4E71                     264      NOP
00200064  13FC 0030 00C00015       265      MOVE.B #$30,DUART_CRB
0020006C  4E71                     266      NOP
0020006E  13FC 0020 00C00015       267      MOVE.B #$20,DUART_CRB
00200076  4E71                     268      NOP
00200078  13FC 0010 00C00015       269      MOVE.B #$10,DUART_CRB   
00200080                           270  
00200080                           271  ;initialise UART
00200080  13FC 0000 00C00009       272      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       273      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       274      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           275  
00200098                           276  ; channel A
00200098  13FC 0013 00C00001       277      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       278      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       279      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       280      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           281  
002000B8                           282  ; channel B
002000B8  13FC 0013 00C00011       283      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       284      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       285      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       286      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           287  
002000D8                           288m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           289m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      290m     IFEQ DEBUG
002000D8  1639 00C00003            291m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                292m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     293m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       294m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           295m     ENDC
002000EC                           296m     
002000EC                 FALSE     297m     IFNE DEBUG
002000EC                           298m     ENDC
002000EC                           299m 
002000EC                           300m     ENDM
002000EC                           301  
002000EC  13FC 0001 00E00001       302      MOVE.B #1,DISPLAY
002000F4                           303         
002000F4                           304m     PRINT_CRLF D3
002000F4                           305mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           306mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      307mm     IFEQ DEBUG
002000F4  1639 00C00003            308mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                309mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     310mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       311mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           312mm     ENDC
00200108                           313mm     
00200108                 FALSE     314mm     IFNE DEBUG
00200108                           315mm     ENDC
00200108                           316mm 
00200108                           317mm     ENDM
00200108                           318mm     PRINT_CHAR #10,D3                           ; LF
00200108                           319mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      320mm     IFEQ DEBUG
00200108  1639 00C00003            321mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                322mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     323mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       324mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           325mm     ENDC
0020011C                           326mm     
0020011C                 FALSE     327mm     IFNE DEBUG
0020011C                           328mm     ENDC
0020011C                           329mm 
0020011C                           330mm     ENDM
0020011C                           331m     ENDM
0020011C                           332  
0020011C  41F9 00200EB8            333      LEA VERSION,A0
00200122                           334m     PRINT_STR A0,D3
00200122                           335m LOOP_5
00200122  0C10 0000                336m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 0016                337m     BEQ EXIT_5
0020012A                           338mm     PRINT_CHAR (A0)+,D3
0020012A                           339mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      340mm     IFEQ DEBUG
0020012A  1639 00C00003            341mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                342mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     343mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            344mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           345mm     ENDC
0020013C                           346mm     
0020013C                 FALSE     347mm     IFNE DEBUG
0020013C                           348mm     ENDC
0020013C                           349mm 
0020013C                           350mm     ENDM
0020013C  60E4                     351m     BRA LOOP_5
0020013E                           352m EXIT_5
0020013E                           353m     ENDM
0020013E                           354m     PRINT_CRLF D3
0020013E                           355mm     PRINT_CHAR #13,D3                           ; CR
0020013E                           356mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020013E                 TRUE      357mm     IFEQ DEBUG
0020013E  1639 00C00003            358mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200144  0803 0002                359mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200148  67F4                     360mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014A  13FC 000D 00C00007       361mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200152                           362mm     ENDC
00200152                           363mm     
00200152                 FALSE     364mm     IFNE DEBUG
00200152                           365mm     ENDC
00200152                           366mm 
00200152                           367mm     ENDM
00200152                           368mm     PRINT_CHAR #10,D3                           ; LF
00200152                           369mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200152                 TRUE      370mm     IFEQ DEBUG
00200152  1639 00C00003            371mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200158  0803 0002                372mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020015C  67F4                     373mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0020015E  13FC 000A 00C00007       374mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200166                           375mm     ENDC
00200166                           376mm     
00200166                 FALSE     377mm     IFNE DEBUG
00200166                           378mm     ENDC
00200166                           379mm 
00200166                           380mm     ENDM
00200166                           381m     ENDM
00200166                           382m     PRINT_CHAR #7,D3
00200166                           383m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200166                 TRUE      384m     IFEQ DEBUG
00200166  1639 00C00003            385m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020016C  0803 0002                386m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200170  67F4                     387m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200172  13FC 0007 00C00007       388m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017A                           389m     ENDC
0020017A                           390m     
0020017A                 FALSE     391m     IFNE DEBUG
0020017A                           392m     ENDC
0020017A                           393m 
0020017A                           394m     ENDM
0020017A                           395  
0020017A  7E00                     396      MOVE.L #0,D7                                ; address accumulator
0020017C                           397  
0020017C  13FC 0002 00E00001       398      MOVE.B #2,DISPLAY
00200184                           399  MAIN_LOOP
00200184                           400m     PRINT_CHAR #'>',D3                          ; prompt
00200184                           401m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200184                 TRUE      402m     IFEQ DEBUG
00200184  1639 00C00003            403m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018A  0803 0002                404m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020018E  67F4                     405m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200190  13FC 003E 00C00007       406m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200198                           407m     ENDC
00200198                           408m     
00200198                 FALSE     409m     IFNE DEBUG
00200198                           410m     ENDC
00200198                           411m 
00200198                           412m     ENDM
00200198                           413m     PRINT_CHAR #32,D3                           ; space
00200198                           414m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200198                 TRUE      415m     IFEQ DEBUG
00200198  1639 00C00003            416m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020019E  0803 0002                417m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A2  67F4                     418m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A4  13FC 0020 00C00007       419m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001AC                           420m     ENDC
002001AC                           421m     
002001AC                 FALSE     422m     IFNE DEBUG
002001AC                           423m     ENDC
002001AC                           424m 
002001AC                           425m     ENDM
002001AC                           426      
002001AC                           427  GET_INPUT
002001AC                           428m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001AC                           429m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001AC                           430m 
002001AC                 TRUE      431m     IFEQ DEBUG
002001AC  1639 00C00003            432m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B2  0803 0000                433m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001B6  67F4                     434m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001B8                           435m     ENDC
002001B8                           436m     
002001B8                           437mm     READ_CHAR D2
002001B8                 TRUE      438mm     IFEQ DEBUG
002001B8  1439 00C00007            439mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001BE                           440mm     ENDC
002001BE                 FALSE     441mm     IFNE DEBUG
002001BE                           442mm     ENDC
002001BE                           443mm      
002001BE  B43C 001B                444mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C2  6700 FE44                445mm     BEQ START
002001C6                           446mm     ENDM
002001C6                           447m 
002001C6                 TRUE      448m     IFEQ DEBUG
002001C6                           449mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001C6                           450mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001C6                 TRUE      451mm     IFEQ DEBUG
002001C6  1639 00C00003            452mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001CC  0803 0002                453mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D0  67F4                     454mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D2  13C2 00C00007            455mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001D8                           456mm     ENDC
002001D8                           457mm     
002001D8                 FALSE     458mm     IFNE DEBUG
002001D8                           459mm     ENDC
002001D8                           460mm 
002001D8                           461mm     ENDM
002001D8                           462m     ENDC
002001D8                           463m     ENDM
002001D8                           464      
002001D8  B43C 0030                465      CMP.B #'0',D2
002001DC  6700 0CBA                466      BEQ HEX_DIGIT
002001E0  B43C 0031                467      CMP.B #'1',D2
002001E4  6700 0CB2                468      BEQ HEX_DIGIT
002001E8  B43C 0032                469      CMP.B #'2',D2
002001EC  6700 0CAA                470      BEQ HEX_DIGIT
002001F0  B43C 0033                471      CMP.B #'3',D2
002001F4  6700 0CA2                472      BEQ HEX_DIGIT
002001F8  B43C 0034                473      CMP.B #'4',D2
002001FC  6700 0C9A                474      BEQ HEX_DIGIT
00200200  B43C 0035                475      CMP.B #'5',D2
00200204  6700 0C92                476      BEQ HEX_DIGIT
00200208  B43C 0036                477      CMP.B #'6',D2
0020020C  6700 0C8A                478      BEQ HEX_DIGIT
00200210  B43C 0037                479      CMP.B #'7',D2
00200214  6700 0C82                480      BEQ HEX_DIGIT
00200218  B43C 0038                481      CMP.B #'8',D2
0020021C  6700 0C7A                482      BEQ HEX_DIGIT
00200220  B43C 0039                483      CMP.B #'9',D2
00200224  6700 0C72                484      BEQ HEX_DIGIT
00200228  B43C 0061                485      CMP.B #'a',D2
0020022C  6700 0C6A                486      BEQ HEX_DIGIT
00200230  B43C 0062                487      CMP.B #'b',D2
00200234  6700 0C62                488      BEQ HEX_DIGIT
00200238  B43C 0063                489      CMP.B #'c',D2
0020023C  6700 0C5A                490      BEQ HEX_DIGIT
00200240  B43C 0064                491      CMP.B #'d',D2
00200244  6700 0C52                492      BEQ HEX_DIGIT
00200248  B43C 0065                493      CMP.B #'e',D2
0020024C  6700 0C4A                494      BEQ HEX_DIGIT
00200250  B43C 0066                495      CMP.B #'f',D2
00200254  6700 0C42                496      BEQ HEX_DIGIT
00200258                           497      
00200258  B43C 0077                498      CMP.B #'w',D2
0020025C  6700 015A                499      BEQ W
00200260                           500      
00200260  B43C 006C                501      CMP.B #'l',D2
00200264  6700 0AC0                502      BEQ L 
00200268                           503  
00200268                           504m     PRINT_CRLF D3
00200268                           505mm     PRINT_CHAR #13,D3                           ; CR
00200268                           506mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200268                 TRUE      507mm     IFEQ DEBUG
00200268  1639 00C00003            508mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020026E  0803 0002                509mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200272  67F4                     510mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200274  13FC 000D 00C00007       511mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020027C                           512mm     ENDC
0020027C                           513mm     
0020027C                 FALSE     514mm     IFNE DEBUG
0020027C                           515mm     ENDC
0020027C                           516mm 
0020027C                           517mm     ENDM
0020027C                           518mm     PRINT_CHAR #10,D3                           ; LF
0020027C                           519mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020027C                 TRUE      520mm     IFEQ DEBUG
0020027C  1639 00C00003            521mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200282  0803 0002                522mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200286  67F4                     523mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00200288  13FC 000A 00C00007       524mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200290                           525mm     ENDC
00200290                           526mm     
00200290                 FALSE     527mm     IFNE DEBUG
00200290                           528mm     ENDC
00200290                           529mm 
00200290                           530mm     ENDM
00200290                           531m     ENDM
00200290                           532   
00200290  B43C 003F                533      CMP.B #'?',D2
00200294  6700 0050                534      BEQ H
00200298                           535  
00200298  B43C 0076                536      CMP.B #'v',D2
0020029C  6700 006E                537      BEQ V
002002A0                           538      
002002A0  B43C 0072                539      CMP.B #'r',D2
002002A4  6700 008C                540      BEQ R
002002A8                           541  
002002A8  B43C 0073                542      CMP.B #'s',D2
002002AC  6700 01D0                543      BEQ S
002002B0                           544  
002002B0  B43C 0067                545      CMP.B #'g',D2
002002B4  6700 0960                546      BEQ G   
002002B8                           547  
002002B8  B43C 007A                548      CMP.B #'z',D2
002002BC  6700 0960                549      BEQ Z   
002002C0                           550  
002002C0  41F9 00200F7A            551      LEA HUH,A0
002002C6                           552m     PRINT_STR A0,D3
002002C6                           553m LOOP_19
002002C6  0C10 0000                554m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CA  6700 0016                555m     BEQ EXIT_19
002002CE                           556mm     PRINT_CHAR (A0)+,D3
002002CE                           557mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002CE                 TRUE      558mm     IFEQ DEBUG
002002CE  1639 00C00003            559mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D4  0803 0002                560mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002D8  67F4                     561mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DA  13D8 00C00007            562mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E0                           563mm     ENDC
002002E0                           564mm     
002002E0                 FALSE     565mm     IFNE DEBUG
002002E0                           566mm     ENDC
002002E0                           567mm 
002002E0                           568mm     ENDM
002002E0  60E4                     569m     BRA LOOP_19
002002E2                           570m EXIT_19
002002E2                           571m     ENDM
002002E2                           572                         
002002E2  6000 FEA0                573      BRA MAIN_LOOP
002002E6                           574      
002002E6                           575  ; commands
002002E6                           576  H   
002002E6  41F9 00200ED5            577      LEA HELP,A0
002002EC                           578m     PRINT_STR A0,D3
002002EC                           579m LOOP_21
002002EC  0C10 0000                580m     CMP.B #0,(A0)                               ; 0 -> DONE
002002F0  6700 0016                581m     BEQ EXIT_21
002002F4                           582mm     PRINT_CHAR (A0)+,D3
002002F4                           583mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002F4                 TRUE      584mm     IFEQ DEBUG
002002F4  1639 00C00003            585mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002FA  0803 0002                586mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002FE  67F4                     587mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00200300  13D8 00C00007            588mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200306                           589mm     ENDC
00200306                           590mm     
00200306                 FALSE     591mm     IFNE DEBUG
00200306                           592mm     ENDC
00200306                           593mm 
00200306                           594mm     ENDM
00200306  60E4                     595m     BRA LOOP_21
00200308                           596m EXIT_21
00200308                           597m     ENDM
00200308  6000 FE7A                598      BRA MAIN_LOOP
0020030C                           599  
0020030C                           600  V   
0020030C  41F9 00200EB8            601      LEA VERSION,A0
00200312                           602m     PRINT_STR A0,D3       
00200312                           603m LOOP_23
00200312  0C10 0000                604m     CMP.B #0,(A0)                               ; 0 -> DONE
00200316  6700 0016                605m     BEQ EXIT_23
0020031A                           606mm     PRINT_CHAR (A0)+,D3
0020031A                           607mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020031A                 TRUE      608mm     IFEQ DEBUG
0020031A  1639 00C00003            609mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200320  0803 0002                610mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200324  67F4                     611mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200326  13D8 00C00007            612mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020032C                           613mm     ENDC
0020032C                           614mm     
0020032C                 FALSE     615mm     IFNE DEBUG
0020032C                           616mm     ENDC
0020032C                           617mm 
0020032C                           618mm     ENDM
0020032C  60E4                     619m     BRA LOOP_23
0020032E                           620m EXIT_23
0020032E                           621m     ENDM
0020032E  6000 FE54                622      BRA MAIN_LOOP
00200332                           623      
00200332                           624  R   
00200332  2047                     625      MOVE.L D7,A0                                ; address accumulator -> address register
00200334  2A10                     626      MOVE.L (A0),D5                              ; read the memory and print it
00200336                           627m     PRINT_REG D5,D3,D7,D6,A0
00200336                           628mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200336                           629mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200336                 TRUE      630mm     IFEQ DEBUG
00200336  1639 00C00003            631mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020033C  0803 0002                632mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200340  67F4                     633mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200342  13FC 0030 00C00007       634mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020034A                           635mm     ENDC
0020034A                           636mm     
0020034A                 FALSE     637mm     IFNE DEBUG
0020034A                           638mm     ENDC
0020034A                           639mm 
0020034A                           640mm     ENDM
0020034A                           641mm     PRINT_CHAR #'x',D3
0020034A                           642mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034A                 TRUE      643mm     IFEQ DEBUG
0020034A  1639 00C00003            644mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200350  0803 0002                645mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200354  67F4                     646mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
00200356  13FC 0078 00C00007       647mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020035E                           648mm     ENDC
0020035E                           649mm     
0020035E                 FALSE     650mm     IFNE DEBUG
0020035E                           651mm     ENDC
0020035E                           652mm 
0020035E                           653mm     ENDM
0020035E  7C07                     654m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200360                           655m LOOP_25
00200360                           656mm     BIN2HEX D5,D7,A0
00200360  41F9 00200FDE            657mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200366  E99D                     658mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200368  1E05                     659mm     MOVE.B D5,D7
0020036A  0287 0000000F            660mm     ANDI.L #$F,D7
00200370  1E30 7000                661mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00200374                           662mm     ENDM
00200374                           663mm     PRINT_CHAR D7,D3
00200374                           664mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200374                 TRUE      665mm     IFEQ DEBUG
00200374  1639 00C00003            666mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020037A  0803 0002                667mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020037E  67F4                     668mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200380  13C7 00C00007            669mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200386                           670mm     ENDC
00200386                           671mm     
00200386                 FALSE     672mm     IFNE DEBUG
00200386                           673mm     ENDC
00200386                           674mm 
00200386                           675mm     ENDM
00200386  57CE FFD8                676m     DBEQ D6,LOOP_25
0020038A                           677m     ENDM
0020038A                           678m     PRINT_CRLF D3
0020038A                           679mm     PRINT_CHAR #13,D3                           ; CR
0020038A                           680mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      681mm     IFEQ DEBUG
0020038A  1639 00C00003            682mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                683mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     684mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
00200396  13FC 000D 00C00007       685mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020039E                           686mm     ENDC
0020039E                           687mm     
0020039E                 FALSE     688mm     IFNE DEBUG
0020039E                           689mm     ENDC
0020039E                           690mm 
0020039E                           691mm     ENDM
0020039E                           692mm     PRINT_CHAR #10,D3                           ; LF
0020039E                           693mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020039E                 TRUE      694mm     IFEQ DEBUG
0020039E  1639 00C00003            695mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A4  0803 0002                696mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003A8  67F4                     697mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003AA  13FC 000A 00C00007       698mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B2                           699mm     ENDC
002003B2                           700mm     
002003B2                 FALSE     701mm     IFNE DEBUG
002003B2                           702mm     ENDC
002003B2                           703mm 
002003B2                           704mm     ENDM
002003B2                           705m     ENDM
002003B2  7E00                     706      MOVE.L #0,D7                                ; clear the now used address accumulator
002003B4  6000 FDCE                707      BRA MAIN_LOOP
002003B8                           708  
002003B8                           709  W
002003B8  7A00                     710      MOVE.L #0,D5                                ; D5 will be the value to write            
002003BA                           711  
002003BA                           712m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003BA                           713m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003BA                           714m 
002003BA                 TRUE      715m     IFEQ DEBUG
002003BA  1639 00C00003            716m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003C0  0803 0000                717m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003C4  67F4                     718m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003C6                           719m     ENDC
002003C6                           720m     
002003C6                           721mm     READ_CHAR D2
002003C6                 TRUE      722mm     IFEQ DEBUG
002003C6  1439 00C00007            723mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003CC                           724mm     ENDC
002003CC                 FALSE     725mm     IFNE DEBUG
002003CC                           726mm     ENDC
002003CC                           727mm      
002003CC  B43C 001B                728mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003D0  6700 FC36                729mm     BEQ START
002003D4                           730mm     ENDM
002003D4                           731m 
002003D4                 TRUE      732m     IFEQ DEBUG
002003D4                           733mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003D4                           734mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D4                 TRUE      735mm     IFEQ DEBUG
002003D4  1639 00C00003            736mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003DA  0803 0002                737mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003DE  67F4                     738mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003E0  13C2 00C00007            739mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003E6                           740mm     ENDC
002003E6                           741mm     
002003E6                 FALSE     742mm     IFNE DEBUG
002003E6                           743mm     ENDC
002003E6                           744mm 
002003E6                           745mm     ENDM
002003E6                           746m     ENDC
002003E6                           747m     ENDM
002003E6                           748m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003E6  41F9 00200FEE            749m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002003EC  0402 0030                750m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002003F0  C4BC 000000FF            751m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002003F6  1430 2000                752m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002003FA                           753m     ENDM
002003FA  1A02                     754      MOVE.B D2,D5                                ; put at bottom of D5
002003FC                           755  
002003FC  3C3C 0006                756      MOVE #6,D6                                  ; 7 bytes left to read
00200400                           757      
00200400                           758  READ_DATA_TO_POKE
00200400  E98D                     759      LSL.L #4,D5                                 ; make what we have so far more significant
00200402                           760m     WAIT_CHAR D2,D3                             ; next character -> D2
00200402                           761m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200402                           762m 
00200402                 TRUE      763m     IFEQ DEBUG
00200402  1639 00C00003            764m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200408  0803 0000                765m         BTST #0,D3                              ; CHECK FOR CHARACTER
0020040C  67F4                     766m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
0020040E                           767m     ENDC
0020040E                           768m     
0020040E                           769mm     READ_CHAR D2
0020040E                 TRUE      770mm     IFEQ DEBUG
0020040E  1439 00C00007            771mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200414                           772mm     ENDC
00200414                 FALSE     773mm     IFNE DEBUG
00200414                           774mm     ENDC
00200414                           775mm      
00200414  B43C 001B                776mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200418  6700 FBEE                777mm     BEQ START
0020041C                           778mm     ENDM
0020041C                           779m 
0020041C                 TRUE      780m     IFEQ DEBUG
0020041C                           781mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0020041C                           782mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041C                 TRUE      783mm     IFEQ DEBUG
0020041C  1639 00C00003            784mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200422  0803 0002                785mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200426  67F4                     786mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200428  13C2 00C00007            787mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020042E                           788mm     ENDC
0020042E                           789mm     
0020042E                 FALSE     790mm     IFNE DEBUG
0020042E                           791mm     ENDC
0020042E                           792mm 
0020042E                           793mm     ENDM
0020042E                           794m     ENDC
0020042E                           795m     ENDM
0020042E                           796m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0020042E  41F9 00200FEE            797m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200434  0402 0030                798m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200438  C4BC 000000FF            799m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020043E  1430 2000                800m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200442                           801m     ENDM
00200442  8A02                     802      OR.B D2,D5
00200444  023C 00FB                803      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200448  57CE FFB6                804      DBEQ D6,READ_DATA_TO_POKE
0020044C                           805      
0020044C  2047                     806      MOVE.L D7,A0                                ; address accumulator -> address register
0020044E  7E00                     807      MOVE.L #0,D7                                ; clear the now used address accumulator
00200450                           808      
00200450  2085                     809      MOVE.L D5,(A0)                              ; write the data
00200452                           810  
00200452                           811m     PRINT_CRLF D3
00200452                           812mm     PRINT_CHAR #13,D3                           ; CR
00200452                           813mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200452                 TRUE      814mm     IFEQ DEBUG
00200452  1639 00C00003            815mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200458  0803 0002                816mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020045C  67F4                     817mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0020045E  13FC 000D 00C00007       818mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200466                           819mm     ENDC
00200466                           820mm     
00200466                 FALSE     821mm     IFNE DEBUG
00200466                           822mm     ENDC
00200466                           823mm 
00200466                           824mm     ENDM
00200466                           825mm     PRINT_CHAR #10,D3                           ; LF
00200466                           826mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200466                 TRUE      827mm     IFEQ DEBUG
00200466  1639 00C00003            828mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020046C  0803 0002                829mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200470  67F4                     830mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
00200472  13FC 000A 00C00007       831mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047A                           832mm     ENDC
0020047A                           833mm     
0020047A                 FALSE     834mm     IFNE DEBUG
0020047A                           835mm     ENDC
0020047A                           836mm 
0020047A                           837mm     ENDM
0020047A                           838m     ENDM
0020047A  6000 FD08                839      BRA MAIN_LOOP
0020047E                           840  
0020047E                           841          
0020047E                           842  S
0020047E  2647                     843      MOVE.L D7,A3                                ; grab the address accumulator
00200480  7800                     844      MOVE.L #0,D4                                ; count of records read -> D4
00200482  2478 0000                845      MOVE.L 0,A2                                 ; start address -> A2
00200486                           846      
00200486                           847  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
00200486                           848m     DOWNLOAD D2                 
00200486                           849m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200486                           850m 
00200486  1439 00C00003            851m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020048C  0802 0000                852m     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200490  6700 0010                853m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00200494                           854m  
00200494                           855mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200494                 TRUE      856mm     IFEQ DEBUG
00200494  1439 00C00007            857mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020049A                           858mm     ENDC
0020049A                 FALSE     859mm     IFNE DEBUG
0020049A                           860mm     ENDC
0020049A                           861mm      
0020049A  B43C 001B                862mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020049E  6700 FB68                863mm     BEQ START
002004A2                           864mm     ENDM
002004A2                           865m CONTINUE_44
002004A2  1439 00C00013            866m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002004A8  0802 0000                867m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004AC  67D8                     868m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004AE                           869m     
002004AE  1439 00C00017            870m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004B4  13C2 00E00001            871m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004BA                           872m     
002004BA                           873m     ENDM
002004BA  B43C 0053                874      CMP.B #'S',D2                               ; found S?    
002004BE  66C6                     875      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004C0                           876      
002004C0                           877m     PRINT_CHAR #'S',D3                          ; print it
002004C0                           878m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004C0                 TRUE      879m     IFEQ DEBUG
002004C0  1639 00C00003            880m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002004C6  0803 0002                881m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002004CA  67F4                     882m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004CC  13FC 0053 00C00007       883m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004D4                           884m     ENDC
002004D4                           885m     
002004D4                 FALSE     886m     IFNE DEBUG
002004D4                           887m     ENDC
002004D4                           888m 
002004D4                           889m     ENDM
002004D4  5284                     890      ADD.L #1,D4                                 ; read another S record, increment count
002004D6                           891      
002004D6                           892m     DOWNLOAD D0                                 ; read the record identifier
002004D6                           893m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004D6                           894m 
002004D6  1039 00C00003            895m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
002004DC  0800 0000                896m     BTST #0,D0                                  ; CHECK FOR CHARACTER
002004E0  6700 0010                897m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004E4                           898m  
002004E4                           899mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
002004E4                 TRUE      900mm     IFEQ DEBUG
002004E4  1039 00C00007            901mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
002004EA                           902mm     ENDC
002004EA                 FALSE     903mm     IFNE DEBUG
002004EA                           904mm     ENDC
002004EA                           905mm      
002004EA  B03C 001B                906mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
002004EE  6700 FB18                907mm     BEQ START
002004F2                           908mm     ENDM
002004F2                           909m CONTINUE_47
002004F2  1039 00C00013            910m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
002004F8  0800 0000                911m     BTST #0,D0                                  ; CHECK FOR CHARACTER
002004FC  67D8                     912m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
002004FE                           913m     
002004FE  1039 00C00017            914m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
00200504  13C0 00E00001            915m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
0020050A                           916m     
0020050A                           917m     ENDM
0020050A                           918m     PRINT_CHAR D0,D3                            ; print it
0020050A                           919m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020050A                 TRUE      920m     IFEQ DEBUG
0020050A  1639 00C00003            921m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200510  0803 0002                922m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200514  67F4                     923m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200516  13C0 00C00007            924m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020051C                           925m     ENDC
0020051C                           926m     
0020051C                 FALSE     927m     IFNE DEBUG
0020051C                           928m     ENDC
0020051C                           929m 
0020051C                           930m     ENDM
0020051C                           931  
0020051C  7C00                     932      MOVE.L #0,D6                                ; clear the checksum
0020051E                           933  
0020051E  7A00                     934      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00200520                           935m     DOWNLOAD_BYTE D2,D5,D3,D1,D6,A0                                        
00200520  123C 0002                936m     MOVE.B #2,D1
00200524                           937m     WHILE.B D1 <GT> 0 DO
00200524                           938ms _10000000
00200524  B238 0000                939ms     CMP.B   0,D1
00200528  6F00 0064                940ms     BLE _10000001
0020052C  E98D                     941m         LSL.L #4,D5                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0020052E                           942mm         DOWNLOAD D2
0020052E                           943mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020052E                           944mm 
0020052E  1439 00C00003            945mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200534  0802 0000                946mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200538  6700 0010                947mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
0020053C                           948mm  
0020053C                           949mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020053C                 TRUE      950mmm     IFEQ DEBUG
0020053C  1439 00C00007            951mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200542                           952mmm     ENDC
00200542                 FALSE     953mmm     IFNE DEBUG
00200542                           954mmm     ENDC
00200542                           955mmm      
00200542  B43C 001B                956mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200546  6700 FAC0                957mmm     BEQ START
0020054A                           958mmm     ENDM
0020054A                           959mm CONTINUE_51
0020054A  1439 00C00013            960mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200550  0802 0000                961mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200554  67D8                     962mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
00200556                           963mm     
00200556  1439 00C00017            964mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020055C  13C2 00E00001            965mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200562                           966mm     
00200562                           967mm     ENDM
00200562                           968mm         PRINT_CHAR D2,D3
00200562                           969mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200562                 TRUE      970mm     IFEQ DEBUG
00200562  1639 00C00003            971mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200568  0803 0002                972mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020056C  67F4                     973mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
0020056E  13C2 00C00007            974mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200574                           975mm     ENDC
00200574                           976mm     
00200574                 FALSE     977mm     IFNE DEBUG
00200574                           978mm     ENDC
00200574                           979mm 
00200574                           980mm     ENDM
00200574                           981mm         HEX2BIN D2,D2,A0
00200574  41F9 00200FEE            982mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020057A  0402 0030                983mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020057E  C4BC 000000FF            984mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200584  1430 2000                985mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200588                           986mm     ENDM
00200588  8A02                     987m         OR.B D2,D5
0020058A  5301                     988m         SUB.B #1,D1
0020058C                           989m     ENDW
0020058C  6096                     990ms     BRA _10000000
0020058E                           991ms _10000001
0020058E                           992m     
0020058E  7400                     993m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200590  1405                     994m     MOVE.B D5,D2
00200592  DC85                     995m     ADD.L D5,D6
00200594                           996m 
00200594                           997m     ENDM
00200594                           998  
00200594                           999      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
00200594  B03C 0030               1000s     CMP.B   #'0',D0
00200598  6600 0032               1001s     BNE.L   _00000000
0020059C                          1002m         PRINT_CRLF D3
0020059C                          1003mm     PRINT_CHAR #13,D3                           ; CR
0020059C                          1004mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020059C                 TRUE     1005mm     IFEQ DEBUG
0020059C  1639 00C00003           1006mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005A2  0803 0002               1007mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005A6  67F4                    1008mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
002005A8  13FC 000D 00C00007      1009mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005B0                          1010mm     ENDC
002005B0                          1011mm     
002005B0                 FALSE    1012mm     IFNE DEBUG
002005B0                          1013mm     ENDC
002005B0                          1014mm 
002005B0                          1015mm     ENDM
002005B0                          1016mm     PRINT_CHAR #10,D3                           ; LF
002005B0                          1017mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B0                 TRUE     1018mm     IFEQ DEBUG
002005B0  1639 00C00003           1019mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005B6  0803 0002               1020mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005BA  67F4                    1021mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005BC  13FC 000A 00C00007      1022mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005C4                          1023mm     ENDC
002005C4                          1024mm     
002005C4                 FALSE    1025mm     IFNE DEBUG
002005C4                          1026mm     ENDC
002005C4                          1027mm 
002005C4                          1028mm     ENDM
002005C4                          1029m     ENDM
002005C4  6000 FEC0               1030          BRA WAIT_FOR_SRECORD
002005C8                          1031      ELSE
002005C8  6000 040A               1032s     BRA _00000001
002005CC                          1033s _00000000
002005CC                          1034          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
002005CC  B03C 0031               1035s     CMP.B   #'1',D0
002005D0  6708                    1036s     BEQ.S   _00000002
002005D2  B03C 0032               1037s     CMP.B   #'2',D0
002005D6  6600 0202               1038s     BNE.L   _00000003
002005DA                          1039s _00000002
002005DA  5785                    1040              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
002005DC                          1041      
002005DC  7E00                    1042              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
002005DE                          1043m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; first byte                           
002005DE  123C 0002               1044m     MOVE.B #2,D1
002005E2                          1045m     WHILE.B D1 <GT> 0 DO
002005E2                          1046ms _10000002
002005E2  B238 0000               1047ms     CMP.B   0,D1
002005E6  6F00 0064               1048ms     BLE _10000003
002005EA  E98F                    1049m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002005EC                          1050mm         DOWNLOAD D2
002005EC                          1051mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005EC                          1052mm 
002005EC  1439 00C00003           1053mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002005F2  0802 0000               1054mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002005F6  6700 0010               1055mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
002005FA                          1056mm  
002005FA                          1057mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002005FA                 TRUE     1058mmm     IFEQ DEBUG
002005FA  1439 00C00007           1059mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200600                          1060mmm     ENDC
00200600                 FALSE    1061mmm     IFNE DEBUG
00200600                          1062mmm     ENDC
00200600                          1063mmm      
00200600  B43C 001B               1064mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200604  6700 FA02               1065mmm     BEQ START
00200608                          1066mmm     ENDM
00200608                          1067mm CONTINUE_59
00200608  1439 00C00013           1068mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020060E  0802 0000               1069mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200612  67D8                    1070mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00200614                          1071mm     
00200614  1439 00C00017           1072mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020061A  13C2 00E00001           1073mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200620                          1074mm     
00200620                          1075mm     ENDM
00200620                          1076mm         PRINT_CHAR D2,D3
00200620                          1077mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200620                 TRUE     1078mm     IFEQ DEBUG
00200620  1639 00C00003           1079mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200626  0803 0002               1080mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020062A  67F4                    1081mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
0020062C  13C2 00C00007           1082mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200632                          1083mm     ENDC
00200632                          1084mm     
00200632                 FALSE    1085mm     IFNE DEBUG
00200632                          1086mm     ENDC
00200632                          1087mm 
00200632                          1088mm     ENDM
00200632                          1089mm         HEX2BIN D2,D2,A0
00200632  41F9 00200FEE           1090mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200638  0402 0030               1091mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020063C  C4BC 000000FF           1092mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200642  1430 2000               1093mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200646                          1094mm     ENDM
00200646  8E02                    1095m         OR.B D2,D7
00200648  5301                    1096m         SUB.B #1,D1
0020064A                          1097m     ENDW
0020064A  6096                    1098ms     BRA _10000002
0020064C                          1099ms _10000003
0020064C                          1100m     
0020064C  7400                    1101m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020064E  1407                    1102m     MOVE.B D7,D2
00200650  DC87                    1103m     ADD.L D7,D6
00200652                          1104m 
00200652                          1105m     ENDM
00200652                          1106m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; second one
00200652  123C 0002               1107m     MOVE.B #2,D1
00200656                          1108m     WHILE.B D1 <GT> 0 DO
00200656                          1109ms _10000004
00200656  B238 0000               1110ms     CMP.B   0,D1
0020065A  6F00 0064               1111ms     BLE _10000005
0020065E  E98F                    1112m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200660                          1113mm         DOWNLOAD D2
00200660                          1114mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200660                          1115mm 
00200660  1439 00C00003           1116mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200666  0802 0000               1117mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020066A  6700 0010               1118mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
0020066E                          1119mm  
0020066E                          1120mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020066E                 TRUE     1121mmm     IFEQ DEBUG
0020066E  1439 00C00007           1122mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200674                          1123mmm     ENDC
00200674                 FALSE    1124mmm     IFNE DEBUG
00200674                          1125mmm     ENDC
00200674                          1126mmm      
00200674  B43C 001B               1127mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200678  6700 F98E               1128mmm     BEQ START
0020067C                          1129mmm     ENDM
0020067C                          1130mm CONTINUE_64
0020067C  1439 00C00013           1131mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200682  0802 0000               1132mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200686  67D8                    1133mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00200688                          1134mm     
00200688  1439 00C00017           1135mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020068E  13C2 00E00001           1136mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200694                          1137mm     
00200694                          1138mm     ENDM
00200694                          1139mm         PRINT_CHAR D2,D3
00200694                          1140mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200694                 TRUE     1141mm     IFEQ DEBUG
00200694  1639 00C00003           1142mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020069A  0803 0002               1143mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020069E  67F4                    1144mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006A0  13C2 00C00007           1145mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006A6                          1146mm     ENDC
002006A6                          1147mm     
002006A6                 FALSE    1148mm     IFNE DEBUG
002006A6                          1149mm     ENDC
002006A6                          1150mm 
002006A6                          1151mm     ENDM
002006A6                          1152mm         HEX2BIN D2,D2,A0
002006A6  41F9 00200FEE           1153mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006AC  0402 0030               1154mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006B0  C4BC 000000FF           1155mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006B6  1430 2000               1156mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006BA                          1157mm     ENDM
002006BA  8E02                    1158m         OR.B D2,D7
002006BC  5301                    1159m         SUB.B #1,D1
002006BE                          1160m     ENDW
002006BE  6096                    1161ms     BRA _10000004
002006C0                          1162ms _10000005
002006C0                          1163m     
002006C0  7400                    1164m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006C2  1407                    1165m     MOVE.B D7,D2
002006C4  DC87                    1166m     ADD.L D7,D6
002006C6                          1167m 
002006C6                          1168m     ENDM
002006C6                          1169              
002006C6                          1170              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
002006C6  B03C 0032               1171s     CMP.B   #'2',D0
002006CA  6600 0078               1172s     BNE.L   _00000004
002006CE  5385                    1173                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address    
002006D0                          1174m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; 3rd byte       
002006D0  123C 0002               1175m     MOVE.B #2,D1
002006D4                          1176m     WHILE.B D1 <GT> 0 DO
002006D4                          1177ms _10000006
002006D4  B238 0000               1178ms     CMP.B   0,D1
002006D8  6F00 0064               1179ms     BLE _10000007
002006DC  E98F                    1180m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002006DE                          1181mm         DOWNLOAD D2
002006DE                          1182mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006DE                          1183mm 
002006DE  1439 00C00003           1184mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002006E4  0802 0000               1185mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002006E8  6700 0010               1186mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
002006EC                          1187mm  
002006EC                          1188mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002006EC                 TRUE     1189mmm     IFEQ DEBUG
002006EC  1439 00C00007           1190mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002006F2                          1191mmm     ENDC
002006F2                 FALSE    1192mmm     IFNE DEBUG
002006F2                          1193mmm     ENDC
002006F2                          1194mmm      
002006F2  B43C 001B               1195mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002006F6  6700 F910               1196mmm     BEQ START
002006FA                          1197mmm     ENDM
002006FA                          1198mm CONTINUE_69
002006FA  1439 00C00013           1199mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200700  0802 0000               1200mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200704  67D8                    1201mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
00200706                          1202mm     
00200706  1439 00C00017           1203mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020070C  13C2 00E00001           1204mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200712                          1205mm     
00200712                          1206mm     ENDM
00200712                          1207mm         PRINT_CHAR D2,D3
00200712                          1208mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200712                 TRUE     1209mm     IFEQ DEBUG
00200712  1639 00C00003           1210mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200718  0803 0002               1211mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020071C  67F4                    1212mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0020071E  13C2 00C00007           1213mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200724                          1214mm     ENDC
00200724                          1215mm     
00200724                 FALSE    1216mm     IFNE DEBUG
00200724                          1217mm     ENDC
00200724                          1218mm 
00200724                          1219mm     ENDM
00200724                          1220mm         HEX2BIN D2,D2,A0
00200724  41F9 00200FEE           1221mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020072A  0402 0030               1222mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020072E  C4BC 000000FF           1223mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200734  1430 2000               1224mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200738                          1225mm     ENDM
00200738  8E02                    1226m         OR.B D2,D7
0020073A  5301                    1227m         SUB.B #1,D1
0020073C                          1228m     ENDW
0020073C  6096                    1229ms     BRA _10000006
0020073E                          1230ms _10000007
0020073E                          1231m     
0020073E  7400                    1232m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200740  1407                    1233m     MOVE.B D7,D2
00200742  DC87                    1234m     ADD.L D7,D6
00200744                          1235m 
00200744                          1236m     ENDM
00200744                          1237              ENDI
00200744                          1238s _00000004
00200744                          1239              
00200744  2247                    1240              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
00200746  D3CB                    1241              ADD.L A3,A1                         ; add in the offset
00200748                          1242  
00200748                          1243              WHILE.L D5 <GT> #0 DO               ; read the data bytes                
00200748                          1244s _10000008
00200748  BABC 00000000           1245s     CMP.L   #0,D5
0020074E  6F00 0080               1246s     BLE _10000009
00200752  7E00                    1247                  MOVE.L #0,D7                    ; D7 holds the byte
00200754                          1248m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; read it                               
00200754  123C 0002               1249m     MOVE.B #2,D1
00200758                          1250m     WHILE.B D1 <GT> 0 DO
00200758                          1251ms _1000000A
00200758  B238 0000               1252ms     CMP.B   0,D1
0020075C  6F00 0064               1253ms     BLE _1000000B
00200760  E98F                    1254m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200762                          1255mm         DOWNLOAD D2
00200762                          1256mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200762                          1257mm 
00200762  1439 00C00003           1258mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200768  0802 0000               1259mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020076C  6700 0010               1260mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00200770                          1261mm  
00200770                          1262mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200770                 TRUE     1263mmm     IFEQ DEBUG
00200770  1439 00C00007           1264mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200776                          1265mmm     ENDC
00200776                 FALSE    1266mmm     IFNE DEBUG
00200776                          1267mmm     ENDC
00200776                          1268mmm      
00200776  B43C 001B               1269mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020077A  6700 F88C               1270mmm     BEQ START
0020077E                          1271mmm     ENDM
0020077E                          1272mm CONTINUE_74
0020077E  1439 00C00013           1273mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200784  0802 0000               1274mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200788  67D8                    1275mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0020078A                          1276mm     
0020078A  1439 00C00017           1277mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200790  13C2 00E00001           1278mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200796                          1279mm     
00200796                          1280mm     ENDM
00200796                          1281mm         PRINT_CHAR D2,D3
00200796                          1282mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200796                 TRUE     1283mm     IFEQ DEBUG
00200796  1639 00C00003           1284mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020079C  0803 0002               1285mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007A0  67F4                    1286mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
002007A2  13C2 00C00007           1287mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007A8                          1288mm     ENDC
002007A8                          1289mm     
002007A8                 FALSE    1290mm     IFNE DEBUG
002007A8                          1291mm     ENDC
002007A8                          1292mm 
002007A8                          1293mm     ENDM
002007A8                          1294mm         HEX2BIN D2,D2,A0
002007A8  41F9 00200FEE           1295mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002007AE  0402 0030               1296mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007B2  C4BC 000000FF           1297mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002007B8  1430 2000               1298mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002007BC                          1299mm     ENDM
002007BC  8E02                    1300m         OR.B D2,D7
002007BE  5301                    1301m         SUB.B #1,D1
002007C0                          1302m     ENDW
002007C0  6096                    1303ms     BRA _1000000A
002007C2                          1304ms _1000000B
002007C2                          1305m     
002007C2  7400                    1306m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007C4  1407                    1307m     MOVE.B D7,D2
002007C6  DC87                    1308m     ADD.L D7,D6
002007C8                          1309m 
002007C8                          1310m     ENDM
002007C8                          1311                          
002007C8  12C7                    1312                  MOVE.B D7,(A1)+                 ; store it!
002007CA                          1313  
002007CA  5385                    1314                  SUB.L #1,D5                     ; 1 less byte to go
002007CC                          1315              ENDW
002007CC  6000 FF7A               1316s     BRA _10000008
002007D0                          1317s _10000009
002007D0                          1318          
002007D0  43F9 00200486           1319              LEA WAIT_FOR_SRECORD,A1             ; next place to go
002007D6                          1320          ELSE
002007D6  6000 01FC               1321s     BRA _00000005
002007DA                          1322s _00000003
002007DA                          1323              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
002007DA  B03C 0038               1324s     CMP.B   #'8',D0
002007DE  6600 016C               1325s     BNE.L   _00000006
002007E2  7E00                    1326                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007E4                          1327m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; top byte  
002007E4  123C 0002               1328m     MOVE.B #2,D1
002007E8                          1329m     WHILE.B D1 <GT> 0 DO
002007E8                          1330ms _1000000C
002007E8  B238 0000               1331ms     CMP.B   0,D1
002007EC  6F00 0064               1332ms     BLE _1000000D
002007F0  E98F                    1333m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002007F2                          1334mm         DOWNLOAD D2
002007F2                          1335mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007F2                          1336mm 
002007F2  1439 00C00003           1337mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002007F8  0802 0000               1338mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002007FC  6700 0010               1339mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
00200800                          1340mm  
00200800                          1341mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200800                 TRUE     1342mmm     IFEQ DEBUG
00200800  1439 00C00007           1343mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200806                          1344mmm     ENDC
00200806                 FALSE    1345mmm     IFNE DEBUG
00200806                          1346mmm     ENDC
00200806                          1347mmm      
00200806  B43C 001B               1348mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020080A  6700 F7FC               1349mmm     BEQ START
0020080E                          1350mmm     ENDM
0020080E                          1351mm CONTINUE_79
0020080E  1439 00C00013           1352mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200814  0802 0000               1353mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200818  67D8                    1354mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
0020081A                          1355mm     
0020081A  1439 00C00017           1356mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200820  13C2 00E00001           1357mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200826                          1358mm     
00200826                          1359mm     ENDM
00200826                          1360mm         PRINT_CHAR D2,D3
00200826                          1361mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200826                 TRUE     1362mm     IFEQ DEBUG
00200826  1639 00C00003           1363mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020082C  0803 0002               1364mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200830  67F4                    1365mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00200832  13C2 00C00007           1366mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200838                          1367mm     ENDC
00200838                          1368mm     
00200838                 FALSE    1369mm     IFNE DEBUG
00200838                          1370mm     ENDC
00200838                          1371mm 
00200838                          1372mm     ENDM
00200838                          1373mm         HEX2BIN D2,D2,A0
00200838  41F9 00200FEE           1374mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020083E  0402 0030               1375mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200842  C4BC 000000FF           1376mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200848  1430 2000               1377mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020084C                          1378mm     ENDM
0020084C  8E02                    1379m         OR.B D2,D7
0020084E  5301                    1380m         SUB.B #1,D1
00200850                          1381m     ENDW
00200850  6096                    1382ms     BRA _1000000C
00200852                          1383ms _1000000D
00200852                          1384m     
00200852  7400                    1385m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200854  1407                    1386m     MOVE.B D7,D2
00200856  DC87                    1387m     ADD.L D7,D6
00200858                          1388m 
00200858                          1389m     ENDM
00200858                          1390m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; middle byte     
00200858  123C 0002               1391m     MOVE.B #2,D1
0020085C                          1392m     WHILE.B D1 <GT> 0 DO
0020085C                          1393ms _1000000E
0020085C  B238 0000               1394ms     CMP.B   0,D1
00200860  6F00 0064               1395ms     BLE _1000000F
00200864  E98F                    1396m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00200866                          1397mm         DOWNLOAD D2
00200866                          1398mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200866                          1399mm 
00200866  1439 00C00003           1400mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020086C  0802 0000               1401mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200870  6700 0010               1402mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00200874                          1403mm  
00200874                          1404mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200874                 TRUE     1405mmm     IFEQ DEBUG
00200874  1439 00C00007           1406mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020087A                          1407mmm     ENDC
0020087A                 FALSE    1408mmm     IFNE DEBUG
0020087A                          1409mmm     ENDC
0020087A                          1410mmm      
0020087A  B43C 001B               1411mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020087E  6700 F788               1412mmm     BEQ START
00200882                          1413mmm     ENDM
00200882                          1414mm CONTINUE_84
00200882  1439 00C00013           1415mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200888  0802 0000               1416mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020088C  67D8                    1417mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0020088E                          1418mm     
0020088E  1439 00C00017           1419mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200894  13C2 00E00001           1420mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020089A                          1421mm     
0020089A                          1422mm     ENDM
0020089A                          1423mm         PRINT_CHAR D2,D3
0020089A                          1424mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020089A                 TRUE     1425mm     IFEQ DEBUG
0020089A  1639 00C00003           1426mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008A0  0803 0002               1427mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008A4  67F4                    1428mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008A6  13C2 00C00007           1429mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008AC                          1430mm     ENDC
002008AC                          1431mm     
002008AC                 FALSE    1432mm     IFNE DEBUG
002008AC                          1433mm     ENDC
002008AC                          1434mm 
002008AC                          1435mm     ENDM
002008AC                          1436mm         HEX2BIN D2,D2,A0
002008AC  41F9 00200FEE           1437mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008B2  0402 0030               1438mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008B6  C4BC 000000FF           1439mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008BC  1430 2000               1440mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008C0                          1441mm     ENDM
002008C0  8E02                    1442m         OR.B D2,D7
002008C2  5301                    1443m         SUB.B #1,D1
002008C4                          1444m     ENDW
002008C4  6096                    1445ms     BRA _1000000E
002008C6                          1446ms _1000000F
002008C6                          1447m     
002008C6  7400                    1448m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002008C8  1407                    1449m     MOVE.B D7,D2
002008CA  DC87                    1450m     ADD.L D7,D6
002008CC                          1451m 
002008CC                          1452m     ENDM
002008CC                          1453m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; bottom byte
002008CC  123C 0002               1454m     MOVE.B #2,D1
002008D0                          1455m     WHILE.B D1 <GT> 0 DO
002008D0                          1456ms _10000010
002008D0  B238 0000               1457ms     CMP.B   0,D1
002008D4  6F00 0064               1458ms     BLE _10000011
002008D8  E98F                    1459m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002008DA                          1460mm         DOWNLOAD D2
002008DA                          1461mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008DA                          1462mm 
002008DA  1439 00C00003           1463mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002008E0  0802 0000               1464mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008E4  6700 0010               1465mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
002008E8                          1466mm  
002008E8                          1467mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002008E8                 TRUE     1468mmm     IFEQ DEBUG
002008E8  1439 00C00007           1469mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008EE                          1470mmm     ENDC
002008EE                 FALSE    1471mmm     IFNE DEBUG
002008EE                          1472mmm     ENDC
002008EE                          1473mmm      
002008EE  B43C 001B               1474mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002008F2  6700 F714               1475mmm     BEQ START
002008F6                          1476mmm     ENDM
002008F6                          1477mm CONTINUE_89
002008F6  1439 00C00013           1478mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002008FC  0802 0000               1479mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200900  67D8                    1480mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00200902                          1481mm     
00200902  1439 00C00017           1482mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200908  13C2 00E00001           1483mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020090E                          1484mm     
0020090E                          1485mm     ENDM
0020090E                          1486mm         PRINT_CHAR D2,D3
0020090E                          1487mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020090E                 TRUE     1488mm     IFEQ DEBUG
0020090E  1639 00C00003           1489mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200914  0803 0002               1490mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200918  67F4                    1491mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0020091A  13C2 00C00007           1492mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200920                          1493mm     ENDC
00200920                          1494mm     
00200920                 FALSE    1495mm     IFNE DEBUG
00200920                          1496mm     ENDC
00200920                          1497mm 
00200920                          1498mm     ENDM
00200920                          1499mm         HEX2BIN D2,D2,A0
00200920  41F9 00200FEE           1500mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200926  0402 0030               1501mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020092A  C4BC 000000FF           1502mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200930  1430 2000               1503mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200934                          1504mm     ENDM
00200934  8E02                    1505m         OR.B D2,D7
00200936  5301                    1506m         SUB.B #1,D1
00200938                          1507m     ENDW
00200938  6096                    1508ms     BRA _10000010
0020093A                          1509ms _10000011
0020093A                          1510m     
0020093A  7400                    1511m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020093C  1407                    1512m     MOVE.B D7,D2
0020093E  DC87                    1513m     ADD.L D7,D6
00200940                          1514m 
00200940                          1515m     ENDM
00200940                          1516                    
00200940  2447                    1517                  MOVE.L D7,A2                    ; start address -> A2
00200942                          1518                  
00200942  43F9 00200B1E           1519                  LEA DOWNLOAD_DONE,A1            ; next place to go
00200948                          1520              ELSE
00200948  6000 008A               1521s     BRA _00000007
0020094C                          1522s _00000006
0020094C                          1523m                 PRINT_CRLF D3
0020094C                          1524mm     PRINT_CHAR #13,D3                           ; CR
0020094C                          1525mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020094C                 TRUE     1526mm     IFEQ DEBUG
0020094C  1639 00C00003           1527mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200952  0803 0002               1528mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200956  67F4                    1529mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00200958  13FC 000D 00C00007      1530mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200960                          1531mm     ENDC
00200960                          1532mm     
00200960                 FALSE    1533mm     IFNE DEBUG
00200960                          1534mm     ENDC
00200960                          1535mm 
00200960                          1536mm     ENDM
00200960                          1537mm     PRINT_CHAR #10,D3                           ; LF
00200960                          1538mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200960                 TRUE     1539mm     IFEQ DEBUG
00200960  1639 00C00003           1540mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200966  0803 0002               1541mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020096A  67F4                    1542mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0020096C  13FC 000A 00C00007      1543mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200974                          1544mm     ENDC
00200974                          1545mm     
00200974                 FALSE    1546mm     IFNE DEBUG
00200974                          1547mm     ENDC
00200974                          1548mm 
00200974                          1549mm     ENDM
00200974                          1550m     ENDM
00200974                          1551              
00200974  41F9 00200FA3           1552                  LEA UNREC,A0                    ; warn for unrecognised type
0020097A                          1553m                 PRINT_STR A0,D3
0020097A                          1554m LOOP_96
0020097A  0C10 0000               1555m     CMP.B #0,(A0)                               ; 0 -> DONE
0020097E  6700 0016               1556m     BEQ EXIT_96
00200982                          1557mm     PRINT_CHAR (A0)+,D3
00200982                          1558mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200982                 TRUE     1559mm     IFEQ DEBUG
00200982  1639 00C00003           1560mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200988  0803 0002               1561mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020098C  67F4                    1562mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
0020098E  13D8 00C00007           1563mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200994                          1564mm     ENDC
00200994                          1565mm     
00200994                 FALSE    1566mm     IFNE DEBUG
00200994                          1567mm     ENDC
00200994                          1568mm 
00200994                          1569mm     ENDM
00200994  60E4                    1570m     BRA LOOP_96
00200996                          1571m EXIT_96
00200996                          1572m     ENDM
00200996                          1573m                 PRINT_CHAR D7,D3
00200996                          1574m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200996                 TRUE     1575m     IFEQ DEBUG
00200996  1639 00C00003           1576m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020099C  0803 0002               1577m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009A0  67F4                    1578m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
002009A2  13C7 00C00007           1579m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009A8                          1580m     ENDC
002009A8                          1581m     
002009A8                 FALSE    1582m     IFNE DEBUG
002009A8                          1583m     ENDC
002009A8                          1584m 
002009A8                          1585m     ENDM
002009A8                          1586m                 PRINT_CRLF D3
002009A8                          1587mm     PRINT_CHAR #13,D3                           ; CR
002009A8                          1588mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009A8                 TRUE     1589mm     IFEQ DEBUG
002009A8  1639 00C00003           1590mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009AE  0803 0002               1591mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009B2  67F4                    1592mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
002009B4  13FC 000D 00C00007      1593mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009BC                          1594mm     ENDC
002009BC                          1595mm     
002009BC                 FALSE    1596mm     IFNE DEBUG
002009BC                          1597mm     ENDC
002009BC                          1598mm 
002009BC                          1599mm     ENDM
002009BC                          1600mm     PRINT_CHAR #10,D3                           ; LF
002009BC                          1601mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BC                 TRUE     1602mm     IFEQ DEBUG
002009BC  1639 00C00003           1603mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009C2  0803 0002               1604mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009C6  67F4                    1605mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
002009C8  13FC 000A 00C00007      1606mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009D0                          1607mm     ENDC
002009D0                          1608mm     
002009D0                 FALSE    1609mm     IFNE DEBUG
002009D0                          1610mm     ENDC
002009D0                          1611mm 
002009D0                          1612mm     ENDM
002009D0                          1613m     ENDM
002009D0                          1614              
002009D0  6000 FAB4               1615                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
002009D4                          1616              ENDI
002009D4                          1617s _00000007
002009D4                          1618          ENDI
002009D4                          1619s _00000005
002009D4                          1620      ENDI
002009D4                          1621s _00000001
002009D4                          1622      
002009D4  7E00                    1623      MOVE.L #0,D7                                ; read the checksum from the data stream, and add into the inverted checksum: should make it FF
002009D6                          1624m     DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0                         
002009D6  123C 0002               1625m     MOVE.B #2,D1
002009DA                          1626m     WHILE.B D1 <GT> 0 DO
002009DA                          1627ms _10000012
002009DA  B238 0000               1628ms     CMP.B   0,D1
002009DE  6F00 0064               1629ms     BLE _10000013
002009E2  E98F                    1630m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
002009E4                          1631mm         DOWNLOAD D2
002009E4                          1632mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009E4                          1633mm 
002009E4  1439 00C00003           1634mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002009EA  0802 0000               1635mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002009EE  6700 0010               1636mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
002009F2                          1637mm  
002009F2                          1638mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002009F2                 TRUE     1639mmm     IFEQ DEBUG
002009F2  1439 00C00007           1640mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002009F8                          1641mmm     ENDC
002009F8                 FALSE    1642mmm     IFNE DEBUG
002009F8                          1643mmm     ENDC
002009F8                          1644mmm      
002009F8  B43C 001B               1645mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002009FC  6700 F60A               1646mmm     BEQ START
00200A00                          1647mmm     ENDM
00200A00                          1648mm CONTINUE_103
00200A00  1439 00C00013           1649mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200A06  0802 0000               1650mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A0A  67D8                    1651mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00200A0C                          1652mm     
00200A0C  1439 00C00017           1653mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A12  13C2 00E00001           1654mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A18                          1655mm     
00200A18                          1656mm     ENDM
00200A18                          1657mm         PRINT_CHAR D2,D3
00200A18                          1658mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A18                 TRUE     1659mm     IFEQ DEBUG
00200A18  1639 00C00003           1660mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A1E  0803 0002               1661mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A22  67F4                    1662mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00200A24  13C2 00C00007           1663mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A2A                          1664mm     ENDC
00200A2A                          1665mm     
00200A2A                 FALSE    1666mm     IFNE DEBUG
00200A2A                          1667mm     ENDC
00200A2A                          1668mm 
00200A2A                          1669mm     ENDM
00200A2A                          1670mm         HEX2BIN D2,D2,A0
00200A2A  41F9 00200FEE           1671mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A30  0402 0030               1672mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A34  C4BC 000000FF           1673mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A3A  1430 2000               1674mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A3E                          1675mm     ENDM
00200A3E  8E02                    1676m         OR.B D2,D7
00200A40  5301                    1677m         SUB.B #1,D1
00200A42                          1678m     ENDW
00200A42  6096                    1679ms     BRA _10000012
00200A44                          1680ms _10000013
00200A44                          1681m     
00200A44  7400                    1682m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200A46  1407                    1683m     MOVE.B D7,D2
00200A48  DC87                    1684m     ADD.L D7,D6
00200A4A                          1685m 
00200A4A                          1686m     ENDM
00200A4A                          1687m     PRINT_CRLF D3
00200A4A                          1688mm     PRINT_CHAR #13,D3                           ; CR
00200A4A                          1689mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A4A                 TRUE     1690mm     IFEQ DEBUG
00200A4A  1639 00C00003           1691mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A50  0803 0002               1692mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A54  67F4                    1693mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A56  13FC 000D 00C00007      1694mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A5E                          1695mm     ENDC
00200A5E                          1696mm     
00200A5E                 FALSE    1697mm     IFNE DEBUG
00200A5E                          1698mm     ENDC
00200A5E                          1699mm 
00200A5E                          1700mm     ENDM
00200A5E                          1701mm     PRINT_CHAR #10,D3                           ; LF
00200A5E                          1702mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A5E                 TRUE     1703mm     IFEQ DEBUG
00200A5E  1639 00C00003           1704mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A64  0803 0002               1705mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A68  67F4                    1706mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00200A6A  13FC 000A 00C00007      1707mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A72                          1708mm     ENDC
00200A72                          1709mm     
00200A72                 FALSE    1710mm     IFNE DEBUG
00200A72                          1711mm     ENDC
00200A72                          1712mm 
00200A72                          1713mm     ENDM
00200A72                          1714m     ENDM
00200A72                          1715          
00200A72                          1716      IF.B D6 <NE> #$FF THEN.L
00200A72  BC3C 00FF               1717s     CMP.B   #$FF,D6
00200A76  6700 00A4               1718s     BEQ.L   _00000008
00200A7A  41F9 00200FBA           1719          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00200A80                          1720m         PRINT_STR A0,D3
00200A80                          1721m LOOP_110
00200A80  0C10 0000               1722m     CMP.B #0,(A0)                               ; 0 -> DONE
00200A84  6700 0016               1723m     BEQ EXIT_110
00200A88                          1724mm     PRINT_CHAR (A0)+,D3
00200A88                          1725mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A88                 TRUE     1726mm     IFEQ DEBUG
00200A88  1639 00C00003           1727mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A8E  0803 0002               1728mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A92  67F4                    1729mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200A94  13D8 00C00007           1730mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200A9A                          1731mm     ENDC
00200A9A                          1732mm     
00200A9A                 FALSE    1733mm     IFNE DEBUG
00200A9A                          1734mm     ENDC
00200A9A                          1735mm 
00200A9A                          1736mm     ENDM
00200A9A  60E4                    1737m     BRA LOOP_110
00200A9C                          1738m EXIT_110
00200A9C                          1739m     ENDM
00200A9C                          1740m         PRINT_REG D4,D3,D6,D7,A0
00200A9C                          1741mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200A9C                          1742mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A9C                 TRUE     1743mm     IFEQ DEBUG
00200A9C  1639 00C00003           1744mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AA2  0803 0002               1745mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AA6  67F4                    1746mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00200AA8  13FC 0030 00C00007      1747mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AB0                          1748mm     ENDC
00200AB0                          1749mm     
00200AB0                 FALSE    1750mm     IFNE DEBUG
00200AB0                          1751mm     ENDC
00200AB0                          1752mm 
00200AB0                          1753mm     ENDM
00200AB0                          1754mm     PRINT_CHAR #'x',D3
00200AB0                          1755mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB0                 TRUE     1756mm     IFEQ DEBUG
00200AB0  1639 00C00003           1757mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AB6  0803 0002               1758mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200ABA  67F4                    1759mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200ABC  13FC 0078 00C00007      1760mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AC4                          1761mm     ENDC
00200AC4                          1762mm     
00200AC4                 FALSE    1763mm     IFNE DEBUG
00200AC4                          1764mm     ENDC
00200AC4                          1765mm 
00200AC4                          1766mm     ENDM
00200AC4  7E07                    1767m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AC6                          1768m LOOP_112
00200AC6                          1769mm     BIN2HEX D4,D6,A0
00200AC6  41F9 00200FDE           1770mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ACC  E99C                    1771mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200ACE  1C04                    1772mm     MOVE.B D4,D6
00200AD0  0286 0000000F           1773mm     ANDI.L #$F,D6
00200AD6  1C30 6000               1774mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200ADA                          1775mm     ENDM
00200ADA                          1776mm     PRINT_CHAR D6,D3
00200ADA                          1777mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200ADA                 TRUE     1778mm     IFEQ DEBUG
00200ADA  1639 00C00003           1779mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AE0  0803 0002               1780mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AE4  67F4                    1781mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200AE6  13C6 00C00007           1782mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AEC                          1783mm     ENDC
00200AEC                          1784mm     
00200AEC                 FALSE    1785mm     IFNE DEBUG
00200AEC                          1786mm     ENDC
00200AEC                          1787mm 
00200AEC                          1788mm     ENDM
00200AEC  57CF FFD8               1789m     DBEQ D7,LOOP_112
00200AF0                          1790m     ENDM
00200AF0                          1791m         PRINT_CRLF D3
00200AF0                          1792mm     PRINT_CHAR #13,D3                           ; CR
00200AF0                          1793mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF0                 TRUE     1794mm     IFEQ DEBUG
00200AF0  1639 00C00003           1795mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AF6  0803 0002               1796mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AFA  67F4                    1797mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200AFC  13FC 000D 00C00007      1798mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B04                          1799mm     ENDC
00200B04                          1800mm     
00200B04                 FALSE    1801mm     IFNE DEBUG
00200B04                          1802mm     ENDC
00200B04                          1803mm 
00200B04                          1804mm     ENDM
00200B04                          1805mm     PRINT_CHAR #10,D3                           ; LF
00200B04                          1806mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B04                 TRUE     1807mm     IFEQ DEBUG
00200B04  1639 00C00003           1808mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B0A  0803 0002               1809mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B0E  67F4                    1810mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B10  13FC 000A 00C00007      1811mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B18                          1812mm     ENDC
00200B18                          1813mm     
00200B18                 FALSE    1814mm     IFNE DEBUG
00200B18                          1815mm     ENDC
00200B18                          1816mm 
00200B18                          1817mm     ENDM
00200B18                          1818m     ENDM
00200B18  6000 F66A               1819          BRA MAIN_LOOP
00200B1C                          1820      ENDI
00200B1C                          1821s _00000008
00200B1C                          1822      
00200B1C  4ED1                    1823      JMP (A1)
00200B1E                          1824  DOWNLOAD_DONE
00200B1E                          1825m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00200B1E                          1826mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200B1E                          1827mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B1E                 TRUE     1828mm     IFEQ DEBUG
00200B1E  1639 00C00003           1829mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B24  0803 0002               1830mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B28  67F4                    1831mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200B2A  13FC 0030 00C00007      1832mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B32                          1833mm     ENDC
00200B32                          1834mm     
00200B32                 FALSE    1835mm     IFNE DEBUG
00200B32                          1836mm     ENDC
00200B32                          1837mm 
00200B32                          1838mm     ENDM
00200B32                          1839mm     PRINT_CHAR #'x',D3
00200B32                          1840mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B32                 TRUE     1841mm     IFEQ DEBUG
00200B32  1639 00C00003           1842mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B38  0803 0002               1843mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B3C  67F4                    1844mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200B3E  13FC 0078 00C00007      1845mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B46                          1846mm     ENDC
00200B46                          1847mm     
00200B46                 FALSE    1848mm     IFNE DEBUG
00200B46                          1849mm     ENDC
00200B46                          1850mm 
00200B46                          1851mm     ENDM
00200B46  7C07                    1852m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B48                          1853m LOOP_120
00200B48                          1854mm     BIN2HEX D4,D7,A0
00200B48  41F9 00200FDE           1855mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B4E  E99C                    1856mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B50  1E04                    1857mm     MOVE.B D4,D7
00200B52  0287 0000000F           1858mm     ANDI.L #$F,D7
00200B58  1E30 7000               1859mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00200B5C                          1860mm     ENDM
00200B5C                          1861mm     PRINT_CHAR D7,D3
00200B5C                          1862mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B5C                 TRUE     1863mm     IFEQ DEBUG
00200B5C  1639 00C00003           1864mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B62  0803 0002               1865mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B66  67F4                    1866mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00200B68  13C7 00C00007           1867mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B6E                          1868mm     ENDC
00200B6E                          1869mm     
00200B6E                 FALSE    1870mm     IFNE DEBUG
00200B6E                          1871mm     ENDC
00200B6E                          1872mm 
00200B6E                          1873mm     ENDM
00200B6E  57CE FFD8               1874m     DBEQ D6,LOOP_120
00200B72                          1875m     ENDM
00200B72  41F9 00200F81           1876      LEA READ,A0
00200B78                          1877m     PRINT_STR A0,D3
00200B78                          1878m LOOP_125
00200B78  0C10 0000               1879m     CMP.B #0,(A0)                               ; 0 -> DONE
00200B7C  6700 0016               1880m     BEQ EXIT_125
00200B80                          1881mm     PRINT_CHAR (A0)+,D3
00200B80                          1882mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B80                 TRUE     1883mm     IFEQ DEBUG
00200B80  1639 00C00003           1884mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B86  0803 0002               1885mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B8A  67F4                    1886mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200B8C  13D8 00C00007           1887mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200B92                          1888mm     ENDC
00200B92                          1889mm     
00200B92                 FALSE    1890mm     IFNE DEBUG
00200B92                          1891mm     ENDC
00200B92                          1892mm 
00200B92                          1893mm     ENDM
00200B92  60E4                    1894m     BRA LOOP_125
00200B94                          1895m EXIT_125
00200B94                          1896m     ENDM
00200B94  2E0A                    1897      MOVE.L A2,D7                                ; set address accumulator to start address
00200B96                          1898m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00200B96                          1899mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200B96                          1900mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B96                 TRUE     1901mm     IFEQ DEBUG
00200B96  1639 00C00003           1902mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B9C  0803 0002               1903mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BA0  67F4                    1904mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200BA2  13FC 0030 00C00007      1905mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BAA                          1906mm     ENDC
00200BAA                          1907mm     
00200BAA                 FALSE    1908mm     IFNE DEBUG
00200BAA                          1909mm     ENDC
00200BAA                          1910mm 
00200BAA                          1911mm     ENDM
00200BAA                          1912mm     PRINT_CHAR #'x',D3
00200BAA                          1913mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BAA                 TRUE     1914mm     IFEQ DEBUG
00200BAA  1639 00C00003           1915mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BB0  0803 0002               1916mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BB4  67F4                    1917mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200BB6  13FC 0078 00C00007      1918mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BBE                          1919mm     ENDC
00200BBE                          1920mm     
00200BBE                 FALSE    1921mm     IFNE DEBUG
00200BBE                          1922mm     ENDC
00200BBE                          1923mm 
00200BBE                          1924mm     ENDM
00200BBE  7C07                    1925m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200BC0                          1926m LOOP_127
00200BC0                          1927mm     BIN2HEX D7,D2,A0
00200BC0  41F9 00200FDE           1928mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200BC6  E99F                    1929mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200BC8  1407                    1930mm     MOVE.B D7,D2
00200BCA  0282 0000000F           1931mm     ANDI.L #$F,D2
00200BD0  1430 2000               1932mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200BD4                          1933mm     ENDM
00200BD4                          1934mm     PRINT_CHAR D2,D3
00200BD4                          1935mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BD4                 TRUE     1936mm     IFEQ DEBUG
00200BD4  1639 00C00003           1937mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BDA  0803 0002               1938mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BDE  67F4                    1939mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200BE0  13C2 00C00007           1940mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200BE6                          1941mm     ENDC
00200BE6                          1942mm     
00200BE6                 FALSE    1943mm     IFNE DEBUG
00200BE6                          1944mm     ENDC
00200BE6                          1945mm 
00200BE6                          1946mm     ENDM
00200BE6  57CE FFD8               1947m     DBEQ D6,LOOP_127
00200BEA                          1948m     ENDM
00200BEA                          1949m     PRINT_CRLF D3     
00200BEA                          1950mm     PRINT_CHAR #13,D3                           ; CR
00200BEA                          1951mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BEA                 TRUE     1952mm     IFEQ DEBUG
00200BEA  1639 00C00003           1953mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BF0  0803 0002               1954mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BF4  67F4                    1955mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200BF6  13FC 000D 00C00007      1956mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200BFE                          1957mm     ENDC
00200BFE                          1958mm     
00200BFE                 FALSE    1959mm     IFNE DEBUG
00200BFE                          1960mm     ENDC
00200BFE                          1961mm 
00200BFE                          1962mm     ENDM
00200BFE                          1963mm     PRINT_CHAR #10,D3                           ; LF
00200BFE                          1964mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BFE                 TRUE     1965mm     IFEQ DEBUG
00200BFE  1639 00C00003           1966mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C04  0803 0002               1967mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C08  67F4                    1968mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00200C0A  13FC 000A 00C00007      1969mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C12                          1970mm     ENDC
00200C12                          1971mm     
00200C12                 FALSE    1972mm     IFNE DEBUG
00200C12                          1973mm     ENDC
00200C12                          1974mm 
00200C12                          1975mm     ENDM
00200C12                          1976m     ENDM
00200C12                          1977          
00200C12  6000 F570               1978      BRA MAIN_LOOP
00200C16                          1979      
00200C16                          1980  G
00200C16  2047                    1981      MOVE.L D7,A0                                ; address accumulator -> address register
00200C18  3E3C 0000               1982      MOVE #0,D7                                  ; clear the now used address accumulator
00200C1C  4ED0                    1983      JMP (A0)                                    ; jump to it!
00200C1E                          1984      
00200C1E                          1985  Z
00200C1E  207C 00200000           1986      MOVE.L #RAM,A0                              ; address of RAM
00200C24  7000                    1987      MOVE.L #0,D0                                ; number of bytes
00200C26                          1988     
00200C26                          1989      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C26                          1990s _10000014
00200C26  B0BC 00040000           1991s     CMP.L   #$40000,D0
00200C2C  6E00 001A               1992s     BGT _10000015
00200C30  2200                    1993          MOVE.L D0,D1                            ; progress update
00200C32  E089                    1994          LSR.L #8,D1 
00200C34  E089                    1995          LSR.L #8,D1
00200C36  0281 0000000F           1996          ANDI.L #$F,D1
00200C3C  13C1 00E00001           1997          MOVE.B D1,DISPLAY
00200C42                          1998  
00200C42  20C0                    1999          MOVE.L D0,(A0)+ 
00200C44  5880                    2000          ADD.L #4,D0
00200C46                          2001      ENDW
00200C46  60DE                    2002s     BRA _10000014
00200C48                          2003s _10000015
00200C48                          2004   
00200C48  207C 00200000           2005      MOVE.L #RAM,A0                              ; address of RAM
00200C4E  7000                    2006      MOVE.L #0,D0                                ; number of bytes
00200C50                          2007     
00200C50                          2008      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C50                          2009s _10000016
00200C50  B0BC 00040000           2010s     CMP.L   #$40000,D0
00200C56  6E00 00C8               2011s     BGT _10000017
00200C5A  2200                    2012          MOVE.L D0,D1                            ; progress update
00200C5C  E089                    2013          LSR.L #8,D1
00200C5E  E089                    2014          LSR.L #8,D1
00200C60  0281 0000000F           2015          ANDI.L #$F,D1
00200C66  13C1 00E00001           2016          MOVE.B D1,DISPLAY
00200C6C                          2017  
00200C6C  2218                    2018          MOVE.L (A0)+,D1
00200C6E                          2019            
00200C6E                          2020          IF.L D0 <EQ> D1 THEN
00200C6E  B081                    2021s     CMP.L   D1,D0
00200C70  6600 0006               2022s     BNE _00000009
00200C74  6000 00A4               2023              BRA OK
00200C78                          2024          ENDI 
00200C78                          2025s _00000009
00200C78                          2026            
00200C78  43F9 00200FCC           2027          LEA RAM_ERROR,A1
00200C7E                          2028m         PRINT_STR A1,D1
00200C7E                          2029m LOOP_135
00200C7E  0C11 0000               2030m     CMP.B #0,(A1)                               ; 0 -> DONE
00200C82  6700 0016               2031m     BEQ EXIT_135
00200C86                          2032mm     PRINT_CHAR (A1)+,D1
00200C86                          2033mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C86                 TRUE     2034mm     IFEQ DEBUG
00200C86  1239 00C00003           2035mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200C8C  0801 0002               2036mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200C90  67F4                    2037mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C92  13D9 00C00007           2038mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200C98                          2039mm     ENDC
00200C98                          2040mm     
00200C98                 FALSE    2041mm     IFNE DEBUG
00200C98                          2042mm     ENDC
00200C98                          2043mm 
00200C98                          2044mm     ENDM
00200C98  60E4                    2045m     BRA LOOP_135
00200C9A                          2046m EXIT_135
00200C9A                          2047m     ENDM
00200C9A  2208                    2048          MOVE.L A0,D1
00200C9C  5981                    2049          SUB.L #4,D1
00200C9E                          2050m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200C9E                          2051mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200C9E                          2052mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C9E                 TRUE     2053mm     IFEQ DEBUG
00200C9E  1639 00C00003           2054mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CA4  0803 0002               2055mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CA8  67F4                    2056mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200CAA  13FC 0030 00C00007      2057mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CB2                          2058mm     ENDC
00200CB2                          2059mm     
00200CB2                 FALSE    2060mm     IFNE DEBUG
00200CB2                          2061mm     ENDC
00200CB2                          2062mm 
00200CB2                          2063mm     ENDM
00200CB2                          2064mm     PRINT_CHAR #'x',D3
00200CB2                          2065mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CB2                 TRUE     2066mm     IFEQ DEBUG
00200CB2  1639 00C00003           2067mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CB8  0803 0002               2068mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CBC  67F4                    2069mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00200CBE  13FC 0078 00C00007      2070mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CC6                          2071mm     ENDC
00200CC6                          2072mm     
00200CC6                 FALSE    2073mm     IFNE DEBUG
00200CC6                          2074mm     ENDC
00200CC6                          2075mm 
00200CC6                          2076mm     ENDM
00200CC6  7C07                    2077m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200CC8                          2078m LOOP_137
00200CC8                          2079mm     BIN2HEX D1,D2,A1
00200CC8  43F9 00200FDE           2080mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200CCE  E999                    2081mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200CD0  1401                    2082mm     MOVE.B D1,D2
00200CD2  0282 0000000F           2083mm     ANDI.L #$F,D2
00200CD8  1431 2000               2084mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200CDC                          2085mm     ENDM
00200CDC                          2086mm     PRINT_CHAR D2,D3
00200CDC                          2087mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CDC                 TRUE     2088mm     IFEQ DEBUG
00200CDC  1639 00C00003           2089mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CE2  0803 0002               2090mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CE6  67F4                    2091mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200CE8  13C2 00C00007           2092mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CEE                          2093mm     ENDC
00200CEE                          2094mm     
00200CEE                 FALSE    2095mm     IFNE DEBUG
00200CEE                          2096mm     ENDC
00200CEE                          2097mm 
00200CEE                          2098mm     ENDM
00200CEE  57CE FFD8               2099m     DBEQ D6,LOOP_137
00200CF2                          2100m     ENDM
00200CF2                          2101m         PRINT_CRLF D3
00200CF2                          2102mm     PRINT_CHAR #13,D3                           ; CR
00200CF2                          2103mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CF2                 TRUE     2104mm     IFEQ DEBUG
00200CF2  1639 00C00003           2105mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CF8  0803 0002               2106mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CFC  67F4                    2107mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00200CFE  13FC 000D 00C00007      2108mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D06                          2109mm     ENDC
00200D06                          2110mm     
00200D06                 FALSE    2111mm     IFNE DEBUG
00200D06                          2112mm     ENDC
00200D06                          2113mm 
00200D06                          2114mm     ENDM
00200D06                          2115mm     PRINT_CHAR #10,D3                           ; LF
00200D06                          2116mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D06                 TRUE     2117mm     IFEQ DEBUG
00200D06  1639 00C00003           2118mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D0C  0803 0002               2119mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D10  67F4                    2120mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200D12  13FC 000A 00C00007      2121mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D1A                          2122mm     ENDC
00200D1A                          2123mm     
00200D1A                 FALSE    2124mm     IFNE DEBUG
00200D1A                          2125mm     ENDC
00200D1A                          2126mm 
00200D1A                          2127mm     ENDM
00200D1A                          2128m     ENDM
00200D1A                          2129  OK    
00200D1A  5880                    2130          ADD.L #4,D0
00200D1C                          2131      ENDW
00200D1C  6000 FF32               2132s     BRA _10000016
00200D20                          2133s _10000017
00200D20                          2134      
00200D20  4EF9 00200184           2135      JMP MAIN_LOOP
00200D26                          2136    
00200D26                          2137  L
00200D26  7A00                    2138      MOVE.L #0,D5                                ; D5 will be the length  to write            
00200D28                          2139  
00200D28                          2140m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200D28                          2141m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D28                          2142m 
00200D28                 TRUE     2143m     IFEQ DEBUG
00200D28  1639 00C00003           2144m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D2E  0803 0000               2145m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200D32  67F4                    2146m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00200D34                          2147m     ENDC
00200D34                          2148m     
00200D34                          2149mm     READ_CHAR D2
00200D34                 TRUE     2150mm     IFEQ DEBUG
00200D34  1439 00C00007           2151mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D3A                          2152mm     ENDC
00200D3A                 FALSE    2153mm     IFNE DEBUG
00200D3A                          2154mm     ENDC
00200D3A                          2155mm      
00200D3A  B43C 001B               2156mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D3E  6700 F2C8               2157mm     BEQ START
00200D42                          2158mm     ENDM
00200D42                          2159m 
00200D42                 TRUE     2160m     IFEQ DEBUG
00200D42                          2161mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200D42                          2162mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D42                 TRUE     2163mm     IFEQ DEBUG
00200D42  1639 00C00003           2164mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D48  0803 0002               2165mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D4C  67F4                    2166mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00200D4E  13C2 00C00007           2167mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D54                          2168mm     ENDC
00200D54                          2169mm     
00200D54                 FALSE    2170mm     IFNE DEBUG
00200D54                          2171mm     ENDC
00200D54                          2172mm 
00200D54                          2173mm     ENDM
00200D54                          2174m     ENDC
00200D54                          2175m     ENDM
00200D54                          2176m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200D54  41F9 00200FEE           2177m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D5A  0402 0030               2178m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D5E  C4BC 000000FF           2179m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D64  1430 2000               2180m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D68                          2181m     ENDM
00200D68  1A02                    2182      MOVE.B D2,D5                                ; put at bottom of D5
00200D6A                          2183  
00200D6A  3C3C 0002               2184      MOVE #2,D6                                  ; 3 bytes left to read
00200D6E                          2185      
00200D6E                          2186  READ_LENGTH
00200D6E  E98D                    2187      LSL.L #4,D5                                 ; make what we have so far more significant
00200D70                          2188m     WAIT_CHAR D2,D3                             ; next character -> D2
00200D70                          2189m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D70                          2190m 
00200D70                 TRUE     2191m     IFEQ DEBUG
00200D70  1639 00C00003           2192m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D76  0803 0000               2193m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200D7A  67F4                    2194m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00200D7C                          2195m     ENDC
00200D7C                          2196m     
00200D7C                          2197mm     READ_CHAR D2
00200D7C                 TRUE     2198mm     IFEQ DEBUG
00200D7C  1439 00C00007           2199mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D82                          2200mm     ENDC
00200D82                 FALSE    2201mm     IFNE DEBUG
00200D82                          2202mm     ENDC
00200D82                          2203mm      
00200D82  B43C 001B               2204mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D86  6700 F280               2205mm     BEQ START
00200D8A                          2206mm     ENDM
00200D8A                          2207m 
00200D8A                 TRUE     2208m     IFEQ DEBUG
00200D8A                          2209mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200D8A                          2210mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D8A                 TRUE     2211mm     IFEQ DEBUG
00200D8A  1639 00C00003           2212mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D90  0803 0002               2213mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D94  67F4                    2214mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00200D96  13C2 00C00007           2215mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D9C                          2216mm     ENDC
00200D9C                          2217mm     
00200D9C                 FALSE    2218mm     IFNE DEBUG
00200D9C                          2219mm     ENDC
00200D9C                          2220mm 
00200D9C                          2221mm     ENDM
00200D9C                          2222m     ENDC
00200D9C                          2223m     ENDM
00200D9C                          2224m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200D9C  41F9 00200FEE           2225m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DA2  0402 0030               2226m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DA6  C4BC 000000FF           2227m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DAC  1430 2000               2228m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DB0                          2229m     ENDM
00200DB0  8A02                    2230      OR.B D2,D5
00200DB2  023C 00FB               2231      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200DB6  57CE FFB6               2232      DBEQ D6,READ_LENGTH
00200DBA                          2233          
00200DBA                          2234m     PRINT_CRLF D3
00200DBA                          2235mm     PRINT_CHAR #13,D3                           ; CR
00200DBA                          2236mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DBA                 TRUE     2237mm     IFEQ DEBUG
00200DBA  1639 00C00003           2238mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DC0  0803 0002               2239mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DC4  67F4                    2240mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200DC6  13FC 000D 00C00007      2241mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DCE                          2242mm     ENDC
00200DCE                          2243mm     
00200DCE                 FALSE    2244mm     IFNE DEBUG
00200DCE                          2245mm     ENDC
00200DCE                          2246mm 
00200DCE                          2247mm     ENDM
00200DCE                          2248mm     PRINT_CHAR #10,D3                           ; LF
00200DCE                          2249mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DCE                 TRUE     2250mm     IFEQ DEBUG
00200DCE  1639 00C00003           2251mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DD4  0803 0002               2252mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DD8  67F4                    2253mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00200DDA  13FC 000A 00C00007      2254mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DE2                          2255mm     ENDC
00200DE2                          2256mm     
00200DE2                 FALSE    2257mm     IFNE DEBUG
00200DE2                          2258mm     ENDC
00200DE2                          2259mm 
00200DE2                          2260mm     ENDM
00200DE2                          2261m     ENDM
00200DE2                          2262  
00200DE2  207C 00000000           2263      MOVE.L #ROM,A0                              ; start of ROM
00200DE8                          2264      
00200DE8  2247                    2265      MOVE.L D7,A1                                ; address accumulator -> address register
00200DEA  7E00                    2266      MOVE.L #0,D7                                ; clear the now used address accumulator
00200DEC                          2267      
00200DEC  267C 00002AAA           2268      MOVE.L #$2AAA,A3
00200DF2  36BC AAAA               2269      MOVE.W #$AAAA,(A3)
00200DF6  267C 00001554           2270      MOVE.L #$1554,A3
00200DFC  36BC 5555               2271      MOVE.W #$5555,(A3)
00200E00  267C 00002AAA           2272      MOVE.L #$2AAA,A3
00200E06  36BC 8080               2273      MOVE.W #$8080,(A3)
00200E0A  267C 00002AAA           2274      MOVE.L #$2AAA,A3
00200E10  36BC AAAA               2275      MOVE.W #$AAAA,(A3)
00200E14  267C 00001554           2276      MOVE.L #$1554,A3
00200E1A  36BC 5555               2277      MOVE.W #$5555,(A3)
00200E1E  267C 00002AAA           2278      MOVE.L #$2AAA,A3
00200E24  36BC 2020               2279      MOVE.W #$2020,(A3)
00200E28                          2280      
00200E28  45F9 00201005           2281      LEA LOADING,A2                              ; important for timing
00200E2E                          2282m     PRINT_STR A2,D3
00200E2E                          2283m LOOP_156
00200E2E  0C12 0000               2284m     CMP.B #0,(A2)                               ; 0 -> DONE
00200E32  6700 0016               2285m     BEQ EXIT_156
00200E36                          2286mm     PRINT_CHAR (A2)+,D3
00200E36                          2287mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E36                 TRUE     2288mm     IFEQ DEBUG
00200E36  1639 00C00003           2289mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E3C  0803 0002               2290mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E40  67F4                    2291mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200E42  13DA 00C00007           2292mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200E48                          2293mm     ENDC
00200E48                          2294mm     
00200E48                 FALSE    2295mm     IFNE DEBUG
00200E48                          2296mm     ENDC
00200E48                          2297mm 
00200E48                          2298mm     ENDM
00200E48  60E4                    2299m     BRA LOOP_156
00200E4A                          2300m EXIT_156
00200E4A                          2301m     ENDM
00200E4A                          2302  
00200E4A  023C 00FB               2303      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200E4E                          2304      
00200E4E                          2305      WHILE D5 <GT> #0 DO
00200E4E                          2306s _10000018
00200E4E  BA7C 0000               2307s     CMP.W   #0,D5
00200E52  6F00 0020               2308s     BLE _10000019
00200E56  5585                    2309          SUB.L #2,D5
00200E58                          2310            
00200E58  13D1 00E00001           2311          MOVE.B (A1),DISPLAY
00200E5E  3091                    2312          MOVE.W (A1),(A0)                        ; write the data
00200E60                          2313        
00200E60                          2314  WAIT_FOR_COMPLETE
00200E60  3410                    2315          MOVE.W (A0),D2
00200E62                          2316  
00200E62                          2317          IF D2 <NE> (A1) THEN
00200E62  B451                    2318s     CMP.W   (A1),D2
00200E64  6700 0008               2319s     BEQ _0000000A
00200E68  4EF9 00200E60           2320              JMP WAIT_FOR_COMPLETE
00200E6E                          2321          ENDI
00200E6E                          2322s _0000000A
00200E6E                          2323        
00200E6E  5488                    2324          ADD.L #2,A0
00200E70  5489                    2325          ADD.L #2,A1
00200E72                          2326      ENDW  
00200E72  60DA                    2327s     BRA _10000018
00200E74                          2328s _10000019
00200E74                          2329      
00200E74  267C 00002AAA           2330      MOVE.L #$2AAA,A3
00200E7A  36BC AAAA               2331      MOVE.W #$AAAA,(A3)
00200E7E  267C 00001554           2332      MOVE.L #$1554,A3
00200E84  36BC 5555               2333      MOVE.W #$5555,(A3)
00200E88  267C 00002AAA           2334      MOVE.L #$2AAA,A3
00200E8E  36BC A0A0               2335      MOVE.W #$A0A0,(A3)
00200E92                          2336              
00200E92  4EF9 00200184           2337      JMP MAIN_LOOP
00200E98                          2338          
00200E98                          2339  HEX_DIGIT
00200E98  E98F                    2340      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200E9A                          2341m     HEX2BIN D2,D2,A0
00200E9A  41F9 00200FEE           2342m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200EA0  0402 0030               2343m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200EA4  C4BC 000000FF           2344m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200EAA  1430 2000               2345m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EAE                          2346m     ENDM
00200EAE  8E02                    2347      OR.B D2,D7  
00200EB0  6000 F2FA               2348      BRA GET_INPUT
00200EB4                          2349  
00200EB4  FFFF FFFF               2350      SIMHALT                                     ; halt simulator
00200EB8                          2351  
00200EB8                          2352  ; strings
00200EB8= 4D 44 46 2D 6D 6F ...   2353  VERSION DC.B 'MDF-mon V1.48 (10/04/2021)',13,10,0
00200ED5= 3F 20 48 65 6C 70 ...   2354  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00200F7A= 48 75 68 3F 0D 0A 00    2355  HUH     DC.B 'Huh?',13,10,0
00200F81= 20 53 20 72 65 63 ...   2356  READ    DC.B ' S records read, start address = ',0
00200FA3= 57 3A 20 55 6E 6B ...   2357  UNREC   DC.B 'W: Unknown Srec type: ',0
00200FBA= 57 3A 20 43 53 20 ...   2358  CS_FAILURE   DC.B 'W: CS failure at ',0
00200FCC= 57 3A 20 52 41 4D ...   2359  RAM_ERROR DC.B 'W: RAM error at: ',0
00200FDE= 30 31 32 33 34 35 ...   2360  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00200FEE= 00 01 02 03 04 05 ...   2361  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201005= 4C 6F 61 64 69 6E ...   2362  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201019                          2363      
00201019                          2364      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200FDE
CONTINUE_103        200A00
CONTINUE_44         2004A2
CONTINUE_47         2004F2
CONTINUE_51         20054A
CONTINUE_59         200608
CONTINUE_64         20067C
CONTINUE_69         2006FA
CONTINUE_74         20077E
CONTINUE_79         20080E
CONTINUE_84         200882
CONTINUE_89         2008F6
CS_FAILURE          200FBA
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       200B1E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            200A9C
EXIT_125            200B94
EXIT_135            200C9A
EXIT_156            200E4A
EXIT_19             2002E2
EXIT_21             200308
EXIT_23             20032E
EXIT_5              20013E
EXIT_96             200996
G                   200C16
GET_INPUT           2001AC
H                   2002E6
HELP                200ED5
HEX2BIN             134
HEX2BIN_LUT         200FEE
HEX_DIGIT           200E98
HUH                 200F7A
L                   200D26
LOADING             201005
LOOP_110            200A80
LOOP_112            200AC6
LOOP_120            200B48
LOOP_125            200B78
LOOP_127            200BC0
LOOP_135            200C7E
LOOP_137            200CC8
LOOP_156            200E2E
LOOP_19             2002C6
LOOP_21             2002EC
LOOP_23             200312
LOOP_25             200360
LOOP_5              200122
LOOP_96             20097A
MAIN_LOOP           200184
OK                  200D1A
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200332
RAM                 200000
RAM_ERROR           200FCC
READ                200F81
READ_CHAR           805
READ_DATA_TO_POKE   200400
READ_LENGTH         200D6E
RESET               200004
ROM                 0
S                   20047E
STACK               200000
START               200008
UNREC               200FA3
V                   20030C
VERSION             200EB8
W                   2003B8
WAIT_CHAR           665
WAIT_FOR_COMPLETE   200E60
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   200166
WAIT_FOR_READY_100  2009A8
WAIT_FOR_READY_101  2009BC
WAIT_FOR_READY_103  2009E4
WAIT_FOR_READY_105  200A18
WAIT_FOR_READY_108  200A4A
WAIT_FOR_READY_109  200A5E
WAIT_FOR_READY_11   200184
WAIT_FOR_READY_111  200A88
WAIT_FOR_READY_113  200A9C
WAIT_FOR_READY_114  200AB0
WAIT_FOR_READY_116  200ADA
WAIT_FOR_READY_118  200AF0
WAIT_FOR_READY_119  200B04
WAIT_FOR_READY_12   200198
WAIT_FOR_READY_121  200B1E
WAIT_FOR_READY_122  200B32
WAIT_FOR_READY_124  200B5C
WAIT_FOR_READY_126  200B80
WAIT_FOR_READY_128  200B96
WAIT_FOR_READY_129  200BAA
WAIT_FOR_READY_13   2001AC
WAIT_FOR_READY_131  200BD4
WAIT_FOR_READY_133  200BEA
WAIT_FOR_READY_134  200BFE
WAIT_FOR_READY_136  200C86
WAIT_FOR_READY_138  200C9E
WAIT_FOR_READY_139  200CB2
WAIT_FOR_READY_141  200CDC
WAIT_FOR_READY_143  200CF2
WAIT_FOR_READY_144  200D06
WAIT_FOR_READY_145  200D28
WAIT_FOR_READY_147  200D42
WAIT_FOR_READY_149  200D70
WAIT_FOR_READY_15   2001C6
WAIT_FOR_READY_151  200D8A
WAIT_FOR_READY_154  200DBA
WAIT_FOR_READY_155  200DCE
WAIT_FOR_READY_157  200E36
WAIT_FOR_READY_17   200268
WAIT_FOR_READY_18   20027C
WAIT_FOR_READY_20   2002CE
WAIT_FOR_READY_22   2002F4
WAIT_FOR_READY_24   20031A
WAIT_FOR_READY_26   200336
WAIT_FOR_READY_27   20034A
WAIT_FOR_READY_29   200374
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   20038A
WAIT_FOR_READY_32   20039E
WAIT_FOR_READY_33   2003BA
WAIT_FOR_READY_35   2003D4
WAIT_FOR_READY_37   200402
WAIT_FOR_READY_39   20041C
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   200452
WAIT_FOR_READY_43   200466
WAIT_FOR_READY_44   200486
WAIT_FOR_READY_46   2004C0
WAIT_FOR_READY_47   2004D6
WAIT_FOR_READY_49   20050A
WAIT_FOR_READY_51   20052E
WAIT_FOR_READY_53   200562
WAIT_FOR_READY_56   20059C
WAIT_FOR_READY_57   2005B0
WAIT_FOR_READY_59   2005EC
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   200620
WAIT_FOR_READY_64   200660
WAIT_FOR_READY_66   200694
WAIT_FOR_READY_69   2006DE
WAIT_FOR_READY_71   200712
WAIT_FOR_READY_74   200762
WAIT_FOR_READY_76   200796
WAIT_FOR_READY_79   2007F2
WAIT_FOR_READY_8    20013E
WAIT_FOR_READY_81   200826
WAIT_FOR_READY_84   200866
WAIT_FOR_READY_86   20089A
WAIT_FOR_READY_89   2008DA
WAIT_FOR_READY_9    200152
WAIT_FOR_READY_91   20090E
WAIT_FOR_READY_94   20094C
WAIT_FOR_READY_95   200960
WAIT_FOR_READY_97   200982
WAIT_FOR_READY_98   200996
WAIT_FOR_SRECORD    200486
Z                   200C1E
_00000000           2005CC
_00000001           2009D4
_00000002           2005DA
_00000003           2007DA
_00000004           200744
_00000005           2009D4
_00000006           20094C
_00000007           2009D4
_00000008           200B1C
_00000009           200C78
_0000000A           200E6E
_10000000           200524
_10000001           20058E
_10000002           2005E2
_10000003           20064C
_10000004           200656
_10000005           2006C0
_10000006           2006D4
_10000007           20073E
_10000008           200748
_10000009           2007D0
_1000000A           200758
_1000000B           2007C2
_1000000C           2007E8
_1000000D           200852
_1000000E           20085C
_1000000F           2008C6
_10000010           2008D0
_10000011           20093A
_10000012           2009DA
_10000013           200A44
_10000014           200C26
_10000015           200C48
_10000016           200C50
_10000017           200D20
_10000018           200E4E
_10000019           200E74
