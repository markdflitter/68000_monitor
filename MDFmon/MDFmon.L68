00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 18:09:31

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ORG  $0
00000000                            21      ;ORG  $200000
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF,\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      PRINT_CHAR #'0',\2                              ;0x header
00000000                           143      PRINT_CHAR #'x',\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  
00000000                           227  ; register catalogue
00000000                           228  ; D0 - used for simulator I/O
00000000                           229  ; D1 - used for simulator I/O
00000000                           230  ; D2 - read character
00000000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           232  ; D6 - working register used in R/W
00000000                           233  ; D7 - address accumulator, reset by download
00000000                           234  ; A0 - address of string to print 
00000000                           235  
00000000                           236  ; start vector
00000000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 238  RESET    DC.L START                             ; RESET
00000008                           239      
00000008                           240  ; start of program  
00000008                           241  START
00000008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00000010                           243  
00000010                           244  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                           ; reset everyting
00000020  4E71                     247      NOP
00000022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     249      NOP
0000002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00000034  4E71                     251      NOP
00000036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0000003E  4E71                     253      NOP
00000040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00000048                           255  
00000048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                           ; reset everyting
00000058  4E71                     258      NOP
0000005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00000062  4E71                     260      NOP
00000064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0000006C  4E71                     262      NOP
0000006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00000076  4E71                     264      NOP
00000078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00000080                           266  
00000080                           267  ;initialise UART
00000080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00000098                           271  
00000098                           272  ; channel A
00000098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
000000A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
000000B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000000B8                           277  
000000B8                           278  ; channel B
000000B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000D8                           283  
000000D8                           284m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      286m     IFEQ DEBUG
000000D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           291m     ENDC
000000EC                           292m     
000000EC                 FALSE     293m     IFNE DEBUG
000000EC                           294m     ENDC
000000EC                           295m 
000000EC                           296m     ENDM
000000EC                           297  
000000EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
000000F4                           299         
000000F4                           300m     PRINT_CRLF D3,A0
000000F4  41F9 00000E78            301m     LEA CRLF,A0
000000FA                           302mm     PRINT_STR A0,D3
000000FA                           303mm LOOP_3
000000FA  0C10 0000                304mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FE  6700 0016                305mm     BEQ EXIT_3
00000102                           306mmm     PRINT_CHAR (A0)+,D3
00000102                           307mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000102                 TRUE      308mmm     IFEQ DEBUG
00000102  1639 00C00003            309mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000108  0803 0002                310mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010C  67F4                     311mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
0000010E  13D8 00C00007            312mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000114                           313mmm     ENDC
00000114                           314mmm     
00000114                 FALSE     315mmm     IFNE DEBUG
00000114                           316mmm     ENDC
00000114                           317mmm 
00000114                           318mmm     ENDM
00000114  60E4                     319mm     BRA LOOP_3
00000116                           320mm EXIT_3
00000116                           321mm     ENDM
00000116                           322m     ENDM
00000116                           323  
00000116  41F9 00000D0C            324      LEA VERSION,A0
0000011C                           325m     PRINT_STR A0,D3
0000011C                           326m LOOP_5
0000011C  0C10 0000                327m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000120  6700 0016                328m     BEQ EXIT_5
00000124                           329mm     PRINT_CHAR (A0)+,D3
00000124                           330mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000124                 TRUE      331mm     IFEQ DEBUG
00000124  1639 00C00003            332mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000012A  0803 0002                333mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012E  67F4                     334mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000130  13D8 00C00007            335mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000136                           336mm     ENDC
00000136                           337mm     
00000136                 FALSE     338mm     IFNE DEBUG
00000136                           339mm     ENDC
00000136                           340mm 
00000136                           341mm     ENDM
00000136  60E4                     342m     BRA LOOP_5
00000138                           343m EXIT_5
00000138                           344m     ENDM
00000138                           345m     PRINT_CRLF D3,A0
00000138  41F9 00000E78            346m     LEA CRLF,A0
0000013E                           347mm     PRINT_STR A0,D3
0000013E                           348mm LOOP_8
0000013E  0C10 0000                349mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                350mm     BEQ EXIT_8
00000146                           351mmm     PRINT_CHAR (A0)+,D3
00000146                           352mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      353mmm     IFEQ DEBUG
00000146  1639 00C00003            354mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                355mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     356mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            357mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           358mmm     ENDC
00000158                           359mmm     
00000158                 FALSE     360mmm     IFNE DEBUG
00000158                           361mmm     ENDC
00000158                           362mmm 
00000158                           363mmm     ENDM
00000158  60E4                     364mm     BRA LOOP_8
0000015A                           365mm EXIT_8
0000015A                           366mm     ENDM
0000015A                           367m     ENDM
0000015A                           368  
0000015A  7E00                     369      MOVE.L #0,D7                                    ; address accumulator
0000015C                           370  
0000015C  13FC 0002 00E00001       371      MOVE.B #2,DISPLAY
00000164                           372  MAIN_LOOP
00000164  41F9 00000E7B            373      LEA PROMPT,A0
0000016A                           374m     PRINT_STR A0,D3
0000016A                           375m LOOP_10
0000016A  0C10 0000                376m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000016E  6700 0016                377m     BEQ EXIT_10
00000172                           378mm     PRINT_CHAR (A0)+,D3
00000172                           379mm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000172                 TRUE      380mm     IFEQ DEBUG
00000172  1639 00C00003            381mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000178  0803 0002                382mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000017C  67F4                     383mm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
0000017E  13D8 00C00007            384mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000184                           385mm     ENDC
00000184                           386mm     
00000184                 FALSE     387mm     IFNE DEBUG
00000184                           388mm     ENDC
00000184                           389mm 
00000184                           390mm     ENDM
00000184  60E4                     391m     BRA LOOP_10
00000186                           392m EXIT_10
00000186                           393m     ENDM
00000186                           394      
00000186                           395  GET_INPUT
00000186                           396m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00000186                           397m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      398m     IFEQ DEBUG
00000186  1639 00C00003            399m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0000                400m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000190  67F4                     401m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000192                           402m     ENDC
00000192                           403m     
00000192                           404mm     READ_CHAR D2
00000192                 TRUE      405mm     IFEQ DEBUG
00000192  1439 00C00007            406mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000198                           407mm     ENDC
00000198                 FALSE     408mm     IFNE DEBUG
00000198                           409mm     ENDC
00000198                           410mm      
00000198  B43C 001B                411mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000019C  6700 FE6A                412mm     BEQ START
000001A0                           413mm     ENDM
000001A0                           414m 
000001A0                 TRUE      415m     IFEQ DEBUG
000001A0                           416mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001A0                           417mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001A0                 TRUE      418mm     IFEQ DEBUG
000001A0  1639 00C00003            419mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001A6  0803 0002                420mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001AA  67F4                     421mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
000001AC  13C2 00C00007            422mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001B2                           423mm     ENDC
000001B2                           424mm     
000001B2                 FALSE     425mm     IFNE DEBUG
000001B2                           426mm     ENDC
000001B2                           427mm 
000001B2                           428mm     ENDM
000001B2                           429m     ENDC
000001B2                           430m     ENDM
000001B2                           431      
000001B2                           432      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001B2  B43C 0030                433s     CMP.B   #'0',D2
000001B6  6D00 000E                434s     BLT _00000000
000001BA  B43C 0039                435s     CMP.B   #'9',D2
000001BE  6E00 0006                436s     BGT _00000000
000001C2  6000 0B28                437          BRA HEX_DIGIT
000001C6                           438      ENDI
000001C6                           439s _00000000
000001C6                           440      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001C6  B43C 0041                441s     CMP.B   #'A',D2
000001CA  6D00 000E                442s     BLT _00000001
000001CE  B43C 0046                443s     CMP.B   #'F',D2
000001D2  6E00 0006                444s     BGT _00000001
000001D6  6000 0B14                445          BRA HEX_DIGIT
000001DA                           446      ENDI
000001DA                           447s _00000001
000001DA                           448          
000001DA  B43C 0077                449      CMP.B #'w',D2
000001DE  6700 0132                450      BEQ W
000001E2                           451      
000001E2  B43C 006C                452      CMP.B #'l',D2
000001E6  6700 0A04                453      BEQ L 
000001EA                           454  
000001EA                           455m     PRINT_CRLF D3,A0
000001EA  41F9 00000E78            456m     LEA CRLF,A0
000001F0                           457mm     PRINT_STR A0,D3
000001F0                           458mm LOOP_16
000001F0  0C10 0000                459mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001F4  6700 0016                460mm     BEQ EXIT_16
000001F8                           461mmm     PRINT_CHAR (A0)+,D3
000001F8                           462mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F8                 TRUE      463mmm     IFEQ DEBUG
000001F8  1639 00C00003            464mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001FE  0803 0002                465mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000202  67F4                     466mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000204  13D8 00C00007            467mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000020A                           468mmm     ENDC
0000020A                           469mmm     
0000020A                 FALSE     470mmm     IFNE DEBUG
0000020A                           471mmm     ENDC
0000020A                           472mmm 
0000020A                           473mmm     ENDM
0000020A  60E4                     474mm     BRA LOOP_16
0000020C                           475mm EXIT_16
0000020C                           476mm     ENDM
0000020C                           477m     ENDM
0000020C                           478   
0000020C  B43C 003F                479      CMP.B #'?',D2
00000210  6700 0050                480      BEQ H
00000214                           481   
00000214  B43C 0076                482      CMP.B #'v',D2
00000218  6700 0052                483      BEQ V
0000021C                           484      
0000021C  B43C 0072                485      CMP.B #'r',D2
00000220  6700 0070                486      BEQ R
00000224                           487  
00000224  B43C 0073                488      CMP.B #'s',D2
00000228  6700 0160                489      BEQ S
0000022C                           490  
0000022C  B43C 0067                491      CMP.B #'g',D2
00000230  6700 08C2                492      BEQ G   
00000234                           493  
00000234  B43C 007A                494      CMP.B #'z',D2
00000238  6700 08C2                495      BEQ Z   
0000023C                           496  
0000023C  41F9 00000DD9            497      LEA HUH,A0
00000242                           498m     PRINT_STR A0,D3
00000242                           499m LOOP_18
00000242  0C10 0000                500m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000246  6700 0016                501m     BEQ EXIT_18
0000024A                           502mm     PRINT_CHAR (A0)+,D3
0000024A                           503mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024A                 TRUE      504mm     IFEQ DEBUG
0000024A  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000250  0803 0002                506mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000254  67F4                     507mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
00000256  13D8 00C00007            508mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000025C                           509mm     ENDC
0000025C                           510mm     
0000025C                 FALSE     511mm     IFNE DEBUG
0000025C                           512mm     ENDC
0000025C                           513mm 
0000025C                           514mm     ENDM
0000025C  60E4                     515m     BRA LOOP_18
0000025E                           516m EXIT_18
0000025E                           517m     ENDM
0000025E                           518                         
0000025E  6000 FF04                519      BRA MAIN_LOOP
00000262                           520      
00000262                           521  ; commands
00000262                           522  H   
00000262  41F9 00000D29            523      LEA HELP,A0
00000268  6000 0008                524      BRA PRINTSTR
0000026C                           525  
0000026C                           526  V   
0000026C  41F9 00000D0C            527      LEA VERSION,A0
00000272                           528  PRINTSTR
00000272                           529m     PRINT_STR A0,D3       
00000272                           530m LOOP_20
00000272  0C10 0000                531m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000276  6700 0016                532m     BEQ EXIT_20
0000027A                           533mm     PRINT_CHAR (A0)+,D3
0000027A                           534mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027A                 TRUE      535mm     IFEQ DEBUG
0000027A  1639 00C00003            536mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000280  0803 0002                537mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000284  67F4                     538mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
00000286  13D8 00C00007            539mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028C                           540mm     ENDC
0000028C                           541mm     
0000028C                 FALSE     542mm     IFNE DEBUG
0000028C                           543mm     ENDC
0000028C                           544mm 
0000028C                           545mm     ENDM
0000028C  60E4                     546m     BRA LOOP_20
0000028E                           547m EXIT_20
0000028E                           548m     ENDM
0000028E  6000 FED4                549      BRA MAIN_LOOP
00000292                           550      
00000292                           551  R   
00000292  2047                     552      MOVE.L D7,A0                                    ; address accumulator -> address register
00000294  7E00                     553      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000296  2A10                     554      MOVE.L (A0),D5                                  ; read the memory and print it
00000298                           555m     PRINT_REG D5,D3,D7,D6,A0
00000298                           556mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00000298                           557mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000298                 TRUE      558mm     IFEQ DEBUG
00000298  1639 00C00003            559mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000029E  0803 0002                560mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A2  67F4                     561mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
000002A4  13FC 0030 00C00007       562mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002AC                           563mm     ENDC
000002AC                           564mm     
000002AC                 FALSE     565mm     IFNE DEBUG
000002AC                           566mm     ENDC
000002AC                           567mm 
000002AC                           568mm     ENDM
000002AC                           569mm     PRINT_CHAR #'x',D3
000002AC                           570mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002AC                 TRUE      571mm     IFEQ DEBUG
000002AC  1639 00C00003            572mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002B2  0803 0002                573mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002B6  67F4                     574mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
000002B8  13FC 0078 00C00007       575mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002C0                           576mm     ENDC
000002C0                           577mm     
000002C0                 FALSE     578mm     IFNE DEBUG
000002C0                           579mm     ENDC
000002C0                           580mm 
000002C0                           581mm     ENDM
000002C0  7C07                     582m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002C2                           583m LOOP_22
000002C2                           584mm     BIN2HEX D5,D7,A0
000002C2  41F9 00000E3D            585mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
000002C8  E99D                     586mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002CA  1E05                     587mm     MOVE.B D5,D7
000002CC  0287 0000000F            588mm     ANDI.L #$F,D7
000002D2  1E30 7000                589mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
000002D6                           590mm     ENDM
000002D6                           591mm     PRINT_CHAR D7,D3
000002D6                           592mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D6                 TRUE      593mm     IFEQ DEBUG
000002D6  1639 00C00003            594mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002DC  0803 0002                595mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002E0  67F4                     596mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002E2  13C7 00C00007            597mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002E8                           598mm     ENDC
000002E8                           599mm     
000002E8                 FALSE     600mm     IFNE DEBUG
000002E8                           601mm     ENDC
000002E8                           602mm 
000002E8                           603mm     ENDM
000002E8  57CE FFD8                604m     DBEQ D6,LOOP_22
000002EC                           605m     ENDM
000002EC                           606m     PRINT_CRLF D3,A0
000002EC  41F9 00000E78            607m     LEA CRLF,A0
000002F2                           608mm     PRINT_STR A0,D3
000002F2                           609mm LOOP_28
000002F2  0C10 0000                610mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002F6  6700 0016                611mm     BEQ EXIT_28
000002FA                           612mmm     PRINT_CHAR (A0)+,D3
000002FA                           613mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FA                 TRUE      614mmm     IFEQ DEBUG
000002FA  1639 00C00003            615mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000300  0803 0002                616mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000304  67F4                     617mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000306  13D8 00C00007            618mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000030C                           619mmm     ENDC
0000030C                           620mmm     
0000030C                 FALSE     621mmm     IFNE DEBUG
0000030C                           622mmm     ENDC
0000030C                           623mmm 
0000030C                           624mmm     ENDM
0000030C  60E4                     625mm     BRA LOOP_28
0000030E                           626mm EXIT_28
0000030E                           627mm     ENDM
0000030E                           628m     ENDM
0000030E  6000 FE54                629      BRA MAIN_LOOP
00000312                           630  
00000312                           631  W
00000312  3C3C 0007                632      MOVE #7,D6                                      ; 7 bytes left to read
00000316                           633      
00000316                           634  READ_DATA_TO_POKE
00000316  E98D                     635      LSL.L #4,D5                                     ; make what we have so far more significant
00000318                           636m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000318                           637m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000318                 TRUE      638m     IFEQ DEBUG
00000318  1639 00C00003            639m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000031E  0803 0000                640m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000322  67F4                     641m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
00000324                           642m     ENDC
00000324                           643m     
00000324                           644mm     READ_CHAR D2
00000324                 TRUE      645mm     IFEQ DEBUG
00000324  1439 00C00007            646mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000032A                           647mm     ENDC
0000032A                 FALSE     648mm     IFNE DEBUG
0000032A                           649mm     ENDC
0000032A                           650mm      
0000032A  B43C 001B                651mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000032E  6700 FCD8                652mm     BEQ START
00000332                           653mm     ENDM
00000332                           654m 
00000332                 TRUE      655m     IFEQ DEBUG
00000332                           656mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000332                           657mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000332                 TRUE      658mm     IFEQ DEBUG
00000332  1639 00C00003            659mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000338  0803 0002                660mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000033C  67F4                     661mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
0000033E  13C2 00C00007            662mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000344                           663mm     ENDC
00000344                           664mm     
00000344                 FALSE     665mm     IFNE DEBUG
00000344                           666mm     ENDC
00000344                           667mm 
00000344                           668mm     ENDM
00000344                           669m     ENDC
00000344                           670m     ENDM
00000344                           671m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000344  41F9 00000E4D            672m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
0000034A  0402 0030                673m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000034E  C4BC 000000FF            674m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000354  1430 2000                675m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000358                           676m     ENDM
00000358  8A02                     677      OR.B D2,D5
0000035A  57CE FFBA                678      DBEQ D6,READ_DATA_TO_POKE
0000035E                           679      
0000035E  2047                     680      MOVE.L D7,A0                                    ; address accumulator -> address register
00000360  7E00                     681      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000362                           682      
00000362  2085                     683      MOVE.L D5,(A0)                                  ; write the data
00000364                           684  
00000364                           685m     PRINT_CRLF D3,A0
00000364  41F9 00000E78            686m     LEA CRLF,A0
0000036A                           687mm     PRINT_STR A0,D3
0000036A                           688mm LOOP_35
0000036A  0C10 0000                689mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000036E  6700 0016                690mm     BEQ EXIT_35
00000372                           691mmm     PRINT_CHAR (A0)+,D3
00000372                           692mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000372                 TRUE      693mmm     IFEQ DEBUG
00000372  1639 00C00003            694mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000378  0803 0002                695mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000037C  67F4                     696mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0000037E  13D8 00C00007            697mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000384                           698mmm     ENDC
00000384                           699mmm     
00000384                 FALSE     700mmm     IFNE DEBUG
00000384                           701mmm     ENDC
00000384                           702mmm 
00000384                           703mmm     ENDM
00000384  60E4                     704mm     BRA LOOP_35
00000386                           705mm EXIT_35
00000386                           706mm     ENDM
00000386                           707m     ENDM
00000386  6000 FDDC                708      BRA MAIN_LOOP
0000038A                           709  
0000038A                           710  ; register map for S
0000038A                           711  ; A0 - start address
0000038A                           712  ; A1 - offset
0000038A                           713  ; A2 - next address to write
0000038A                           714  ; A3 - next location (jmp)
0000038A                           715  ; A4 - Working Address Register
0000038A                           716  ; D0 - record count
0000038A                           717  ; D1 - 'S', record type, data byte
0000038A                           718  ; D2 - checksum
0000038A                           719  ; D3 - data byte count
0000038A                           720  ; D4 - read address, moved into A2
0000038A                           721  ; D5 - temp
0000038A                           722  ; D6 - temp
0000038A                           723  ; D7 - temp
0000038A                           724  S
0000038A  2078 0000                725      MOVE.L 0,A0                                     ; start address -> A0
0000038E  2247                     726      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000390                           727      
00000390  7000                     728      MOVE.L #0,D0                                    ; count of records read -> D0
00000392                           729          
00000392                           730  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000392                           731m     DOWNLOAD D1                 
00000392                           732m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000392                           733m 
00000392  1239 00C00003            734m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000398  0801 0000                735m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000039C  6700 0010                736m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
000003A0                           737m  
000003A0                           738mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003A0                 TRUE      739mm     IFEQ DEBUG
000003A0  1239 00C00007            740mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003A6                           741mm     ENDC
000003A6                 FALSE     742mm     IFNE DEBUG
000003A6                           743mm     ENDC
000003A6                           744mm      
000003A6  B23C 001B                745mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003AA  6700 FC5C                746mm     BEQ START
000003AE                           747mm     ENDM
000003AE                           748m CONTINUE_37
000003AE  1239 00C00013            749m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003B4  0801 0000                750m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003B8  67D8                     751m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
000003BA                           752m     
000003BA  1239 00C00017            753m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003C0  13C1 00E00001            754m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003C6                           755m     
000003C6                           756m     ENDM
000003C6  B23C 0053                757      CMP.B #'S',D1                                   ; found S?    
000003CA  66C6                     758      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003CC                           759      
000003CC                           760m     PRINT_CHAR #'S',D5                            ; print the S
000003CC                           761m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003CC                 TRUE      762m     IFEQ DEBUG
000003CC  1A39 00C00003            763m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003D2  0805 0002                764m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003D6  67F4                     765m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003D8  13FC 0053 00C00007       766m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003E0                           767m     ENDC
000003E0                           768m     
000003E0                 FALSE     769m     IFNE DEBUG
000003E0                           770m     ENDC
000003E0                           771m 
000003E0                           772m     ENDM
000003E0  5280                     773      ADD.L #1,D0                                     ; read another S record, increment count
000003E2                           774      
000003E2                           775m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003E2                           776m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E2                           777m 
000003E2  1239 00C00003            778m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003E8  0801 0000                779m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003EC  6700 0010                780m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003F0                           781m  
000003F0                           782mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003F0                 TRUE      783mm     IFEQ DEBUG
000003F0  1239 00C00007            784mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003F6                           785mm     ENDC
000003F6                 FALSE     786mm     IFNE DEBUG
000003F6                           787mm     ENDC
000003F6                           788mm      
000003F6  B23C 001B                789mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003FA  6700 FC0C                790mm     BEQ START
000003FE                           791mm     ENDM
000003FE                           792m CONTINUE_40
000003FE  1239 00C00013            793m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000404  0801 0000                794m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000408  67D8                     795m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
0000040A                           796m     
0000040A  1239 00C00017            797m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000410  13C1 00E00001            798m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000416                           799m     
00000416                           800m     ENDM
00000416                           801m     PRINT_CHAR D1,D5
00000416                           802m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000416                 TRUE      803m     IFEQ DEBUG
00000416  1A39 00C00003            804m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000041C  0805 0002                805m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000420  67F4                     806m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000422  13C1 00C00007            807m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000428                           808m     ENDC
00000428                           809m     
00000428                 FALSE     810m     IFNE DEBUG
00000428                           811m     ENDC
00000428                           812m 
00000428                           813m     ENDM
00000428                           814  
00000428  7400                     815      MOVE.L #0,D2                                    ; clear the checksum
0000042A                           816  
0000042A                           817m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
0000042A  1E3C 0002                818m     MOVE.B #2,D7
0000042E                           819m     WHILE.B D7 <GT> 0 DO
0000042E                           820ms _10000000
0000042E  BE38 0000                821ms     CMP.B   0,D7
00000432  6F00 0064                822ms     BLE _10000001
00000436  E98B                     823m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000438                           824mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000438                           825mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000438                           826mm 
00000438  1A39 00C00003            827mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000043E  0805 0000                828mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000442  6700 0010                829mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000446                           830mm  
00000446                           831mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000446                 TRUE      832mmm     IFEQ DEBUG
00000446  1A39 00C00007            833mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000044C                           834mmm     ENDC
0000044C                 FALSE     835mmm     IFNE DEBUG
0000044C                           836mmm     ENDC
0000044C                           837mmm      
0000044C  BA3C 001B                838mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000450  6700 FBB6                839mmm     BEQ START
00000454                           840mmm     ENDM
00000454                           841mm CONTINUE_44
00000454  1A39 00C00013            842mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000045A  0805 0000                843mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000045E  67D8                     844mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00000460                           845mm     
00000460  1A39 00C00017            846mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000466  13C5 00E00001            847mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000046C                           848mm     
0000046C                           849mm     ENDM
0000046C                           850mm         PRINT_CHAR D5,D6
0000046C                           851mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046C                 TRUE      852mm     IFEQ DEBUG
0000046C  1C39 00C00003            853mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000472  0806 0002                854mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000476  67F4                     855mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000478  13C5 00C00007            856mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000047E                           857mm     ENDC
0000047E                           858mm     
0000047E                 FALSE     859mm     IFNE DEBUG
0000047E                           860mm     ENDC
0000047E                           861mm 
0000047E                           862mm     ENDM
0000047E                           863mm         HEX2BIN D5,D5,A4
0000047E  49F9 00000E4D            864mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000484  0405 0030                865mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000488  CABC 000000FF            866mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000048E  1A34 5000                867mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000492                           868mm     ENDM
00000492  8605                     869m         OR.B D5,D3
00000494  5307                     870m         SUB.B #1,D7
00000496                           871m     ENDW
00000496  6096                     872ms     BRA _10000000
00000498                           873ms _10000001
00000498                           874m     
00000498  7A00                     875m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000049A  1A03                     876m     MOVE.B D3,D5
0000049C  D483                     877m     ADD.L D3,D2
0000049E                           878m 
0000049E                           879m     ENDM
0000049E                           880  
0000049E                           881      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000049E  B23C 0030                882s     CMP.B   #'0',D1
000004A2  6600 002C                883s     BNE.L   _00000002
000004A6                           884m         PRINT_CRLF D5,A4
000004A6  49F9 00000E78            885m     LEA CRLF,A4
000004AC                           886mm     PRINT_STR A4,D5
000004AC                           887mm LOOP_49
000004AC  0C14 0000                888mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000004B0  6700 0016                889mm     BEQ EXIT_49
000004B4                           890mmm     PRINT_CHAR (A4)+,D5
000004B4                           891mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B4                 TRUE      892mmm     IFEQ DEBUG
000004B4  1A39 00C00003            893mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004BA  0805 0002                894mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004BE  67F4                     895mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
000004C0  13DC 00C00007            896mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000004C6                           897mmm     ENDC
000004C6                           898mmm     
000004C6                 FALSE     899mmm     IFNE DEBUG
000004C6                           900mmm     ENDC
000004C6                           901mmm 
000004C6                           902mmm     ENDM
000004C6  60E4                     903mm     BRA LOOP_49
000004C8                           904mm EXIT_49
000004C8                           905mm     ENDM
000004C8                           906m     ENDM
000004C8  6000 FEC8                907          BRA WAIT_FOR_SRECORD
000004CC                           908      ELSE
000004CC  6000 03F8                909s     BRA _00000003
000004D0                           910s _00000002
000004D0                           911          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000004D0  B23C 0031                912s     CMP.B   #'1',D1
000004D4  6708                     913s     BEQ.S   _00000004
000004D6  B23C 0032                914s     CMP.B   #'2',D1
000004DA  6600 01FC                915s     BNE.L   _00000005
000004DE                           916s _00000004
000004DE  5783                     917              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004E0                           918      
000004E0  7800                     919              MOVE.L #0,D4                            ; read two bytes of address
000004E2                           920m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004E2  1E3C 0002                921m     MOVE.B #2,D7
000004E6                           922m     WHILE.B D7 <GT> 0 DO
000004E6                           923ms _10000002
000004E6  BE38 0000                924ms     CMP.B   0,D7
000004EA  6F00 0064                925ms     BLE _10000003
000004EE  E98C                     926m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004F0                           927mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004F0                           928mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F0                           929mm 
000004F0  1A39 00C00003            930mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004F6  0805 0000                931mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004FA  6700 0010                932mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
000004FE                           933mm  
000004FE                           934mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004FE                 TRUE      935mmm     IFEQ DEBUG
000004FE  1A39 00C00007            936mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000504                           937mmm     ENDC
00000504                 FALSE     938mmm     IFNE DEBUG
00000504                           939mmm     ENDC
00000504                           940mmm      
00000504  BA3C 001B                941mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000508  6700 FAFE                942mmm     BEQ START
0000050C                           943mmm     ENDM
0000050C                           944mm CONTINUE_52
0000050C  1A39 00C00013            945mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000512  0805 0000                946mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000516  67D8                     947mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
00000518                           948mm     
00000518  1A39 00C00017            949mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000051E  13C5 00E00001            950mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000524                           951mm     
00000524                           952mm     ENDM
00000524                           953mm         PRINT_CHAR D5,D6
00000524                           954mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000524                 TRUE      955mm     IFEQ DEBUG
00000524  1C39 00C00003            956mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000052A  0806 0002                957mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000052E  67F4                     958mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
00000530  13C5 00C00007            959mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000536                           960mm     ENDC
00000536                           961mm     
00000536                 FALSE     962mm     IFNE DEBUG
00000536                           963mm     ENDC
00000536                           964mm 
00000536                           965mm     ENDM
00000536                           966mm         HEX2BIN D5,D5,A4
00000536  49F9 00000E4D            967mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000053C  0405 0030                968mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000540  CABC 000000FF            969mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000546  1A34 5000                970mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000054A                           971mm     ENDM
0000054A  8805                     972m         OR.B D5,D4
0000054C  5307                     973m         SUB.B #1,D7
0000054E                           974m     ENDW
0000054E  6096                     975ms     BRA _10000002
00000550                           976ms _10000003
00000550                           977m     
00000550  7A00                     978m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000552  1A04                     979m     MOVE.B D4,D5
00000554  D484                     980m     ADD.L D4,D2
00000556                           981m 
00000556                           982m     ENDM
00000556                           983m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000556  1E3C 0002                984m     MOVE.B #2,D7
0000055A                           985m     WHILE.B D7 <GT> 0 DO
0000055A                           986ms _10000004
0000055A  BE38 0000                987ms     CMP.B   0,D7
0000055E  6F00 0064                988ms     BLE _10000005
00000562  E98C                     989m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000564                           990mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000564                           991mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                           992mm 
00000564  1A39 00C00003            993mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000056A  0805 0000                994mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000056E  6700 0010                995mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000572                           996mm  
00000572                           997mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000572                 TRUE      998mmm     IFEQ DEBUG
00000572  1A39 00C00007            999mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000578                          1000mmm     ENDC
00000578                 FALSE    1001mmm     IFNE DEBUG
00000578                          1002mmm     ENDC
00000578                          1003mmm      
00000578  BA3C 001B               1004mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000057C  6700 FA8A               1005mmm     BEQ START
00000580                          1006mmm     ENDM
00000580                          1007mm CONTINUE_57
00000580  1A39 00C00013           1008mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000586  0805 0000               1009mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000058A  67D8                    1010mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000058C                          1011mm     
0000058C  1A39 00C00017           1012mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000592  13C5 00E00001           1013mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000598                          1014mm     
00000598                          1015mm     ENDM
00000598                          1016mm         PRINT_CHAR D5,D6
00000598                          1017mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000598                 TRUE     1018mm     IFEQ DEBUG
00000598  1C39 00C00003           1019mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000059E  0806 0002               1020mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005A2  67F4                    1021mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
000005A4  13C5 00C00007           1022mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005AA                          1023mm     ENDC
000005AA                          1024mm     
000005AA                 FALSE    1025mm     IFNE DEBUG
000005AA                          1026mm     ENDC
000005AA                          1027mm 
000005AA                          1028mm     ENDM
000005AA                          1029mm         HEX2BIN D5,D5,A4
000005AA  49F9 00000E4D           1030mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005B0  0405 0030               1031mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B4  CABC 000000FF           1032mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005BA  1A34 5000               1033mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005BE                          1034mm     ENDM
000005BE  8805                    1035m         OR.B D5,D4
000005C0  5307                    1036m         SUB.B #1,D7
000005C2                          1037m     ENDW
000005C2  6096                    1038ms     BRA _10000004
000005C4                          1039ms _10000005
000005C4                          1040m     
000005C4  7A00                    1041m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005C6  1A04                    1042m     MOVE.B D4,D5
000005C8  D484                    1043m     ADD.L D4,D2
000005CA                          1044m 
000005CA                          1045m     ENDM
000005CA                          1046              
000005CA                          1047              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
000005CA  B23C 0032               1048s     CMP.B   #'2',D1
000005CE  6600 0078               1049s     BNE.L   _00000006
000005D2  5383                    1050                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005D4                          1051m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005D4  1E3C 0002               1052m     MOVE.B #2,D7
000005D8                          1053m     WHILE.B D7 <GT> 0 DO
000005D8                          1054ms _10000006
000005D8  BE38 0000               1055ms     CMP.B   0,D7
000005DC  6F00 0064               1056ms     BLE _10000007
000005E0  E98C                    1057m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005E2                          1058mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005E2                          1059mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                          1060mm 
000005E2  1A39 00C00003           1061mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005E8  0805 0000               1062mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005EC  6700 0010               1063mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005F0                          1064mm  
000005F0                          1065mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005F0                 TRUE     1066mmm     IFEQ DEBUG
000005F0  1A39 00C00007           1067mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005F6                          1068mmm     ENDC
000005F6                 FALSE    1069mmm     IFNE DEBUG
000005F6                          1070mmm     ENDC
000005F6                          1071mmm      
000005F6  BA3C 001B               1072mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005FA  6700 FA0C               1073mmm     BEQ START
000005FE                          1074mmm     ENDM
000005FE                          1075mm CONTINUE_62
000005FE  1A39 00C00013           1076mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000604  0805 0000               1077mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000608  67D8                    1078mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
0000060A                          1079mm     
0000060A  1A39 00C00017           1080mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000610  13C5 00E00001           1081mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000616                          1082mm     
00000616                          1083mm     ENDM
00000616                          1084mm         PRINT_CHAR D5,D6
00000616                          1085mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000616                 TRUE     1086mm     IFEQ DEBUG
00000616  1C39 00C00003           1087mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000061C  0806 0002               1088mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000620  67F4                    1089mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
00000622  13C5 00C00007           1090mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000628                          1091mm     ENDC
00000628                          1092mm     
00000628                 FALSE    1093mm     IFNE DEBUG
00000628                          1094mm     ENDC
00000628                          1095mm 
00000628                          1096mm     ENDM
00000628                          1097mm         HEX2BIN D5,D5,A4
00000628  49F9 00000E4D           1098mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000062E  0405 0030               1099mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000632  CABC 000000FF           1100mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000638  1A34 5000               1101mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000063C                          1102mm     ENDM
0000063C  8805                    1103m         OR.B D5,D4
0000063E  5307                    1104m         SUB.B #1,D7
00000640                          1105m     ENDW
00000640  6096                    1106ms     BRA _10000006
00000642                          1107ms _10000007
00000642                          1108m     
00000642  7A00                    1109m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000644  1A04                    1110m     MOVE.B D4,D5
00000646  D484                    1111m     ADD.L D4,D2
00000648                          1112m 
00000648                          1113m     ENDM
00000648                          1114              ENDI
00000648                          1115s _00000006
00000648                          1116              
00000648  2444                    1117                  MOVE.L D4,A2                            ; put the address in an address register
0000064A  D5C9                    1118              ADD.L A1,A2                             ; add in the offset
0000064C                          1119  
0000064C                          1120              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000064C                          1121s _10000008
0000064C  B63C 0000               1122s     CMP.B   #0,D3
00000650  6F00 007E               1123s     BLE _10000009
00000654                          1124m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000654  1E3C 0002               1125m     MOVE.B #2,D7
00000658                          1126m     WHILE.B D7 <GT> 0 DO
00000658                          1127ms _1000000A
00000658  BE38 0000               1128ms     CMP.B   0,D7
0000065C  6F00 0064               1129ms     BLE _1000000B
00000660  E989                    1130m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000662                          1131mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000662                          1132mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000662                          1133mm 
00000662  1A39 00C00003           1134mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000668  0805 0000               1135mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000066C  6700 0010               1136mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
00000670                          1137mm  
00000670                          1138mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000670                 TRUE     1139mmm     IFEQ DEBUG
00000670  1A39 00C00007           1140mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000676                          1141mmm     ENDC
00000676                 FALSE    1142mmm     IFNE DEBUG
00000676                          1143mmm     ENDC
00000676                          1144mmm      
00000676  BA3C 001B               1145mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000067A  6700 F98C               1146mmm     BEQ START
0000067E                          1147mmm     ENDM
0000067E                          1148mm CONTINUE_67
0000067E  1A39 00C00013           1149mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000684  0805 0000               1150mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000688  67D8                    1151mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
0000068A                          1152mm     
0000068A  1A39 00C00017           1153mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000690  13C5 00E00001           1154mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000696                          1155mm     
00000696                          1156mm     ENDM
00000696                          1157mm         PRINT_CHAR D5,D6
00000696                          1158mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000696                 TRUE     1159mm     IFEQ DEBUG
00000696  1C39 00C00003           1160mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000069C  0806 0002               1161mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006A0  67F4                    1162mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
000006A2  13C5 00C00007           1163mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006A8                          1164mm     ENDC
000006A8                          1165mm     
000006A8                 FALSE    1166mm     IFNE DEBUG
000006A8                          1167mm     ENDC
000006A8                          1168mm 
000006A8                          1169mm     ENDM
000006A8                          1170mm         HEX2BIN D5,D5,A4
000006A8  49F9 00000E4D           1171mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000006AE  0405 0030               1172mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B2  CABC 000000FF           1173mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006B8  1A34 5000               1174mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006BC                          1175mm     ENDM
000006BC  8205                    1176m         OR.B D5,D1
000006BE  5307                    1177m         SUB.B #1,D7
000006C0                          1178m     ENDW
000006C0  6096                    1179ms     BRA _1000000A
000006C2                          1180ms _1000000B
000006C2                          1181m     
000006C2  7A00                    1182m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006C4  1A01                    1183m     MOVE.B D1,D5
000006C6  D481                    1184m     ADD.L D1,D2
000006C8                          1185m 
000006C8                          1186m     ENDM
000006C8                          1187                          
000006C8  14C1                    1188                  MOVE.B D1,(A2)+                     ; store it!
000006CA                          1189  
000006CA  5303                    1190                  SUB.B #1,D3                     ; 1 less byte to go
000006CC                          1191              ENDW
000006CC  6000 FF7E               1192s     BRA _10000008
000006D0                          1193s _10000009
000006D0                          1194          
000006D0  47F8 0392               1195              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006D4                          1196          ELSE
000006D4  6000 01F0               1197s     BRA _00000007
000006D8                          1198s _00000005
000006D8                          1199              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006D8  B23C 0038               1200s     CMP.B   #'8',D1
000006DC  6600 016C               1201s     BNE.L   _00000008
000006E0  7800                    1202                  MOVE.L #0,D4                    ; read the 24 bit start address
000006E2                          1203m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006E2  1E3C 0002               1204m     MOVE.B #2,D7
000006E6                          1205m     WHILE.B D7 <GT> 0 DO
000006E6                          1206ms _1000000C
000006E6  BE38 0000               1207ms     CMP.B   0,D7
000006EA  6F00 0064               1208ms     BLE _1000000D
000006EE  E98C                    1209m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006F0                          1210mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006F0                          1211mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F0                          1212mm 
000006F0  1A39 00C00003           1213mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006F6  0805 0000               1214mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006FA  6700 0010               1215mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
000006FE                          1216mm  
000006FE                          1217mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006FE                 TRUE     1218mmm     IFEQ DEBUG
000006FE  1A39 00C00007           1219mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000704                          1220mmm     ENDC
00000704                 FALSE    1221mmm     IFNE DEBUG
00000704                          1222mmm     ENDC
00000704                          1223mmm      
00000704  BA3C 001B               1224mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000708  6700 F8FE               1225mmm     BEQ START
0000070C                          1226mmm     ENDM
0000070C                          1227mm CONTINUE_72
0000070C  1A39 00C00013           1228mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000712  0805 0000               1229mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000716  67D8                    1230mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
00000718                          1231mm     
00000718  1A39 00C00017           1232mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000071E  13C5 00E00001           1233mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000724                          1234mm     
00000724                          1235mm     ENDM
00000724                          1236mm         PRINT_CHAR D5,D6
00000724                          1237mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000724                 TRUE     1238mm     IFEQ DEBUG
00000724  1C39 00C00003           1239mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000072A  0806 0002               1240mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000072E  67F4                    1241mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
00000730  13C5 00C00007           1242mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000736                          1243mm     ENDC
00000736                          1244mm     
00000736                 FALSE    1245mm     IFNE DEBUG
00000736                          1246mm     ENDC
00000736                          1247mm 
00000736                          1248mm     ENDM
00000736                          1249mm         HEX2BIN D5,D5,A4
00000736  49F9 00000E4D           1250mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000073C  0405 0030               1251mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000740  CABC 000000FF           1252mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000746  1A34 5000               1253mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000074A                          1254mm     ENDM
0000074A  8805                    1255m         OR.B D5,D4
0000074C  5307                    1256m         SUB.B #1,D7
0000074E                          1257m     ENDW
0000074E  6096                    1258ms     BRA _1000000C
00000750                          1259ms _1000000D
00000750                          1260m     
00000750  7A00                    1261m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000752  1A04                    1262m     MOVE.B D4,D5
00000754  D484                    1263m     ADD.L D4,D2
00000756                          1264m 
00000756                          1265m     ENDM
00000756                          1266m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000756  1E3C 0002               1267m     MOVE.B #2,D7
0000075A                          1268m     WHILE.B D7 <GT> 0 DO
0000075A                          1269ms _1000000E
0000075A  BE38 0000               1270ms     CMP.B   0,D7
0000075E  6F00 0064               1271ms     BLE _1000000F
00000762  E98C                    1272m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000764                          1273mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000764                          1274mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000764                          1275mm 
00000764  1A39 00C00003           1276mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000076A  0805 0000               1277mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000076E  6700 0010               1278mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000772                          1279mm  
00000772                          1280mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000772                 TRUE     1281mmm     IFEQ DEBUG
00000772  1A39 00C00007           1282mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000778                          1283mmm     ENDC
00000778                 FALSE    1284mmm     IFNE DEBUG
00000778                          1285mmm     ENDC
00000778                          1286mmm      
00000778  BA3C 001B               1287mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000077C  6700 F88A               1288mmm     BEQ START
00000780                          1289mmm     ENDM
00000780                          1290mm CONTINUE_77
00000780  1A39 00C00013           1291mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000786  0805 0000               1292mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000078A  67D8                    1293mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000078C                          1294mm     
0000078C  1A39 00C00017           1295mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000792  13C5 00E00001           1296mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000798                          1297mm     
00000798                          1298mm     ENDM
00000798                          1299mm         PRINT_CHAR D5,D6
00000798                          1300mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                 TRUE     1301mm     IFEQ DEBUG
00000798  1C39 00C00003           1302mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000079E  0806 0002               1303mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007A2  67F4                    1304mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
000007A4  13C5 00C00007           1305mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007AA                          1306mm     ENDC
000007AA                          1307mm     
000007AA                 FALSE    1308mm     IFNE DEBUG
000007AA                          1309mm     ENDC
000007AA                          1310mm 
000007AA                          1311mm     ENDM
000007AA                          1312mm         HEX2BIN D5,D5,A4
000007AA  49F9 00000E4D           1313mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007B0  0405 0030               1314mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B4  CABC 000000FF           1315mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007BA  1A34 5000               1316mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007BE                          1317mm     ENDM
000007BE  8805                    1318m         OR.B D5,D4
000007C0  5307                    1319m         SUB.B #1,D7
000007C2                          1320m     ENDW
000007C2  6096                    1321ms     BRA _1000000E
000007C4                          1322ms _1000000F
000007C4                          1323m     
000007C4  7A00                    1324m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C6  1A04                    1325m     MOVE.B D4,D5
000007C8  D484                    1326m     ADD.L D4,D2
000007CA                          1327m 
000007CA                          1328m     ENDM
000007CA                          1329m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
000007CA  1E3C 0002               1330m     MOVE.B #2,D7
000007CE                          1331m     WHILE.B D7 <GT> 0 DO
000007CE                          1332ms _10000010
000007CE  BE38 0000               1333ms     CMP.B   0,D7
000007D2  6F00 0064               1334ms     BLE _10000011
000007D6  E98C                    1335m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007D8                          1336mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007D8                          1337mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D8                          1338mm 
000007D8  1A39 00C00003           1339mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007DE  0805 0000               1340mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007E2  6700 0010               1341mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007E6                          1342mm  
000007E6                          1343mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007E6                 TRUE     1344mmm     IFEQ DEBUG
000007E6  1A39 00C00007           1345mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007EC                          1346mmm     ENDC
000007EC                 FALSE    1347mmm     IFNE DEBUG
000007EC                          1348mmm     ENDC
000007EC                          1349mmm      
000007EC  BA3C 001B               1350mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007F0  6700 F816               1351mmm     BEQ START
000007F4                          1352mmm     ENDM
000007F4                          1353mm CONTINUE_82
000007F4  1A39 00C00013           1354mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007FA  0805 0000               1355mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007FE  67D8                    1356mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
00000800                          1357mm     
00000800  1A39 00C00017           1358mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000806  13C5 00E00001           1359mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000080C                          1360mm     
0000080C                          1361mm     ENDM
0000080C                          1362mm         PRINT_CHAR D5,D6
0000080C                          1363mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                 TRUE     1364mm     IFEQ DEBUG
0000080C  1C39 00C00003           1365mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000812  0806 0002               1366mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000816  67F4                    1367mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
00000818  13C5 00C00007           1368mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000081E                          1369mm     ENDC
0000081E                          1370mm     
0000081E                 FALSE    1371mm     IFNE DEBUG
0000081E                          1372mm     ENDC
0000081E                          1373mm 
0000081E                          1374mm     ENDM
0000081E                          1375mm         HEX2BIN D5,D5,A4
0000081E  49F9 00000E4D           1376mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000824  0405 0030               1377mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000828  CABC 000000FF           1378mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000082E  1A34 5000               1379mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000832                          1380mm     ENDM
00000832  8805                    1381m         OR.B D5,D4
00000834  5307                    1382m         SUB.B #1,D7
00000836                          1383m     ENDW
00000836  6096                    1384ms     BRA _10000010
00000838                          1385ms _10000011
00000838                          1386m     
00000838  7A00                    1387m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000083A  1A04                    1388m     MOVE.B D4,D5
0000083C  D484                    1389m     ADD.L D4,D2
0000083E                          1390m 
0000083E                          1391m     ENDM
0000083E                          1392                    
0000083E  2044                    1393                  MOVE.L D4,A0                    ; start address -> A0
00000840                          1394                  
00000840  47F9 00000A02           1395                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000846                          1396              ELSE
00000846  6000 007E               1397s     BRA _00000009
0000084A                          1398s _00000008
0000084A                          1399m                 PRINT_CRLF D5,A4
0000084A  49F9 00000E78           1400m     LEA CRLF,A4
00000850                          1401mm     PRINT_STR A4,D5
00000850                          1402mm LOOP_87
00000850  0C14 0000               1403mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000854  6700 0016               1404mm     BEQ EXIT_87
00000858                          1405mmm     PRINT_CHAR (A4)+,D5
00000858                          1406mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000858                 TRUE     1407mmm     IFEQ DEBUG
00000858  1A39 00C00003           1408mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000085E  0805 0002               1409mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000862  67F4                    1410mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00000864  13DC 00C00007           1411mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000086A                          1412mmm     ENDC
0000086A                          1413mmm     
0000086A                 FALSE    1414mmm     IFNE DEBUG
0000086A                          1415mmm     ENDC
0000086A                          1416mmm 
0000086A                          1417mmm     ENDM
0000086A  60E4                    1418mm     BRA LOOP_87
0000086C                          1419mm EXIT_87
0000086C                          1420mm     ENDM
0000086C                          1421m     ENDM
0000086C                          1422              
0000086C  49F9 00000E02           1423                  LEA UNREC,A4                    ; warn for unrecognised type
00000872                          1424m                 PRINT_STR A4,D5
00000872                          1425m LOOP_89
00000872  0C14 0000               1426m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000876  6700 0016               1427m     BEQ EXIT_89
0000087A                          1428mm     PRINT_CHAR (A4)+,D5
0000087A                          1429mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087A                 TRUE     1430mm     IFEQ DEBUG
0000087A  1A39 00C00003           1431mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000880  0805 0002               1432mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000884  67F4                    1433mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00000886  13DC 00C00007           1434mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000088C                          1435mm     ENDC
0000088C                          1436mm     
0000088C                 FALSE    1437mm     IFNE DEBUG
0000088C                          1438mm     ENDC
0000088C                          1439mm 
0000088C                          1440mm     ENDM
0000088C  60E4                    1441m     BRA LOOP_89
0000088E                          1442m EXIT_89
0000088E                          1443m     ENDM
0000088E                          1444m                 PRINT_CHAR D1,D5
0000088E                          1445m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088E                 TRUE     1446m     IFEQ DEBUG
0000088E  1A39 00C00003           1447m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000894  0805 0002               1448m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000898  67F4                    1449m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0000089A  13C1 00C00007           1450m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008A0                          1451m     ENDC
000008A0                          1452m     
000008A0                 FALSE    1453m     IFNE DEBUG
000008A0                          1454m     ENDC
000008A0                          1455m 
000008A0                          1456m     ENDM
000008A0                          1457m                 PRINT_CRLF D5,A4
000008A0  49F9 00000E78           1458m     LEA CRLF,A4
000008A6                          1459mm     PRINT_STR A4,D5
000008A6                          1460mm LOOP_93
000008A6  0C14 0000               1461mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008AA  6700 0016               1462mm     BEQ EXIT_93
000008AE                          1463mmm     PRINT_CHAR (A4)+,D5
000008AE                          1464mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AE                 TRUE     1465mmm     IFEQ DEBUG
000008AE  1A39 00C00003           1466mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008B4  0805 0002               1467mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008B8  67F4                    1468mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
000008BA  13DC 00C00007           1469mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008C0                          1470mmm     ENDC
000008C0                          1471mmm     
000008C0                 FALSE    1472mmm     IFNE DEBUG
000008C0                          1473mmm     ENDC
000008C0                          1474mmm 
000008C0                          1475mmm     ENDM
000008C0  60E4                    1476mm     BRA LOOP_93
000008C2                          1477mm EXIT_93
000008C2                          1478mm     ENDM
000008C2                          1479m     ENDM
000008C2                          1480              
000008C2  6000 FACE               1481                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
000008C6                          1482              ENDI
000008C6                          1483s _00000009
000008C6                          1484          ENDI
000008C6                          1485s _00000007
000008C6                          1486      ENDI
000008C6                          1487s _00000003
000008C6                          1488      
000008C6                          1489m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
000008C6  1E3C 0002               1490m     MOVE.B #2,D7
000008CA                          1491m     WHILE.B D7 <GT> 0 DO
000008CA                          1492ms _10000012
000008CA  BE38 0000               1493ms     CMP.B   0,D7
000008CE  6F00 0064               1494ms     BLE _10000013
000008D2  E98C                    1495m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008D4                          1496mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008D4                          1497mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D4                          1498mm 
000008D4  1A39 00C00003           1499mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008DA  0805 0000               1500mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008DE  6700 0010               1501mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008E2                          1502mm  
000008E2                          1503mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008E2                 TRUE     1504mmm     IFEQ DEBUG
000008E2  1A39 00C00007           1505mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008E8                          1506mmm     ENDC
000008E8                 FALSE    1507mmm     IFNE DEBUG
000008E8                          1508mmm     ENDC
000008E8                          1509mmm      
000008E8  BA3C 001B               1510mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008EC  6700 F71A               1511mmm     BEQ START
000008F0                          1512mmm     ENDM
000008F0                          1513mm CONTINUE_96
000008F0  1A39 00C00013           1514mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008F6  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008FA  67D8                    1516mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
000008FC                          1517mm     
000008FC  1A39 00C00017           1518mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000902  13C5 00E00001           1519mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000908                          1520mm     
00000908                          1521mm     ENDM
00000908                          1522mm         PRINT_CHAR D5,D6
00000908                          1523mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000908                 TRUE     1524mm     IFEQ DEBUG
00000908  1C39 00C00003           1525mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000090E  0806 0002               1526mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000912  67F4                    1527mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00000914  13C5 00C00007           1528mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000091A                          1529mm     ENDC
0000091A                          1530mm     
0000091A                 FALSE    1531mm     IFNE DEBUG
0000091A                          1532mm     ENDC
0000091A                          1533mm 
0000091A                          1534mm     ENDM
0000091A                          1535mm         HEX2BIN D5,D5,A4
0000091A  49F9 00000E4D           1536mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000920  0405 0030               1537mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000924  CABC 000000FF           1538mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000092A  1A34 5000               1539mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000092E                          1540mm     ENDM
0000092E  8805                    1541m         OR.B D5,D4
00000930  5307                    1542m         SUB.B #1,D7
00000932                          1543m     ENDW
00000932  6096                    1544ms     BRA _10000012
00000934                          1545ms _10000013
00000934                          1546m     
00000934  7A00                    1547m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000936  1A04                    1548m     MOVE.B D4,D5
00000938  D484                    1549m     ADD.L D4,D2
0000093A                          1550m 
0000093A                          1551m     ENDM
0000093A                          1552m     PRINT_CRLF D5,A4
0000093A  49F9 00000E78           1553m     LEA CRLF,A4
00000940                          1554mm     PRINT_STR A4,D5
00000940                          1555mm LOOP_101
00000940  0C14 0000               1556mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000944  6700 0016               1557mm     BEQ EXIT_101
00000948                          1558mmm     PRINT_CHAR (A4)+,D5
00000948                          1559mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000948                 TRUE     1560mmm     IFEQ DEBUG
00000948  1A39 00C00003           1561mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000094E  0805 0002               1562mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000952  67F4                    1563mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000954  13DC 00C00007           1564mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000095A                          1565mmm     ENDC
0000095A                          1566mmm     
0000095A                 FALSE    1567mmm     IFNE DEBUG
0000095A                          1568mmm     ENDC
0000095A                          1569mmm 
0000095A                          1570mmm     ENDM
0000095A  60E4                    1571mm     BRA LOOP_101
0000095C                          1572mm EXIT_101
0000095C                          1573mm     ENDM
0000095C                          1574m     ENDM
0000095C                          1575          
0000095C                          1576      IF.B D2 <NE> #$FF THEN.L
0000095C  B43C 00FF               1577s     CMP.B   #$FF,D2
00000960  6700 009E               1578s     BEQ.L   _0000000A
00000964  49F9 00000E19           1579          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
0000096A                          1580m         PRINT_STR A4,D5
0000096A                          1581m LOOP_103
0000096A  0C14 0000               1582m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000096E  6700 0016               1583m     BEQ EXIT_103
00000972                          1584mm     PRINT_CHAR (A4)+,D5
00000972                          1585mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000972                 TRUE     1586mm     IFEQ DEBUG
00000972  1A39 00C00003           1587mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000978  0805 0002               1588mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000097C  67F4                    1589mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000097E  13DC 00C00007           1590mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000984                          1591mm     ENDC
00000984                          1592mm     
00000984                 FALSE    1593mm     IFNE DEBUG
00000984                          1594mm     ENDC
00000984                          1595mm 
00000984                          1596mm     ENDM
00000984  60E4                    1597m     BRA LOOP_103
00000986                          1598m EXIT_103
00000986                          1599m     ENDM
00000986                          1600m         PRINT_REG D0,D5,D2,D6,A4
00000986                          1601mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000986                          1602mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000986                 TRUE     1603mm     IFEQ DEBUG
00000986  1A39 00C00003           1604mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000098C  0805 0002               1605mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000990  67F4                    1606mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000992  13FC 0030 00C00007      1607mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000099A                          1608mm     ENDC
0000099A                          1609mm     
0000099A                 FALSE    1610mm     IFNE DEBUG
0000099A                          1611mm     ENDC
0000099A                          1612mm 
0000099A                          1613mm     ENDM
0000099A                          1614mm     PRINT_CHAR #'x',D5
0000099A                          1615mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099A                 TRUE     1616mm     IFEQ DEBUG
0000099A  1A39 00C00003           1617mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009A0  0805 0002               1618mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009A4  67F4                    1619mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
000009A6  13FC 0078 00C00007      1620mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
000009AE                          1621mm     ENDC
000009AE                          1622mm     
000009AE                 FALSE    1623mm     IFNE DEBUG
000009AE                          1624mm     ENDC
000009AE                          1625mm 
000009AE                          1626mm     ENDM
000009AE  7C07                    1627m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009B0                          1628m LOOP_105
000009B0                          1629mm     BIN2HEX D0,D2,A4
000009B0  49F9 00000E3D           1630mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
000009B6  E998                    1631mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009B8  1400                    1632mm     MOVE.B D0,D2
000009BA  0282 0000000F           1633mm     ANDI.L #$F,D2
000009C0  1434 2000               1634mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
000009C4                          1635mm     ENDM
000009C4                          1636mm     PRINT_CHAR D2,D5
000009C4                          1637mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C4                 TRUE     1638mm     IFEQ DEBUG
000009C4  1A39 00C00003           1639mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009CA  0805 0002               1640mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009CE  67F4                    1641mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
000009D0  13C2 00C00007           1642mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009D6                          1643mm     ENDC
000009D6                          1644mm     
000009D6                 FALSE    1645mm     IFNE DEBUG
000009D6                          1646mm     ENDC
000009D6                          1647mm 
000009D6                          1648mm     ENDM
000009D6  57CE FFD8               1649m     DBEQ D6,LOOP_105
000009DA                          1650m     ENDM
000009DA                          1651m         PRINT_CRLF D5,A4
000009DA  49F9 00000E78           1652m     LEA CRLF,A4
000009E0                          1653mm     PRINT_STR A4,D5
000009E0                          1654mm LOOP_111
000009E0  0C14 0000               1655mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009E4  6700 0016               1656mm     BEQ EXIT_111
000009E8                          1657mmm     PRINT_CHAR (A4)+,D5
000009E8                          1658mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E8                 TRUE     1659mmm     IFEQ DEBUG
000009E8  1A39 00C00003           1660mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009EE  0805 0002               1661mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009F2  67F4                    1662mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
000009F4  13DC 00C00007           1663mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009FA                          1664mmm     ENDC
000009FA                          1665mmm     
000009FA                 FALSE    1666mmm     IFNE DEBUG
000009FA                          1667mmm     ENDC
000009FA                          1668mmm 
000009FA                          1669mmm     ENDM
000009FA  60E4                    1670mm     BRA LOOP_111
000009FC                          1671mm EXIT_111
000009FC                          1672mm     ENDM
000009FC                          1673m     ENDM
000009FC  6000 F766               1674          BRA MAIN_LOOP
00000A00                          1675      ENDI
00000A00                          1676s _0000000A
00000A00                          1677      
00000A00  4ED3                    1678      JMP (A3)
00000A02                          1679  DOWNLOAD_DONE
00000A02                          1680m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A02                          1681mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A02                          1682mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A02                 TRUE     1683mm     IFEQ DEBUG
00000A02  1A39 00C00003           1684mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A08  0805 0002               1685mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0C  67F4                    1686mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000A0E  13FC 0030 00C00007      1687mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A16                          1688mm     ENDC
00000A16                          1689mm     
00000A16                 FALSE    1690mm     IFNE DEBUG
00000A16                          1691mm     ENDC
00000A16                          1692mm 
00000A16                          1693mm     ENDM
00000A16                          1694mm     PRINT_CHAR #'x',D5
00000A16                          1695mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1696mm     IFEQ DEBUG
00000A16  1A39 00C00003           1697mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A1C  0805 0002               1698mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1699mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000A22  13FC 0078 00C00007      1700mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A2A                          1701mm     ENDC
00000A2A                          1702mm     
00000A2A                 FALSE    1703mm     IFNE DEBUG
00000A2A                          1704mm     ENDC
00000A2A                          1705mm 
00000A2A                          1706mm     ENDM
00000A2A  7407                    1707m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A2C                          1708m LOOP_113
00000A2C                          1709mm     BIN2HEX D0,D6,A1
00000A2C  43F9 00000E3D           1710mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A32  E998                    1711mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A34  1C00                    1712mm     MOVE.B D0,D6
00000A36  0286 0000000F           1713mm     ANDI.L #$F,D6
00000A3C  1C31 6000               1714mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A40                          1715mm     ENDM
00000A40                          1716mm     PRINT_CHAR D6,D5
00000A40                          1717mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A40                 TRUE     1718mm     IFEQ DEBUG
00000A40  1A39 00C00003           1719mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A46  0805 0002               1720mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A4A  67F4                    1721mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A4C  13C6 00C00007           1722mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A52                          1723mm     ENDC
00000A52                          1724mm     
00000A52                 FALSE    1725mm     IFNE DEBUG
00000A52                          1726mm     ENDC
00000A52                          1727mm 
00000A52                          1728mm     ENDM
00000A52  57CA FFD8               1729m     DBEQ D2,LOOP_113
00000A56                          1730m     ENDM
00000A56  43F9 00000DE0           1731      LEA READ,A1
00000A5C                          1732m     PRINT_STR A1,D5
00000A5C                          1733m LOOP_118
00000A5C  0C11 0000               1734m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A60  6700 0016               1735m     BEQ EXIT_118
00000A64                          1736mm     PRINT_CHAR (A1)+,D5
00000A64                          1737mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A64                 TRUE     1738mm     IFEQ DEBUG
00000A64  1A39 00C00003           1739mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A6A  0805 0002               1740mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A6E  67F4                    1741mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A70  13D9 00C00007           1742mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A76                          1743mm     ENDC
00000A76                          1744mm     
00000A76                 FALSE    1745mm     IFNE DEBUG
00000A76                          1746mm     ENDC
00000A76                          1747mm 
00000A76                          1748mm     ENDM
00000A76  60E4                    1749m     BRA LOOP_118
00000A78                          1750m EXIT_118
00000A78                          1751m     ENDM
00000A78  2E08                    1752      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A7A                          1753m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A7A                          1754mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00000A7A                          1755mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A7A                 TRUE     1756mm     IFEQ DEBUG
00000A7A  1A39 00C00003           1757mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A80  0805 0002               1758mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A84  67F4                    1759mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A86  13FC 0030 00C00007      1760mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A8E                          1761mm     ENDC
00000A8E                          1762mm     
00000A8E                 FALSE    1763mm     IFNE DEBUG
00000A8E                          1764mm     ENDC
00000A8E                          1765mm 
00000A8E                          1766mm     ENDM
00000A8E                          1767mm     PRINT_CHAR #'x',D5
00000A8E                          1768mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A8E                 TRUE     1769mm     IFEQ DEBUG
00000A8E  1A39 00C00003           1770mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A94  0805 0002               1771mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A98  67F4                    1772mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000A9A  13FC 0078 00C00007      1773mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AA2                          1774mm     ENDC
00000AA2                          1775mm     
00000AA2                 FALSE    1776mm     IFNE DEBUG
00000AA2                          1777mm     ENDC
00000AA2                          1778mm 
00000AA2                          1779mm     ENDM
00000AA2  7407                    1780m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AA4                          1781m LOOP_120
00000AA4                          1782mm     BIN2HEX D7,D6,A1
00000AA4  43F9 00000E3D           1783mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000AAA  E99F                    1784mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AAC  1C07                    1785mm     MOVE.B D7,D6
00000AAE  0286 0000000F           1786mm     ANDI.L #$F,D6
00000AB4  1C31 6000               1787mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000AB8                          1788mm     ENDM
00000AB8                          1789mm     PRINT_CHAR D6,D5
00000AB8                          1790mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB8                 TRUE     1791mm     IFEQ DEBUG
00000AB8  1A39 00C00003           1792mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ABE  0805 0002               1793mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AC2  67F4                    1794mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000AC4  13C6 00C00007           1795mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000ACA                          1796mm     ENDC
00000ACA                          1797mm     
00000ACA                 FALSE    1798mm     IFNE DEBUG
00000ACA                          1799mm     ENDC
00000ACA                          1800mm 
00000ACA                          1801mm     ENDM
00000ACA  57CA FFD8               1802m     DBEQ D2,LOOP_120
00000ACE                          1803m     ENDM
00000ACE                          1804m     PRINT_CRLF D5,A4     
00000ACE  49F9 00000E78           1805m     LEA CRLF,A4
00000AD4                          1806mm     PRINT_STR A4,D5
00000AD4                          1807mm LOOP_126
00000AD4  0C14 0000               1808mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000AD8  6700 0016               1809mm     BEQ EXIT_126
00000ADC                          1810mmm     PRINT_CHAR (A4)+,D5
00000ADC                          1811mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ADC                 TRUE     1812mmm     IFEQ DEBUG
00000ADC  1A39 00C00003           1813mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AE2  0805 0002               1814mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AE6  67F4                    1815mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AE8  13DC 00C00007           1816mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AEE                          1817mmm     ENDC
00000AEE                          1818mmm     
00000AEE                 FALSE    1819mmm     IFNE DEBUG
00000AEE                          1820mmm     ENDC
00000AEE                          1821mmm 
00000AEE                          1822mmm     ENDM
00000AEE  60E4                    1823mm     BRA LOOP_126
00000AF0                          1824mm EXIT_126
00000AF0                          1825mm     ENDM
00000AF0                          1826m     ENDM
00000AF0                          1827          
00000AF0  6000 F672               1828      BRA MAIN_LOOP
00000AF4                          1829      
00000AF4                          1830  G
00000AF4  2047                    1831      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AF6  3E3C 0000               1832      MOVE #0,D7                                      ; clear the now used address accumulator
00000AFA  4ED0                    1833      JMP (A0)                                        ; jump to it!
00000AFC                          1834      
00000AFC                          1835  Z
00000AFC  207C 00200000           1836      MOVE.L #RAM,A0                                  ; address of RAM
00000B02                          1837      
00000B02                          1838      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000B02  7000                    1839s     MOVE.L  #0,D0
00000B04  6000 0012               1840s     BRA _20000001
00000B08                          1841s _20000000
00000B08  2200                    1842              MOVE.L D0,D1                              ; progress update
00000B0A  E089                    1843          LSR.L #8,D1 
00000B0C  E089                    1844          LSR.L #8,D1
00000B0E  13C1 00E00001           1845          MOVE.B D1,DISPLAY
00000B14                          1846  
00000B14  20C0                    1847          MOVE.L D0,(A0)+
00000B16                          1848      ENDF
00000B16  5880                    1849s     ADD.L   #4,D0
00000B18                          1850s _20000001
00000B18  B0BC 00040000           1851s     CMP.L   #$40000,D0
00000B1E  6FE8                    1852s     BLE _20000000
00000B20                          1853   
00000B20  207C 00200000           1854      MOVE.L #RAM,A0                                    ; address of RAM
00000B26                          1855     
00000B26                          1856      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000B26  7000                    1857s     MOVE.L  #0,D0
00000B28  6000 00B4               1858s     BRA _20000003
00000B2C                          1859s _20000002
00000B2C  2200                    1860          MOVE.L D0,D1                              ; progress update
00000B2E  E089                    1861          LSR.L #8,D1
00000B30  E089                    1862          LSR.L #8,D1
00000B32  13C1 00E00001           1863          MOVE.B D1,DISPLAY
00000B38                          1864  
00000B38  2218                    1865          MOVE.L (A0)+,D1
00000B3A                          1866            
00000B3A                          1867          IF.L D0 <NE> D1 THEN      
00000B3A  B081                    1868s     CMP.L   D1,D0
00000B3C  6700 009E               1869s     BEQ _0000000B
00000B40  43F9 00000E2B           1870              LEA RAM_ERROR,A1
00000B46                          1871m             PRINT_STR A1,D1
00000B46                          1872m LOOP_128
00000B46  0C11 0000               1873m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B4A  6700 0016               1874m     BEQ EXIT_128
00000B4E                          1875mm     PRINT_CHAR (A1)+,D1
00000B4E                          1876mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4E                 TRUE     1877mm     IFEQ DEBUG
00000B4E  1239 00C00003           1878mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B54  0801 0002               1879mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B58  67F4                    1880mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B5A  13D9 00C00007           1881mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B60                          1882mm     ENDC
00000B60                          1883mm     
00000B60                 FALSE    1884mm     IFNE DEBUG
00000B60                          1885mm     ENDC
00000B60                          1886mm 
00000B60                          1887mm     ENDM
00000B60  60E4                    1888m     BRA LOOP_128
00000B62                          1889m EXIT_128
00000B62                          1890m     ENDM
00000B62  2208                    1891              MOVE.L A0,D1
00000B64  5981                    1892              SUB.L #4,D1
00000B66                          1893m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B66                          1894mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00000B66                          1895mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B66                 TRUE     1896mm     IFEQ DEBUG
00000B66  1639 00C00003           1897mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B6C  0803 0002               1898mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B70  67F4                    1899mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B72  13FC 0030 00C00007      1900mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B7A                          1901mm     ENDC
00000B7A                          1902mm     
00000B7A                 FALSE    1903mm     IFNE DEBUG
00000B7A                          1904mm     ENDC
00000B7A                          1905mm 
00000B7A                          1906mm     ENDM
00000B7A                          1907mm     PRINT_CHAR #'x',D3
00000B7A                          1908mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7A                 TRUE     1909mm     IFEQ DEBUG
00000B7A  1639 00C00003           1910mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B80  0803 0002               1911mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B84  67F4                    1912mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000B86  13FC 0078 00C00007      1913mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B8E                          1914mm     ENDC
00000B8E                          1915mm     
00000B8E                 FALSE    1916mm     IFNE DEBUG
00000B8E                          1917mm     ENDC
00000B8E                          1918mm 
00000B8E                          1919mm     ENDM
00000B8E  7C07                    1920m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B90                          1921m LOOP_130
00000B90                          1922mm     BIN2HEX D1,D2,A1
00000B90  43F9 00000E3D           1923mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B96  E999                    1924mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B98  1401                    1925mm     MOVE.B D1,D2
00000B9A  0282 0000000F           1926mm     ANDI.L #$F,D2
00000BA0  1431 2000               1927mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BA4                          1928mm     ENDM
00000BA4                          1929mm     PRINT_CHAR D2,D3
00000BA4                          1930mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     1931mm     IFEQ DEBUG
00000BA4  1639 00C00003           1932mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BAA  0803 0002               1933mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    1934mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000BB0  13C2 00C00007           1935mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BB6                          1936mm     ENDC
00000BB6                          1937mm     
00000BB6                 FALSE    1938mm     IFNE DEBUG
00000BB6                          1939mm     ENDC
00000BB6                          1940mm 
00000BB6                          1941mm     ENDM
00000BB6  57CE FFD8               1942m     DBEQ D6,LOOP_130
00000BBA                          1943m     ENDM
00000BBA                          1944m             PRINT_CRLF D3,A1
00000BBA  43F9 00000E78           1945m     LEA CRLF,A1
00000BC0                          1946mm     PRINT_STR A1,D3
00000BC0                          1947mm LOOP_136
00000BC0  0C11 0000               1948mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BC4  6700 0016               1949mm     BEQ EXIT_136
00000BC8                          1950mmm     PRINT_CHAR (A1)+,D3
00000BC8                          1951mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1952mmm     IFEQ DEBUG
00000BC8  1639 00C00003           1953mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BCE  0803 0002               1954mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1955mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000BD4  13D9 00C00007           1956mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BDA                          1957mmm     ENDC
00000BDA                          1958mmm     
00000BDA                 FALSE    1959mmm     IFNE DEBUG
00000BDA                          1960mmm     ENDC
00000BDA                          1961mmm 
00000BDA                          1962mmm     ENDM
00000BDA  60E4                    1963mm     BRA LOOP_136
00000BDC                          1964mm EXIT_136
00000BDC                          1965mm     ENDM
00000BDC                          1966m     ENDM
00000BDC                          1967          ENDI 
00000BDC                          1968s _0000000B
00000BDC                          1969      ENDF
00000BDC  5880                    1970s     ADD.L   #4,D0
00000BDE                          1971s _20000003
00000BDE  B0BC 00040000           1972s     CMP.L   #$40000,D0
00000BE4  6F00 FF46               1973s     BLE _20000002
00000BE8                          1974      
00000BE8  6000 F57A               1975      BRA MAIN_LOOP
00000BEC                          1976    
00000BEC                          1977  L
00000BEC  7A00                    1978      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000BEE                          1979  
00000BEE                          1980      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000BEE  3C3C 0000               1981s     MOVE.W  #0,D6
00000BF2  6000 0048               1982s     BRA _20000005
00000BF6                          1983s _20000004
00000BF6  E98D                    1984          LSL.L #4,D5                                 ; make what we have so far more significant
00000BF8                          1985m         WAIT_CHAR D2,D3                             ; next character -> D2
00000BF8                          1986m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF8                 TRUE     1987m     IFEQ DEBUG
00000BF8  1639 00C00003           1988m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BFE  0803 0000               1989m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000C02  67F4                    1990m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000C04                          1991m     ENDC
00000C04                          1992m     
00000C04                          1993mm     READ_CHAR D2
00000C04                 TRUE     1994mm     IFEQ DEBUG
00000C04  1439 00C00007           1995mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000C0A                          1996mm     ENDC
00000C0A                 FALSE    1997mm     IFNE DEBUG
00000C0A                          1998mm     ENDC
00000C0A                          1999mm      
00000C0A  B43C 001B               2000mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000C0E  6700 F3F8               2001mm     BEQ START
00000C12                          2002mm     ENDM
00000C12                          2003m 
00000C12                 TRUE     2004m     IFEQ DEBUG
00000C12                          2005mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000C12                          2006mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C12                 TRUE     2007mm     IFEQ DEBUG
00000C12  1639 00C00003           2008mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C18  0803 0002               2009mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C1C  67F4                    2010mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000C1E  13C2 00C00007           2011mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C24                          2012mm     ENDC
00000C24                          2013mm     
00000C24                 FALSE    2014mm     IFNE DEBUG
00000C24                          2015mm     ENDC
00000C24                          2016mm 
00000C24                          2017mm     ENDM
00000C24                          2018m     ENDC
00000C24                          2019m     ENDM
00000C24                          2020m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000C24  41F9 00000E4D           2021m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000C2A  0402 0030               2022m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C2E  C4BC 000000FF           2023m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000C34  1430 2000               2024m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000C38                          2025m     ENDM
00000C38  8A02                    2026          OR.B D2,D5
00000C3A                          2027      ENDF
00000C3A  5246                    2028s     ADD.W   #1,D6
00000C3C                          2029s _20000005
00000C3C  BC7C 0003               2030s     CMP.W   #3,D6
00000C40  6FB4                    2031s     BLE _20000004
00000C42                          2032            
00000C42                          2033m     PRINT_CRLF D3,A0
00000C42  41F9 00000E78           2034m     LEA CRLF,A0
00000C48                          2035mm     PRINT_STR A0,D3
00000C48                          2036mm LOOP_143
00000C48  0C10 0000               2037mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C4C  6700 0016               2038mm     BEQ EXIT_143
00000C50                          2039mmm     PRINT_CHAR (A0)+,D3
00000C50                          2040mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C50                 TRUE     2041mmm     IFEQ DEBUG
00000C50  1639 00C00003           2042mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C56  0803 0002               2043mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C5A  67F4                    2044mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C5C  13D8 00C00007           2045mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C62                          2046mmm     ENDC
00000C62                          2047mmm     
00000C62                 FALSE    2048mmm     IFNE DEBUG
00000C62                          2049mmm     ENDC
00000C62                          2050mmm 
00000C62                          2051mmm     ENDM
00000C62  60E4                    2052mm     BRA LOOP_143
00000C64                          2053mm EXIT_143
00000C64                          2054mm     ENDM
00000C64                          2055m     ENDM
00000C64                          2056  
00000C64  207C 00000000           2057      MOVE.L #ROM,A0                                  ; start of ROM
00000C6A                          2058      
00000C6A  2247                    2059      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C6C  7E00                    2060      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C6E                          2061      
00000C6E  31FC AAAA 2AAA          2062      MOVE.W #$AAAA,$2AAA
00000C74  31FC 5555 1554          2063      MOVE.W #$5555,$1554
00000C7A  31FC 8080 2AAA          2064      MOVE.W #$8080,$2AAA
00000C80  31FC AAAA 2AAA          2065      MOVE.W #$AAAA,$2AAA
00000C86  31FC 5555 1554          2066      MOVE.W #$5555,$1554
00000C8C  31FC 2020 2AAA          2067      MOVE.W #$2020,$2AAA
00000C92                          2068      
00000C92  45F9 00000E64           2069      LEA LOADING,A2                              ; important for timing
00000C98                          2070m     PRINT_STR A2,D3
00000C98                          2071m LOOP_145
00000C98  0C12 0000               2072m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C9C  6700 0016               2073m     BEQ EXIT_145
00000CA0                          2074mm     PRINT_CHAR (A2)+,D3
00000CA0                          2075mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA0                 TRUE     2076mm     IFEQ DEBUG
00000CA0  1639 00C00003           2077mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CA6  0803 0002               2078mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CAA  67F4                    2079mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000CAC  13DA 00C00007           2080mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CB2                          2081mm     ENDC
00000CB2                          2082mm     
00000CB2                 FALSE    2083mm     IFNE DEBUG
00000CB2                          2084mm     ENDC
00000CB2                          2085mm 
00000CB2                          2086mm     ENDM
00000CB2  60E4                    2087m     BRA LOOP_145
00000CB4                          2088m EXIT_145
00000CB4                          2089m     ENDM
00000CB4                          2090      
00000CB4                          2091      WHILE D5 <GT> #0 DO
00000CB4                          2092s _10000014
00000CB4  BA7C 0000               2093s     CMP.W   #0,D5
00000CB8  6F00 001C               2094s     BLE _10000015
00000CBC  5585                    2095          SUB.L #2,D5
00000CBE                          2096            
00000CBE  13D1 00E00001           2097          MOVE.B (A1),DISPLAY
00000CC4  3091                    2098          MOVE.W (A1),(A0)                            ; write the data
00000CC6                          2099        
00000CC6                          2100  WAIT_FOR_COMPLETE
00000CC6  3410                    2101          MOVE.W (A0),D2
00000CC8                          2102  
00000CC8                          2103          IF D2 <NE> (A1) THEN
00000CC8  B451                    2104s     CMP.W   (A1),D2
00000CCA  6700 0004               2105s     BEQ _0000000C
00000CCE  60F6                    2106              BRA WAIT_FOR_COMPLETE
00000CD0                          2107          ENDI
00000CD0                          2108s _0000000C
00000CD0                          2109        
00000CD0  5488                    2110          ADD.L #2,A0
00000CD2  5489                    2111          ADD.L #2,A1
00000CD4                          2112       ENDW    
00000CD4  60DE                    2113s     BRA _10000014
00000CD6                          2114s _10000015
00000CD6                          2115      
00000CD6  31FC AAAA 2AAA          2116      MOVE.W #$AAAA,$2AAA
00000CDC  31FC 5555 1554          2117      MOVE.W #$5555,$1554
00000CE2  31FC A0A0 2AAA          2118      MOVE.W #$A0A0,$2AAA
00000CE8                          2119              
00000CE8  6000 F47A               2120      BRA MAIN_LOOP
00000CEC                          2121          
00000CEC                          2122  HEX_DIGIT
00000CEC  E98F                    2123      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000CEE                          2124m     HEX2BIN D2,D2,A0
00000CEE  41F9 00000E4D           2125m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000CF4  0402 0030               2126m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CF8  C4BC 000000FF           2127m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000CFE  1430 2000               2128m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000D02                          2129m     ENDM
00000D02  8E02                    2130      OR.B D2,D7  
00000D04  6000 F480               2131      BRA GET_INPUT
00000D08                          2132  
00000D08  FFFF FFFF               2133      SIMHALT                                         ; halt simulator
00000D0C                          2134  
00000D0C                          2135  ; strings
00000D0C= 4D 44 46 2D 6D 6F ...   2136  VERSION DC.B 'MDF-mon V1.54 (10/04/2021)',CR,LF,NULL
00000D29= 3F 09 09 09 68 65 ...   2137  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000D33= 5B 76 5D 09 09 09 ...   2138          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000D42= 78 78 78 78 78 78 ...   2139          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D5A= 78 78 78 78 78 78 ...   2140          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D7A= 5B 73 5D 09 09 09 ...   2141          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000D94= 78 78 78 78 78 78 ...   2142          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000DA5= 5B 7A 5D 09 09 09 ...   2143          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000DB7= 78 78 78 78 78 78 ...   2144          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000DD9= 48 75 68 3F 0D 0A 00    2145  HUH     DC.B 'Huh?',CR,LF,NULL
00000DE0= 20 53 20 72 65 63 ...   2146  READ    DC.B ' S records read, start address = ',NULL
00000E02= 57 3A 20 55 6E 6B ...   2147  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000E19= 57 3A 20 43 53 20 ...   2148  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000E2B= 57 3A 20 52 41 4D ...   2149  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000E3D= 30 31 32 33 34 35 ...   2150  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E4D= 00 01 02 03 04 05 ...   2151  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E64= 4C 6F 61 64 69 6E ...   2152  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E78= 0D 0A 00                2153  CRLF    DC.B CR,LF,NULL
00000E7B= 3E 20 00                2154  PROMPT  DC.B '> ',NULL
00000E7E                          2155      
00000E7E                          2156      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         E3D
CONTINUE_37         3AE
CONTINUE_40         3FE
CONTINUE_44         454
CONTINUE_52         50C
CONTINUE_57         580
CONTINUE_62         5FE
CONTINUE_67         67E
CONTINUE_72         70C
CONTINUE_77         780
CONTINUE_82         7F4
CONTINUE_96         8F0
CR                  D
CRLF                E78
CS_FAILURE          E19
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            962
DOWNLOAD_BYTE       C47
DOWNLOAD_DONE       A02
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             186
EXIT_101            95C
EXIT_103            986
EXIT_111            9FC
EXIT_118            A78
EXIT_126            AF0
EXIT_128            B62
EXIT_136            BDC
EXIT_143            C64
EXIT_145            CB4
EXIT_16             20C
EXIT_18             25E
EXIT_20             28E
EXIT_28             30E
EXIT_3              116
EXIT_35             386
EXIT_49             4C8
EXIT_5              138
EXIT_8              15A
EXIT_87             86C
EXIT_89             88E
EXIT_93             8C2
G                   AF4
GET_INPUT           186
H                   262
HELP                D29
HEX2BIN             134
HEX2BIN_LUT         E4D
HEX_DIGIT           CEC
HUH                 DD9
L                   BEC
LF                  A
LOADING             E64
LOOP_10             16A
LOOP_101            940
LOOP_103            96A
LOOP_105            9B0
LOOP_111            9E0
LOOP_113            A2C
LOOP_118            A5C
LOOP_120            AA4
LOOP_126            AD4
LOOP_128            B46
LOOP_130            B90
LOOP_136            BC0
LOOP_143            C48
LOOP_145            C98
LOOP_16             1F0
LOOP_18             242
LOOP_20             272
LOOP_22             2C2
LOOP_28             2F2
LOOP_3              FA
LOOP_35             36A
LOOP_49             4AC
LOOP_5              11C
LOOP_8              13E
LOOP_87             850
LOOP_89             872
LOOP_93             8A6
MAIN_LOOP           164
NULL                0
PRINTSTR            272
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
PROMPT              E7B
R                   292
RAM                 200000
RAM_ERROR           E2B
READ                DE0
READ_CHAR           7FC
READ_DATA_TO_POKE   316
RESET               4
ROM                 0
S                   38A
STACK               0
START               8
TAB                 9
UNREC               E02
V                   26C
VERSION             D0C
W                   312
WAIT_CHAR           64D
WAIT_FOR_COMPLETE   CC6
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_102  948
WAIT_FOR_READY_104  972
WAIT_FOR_READY_106  986
WAIT_FOR_READY_107  99A
WAIT_FOR_READY_109  9C4
WAIT_FOR_READY_11   172
WAIT_FOR_READY_112  9E8
WAIT_FOR_READY_114  A02
WAIT_FOR_READY_115  A16
WAIT_FOR_READY_117  A40
WAIT_FOR_READY_119  A64
WAIT_FOR_READY_12   186
WAIT_FOR_READY_121  A7A
WAIT_FOR_READY_122  A8E
WAIT_FOR_READY_124  AB8
WAIT_FOR_READY_127  ADC
WAIT_FOR_READY_129  B4E
WAIT_FOR_READY_131  B66
WAIT_FOR_READY_132  B7A
WAIT_FOR_READY_134  BA4
WAIT_FOR_READY_137  BC8
WAIT_FOR_READY_138  BF8
WAIT_FOR_READY_14   1A0
WAIT_FOR_READY_140  C12
WAIT_FOR_READY_144  C50
WAIT_FOR_READY_146  CA0
WAIT_FOR_READY_17   1F8
WAIT_FOR_READY_19   24A
WAIT_FOR_READY_21   27A
WAIT_FOR_READY_23   298
WAIT_FOR_READY_24   2AC
WAIT_FOR_READY_26   2D6
WAIT_FOR_READY_29   2FA
WAIT_FOR_READY_30   318
WAIT_FOR_READY_32   332
WAIT_FOR_READY_36   372
WAIT_FOR_READY_37   392
WAIT_FOR_READY_39   3CC
WAIT_FOR_READY_4    102
WAIT_FOR_READY_40   3E2
WAIT_FOR_READY_42   416
WAIT_FOR_READY_44   438
WAIT_FOR_READY_46   46C
WAIT_FOR_READY_50   4B4
WAIT_FOR_READY_52   4F0
WAIT_FOR_READY_54   524
WAIT_FOR_READY_57   564
WAIT_FOR_READY_59   598
WAIT_FOR_READY_6    124
WAIT_FOR_READY_62   5E2
WAIT_FOR_READY_64   616
WAIT_FOR_READY_67   662
WAIT_FOR_READY_69   696
WAIT_FOR_READY_72   6F0
WAIT_FOR_READY_74   724
WAIT_FOR_READY_77   764
WAIT_FOR_READY_79   798
WAIT_FOR_READY_82   7D8
WAIT_FOR_READY_84   80C
WAIT_FOR_READY_88   858
WAIT_FOR_READY_9    146
WAIT_FOR_READY_90   87A
WAIT_FOR_READY_91   88E
WAIT_FOR_READY_94   8AE
WAIT_FOR_READY_96   8D4
WAIT_FOR_READY_98   908
WAIT_FOR_SRECORD    392
Z                   AFC
_00000000           1C6
_00000001           1DA
_00000002           4D0
_00000003           8C6
_00000004           4DE
_00000005           6D8
_00000006           648
_00000007           8C6
_00000008           84A
_00000009           8C6
_0000000A           A00
_0000000B           BDC
_0000000C           CD0
_10000000           42E
_10000001           498
_10000002           4E6
_10000003           550
_10000004           55A
_10000005           5C4
_10000006           5D8
_10000007           642
_10000008           64C
_10000009           6D0
_1000000A           658
_1000000B           6C2
_1000000C           6E6
_1000000D           750
_1000000E           75A
_1000000F           7C4
_10000010           7CE
_10000011           838
_10000012           8CA
_10000013           934
_10000014           CB4
_10000015           CD6
_20000000           B08
_20000001           B18
_20000002           B2C
_20000003           BDE
_20000004           BF6
_20000005           C3C
