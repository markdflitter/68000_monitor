00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 12:49:28

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                             9  ; something prints 'N' on starting...
00000000                            10  ; press ? for help
00000000                            11  ; use DBLoop?
00000000                            12  
00000000                            13  ; ideas, but no room to do them
00000000                            14  ;------------------------------
00000000                            15  ; keep track of highest address hit during srec download
00000000                            16  ; implement backspace
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            20  
00000000                            21      ORG  $0
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF(PC),\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      LEA ox(PC),\5
00000000                           143      PRINT_STR \5,\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  ; write word to EEPROM
00000000                           227  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           228  PROGRAM MACRO
00000000                           229    MOVE.W \1,\2                          ; write the data
00000000                           230        
00000000                           231  WAIT_FOR_COMPLETE\@
00000000                           232          MOVE.W \2,\3
00000000                           233  
00000000                           234          IF.W \3 <NE> \1 THEN
00000000                           235              BRA WAIT_FOR_COMPLETE\@
00000000                           236          ENDI
00000000                           237          ENDM
00000000                           238          
00000000                           239  ; register catalogue
00000000                           240  ; D0 - used for simulator I/O
00000000                           241  ; D1 - used for simulator I/O
00000000                           242  ; D2 - read character
00000000                           243  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           244  ; D6 - working register used in R/W
00000000                           245  ; D7 - address accumulator, reset by download
00000000                           246  ; A0 - address of string to print 
00000000                           247  
00000000                           248  ; start vector
00000000= 00000000                 249  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 250  RESET    DC.L START                             ; RESET
00000008                           251      
00000008                           252  ; start of program  
00000008                           253  START
00000008  13FC 0000 00E00001       254      MOVE.B #0,DISPLAY
00000010                           255  
00000010                           256  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       257      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       258      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           259      
00000020                           260      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                261s     MOVE.W  #$50,D1
00000024  6000 000E                262s     BRA _20000001
00000028                           263s _20000000
00000028  13C1 00C00005            264          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     265          NOP
00000030                           266      ENDF
00000030  0441 0010                267s     SUB.W   #$10,D1
00000034                           268s _20000001
00000034  B27C 0010                269s     CMP.W   #$10,D1
00000038  6CEE                     270s     BGE _20000000
0000003A                           271  
0000003A                           272      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                273s     MOVE.W  #$50,D1
0000003E  6000 000E                274s     BRA _20000003
00000042                           275s _20000002
00000042  13C1 00C00015            276          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     277          NOP
0000004A                           278      ENDF
0000004A  0441 0010                279s     SUB.W   #$10,D1
0000004E                           280s _20000003
0000004E  B27C 0010                281s     CMP.W   #$10,D1
00000052  6CEE                     282s     BGE _20000002
00000054                           283    
00000054                           284  ;initialise UART
00000054  13FC 0000 00C00009       285      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       286      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       287      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           288  
0000006C                           289  ; channel A
0000006C  13FC 0013 00C00001       290      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       291      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       292      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       293      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           294  
0000008C                           295  ; channel B
0000008C  13FC 0013 00C00011       296      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       297      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       298      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       299      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           300  
000000AC                           301      ;PRINT_CHAR '.',D3                              ; give the serial port chance to settle after reset
000000AC                           302  
000000AC  13FC 0001 00E00001       303      MOVE.B #1,DISPLAY
000000B4                           304         
000000B4                           305m     PRINT_CRLF D3,A0
000000B4  41FA 0E6D                306m     LEA CRLF(PC),A0
000000B8                           307mm     PRINT_STR A0,D3
000000B8                           308mm LOOP_2
000000B8  0C10 0000                309mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000BC  6700 0016                310mm     BEQ EXIT_2
000000C0                           311mmm     PRINT_CHAR (A0)+,D3
000000C0                           312mmm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      313mmm     IFEQ DEBUG
000000C0  1639 00C00003            314mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000C6  0803 0002                315mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000CA  67F4                     316mmm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
000000CC  13D8 00C00007            317mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000D2                           318mmm     ENDC
000000D2                           319mmm     
000000D2                 FALSE     320mmm     IFNE DEBUG
000000D2                           321mmm     ENDC
000000D2                           322mmm 
000000D2                           323mmm     ENDM
000000D2  60E4                     324mm     BRA LOOP_2
000000D4                           325mm EXIT_2
000000D4                           326mm     ENDM
000000D4                           327m     ENDM
000000D4                           328  
000000D4  41FA 0CCE                329      LEA VERSION(PC),A0
000000D8                           330m     PRINT_STR A0,D3
000000D8                           331m LOOP_4
000000D8  0C10 0000                332m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000DC  6700 0016                333m     BEQ EXIT_4
000000E0                           334mm     PRINT_CHAR (A0)+,D3
000000E0                           335mm WAIT_FOR_READY_5                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E0                 TRUE      336mm     IFEQ DEBUG
000000E0  1639 00C00003            337mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000E6  0803 0002                338mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000EA  67F4                     339mm         BEQ WAIT_FOR_READY_5                    ; NO SPACE, CHECK AGAIN
000000EC  13D8 00C00007            340mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000F2                           341mm     ENDC
000000F2                           342mm     
000000F2                 FALSE     343mm     IFNE DEBUG
000000F2                           344mm     ENDC
000000F2                           345mm 
000000F2                           346mm     ENDM
000000F2  60E4                     347m     BRA LOOP_4
000000F4                           348m EXIT_4
000000F4                           349m     ENDM
000000F4                           350      
000000F4  41FA 0CCB                351      LEA HELPPROMPT(PC),A0
000000F8                           352m     PRINT_STR A0,D3
000000F8                           353m LOOP_6
000000F8  0C10 0000                354m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FC  6700 0016                355m     BEQ EXIT_6
00000100                           356mm     PRINT_CHAR (A0)+,D3
00000100                           357mm WAIT_FOR_READY_7                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000100                 TRUE      358mm     IFEQ DEBUG
00000100  1639 00C00003            359mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000106  0803 0002                360mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010A  67F4                     361mm         BEQ WAIT_FOR_READY_7                    ; NO SPACE, CHECK AGAIN
0000010C  13D8 00C00007            362mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000112                           363mm     ENDC
00000112                           364mm     
00000112                 FALSE     365mm     IFNE DEBUG
00000112                           366mm     ENDC
00000112                           367mm 
00000112                           368mm     ENDM
00000112  60E4                     369m     BRA LOOP_6
00000114                           370m EXIT_6
00000114                           371m     ENDM
00000114                           372      
00000114                           373m     PRINT_CRLF D3,A0
00000114  41FA 0E0D                374m     LEA CRLF(PC),A0
00000118                           375mm     PRINT_STR A0,D3
00000118                           376mm LOOP_9
00000118  0C10 0000                377mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000011C  6700 0016                378mm     BEQ EXIT_9
00000120                           379mmm     PRINT_CHAR (A0)+,D3
00000120                           380mmm WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000120                 TRUE      381mmm     IFEQ DEBUG
00000120  1639 00C00003            382mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000126  0803 0002                383mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012A  67F4                     384mmm         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0000012C  13D8 00C00007            385mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000132                           386mmm     ENDC
00000132                           387mmm     
00000132                 FALSE     388mmm     IFNE DEBUG
00000132                           389mmm     ENDC
00000132                           390mmm 
00000132                           391mmm     ENDM
00000132  60E4                     392mm     BRA LOOP_9
00000134                           393mm EXIT_9
00000134                           394mm     ENDM
00000134                           395m     ENDM
00000134                           396  
00000134  7E00                     397      MOVE.L #0,D7                                    ; address accumulator
00000136                           398  
00000136  13FC 0002 00E00001       399      MOVE.B #2,DISPLAY
0000013E                           400  MAIN_LOOP
0000013E  41FA 0DE6                401      LEA PROMPT(PC),A0
00000142                           402m     PRINT_STR A0,D3
00000142                           403m LOOP_11
00000142  0C10 0000                404m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000146  6700 0016                405m     BEQ EXIT_11
0000014A                           406mm     PRINT_CHAR (A0)+,D3
0000014A                           407mm WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000014A                 TRUE      408mm     IFEQ DEBUG
0000014A  1639 00C00003            409mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000150  0803 0002                410mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000154  67F4                     411mm         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
00000156  13D8 00C00007            412mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000015C                           413mm     ENDC
0000015C                           414mm     
0000015C                 FALSE     415mm     IFNE DEBUG
0000015C                           416mm     ENDC
0000015C                           417mm 
0000015C                           418mm     ENDM
0000015C  60E4                     419m     BRA LOOP_11
0000015E                           420m EXIT_11
0000015E                           421m     ENDM
0000015E                           422      
0000015E                           423  GET_INPUT
0000015E                           424m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015E                           425m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015E                 TRUE      426m     IFEQ DEBUG
0000015E  1639 00C00003            427m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000164  0803 0000                428m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000168  67F4                     429m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
0000016A                           430m     ENDC
0000016A                           431m     
0000016A                           432mm     READ_CHAR D2
0000016A                 TRUE      433mm     IFEQ DEBUG
0000016A  1439 00C00007            434mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000170                           435mm     ENDC
00000170                 FALSE     436mm     IFNE DEBUG
00000170                           437mm     ENDC
00000170                           438mm      
00000170  B43C 001B                439mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000174  6700 FE92                440mm     BEQ START
00000178                           441mm     ENDM
00000178                           442m 
00000178                 TRUE      443m     IFEQ DEBUG
00000178                           444mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000178                           445mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      446mm     IFEQ DEBUG
00000178  1639 00C00003            447mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                448mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     449mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
00000184  13C2 00C00007            450mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000018A                           451mm     ENDC
0000018A                           452mm     
0000018A                 FALSE     453mm     IFNE DEBUG
0000018A                           454mm     ENDC
0000018A                           455mm 
0000018A                           456mm     ENDM
0000018A                           457m     ENDC
0000018A                           458m     ENDM
0000018A                           459      
0000018A                           460      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000018A  B43C 0030                461s     CMP.B   #'0',D2
0000018E  6D00 000E                462s     BLT _00000000
00000192  B43C 0039                463s     CMP.B   #'9',D2
00000196  6E00 0006                464s     BGT _00000000
0000019A  6000 0BEA                465          BRA HEX_DIGIT
0000019E                           466      ENDI
0000019E                           467s _00000000
0000019E                           468      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019E  B43C 0041                469s     CMP.B   #'A',D2
000001A2  6D00 000E                470s     BLT _00000001
000001A6  B43C 0046                471s     CMP.B   #'F',D2
000001AA  6E00 0006                472s     BGT _00000001
000001AE  6000 0BD6                473          BRA HEX_DIGIT
000001B2                           474      ENDI
000001B2                           475s _00000001
000001B2                           476          
000001B2  B43C 0077                477      CMP.B #'w',D2
000001B6  6700 011E                478      BEQ W
000001BA                           479      
000001BA  B43C 006C                480      CMP.B #'l',D2
000001BE  6700 09A0                481      BEQ L 
000001C2                           482  
000001C2                           483m     PRINT_CRLF D3,A0
000001C2  41FA 0D5F                484m     LEA CRLF(PC),A0
000001C6                           485mm     PRINT_STR A0,D3
000001C6                           486mm LOOP_17
000001C6  0C10 0000                487mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001CA  6700 0016                488mm     BEQ EXIT_17
000001CE                           489mmm     PRINT_CHAR (A0)+,D3
000001CE                           490mmm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      491mmm     IFEQ DEBUG
000001CE  1639 00C00003            492mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001D4  0803 0002                493mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D8  67F4                     494mmm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
000001DA  13D8 00C00007            495mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001E0                           496mmm     ENDC
000001E0                           497mmm     
000001E0                 FALSE     498mmm     IFNE DEBUG
000001E0                           499mmm     ENDC
000001E0                           500mmm 
000001E0                           501mmm     ENDM
000001E0  60E4                     502mm     BRA LOOP_17
000001E2                           503mm EXIT_17
000001E2                           504mm     ENDM
000001E2                           505m     ENDM
000001E2                           506   
000001E2  B43C 003F                507      CMP.B #'?',D2
000001E6  6700 004E                508      BEQ H
000001EA                           509   
000001EA  B43C 0076                510      CMP.B #'v',D2
000001EE  6700 004E                511      BEQ V
000001F2                           512      
000001F2  B43C 0072                513      CMP.B #'r',D2
000001F6  6700 006A                514      BEQ R
000001FA                           515  
000001FA  B43C 0073                516      CMP.B #'s',D2
000001FE  6700 014A                517      BEQ S
00000202                           518  
00000202  B43C 0067                519      CMP.B #'g',D2
00000206  6700 086E                520      BEQ G   
0000020A                           521  
0000020A  B43C 007A                522      CMP.B #'z',D2
0000020E  6700 086E                523      BEQ Z   
00000212                           524  
00000212  41FA 0C70                525      LEA HUH(PC),A0
00000216                           526m     PRINT_STR A0,D3
00000216                           527m LOOP_19
00000216  0C10 0000                528m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000021A  6700 0016                529m     BEQ EXIT_19
0000021E                           530mm     PRINT_CHAR (A0)+,D3
0000021E                           531mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021E                 TRUE      532mm     IFEQ DEBUG
0000021E  1639 00C00003            533mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000224  0803 0002                534mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000228  67F4                     535mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
0000022A  13D8 00C00007            536mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000230                           537mm     ENDC
00000230                           538mm     
00000230                 FALSE     539mm     IFNE DEBUG
00000230                           540mm     ENDC
00000230                           541mm 
00000230                           542mm     ENDM
00000230  60E4                     543m     BRA LOOP_19
00000232                           544m EXIT_19
00000232                           545m     ENDM
00000232                           546                         
00000232  6000 FF0A                547      BRA MAIN_LOOP
00000236                           548      
00000236                           549  ; commands
00000236                           550  H   
00000236  41FA 0B9C                551      LEA HELP(PC),A0
0000023A  6000 0006                552      BRA PRINTSTR
0000023E                           553  
0000023E                           554  V   
0000023E  41FA 0B64                555      LEA VERSION(PC),A0
00000242                           556  PRINTSTR
00000242                           557m     PRINT_STR A0,D3       
00000242                           558m LOOP_21
00000242  0C10 0000                559m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000246  6700 0016                560m     BEQ EXIT_21
0000024A                           561mm     PRINT_CHAR (A0)+,D3
0000024A                           562mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024A                 TRUE      563mm     IFEQ DEBUG
0000024A  1639 00C00003            564mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000250  0803 0002                565mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000254  67F4                     566mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000256  13D8 00C00007            567mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000025C                           568mm     ENDC
0000025C                           569mm     
0000025C                 FALSE     570mm     IFNE DEBUG
0000025C                           571mm     ENDC
0000025C                           572mm 
0000025C                           573mm     ENDM
0000025C  60E4                     574m     BRA LOOP_21
0000025E                           575m EXIT_21
0000025E                           576m     ENDM
0000025E  6000 FEDE                577      BRA MAIN_LOOP
00000262                           578      
00000262                           579  R   
00000262  2047                     580      MOVE.L D7,A0                                    ; address accumulator -> address register
00000264  7E00                     581      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000266  2410                     582      MOVE.L (A0),D2                                  ; read the memory and print it
00000268                           583m     PRINT_REG D2,D3,D4,D5,A0
00000268  41FA 0CBF                584m     LEA OX(PC),A0
0000026C                           585mm     PRINT_STR A0,D3
0000026C                           586mm LOOP_24
0000026C  0C10 0000                587mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000270  6700 0016                588mm     BEQ EXIT_24
00000274                           589mmm     PRINT_CHAR (A0)+,D3
00000274                           590mmm WAIT_FOR_READY_25                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      591mmm     IFEQ DEBUG
00000274  1639 00C00003            592mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000027A  0803 0002                593mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000027E  67F4                     594mmm         BEQ WAIT_FOR_READY_25                   ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            595mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000286                           596mmm     ENDC
00000286                           597mmm     
00000286                 FALSE     598mmm     IFNE DEBUG
00000286                           599mmm     ENDC
00000286                           600mmm 
00000286                           601mmm     ENDM
00000286  60E4                     602mm     BRA LOOP_24
00000288                           603mm EXIT_24
00000288                           604mm     ENDM
00000288  7A07                     605m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           606m LOOP_23
0000028A                           607mm     BIN2HEX D2,D4,A0
0000028A  41FA 0C5C                608mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
0000028E  E99A                     609mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1802                     610mm     MOVE.B D2,D4
00000292  0284 0000000F            611mm     ANDI.L #$F,D4
00000298  1830 4000                612mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           613mm     ENDM
0000029C                           614mm     PRINT_CHAR D4,D3
0000029C                           615mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      616mm     IFEQ DEBUG
0000029C  1639 00C00003            617mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                618mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     619mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002A8  13C4 00C00007            620mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002AE                           621mm     ENDC
000002AE                           622mm     
000002AE                 FALSE     623mm     IFNE DEBUG
000002AE                           624mm     ENDC
000002AE                           625mm 
000002AE                           626mm     ENDM
000002AE  57CD FFDA                627m     DBEQ D5,LOOP_23
000002B2                           628m     ENDM
000002B2                           629m     PRINT_CRLF D3,A0
000002B2  41FA 0C6F                630m     LEA CRLF(PC),A0
000002B6                           631mm     PRINT_STR A0,D3
000002B6                           632mm LOOP_29
000002B6  0C10 0000                633mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002BA  6700 0016                634mm     BEQ EXIT_29
000002BE                           635mmm     PRINT_CHAR (A0)+,D3
000002BE                           636mmm WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      637mmm     IFEQ DEBUG
000002BE  1639 00C00003            638mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002C4  0803 0002                639mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002C8  67F4                     640mmm         BEQ WAIT_FOR_READY_30                   ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            641mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D0                           642mmm     ENDC
000002D0                           643mmm     
000002D0                 FALSE     644mmm     IFNE DEBUG
000002D0                           645mmm     ENDC
000002D0                           646mmm 
000002D0                           647mmm     ENDM
000002D0  60E4                     648mm     BRA LOOP_29
000002D2                           649mm EXIT_29
000002D2                           650mm     ENDM
000002D2                           651m     ENDM
000002D2  6000 FE6A                652      BRA MAIN_LOOP
000002D6                           653  
000002D6                           654  W
000002D6  3C3C 0007                655      MOVE #7,D6                                      ; 7 bytes left to read
000002DA                           656      
000002DA                           657  READ_DATA_TO_POKE
000002DA  E98D                     658      LSL.L #4,D5                                     ; make what we have so far more significant
000002DC                           659m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002DC                           660m WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DC                 TRUE      661m     IFEQ DEBUG
000002DC  1639 00C00003            662m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E2  0803 0000                663m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002E6  67F4                     664m         BEQ WAIT_FOR_READY_31                   ; NOTHING, CHECK AGAIN
000002E8                           665m     ENDC
000002E8                           666m     
000002E8                           667mm     READ_CHAR D2
000002E8                 TRUE      668mm     IFEQ DEBUG
000002E8  1439 00C00007            669mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002EE                           670mm     ENDC
000002EE                 FALSE     671mm     IFNE DEBUG
000002EE                           672mm     ENDC
000002EE                           673mm      
000002EE  B43C 001B                674mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002F2  6700 FD14                675mm     BEQ START
000002F6                           676mm     ENDM
000002F6                           677m 
000002F6                 TRUE      678m     IFEQ DEBUG
000002F6                           679mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000002F6                           680mm WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F6                 TRUE      681mm     IFEQ DEBUG
000002F6  1639 00C00003            682mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FC  0803 0002                683mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000300  67F4                     684mm         BEQ WAIT_FOR_READY_33                   ; NO SPACE, CHECK AGAIN
00000302  13C2 00C00007            685mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000308                           686mm     ENDC
00000308                           687mm     
00000308                 FALSE     688mm     IFNE DEBUG
00000308                           689mm     ENDC
00000308                           690mm 
00000308                           691mm     ENDM
00000308                           692m     ENDC
00000308                           693m     ENDM
00000308                           694m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000308  41FA 0BEE                695m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000030C  0402 0030                696m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000310  C4BC 000000FF            697m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000316  1430 2000                698m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
0000031A                           699m     ENDM
0000031A  8A02                     700      OR.B D2,D5
0000031C  57CE FFBC                701      DBEQ D6,READ_DATA_TO_POKE
00000320                           702      
00000320  2047                     703      MOVE.L D7,A0                                    ; address accumulator -> address register
00000322  7E00                     704      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000324                           705      
00000324  2085                     706      MOVE.L D5,(A0)                                  ; write the data
00000326                           707  
00000326                           708m     PRINT_CRLF D3,A0
00000326  41FA 0BFB                709m     LEA CRLF(PC),A0
0000032A                           710mm     PRINT_STR A0,D3
0000032A                           711mm LOOP_36
0000032A  0C10 0000                712mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000032E  6700 0016                713mm     BEQ EXIT_36
00000332                           714mmm     PRINT_CHAR (A0)+,D3
00000332                           715mmm WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000332                 TRUE      716mmm     IFEQ DEBUG
00000332  1639 00C00003            717mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000338  0803 0002                718mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000033C  67F4                     719mmm         BEQ WAIT_FOR_READY_37                   ; NO SPACE, CHECK AGAIN
0000033E  13D8 00C00007            720mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000344                           721mmm     ENDC
00000344                           722mmm     
00000344                 FALSE     723mmm     IFNE DEBUG
00000344                           724mmm     ENDC
00000344                           725mmm 
00000344                           726mmm     ENDM
00000344  60E4                     727mm     BRA LOOP_36
00000346                           728mm EXIT_36
00000346                           729mm     ENDM
00000346                           730m     ENDM
00000346  6000 FDF6                731      BRA MAIN_LOOP
0000034A                           732  
0000034A                           733  ; register map for S
0000034A                           734  ; A0 - start address
0000034A                           735  ; A1 - offset
0000034A                           736  ; A2 - next address to write
0000034A                           737  ; A3 - next location (jmp)
0000034A                           738  ; A4 - Working Address Register
0000034A                           739  ; D0 - record count
0000034A                           740  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000034A                           741  ; D2 - checksum
0000034A                           742  ; D3 - data byte count
0000034A                           743  ; D4 - read address, moved into A2
0000034A                           744  ; D5 - temp
0000034A                           745  ; D6 - temp
0000034A                           746  ; D7 - temp
0000034A                           747  S
0000034A  2078 0000                748      MOVE.L 0,A0                                     ; start address -> A0
0000034E  2247                     749      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000350                           750      
00000350  7000                     751      MOVE.L #0,D0                                    ; count of records read -> D0
00000352                           752          
00000352                           753  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000352                           754m     DOWNLOAD D1                 
00000352                           755m WAIT_FOR_READY_38                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000352                           756m 
00000352  1239 00C00003            757m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000358  0801 0000                758m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000035C  6700 0010                759m     BEQ CONTINUE_38                             ; NOTHING, CONTINUE
00000360                           760m  
00000360                           761mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000360                 TRUE      762mm     IFEQ DEBUG
00000360  1239 00C00007            763mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000366                           764mm     ENDC
00000366                 FALSE     765mm     IFNE DEBUG
00000366                           766mm     ENDC
00000366                           767mm      
00000366  B23C 001B                768mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0000036A  6700 FC9C                769mm     BEQ START
0000036E                           770mm     ENDM
0000036E                           771m CONTINUE_38
0000036E  1239 00C00013            772m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000374  0801 0000                773m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000378  67D8                     774m     BEQ WAIT_FOR_READY_38                           ; NOTHING, CHECK AGAIN
0000037A                           775m     
0000037A  1239 00C00017            776m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000380  13C1 00E00001            777m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000386                           778m     
00000386                           779m     ENDM
00000386  B23C 0053                780      CMP.B #'S',D1                                   ; found S?    
0000038A  66C6                     781      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000038C                           782      
0000038C                           783m     PRINT_CHAR #'S',D5                            ; print the S
0000038C                           784m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038C                 TRUE      785m     IFEQ DEBUG
0000038C  1A39 00C00003            786m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000392  0805 0002                787m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000396  67F4                     788m         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
00000398  13FC 0053 00C00007       789m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003A0                           790m     ENDC
000003A0                           791m     
000003A0                 FALSE     792m     IFNE DEBUG
000003A0                           793m     ENDC
000003A0                           794m 
000003A0                           795m     ENDM
000003A0  5280                     796      ADD.L #1,D0                                     ; read another S record, increment count
000003A2                           797      
000003A2                           798m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003A2                           799m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A2                           800m 
000003A2  1239 00C00003            801m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003A8  0801 0000                802m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003AC  6700 0010                803m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
000003B0                           804m  
000003B0                           805mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003B0                 TRUE      806mm     IFEQ DEBUG
000003B0  1239 00C00007            807mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003B6                           808mm     ENDC
000003B6                 FALSE     809mm     IFNE DEBUG
000003B6                           810mm     ENDC
000003B6                           811mm      
000003B6  B23C 001B                812mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003BA  6700 FC4C                813mm     BEQ START
000003BE                           814mm     ENDM
000003BE                           815m CONTINUE_41
000003BE  1239 00C00013            816m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003C4  0801 0000                817m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003C8  67D8                     818m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003CA                           819m     
000003CA  1239 00C00017            820m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003D0  13C1 00E00001            821m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003D6                           822m     
000003D6                           823m     ENDM
000003D6                           824m     PRINT_CHAR D1,D5
000003D6                           825m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D6                 TRUE      826m     IFEQ DEBUG
000003D6  1A39 00C00003            827m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003DC  0805 0002                828m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003E0  67F4                     829m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
000003E2  13C1 00C00007            830m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003E8                           831m     ENDC
000003E8                           832m     
000003E8                 FALSE     833m     IFNE DEBUG
000003E8                           834m     ENDC
000003E8                           835m 
000003E8                           836m     ENDM
000003E8                           837  
000003E8  7400                     838      MOVE.L #0,D2                                    ; clear the checksum
000003EA                           839  
000003EA                           840m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003EA  1E3C 0002                841m     MOVE.B #2,D7
000003EE                           842m     WHILE.B D7 <GT> 0 DO
000003EE                           843ms _10000000
000003EE  BE38 0000                844ms     CMP.B   0,D7
000003F2  6F00 0062                845ms     BLE _10000001
000003F6  E98B                     846m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
000003F8                           847mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000003F8                           848mm WAIT_FOR_READY_45                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003F8                           849mm 
000003F8  1A39 00C00003            850mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000003FE  0805 0000                851mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000402  6700 0010                852mm     BEQ CONTINUE_45                             ; NOTHING, CONTINUE
00000406                           853mm  
00000406                           854mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000406                 TRUE      855mmm     IFEQ DEBUG
00000406  1A39 00C00007            856mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000040C                           857mmm     ENDC
0000040C                 FALSE     858mmm     IFNE DEBUG
0000040C                           859mmm     ENDC
0000040C                           860mmm      
0000040C  BA3C 001B                861mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000410  6700 FBF6                862mmm     BEQ START
00000414                           863mmm     ENDM
00000414                           864mm CONTINUE_45
00000414  1A39 00C00013            865mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000041A  0805 0000                866mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000041E  67D8                     867mm     BEQ WAIT_FOR_READY_45                           ; NOTHING, CHECK AGAIN
00000420                           868mm     
00000420  1A39 00C00017            869mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000426  13C5 00E00001            870mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000042C                           871mm     
0000042C                           872mm     ENDM
0000042C                           873mm         PRINT_CHAR D5,D6
0000042C                           874mm WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042C                 TRUE      875mm     IFEQ DEBUG
0000042C  1C39 00C00003            876mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000432  0806 0002                877mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000436  67F4                     878mm         BEQ WAIT_FOR_READY_47                   ; NO SPACE, CHECK AGAIN
00000438  13C5 00C00007            879mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000043E                           880mm     ENDC
0000043E                           881mm     
0000043E                 FALSE     882mm     IFNE DEBUG
0000043E                           883mm     ENDC
0000043E                           884mm 
0000043E                           885mm     ENDM
0000043E                           886mm         HEX2BIN D5,D5,A4
0000043E  49FA 0AB8                887mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000442  0405 0030                888mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000446  CABC 000000FF            889mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000044C  1A34 5000                890mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000450                           891mm     ENDM
00000450  8605                     892m         OR.B D5,D3
00000452  5307                     893m         SUB.B #1,D7
00000454                           894m     ENDW
00000454  6098                     895ms     BRA _10000000
00000456                           896ms _10000001
00000456                           897m     
00000456  7A00                     898m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000458  1A03                     899m     MOVE.B D3,D5
0000045A  D483                     900m     ADD.L D3,D2
0000045C                           901m 
0000045C                           902m     ENDM
0000045C                           903  
0000045C                           904      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000045C  B23C 0030                905s     CMP.B   #'0',D1
00000460  6600 002A                906s     BNE.L   _00000002
00000464                           907m         PRINT_CRLF D5,A4
00000464  49FA 0ABD                908m     LEA CRLF(PC),A4
00000468                           909mm     PRINT_STR A4,D5
00000468                           910mm LOOP_50
00000468  0C14 0000                911mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000046C  6700 0016                912mm     BEQ EXIT_50
00000470                           913mmm     PRINT_CHAR (A4)+,D5
00000470                           914mmm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000470                 TRUE      915mmm     IFEQ DEBUG
00000470  1A39 00C00003            916mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000476  0805 0002                917mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000047A  67F4                     918mmm         BEQ WAIT_FOR_READY_51                   ; NO SPACE, CHECK AGAIN
0000047C  13DC 00C00007            919mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000482                           920mmm     ENDC
00000482                           921mmm     
00000482                 FALSE     922mmm     IFNE DEBUG
00000482                           923mmm     ENDC
00000482                           924mmm 
00000482                           925mmm     ENDM
00000482  60E4                     926mm     BRA LOOP_50
00000484                           927mm EXIT_50
00000484                           928mm     ENDM
00000484                           929m     ENDM
00000484  6000 FECC                930          BRA WAIT_FOR_SRECORD
00000488                           931      ELSE
00000488  6000 03DE                932s     BRA _00000003
0000048C                           933s _00000002
0000048C                           934          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
0000048C  B23C 0031                935s     CMP.B   #'1',D1
00000490  6708                     936s     BEQ.S   _00000004
00000492  B23C 0032                937s     CMP.B   #'2',D1
00000496  6600 01F0                938s     BNE.L   _00000005
0000049A                           939s _00000004
0000049A  5783                     940              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000049C                           941      
0000049C  7800                     942              MOVE.L #0,D4                            ; read two bytes of address
0000049E                           943m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
0000049E  1E3C 0002                944m     MOVE.B #2,D7
000004A2                           945m     WHILE.B D7 <GT> 0 DO
000004A2                           946ms _10000002
000004A2  BE38 0000                947ms     CMP.B   0,D7
000004A6  6F00 0062                948ms     BLE _10000003
000004AA  E98C                     949m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004AC                           950mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004AC                           951mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AC                           952mm 
000004AC  1A39 00C00003            953mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004B2  0805 0000                954mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004B6  6700 0010                955mm     BEQ CONTINUE_53                             ; NOTHING, CONTINUE
000004BA                           956mm  
000004BA                           957mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004BA                 TRUE      958mmm     IFEQ DEBUG
000004BA  1A39 00C00007            959mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C0                           960mmm     ENDC
000004C0                 FALSE     961mmm     IFNE DEBUG
000004C0                           962mmm     ENDC
000004C0                           963mmm      
000004C0  BA3C 001B                964mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004C4  6700 FB42                965mmm     BEQ START
000004C8                           966mmm     ENDM
000004C8                           967mm CONTINUE_53
000004C8  1A39 00C00013            968mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004CE  0805 0000                969mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004D2  67D8                     970mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D4                           971mm     
000004D4  1A39 00C00017            972mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004DA  13C5 00E00001            973mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E0                           974mm     
000004E0                           975mm     ENDM
000004E0                           976mm         PRINT_CHAR D5,D6
000004E0                           977mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E0                 TRUE      978mm     IFEQ DEBUG
000004E0  1C39 00C00003            979mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004E6  0806 0002                980mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004EA  67F4                     981mm         BEQ WAIT_FOR_READY_55                   ; NO SPACE, CHECK AGAIN
000004EC  13C5 00C00007            982mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004F2                           983mm     ENDC
000004F2                           984mm     
000004F2                 FALSE     985mm     IFNE DEBUG
000004F2                           986mm     ENDC
000004F2                           987mm 
000004F2                           988mm     ENDM
000004F2                           989mm         HEX2BIN D5,D5,A4
000004F2  49FA 0A04                990mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004F6  0405 0030                991mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004FA  CABC 000000FF            992mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000500  1A34 5000                993mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000504                           994mm     ENDM
00000504  8805                     995m         OR.B D5,D4
00000506  5307                     996m         SUB.B #1,D7
00000508                           997m     ENDW
00000508  6098                     998ms     BRA _10000002
0000050A                           999ms _10000003
0000050A                          1000m     
0000050A  7A00                    1001m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000050C  1A04                    1002m     MOVE.B D4,D5
0000050E  D484                    1003m     ADD.L D4,D2
00000510                          1004m 
00000510                          1005m     ENDM
00000510                          1006m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000510  1E3C 0002               1007m     MOVE.B #2,D7
00000514                          1008m     WHILE.B D7 <GT> 0 DO
00000514                          1009ms _10000004
00000514  BE38 0000               1010ms     CMP.B   0,D7
00000518  6F00 0062               1011ms     BLE _10000005
0000051C  E98C                    1012m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000051E                          1013mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000051E                          1014mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000051E                          1015mm 
0000051E  1A39 00C00003           1016mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000524  0805 0000               1017mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000528  6700 0010               1018mm     BEQ CONTINUE_58                             ; NOTHING, CONTINUE
0000052C                          1019mm  
0000052C                          1020mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000052C                 TRUE     1021mmm     IFEQ DEBUG
0000052C  1A39 00C00007           1022mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000532                          1023mmm     ENDC
00000532                 FALSE    1024mmm     IFNE DEBUG
00000532                          1025mmm     ENDC
00000532                          1026mmm      
00000532  BA3C 001B               1027mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000536  6700 FAD0               1028mmm     BEQ START
0000053A                          1029mmm     ENDM
0000053A                          1030mm CONTINUE_58
0000053A  1A39 00C00013           1031mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000540  0805 0000               1032mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000544  67D8                    1033mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000546                          1034mm     
00000546  1A39 00C00017           1035mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000054C  13C5 00E00001           1036mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000552                          1037mm     
00000552                          1038mm     ENDM
00000552                          1039mm         PRINT_CHAR D5,D6
00000552                          1040mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000552                 TRUE     1041mm     IFEQ DEBUG
00000552  1C39 00C00003           1042mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000558  0806 0002               1043mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000055C  67F4                    1044mm         BEQ WAIT_FOR_READY_60                   ; NO SPACE, CHECK AGAIN
0000055E  13C5 00C00007           1045mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000564                          1046mm     ENDC
00000564                          1047mm     
00000564                 FALSE    1048mm     IFNE DEBUG
00000564                          1049mm     ENDC
00000564                          1050mm 
00000564                          1051mm     ENDM
00000564                          1052mm         HEX2BIN D5,D5,A4
00000564  49FA 0992               1053mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000568  0405 0030               1054mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000056C  CABC 000000FF           1055mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000572  1A34 5000               1056mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000576                          1057mm     ENDM
00000576  8805                    1058m         OR.B D5,D4
00000578  5307                    1059m         SUB.B #1,D7
0000057A                          1060m     ENDW
0000057A  6098                    1061ms     BRA _10000004
0000057C                          1062ms _10000005
0000057C                          1063m     
0000057C  7A00                    1064m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000057E  1A04                    1065m     MOVE.B D4,D5
00000580  D484                    1066m     ADD.L D4,D2
00000582                          1067m 
00000582                          1068m     ENDM
00000582                          1069              
00000582                          1070              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000582  B23C 0032               1071s     CMP.B   #'2',D1
00000586  6600 0076               1072s     BNE.L   _00000006
0000058A  5383                    1073                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000058C                          1074m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
0000058C  1E3C 0002               1075m     MOVE.B #2,D7
00000590                          1076m     WHILE.B D7 <GT> 0 DO
00000590                          1077ms _10000006
00000590  BE38 0000               1078ms     CMP.B   0,D7
00000594  6F00 0062               1079ms     BLE _10000007
00000598  E98C                    1080m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000059A                          1081mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000059A                          1082mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059A                          1083mm 
0000059A  1A39 00C00003           1084mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005A0  0805 0000               1085mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005A4  6700 0010               1086mm     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
000005A8                          1087mm  
000005A8                          1088mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005A8                 TRUE     1089mmm     IFEQ DEBUG
000005A8  1A39 00C00007           1090mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005AE                          1091mmm     ENDC
000005AE                 FALSE    1092mmm     IFNE DEBUG
000005AE                          1093mmm     ENDC
000005AE                          1094mmm      
000005AE  BA3C 001B               1095mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005B2  6700 FA54               1096mmm     BEQ START
000005B6                          1097mmm     ENDM
000005B6                          1098mm CONTINUE_63
000005B6  1A39 00C00013           1099mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005BC  0805 0000               1100mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005C0  67D8                    1101mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005C2                          1102mm     
000005C2  1A39 00C00017           1103mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005C8  13C5 00E00001           1104mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005CE                          1105mm     
000005CE                          1106mm     ENDM
000005CE                          1107mm         PRINT_CHAR D5,D6
000005CE                          1108mm WAIT_FOR_READY_65                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1109mm     IFEQ DEBUG
000005CE  1C39 00C00003           1110mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005D4  0806 0002               1111mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1112mm         BEQ WAIT_FOR_READY_65                   ; NO SPACE, CHECK AGAIN
000005DA  13C5 00C00007           1113mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005E0                          1114mm     ENDC
000005E0                          1115mm     
000005E0                 FALSE    1116mm     IFNE DEBUG
000005E0                          1117mm     ENDC
000005E0                          1118mm 
000005E0                          1119mm     ENDM
000005E0                          1120mm         HEX2BIN D5,D5,A4
000005E0  49FA 0916               1121mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005E4  0405 0030               1122mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005E8  CABC 000000FF           1123mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005EE  1A34 5000               1124mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005F2                          1125mm     ENDM
000005F2  8805                    1126m         OR.B D5,D4
000005F4  5307                    1127m         SUB.B #1,D7
000005F6                          1128m     ENDW
000005F6  6098                    1129ms     BRA _10000006
000005F8                          1130ms _10000007
000005F8                          1131m     
000005F8  7A00                    1132m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005FA  1A04                    1133m     MOVE.B D4,D5
000005FC  D484                    1134m     ADD.L D4,D2
000005FE                          1135m 
000005FE                          1136m     ENDM
000005FE                          1137              ENDI
000005FE                          1138s _00000006
000005FE                          1139              
000005FE  2444                    1140                  MOVE.L D4,A2                            ; put the address in an address register
00000600  D5C9                    1141              ADD.L A1,A2                             ; add in the offset
00000602                          1142  
00000602                          1143              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
00000602                          1144s _10000008
00000602  B63C 0000               1145s     CMP.B   #0,D3
00000606  6F00 007A               1146s     BLE _10000009
0000060A                          1147m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
0000060A  1E3C 0002               1148m     MOVE.B #2,D7
0000060E                          1149m     WHILE.B D7 <GT> 0 DO
0000060E                          1150ms _1000000A
0000060E  BE38 0000               1151ms     CMP.B   0,D7
00000612  6F00 0062               1152ms     BLE _1000000B
00000616  E989                    1153m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000618                          1154mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000618                          1155mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000618                          1156mm 
00000618  1A39 00C00003           1157mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000061E  0805 0000               1158mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000622  6700 0010               1159mm     BEQ CONTINUE_68                             ; NOTHING, CONTINUE
00000626                          1160mm  
00000626                          1161mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000626                 TRUE     1162mmm     IFEQ DEBUG
00000626  1A39 00C00007           1163mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000062C                          1164mmm     ENDC
0000062C                 FALSE    1165mmm     IFNE DEBUG
0000062C                          1166mmm     ENDC
0000062C                          1167mmm      
0000062C  BA3C 001B               1168mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000630  6700 F9D6               1169mmm     BEQ START
00000634                          1170mmm     ENDM
00000634                          1171mm CONTINUE_68
00000634  1A39 00C00013           1172mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000063A  0805 0000               1173mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000063E  67D8                    1174mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
00000640                          1175mm     
00000640  1A39 00C00017           1176mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000646  13C5 00E00001           1177mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000064C                          1178mm     
0000064C                          1179mm     ENDM
0000064C                          1180mm         PRINT_CHAR D5,D6
0000064C                          1181mm WAIT_FOR_READY_70                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000064C                 TRUE     1182mm     IFEQ DEBUG
0000064C  1C39 00C00003           1183mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000652  0806 0002               1184mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000656  67F4                    1185mm         BEQ WAIT_FOR_READY_70                   ; NO SPACE, CHECK AGAIN
00000658  13C5 00C00007           1186mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000065E                          1187mm     ENDC
0000065E                          1188mm     
0000065E                 FALSE    1189mm     IFNE DEBUG
0000065E                          1190mm     ENDC
0000065E                          1191mm 
0000065E                          1192mm     ENDM
0000065E                          1193mm         HEX2BIN D5,D5,A4
0000065E  49FA 0898               1194mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000662  0405 0030               1195mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000666  CABC 000000FF           1196mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000066C  1A34 5000               1197mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000670                          1198mm     ENDM
00000670  8205                    1199m         OR.B D5,D1
00000672  5307                    1200m         SUB.B #1,D7
00000674                          1201m     ENDW
00000674  6098                    1202ms     BRA _1000000A
00000676                          1203ms _1000000B
00000676                          1204m     
00000676  7A00                    1205m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000678  1A01                    1206m     MOVE.B D1,D5
0000067A  D481                    1207m     ADD.L D1,D2
0000067C                          1208m 
0000067C                          1209m     ENDM
0000067C                          1210                          
0000067C  14C1                    1211                  MOVE.B D1,(A2)+                     ; store it!
0000067E                          1212  
0000067E  5303                    1213                  SUB.B #1,D3                      ; 1 less byte to go
00000680                          1214              ENDW
00000680  6080                    1215s     BRA _10000008
00000682                          1216s _10000009
00000682                          1217          
00000682  7200                    1218              MOVE.L #0,D1                         ; not done yet
00000684                          1219          ELSE
00000684  6000 01E2               1220s     BRA _00000007
00000688                          1221s _00000005
00000688                          1222              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000688  B23C 0038               1223s     CMP.B   #'8',D1
0000068C  6600 0164               1224s     BNE.L   _00000008
00000690  7800                    1225                  MOVE.L #0,D4                    ; read the 24 bit start address
00000692                          1226m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
00000692  1E3C 0002               1227m     MOVE.B #2,D7
00000696                          1228m     WHILE.B D7 <GT> 0 DO
00000696                          1229ms _1000000C
00000696  BE38 0000               1230ms     CMP.B   0,D7
0000069A  6F00 0062               1231ms     BLE _1000000D
0000069E  E98C                    1232m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006A0                          1233mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006A0                          1234mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A0                          1235mm 
000006A0  1A39 00C00003           1236mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006A6  0805 0000               1237mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006AA  6700 0010               1238mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
000006AE                          1239mm  
000006AE                          1240mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006AE                 TRUE     1241mmm     IFEQ DEBUG
000006AE  1A39 00C00007           1242mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006B4                          1243mmm     ENDC
000006B4                 FALSE    1244mmm     IFNE DEBUG
000006B4                          1245mmm     ENDC
000006B4                          1246mmm      
000006B4  BA3C 001B               1247mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006B8  6700 F94E               1248mmm     BEQ START
000006BC                          1249mmm     ENDM
000006BC                          1250mm CONTINUE_73
000006BC  1A39 00C00013           1251mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006C2  0805 0000               1252mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C6  67D8                    1253mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
000006C8                          1254mm     
000006C8  1A39 00C00017           1255mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006CE  13C5 00E00001           1256mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006D4                          1257mm     
000006D4                          1258mm     ENDM
000006D4                          1259mm         PRINT_CHAR D5,D6
000006D4                          1260mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D4                 TRUE     1261mm     IFEQ DEBUG
000006D4  1C39 00C00003           1262mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006DA  0806 0002               1263mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006DE  67F4                    1264mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
000006E0  13C5 00C00007           1265mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006E6                          1266mm     ENDC
000006E6                          1267mm     
000006E6                 FALSE    1268mm     IFNE DEBUG
000006E6                          1269mm     ENDC
000006E6                          1270mm 
000006E6                          1271mm     ENDM
000006E6                          1272mm         HEX2BIN D5,D5,A4
000006E6  49FA 0810               1273mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006EA  0405 0030               1274mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006EE  CABC 000000FF           1275mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006F4  1A34 5000               1276mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006F8                          1277mm     ENDM
000006F8  8805                    1278m         OR.B D5,D4
000006FA  5307                    1279m         SUB.B #1,D7
000006FC                          1280m     ENDW
000006FC  6098                    1281ms     BRA _1000000C
000006FE                          1282ms _1000000D
000006FE                          1283m     
000006FE  7A00                    1284m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000700  1A04                    1285m     MOVE.B D4,D5
00000702  D484                    1286m     ADD.L D4,D2
00000704                          1287m 
00000704                          1288m     ENDM
00000704                          1289m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000704  1E3C 0002               1290m     MOVE.B #2,D7
00000708                          1291m     WHILE.B D7 <GT> 0 DO
00000708                          1292ms _1000000E
00000708  BE38 0000               1293ms     CMP.B   0,D7
0000070C  6F00 0062               1294ms     BLE _1000000F
00000710  E98C                    1295m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000712                          1296mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000712                          1297mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                          1298mm 
00000712  1A39 00C00003           1299mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000718  0805 0000               1300mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000071C  6700 0010               1301mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
00000720                          1302mm  
00000720                          1303mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000720                 TRUE     1304mmm     IFEQ DEBUG
00000720  1A39 00C00007           1305mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000726                          1306mmm     ENDC
00000726                 FALSE    1307mmm     IFNE DEBUG
00000726                          1308mmm     ENDC
00000726                          1309mmm      
00000726  BA3C 001B               1310mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000072A  6700 F8DC               1311mmm     BEQ START
0000072E                          1312mmm     ENDM
0000072E                          1313mm CONTINUE_78
0000072E  1A39 00C00013           1314mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000734  0805 0000               1315mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000738  67D8                    1316mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
0000073A                          1317mm     
0000073A  1A39 00C00017           1318mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000740  13C5 00E00001           1319mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000746                          1320mm     
00000746                          1321mm     ENDM
00000746                          1322mm         PRINT_CHAR D5,D6
00000746                          1323mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000746                 TRUE     1324mm     IFEQ DEBUG
00000746  1C39 00C00003           1325mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000074C  0806 0002               1326mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000750  67F4                    1327mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
00000752  13C5 00C00007           1328mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000758                          1329mm     ENDC
00000758                          1330mm     
00000758                 FALSE    1331mm     IFNE DEBUG
00000758                          1332mm     ENDC
00000758                          1333mm 
00000758                          1334mm     ENDM
00000758                          1335mm         HEX2BIN D5,D5,A4
00000758  49FA 079E               1336mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000075C  0405 0030               1337mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000760  CABC 000000FF           1338mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000766  1A34 5000               1339mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000076A                          1340mm     ENDM
0000076A  8805                    1341m         OR.B D5,D4
0000076C  5307                    1342m         SUB.B #1,D7
0000076E                          1343m     ENDW
0000076E  6098                    1344ms     BRA _1000000E
00000770                          1345ms _1000000F
00000770                          1346m     
00000770  7A00                    1347m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000772  1A04                    1348m     MOVE.B D4,D5
00000774  D484                    1349m     ADD.L D4,D2
00000776                          1350m 
00000776                          1351m     ENDM
00000776                          1352m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000776  1E3C 0002               1353m     MOVE.B #2,D7
0000077A                          1354m     WHILE.B D7 <GT> 0 DO
0000077A                          1355ms _10000010
0000077A  BE38 0000               1356ms     CMP.B   0,D7
0000077E  6F00 0062               1357ms     BLE _10000011
00000782  E98C                    1358m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000784                          1359mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000784                          1360mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                          1361mm 
00000784  1A39 00C00003           1362mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000078A  0805 0000               1363mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000078E  6700 0010               1364mm     BEQ CONTINUE_83                             ; NOTHING, CONTINUE
00000792                          1365mm  
00000792                          1366mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000792                 TRUE     1367mmm     IFEQ DEBUG
00000792  1A39 00C00007           1368mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000798                          1369mmm     ENDC
00000798                 FALSE    1370mmm     IFNE DEBUG
00000798                          1371mmm     ENDC
00000798                          1372mmm      
00000798  BA3C 001B               1373mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000079C  6700 F86A               1374mmm     BEQ START
000007A0                          1375mmm     ENDM
000007A0                          1376mm CONTINUE_83
000007A0  1A39 00C00013           1377mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007A6  0805 0000               1378mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007AA  67D8                    1379mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
000007AC                          1380mm     
000007AC  1A39 00C00017           1381mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007B2  13C5 00E00001           1382mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007B8                          1383mm     
000007B8                          1384mm     ENDM
000007B8                          1385mm         PRINT_CHAR D5,D6
000007B8                          1386mm WAIT_FOR_READY_85                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007B8                 TRUE     1387mm     IFEQ DEBUG
000007B8  1C39 00C00003           1388mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007BE  0806 0002               1389mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007C2  67F4                    1390mm         BEQ WAIT_FOR_READY_85                   ; NO SPACE, CHECK AGAIN
000007C4  13C5 00C00007           1391mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007CA                          1392mm     ENDC
000007CA                          1393mm     
000007CA                 FALSE    1394mm     IFNE DEBUG
000007CA                          1395mm     ENDC
000007CA                          1396mm 
000007CA                          1397mm     ENDM
000007CA                          1398mm         HEX2BIN D5,D5,A4
000007CA  49FA 072C               1399mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007CE  0405 0030               1400mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007D2  CABC 000000FF           1401mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007D8  1A34 5000               1402mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007DC                          1403mm     ENDM
000007DC  8805                    1404m         OR.B D5,D4
000007DE  5307                    1405m         SUB.B #1,D7
000007E0                          1406m     ENDW
000007E0  6098                    1407ms     BRA _10000010
000007E2                          1408ms _10000011
000007E2                          1409m     
000007E2  7A00                    1410m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007E4  1A04                    1411m     MOVE.B D4,D5
000007E6  D484                    1412m     ADD.L D4,D2
000007E8                          1413m 
000007E8                          1414m     ENDM
000007E8                          1415                            
000007E8  2044                    1416                  MOVE.L D4,A0                    ; start address -> A0
000007EA  D1C9                    1417                  ADD.L A1,A0                         ; add in the offset
000007EC                          1418  
000007EC  72FF                    1419                  MOVE.L #$FFFFFFFF,D1             ; done
000007EE                          1420              ELSE
000007EE  6000 0078               1421s     BRA _00000009
000007F2                          1422s _00000008
000007F2                          1423m                 PRINT_CRLF D5,A4
000007F2  49FA 072F               1424m     LEA CRLF(PC),A4
000007F6                          1425mm     PRINT_STR A4,D5
000007F6                          1426mm LOOP_88
000007F6  0C14 0000               1427mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000007FA  6700 0016               1428mm     BEQ EXIT_88
000007FE                          1429mmm     PRINT_CHAR (A4)+,D5
000007FE                          1430mmm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FE                 TRUE     1431mmm     IFEQ DEBUG
000007FE  1A39 00C00003           1432mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000804  0805 0002               1433mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000808  67F4                    1434mmm         BEQ WAIT_FOR_READY_89                   ; NO SPACE, CHECK AGAIN
0000080A  13DC 00C00007           1435mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000810                          1436mmm     ENDC
00000810                          1437mmm     
00000810                 FALSE    1438mmm     IFNE DEBUG
00000810                          1439mmm     ENDC
00000810                          1440mmm 
00000810                          1441mmm     ENDM
00000810  60E4                    1442mm     BRA LOOP_88
00000812                          1443mm EXIT_88
00000812                          1444mm     ENDM
00000812                          1445m     ENDM
00000812                          1446              
00000812  49FA 0699               1447                  LEA UNREC(PC),A4                ; warn for unrecognised type
00000816                          1448m                 PRINT_STR A4,D5
00000816                          1449m LOOP_90
00000816  0C14 0000               1450m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000081A  6700 0016               1451m     BEQ EXIT_90
0000081E                          1452mm     PRINT_CHAR (A4)+,D5
0000081E                          1453mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000081E                 TRUE     1454mm     IFEQ DEBUG
0000081E  1A39 00C00003           1455mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000824  0805 0002               1456mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000828  67F4                    1457mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0000082A  13DC 00C00007           1458mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000830                          1459mm     ENDC
00000830                          1460mm     
00000830                 FALSE    1461mm     IFNE DEBUG
00000830                          1462mm     ENDC
00000830                          1463mm 
00000830                          1464mm     ENDM
00000830  60E4                    1465m     BRA LOOP_90
00000832                          1466m EXIT_90
00000832                          1467m     ENDM
00000832                          1468m                 PRINT_CHAR D1,D5
00000832                          1469m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000832                 TRUE     1470m     IFEQ DEBUG
00000832  1A39 00C00003           1471m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000838  0805 0002               1472m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000083C  67F4                    1473m         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
0000083E  13C1 00C00007           1474m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000844                          1475m     ENDC
00000844                          1476m     
00000844                 FALSE    1477m     IFNE DEBUG
00000844                          1478m     ENDC
00000844                          1479m 
00000844                          1480m     ENDM
00000844                          1481m                 PRINT_CRLF D5,A4
00000844  49FA 06DD               1482m     LEA CRLF(PC),A4
00000848                          1483mm     PRINT_STR A4,D5
00000848                          1484mm LOOP_94
00000848  0C14 0000               1485mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000084C  6700 0016               1486mm     BEQ EXIT_94
00000850                          1487mmm     PRINT_CHAR (A4)+,D5
00000850                          1488mmm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000850                 TRUE     1489mmm     IFEQ DEBUG
00000850  1A39 00C00003           1490mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000856  0805 0002               1491mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000085A  67F4                    1492mmm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0000085C  13DC 00C00007           1493mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000862                          1494mmm     ENDC
00000862                          1495mmm     
00000862                 FALSE    1496mmm     IFNE DEBUG
00000862                          1497mmm     ENDC
00000862                          1498mmm 
00000862                          1499mmm     ENDM
00000862  60E4                    1500mm     BRA LOOP_94
00000864                          1501mm EXIT_94
00000864                          1502mm     ENDM
00000864                          1503m     ENDM
00000864                          1504              
00000864  6000 FAEC               1505                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000868                          1506              ENDI
00000868                          1507s _00000009
00000868                          1508          ENDI
00000868                          1509s _00000007
00000868                          1510      ENDI
00000868                          1511s _00000003
00000868                          1512      
00000868                          1513m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000868  1E3C 0002               1514m     MOVE.B #2,D7
0000086C                          1515m     WHILE.B D7 <GT> 0 DO
0000086C                          1516ms _10000012
0000086C  BE38 0000               1517ms     CMP.B   0,D7
00000870  6F00 0062               1518ms     BLE _10000013
00000874  E98C                    1519m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000876                          1520mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000876                          1521mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000876                          1522mm 
00000876  1A39 00C00003           1523mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000087C  0805 0000               1524mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000880  6700 0010               1525mm     BEQ CONTINUE_97                             ; NOTHING, CONTINUE
00000884                          1526mm  
00000884                          1527mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000884                 TRUE     1528mmm     IFEQ DEBUG
00000884  1A39 00C00007           1529mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000088A                          1530mmm     ENDC
0000088A                 FALSE    1531mmm     IFNE DEBUG
0000088A                          1532mmm     ENDC
0000088A                          1533mmm      
0000088A  BA3C 001B               1534mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000088E  6700 F778               1535mmm     BEQ START
00000892                          1536mmm     ENDM
00000892                          1537mm CONTINUE_97
00000892  1A39 00C00013           1538mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000898  0805 0000               1539mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000089C  67D8                    1540mm     BEQ WAIT_FOR_READY_97                           ; NOTHING, CHECK AGAIN
0000089E                          1541mm     
0000089E  1A39 00C00017           1542mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008A4  13C5 00E00001           1543mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008AA                          1544mm     
000008AA                          1545mm     ENDM
000008AA                          1546mm         PRINT_CHAR D5,D6
000008AA                          1547mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AA                 TRUE     1548mm     IFEQ DEBUG
000008AA  1C39 00C00003           1549mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008B0  0806 0002               1550mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008B4  67F4                    1551mm         BEQ WAIT_FOR_READY_99                   ; NO SPACE, CHECK AGAIN
000008B6  13C5 00C00007           1552mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008BC                          1553mm     ENDC
000008BC                          1554mm     
000008BC                 FALSE    1555mm     IFNE DEBUG
000008BC                          1556mm     ENDC
000008BC                          1557mm 
000008BC                          1558mm     ENDM
000008BC                          1559mm         HEX2BIN D5,D5,A4
000008BC  49FA 063A               1560mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008C0  0405 0030               1561mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008C4  CABC 000000FF           1562mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008CA  1A34 5000               1563mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008CE                          1564mm     ENDM
000008CE  8805                    1565m         OR.B D5,D4
000008D0  5307                    1566m         SUB.B #1,D7
000008D2                          1567m     ENDW
000008D2  6098                    1568ms     BRA _10000012
000008D4                          1569ms _10000013
000008D4                          1570m     
000008D4  7A00                    1571m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008D6  1A04                    1572m     MOVE.B D4,D5
000008D8  D484                    1573m     ADD.L D4,D2
000008DA                          1574m 
000008DA                          1575m     ENDM
000008DA                          1576m     PRINT_CRLF D5,A4
000008DA  49FA 0647               1577m     LEA CRLF(PC),A4
000008DE                          1578mm     PRINT_STR A4,D5
000008DE                          1579mm LOOP_102
000008DE  0C14 0000               1580mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008E2  6700 0016               1581mm     BEQ EXIT_102
000008E6                          1582mmm     PRINT_CHAR (A4)+,D5
000008E6                          1583mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1584mmm     IFEQ DEBUG
000008E6  1A39 00C00003           1585mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008EC  0805 0002               1586mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1587mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
000008F2  13DC 00C00007           1588mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008F8                          1589mmm     ENDC
000008F8                          1590mmm     
000008F8                 FALSE    1591mmm     IFNE DEBUG
000008F8                          1592mmm     ENDC
000008F8                          1593mmm 
000008F8                          1594mmm     ENDM
000008F8  60E4                    1595mm     BRA LOOP_102
000008FA                          1596mm EXIT_102
000008FA                          1597mm     ENDM
000008FA                          1598m     ENDM
000008FA                          1599          
000008FA                          1600      IF.B D2 <NE> #$FF THEN.L
000008FA  B43C 00FF               1601s     CMP.B   #$FF,D2
000008FE  6700 0090               1602s     BEQ.L   _0000000A
00000902  49FA 05C0               1603          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
00000906                          1604m         PRINT_STR A4,D5
00000906                          1605m LOOP_104
00000906  0C14 0000               1606m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000090A  6700 0016               1607m     BEQ EXIT_104
0000090E                          1608mm     PRINT_CHAR (A4)+,D5
0000090E                          1609mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090E                 TRUE     1610mm     IFEQ DEBUG
0000090E  1A39 00C00003           1611mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000914  0805 0002               1612mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000918  67F4                    1613mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
0000091A  13DC 00C00007           1614mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000920                          1615mm     ENDC
00000920                          1616mm     
00000920                 FALSE    1617mm     IFNE DEBUG
00000920                          1618mm     ENDC
00000920                          1619mm 
00000920                          1620mm     ENDM
00000920  60E4                    1621m     BRA LOOP_104
00000922                          1622m EXIT_104
00000922                          1623m     ENDM
00000922                          1624m         PRINT_REG D0,D5,D2,D6,A4
00000922  49FA 0605               1625m     LEA OX(PC),A4
00000926                          1626mm     PRINT_STR A4,D5
00000926                          1627mm LOOP_107
00000926  0C14 0000               1628mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000092A  6700 0016               1629mm     BEQ EXIT_107
0000092E                          1630mmm     PRINT_CHAR (A4)+,D5
0000092E                          1631mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092E                 TRUE     1632mmm     IFEQ DEBUG
0000092E  1A39 00C00003           1633mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000934  0805 0002               1634mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000938  67F4                    1635mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
0000093A  13DC 00C00007           1636mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000940                          1637mmm     ENDC
00000940                          1638mmm     
00000940                 FALSE    1639mmm     IFNE DEBUG
00000940                          1640mmm     ENDC
00000940                          1641mmm 
00000940                          1642mmm     ENDM
00000940  60E4                    1643mm     BRA LOOP_107
00000942                          1644mm EXIT_107
00000942                          1645mm     ENDM
00000942  7C07                    1646m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000944                          1647m LOOP_106
00000944                          1648mm     BIN2HEX D0,D2,A4
00000944  49FA 05A2               1649mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
00000948  E998                    1650mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000094A  1400                    1651mm     MOVE.B D0,D2
0000094C  0282 0000000F           1652mm     ANDI.L #$F,D2
00000952  1434 2000               1653mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000956                          1654mm     ENDM
00000956                          1655mm     PRINT_CHAR D2,D5
00000956                          1656mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000956                 TRUE     1657mm     IFEQ DEBUG
00000956  1A39 00C00003           1658mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000095C  0805 0002               1659mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000960  67F4                    1660mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
00000962  13C2 00C00007           1661mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000968                          1662mm     ENDC
00000968                          1663mm     
00000968                 FALSE    1664mm     IFNE DEBUG
00000968                          1665mm     ENDC
00000968                          1666mm 
00000968                          1667mm     ENDM
00000968  57CE FFDA               1668m     DBEQ D6,LOOP_106
0000096C                          1669m     ENDM
0000096C                          1670m         PRINT_CRLF D5,A4
0000096C  49FA 05B5               1671m     LEA CRLF(PC),A4
00000970                          1672mm     PRINT_STR A4,D5
00000970                          1673mm LOOP_112
00000970  0C14 0000               1674mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000974  6700 0016               1675mm     BEQ EXIT_112
00000978                          1676mmm     PRINT_CHAR (A4)+,D5
00000978                          1677mmm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000978                 TRUE     1678mmm     IFEQ DEBUG
00000978  1A39 00C00003           1679mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000097E  0805 0002               1680mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000982  67F4                    1681mmm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000984  13DC 00C00007           1682mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000098A                          1683mmm     ENDC
0000098A                          1684mmm     
0000098A                 FALSE    1685mmm     IFNE DEBUG
0000098A                          1686mmm     ENDC
0000098A                          1687mmm 
0000098A                          1688mmm     ENDM
0000098A  60E4                    1689mm     BRA LOOP_112
0000098C                          1690mm EXIT_112
0000098C                          1691mm     ENDM
0000098C                          1692m     ENDM
0000098C  6000 F7B0               1693          BRA MAIN_LOOP
00000990                          1694      ENDI
00000990                          1695s _0000000A
00000990                          1696      
00000990                          1697      IF D1 <EQ> #0 THEN
00000990  B27C 0000               1698s     CMP.W   #0,D1
00000994  6600 0006               1699s     BNE _0000000B
00000998  6000 F9B8               1700        BRA WAIT_FOR_SRECORD            
0000099C                          1701      ENDI
0000099C                          1702s _0000000B
0000099C                          1703  DOWNLOAD_DONE
0000099C                          1704m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
0000099C  43FA 058B               1705m     LEA OX(PC),A1
000009A0                          1706mm     PRINT_STR A1,D5
000009A0                          1707mm LOOP_115
000009A0  0C11 0000               1708mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009A4  6700 0016               1709mm     BEQ EXIT_115
000009A8                          1710mmm     PRINT_CHAR (A1)+,D5
000009A8                          1711mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A8                 TRUE     1712mmm     IFEQ DEBUG
000009A8  1A39 00C00003           1713mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009AE  0805 0002               1714mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009B2  67F4                    1715mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009B4  13D9 00C00007           1716mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009BA                          1717mmm     ENDC
000009BA                          1718mmm     
000009BA                 FALSE    1719mmm     IFNE DEBUG
000009BA                          1720mmm     ENDC
000009BA                          1721mmm 
000009BA                          1722mmm     ENDM
000009BA  60E4                    1723mm     BRA LOOP_115
000009BC                          1724mm EXIT_115
000009BC                          1725mm     ENDM
000009BC  7407                    1726m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009BE                          1727m LOOP_114
000009BE                          1728mm     BIN2HEX D0,D6,A1
000009BE  43FA 0528               1729mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009C2  E998                    1730mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009C4  1C00                    1731mm     MOVE.B D0,D6
000009C6  0286 0000000F           1732mm     ANDI.L #$F,D6
000009CC  1C31 6000               1733mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009D0                          1734mm     ENDM
000009D0                          1735mm     PRINT_CHAR D6,D5
000009D0                          1736mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D0                 TRUE     1737mm     IFEQ DEBUG
000009D0  1A39 00C00003           1738mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009D6  0805 0002               1739mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009DA  67F4                    1740mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
000009DC  13C6 00C00007           1741mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009E2                          1742mm     ENDC
000009E2                          1743mm     
000009E2                 FALSE    1744mm     IFNE DEBUG
000009E2                          1745mm     ENDC
000009E2                          1746mm 
000009E2                          1747mm     ENDM
000009E2  57CA FFDA               1748m     DBEQ D2,LOOP_114
000009E6                          1749m     ENDM
000009E6  43FA 04A3               1750      LEA READ(PC),A1
000009EA                          1751m     PRINT_STR A1,D5
000009EA                          1752m LOOP_119
000009EA  0C11 0000               1753m     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009EE  6700 0016               1754m     BEQ EXIT_119
000009F2                          1755mm     PRINT_CHAR (A1)+,D5
000009F2                          1756mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F2                 TRUE     1757mm     IFEQ DEBUG
000009F2  1A39 00C00003           1758mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009F8  0805 0002               1759mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009FC  67F4                    1760mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
000009FE  13D9 00C00007           1761mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A04                          1762mm     ENDC
00000A04                          1763mm     
00000A04                 FALSE    1764mm     IFNE DEBUG
00000A04                          1765mm     ENDC
00000A04                          1766mm 
00000A04                          1767mm     ENDM
00000A04  60E4                    1768m     BRA LOOP_119
00000A06                          1769m EXIT_119
00000A06                          1770m     ENDM
00000A06  2E08                    1771      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A08                          1772m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A08  43FA 051F               1773m     LEA OX(PC),A1
00000A0C                          1774mm     PRINT_STR A1,D5
00000A0C                          1775mm LOOP_122
00000A0C  0C11 0000               1776mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A10  6700 0016               1777mm     BEQ EXIT_122
00000A14                          1778mmm     PRINT_CHAR (A1)+,D5
00000A14                          1779mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A14                 TRUE     1780mmm     IFEQ DEBUG
00000A14  1A39 00C00003           1781mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A1A  0805 0002               1782mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A1E  67F4                    1783mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A20  13D9 00C00007           1784mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A26                          1785mmm     ENDC
00000A26                          1786mmm     
00000A26                 FALSE    1787mmm     IFNE DEBUG
00000A26                          1788mmm     ENDC
00000A26                          1789mmm 
00000A26                          1790mmm     ENDM
00000A26  60E4                    1791mm     BRA LOOP_122
00000A28                          1792mm EXIT_122
00000A28                          1793mm     ENDM
00000A28  7407                    1794m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A2A                          1795m LOOP_121
00000A2A                          1796mm     BIN2HEX D7,D6,A1
00000A2A  43FA 04BC               1797mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A2E  E99F                    1798mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A30  1C07                    1799mm     MOVE.B D7,D6
00000A32  0286 0000000F           1800mm     ANDI.L #$F,D6
00000A38  1C31 6000               1801mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A3C                          1802mm     ENDM
00000A3C                          1803mm     PRINT_CHAR D6,D5
00000A3C                          1804mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A3C                 TRUE     1805mm     IFEQ DEBUG
00000A3C  1A39 00C00003           1806mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A42  0805 0002               1807mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A46  67F4                    1808mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000A48  13C6 00C00007           1809mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A4E                          1810mm     ENDC
00000A4E                          1811mm     
00000A4E                 FALSE    1812mm     IFNE DEBUG
00000A4E                          1813mm     ENDC
00000A4E                          1814mm 
00000A4E                          1815mm     ENDM
00000A4E  57CA FFDA               1816m     DBEQ D2,LOOP_121
00000A52                          1817m     ENDM
00000A52                          1818m     PRINT_CRLF D5,A4     
00000A52  49FA 04CF               1819m     LEA CRLF(PC),A4
00000A56                          1820mm     PRINT_STR A4,D5
00000A56                          1821mm LOOP_127
00000A56  0C14 0000               1822mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A5A  6700 0016               1823mm     BEQ EXIT_127
00000A5E                          1824mmm     PRINT_CHAR (A4)+,D5
00000A5E                          1825mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5E                 TRUE     1826mmm     IFEQ DEBUG
00000A5E  1A39 00C00003           1827mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A64  0805 0002               1828mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A68  67F4                    1829mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A6A  13DC 00C00007           1830mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A70                          1831mmm     ENDC
00000A70                          1832mmm     
00000A70                 FALSE    1833mmm     IFNE DEBUG
00000A70                          1834mmm     ENDC
00000A70                          1835mmm 
00000A70                          1836mmm     ENDM
00000A70  60E4                    1837mm     BRA LOOP_127
00000A72                          1838mm EXIT_127
00000A72                          1839mm     ENDM
00000A72                          1840m     ENDM
00000A72                          1841          
00000A72  6000 F6CA               1842      BRA MAIN_LOOP
00000A76                          1843      
00000A76                          1844  G
00000A76  2047                    1845      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A78  3E3C 0000               1846      MOVE #0,D7                                      ; clear the now used address accumulator
00000A7C  4ED0                    1847      JMP (A0)                                        ; jump to it!
00000A7E                          1848      
00000A7E                          1849  Z
00000A7E  207C 00200000           1850      MOVE.L #RAM,A0                                  ; address of RAM
00000A84                          1851      
00000A84                          1852      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A84  7000                    1853s     MOVE.L  #0,D0
00000A86  6000 0012               1854s     BRA _20000005
00000A8A                          1855s _20000004
00000A8A  2200                    1856          MOVE.L D0,D1                              ; progress update
00000A8C  E089                    1857          LSR.L #8,D1 
00000A8E  E089                    1858          LSR.L #8,D1
00000A90  13C1 00E00001           1859          MOVE.B D1,DISPLAY
00000A96                          1860  
00000A96  20C0                    1861          MOVE.L D0,(A0)+
00000A98                          1862      ENDF
00000A98  5880                    1863s     ADD.L   #4,D0
00000A9A                          1864s _20000005
00000A9A  B0BC 00040000           1865s     CMP.L   #$40000,D0
00000AA0  6FE8                    1866s     BLE _20000004
00000AA2                          1867   
00000AA2  207C 00200000           1868      MOVE.L #RAM,A0                                    ; address of RAM
00000AA8                          1869     
00000AA8                          1870      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AA8  7000                    1871s     MOVE.L  #0,D0
00000AAA  6000 00A6               1872s     BRA _20000007
00000AAE                          1873s _20000006
00000AAE  2200                    1874          MOVE.L D0,D1                              ; progress update
00000AB0  E089                    1875          LSR.L #8,D1
00000AB2  E089                    1876          LSR.L #8,D1
00000AB4  13C1 00E00001           1877          MOVE.B D1,DISPLAY
00000ABA                          1878  
00000ABA  2218                    1879          MOVE.L (A0)+,D1
00000ABC                          1880            
00000ABC                          1881          IF.L D0 <NE> D1 THEN      
00000ABC  B081                    1882s     CMP.L   D1,D0
00000ABE  6700 0090               1883s     BEQ _0000000C
00000AC2  43FA 0412               1884              LEA RAM_ERROR(PC),A1
00000AC6                          1885m             PRINT_STR A1,D1
00000AC6                          1886m LOOP_129
00000AC6  0C11 0000               1887m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000ACA  6700 0016               1888m     BEQ EXIT_129
00000ACE                          1889mm     PRINT_CHAR (A1)+,D1
00000ACE                          1890mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACE                 TRUE     1891mm     IFEQ DEBUG
00000ACE  1239 00C00003           1892mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000AD4  0801 0002               1893mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000AD8  67F4                    1894mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000ADA  13D9 00C00007           1895mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AE0                          1896mm     ENDC
00000AE0                          1897mm     
00000AE0                 FALSE    1898mm     IFNE DEBUG
00000AE0                          1899mm     ENDC
00000AE0                          1900mm 
00000AE0                          1901mm     ENDM
00000AE0  60E4                    1902m     BRA LOOP_129
00000AE2                          1903m EXIT_129
00000AE2                          1904m     ENDM
00000AE2  2208                    1905              MOVE.L A0,D1
00000AE4  5981                    1906              SUB.L #4,D1
00000AE6                          1907m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AE6  43FA 0441               1908m     LEA OX(PC),A1
00000AEA                          1909mm     PRINT_STR A1,D3
00000AEA                          1910mm LOOP_132
00000AEA  0C11 0000               1911mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AEE  6700 0016               1912mm     BEQ EXIT_132
00000AF2                          1913mmm     PRINT_CHAR (A1)+,D3
00000AF2                          1914mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF2                 TRUE     1915mmm     IFEQ DEBUG
00000AF2  1639 00C00003           1916mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AF8  0803 0002               1917mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AFC  67F4                    1918mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000AFE  13D9 00C00007           1919mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B04                          1920mmm     ENDC
00000B04                          1921mmm     
00000B04                 FALSE    1922mmm     IFNE DEBUG
00000B04                          1923mmm     ENDC
00000B04                          1924mmm 
00000B04                          1925mmm     ENDM
00000B04  60E4                    1926mm     BRA LOOP_132
00000B06                          1927mm EXIT_132
00000B06                          1928mm     ENDM
00000B06  7C07                    1929m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B08                          1930m LOOP_131
00000B08                          1931mm     BIN2HEX D1,D2,A1
00000B08  43FA 03DE               1932mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B0C  E999                    1933mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B0E  1401                    1934mm     MOVE.B D1,D2
00000B10  0282 0000000F           1935mm     ANDI.L #$F,D2
00000B16  1431 2000               1936mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B1A                          1937mm     ENDM
00000B1A                          1938mm     PRINT_CHAR D2,D3
00000B1A                          1939mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1A                 TRUE     1940mm     IFEQ DEBUG
00000B1A  1639 00C00003           1941mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B20  0803 0002               1942mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B24  67F4                    1943mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00000B26  13C2 00C00007           1944mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B2C                          1945mm     ENDC
00000B2C                          1946mm     
00000B2C                 FALSE    1947mm     IFNE DEBUG
00000B2C                          1948mm     ENDC
00000B2C                          1949mm 
00000B2C                          1950mm     ENDM
00000B2C  57CE FFDA               1951m     DBEQ D6,LOOP_131
00000B30                          1952m     ENDM
00000B30                          1953m             PRINT_CRLF D3,A1
00000B30  43FA 03F1               1954m     LEA CRLF(PC),A1
00000B34                          1955mm     PRINT_STR A1,D3
00000B34                          1956mm LOOP_137
00000B34  0C11 0000               1957mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B38  6700 0016               1958mm     BEQ EXIT_137
00000B3C                          1959mmm     PRINT_CHAR (A1)+,D3
00000B3C                          1960mmm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     1961mmm     IFEQ DEBUG
00000B3C  1639 00C00003           1962mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B42  0803 0002               1963mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B46  67F4                    1964mmm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B48  13D9 00C00007           1965mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B4E                          1966mmm     ENDC
00000B4E                          1967mmm     
00000B4E                 FALSE    1968mmm     IFNE DEBUG
00000B4E                          1969mmm     ENDC
00000B4E                          1970mmm 
00000B4E                          1971mmm     ENDM
00000B4E  60E4                    1972mm     BRA LOOP_137
00000B50                          1973mm EXIT_137
00000B50                          1974mm     ENDM
00000B50                          1975m     ENDM
00000B50                          1976          ENDI 
00000B50                          1977s _0000000C
00000B50                          1978      ENDF
00000B50  5880                    1979s     ADD.L   #4,D0
00000B52                          1980s _20000007
00000B52  B0BC 00040000           1981s     CMP.L   #$40000,D0
00000B58  6F00 FF54               1982s     BLE _20000006
00000B5C                          1983      
00000B5C  6000 F5E0               1984      BRA MAIN_LOOP
00000B60                          1985    
00000B60                          1986  L
00000B60  7000                    1987      MOVE.L #0,D0                                    ; D0 will be the length  to write            
00000B62  7200                    1988      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B64                          1989  
00000B64                          1990      FOR D2 = #0 TO #7 DO                          ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B64  343C 0000               1991s     MOVE.W  #0,D2
00000B68  6000 0046               1992s     BRA _20000009
00000B6C                          1993s _20000008
00000B6C  E989                    1994          LSL.L #4,D1                                 ; make what we have so far more significant
00000B6E                          1995m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B6E                          1996m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B6E                 TRUE     1997m     IFEQ DEBUG
00000B6E  1839 00C00003           1998m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B74  0804 0000               1999m         BTST #0,D4                              ; CHECK FOR CHARACTER
00000B78  67F4                    2000m         BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00000B7A                          2001m     ENDC
00000B7A                          2002m     
00000B7A                          2003mm     READ_CHAR D3
00000B7A                 TRUE     2004mm     IFEQ DEBUG
00000B7A  1639 00C00007           2005mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B80                          2006mm     ENDC
00000B80                 FALSE    2007mm     IFNE DEBUG
00000B80                          2008mm     ENDC
00000B80                          2009mm      
00000B80  B63C 001B               2010mm     CMP.B #$1B,D3                               ; CHECK FOR ESCAPE AND GO TO START
00000B84  6700 F482               2011mm     BEQ START
00000B88                          2012mm     ENDM
00000B88                          2013m 
00000B88                 TRUE     2014m     IFEQ DEBUG
00000B88                          2015mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B88                          2016mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2017mm     IFEQ DEBUG
00000B88  1839 00C00003           2018mm         MOVE.B DUART_SRA,D4                     ; READ STATUS REGISTER
00000B8E  0804 0002               2019mm         BTST #2,D4                              ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2020mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B94  13C3 00C00007           2021mm         MOVE.B D3,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B9A                          2022mm     ENDC
00000B9A                          2023mm     
00000B9A                 FALSE    2024mm     IFNE DEBUG
00000B9A                          2025mm     ENDC
00000B9A                          2026mm 
00000B9A                          2027mm     ENDM
00000B9A                          2028m     ENDC
00000B9A                          2029m     ENDM
00000B9A                          2030m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000B9A  41FA 035C               2031m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000B9E  0403 0030               2032m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BA2  C6BC 000000FF           2033m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BA8  1630 3000               2034m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BAC                          2035m     ENDM
00000BAC  8203                    2036          OR.B D3,D1
00000BAE                          2037      ENDF
00000BAE  5242                    2038s     ADD.W   #1,D2
00000BB0                          2039s _20000009
00000BB0  B47C 0007               2040s     CMP.W   #7,D2
00000BB4  6FB6                    2041s     BLE _20000008
00000BB6                          2042      
00000BB6  3001                    2043      MOVE.W D1,D0                                  ; extract the LSword for the length
00000BB8  E089                    2044      LSR.L #8,D1                                   ; extract the MSword for the address
00000BBA  E089                    2045      LSR.L #8,D1                                   
00000BBC                          2046                        
00000BBC                          2047m     PRINT_CRLF D2,A1
00000BBC  43FA 0365               2048m     LEA CRLF(PC),A1
00000BC0                          2049mm     PRINT_STR A1,D2
00000BC0                          2050mm LOOP_144
00000BC0  0C11 0000               2051mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BC4  6700 0016               2052mm     BEQ EXIT_144
00000BC8                          2053mmm     PRINT_CHAR (A1)+,D2
00000BC8                          2054mmm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     2055mmm     IFEQ DEBUG
00000BC8  1439 00C00003           2056mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000BCE  0802 0002               2057mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    2058mmm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000BD4  13D9 00C00007           2059mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BDA                          2060mmm     ENDC
00000BDA                          2061mmm     
00000BDA                 FALSE    2062mmm     IFNE DEBUG
00000BDA                          2063mmm     ENDC
00000BDA                          2064mmm 
00000BDA                          2065mmm     ENDM
00000BDA  60E4                    2066mm     BRA LOOP_144
00000BDC                          2067mm EXIT_144
00000BDC                          2068mm     ENDM
00000BDC                          2069m     ENDM
00000BDC                          2070  
00000BDC  2041                    2071      MOVE.L D1,A0                                ; target address
00000BDE                          2072      
00000BDE  2247                    2073      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BE0  7E00                    2074      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BE2                          2075  
00000BE2  5089                    2076      ADD.L #8,A1                                   ; skip the initial stack pointer and reset vector for now
00000BE4  5180                    2077      SUB.L #8,D0
00000BE6                          2078      
00000BE6  31FC AAAA 2AAA          2079      MOVE.W #$AAAA,$2AAA
00000BEC  31FC 5555 1554          2080      MOVE.W #$5555,$1554
00000BF2  31FC 8080 2AAA          2081      MOVE.W #$8080,$2AAA
00000BF8  31FC AAAA 2AAA          2082      MOVE.W #$AAAA,$2AAA
00000BFE  31FC 5555 1554          2083      MOVE.W #$5555,$1554
00000C04  31FC 2020 2AAA          2084      MOVE.W #$2020,$2AAA
00000C0A                          2085      
00000C0A  45FA 0303               2086      LEA LOADING(PC),A2                          ; the prints are important for timing to unprotect the EEPROM
00000C0E                          2087m     PRINT_STR A2,D2
00000C0E                          2088m LOOP_146
00000C0E  0C12 0000               2089m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C12  6700 0016               2090m     BEQ EXIT_146
00000C16                          2091mm     PRINT_CHAR (A2)+,D2
00000C16                          2092mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C16                 TRUE     2093mm     IFEQ DEBUG
00000C16  1439 00C00003           2094mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000C1C  0802 0002               2095mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000C20  67F4                    2096mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000C22  13DA 00C00007           2097mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C28                          2098mm     ENDC
00000C28                          2099mm     
00000C28                 FALSE    2100mm     IFNE DEBUG
00000C28                          2101mm     ENDC
00000C28                          2102mm 
00000C28                          2103mm     ENDM
00000C28  60E4                    2104m     BRA LOOP_146
00000C2A                          2105m EXIT_146
00000C2A                          2106m     ENDM
00000C2A                          2107      
00000C2A  2409                    2108      MOVE.L A1,D2                
00000C2C                          2109m     PRINT_REG D2,D3,D4,D5,A2
00000C2C  45FA 02FB               2110m     LEA OX(PC),A2
00000C30                          2111mm     PRINT_STR A2,D3
00000C30                          2112mm LOOP_149
00000C30  0C12 0000               2113mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C34  6700 0016               2114mm     BEQ EXIT_149
00000C38                          2115mmm     PRINT_CHAR (A2)+,D3
00000C38                          2116mmm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C38                 TRUE     2117mmm     IFEQ DEBUG
00000C38  1639 00C00003           2118mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C3E  0803 0002               2119mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C42  67F4                    2120mmm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00000C44  13DA 00C00007           2121mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C4A                          2122mmm     ENDC
00000C4A                          2123mmm     
00000C4A                 FALSE    2124mmm     IFNE DEBUG
00000C4A                          2125mmm     ENDC
00000C4A                          2126mmm 
00000C4A                          2127mmm     ENDM
00000C4A  60E4                    2128mm     BRA LOOP_149
00000C4C                          2129mm EXIT_149
00000C4C                          2130mm     ENDM
00000C4C  7A07                    2131m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C4E                          2132m LOOP_148
00000C4E                          2133mm     BIN2HEX D2,D4,A2
00000C4E  45FA 0298               2134mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000C52  E99A                    2135mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C54  1802                    2136mm     MOVE.B D2,D4
00000C56  0284 0000000F           2137mm     ANDI.L #$F,D4
00000C5C  1832 4000               2138mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000C60                          2139mm     ENDM
00000C60                          2140mm     PRINT_CHAR D4,D3
00000C60                          2141mm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C60                 TRUE     2142mm     IFEQ DEBUG
00000C60  1639 00C00003           2143mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C66  0803 0002               2144mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C6A  67F4                    2145mm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000C6C  13C4 00C00007           2146mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C72                          2147mm     ENDC
00000C72                          2148mm     
00000C72                 FALSE    2149mm     IFNE DEBUG
00000C72                          2150mm     ENDC
00000C72                          2151mm 
00000C72                          2152mm     ENDM
00000C72  57CD FFDA               2153m     DBEQ D5,LOOP_148
00000C76                          2154m     ENDM
00000C76                          2155  
00000C76  45FA 02B4               2156      LEA TO(PC),A2
00000C7A                          2157m     PRINT_STR A2,D3
00000C7A                          2158m LOOP_153
00000C7A  0C12 0000               2159m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C7E  6700 0016               2160m     BEQ EXIT_153
00000C82                          2161mm     PRINT_CHAR (A2)+,D3
00000C82                          2162mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C82                 TRUE     2163mm     IFEQ DEBUG
00000C82  1639 00C00003           2164mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C88  0803 0002               2165mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C8C  67F4                    2166mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C8E  13DA 00C00007           2167mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C94                          2168mm     ENDC
00000C94                          2169mm     
00000C94                 FALSE    2170mm     IFNE DEBUG
00000C94                          2171mm     ENDC
00000C94                          2172mm 
00000C94                          2173mm     ENDM
00000C94  60E4                    2174m     BRA LOOP_153
00000C96                          2175m EXIT_153
00000C96                          2176m     ENDM
00000C96                          2177      
00000C96  2408                    2178          MOVE.L A0,D2                
00000C98                          2179m     PRINT_REG D2,D3,D4,D5,A2
00000C98  45FA 028F               2180m     LEA OX(PC),A2
00000C9C                          2181mm     PRINT_STR A2,D3
00000C9C                          2182mm LOOP_156
00000C9C  0C12 0000               2183mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CA0  6700 0016               2184mm     BEQ EXIT_156
00000CA4                          2185mmm     PRINT_CHAR (A2)+,D3
00000CA4                          2186mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA4                 TRUE     2187mmm     IFEQ DEBUG
00000CA4  1639 00C00003           2188mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CAA  0803 0002               2189mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CAE  67F4                    2190mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000CB0  13DA 00C00007           2191mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CB6                          2192mmm     ENDC
00000CB6                          2193mmm     
00000CB6                 FALSE    2194mmm     IFNE DEBUG
00000CB6                          2195mmm     ENDC
00000CB6                          2196mmm 
00000CB6                          2197mmm     ENDM
00000CB6  60E4                    2198mm     BRA LOOP_156
00000CB8                          2199mm EXIT_156
00000CB8                          2200mm     ENDM
00000CB8  7A07                    2201m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CBA                          2202m LOOP_155
00000CBA                          2203mm     BIN2HEX D2,D4,A2
00000CBA  45FA 022C               2204mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000CBE  E99A                    2205mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CC0  1802                    2206mm     MOVE.B D2,D4
00000CC2  0284 0000000F           2207mm     ANDI.L #$F,D4
00000CC8  1832 4000               2208mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000CCC                          2209mm     ENDM
00000CCC                          2210mm     PRINT_CHAR D4,D3
00000CCC                          2211mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                 TRUE     2212mm     IFEQ DEBUG
00000CCC  1639 00C00003           2213mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CD2  0803 0002               2214mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CD6  67F4                    2215mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000CD8  13C4 00C00007           2216mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CDE                          2217mm     ENDC
00000CDE                          2218mm     
00000CDE                 FALSE    2219mm     IFNE DEBUG
00000CDE                          2220mm     ENDC
00000CDE                          2221mm 
00000CDE                          2222mm     ENDM
00000CDE  57CD FFDA               2223m     DBEQ D5,LOOP_155
00000CE2                          2224m     ENDM
00000CE2                          2225  
00000CE2                          2226m     PRINT_CRLF D3,A2
00000CE2  45FA 023F               2227m     LEA CRLF(PC),A2
00000CE6                          2228mm     PRINT_STR A2,D3
00000CE6                          2229mm LOOP_161
00000CE6  0C12 0000               2230mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CEA  6700 0016               2231mm     BEQ EXIT_161
00000CEE                          2232mmm     PRINT_CHAR (A2)+,D3
00000CEE                          2233mmm WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CEE                 TRUE     2234mmm     IFEQ DEBUG
00000CEE  1639 00C00003           2235mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CF4  0803 0002               2236mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CF8  67F4                    2237mmm         BEQ WAIT_FOR_READY_162                      ; NO SPACE, CHECK AGAIN
00000CFA  13DA 00C00007           2238mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000D00                          2239mmm     ENDC
00000D00                          2240mmm     
00000D00                 FALSE    2241mmm     IFNE DEBUG
00000D00                          2242mmm     ENDC
00000D00                          2243mmm 
00000D00                          2244mmm     ENDM
00000D00  60E4                    2245mm     BRA LOOP_161
00000D02                          2246mm EXIT_161
00000D02                          2247mm     ENDM
00000D02                          2248m     ENDM
00000D02                          2249  
00000D02                          2250      WHILE D0 <GT> #0 DO
00000D02                          2251s _10000014
00000D02  B07C 0000               2252s     CMP.W   #0,D0
00000D06  6F00 001C               2253s     BLE _10000015
00000D0A  5580                    2254          SUB.L #2,D0
00000D0C                          2255        
00000D0C  13D1 00E00001           2256          MOVE.B (A1),DISPLAY
00000D12                          2257          
00000D12                          2258m         PROGRAM (A1),(A0),D2
00000D12  3091                    2259m   MOVE.W (A1),(A0)                          ; WRITE THE DATA
00000D14                          2260m       
00000D14                          2261m WAIT_FOR_COMPLETE_163
00000D14  3410                    2262m         MOVE.W (A0),D2
00000D16                          2263m 
00000D16                          2264m         IF.W D2 <NE> (A1) THEN
00000D16  B451                    2265ms     CMP.W   (A1),D2
00000D18  6700 0004               2266ms     BEQ _0000000D
00000D1C  60F6                    2267m             BRA WAIT_FOR_COMPLETE_163
00000D1E                          2268m         ENDI
00000D1E                          2269ms _0000000D
00000D1E                          2270m         ENDM
00000D1E                          2271                
00000D1E  5488                    2272          ADD.L #2,A0
00000D20  5489                    2273          ADD.L #2,A1
00000D22                          2274      ENDW
00000D22  60DE                    2275s     BRA _10000014
00000D24                          2276s _10000015
00000D24                          2277      
00000D24                          2278m     PROGRAM #$1234, $0, D2                         ; we're done, can now update the SP and start vector
00000D24  31FC 1234 0000          2279m   MOVE.W #$1234,$0                          ; WRITE THE DATA
00000D2A                          2280m       
00000D2A                          2281m WAIT_FOR_COMPLETE_164
00000D2A  3438 0000               2282m         MOVE.W $0,D2
00000D2E                          2283m 
00000D2E                          2284m         IF.W D2 <NE> #$1234 THEN
00000D2E  B47C 1234               2285ms     CMP.W   #$1234,D2
00000D32  6700 0004               2286ms     BEQ _0000000E
00000D36  60F2                    2287m             BRA WAIT_FOR_COMPLETE_164
00000D38                          2288m         ENDI
00000D38                          2289ms _0000000E
00000D38                          2290m         ENDM
00000D38                          2291m     PROGRAM #$5678, $2, D2                         
00000D38  31FC 5678 0002          2292m   MOVE.W #$5678,$2                          ; WRITE THE DATA
00000D3E                          2293m       
00000D3E                          2294m WAIT_FOR_COMPLETE_165
00000D3E  3438 0002               2295m         MOVE.W $2,D2
00000D42                          2296m 
00000D42                          2297m         IF.W D2 <NE> #$5678 THEN
00000D42  B47C 5678               2298ms     CMP.W   #$5678,D2
00000D46  6700 0004               2299ms     BEQ _0000000F
00000D4A  60F2                    2300m             BRA WAIT_FOR_COMPLETE_165
00000D4C                          2301m         ENDI
00000D4C                          2302ms _0000000F
00000D4C                          2303m         ENDM
00000D4C                          2304  
00000D4C                          2305m     PROGRAM D1, $4, D2                             ; we're done, can now update the SP and start vector
00000D4C  31C1 0004               2306m   MOVE.W D1,$4                          ; WRITE THE DATA
00000D50                          2307m       
00000D50                          2308m WAIT_FOR_COMPLETE_166
00000D50  3438 0004               2309m         MOVE.W $4,D2
00000D54                          2310m 
00000D54                          2311m         IF.W D2 <NE> D1 THEN
00000D54  B441                    2312ms     CMP.W   D1,D2
00000D56  6700 0004               2313ms     BEQ _00000010
00000D5A  60F4                    2314m             BRA WAIT_FOR_COMPLETE_166
00000D5C                          2315m         ENDI
00000D5C                          2316ms _00000010
00000D5C                          2317m         ENDM
00000D5C  E089                    2318      LSR.L #8,D1
00000D5E  E089                    2319      LSR.L #8,D1
00000D60                          2320m     PROGRAM D1, $6, D2                         
00000D60  31C1 0006               2321m   MOVE.W D1,$6                          ; WRITE THE DATA
00000D64                          2322m       
00000D64                          2323m WAIT_FOR_COMPLETE_167
00000D64  3438 0006               2324m         MOVE.W $6,D2
00000D68                          2325m 
00000D68                          2326m         IF.W D2 <NE> D1 THEN
00000D68  B441                    2327ms     CMP.W   D1,D2
00000D6A  6700 0004               2328ms     BEQ _00000011
00000D6E  60F4                    2329m             BRA WAIT_FOR_COMPLETE_167
00000D70                          2330m         ENDI
00000D70                          2331ms _00000011
00000D70                          2332m         ENDM
00000D70                          2333  
00000D70  31FC AAAA 2AAA          2334      MOVE.W #$AAAA,$2AAA                            ; and write protect
00000D76  31FC 5555 1554          2335      MOVE.W #$5555,$1554
00000D7C  31FC A0A0 2AAA          2336      MOVE.W #$A0A0,$2AAA
00000D82                          2337              
00000D82  6000 F3BA               2338      BRA MAIN_LOOP
00000D86                          2339          
00000D86                          2340  HEX_DIGIT
00000D86  E98F                    2341      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000D88                          2342m     HEX2BIN D2,D2,A0
00000D88  41FA 016E               2343m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000D8C  0402 0030               2344m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D90  C4BC 000000FF           2345m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000D96  1430 2000               2346m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000D9A                          2347m     ENDM
00000D9A  8E02                    2348      OR.B D2,D7  
00000D9C  6000 F3C0               2349      BRA GET_INPUT
00000DA0                          2350  
00000DA0  FFFF FFFF               2351      SIMHALT                                         ; halt simulator
00000DA4                          2352  
00000DA4                          2353  ; strings
00000DA4= 4D 44 46 2D 6D 6F ...   2354  VERSION DC.B 'MDF-mon V1.59 (11/04/2021)',CR,LF,NULL
00000DC1= 50 72 65 73 73 20 ...   2355  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000DD4= 3F 09 09 09 68 65 ...   2356  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000DDE= 5B 76 5D 09 09 09 ...   2357          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000DED= 78 78 78 78 78 78 ...   2358          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000E05= 78 78 78 78 78 78 ...   2359          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000E25= 5B 73 5D 09 09 09 ...   2360          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000E3F= 78 78 78 78 78 78 ...   2361          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000E50= 5B 7A 5D 09 09 09 ...   2362          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000E62= 78 78 78 78 78 78 ...   2363          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000E84= 48 75 68 3F 0D 0A 00    2364  HUH     DC.B 'Huh?',CR,LF,NULL
00000E8B= 20 53 20 72 65 63 ...   2365  READ    DC.B ' S records read, start address = ',NULL
00000EAD= 57 3A 20 55 6E 6B ...   2366  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000EC4= 57 3A 20 43 53 20 ...   2367  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000ED6= 57 3A 20 52 41 4D ...   2368  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000EE8= 30 31 32 33 34 35 ...   2369  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000EF8= 00 01 02 03 04 05 ...   2370  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000F0F= 4C 6F 61 64 69 6E ...   2371  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000F23= 0D 0A 00                2372  CRLF    DC.B CR,LF,NULL
00000F26= 3E 20 00                2373  PROMPT  DC.B '> ',NULL
00000F29= 30 78 00                2374  ox      DC.B '0x',NULL
00000F2C= 20 2D 3E 20 00          2375  to      DC.B ' -> ',NULL
00000F31                          2376      
00000F31                          2377      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         EE8
CONTINUE_38         36E
CONTINUE_41         3BE
CONTINUE_45         414
CONTINUE_53         4C8
CONTINUE_58         53A
CONTINUE_63         5B6
CONTINUE_68         634
CONTINUE_73         6BC
CONTINUE_78         72E
CONTINUE_83         7A0
CONTINUE_97         892
CR                  D
CRLF                F23
CS_FAILURE          EC4
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       C2D
DOWNLOAD_DONE       99C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            8FA
EXIT_104            922
EXIT_107            942
EXIT_11             15E
EXIT_112            98C
EXIT_115            9BC
EXIT_119            A06
EXIT_122            A28
EXIT_127            A72
EXIT_129            AE2
EXIT_132            B06
EXIT_137            B50
EXIT_144            BDC
EXIT_146            C2A
EXIT_149            C4C
EXIT_153            C96
EXIT_156            CB8
EXIT_161            D02
EXIT_17             1E2
EXIT_19             232
EXIT_2              D4
EXIT_21             25E
EXIT_24             288
EXIT_29             2D2
EXIT_36             346
EXIT_4              F4
EXIT_50             484
EXIT_6              114
EXIT_88             812
EXIT_9              134
EXIT_90             832
EXIT_94             864
G                   A76
GET_INPUT           15E
H                   236
HELP                DD4
HELPPROMPT          DC1
HEX2BIN             137
HEX2BIN_LUT         EF8
HEX_DIGIT           D86
HUH                 E84
L                   B60
LF                  A
LOADING             F0F
LOOP_102            8DE
LOOP_104            906
LOOP_106            944
LOOP_107            926
LOOP_11             142
LOOP_112            970
LOOP_114            9BE
LOOP_115            9A0
LOOP_119            9EA
LOOP_121            A2A
LOOP_122            A0C
LOOP_127            A56
LOOP_129            AC6
LOOP_131            B08
LOOP_132            AEA
LOOP_137            B34
LOOP_144            BC0
LOOP_146            C0E
LOOP_148            C4E
LOOP_149            C30
LOOP_153            C7A
LOOP_155            CBA
LOOP_156            C9C
LOOP_161            CE6
LOOP_17             1C6
LOOP_19             216
LOOP_2              B8
LOOP_21             242
LOOP_23             28A
LOOP_24             26C
LOOP_29             2B6
LOOP_36             32A
LOOP_4              D8
LOOP_50             468
LOOP_6              F8
LOOP_88             7F6
LOOP_9              118
LOOP_90             816
LOOP_94             848
MAIN_LOOP           13E
NULL                0
OX                  F29
PRINTSTR            242
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROGRAM             E50
PROMPT              F26
R                   262
RAM                 200000
RAM_ERROR           ED6
READ                E8B
READ_CHAR           7E2
READ_DATA_TO_POKE   2DA
RESET               4
ROM                 0
S                   34A
STACK               0
START               8
TAB                 9
TO                  F2C
UNREC               EAD
V                   23E
VERSION             DA4
W                   2D6
WAIT_CHAR           633
WAIT_FOR_COMPLETE_163  D14
WAIT_FOR_COMPLETE_164  D2A
WAIT_FOR_COMPLETE_165  D3E
WAIT_FOR_COMPLETE_166  D50
WAIT_FOR_COMPLETE_167  D64
WAIT_FOR_READY_10   120
WAIT_FOR_READY_103  8E6
WAIT_FOR_READY_105  90E
WAIT_FOR_READY_108  92E
WAIT_FOR_READY_110  956
WAIT_FOR_READY_113  978
WAIT_FOR_READY_116  9A8
WAIT_FOR_READY_118  9D0
WAIT_FOR_READY_12   14A
WAIT_FOR_READY_120  9F2
WAIT_FOR_READY_123  A14
WAIT_FOR_READY_125  A3C
WAIT_FOR_READY_128  A5E
WAIT_FOR_READY_13   15E
WAIT_FOR_READY_130  ACE
WAIT_FOR_READY_133  AF2
WAIT_FOR_READY_135  B1A
WAIT_FOR_READY_138  B3C
WAIT_FOR_READY_139  B6E
WAIT_FOR_READY_141  B88
WAIT_FOR_READY_145  BC8
WAIT_FOR_READY_147  C16
WAIT_FOR_READY_15   178
WAIT_FOR_READY_150  C38
WAIT_FOR_READY_152  C60
WAIT_FOR_READY_154  C82
WAIT_FOR_READY_157  CA4
WAIT_FOR_READY_159  CCC
WAIT_FOR_READY_162  CEE
WAIT_FOR_READY_18   1CE
WAIT_FOR_READY_20   21E
WAIT_FOR_READY_22   24A
WAIT_FOR_READY_25   274
WAIT_FOR_READY_27   29C
WAIT_FOR_READY_3    C0
WAIT_FOR_READY_30   2BE
WAIT_FOR_READY_31   2DC
WAIT_FOR_READY_33   2F6
WAIT_FOR_READY_37   332
WAIT_FOR_READY_38   352
WAIT_FOR_READY_40   38C
WAIT_FOR_READY_41   3A2
WAIT_FOR_READY_43   3D6
WAIT_FOR_READY_45   3F8
WAIT_FOR_READY_47   42C
WAIT_FOR_READY_5    E0
WAIT_FOR_READY_51   470
WAIT_FOR_READY_53   4AC
WAIT_FOR_READY_55   4E0
WAIT_FOR_READY_58   51E
WAIT_FOR_READY_60   552
WAIT_FOR_READY_63   59A
WAIT_FOR_READY_65   5CE
WAIT_FOR_READY_68   618
WAIT_FOR_READY_7    100
WAIT_FOR_READY_70   64C
WAIT_FOR_READY_73   6A0
WAIT_FOR_READY_75   6D4
WAIT_FOR_READY_78   712
WAIT_FOR_READY_80   746
WAIT_FOR_READY_83   784
WAIT_FOR_READY_85   7B8
WAIT_FOR_READY_89   7FE
WAIT_FOR_READY_91   81E
WAIT_FOR_READY_92   832
WAIT_FOR_READY_95   850
WAIT_FOR_READY_97   876
WAIT_FOR_READY_99   8AA
WAIT_FOR_SRECORD    352
Z                   A7E
_00000000           19E
_00000001           1B2
_00000002           48C
_00000003           868
_00000004           49A
_00000005           688
_00000006           5FE
_00000007           868
_00000008           7F2
_00000009           868
_0000000A           990
_0000000B           99C
_0000000C           B50
_0000000D           D1E
_0000000E           D38
_0000000F           D4C
_00000010           D5C
_00000011           D70
_10000000           3EE
_10000001           456
_10000002           4A2
_10000003           50A
_10000004           514
_10000005           57C
_10000006           590
_10000007           5F8
_10000008           602
_10000009           682
_1000000A           60E
_1000000B           676
_1000000C           696
_1000000D           6FE
_1000000E           708
_1000000F           770
_10000010           77A
_10000011           7E2
_10000012           86C
_10000013           8D4
_10000014           D02
_10000015           D24
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A8A
_20000005           A9A
_20000006           AAE
_20000007           B52
_20000008           B6C
_20000009           BB0
