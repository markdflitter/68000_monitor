00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 31/03/2021 10:48:23

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; WRITE doesn't seem to work for reals - it writes to the correct place, but the wrong data
00000000                             9  ; can do WWWWW in the input loop - it doesn't validate
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00E00000                 14  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 15  DISPLAY_            EQU $0
00000000  =00E00001                 16  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            17  
00000000  =00D30000                 18  DUART_BASE          EQU $D30000
00000000  =00000000                 19  DUART_MRA_          EQU $0
00000000  =00000001                 20  DUART_CSRA_         EQU $1
00000000  =00000001                 21  DUART_SRA_          EQU $1
00000000  =00000002                 22  DUART_CRA_          EQU $2
00000000  =00000003                 23  DUART_TXA_          EQU $3
00000000  =00000003                 24  DUART_RXA_          EQU $3
00000000  =00000004                 25  DUART_ACR_          EQU $4
00000000  =00000005                 26  DUART_IMR_          EQU $5
00000000  =00000008                 27  DUART_MRB_          EQU $8
00000000  =00000009                 28  DUART_CSRB_         EQU $9
00000000  =00000009                 29  DUART_SRB_          EQU $9
00000000  =0000000A                 30  DUART_CRB_          EQU $A
00000000  =0000000B                 31  DUART_TXB_          EQU $B
00000000  =0000000B                 32  DUART_RXB_          EQU $B
00000000  =0000000C                 33  DUART_IVR_          EQU $C
00000000  =0000000D                 34  DUART_OPCR_         EQU $D
00000000  =0000000E                 35  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 36  DUART_RESET_OPR_    EQU $F
00000000                            37  RRRR
00000000  =00D30001                 38  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 39  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 40  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 41  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 42  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 43  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            44  
00000000  =00D30011                 45  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 46  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 47  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 48  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 49  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 50  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            51  
00000000  =00D30009                 52  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 53  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 54  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 55  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 56  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 57  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            58  
00000000                            59  ; macros
00000000                            60  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            61  ; the input register is changed during the process
00000000                            62  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            63  BIN2HEX MACRO
00000000                            64    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            65    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            66    MOVE.B \1,\2
00000000                            67    ANDI.L #$F,\2
00000000                            68    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            69    ENDM
00000000                            70  
00000000                            71  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            72  ; the input register is changed during the process
00000000                            73  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            74  HEX2BIN MACRO
00000000                            75    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            76    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            77    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            78    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            79    ENDM
00000000                            80  
00000000                            81  ; send a single char to the serial port
00000000                            82  ; \1 = char to send, \2 = data register to use for status poll
00000000                            83  ; will stamp on D3 and D2 in debug mode
00000000                            84  PRINT_CHAR MACRO
00000000                            85  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            86      IFEQ DEBUG
00000000                            87        MOVE.B DUART_SRA,\2           ; read status register
00000000                            88        BTST #2,\2                    ; check for space to send
00000000                            89        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            90        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            91      ENDC
00000000                            92      
00000000                            93      IFNE DEBUG
00000000                            94        MOVE.B \1,D1
00000000                            95        MOVE.L #6,D0   
00000000                            96        TRAP #15                      ; write to terminal in simulator
00000000                            97      ENDC
00000000                            98  
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send CR,LF to the serial port
00000000                           102  ; \1 = data register to use for status poll
00000000                           103  PRINT_CRLF MACRO                  
00000000                           104      PRINT_CHAR #13,\1             ; CR
00000000                           105      PRINT_CHAR #10,\1             ; LF
00000000                           106      ENDM
00000000                           107  
00000000                           108  ; send C-style, zero terminated string to the serial port
00000000                           109  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           110  PRINT_STR MACRO
00000000                           111  LOOP\@
00000000                           112      CMP.B #0,(\1)                 ; 0 -> done
00000000                           113      BEQ EXIT\@
00000000                           114      PRINT_CHAR (\1)+,\2
00000000                           115      JMP LOOP\@
00000000                           116  EXIT\@
00000000                           117      ENDM
00000000                           118    
00000000                           119  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           120  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           121  PRINT_REG MACRO
00000000                           122      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           123  LOOP\@
00000000                           124      BIN2HEX \1,\3,\5
00000000                           125      PRINT_CHAR \3,\2
00000000                           126      DBEQ \4,LOOP\@
00000000                           127      ENDM
00000000                           128    
00000000                           129  ; read a char from the serial port
00000000                           130  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           131  ; will stamp on D3 and D2 in debug mode
00000000                           132  READ_CHAR MACRO
00000000                           133  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           134  
00000000                           135      IFEQ DEBUG
00000000                           136        MOVE.B DUART_SRA,\2         ; read status register
00000000                           137        BTST #0,\2                    ; check for character
00000000                           138        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           139      ENDC
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           143      ENDC
00000000                           144      IFNE DEBUG
00000000                           145        MOVE.L #5,D0    
00000000                           146        TRAP #15                    ; read from keyboard in simulator
00000000                           147        MOVE.L D1,\1
00000000                           148      ENDC
00000000                           149       
00000000                           150      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           151      BEQ RESTART
00000000                           152  
00000000                           153      IFEQ DEBUG
00000000                           154        PRINT_CHAR \1,\2            ; echo it back
00000000                           155      ENDC
00000000                           156      ENDM
00000000                           157  
00000000                           158  ; register catalogue
00000000                           159  ; D0 - used for simulator I/O
00000000                           160  ; D1 - used for simulator I/O
00000000                           161  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           162  ; D4 - read character
00000000                           163  ; D5 - data to write / data read
00000000                           164  ; D6 - working register used in R/W
00000000                           165  ; D7 - address accumulator
00000000                           166  ; A0 - address of string to print / address for R or W
00000000                           167  
00000000                           168  ; start vector
00000000                           169      ORG  $0
00000000= 00000000                 170      DC.L $00000000              ; PC
00000004= 00000000                 171      DC.L $00000000              ; SP
00000008                           172      
00000008                           173  ; start of program  
00000008                           174  START
00000008  13FC 0000 00E00001       175      MOVE.B #0,DISPLAY
00000010                           176     
00000010                           177  ;initialise UART
00000010  13FC 0000 00D30009       178      MOVE.B #$0,DUART_ACR            
00000018  13FC 0000 00D3000B       179      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000020  13FC 0000 00D3001B       180      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000028                           181  
00000028                           182  ; channel A
00000028  13FC 0003 00D30001       183      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000030  13FC 0007 00D30001       184      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000038  13FC 00BB 00D30003       185      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
00000040  13FC 0005 00D30005       186      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000048                           187  
00000048                           188  ; channel B
00000048  13FC 0003 00D30011       189      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
00000050  13FC 0047 00D30011       190      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
00000058  13FC 00BB 00D30013       191      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
00000060  13FC 0005 00D30015       192      MOVE.B #$5,DUART_CRB            ; enable rx & tx
00000068                           193  
00000068                           194  WARM_START
00000068  13FC 0001 00E00001       195      MOVE.B #1,DISPLAY
00000070                           196         
00000070  41F9 00000486            197      LEA VERSION,A0
00000076                           198m     PRINT_STR A0,D3
00000094                           199m     PRINT_CRLF D3
000000BC                           200m     PRINT_CHAR #7,D3
000000D0                           201  
000000D0  7E00                     202      MOVE.L #0,D7                    ; address accumulator
000000D2                           203  
000000D2  13FC 0002 00E00001       204      MOVE.B #2,DISPLAY
000000DA                           205  MAIN_LOOP
000000DA                           206m     PRINT_CHAR #'>',D3               ; prompt
000000EE                           207m     PRINT_CHAR #32,D3                ; space
00000102                           208      
00000102                           209  GET_INPUT
00000102                           210m     READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000012E                           211      
0000012E  B83C 0030                212      CMP.B #'0',D4
00000132  6700 0332                213      BEQ HEX_DIGIT
00000136  B83C 0031                214      CMP.B #'1',D4
0000013A  6700 032A                215      BEQ HEX_DIGIT
0000013E  B83C 0032                216      CMP.B #'2',D4
00000142  6700 0322                217      BEQ HEX_DIGIT
00000146  B83C 0033                218      CMP.B #'3',D4
0000014A  6700 031A                219      BEQ HEX_DIGIT
0000014E  B83C 0034                220      CMP.B #'4',D4
00000152  6700 0312                221      BEQ HEX_DIGIT
00000156  B83C 0035                222      CMP.B #'5',D4
0000015A  6700 030A                223      BEQ HEX_DIGIT
0000015E  B83C 0036                224      CMP.B #'6',D4
00000162  6700 0302                225      BEQ HEX_DIGIT
00000166  B83C 0037                226      CMP.B #'7',D4
0000016A  6700 02FA                227      BEQ HEX_DIGIT
0000016E  B83C 0038                228      CMP.B #'8',D4
00000172  6700 02F2                229      BEQ HEX_DIGIT
00000176  B83C 0039                230      CMP.B #'9',D4
0000017A  6700 02EA                231      BEQ HEX_DIGIT
0000017E  B83C 0041                232      CMP.B #'A',D4
00000182  6700 02E2                233      BEQ HEX_DIGIT
00000186  B83C 0042                234      CMP.B #'B',D4
0000018A  6700 02DA                235      BEQ HEX_DIGIT
0000018E  B83C 0043                236      CMP.B #'C',D4
00000192  6700 02D2                237      BEQ HEX_DIGIT
00000196  B83C 0044                238      CMP.B #'D',D4
0000019A  6700 02CA                239      BEQ HEX_DIGIT
0000019E  B83C 0045                240      CMP.B #'E',D4
000001A2  6700 02C2                241      BEQ HEX_DIGIT
000001A6  B83C 0046                242      CMP.B #'F',D4
000001AA  6700 02BA                243      BEQ HEX_DIGIT
000001AE                           244      
000001AE  B83C 0057                245      CMP.B #'W',D4
000001B2  6700 01B4                246      BEQ W
000001B6                           247  
000001B6                           248m     PRINT_CRLF D3
000001DE                           249   
000001DE  B83C 003F                250      CMP.B #'?',D4
000001E2  6700 00D6                251      BEQ H
000001E6                           252  
000001E6  B83C 0056                253      CMP.B #'V',D4
000001EA  6700 00F6                254      BEQ V
000001EE                           255      
000001EE  B83C 0052                256      CMP.B #'R',D4
000001F2  6700 0116                257      BEQ R
000001F6                           258  
000001F6  B83C 0053                259      CMP.B #'S',D4
000001FA  6700 0232                260      BEQ S
000001FE                           261  
000001FE  B83C 0047                262      CMP.B #'G',D4
00000202  6700 025A                263      BEQ G   
00000206                           264  
00000206  41F9 000004FD            265      LEA HUH,A0
0000020C                           266m     PRINT_STR A0,D3
0000022A                           267                         
0000022A  4EF8 00DA                268      JMP MAIN_LOOP
0000022E                           269  
0000022E                           270  RESTART
0000022E                           271m     PRINT_CRLF D3
00000256                           272     
00000256  13FC 000A 00D30005       273      MOVE.B #$A,DUART_CRA            ; disable rx & tx
0000025E  13FC 0010 00D30005       274      MOVE.B #$10,DUART_CRA           ; reset MRA pointer
00000266                           275  
00000266  13FC 0000 00D30009       276      MOVE.B #$0,DUART_ACR            
0000026E  13FC 0000 00D3000B       277      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000276  13FC 0000 00D3001B       278      MOVE.B #$0,DUART_OPCR           ; enable all outputs
0000027E                           279  
0000027E                           280  ; channel A
0000027E  13FC 0003 00D30001       281      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000286                           282      ;MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000286  13FC 00BB 00D30003       283      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
0000028E  13FC 0005 00D30005       284      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000296                           285  
00000296                           286  ; channel B
00000296  13FC 0003 00D30011       287      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
0000029E  13FC 0047 00D30011       288      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
000002A6  13FC 00BB 00D30013       289      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000002AE  13FC 0005 00D30015       290      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000002B6                           291  
000002B6  4EF8 0068                292      JMP WARM_START
000002BA                           293  
000002BA                           294  ; commands
000002BA  41F9 000004A2            295  H   LEA HELP,A0
000002C0                           296m     PRINT_STR A0,D3
000002DE  4EF8 00DA                297      JMP MAIN_LOOP
000002E2                           298  
000002E2  41F9 00000486            299  V   LEA VERSION,A0
000002E8                           300m     PRINT_STR A0,D3       
00000306  4EF8 00DA                301      JMP MAIN_LOOP
0000030A                           302      
0000030A                           303  R   
0000030A  2047                     304      MOVE.L D7,A0                    ; address accumulator -> address register
0000030C  2A10                     305      MOVE.L (A0),D5                  ; read the memory and print it
0000030E                           306m     PRINT_REG D5,D3,D7,D6,A0
0000033A                           307m     PRINT_CRLF D3
00000362  7E00                     308      MOVE.L #0,D7                    ; clear the now used address accumulator
00000364  4EF8 00DA                309      JMP MAIN_LOOP
00000368                           310  
00000368  7A00                     311  W   MOVE.L #0,D5                    ; D5 will be the value to write            
0000036A                           312  
0000036A                           313m     READ_CHAR D4,D3                 ; read most significant character -> D4
00000396                           314m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
000003AA  1A04                     315      MOVE.B D4,D5                    ; put at bottom of D5
000003AC                           316  
000003AC  3C3C 0006                317      MOVE #6,D6                      ; 7 bytes left to read
000003B0                           318      
000003B0                           319  READ_DATA
000003B0  E98D                     320      LSL.L #4,D5                     ; make what we have so far more significant
000003B2                           321m     READ_CHAR D4,D3                 ; next character -> D4
000003DE                           322m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
000003F2  8A04                     323      OR.B D4,D5
000003F4  023C 00FB                324      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
000003F8  57CE FFB6                325      DBEQ D6,READ_DATA
000003FC                           326      
000003FC  2047                     327      MOVE.L D7,A0                    ; address accumulator -> address register
000003FE  7E00                     328      MOVE.L #0,D7                    ; clear the now used address accumulator
00000400                           329      
00000400  2084                     330      MOVE.L D4,(A0)                  ; write the data
00000402                           331  
00000402                           332m     PRINT_CRLF D3
0000042A  4EF8 00DA                333      JMP MAIN_LOOP
0000042E                           334  
0000042E                           335m S   READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000045A  4EF8 042E                336      JMP S
0000045E                           337  
0000045E  2047                     338  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000460  3E3C 0000                339      MOVE #0,D7                      ; clear the now used address accumulator
00000464  4ED0                     340      JMP (A0)                        ; jump to it!
00000466                           341          
00000466                           342  HEX_DIGIT
00000466  E98F                     343      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000468                           344m     HEX2BIN D4,D4,A0
0000047C  8E04                     345      OR.B D4,D7  
0000047E  4EF8 0102                346      JMP GET_INPUT
00000482                           347  
00000482  FFFF FFFF                348      SIMHALT                         ; halt simulator
00000486                           349  
00000486                           350  ; strings
00000486= 4D 44 46 2D 6D 6F ...    351  VERSION DC.B 'MDF-mon V1.5 (31/03/2021)',13,10,0
000004A2= 3F 20 48 65 6C 70 ...    352  HELP    DC.B '? Help',13,10,'V Version',13,10,'nnnnnnnnR Read',13,10,'nnnnnnnnWnn Write',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
000004FD= 48 75 68 3F 0D 0A 00     353  HUH     DC.B 'Huh?',13,10,0
00000504= 55 6E 69 6D 70 6C ...    354  UNIMP   DC.B 'Unimplemented',13,10,0
00000514= 30 31 32 33 34 35 ...    355  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000524= 00 01 02 03 04 05 ...    356  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000053B                           357      
0000053B                           358      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         514
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_1              94
EXIT_14             22A
EXIT_19             2DE
EXIT_21             306
G                   45E
GET_INPUT           102
H                   2BA
HELP                4A2
HEX2BIN             12B
HEX2BIN_LUT         524
HEX_DIGIT           466
HUH                 4FD
LOOP_1              76
LOOP_14             20C
LOOP_19             2C0
LOOP_21             2E8
LOOP_23             310
MAIN_LOOP           DA
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   30A
READ_CHAR           5D1
READ_DATA           3B0
RESTART             22E
RRRR                0
S                   42E
START               8
UNIMP               504
V                   2E2
VERSION             486
W                   368
WAIT_FOR_READY_10   11C
WAIT_FOR_READY_12   1B6
WAIT_FOR_READY_13   1CA
WAIT_FOR_READY_15   214
WAIT_FOR_READY_17   22E
WAIT_FOR_READY_18   242
WAIT_FOR_READY_2    7E
WAIT_FOR_READY_20   2C8
WAIT_FOR_READY_22   2F0
WAIT_FOR_READY_25   324
WAIT_FOR_READY_27   33A
WAIT_FOR_READY_28   34E
WAIT_FOR_READY_29   36A
WAIT_FOR_READY_30   384
WAIT_FOR_READY_32   3B2
WAIT_FOR_READY_33   3CC
WAIT_FOR_READY_36   402
WAIT_FOR_READY_37   416
WAIT_FOR_READY_38   42E
WAIT_FOR_READY_39   448
WAIT_FOR_READY_4    94
WAIT_FOR_READY_5    A8
WAIT_FOR_READY_6    BC
WAIT_FOR_READY_7    DA
WAIT_FOR_READY_8    EE
WAIT_FOR_READY_9    102
WARM_START          68
