00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 12:47:41

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                             9  ; something prints 'N' on starting...
00000000                            10  ; press ? for help
00000000                            11  ; use DBLoop?
00000000                            12  
00000000                            13  ; ideas, but no room to do them
00000000                            14  ;------------------------------
00000000                            15  ; keep track of highest address hit during srec download
00000000                            16  ; implement backspace
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            20  
00000000                            21      ORG  $0
00000000                            22  
00000000  =00000000                 23  DEBUG               EQU 0
00000000                            24  
00000000                            25  ; constants
00000000  =00000000                 26  NULL                EQU 0
00000000  =00000009                 27  TAB                 EQU 9
00000000  =0000000D                 28  CR                  EQU 13
00000000  =0000000A                 29  LF                  EQU 10
00000000                            30  
00000000  =00000000                 31  ROM                 EQU $0
00000000  =00200000                 32  RAM                 EQU $200000
00000000                            33     
00000000  =00C00000                 34  DUART_BASE          EQU $C00000
00000000  =00000000                 35  DUART_MRA_          EQU $0
00000000  =00000001                 36  DUART_CSRA_         EQU $1
00000000  =00000001                 37  DUART_SRA_          EQU $1
00000000  =00000002                 38  DUART_CRA_          EQU $2
00000000  =00000003                 39  DUART_TXA_          EQU $3
00000000  =00000003                 40  DUART_RXA_          EQU $3
00000000  =00000004                 41  DUART_ACR_          EQU $4
00000000  =00000005                 42  DUART_IMR_          EQU $5
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            74  
00000000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 76  DISPLAY_            EQU $0
00000000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            78  
00000000                            79  ; macros
00000000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            81  ; the input register is changed during the process
00000000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            83  BIN2HEX MACRO
00000000                            84      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            86      MOVE.B \1,\2
00000000                            87      ANDI.L #$F,\2
00000000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            89      ENDM
00000000                            90  
00000000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            92  ; the input register is changed during the process
00000000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            94  HEX2BIN MACRO
00000000                            95      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send a single char to the serial port
00000000                           102  ; \1 = char to send, \2 = data register to use for status poll
00000000                           103  ; will stamp on D0 and D1 in debug mode
00000000                           104  PRINT_CHAR MACRO
00000000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           106      IFEQ DEBUG
00000000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           108          BTST #2,\2                              ; check for space to send
00000000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           111      ENDC
00000000                           112      
00000000                           113      IFNE DEBUG
00000000                           114          MOVE.B \1,D1
00000000                           115          MOVE.L #6,D0   
00000000                           116          TRAP #15                                ; write to terminal in simulator
00000000                           117      ENDC
00000000                           118  
00000000                           119      ENDM
00000000                           120  
00000000                           121  ; send CR,LF to the serial port
00000000                           122  ; \1 = data register to use for status poll, /2 = working address register
00000000                           123  PRINT_CRLF MACRO
00000000                           124      LEA CRLF(PC),\2
00000000                           125      PRINT_STR \2,\1
00000000                           126      ENDM
00000000                           127  
00000000                           128  ; send C-style, zero terminated string to the serial port
00000000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           130  PRINT_STR MACRO
00000000                           131  LOOP\@
00000000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           133      BEQ EXIT\@
00000000                           134      PRINT_CHAR (\1)+,\2
00000000                           135      BRA LOOP\@
00000000                           136  EXIT\@
00000000                           137      ENDM
00000000                           138    
00000000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           141  PRINT_REG MACRO
00000000                           142      LEA ox(PC),\5
00000000                           143      PRINT_STR \5,\2
00000000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           145  LOOP\@
00000000                           146      BIN2HEX \1,\3,\5
00000000                           147      PRINT_CHAR \3,\2
00000000                           148      DBEQ \4,LOOP\@
00000000                           149      ENDM
00000000                           150      
00000000                           151  ; wait for a char from the serial port
00000000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  WAIT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #0,\2                              ; check for character
00000000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           160      ENDC
00000000                           161      
00000000                           162      READ_CHAR \1
00000000                           163  
00000000                           164      IFEQ DEBUG
00000000                           165          PRINT_CHAR \1,\2                            ; echo it back
00000000                           166      ENDC
00000000                           167      ENDM
00000000                           168      
00000000                           169  ; read a char from the serial port - assumes that there is one!
00000000                           170  ; \ 1= data register for read char
00000000                           171  ; will stamp on D0 and D1 in debug mode
00000000                           172  READ_CHAR MACRO
00000000                           173      IFEQ DEBUG
00000000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           175      ENDC
00000000                           176      IFNE DEBUG
00000000                           177          MOVE.L #5,D0    
00000000                           178          TRAP #15                                    ; read from keyboard in simulator
00000000                           179          MOVE.L D1,\1
00000000                           180      ENDC
00000000                           181       
00000000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           183      BEQ START
00000000                           184      ENDM
00000000                           185      
00000000                           186      
00000000                           187  ; read data from the download serial port
00000000                           188  ; \ 1= data register for read char
00000000                           189  DOWNLOAD MACRO
00000000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           191  
00000000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ CONTINUE\@                              ; nothing, continue
00000000                           195   
00000000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           197  CONTINUE\@
00000000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           199      BTST #0,\1                                      ; check for character
00000000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           201      
00000000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           204      
00000000                           205      ENDM
00000000                           206      
00000000                           207  ; read two hex digits from the download serial port and convert to a byte
00000000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           209  DOWNLOAD_BYTE MACRO
00000000                           210      MOVE.B #2,\4
00000000                           211      WHILE.B \4 <GT> 0 DO
00000000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           214          PRINT_CHAR \2,\3
00000000                           215          HEX2BIN \2,\2,\6
00000000                           216          OR.B \2,\1
00000000                           217          SUB.B #1,\4
00000000                           218      ENDW
00000000                           219      
00000000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           221      MOVE.B \1,\2
00000000                           222      ADD.L \1,\5
00000000                           223  
00000000                           224      ENDM
00000000                           225      
00000000                           226  ; write word to EEPROM
00000000                           227  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           228  PROGRAM MACRO
00000000                           229    MOVE.W \1,\2                          ; write the data
00000000                           230        
00000000                           231  WAIT_FOR_COMPLETE\@
00000000                           232          MOVE.W \2,\3
00000000                           233  
00000000                           234          IF.W \3 <NE> \1 THEN
00000000                           235              BRA WAIT_FOR_COMPLETE\@
00000000                           236          ENDI
00000000                           237          ENDM
00000000                           238          
00000000                           239  ; register catalogue
00000000                           240  ; D0 - used for simulator I/O
00000000                           241  ; D1 - used for simulator I/O
00000000                           242  ; D2 - read character
00000000                           243  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           244  ; D6 - working register used in R/W
00000000                           245  ; D7 - address accumulator, reset by download
00000000                           246  ; A0 - address of string to print 
00000000                           247  
00000000                           248  ; start vector
00000000= 00000000                 249  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 250  RESET    DC.L START                             ; RESET
00000008                           251      
00000008                           252  ; start of program  
00000008                           253  START
00000008  13FC 0000 00E00001       254      MOVE.B #0,DISPLAY
00000010                           255  
00000010                           256  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       257      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       258      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           259      
00000020                           260      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                261s     MOVE.W  #$50,D1
00000024  6000 000E                262s     BRA _20000001
00000028                           263s _20000000
00000028  13C1 00C00005            264          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     265          NOP
00000030                           266      ENDF
00000030  0441 0010                267s     SUB.W   #$10,D1
00000034                           268s _20000001
00000034  B27C 0010                269s     CMP.W   #$10,D1
00000038  6CEE                     270s     BGE _20000000
0000003A                           271  
0000003A                           272      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                273s     MOVE.W  #$50,D1
0000003E  6000 000E                274s     BRA _20000003
00000042                           275s _20000002
00000042  13C1 00C00015            276          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     277          NOP
0000004A                           278      ENDF
0000004A  0441 0010                279s     SUB.W   #$10,D1
0000004E                           280s _20000003
0000004E  B27C 0010                281s     CMP.W   #$10,D1
00000052  6CEE                     282s     BGE _20000002
00000054                           283    
00000054                           284  ;initialise UART
00000054  13FC 0000 00C00009       285      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       286      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       287      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           288  
0000006C                           289  ; channel A
0000006C  13FC 0013 00C00001       290      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       291      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       292      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       293      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           294  
0000008C                           295  ; channel B
0000008C  13FC 0013 00C00011       296      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       297      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       298      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       299      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           300  
000000AC                           301m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000AC                           302m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      303m     IFEQ DEBUG
000000AC  1639 00C00003            304m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000B2  0803 0002                305m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000B6  67F4                     306m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000B8  13F8 002E 00C00007       307m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000C0                           308m     ENDC
000000C0                           309m     
000000C0                 FALSE     310m     IFNE DEBUG
000000C0                           311m     ENDC
000000C0                           312m 
000000C0                           313m     ENDM
000000C0                           314  
000000C0  13FC 0001 00E00001       315      MOVE.B #1,DISPLAY
000000C8                           316         
000000C8                           317m     PRINT_CRLF D3,A0
000000C8  41FA 0E6D                318m     LEA CRLF(PC),A0
000000CC                           319mm     PRINT_STR A0,D3
000000CC                           320mm LOOP_3
000000CC  0C10 0000                321mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000D0  6700 0016                322mm     BEQ EXIT_3
000000D4                           323mmm     PRINT_CHAR (A0)+,D3
000000D4                           324mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      325mmm     IFEQ DEBUG
000000D4  1639 00C00003            326mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DA  0803 0002                327mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000DE  67F4                     328mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
000000E0  13D8 00C00007            329mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000E6                           330mmm     ENDC
000000E6                           331mmm     
000000E6                 FALSE     332mmm     IFNE DEBUG
000000E6                           333mmm     ENDC
000000E6                           334mmm 
000000E6                           335mmm     ENDM
000000E6  60E4                     336mm     BRA LOOP_3
000000E8                           337mm EXIT_3
000000E8                           338mm     ENDM
000000E8                           339m     ENDM
000000E8                           340  
000000E8  41FA 0CCE                341      LEA VERSION(PC),A0
000000EC                           342m     PRINT_STR A0,D3
000000EC                           343m LOOP_5
000000EC  0C10 0000                344m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000F0  6700 0016                345m     BEQ EXIT_5
000000F4                           346mm     PRINT_CHAR (A0)+,D3
000000F4                           347mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      348mm     IFEQ DEBUG
000000F4  1639 00C00003            349mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                350mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     351mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000100  13D8 00C00007            352mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000106                           353mm     ENDC
00000106                           354mm     
00000106                 FALSE     355mm     IFNE DEBUG
00000106                           356mm     ENDC
00000106                           357mm 
00000106                           358mm     ENDM
00000106  60E4                     359m     BRA LOOP_5
00000108                           360m EXIT_5
00000108                           361m     ENDM
00000108                           362      
00000108  41FA 0CCB                363      LEA HELPPROMPT(PC),A0
0000010C                           364m     PRINT_STR A0,D3
0000010C                           365m LOOP_7
0000010C  0C10 0000                366m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000110  6700 0016                367m     BEQ EXIT_7
00000114                           368mm     PRINT_CHAR (A0)+,D3
00000114                           369mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000114                 TRUE      370mm     IFEQ DEBUG
00000114  1639 00C00003            371mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000011A  0803 0002                372mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000011E  67F4                     373mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
00000120  13D8 00C00007            374mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000126                           375mm     ENDC
00000126                           376mm     
00000126                 FALSE     377mm     IFNE DEBUG
00000126                           378mm     ENDC
00000126                           379mm 
00000126                           380mm     ENDM
00000126  60E4                     381m     BRA LOOP_7
00000128                           382m EXIT_7
00000128                           383m     ENDM
00000128                           384      
00000128                           385m     PRINT_CRLF D3,A0
00000128  41FA 0E0D                386m     LEA CRLF(PC),A0
0000012C                           387mm     PRINT_STR A0,D3
0000012C                           388mm LOOP_10
0000012C  0C10 0000                389mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000130  6700 0016                390mm     BEQ EXIT_10
00000134                           391mmm     PRINT_CHAR (A0)+,D3
00000134                           392mmm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000134                 TRUE      393mmm     IFEQ DEBUG
00000134  1639 00C00003            394mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000013A  0803 0002                395mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000013E  67F4                     396mmm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000140  13D8 00C00007            397mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000146                           398mmm     ENDC
00000146                           399mmm     
00000146                 FALSE     400mmm     IFNE DEBUG
00000146                           401mmm     ENDC
00000146                           402mmm 
00000146                           403mmm     ENDM
00000146  60E4                     404mm     BRA LOOP_10
00000148                           405mm EXIT_10
00000148                           406mm     ENDM
00000148                           407m     ENDM
00000148                           408  
00000148  7E00                     409      MOVE.L #0,D7                                    ; address accumulator
0000014A                           410  
0000014A  13FC 0002 00E00001       411      MOVE.B #2,DISPLAY
00000152                           412  MAIN_LOOP
00000152  41FA 0DE6                413      LEA PROMPT(PC),A0
00000156                           414m     PRINT_STR A0,D3
00000156                           415m LOOP_12
00000156  0C10 0000                416m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000015A  6700 0016                417m     BEQ EXIT_12
0000015E                           418mm     PRINT_CHAR (A0)+,D3
0000015E                           419mm WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015E                 TRUE      420mm     IFEQ DEBUG
0000015E  1639 00C00003            421mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000164  0803 0002                422mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000168  67F4                     423mm         BEQ WAIT_FOR_READY_13                   ; NO SPACE, CHECK AGAIN
0000016A  13D8 00C00007            424mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000170                           425mm     ENDC
00000170                           426mm     
00000170                 FALSE     427mm     IFNE DEBUG
00000170                           428mm     ENDC
00000170                           429mm 
00000170                           430mm     ENDM
00000170  60E4                     431m     BRA LOOP_12
00000172                           432m EXIT_12
00000172                           433m     ENDM
00000172                           434      
00000172                           435  GET_INPUT
00000172                           436m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00000172                           437m WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000172                 TRUE      438m     IFEQ DEBUG
00000172  1639 00C00003            439m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000178  0803 0000                440m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000017C  67F4                     441m         BEQ WAIT_FOR_READY_14                   ; NOTHING, CHECK AGAIN
0000017E                           442m     ENDC
0000017E                           443m     
0000017E                           444mm     READ_CHAR D2
0000017E                 TRUE      445mm     IFEQ DEBUG
0000017E  1439 00C00007            446mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000184                           447mm     ENDC
00000184                 FALSE     448mm     IFNE DEBUG
00000184                           449mm     ENDC
00000184                           450mm      
00000184  B43C 001B                451mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000188  6700 FE7E                452mm     BEQ START
0000018C                           453mm     ENDM
0000018C                           454m 
0000018C                 TRUE      455m     IFEQ DEBUG
0000018C                           456mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000018C                           457mm WAIT_FOR_READY_16                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000018C                 TRUE      458mm     IFEQ DEBUG
0000018C  1639 00C00003            459mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000192  0803 0002                460mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000196  67F4                     461mm         BEQ WAIT_FOR_READY_16                   ; NO SPACE, CHECK AGAIN
00000198  13C2 00C00007            462mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000019E                           463mm     ENDC
0000019E                           464mm     
0000019E                 FALSE     465mm     IFNE DEBUG
0000019E                           466mm     ENDC
0000019E                           467mm 
0000019E                           468mm     ENDM
0000019E                           469m     ENDC
0000019E                           470m     ENDM
0000019E                           471      
0000019E                           472      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000019E  B43C 0030                473s     CMP.B   #'0',D2
000001A2  6D00 000E                474s     BLT _00000000
000001A6  B43C 0039                475s     CMP.B   #'9',D2
000001AA  6E00 0006                476s     BGT _00000000
000001AE  6000 0BEA                477          BRA HEX_DIGIT
000001B2                           478      ENDI
000001B2                           479s _00000000
000001B2                           480      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001B2  B43C 0041                481s     CMP.B   #'A',D2
000001B6  6D00 000E                482s     BLT _00000001
000001BA  B43C 0046                483s     CMP.B   #'F',D2
000001BE  6E00 0006                484s     BGT _00000001
000001C2  6000 0BD6                485          BRA HEX_DIGIT
000001C6                           486      ENDI
000001C6                           487s _00000001
000001C6                           488          
000001C6  B43C 0077                489      CMP.B #'w',D2
000001CA  6700 011E                490      BEQ W
000001CE                           491      
000001CE  B43C 006C                492      CMP.B #'l',D2
000001D2  6700 09A0                493      BEQ L 
000001D6                           494  
000001D6                           495m     PRINT_CRLF D3,A0
000001D6  41FA 0D5F                496m     LEA CRLF(PC),A0
000001DA                           497mm     PRINT_STR A0,D3
000001DA                           498mm LOOP_18
000001DA  0C10 0000                499mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001DE  6700 0016                500mm     BEQ EXIT_18
000001E2                           501mmm     PRINT_CHAR (A0)+,D3
000001E2                           502mmm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      503mmm     IFEQ DEBUG
000001E2  1639 00C00003            504mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001E8  0803 0002                505mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001EC  67F4                     506mmm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
000001EE  13D8 00C00007            507mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001F4                           508mmm     ENDC
000001F4                           509mmm     
000001F4                 FALSE     510mmm     IFNE DEBUG
000001F4                           511mmm     ENDC
000001F4                           512mmm 
000001F4                           513mmm     ENDM
000001F4  60E4                     514mm     BRA LOOP_18
000001F6                           515mm EXIT_18
000001F6                           516mm     ENDM
000001F6                           517m     ENDM
000001F6                           518   
000001F6  B43C 003F                519      CMP.B #'?',D2
000001FA  6700 004E                520      BEQ H
000001FE                           521   
000001FE  B43C 0076                522      CMP.B #'v',D2
00000202  6700 004E                523      BEQ V
00000206                           524      
00000206  B43C 0072                525      CMP.B #'r',D2
0000020A  6700 006A                526      BEQ R
0000020E                           527  
0000020E  B43C 0073                528      CMP.B #'s',D2
00000212  6700 014A                529      BEQ S
00000216                           530  
00000216  B43C 0067                531      CMP.B #'g',D2
0000021A  6700 086E                532      BEQ G   
0000021E                           533  
0000021E  B43C 007A                534      CMP.B #'z',D2
00000222  6700 086E                535      BEQ Z   
00000226                           536  
00000226  41FA 0C70                537      LEA HUH(PC),A0
0000022A                           538m     PRINT_STR A0,D3
0000022A                           539m LOOP_20
0000022A  0C10 0000                540m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000022E  6700 0016                541m     BEQ EXIT_20
00000232                           542mm     PRINT_CHAR (A0)+,D3
00000232                           543mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000232                 TRUE      544mm     IFEQ DEBUG
00000232  1639 00C00003            545mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000238  0803 0002                546mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000023C  67F4                     547mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000023E  13D8 00C00007            548mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000244                           549mm     ENDC
00000244                           550mm     
00000244                 FALSE     551mm     IFNE DEBUG
00000244                           552mm     ENDC
00000244                           553mm 
00000244                           554mm     ENDM
00000244  60E4                     555m     BRA LOOP_20
00000246                           556m EXIT_20
00000246                           557m     ENDM
00000246                           558                         
00000246  6000 FF0A                559      BRA MAIN_LOOP
0000024A                           560      
0000024A                           561  ; commands
0000024A                           562  H   
0000024A  41FA 0B9C                563      LEA HELP(PC),A0
0000024E  6000 0006                564      BRA PRINTSTR
00000252                           565  
00000252                           566  V   
00000252  41FA 0B64                567      LEA VERSION(PC),A0
00000256                           568  PRINTSTR
00000256                           569m     PRINT_STR A0,D3       
00000256                           570m LOOP_22
00000256  0C10 0000                571m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000025A  6700 0016                572m     BEQ EXIT_22
0000025E                           573mm     PRINT_CHAR (A0)+,D3
0000025E                           574mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000025E                 TRUE      575mm     IFEQ DEBUG
0000025E  1639 00C00003            576mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000264  0803 0002                577mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000268  67F4                     578mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
0000026A  13D8 00C00007            579mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000270                           580mm     ENDC
00000270                           581mm     
00000270                 FALSE     582mm     IFNE DEBUG
00000270                           583mm     ENDC
00000270                           584mm 
00000270                           585mm     ENDM
00000270  60E4                     586m     BRA LOOP_22
00000272                           587m EXIT_22
00000272                           588m     ENDM
00000272  6000 FEDE                589      BRA MAIN_LOOP
00000276                           590      
00000276                           591  R   
00000276  2047                     592      MOVE.L D7,A0                                    ; address accumulator -> address register
00000278  7E00                     593      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000027A  2410                     594      MOVE.L (A0),D2                                  ; read the memory and print it
0000027C                           595m     PRINT_REG D2,D3,D4,D5,A0
0000027C  41FA 0CBF                596m     LEA OX(PC),A0
00000280                           597mm     PRINT_STR A0,D3
00000280                           598mm LOOP_25
00000280  0C10 0000                599mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000284  6700 0016                600mm     BEQ EXIT_25
00000288                           601mmm     PRINT_CHAR (A0)+,D3
00000288                           602mmm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000288                 TRUE      603mmm     IFEQ DEBUG
00000288  1639 00C00003            604mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000028E  0803 0002                605mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000292  67F4                     606mmm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00000294  13D8 00C00007            607mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000029A                           608mmm     ENDC
0000029A                           609mmm     
0000029A                 FALSE     610mmm     IFNE DEBUG
0000029A                           611mmm     ENDC
0000029A                           612mmm 
0000029A                           613mmm     ENDM
0000029A  60E4                     614mm     BRA LOOP_25
0000029C                           615mm EXIT_25
0000029C                           616mm     ENDM
0000029C  7A07                     617m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000029E                           618m LOOP_24
0000029E                           619mm     BIN2HEX D2,D4,A0
0000029E  41FA 0C5C                620mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
000002A2  E99A                     621mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002A4  1802                     622mm     MOVE.B D2,D4
000002A6  0284 0000000F            623mm     ANDI.L #$F,D4
000002AC  1830 4000                624mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
000002B0                           625mm     ENDM
000002B0                           626mm     PRINT_CHAR D4,D3
000002B0                           627mm WAIT_FOR_READY_28                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B0                 TRUE      628mm     IFEQ DEBUG
000002B0  1639 00C00003            629mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002B6  0803 0002                630mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002BA  67F4                     631mm         BEQ WAIT_FOR_READY_28                   ; NO SPACE, CHECK AGAIN
000002BC  13C4 00C00007            632mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002C2                           633mm     ENDC
000002C2                           634mm     
000002C2                 FALSE     635mm     IFNE DEBUG
000002C2                           636mm     ENDC
000002C2                           637mm 
000002C2                           638mm     ENDM
000002C2  57CD FFDA                639m     DBEQ D5,LOOP_24
000002C6                           640m     ENDM
000002C6                           641m     PRINT_CRLF D3,A0
000002C6  41FA 0C6F                642m     LEA CRLF(PC),A0
000002CA                           643mm     PRINT_STR A0,D3
000002CA                           644mm LOOP_30
000002CA  0C10 0000                645mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002CE  6700 0016                646mm     BEQ EXIT_30
000002D2                           647mmm     PRINT_CHAR (A0)+,D3
000002D2                           648mmm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D2                 TRUE      649mmm     IFEQ DEBUG
000002D2  1639 00C00003            650mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D8  0803 0002                651mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002DC  67F4                     652mmm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
000002DE  13D8 00C00007            653mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E4                           654mmm     ENDC
000002E4                           655mmm     
000002E4                 FALSE     656mmm     IFNE DEBUG
000002E4                           657mmm     ENDC
000002E4                           658mmm 
000002E4                           659mmm     ENDM
000002E4  60E4                     660mm     BRA LOOP_30
000002E6                           661mm EXIT_30
000002E6                           662mm     ENDM
000002E6                           663m     ENDM
000002E6  6000 FE6A                664      BRA MAIN_LOOP
000002EA                           665  
000002EA                           666  W
000002EA  3C3C 0007                667      MOVE #7,D6                                      ; 7 bytes left to read
000002EE                           668      
000002EE                           669  READ_DATA_TO_POKE
000002EE  E98D                     670      LSL.L #4,D5                                     ; make what we have so far more significant
000002F0                           671m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002F0                           672m WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      673m     IFEQ DEBUG
000002F0  1639 00C00003            674m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F6  0803 0000                675m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002FA  67F4                     676m         BEQ WAIT_FOR_READY_32                   ; NOTHING, CHECK AGAIN
000002FC                           677m     ENDC
000002FC                           678m     
000002FC                           679mm     READ_CHAR D2
000002FC                 TRUE      680mm     IFEQ DEBUG
000002FC  1439 00C00007            681mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000302                           682mm     ENDC
00000302                 FALSE     683mm     IFNE DEBUG
00000302                           684mm     ENDC
00000302                           685mm      
00000302  B43C 001B                686mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000306  6700 FD00                687mm     BEQ START
0000030A                           688mm     ENDM
0000030A                           689m 
0000030A                 TRUE      690m     IFEQ DEBUG
0000030A                           691mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000030A                           692mm WAIT_FOR_READY_34                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000030A                 TRUE      693mm     IFEQ DEBUG
0000030A  1639 00C00003            694mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000310  0803 0002                695mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000314  67F4                     696mm         BEQ WAIT_FOR_READY_34                   ; NO SPACE, CHECK AGAIN
00000316  13C2 00C00007            697mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000031C                           698mm     ENDC
0000031C                           699mm     
0000031C                 FALSE     700mm     IFNE DEBUG
0000031C                           701mm     ENDC
0000031C                           702mm 
0000031C                           703mm     ENDM
0000031C                           704m     ENDC
0000031C                           705m     ENDM
0000031C                           706m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0000031C  41FA 0BEE                707m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000320  0402 0030                708m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000324  C4BC 000000FF            709m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000032A  1430 2000                710m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
0000032E                           711m     ENDM
0000032E  8A02                     712      OR.B D2,D5
00000330  57CE FFBC                713      DBEQ D6,READ_DATA_TO_POKE
00000334                           714      
00000334  2047                     715      MOVE.L D7,A0                                    ; address accumulator -> address register
00000336  7E00                     716      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000338                           717      
00000338  2085                     718      MOVE.L D5,(A0)                                  ; write the data
0000033A                           719  
0000033A                           720m     PRINT_CRLF D3,A0
0000033A  41FA 0BFB                721m     LEA CRLF(PC),A0
0000033E                           722mm     PRINT_STR A0,D3
0000033E                           723mm LOOP_37
0000033E  0C10 0000                724mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000342  6700 0016                725mm     BEQ EXIT_37
00000346                           726mmm     PRINT_CHAR (A0)+,D3
00000346                           727mmm WAIT_FOR_READY_38                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000346                 TRUE      728mmm     IFEQ DEBUG
00000346  1639 00C00003            729mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000034C  0803 0002                730mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000350  67F4                     731mmm         BEQ WAIT_FOR_READY_38                   ; NO SPACE, CHECK AGAIN
00000352  13D8 00C00007            732mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000358                           733mmm     ENDC
00000358                           734mmm     
00000358                 FALSE     735mmm     IFNE DEBUG
00000358                           736mmm     ENDC
00000358                           737mmm 
00000358                           738mmm     ENDM
00000358  60E4                     739mm     BRA LOOP_37
0000035A                           740mm EXIT_37
0000035A                           741mm     ENDM
0000035A                           742m     ENDM
0000035A  6000 FDF6                743      BRA MAIN_LOOP
0000035E                           744  
0000035E                           745  ; register map for S
0000035E                           746  ; A0 - start address
0000035E                           747  ; A1 - offset
0000035E                           748  ; A2 - next address to write
0000035E                           749  ; A3 - next location (jmp)
0000035E                           750  ; A4 - Working Address Register
0000035E                           751  ; D0 - record count
0000035E                           752  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000035E                           753  ; D2 - checksum
0000035E                           754  ; D3 - data byte count
0000035E                           755  ; D4 - read address, moved into A2
0000035E                           756  ; D5 - temp
0000035E                           757  ; D6 - temp
0000035E                           758  ; D7 - temp
0000035E                           759  S
0000035E  2078 0000                760      MOVE.L 0,A0                                     ; start address -> A0
00000362  2247                     761      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000364                           762      
00000364  7000                     763      MOVE.L #0,D0                                    ; count of records read -> D0
00000366                           764          
00000366                           765  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000366                           766m     DOWNLOAD D1                 
00000366                           767m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000366                           768m 
00000366  1239 00C00003            769m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0000036C  0801 0000                770m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000370  6700 0010                771m     BEQ CONTINUE_39                             ; NOTHING, CONTINUE
00000374                           772m  
00000374                           773mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000374                 TRUE      774mm     IFEQ DEBUG
00000374  1239 00C00007            775mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000037A                           776mm     ENDC
0000037A                 FALSE     777mm     IFNE DEBUG
0000037A                           778mm     ENDC
0000037A                           779mm      
0000037A  B23C 001B                780mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0000037E  6700 FC88                781mm     BEQ START
00000382                           782mm     ENDM
00000382                           783m CONTINUE_39
00000382  1239 00C00013            784m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000388  0801 0000                785m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000038C  67D8                     786m     BEQ WAIT_FOR_READY_39                           ; NOTHING, CHECK AGAIN
0000038E                           787m     
0000038E  1239 00C00017            788m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000394  13C1 00E00001            789m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000039A                           790m     
0000039A                           791m     ENDM
0000039A  B23C 0053                792      CMP.B #'S',D1                                   ; found S?    
0000039E  66C6                     793      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003A0                           794      
000003A0                           795m     PRINT_CHAR #'S',D5                            ; print the S
000003A0                           796m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A0                 TRUE      797m     IFEQ DEBUG
000003A0  1A39 00C00003            798m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003A6  0805 0002                799m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003AA  67F4                     800m         BEQ WAIT_FOR_READY_41                   ; NO SPACE, CHECK AGAIN
000003AC  13FC 0053 00C00007       801m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003B4                           802m     ENDC
000003B4                           803m     
000003B4                 FALSE     804m     IFNE DEBUG
000003B4                           805m     ENDC
000003B4                           806m 
000003B4                           807m     ENDM
000003B4  5280                     808      ADD.L #1,D0                                     ; read another S record, increment count
000003B6                           809      
000003B6                           810m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003B6                           811m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B6                           812m 
000003B6  1239 00C00003            813m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003BC  0801 0000                814m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003C0  6700 0010                815m     BEQ CONTINUE_42                             ; NOTHING, CONTINUE
000003C4                           816m  
000003C4                           817mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003C4                 TRUE      818mm     IFEQ DEBUG
000003C4  1239 00C00007            819mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003CA                           820mm     ENDC
000003CA                 FALSE     821mm     IFNE DEBUG
000003CA                           822mm     ENDC
000003CA                           823mm      
000003CA  B23C 001B                824mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003CE  6700 FC38                825mm     BEQ START
000003D2                           826mm     ENDM
000003D2                           827m CONTINUE_42
000003D2  1239 00C00013            828m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003D8  0801 0000                829m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003DC  67D8                     830m     BEQ WAIT_FOR_READY_42                           ; NOTHING, CHECK AGAIN
000003DE                           831m     
000003DE  1239 00C00017            832m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003E4  13C1 00E00001            833m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003EA                           834m     
000003EA                           835m     ENDM
000003EA                           836m     PRINT_CHAR D1,D5
000003EA                           837m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EA                 TRUE      838m     IFEQ DEBUG
000003EA  1A39 00C00003            839m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003F0  0805 0002                840m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003F4  67F4                     841m         BEQ WAIT_FOR_READY_44                   ; NO SPACE, CHECK AGAIN
000003F6  13C1 00C00007            842m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003FC                           843m     ENDC
000003FC                           844m     
000003FC                 FALSE     845m     IFNE DEBUG
000003FC                           846m     ENDC
000003FC                           847m 
000003FC                           848m     ENDM
000003FC                           849  
000003FC  7400                     850      MOVE.L #0,D2                                    ; clear the checksum
000003FE                           851  
000003FE                           852m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003FE  1E3C 0002                853m     MOVE.B #2,D7
00000402                           854m     WHILE.B D7 <GT> 0 DO
00000402                           855ms _10000000
00000402  BE38 0000                856ms     CMP.B   0,D7
00000406  6F00 0062                857ms     BLE _10000001
0000040A  E98B                     858m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
0000040C                           859mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000040C                           860mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040C                           861mm 
0000040C  1A39 00C00003            862mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000412  0805 0000                863mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000416  6700 0010                864mm     BEQ CONTINUE_46                             ; NOTHING, CONTINUE
0000041A                           865mm  
0000041A                           866mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000041A                 TRUE      867mmm     IFEQ DEBUG
0000041A  1A39 00C00007            868mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000420                           869mmm     ENDC
00000420                 FALSE     870mmm     IFNE DEBUG
00000420                           871mmm     ENDC
00000420                           872mmm      
00000420  BA3C 001B                873mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000424  6700 FBE2                874mmm     BEQ START
00000428                           875mmm     ENDM
00000428                           876mm CONTINUE_46
00000428  1A39 00C00013            877mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000042E  0805 0000                878mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000432  67D8                     879mm     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
00000434                           880mm     
00000434  1A39 00C00017            881mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000043A  13C5 00E00001            882mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000440                           883mm     
00000440                           884mm     ENDM
00000440                           885mm         PRINT_CHAR D5,D6
00000440                           886mm WAIT_FOR_READY_48                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000440                 TRUE      887mm     IFEQ DEBUG
00000440  1C39 00C00003            888mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000446  0806 0002                889mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000044A  67F4                     890mm         BEQ WAIT_FOR_READY_48                   ; NO SPACE, CHECK AGAIN
0000044C  13C5 00C00007            891mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000452                           892mm     ENDC
00000452                           893mm     
00000452                 FALSE     894mm     IFNE DEBUG
00000452                           895mm     ENDC
00000452                           896mm 
00000452                           897mm     ENDM
00000452                           898mm         HEX2BIN D5,D5,A4
00000452  49FA 0AB8                899mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000456  0405 0030                900mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000045A  CABC 000000FF            901mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000460  1A34 5000                902mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000464                           903mm     ENDM
00000464  8605                     904m         OR.B D5,D3
00000466  5307                     905m         SUB.B #1,D7
00000468                           906m     ENDW
00000468  6098                     907ms     BRA _10000000
0000046A                           908ms _10000001
0000046A                           909m     
0000046A  7A00                     910m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000046C  1A03                     911m     MOVE.B D3,D5
0000046E  D483                     912m     ADD.L D3,D2
00000470                           913m 
00000470                           914m     ENDM
00000470                           915  
00000470                           916      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000470  B23C 0030                917s     CMP.B   #'0',D1
00000474  6600 002A                918s     BNE.L   _00000002
00000478                           919m         PRINT_CRLF D5,A4
00000478  49FA 0ABD                920m     LEA CRLF(PC),A4
0000047C                           921mm     PRINT_STR A4,D5
0000047C                           922mm LOOP_51
0000047C  0C14 0000                923mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000480  6700 0016                924mm     BEQ EXIT_51
00000484                           925mmm     PRINT_CHAR (A4)+,D5
00000484                           926mmm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000484                 TRUE      927mmm     IFEQ DEBUG
00000484  1A39 00C00003            928mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000048A  0805 0002                929mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000048E  67F4                     930mmm         BEQ WAIT_FOR_READY_52                   ; NO SPACE, CHECK AGAIN
00000490  13DC 00C00007            931mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000496                           932mmm     ENDC
00000496                           933mmm     
00000496                 FALSE     934mmm     IFNE DEBUG
00000496                           935mmm     ENDC
00000496                           936mmm 
00000496                           937mmm     ENDM
00000496  60E4                     938mm     BRA LOOP_51
00000498                           939mm EXIT_51
00000498                           940mm     ENDM
00000498                           941m     ENDM
00000498  6000 FECC                942          BRA WAIT_FOR_SRECORD
0000049C                           943      ELSE
0000049C  6000 03DE                944s     BRA _00000003
000004A0                           945s _00000002
000004A0                           946          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000004A0  B23C 0031                947s     CMP.B   #'1',D1
000004A4  6708                     948s     BEQ.S   _00000004
000004A6  B23C 0032                949s     CMP.B   #'2',D1
000004AA  6600 01F0                950s     BNE.L   _00000005
000004AE                           951s _00000004
000004AE  5783                     952              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004B0                           953      
000004B0  7800                     954              MOVE.L #0,D4                            ; read two bytes of address
000004B2                           955m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004B2  1E3C 0002                956m     MOVE.B #2,D7
000004B6                           957m     WHILE.B D7 <GT> 0 DO
000004B6                           958ms _10000002
000004B6  BE38 0000                959ms     CMP.B   0,D7
000004BA  6F00 0062                960ms     BLE _10000003
000004BE  E98C                     961m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004C0                           962mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004C0                           963mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                           964mm 
000004C0  1A39 00C00003            965mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004C6  0805 0000                966mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004CA  6700 0010                967mm     BEQ CONTINUE_54                             ; NOTHING, CONTINUE
000004CE                           968mm  
000004CE                           969mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004CE                 TRUE      970mmm     IFEQ DEBUG
000004CE  1A39 00C00007            971mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004D4                           972mmm     ENDC
000004D4                 FALSE     973mmm     IFNE DEBUG
000004D4                           974mmm     ENDC
000004D4                           975mmm      
000004D4  BA3C 001B                976mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004D8  6700 FB2E                977mmm     BEQ START
000004DC                           978mmm     ENDM
000004DC                           979mm CONTINUE_54
000004DC  1A39 00C00013            980mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004E2  0805 0000                981mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004E6  67D8                     982mm     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000004E8                           983mm     
000004E8  1A39 00C00017            984mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004EE  13C5 00E00001            985mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004F4                           986mm     
000004F4                           987mm     ENDM
000004F4                           988mm         PRINT_CHAR D5,D6
000004F4                           989mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F4                 TRUE      990mm     IFEQ DEBUG
000004F4  1C39 00C00003            991mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004FA  0806 0002                992mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004FE  67F4                     993mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
00000500  13C5 00C00007            994mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000506                           995mm     ENDC
00000506                           996mm     
00000506                 FALSE     997mm     IFNE DEBUG
00000506                           998mm     ENDC
00000506                           999mm 
00000506                          1000mm     ENDM
00000506                          1001mm         HEX2BIN D5,D5,A4
00000506  49FA 0A04               1002mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000050A  0405 0030               1003mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000050E  CABC 000000FF           1004mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000514  1A34 5000               1005mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000518                          1006mm     ENDM
00000518  8805                    1007m         OR.B D5,D4
0000051A  5307                    1008m         SUB.B #1,D7
0000051C                          1009m     ENDW
0000051C  6098                    1010ms     BRA _10000002
0000051E                          1011ms _10000003
0000051E                          1012m     
0000051E  7A00                    1013m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000520  1A04                    1014m     MOVE.B D4,D5
00000522  D484                    1015m     ADD.L D4,D2
00000524                          1016m 
00000524                          1017m     ENDM
00000524                          1018m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000524  1E3C 0002               1019m     MOVE.B #2,D7
00000528                          1020m     WHILE.B D7 <GT> 0 DO
00000528                          1021ms _10000004
00000528  BE38 0000               1022ms     CMP.B   0,D7
0000052C  6F00 0062               1023ms     BLE _10000005
00000530  E98C                    1024m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000532                          1025mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000532                          1026mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000532                          1027mm 
00000532  1A39 00C00003           1028mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000538  0805 0000               1029mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000053C  6700 0010               1030mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
00000540                          1031mm  
00000540                          1032mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000540                 TRUE     1033mmm     IFEQ DEBUG
00000540  1A39 00C00007           1034mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000546                          1035mmm     ENDC
00000546                 FALSE    1036mmm     IFNE DEBUG
00000546                          1037mmm     ENDC
00000546                          1038mmm      
00000546  BA3C 001B               1039mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000054A  6700 FABC               1040mmm     BEQ START
0000054E                          1041mmm     ENDM
0000054E                          1042mm CONTINUE_59
0000054E  1A39 00C00013           1043mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000554  0805 0000               1044mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000558  67D8                    1045mm     BEQ WAIT_FOR_READY_59                           ; NOTHING, CHECK AGAIN
0000055A                          1046mm     
0000055A  1A39 00C00017           1047mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000560  13C5 00E00001           1048mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000566                          1049mm     
00000566                          1050mm     ENDM
00000566                          1051mm         PRINT_CHAR D5,D6
00000566                          1052mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000566                 TRUE     1053mm     IFEQ DEBUG
00000566  1C39 00C00003           1054mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000056C  0806 0002               1055mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000570  67F4                    1056mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
00000572  13C5 00C00007           1057mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000578                          1058mm     ENDC
00000578                          1059mm     
00000578                 FALSE    1060mm     IFNE DEBUG
00000578                          1061mm     ENDC
00000578                          1062mm 
00000578                          1063mm     ENDM
00000578                          1064mm         HEX2BIN D5,D5,A4
00000578  49FA 0992               1065mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000057C  0405 0030               1066mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000580  CABC 000000FF           1067mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000586  1A34 5000               1068mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000058A                          1069mm     ENDM
0000058A  8805                    1070m         OR.B D5,D4
0000058C  5307                    1071m         SUB.B #1,D7
0000058E                          1072m     ENDW
0000058E  6098                    1073ms     BRA _10000004
00000590                          1074ms _10000005
00000590                          1075m     
00000590  7A00                    1076m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000592  1A04                    1077m     MOVE.B D4,D5
00000594  D484                    1078m     ADD.L D4,D2
00000596                          1079m 
00000596                          1080m     ENDM
00000596                          1081              
00000596                          1082              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000596  B23C 0032               1083s     CMP.B   #'2',D1
0000059A  6600 0076               1084s     BNE.L   _00000006
0000059E  5383                    1085                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005A0                          1086m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005A0  1E3C 0002               1087m     MOVE.B #2,D7
000005A4                          1088m     WHILE.B D7 <GT> 0 DO
000005A4                          1089ms _10000006
000005A4  BE38 0000               1090ms     CMP.B   0,D7
000005A8  6F00 0062               1091ms     BLE _10000007
000005AC  E98C                    1092m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005AE                          1093mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005AE                          1094mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005AE                          1095mm 
000005AE  1A39 00C00003           1096mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005B4  0805 0000               1097mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005B8  6700 0010               1098mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
000005BC                          1099mm  
000005BC                          1100mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005BC                 TRUE     1101mmm     IFEQ DEBUG
000005BC  1A39 00C00007           1102mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005C2                          1103mmm     ENDC
000005C2                 FALSE    1104mmm     IFNE DEBUG
000005C2                          1105mmm     ENDC
000005C2                          1106mmm      
000005C2  BA3C 001B               1107mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005C6  6700 FA40               1108mmm     BEQ START
000005CA                          1109mmm     ENDM
000005CA                          1110mm CONTINUE_64
000005CA  1A39 00C00013           1111mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005D0  0805 0000               1112mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D4  67D8                    1113mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
000005D6                          1114mm     
000005D6  1A39 00C00017           1115mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005DC  13C5 00E00001           1116mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005E2                          1117mm     
000005E2                          1118mm     ENDM
000005E2                          1119mm         PRINT_CHAR D5,D6
000005E2                          1120mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1121mm     IFEQ DEBUG
000005E2  1C39 00C00003           1122mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005E8  0806 0002               1123mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1124mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
000005EE  13C5 00C00007           1125mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005F4                          1126mm     ENDC
000005F4                          1127mm     
000005F4                 FALSE    1128mm     IFNE DEBUG
000005F4                          1129mm     ENDC
000005F4                          1130mm 
000005F4                          1131mm     ENDM
000005F4                          1132mm         HEX2BIN D5,D5,A4
000005F4  49FA 0916               1133mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005F8  0405 0030               1134mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005FC  CABC 000000FF           1135mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000602  1A34 5000               1136mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000606                          1137mm     ENDM
00000606  8805                    1138m         OR.B D5,D4
00000608  5307                    1139m         SUB.B #1,D7
0000060A                          1140m     ENDW
0000060A  6098                    1141ms     BRA _10000006
0000060C                          1142ms _10000007
0000060C                          1143m     
0000060C  7A00                    1144m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000060E  1A04                    1145m     MOVE.B D4,D5
00000610  D484                    1146m     ADD.L D4,D2
00000612                          1147m 
00000612                          1148m     ENDM
00000612                          1149              ENDI
00000612                          1150s _00000006
00000612                          1151              
00000612  2444                    1152                  MOVE.L D4,A2                            ; put the address in an address register
00000614  D5C9                    1153              ADD.L A1,A2                             ; add in the offset
00000616                          1154  
00000616                          1155              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
00000616                          1156s _10000008
00000616  B63C 0000               1157s     CMP.B   #0,D3
0000061A  6F00 007A               1158s     BLE _10000009
0000061E                          1159m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
0000061E  1E3C 0002               1160m     MOVE.B #2,D7
00000622                          1161m     WHILE.B D7 <GT> 0 DO
00000622                          1162ms _1000000A
00000622  BE38 0000               1163ms     CMP.B   0,D7
00000626  6F00 0062               1164ms     BLE _1000000B
0000062A  E989                    1165m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
0000062C                          1166mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000062C                          1167mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062C                          1168mm 
0000062C  1A39 00C00003           1169mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000632  0805 0000               1170mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000636  6700 0010               1171mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
0000063A                          1172mm  
0000063A                          1173mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000063A                 TRUE     1174mmm     IFEQ DEBUG
0000063A  1A39 00C00007           1175mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000640                          1176mmm     ENDC
00000640                 FALSE    1177mmm     IFNE DEBUG
00000640                          1178mmm     ENDC
00000640                          1179mmm      
00000640  BA3C 001B               1180mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000644  6700 F9C2               1181mmm     BEQ START
00000648                          1182mmm     ENDM
00000648                          1183mm CONTINUE_69
00000648  1A39 00C00013           1184mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000064E  0805 0000               1185mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000652  67D8                    1186mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000654                          1187mm     
00000654  1A39 00C00017           1188mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000065A  13C5 00E00001           1189mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000660                          1190mm     
00000660                          1191mm     ENDM
00000660                          1192mm         PRINT_CHAR D5,D6
00000660                          1193mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000660                 TRUE     1194mm     IFEQ DEBUG
00000660  1C39 00C00003           1195mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000666  0806 0002               1196mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000066A  67F4                    1197mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
0000066C  13C5 00C00007           1198mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000672                          1199mm     ENDC
00000672                          1200mm     
00000672                 FALSE    1201mm     IFNE DEBUG
00000672                          1202mm     ENDC
00000672                          1203mm 
00000672                          1204mm     ENDM
00000672                          1205mm         HEX2BIN D5,D5,A4
00000672  49FA 0898               1206mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000676  0405 0030               1207mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000067A  CABC 000000FF           1208mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000680  1A34 5000               1209mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000684                          1210mm     ENDM
00000684  8205                    1211m         OR.B D5,D1
00000686  5307                    1212m         SUB.B #1,D7
00000688                          1213m     ENDW
00000688  6098                    1214ms     BRA _1000000A
0000068A                          1215ms _1000000B
0000068A                          1216m     
0000068A  7A00                    1217m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000068C  1A01                    1218m     MOVE.B D1,D5
0000068E  D481                    1219m     ADD.L D1,D2
00000690                          1220m 
00000690                          1221m     ENDM
00000690                          1222                          
00000690  14C1                    1223                  MOVE.B D1,(A2)+                     ; store it!
00000692                          1224  
00000692  5303                    1225                  SUB.B #1,D3                      ; 1 less byte to go
00000694                          1226              ENDW
00000694  6080                    1227s     BRA _10000008
00000696                          1228s _10000009
00000696                          1229          
00000696  7200                    1230              MOVE.L #0,D1                         ; not done yet
00000698                          1231          ELSE
00000698  6000 01E2               1232s     BRA _00000007
0000069C                          1233s _00000005
0000069C                          1234              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000069C  B23C 0038               1235s     CMP.B   #'8',D1
000006A0  6600 0164               1236s     BNE.L   _00000008
000006A4  7800                    1237                  MOVE.L #0,D4                    ; read the 24 bit start address
000006A6                          1238m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006A6  1E3C 0002               1239m     MOVE.B #2,D7
000006AA                          1240m     WHILE.B D7 <GT> 0 DO
000006AA                          1241ms _1000000C
000006AA  BE38 0000               1242ms     CMP.B   0,D7
000006AE  6F00 0062               1243ms     BLE _1000000D
000006B2  E98C                    1244m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006B4                          1245mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006B4                          1246mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006B4                          1247mm 
000006B4  1A39 00C00003           1248mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006BA  0805 0000               1249mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006BE  6700 0010               1250mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
000006C2                          1251mm  
000006C2                          1252mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006C2                 TRUE     1253mmm     IFEQ DEBUG
000006C2  1A39 00C00007           1254mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006C8                          1255mmm     ENDC
000006C8                 FALSE    1256mmm     IFNE DEBUG
000006C8                          1257mmm     ENDC
000006C8                          1258mmm      
000006C8  BA3C 001B               1259mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006CC  6700 F93A               1260mmm     BEQ START
000006D0                          1261mmm     ENDM
000006D0                          1262mm CONTINUE_74
000006D0  1A39 00C00013           1263mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006D6  0805 0000               1264mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DA  67D8                    1265mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000006DC                          1266mm     
000006DC  1A39 00C00017           1267mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006E2  13C5 00E00001           1268mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006E8                          1269mm     
000006E8                          1270mm     ENDM
000006E8                          1271mm         PRINT_CHAR D5,D6
000006E8                          1272mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E8                 TRUE     1273mm     IFEQ DEBUG
000006E8  1C39 00C00003           1274mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006EE  0806 0002               1275mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006F2  67F4                    1276mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
000006F4  13C5 00C00007           1277mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006FA                          1278mm     ENDC
000006FA                          1279mm     
000006FA                 FALSE    1280mm     IFNE DEBUG
000006FA                          1281mm     ENDC
000006FA                          1282mm 
000006FA                          1283mm     ENDM
000006FA                          1284mm         HEX2BIN D5,D5,A4
000006FA  49FA 0810               1285mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006FE  0405 0030               1286mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000702  CABC 000000FF           1287mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000708  1A34 5000               1288mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000070C                          1289mm     ENDM
0000070C  8805                    1290m         OR.B D5,D4
0000070E  5307                    1291m         SUB.B #1,D7
00000710                          1292m     ENDW
00000710  6098                    1293ms     BRA _1000000C
00000712                          1294ms _1000000D
00000712                          1295m     
00000712  7A00                    1296m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000714  1A04                    1297m     MOVE.B D4,D5
00000716  D484                    1298m     ADD.L D4,D2
00000718                          1299m 
00000718                          1300m     ENDM
00000718                          1301m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000718  1E3C 0002               1302m     MOVE.B #2,D7
0000071C                          1303m     WHILE.B D7 <GT> 0 DO
0000071C                          1304ms _1000000E
0000071C  BE38 0000               1305ms     CMP.B   0,D7
00000720  6F00 0062               1306ms     BLE _1000000F
00000724  E98C                    1307m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000726                          1308mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000726                          1309mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000726                          1310mm 
00000726  1A39 00C00003           1311mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000072C  0805 0000               1312mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000730  6700 0010               1313mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
00000734                          1314mm  
00000734                          1315mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000734                 TRUE     1316mmm     IFEQ DEBUG
00000734  1A39 00C00007           1317mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000073A                          1318mmm     ENDC
0000073A                 FALSE    1319mmm     IFNE DEBUG
0000073A                          1320mmm     ENDC
0000073A                          1321mmm      
0000073A  BA3C 001B               1322mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000073E  6700 F8C8               1323mmm     BEQ START
00000742                          1324mmm     ENDM
00000742                          1325mm CONTINUE_79
00000742  1A39 00C00013           1326mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000748  0805 0000               1327mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000074C  67D8                    1328mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
0000074E                          1329mm     
0000074E  1A39 00C00017           1330mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000754  13C5 00E00001           1331mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000075A                          1332mm     
0000075A                          1333mm     ENDM
0000075A                          1334mm         PRINT_CHAR D5,D6
0000075A                          1335mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000075A                 TRUE     1336mm     IFEQ DEBUG
0000075A  1C39 00C00003           1337mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000760  0806 0002               1338mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000764  67F4                    1339mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00000766  13C5 00C00007           1340mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000076C                          1341mm     ENDC
0000076C                          1342mm     
0000076C                 FALSE    1343mm     IFNE DEBUG
0000076C                          1344mm     ENDC
0000076C                          1345mm 
0000076C                          1346mm     ENDM
0000076C                          1347mm         HEX2BIN D5,D5,A4
0000076C  49FA 079E               1348mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000770  0405 0030               1349mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000774  CABC 000000FF           1350mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000077A  1A34 5000               1351mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000077E                          1352mm     ENDM
0000077E  8805                    1353m         OR.B D5,D4
00000780  5307                    1354m         SUB.B #1,D7
00000782                          1355m     ENDW
00000782  6098                    1356ms     BRA _1000000E
00000784                          1357ms _1000000F
00000784                          1358m     
00000784  7A00                    1359m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000786  1A04                    1360m     MOVE.B D4,D5
00000788  D484                    1361m     ADD.L D4,D2
0000078A                          1362m 
0000078A                          1363m     ENDM
0000078A                          1364m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
0000078A  1E3C 0002               1365m     MOVE.B #2,D7
0000078E                          1366m     WHILE.B D7 <GT> 0 DO
0000078E                          1367ms _10000010
0000078E  BE38 0000               1368ms     CMP.B   0,D7
00000792  6F00 0062               1369ms     BLE _10000011
00000796  E98C                    1370m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000798                          1371mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000798                          1372mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                          1373mm 
00000798  1A39 00C00003           1374mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000079E  0805 0000               1375mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007A2  6700 0010               1376mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
000007A6                          1377mm  
000007A6                          1378mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007A6                 TRUE     1379mmm     IFEQ DEBUG
000007A6  1A39 00C00007           1380mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007AC                          1381mmm     ENDC
000007AC                 FALSE    1382mmm     IFNE DEBUG
000007AC                          1383mmm     ENDC
000007AC                          1384mmm      
000007AC  BA3C 001B               1385mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007B0  6700 F856               1386mmm     BEQ START
000007B4                          1387mmm     ENDM
000007B4                          1388mm CONTINUE_84
000007B4  1A39 00C00013           1389mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007BA  0805 0000               1390mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007BE  67D8                    1391mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000007C0                          1392mm     
000007C0  1A39 00C00017           1393mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007C6  13C5 00E00001           1394mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007CC                          1395mm     
000007CC                          1396mm     ENDM
000007CC                          1397mm         PRINT_CHAR D5,D6
000007CC                          1398mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CC                 TRUE     1399mm     IFEQ DEBUG
000007CC  1C39 00C00003           1400mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007D2  0806 0002               1401mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007D6  67F4                    1402mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
000007D8  13C5 00C00007           1403mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007DE                          1404mm     ENDC
000007DE                          1405mm     
000007DE                 FALSE    1406mm     IFNE DEBUG
000007DE                          1407mm     ENDC
000007DE                          1408mm 
000007DE                          1409mm     ENDM
000007DE                          1410mm         HEX2BIN D5,D5,A4
000007DE  49FA 072C               1411mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007E2  0405 0030               1412mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007E6  CABC 000000FF           1413mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007EC  1A34 5000               1414mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007F0                          1415mm     ENDM
000007F0  8805                    1416m         OR.B D5,D4
000007F2  5307                    1417m         SUB.B #1,D7
000007F4                          1418m     ENDW
000007F4  6098                    1419ms     BRA _10000010
000007F6                          1420ms _10000011
000007F6                          1421m     
000007F6  7A00                    1422m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007F8  1A04                    1423m     MOVE.B D4,D5
000007FA  D484                    1424m     ADD.L D4,D2
000007FC                          1425m 
000007FC                          1426m     ENDM
000007FC                          1427                            
000007FC  2044                    1428                  MOVE.L D4,A0                    ; start address -> A0
000007FE  D1C9                    1429                  ADD.L A1,A0                         ; add in the offset
00000800                          1430  
00000800  72FF                    1431                  MOVE.L #$FFFFFFFF,D1             ; done
00000802                          1432              ELSE
00000802  6000 0078               1433s     BRA _00000009
00000806                          1434s _00000008
00000806                          1435m                 PRINT_CRLF D5,A4
00000806  49FA 072F               1436m     LEA CRLF(PC),A4
0000080A                          1437mm     PRINT_STR A4,D5
0000080A                          1438mm LOOP_89
0000080A  0C14 0000               1439mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000080E  6700 0016               1440mm     BEQ EXIT_89
00000812                          1441mmm     PRINT_CHAR (A4)+,D5
00000812                          1442mmm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000812                 TRUE     1443mmm     IFEQ DEBUG
00000812  1A39 00C00003           1444mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000818  0805 0002               1445mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000081C  67F4                    1446mmm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
0000081E  13DC 00C00007           1447mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000824                          1448mmm     ENDC
00000824                          1449mmm     
00000824                 FALSE    1450mmm     IFNE DEBUG
00000824                          1451mmm     ENDC
00000824                          1452mmm 
00000824                          1453mmm     ENDM
00000824  60E4                    1454mm     BRA LOOP_89
00000826                          1455mm EXIT_89
00000826                          1456mm     ENDM
00000826                          1457m     ENDM
00000826                          1458              
00000826  49FA 0699               1459                  LEA UNREC(PC),A4                ; warn for unrecognised type
0000082A                          1460m                 PRINT_STR A4,D5
0000082A                          1461m LOOP_91
0000082A  0C14 0000               1462m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000082E  6700 0016               1463m     BEQ EXIT_91
00000832                          1464mm     PRINT_CHAR (A4)+,D5
00000832                          1465mm WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000832                 TRUE     1466mm     IFEQ DEBUG
00000832  1A39 00C00003           1467mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000838  0805 0002               1468mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000083C  67F4                    1469mm         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
0000083E  13DC 00C00007           1470mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000844                          1471mm     ENDC
00000844                          1472mm     
00000844                 FALSE    1473mm     IFNE DEBUG
00000844                          1474mm     ENDC
00000844                          1475mm 
00000844                          1476mm     ENDM
00000844  60E4                    1477m     BRA LOOP_91
00000846                          1478m EXIT_91
00000846                          1479m     ENDM
00000846                          1480m                 PRINT_CHAR D1,D5
00000846                          1481m WAIT_FOR_READY_93                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000846                 TRUE     1482m     IFEQ DEBUG
00000846  1A39 00C00003           1483m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000084C  0805 0002               1484m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000850  67F4                    1485m         BEQ WAIT_FOR_READY_93                   ; NO SPACE, CHECK AGAIN
00000852  13C1 00C00007           1486m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000858                          1487m     ENDC
00000858                          1488m     
00000858                 FALSE    1489m     IFNE DEBUG
00000858                          1490m     ENDC
00000858                          1491m 
00000858                          1492m     ENDM
00000858                          1493m                 PRINT_CRLF D5,A4
00000858  49FA 06DD               1494m     LEA CRLF(PC),A4
0000085C                          1495mm     PRINT_STR A4,D5
0000085C                          1496mm LOOP_95
0000085C  0C14 0000               1497mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000860  6700 0016               1498mm     BEQ EXIT_95
00000864                          1499mmm     PRINT_CHAR (A4)+,D5
00000864                          1500mmm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000864                 TRUE     1501mmm     IFEQ DEBUG
00000864  1A39 00C00003           1502mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000086A  0805 0002               1503mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000086E  67F4                    1504mmm         BEQ WAIT_FOR_READY_96                   ; NO SPACE, CHECK AGAIN
00000870  13DC 00C00007           1505mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000876                          1506mmm     ENDC
00000876                          1507mmm     
00000876                 FALSE    1508mmm     IFNE DEBUG
00000876                          1509mmm     ENDC
00000876                          1510mmm 
00000876                          1511mmm     ENDM
00000876  60E4                    1512mm     BRA LOOP_95
00000878                          1513mm EXIT_95
00000878                          1514mm     ENDM
00000878                          1515m     ENDM
00000878                          1516              
00000878  6000 FAEC               1517                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0000087C                          1518              ENDI
0000087C                          1519s _00000009
0000087C                          1520          ENDI
0000087C                          1521s _00000007
0000087C                          1522      ENDI
0000087C                          1523s _00000003
0000087C                          1524      
0000087C                          1525m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0000087C  1E3C 0002               1526m     MOVE.B #2,D7
00000880                          1527m     WHILE.B D7 <GT> 0 DO
00000880                          1528ms _10000012
00000880  BE38 0000               1529ms     CMP.B   0,D7
00000884  6F00 0062               1530ms     BLE _10000013
00000888  E98C                    1531m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000088A                          1532mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088A                          1533mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088A                          1534mm 
0000088A  1A39 00C00003           1535mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000890  0805 0000               1536mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000894  6700 0010               1537mm     BEQ CONTINUE_98                             ; NOTHING, CONTINUE
00000898                          1538mm  
00000898                          1539mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000898                 TRUE     1540mmm     IFEQ DEBUG
00000898  1A39 00C00007           1541mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000089E                          1542mmm     ENDC
0000089E                 FALSE    1543mmm     IFNE DEBUG
0000089E                          1544mmm     ENDC
0000089E                          1545mmm      
0000089E  BA3C 001B               1546mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008A2  6700 F764               1547mmm     BEQ START
000008A6                          1548mmm     ENDM
000008A6                          1549mm CONTINUE_98
000008A6  1A39 00C00013           1550mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008AC  0805 0000               1551mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008B0  67D8                    1552mm     BEQ WAIT_FOR_READY_98                           ; NOTHING, CHECK AGAIN
000008B2                          1553mm     
000008B2  1A39 00C00017           1554mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008B8  13C5 00E00001           1555mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008BE                          1556mm     
000008BE                          1557mm     ENDM
000008BE                          1558mm         PRINT_CHAR D5,D6
000008BE                          1559mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BE                 TRUE     1560mm     IFEQ DEBUG
000008BE  1C39 00C00003           1561mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008C4  0806 0002               1562mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008C8  67F4                    1563mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000008CA  13C5 00C00007           1564mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008D0                          1565mm     ENDC
000008D0                          1566mm     
000008D0                 FALSE    1567mm     IFNE DEBUG
000008D0                          1568mm     ENDC
000008D0                          1569mm 
000008D0                          1570mm     ENDM
000008D0                          1571mm         HEX2BIN D5,D5,A4
000008D0  49FA 063A               1572mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008D4  0405 0030               1573mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D8  CABC 000000FF           1574mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008DE  1A34 5000               1575mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008E2                          1576mm     ENDM
000008E2  8805                    1577m         OR.B D5,D4
000008E4  5307                    1578m         SUB.B #1,D7
000008E6                          1579m     ENDW
000008E6  6098                    1580ms     BRA _10000012
000008E8                          1581ms _10000013
000008E8                          1582m     
000008E8  7A00                    1583m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008EA  1A04                    1584m     MOVE.B D4,D5
000008EC  D484                    1585m     ADD.L D4,D2
000008EE                          1586m 
000008EE                          1587m     ENDM
000008EE                          1588m     PRINT_CRLF D5,A4
000008EE  49FA 0647               1589m     LEA CRLF(PC),A4
000008F2                          1590mm     PRINT_STR A4,D5
000008F2                          1591mm LOOP_103
000008F2  0C14 0000               1592mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008F6  6700 0016               1593mm     BEQ EXIT_103
000008FA                          1594mmm     PRINT_CHAR (A4)+,D5
000008FA                          1595mmm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008FA                 TRUE     1596mmm     IFEQ DEBUG
000008FA  1A39 00C00003           1597mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000900  0805 0002               1598mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000904  67F4                    1599mmm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
00000906  13DC 00C00007           1600mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000090C                          1601mmm     ENDC
0000090C                          1602mmm     
0000090C                 FALSE    1603mmm     IFNE DEBUG
0000090C                          1604mmm     ENDC
0000090C                          1605mmm 
0000090C                          1606mmm     ENDM
0000090C  60E4                    1607mm     BRA LOOP_103
0000090E                          1608mm EXIT_103
0000090E                          1609mm     ENDM
0000090E                          1610m     ENDM
0000090E                          1611          
0000090E                          1612      IF.B D2 <NE> #$FF THEN.L
0000090E  B43C 00FF               1613s     CMP.B   #$FF,D2
00000912  6700 0090               1614s     BEQ.L   _0000000A
00000916  49FA 05C0               1615          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
0000091A                          1616m         PRINT_STR A4,D5
0000091A                          1617m LOOP_105
0000091A  0C14 0000               1618m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000091E  6700 0016               1619m     BEQ EXIT_105
00000922                          1620mm     PRINT_CHAR (A4)+,D5
00000922                          1621mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000922                 TRUE     1622mm     IFEQ DEBUG
00000922  1A39 00C00003           1623mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000928  0805 0002               1624mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000092C  67F4                    1625mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
0000092E  13DC 00C00007           1626mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000934                          1627mm     ENDC
00000934                          1628mm     
00000934                 FALSE    1629mm     IFNE DEBUG
00000934                          1630mm     ENDC
00000934                          1631mm 
00000934                          1632mm     ENDM
00000934  60E4                    1633m     BRA LOOP_105
00000936                          1634m EXIT_105
00000936                          1635m     ENDM
00000936                          1636m         PRINT_REG D0,D5,D2,D6,A4
00000936  49FA 0605               1637m     LEA OX(PC),A4
0000093A                          1638mm     PRINT_STR A4,D5
0000093A                          1639mm LOOP_108
0000093A  0C14 0000               1640mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000093E  6700 0016               1641mm     BEQ EXIT_108
00000942                          1642mmm     PRINT_CHAR (A4)+,D5
00000942                          1643mmm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000942                 TRUE     1644mmm     IFEQ DEBUG
00000942  1A39 00C00003           1645mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000948  0805 0002               1646mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000094C  67F4                    1647mmm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
0000094E  13DC 00C00007           1648mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000954                          1649mmm     ENDC
00000954                          1650mmm     
00000954                 FALSE    1651mmm     IFNE DEBUG
00000954                          1652mmm     ENDC
00000954                          1653mmm 
00000954                          1654mmm     ENDM
00000954  60E4                    1655mm     BRA LOOP_108
00000956                          1656mm EXIT_108
00000956                          1657mm     ENDM
00000956  7C07                    1658m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000958                          1659m LOOP_107
00000958                          1660mm     BIN2HEX D0,D2,A4
00000958  49FA 05A2               1661mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
0000095C  E998                    1662mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000095E  1400                    1663mm     MOVE.B D0,D2
00000960  0282 0000000F           1664mm     ANDI.L #$F,D2
00000966  1434 2000               1665mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000096A                          1666mm     ENDM
0000096A                          1667mm     PRINT_CHAR D2,D5
0000096A                          1668mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000096A                 TRUE     1669mm     IFEQ DEBUG
0000096A  1A39 00C00003           1670mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000970  0805 0002               1671mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000974  67F4                    1672mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000976  13C2 00C00007           1673mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000097C                          1674mm     ENDC
0000097C                          1675mm     
0000097C                 FALSE    1676mm     IFNE DEBUG
0000097C                          1677mm     ENDC
0000097C                          1678mm 
0000097C                          1679mm     ENDM
0000097C  57CE FFDA               1680m     DBEQ D6,LOOP_107
00000980                          1681m     ENDM
00000980                          1682m         PRINT_CRLF D5,A4
00000980  49FA 05B5               1683m     LEA CRLF(PC),A4
00000984                          1684mm     PRINT_STR A4,D5
00000984                          1685mm LOOP_113
00000984  0C14 0000               1686mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000988  6700 0016               1687mm     BEQ EXIT_113
0000098C                          1688mmm     PRINT_CHAR (A4)+,D5
0000098C                          1689mmm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1690mmm     IFEQ DEBUG
0000098C  1A39 00C00003           1691mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000992  0805 0002               1692mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000996  67F4                    1693mmm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000998  13DC 00C00007           1694mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000099E                          1695mmm     ENDC
0000099E                          1696mmm     
0000099E                 FALSE    1697mmm     IFNE DEBUG
0000099E                          1698mmm     ENDC
0000099E                          1699mmm 
0000099E                          1700mmm     ENDM
0000099E  60E4                    1701mm     BRA LOOP_113
000009A0                          1702mm EXIT_113
000009A0                          1703mm     ENDM
000009A0                          1704m     ENDM
000009A0  6000 F7B0               1705          BRA MAIN_LOOP
000009A4                          1706      ENDI
000009A4                          1707s _0000000A
000009A4                          1708      
000009A4                          1709      IF D1 <EQ> #0 THEN
000009A4  B27C 0000               1710s     CMP.W   #0,D1
000009A8  6600 0006               1711s     BNE _0000000B
000009AC  6000 F9B8               1712        BRA WAIT_FOR_SRECORD            
000009B0                          1713      ENDI
000009B0                          1714s _0000000B
000009B0                          1715  DOWNLOAD_DONE
000009B0                          1716m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009B0  43FA 058B               1717m     LEA OX(PC),A1
000009B4                          1718mm     PRINT_STR A1,D5
000009B4                          1719mm LOOP_116
000009B4  0C11 0000               1720mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009B8  6700 0016               1721mm     BEQ EXIT_116
000009BC                          1722mmm     PRINT_CHAR (A1)+,D5
000009BC                          1723mmm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BC                 TRUE     1724mmm     IFEQ DEBUG
000009BC  1A39 00C00003           1725mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009C2  0805 0002               1726mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009C6  67F4                    1727mmm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
000009C8  13D9 00C00007           1728mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009CE                          1729mmm     ENDC
000009CE                          1730mmm     
000009CE                 FALSE    1731mmm     IFNE DEBUG
000009CE                          1732mmm     ENDC
000009CE                          1733mmm 
000009CE                          1734mmm     ENDM
000009CE  60E4                    1735mm     BRA LOOP_116
000009D0                          1736mm EXIT_116
000009D0                          1737mm     ENDM
000009D0  7407                    1738m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009D2                          1739m LOOP_115
000009D2                          1740mm     BIN2HEX D0,D6,A1
000009D2  43FA 0528               1741mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009D6  E998                    1742mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009D8  1C00                    1743mm     MOVE.B D0,D6
000009DA  0286 0000000F           1744mm     ANDI.L #$F,D6
000009E0  1C31 6000               1745mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009E4                          1746mm     ENDM
000009E4                          1747mm     PRINT_CHAR D6,D5
000009E4                          1748mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E4                 TRUE     1749mm     IFEQ DEBUG
000009E4  1A39 00C00003           1750mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009EA  0805 0002               1751mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009EE  67F4                    1752mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
000009F0  13C6 00C00007           1753mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009F6                          1754mm     ENDC
000009F6                          1755mm     
000009F6                 FALSE    1756mm     IFNE DEBUG
000009F6                          1757mm     ENDC
000009F6                          1758mm 
000009F6                          1759mm     ENDM
000009F6  57CA FFDA               1760m     DBEQ D2,LOOP_115
000009FA                          1761m     ENDM
000009FA  43FA 04A3               1762      LEA READ(PC),A1
000009FE                          1763m     PRINT_STR A1,D5
000009FE                          1764m LOOP_120
000009FE  0C11 0000               1765m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A02  6700 0016               1766m     BEQ EXIT_120
00000A06                          1767mm     PRINT_CHAR (A1)+,D5
00000A06                          1768mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A06                 TRUE     1769mm     IFEQ DEBUG
00000A06  1A39 00C00003           1770mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A0C  0805 0002               1771mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A10  67F4                    1772mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A12  13D9 00C00007           1773mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A18                          1774mm     ENDC
00000A18                          1775mm     
00000A18                 FALSE    1776mm     IFNE DEBUG
00000A18                          1777mm     ENDC
00000A18                          1778mm 
00000A18                          1779mm     ENDM
00000A18  60E4                    1780m     BRA LOOP_120
00000A1A                          1781m EXIT_120
00000A1A                          1782m     ENDM
00000A1A  2E08                    1783      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A1C                          1784m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A1C  43FA 051F               1785m     LEA OX(PC),A1
00000A20                          1786mm     PRINT_STR A1,D5
00000A20                          1787mm LOOP_123
00000A20  0C11 0000               1788mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A24  6700 0016               1789mm     BEQ EXIT_123
00000A28                          1790mmm     PRINT_CHAR (A1)+,D5
00000A28                          1791mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A28                 TRUE     1792mmm     IFEQ DEBUG
00000A28  1A39 00C00003           1793mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A2E  0805 0002               1794mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A32  67F4                    1795mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A34  13D9 00C00007           1796mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A3A                          1797mmm     ENDC
00000A3A                          1798mmm     
00000A3A                 FALSE    1799mmm     IFNE DEBUG
00000A3A                          1800mmm     ENDC
00000A3A                          1801mmm 
00000A3A                          1802mmm     ENDM
00000A3A  60E4                    1803mm     BRA LOOP_123
00000A3C                          1804mm EXIT_123
00000A3C                          1805mm     ENDM
00000A3C  7407                    1806m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A3E                          1807m LOOP_122
00000A3E                          1808mm     BIN2HEX D7,D6,A1
00000A3E  43FA 04BC               1809mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A42  E99F                    1810mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A44  1C07                    1811mm     MOVE.B D7,D6
00000A46  0286 0000000F           1812mm     ANDI.L #$F,D6
00000A4C  1C31 6000               1813mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A50                          1814mm     ENDM
00000A50                          1815mm     PRINT_CHAR D6,D5
00000A50                          1816mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A50                 TRUE     1817mm     IFEQ DEBUG
00000A50  1A39 00C00003           1818mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A56  0805 0002               1819mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A5A  67F4                    1820mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A5C  13C6 00C00007           1821mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A62                          1822mm     ENDC
00000A62                          1823mm     
00000A62                 FALSE    1824mm     IFNE DEBUG
00000A62                          1825mm     ENDC
00000A62                          1826mm 
00000A62                          1827mm     ENDM
00000A62  57CA FFDA               1828m     DBEQ D2,LOOP_122
00000A66                          1829m     ENDM
00000A66                          1830m     PRINT_CRLF D5,A4     
00000A66  49FA 04CF               1831m     LEA CRLF(PC),A4
00000A6A                          1832mm     PRINT_STR A4,D5
00000A6A                          1833mm LOOP_128
00000A6A  0C14 0000               1834mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A6E  6700 0016               1835mm     BEQ EXIT_128
00000A72                          1836mmm     PRINT_CHAR (A4)+,D5
00000A72                          1837mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A72                 TRUE     1838mmm     IFEQ DEBUG
00000A72  1A39 00C00003           1839mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A78  0805 0002               1840mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A7C  67F4                    1841mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000A7E  13DC 00C00007           1842mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A84                          1843mmm     ENDC
00000A84                          1844mmm     
00000A84                 FALSE    1845mmm     IFNE DEBUG
00000A84                          1846mmm     ENDC
00000A84                          1847mmm 
00000A84                          1848mmm     ENDM
00000A84  60E4                    1849mm     BRA LOOP_128
00000A86                          1850mm EXIT_128
00000A86                          1851mm     ENDM
00000A86                          1852m     ENDM
00000A86                          1853          
00000A86  6000 F6CA               1854      BRA MAIN_LOOP
00000A8A                          1855      
00000A8A                          1856  G
00000A8A  2047                    1857      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A8C  3E3C 0000               1858      MOVE #0,D7                                      ; clear the now used address accumulator
00000A90  4ED0                    1859      JMP (A0)                                        ; jump to it!
00000A92                          1860      
00000A92                          1861  Z
00000A92  207C 00200000           1862      MOVE.L #RAM,A0                                  ; address of RAM
00000A98                          1863      
00000A98                          1864      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A98  7000                    1865s     MOVE.L  #0,D0
00000A9A  6000 0012               1866s     BRA _20000005
00000A9E                          1867s _20000004
00000A9E  2200                    1868          MOVE.L D0,D1                              ; progress update
00000AA0  E089                    1869          LSR.L #8,D1 
00000AA2  E089                    1870          LSR.L #8,D1
00000AA4  13C1 00E00001           1871          MOVE.B D1,DISPLAY
00000AAA                          1872  
00000AAA  20C0                    1873          MOVE.L D0,(A0)+
00000AAC                          1874      ENDF
00000AAC  5880                    1875s     ADD.L   #4,D0
00000AAE                          1876s _20000005
00000AAE  B0BC 00040000           1877s     CMP.L   #$40000,D0
00000AB4  6FE8                    1878s     BLE _20000004
00000AB6                          1879   
00000AB6  207C 00200000           1880      MOVE.L #RAM,A0                                    ; address of RAM
00000ABC                          1881     
00000ABC                          1882      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000ABC  7000                    1883s     MOVE.L  #0,D0
00000ABE  6000 00A6               1884s     BRA _20000007
00000AC2                          1885s _20000006
00000AC2  2200                    1886          MOVE.L D0,D1                              ; progress update
00000AC4  E089                    1887          LSR.L #8,D1
00000AC6  E089                    1888          LSR.L #8,D1
00000AC8  13C1 00E00001           1889          MOVE.B D1,DISPLAY
00000ACE                          1890  
00000ACE  2218                    1891          MOVE.L (A0)+,D1
00000AD0                          1892            
00000AD0                          1893          IF.L D0 <NE> D1 THEN      
00000AD0  B081                    1894s     CMP.L   D1,D0
00000AD2  6700 0090               1895s     BEQ _0000000C
00000AD6  43FA 0412               1896              LEA RAM_ERROR(PC),A1
00000ADA                          1897m             PRINT_STR A1,D1
00000ADA                          1898m LOOP_130
00000ADA  0C11 0000               1899m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000ADE  6700 0016               1900m     BEQ EXIT_130
00000AE2                          1901mm     PRINT_CHAR (A1)+,D1
00000AE2                          1902mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE2                 TRUE     1903mm     IFEQ DEBUG
00000AE2  1239 00C00003           1904mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000AE8  0801 0002               1905mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000AEC  67F4                    1906mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AEE  13D9 00C00007           1907mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AF4                          1908mm     ENDC
00000AF4                          1909mm     
00000AF4                 FALSE    1910mm     IFNE DEBUG
00000AF4                          1911mm     ENDC
00000AF4                          1912mm 
00000AF4                          1913mm     ENDM
00000AF4  60E4                    1914m     BRA LOOP_130
00000AF6                          1915m EXIT_130
00000AF6                          1916m     ENDM
00000AF6  2208                    1917              MOVE.L A0,D1
00000AF8  5981                    1918              SUB.L #4,D1
00000AFA                          1919m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AFA  43FA 0441               1920m     LEA OX(PC),A1
00000AFE                          1921mm     PRINT_STR A1,D3
00000AFE                          1922mm LOOP_133
00000AFE  0C11 0000               1923mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B02  6700 0016               1924mm     BEQ EXIT_133
00000B06                          1925mmm     PRINT_CHAR (A1)+,D3
00000B06                          1926mmm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B06                 TRUE     1927mmm     IFEQ DEBUG
00000B06  1639 00C00003           1928mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B0C  0803 0002               1929mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B10  67F4                    1930mmm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B12  13D9 00C00007           1931mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B18                          1932mmm     ENDC
00000B18                          1933mmm     
00000B18                 FALSE    1934mmm     IFNE DEBUG
00000B18                          1935mmm     ENDC
00000B18                          1936mmm 
00000B18                          1937mmm     ENDM
00000B18  60E4                    1938mm     BRA LOOP_133
00000B1A                          1939mm EXIT_133
00000B1A                          1940mm     ENDM
00000B1A  7C07                    1941m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B1C                          1942m LOOP_132
00000B1C                          1943mm     BIN2HEX D1,D2,A1
00000B1C  43FA 03DE               1944mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B20  E999                    1945mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B22  1401                    1946mm     MOVE.B D1,D2
00000B24  0282 0000000F           1947mm     ANDI.L #$F,D2
00000B2A  1431 2000               1948mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B2E                          1949mm     ENDM
00000B2E                          1950mm     PRINT_CHAR D2,D3
00000B2E                          1951mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B2E                 TRUE     1952mm     IFEQ DEBUG
00000B2E  1639 00C00003           1953mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B34  0803 0002               1954mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B38  67F4                    1955mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B3A  13C2 00C00007           1956mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B40                          1957mm     ENDC
00000B40                          1958mm     
00000B40                 FALSE    1959mm     IFNE DEBUG
00000B40                          1960mm     ENDC
00000B40                          1961mm 
00000B40                          1962mm     ENDM
00000B40  57CE FFDA               1963m     DBEQ D6,LOOP_132
00000B44                          1964m     ENDM
00000B44                          1965m             PRINT_CRLF D3,A1
00000B44  43FA 03F1               1966m     LEA CRLF(PC),A1
00000B48                          1967mm     PRINT_STR A1,D3
00000B48                          1968mm LOOP_138
00000B48  0C11 0000               1969mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B4C  6700 0016               1970mm     BEQ EXIT_138
00000B50                          1971mmm     PRINT_CHAR (A1)+,D3
00000B50                          1972mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B50                 TRUE     1973mmm     IFEQ DEBUG
00000B50  1639 00C00003           1974mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B56  0803 0002               1975mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B5A  67F4                    1976mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000B5C  13D9 00C00007           1977mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B62                          1978mmm     ENDC
00000B62                          1979mmm     
00000B62                 FALSE    1980mmm     IFNE DEBUG
00000B62                          1981mmm     ENDC
00000B62                          1982mmm 
00000B62                          1983mmm     ENDM
00000B62  60E4                    1984mm     BRA LOOP_138
00000B64                          1985mm EXIT_138
00000B64                          1986mm     ENDM
00000B64                          1987m     ENDM
00000B64                          1988          ENDI 
00000B64                          1989s _0000000C
00000B64                          1990      ENDF
00000B64  5880                    1991s     ADD.L   #4,D0
00000B66                          1992s _20000007
00000B66  B0BC 00040000           1993s     CMP.L   #$40000,D0
00000B6C  6F00 FF54               1994s     BLE _20000006
00000B70                          1995      
00000B70  6000 F5E0               1996      BRA MAIN_LOOP
00000B74                          1997    
00000B74                          1998  L
00000B74  7000                    1999      MOVE.L #0,D0                                    ; D0 will be the length  to write            
00000B76  7200                    2000      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B78                          2001  
00000B78                          2002      FOR D2 = #0 TO #7 DO                          ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B78  343C 0000               2003s     MOVE.W  #0,D2
00000B7C  6000 0046               2004s     BRA _20000009
00000B80                          2005s _20000008
00000B80  E989                    2006          LSL.L #4,D1                                 ; make what we have so far more significant
00000B82                          2007m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B82                          2008m WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B82                 TRUE     2009m     IFEQ DEBUG
00000B82  1839 00C00003           2010m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B88  0804 0000               2011m         BTST #0,D4                              ; CHECK FOR CHARACTER
00000B8C  67F4                    2012m         BEQ WAIT_FOR_READY_140                      ; NOTHING, CHECK AGAIN
00000B8E                          2013m     ENDC
00000B8E                          2014m     
00000B8E                          2015mm     READ_CHAR D3
00000B8E                 TRUE     2016mm     IFEQ DEBUG
00000B8E  1639 00C00007           2017mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B94                          2018mm     ENDC
00000B94                 FALSE    2019mm     IFNE DEBUG
00000B94                          2020mm     ENDC
00000B94                          2021mm      
00000B94  B63C 001B               2022mm     CMP.B #$1B,D3                               ; CHECK FOR ESCAPE AND GO TO START
00000B98  6700 F46E               2023mm     BEQ START
00000B9C                          2024mm     ENDM
00000B9C                          2025m 
00000B9C                 TRUE     2026m     IFEQ DEBUG
00000B9C                          2027mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B9C                          2028mm WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B9C                 TRUE     2029mm     IFEQ DEBUG
00000B9C  1839 00C00003           2030mm         MOVE.B DUART_SRA,D4                     ; READ STATUS REGISTER
00000BA2  0804 0002               2031mm         BTST #2,D4                              ; CHECK FOR SPACE TO SEND
00000BA6  67F4                    2032mm         BEQ WAIT_FOR_READY_142                      ; NO SPACE, CHECK AGAIN
00000BA8  13C3 00C00007           2033mm         MOVE.B D3,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BAE                          2034mm     ENDC
00000BAE                          2035mm     
00000BAE                 FALSE    2036mm     IFNE DEBUG
00000BAE                          2037mm     ENDC
00000BAE                          2038mm 
00000BAE                          2039mm     ENDM
00000BAE                          2040m     ENDC
00000BAE                          2041m     ENDM
00000BAE                          2042m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BAE  41FA 035C               2043m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BB2  0403 0030               2044m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BB6  C6BC 000000FF           2045m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BBC  1630 3000               2046m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BC0                          2047m     ENDM
00000BC0  8203                    2048          OR.B D3,D1
00000BC2                          2049      ENDF
00000BC2  5242                    2050s     ADD.W   #1,D2
00000BC4                          2051s _20000009
00000BC4  B47C 0007               2052s     CMP.W   #7,D2
00000BC8  6FB6                    2053s     BLE _20000008
00000BCA                          2054      
00000BCA  3001                    2055      MOVE.W D1,D0                                  ; extract the LSword for the length
00000BCC  E089                    2056      LSR.L #8,D1                                   ; extract the MSword for the address
00000BCE  E089                    2057      LSR.L #8,D1                                   
00000BD0                          2058                        
00000BD0                          2059m     PRINT_CRLF D2,A1
00000BD0  43FA 0365               2060m     LEA CRLF(PC),A1
00000BD4                          2061mm     PRINT_STR A1,D2
00000BD4                          2062mm LOOP_145
00000BD4  0C11 0000               2063mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BD8  6700 0016               2064mm     BEQ EXIT_145
00000BDC                          2065mmm     PRINT_CHAR (A1)+,D2
00000BDC                          2066mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BDC                 TRUE     2067mmm     IFEQ DEBUG
00000BDC  1439 00C00003           2068mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000BE2  0802 0002               2069mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000BE6  67F4                    2070mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000BE8  13D9 00C00007           2071mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BEE                          2072mmm     ENDC
00000BEE                          2073mmm     
00000BEE                 FALSE    2074mmm     IFNE DEBUG
00000BEE                          2075mmm     ENDC
00000BEE                          2076mmm 
00000BEE                          2077mmm     ENDM
00000BEE  60E4                    2078mm     BRA LOOP_145
00000BF0                          2079mm EXIT_145
00000BF0                          2080mm     ENDM
00000BF0                          2081m     ENDM
00000BF0                          2082  
00000BF0  2041                    2083      MOVE.L D1,A0                                ; target address
00000BF2                          2084      
00000BF2  2247                    2085      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BF4  7E00                    2086      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BF6                          2087  
00000BF6  5089                    2088      ADD.L #8,A1                                   ; skip the initial stack pointer and reset vector for now
00000BF8  5180                    2089      SUB.L #8,D0
00000BFA                          2090      
00000BFA  31FC AAAA 2AAA          2091      MOVE.W #$AAAA,$2AAA
00000C00  31FC 5555 1554          2092      MOVE.W #$5555,$1554
00000C06  31FC 8080 2AAA          2093      MOVE.W #$8080,$2AAA
00000C0C  31FC AAAA 2AAA          2094      MOVE.W #$AAAA,$2AAA
00000C12  31FC 5555 1554          2095      MOVE.W #$5555,$1554
00000C18  31FC 2020 2AAA          2096      MOVE.W #$2020,$2AAA
00000C1E                          2097      
00000C1E  45FA 0303               2098      LEA LOADING(PC),A2                          ; the prints are important for timing to unprotect the EEPROM
00000C22                          2099m     PRINT_STR A2,D2
00000C22                          2100m LOOP_147
00000C22  0C12 0000               2101m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C26  6700 0016               2102m     BEQ EXIT_147
00000C2A                          2103mm     PRINT_CHAR (A2)+,D2
00000C2A                          2104mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2A                 TRUE     2105mm     IFEQ DEBUG
00000C2A  1439 00C00003           2106mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000C30  0802 0002               2107mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000C34  67F4                    2108mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C36  13DA 00C00007           2109mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C3C                          2110mm     ENDC
00000C3C                          2111mm     
00000C3C                 FALSE    2112mm     IFNE DEBUG
00000C3C                          2113mm     ENDC
00000C3C                          2114mm 
00000C3C                          2115mm     ENDM
00000C3C  60E4                    2116m     BRA LOOP_147
00000C3E                          2117m EXIT_147
00000C3E                          2118m     ENDM
00000C3E                          2119      
00000C3E  2409                    2120      MOVE.L A1,D2                
00000C40                          2121m     PRINT_REG D2,D3,D4,D5,A2
00000C40  45FA 02FB               2122m     LEA OX(PC),A2
00000C44                          2123mm     PRINT_STR A2,D3
00000C44                          2124mm LOOP_150
00000C44  0C12 0000               2125mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C48  6700 0016               2126mm     BEQ EXIT_150
00000C4C                          2127mmm     PRINT_CHAR (A2)+,D3
00000C4C                          2128mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4C                 TRUE     2129mmm     IFEQ DEBUG
00000C4C  1639 00C00003           2130mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C52  0803 0002               2131mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C56  67F4                    2132mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C58  13DA 00C00007           2133mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C5E                          2134mmm     ENDC
00000C5E                          2135mmm     
00000C5E                 FALSE    2136mmm     IFNE DEBUG
00000C5E                          2137mmm     ENDC
00000C5E                          2138mmm 
00000C5E                          2139mmm     ENDM
00000C5E  60E4                    2140mm     BRA LOOP_150
00000C60                          2141mm EXIT_150
00000C60                          2142mm     ENDM
00000C60  7A07                    2143m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C62                          2144m LOOP_149
00000C62                          2145mm     BIN2HEX D2,D4,A2
00000C62  45FA 0298               2146mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000C66  E99A                    2147mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C68  1802                    2148mm     MOVE.B D2,D4
00000C6A  0284 0000000F           2149mm     ANDI.L #$F,D4
00000C70  1832 4000               2150mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000C74                          2151mm     ENDM
00000C74                          2152mm     PRINT_CHAR D4,D3
00000C74                          2153mm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C74                 TRUE     2154mm     IFEQ DEBUG
00000C74  1639 00C00003           2155mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C7A  0803 0002               2156mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C7E  67F4                    2157mm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C80  13C4 00C00007           2158mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C86                          2159mm     ENDC
00000C86                          2160mm     
00000C86                 FALSE    2161mm     IFNE DEBUG
00000C86                          2162mm     ENDC
00000C86                          2163mm 
00000C86                          2164mm     ENDM
00000C86  57CD FFDA               2165m     DBEQ D5,LOOP_149
00000C8A                          2166m     ENDM
00000C8A                          2167  
00000C8A  45FA 02B4               2168      LEA TO(PC),A2
00000C8E                          2169m     PRINT_STR A2,D3
00000C8E                          2170m LOOP_154
00000C8E  0C12 0000               2171m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C92  6700 0016               2172m     BEQ EXIT_154
00000C96                          2173mm     PRINT_CHAR (A2)+,D3
00000C96                          2174mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C96                 TRUE     2175mm     IFEQ DEBUG
00000C96  1639 00C00003           2176mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C9C  0803 0002               2177mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA0  67F4                    2178mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000CA2  13DA 00C00007           2179mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CA8                          2180mm     ENDC
00000CA8                          2181mm     
00000CA8                 FALSE    2182mm     IFNE DEBUG
00000CA8                          2183mm     ENDC
00000CA8                          2184mm 
00000CA8                          2185mm     ENDM
00000CA8  60E4                    2186m     BRA LOOP_154
00000CAA                          2187m EXIT_154
00000CAA                          2188m     ENDM
00000CAA                          2189      
00000CAA  2408                    2190          MOVE.L A0,D2                
00000CAC                          2191m     PRINT_REG D2,D3,D4,D5,A2
00000CAC  45FA 028F               2192m     LEA OX(PC),A2
00000CB0                          2193mm     PRINT_STR A2,D3
00000CB0                          2194mm LOOP_157
00000CB0  0C12 0000               2195mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CB4  6700 0016               2196mm     BEQ EXIT_157
00000CB8                          2197mmm     PRINT_CHAR (A2)+,D3
00000CB8                          2198mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB8                 TRUE     2199mmm     IFEQ DEBUG
00000CB8  1639 00C00003           2200mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CBE  0803 0002               2201mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CC2  67F4                    2202mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000CC4  13DA 00C00007           2203mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CCA                          2204mmm     ENDC
00000CCA                          2205mmm     
00000CCA                 FALSE    2206mmm     IFNE DEBUG
00000CCA                          2207mmm     ENDC
00000CCA                          2208mmm 
00000CCA                          2209mmm     ENDM
00000CCA  60E4                    2210mm     BRA LOOP_157
00000CCC                          2211mm EXIT_157
00000CCC                          2212mm     ENDM
00000CCC  7A07                    2213m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCE                          2214m LOOP_156
00000CCE                          2215mm     BIN2HEX D2,D4,A2
00000CCE  45FA 022C               2216mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000CD2  E99A                    2217mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD4  1802                    2218mm     MOVE.B D2,D4
00000CD6  0284 0000000F           2219mm     ANDI.L #$F,D4
00000CDC  1832 4000               2220mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000CE0                          2221mm     ENDM
00000CE0                          2222mm     PRINT_CHAR D4,D3
00000CE0                          2223mm WAIT_FOR_READY_160                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE0                 TRUE     2224mm     IFEQ DEBUG
00000CE0  1639 00C00003           2225mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE6  0803 0002               2226mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CEA  67F4                    2227mm         BEQ WAIT_FOR_READY_160                      ; NO SPACE, CHECK AGAIN
00000CEC  13C4 00C00007           2228mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CF2                          2229mm     ENDC
00000CF2                          2230mm     
00000CF2                 FALSE    2231mm     IFNE DEBUG
00000CF2                          2232mm     ENDC
00000CF2                          2233mm 
00000CF2                          2234mm     ENDM
00000CF2  57CD FFDA               2235m     DBEQ D5,LOOP_156
00000CF6                          2236m     ENDM
00000CF6                          2237  
00000CF6                          2238m     PRINT_CRLF D3,A2
00000CF6  45FA 023F               2239m     LEA CRLF(PC),A2
00000CFA                          2240mm     PRINT_STR A2,D3
00000CFA                          2241mm LOOP_162
00000CFA  0C12 0000               2242mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CFE  6700 0016               2243mm     BEQ EXIT_162
00000D02                          2244mmm     PRINT_CHAR (A2)+,D3
00000D02                          2245mmm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D02                 TRUE     2246mmm     IFEQ DEBUG
00000D02  1639 00C00003           2247mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D08  0803 0002               2248mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0C  67F4                    2249mmm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D0E  13DA 00C00007           2250mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000D14                          2251mmm     ENDC
00000D14                          2252mmm     
00000D14                 FALSE    2253mmm     IFNE DEBUG
00000D14                          2254mmm     ENDC
00000D14                          2255mmm 
00000D14                          2256mmm     ENDM
00000D14  60E4                    2257mm     BRA LOOP_162
00000D16                          2258mm EXIT_162
00000D16                          2259mm     ENDM
00000D16                          2260m     ENDM
00000D16                          2261  
00000D16                          2262      WHILE D0 <GT> #0 DO
00000D16                          2263s _10000014
00000D16  B07C 0000               2264s     CMP.W   #0,D0
00000D1A  6F00 001C               2265s     BLE _10000015
00000D1E  5580                    2266          SUB.L #2,D0
00000D20                          2267        
00000D20  13D1 00E00001           2268          MOVE.B (A1),DISPLAY
00000D26                          2269          
00000D26                          2270m         PROGRAM (A1),(A0),D2
00000D26  3091                    2271m   MOVE.W (A1),(A0)                          ; WRITE THE DATA
00000D28                          2272m       
00000D28                          2273m WAIT_FOR_COMPLETE_164
00000D28  3410                    2274m         MOVE.W (A0),D2
00000D2A                          2275m 
00000D2A                          2276m         IF.W D2 <NE> (A1) THEN
00000D2A  B451                    2277ms     CMP.W   (A1),D2
00000D2C  6700 0004               2278ms     BEQ _0000000D
00000D30  60F6                    2279m             BRA WAIT_FOR_COMPLETE_164
00000D32                          2280m         ENDI
00000D32                          2281ms _0000000D
00000D32                          2282m         ENDM
00000D32                          2283                
00000D32  5488                    2284          ADD.L #2,A0
00000D34  5489                    2285          ADD.L #2,A1
00000D36                          2286      ENDW
00000D36  60DE                    2287s     BRA _10000014
00000D38                          2288s _10000015
00000D38                          2289      
00000D38                          2290m     PROGRAM #$1234, $0, D2                         ; we're done, can now update the SP and start vector
00000D38  31FC 1234 0000          2291m   MOVE.W #$1234,$0                          ; WRITE THE DATA
00000D3E                          2292m       
00000D3E                          2293m WAIT_FOR_COMPLETE_165
00000D3E  3438 0000               2294m         MOVE.W $0,D2
00000D42                          2295m 
00000D42                          2296m         IF.W D2 <NE> #$1234 THEN
00000D42  B47C 1234               2297ms     CMP.W   #$1234,D2
00000D46  6700 0004               2298ms     BEQ _0000000E
00000D4A  60F2                    2299m             BRA WAIT_FOR_COMPLETE_165
00000D4C                          2300m         ENDI
00000D4C                          2301ms _0000000E
00000D4C                          2302m         ENDM
00000D4C                          2303m     PROGRAM #$5678, $2, D2                         
00000D4C  31FC 5678 0002          2304m   MOVE.W #$5678,$2                          ; WRITE THE DATA
00000D52                          2305m       
00000D52                          2306m WAIT_FOR_COMPLETE_166
00000D52  3438 0002               2307m         MOVE.W $2,D2
00000D56                          2308m 
00000D56                          2309m         IF.W D2 <NE> #$5678 THEN
00000D56  B47C 5678               2310ms     CMP.W   #$5678,D2
00000D5A  6700 0004               2311ms     BEQ _0000000F
00000D5E  60F2                    2312m             BRA WAIT_FOR_COMPLETE_166
00000D60                          2313m         ENDI
00000D60                          2314ms _0000000F
00000D60                          2315m         ENDM
00000D60                          2316  
00000D60                          2317m     PROGRAM D1, $4, D2                             ; we're done, can now update the SP and start vector
00000D60  31C1 0004               2318m   MOVE.W D1,$4                          ; WRITE THE DATA
00000D64                          2319m       
00000D64                          2320m WAIT_FOR_COMPLETE_167
00000D64  3438 0004               2321m         MOVE.W $4,D2
00000D68                          2322m 
00000D68                          2323m         IF.W D2 <NE> D1 THEN
00000D68  B441                    2324ms     CMP.W   D1,D2
00000D6A  6700 0004               2325ms     BEQ _00000010
00000D6E  60F4                    2326m             BRA WAIT_FOR_COMPLETE_167
00000D70                          2327m         ENDI
00000D70                          2328ms _00000010
00000D70                          2329m         ENDM
00000D70  E089                    2330      LSR.L #8,D1
00000D72  E089                    2331      LSR.L #8,D1
00000D74                          2332m     PROGRAM D1, $6, D2                         
00000D74  31C1 0006               2333m   MOVE.W D1,$6                          ; WRITE THE DATA
00000D78                          2334m       
00000D78                          2335m WAIT_FOR_COMPLETE_168
00000D78  3438 0006               2336m         MOVE.W $6,D2
00000D7C                          2337m 
00000D7C                          2338m         IF.W D2 <NE> D1 THEN
00000D7C  B441                    2339ms     CMP.W   D1,D2
00000D7E  6700 0004               2340ms     BEQ _00000011
00000D82  60F4                    2341m             BRA WAIT_FOR_COMPLETE_168
00000D84                          2342m         ENDI
00000D84                          2343ms _00000011
00000D84                          2344m         ENDM
00000D84                          2345  
00000D84  31FC AAAA 2AAA          2346      MOVE.W #$AAAA,$2AAA                            ; and write protect
00000D8A  31FC 5555 1554          2347      MOVE.W #$5555,$1554
00000D90  31FC A0A0 2AAA          2348      MOVE.W #$A0A0,$2AAA
00000D96                          2349              
00000D96  6000 F3BA               2350      BRA MAIN_LOOP
00000D9A                          2351          
00000D9A                          2352  HEX_DIGIT
00000D9A  E98F                    2353      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000D9C                          2354m     HEX2BIN D2,D2,A0
00000D9C  41FA 016E               2355m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000DA0  0402 0030               2356m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DA4  C4BC 000000FF           2357m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000DAA  1430 2000               2358m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000DAE                          2359m     ENDM
00000DAE  8E02                    2360      OR.B D2,D7  
00000DB0  6000 F3C0               2361      BRA GET_INPUT
00000DB4                          2362  
00000DB4  FFFF FFFF               2363      SIMHALT                                         ; halt simulator
00000DB8                          2364  
00000DB8                          2365  ; strings
00000DB8= 4D 44 46 2D 6D 6F ...   2366  VERSION DC.B 'MDF-mon V1.59 (11/04/2021)',CR,LF,NULL
00000DD5= 50 72 65 73 73 20 ...   2367  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000DE8= 3F 09 09 09 68 65 ...   2368  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000DF2= 5B 76 5D 09 09 09 ...   2369          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000E01= 78 78 78 78 78 78 ...   2370          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000E19= 78 78 78 78 78 78 ...   2371          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000E39= 5B 73 5D 09 09 09 ...   2372          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000E53= 78 78 78 78 78 78 ...   2373          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000E64= 5B 7A 5D 09 09 09 ...   2374          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000E76= 78 78 78 78 78 78 ...   2375          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000E98= 48 75 68 3F 0D 0A 00    2376  HUH     DC.B 'Huh?',CR,LF,NULL
00000E9F= 20 53 20 72 65 63 ...   2377  READ    DC.B ' S records read, start address = ',NULL
00000EC1= 57 3A 20 55 6E 6B ...   2378  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000ED8= 57 3A 20 43 53 20 ...   2379  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000EEA= 57 3A 20 52 41 4D ...   2380  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000EFC= 30 31 32 33 34 35 ...   2381  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000F0C= 00 01 02 03 04 05 ...   2382  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000F23= 4C 6F 61 64 69 6E ...   2383  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000F37= 0D 0A 00                2384  CRLF    DC.B CR,LF,NULL
00000F3A= 3E 20 00                2385  PROMPT  DC.B '> ',NULL
00000F3D= 30 78 00                2386  ox      DC.B '0x',NULL
00000F40= 20 2D 3E 20 00          2387  to      DC.B ' -> ',NULL
00000F45                          2388      
00000F45                          2389      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         EFC
CONTINUE_39         382
CONTINUE_42         3D2
CONTINUE_46         428
CONTINUE_54         4DC
CONTINUE_59         54E
CONTINUE_64         5CA
CONTINUE_69         648
CONTINUE_74         6D0
CONTINUE_79         742
CONTINUE_84         7B4
CONTINUE_98         8A6
CR                  D
CRLF                F37
CS_FAILURE          ED8
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       C2D
DOWNLOAD_DONE       9B0
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             148
EXIT_103            90E
EXIT_105            936
EXIT_108            956
EXIT_113            9A0
EXIT_116            9D0
EXIT_12             172
EXIT_120            A1A
EXIT_123            A3C
EXIT_128            A86
EXIT_130            AF6
EXIT_133            B1A
EXIT_138            B64
EXIT_145            BF0
EXIT_147            C3E
EXIT_150            C60
EXIT_154            CAA
EXIT_157            CCC
EXIT_162            D16
EXIT_18             1F6
EXIT_20             246
EXIT_22             272
EXIT_25             29C
EXIT_3              E8
EXIT_30             2E6
EXIT_37             35A
EXIT_5              108
EXIT_51             498
EXIT_7              128
EXIT_89             826
EXIT_91             846
EXIT_95             878
G                   A8A
GET_INPUT           172
H                   24A
HELP                DE8
HELPPROMPT          DD5
HEX2BIN             137
HEX2BIN_LUT         F0C
HEX_DIGIT           D9A
HUH                 E98
L                   B74
LF                  A
LOADING             F23
LOOP_10             12C
LOOP_103            8F2
LOOP_105            91A
LOOP_107            958
LOOP_108            93A
LOOP_113            984
LOOP_115            9D2
LOOP_116            9B4
LOOP_12             156
LOOP_120            9FE
LOOP_122            A3E
LOOP_123            A20
LOOP_128            A6A
LOOP_130            ADA
LOOP_132            B1C
LOOP_133            AFE
LOOP_138            B48
LOOP_145            BD4
LOOP_147            C22
LOOP_149            C62
LOOP_150            C44
LOOP_154            C8E
LOOP_156            CCE
LOOP_157            CB0
LOOP_162            CFA
LOOP_18             1DA
LOOP_20             22A
LOOP_22             256
LOOP_24             29E
LOOP_25             280
LOOP_3              CC
LOOP_30             2CA
LOOP_37             33E
LOOP_5              EC
LOOP_51             47C
LOOP_7              10C
LOOP_89             80A
LOOP_91             82A
LOOP_95             85C
MAIN_LOOP           152
NULL                0
OX                  F3D
PRINTSTR            256
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROGRAM             E50
PROMPT              F3A
R                   276
RAM                 200000
RAM_ERROR           EEA
READ                E9F
READ_CHAR           7E2
READ_DATA_TO_POKE   2EE
RESET               4
ROM                 0
S                   35E
STACK               0
START               8
TAB                 9
TO                  F40
UNREC               EC1
V                   252
VERSION             DB8
W                   2EA
WAIT_CHAR           633
WAIT_FOR_COMPLETE_164  D28
WAIT_FOR_COMPLETE_165  D3E
WAIT_FOR_COMPLETE_166  D52
WAIT_FOR_COMPLETE_167  D64
WAIT_FOR_COMPLETE_168  D78
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_100  8BE
WAIT_FOR_READY_104  8FA
WAIT_FOR_READY_106  922
WAIT_FOR_READY_109  942
WAIT_FOR_READY_11   134
WAIT_FOR_READY_111  96A
WAIT_FOR_READY_114  98C
WAIT_FOR_READY_117  9BC
WAIT_FOR_READY_119  9E4
WAIT_FOR_READY_121  A06
WAIT_FOR_READY_124  A28
WAIT_FOR_READY_126  A50
WAIT_FOR_READY_129  A72
WAIT_FOR_READY_13   15E
WAIT_FOR_READY_131  AE2
WAIT_FOR_READY_134  B06
WAIT_FOR_READY_136  B2E
WAIT_FOR_READY_139  B50
WAIT_FOR_READY_14   172
WAIT_FOR_READY_140  B82
WAIT_FOR_READY_142  B9C
WAIT_FOR_READY_146  BDC
WAIT_FOR_READY_148  C2A
WAIT_FOR_READY_151  C4C
WAIT_FOR_READY_153  C74
WAIT_FOR_READY_155  C96
WAIT_FOR_READY_158  CB8
WAIT_FOR_READY_16   18C
WAIT_FOR_READY_160  CE0
WAIT_FOR_READY_163  D02
WAIT_FOR_READY_19   1E2
WAIT_FOR_READY_21   232
WAIT_FOR_READY_23   25E
WAIT_FOR_READY_26   288
WAIT_FOR_READY_28   2B0
WAIT_FOR_READY_31   2D2
WAIT_FOR_READY_32   2F0
WAIT_FOR_READY_34   30A
WAIT_FOR_READY_38   346
WAIT_FOR_READY_39   366
WAIT_FOR_READY_4    D4
WAIT_FOR_READY_41   3A0
WAIT_FOR_READY_42   3B6
WAIT_FOR_READY_44   3EA
WAIT_FOR_READY_46   40C
WAIT_FOR_READY_48   440
WAIT_FOR_READY_52   484
WAIT_FOR_READY_54   4C0
WAIT_FOR_READY_56   4F4
WAIT_FOR_READY_59   532
WAIT_FOR_READY_6    F4
WAIT_FOR_READY_61   566
WAIT_FOR_READY_64   5AE
WAIT_FOR_READY_66   5E2
WAIT_FOR_READY_69   62C
WAIT_FOR_READY_71   660
WAIT_FOR_READY_74   6B4
WAIT_FOR_READY_76   6E8
WAIT_FOR_READY_79   726
WAIT_FOR_READY_8    114
WAIT_FOR_READY_81   75A
WAIT_FOR_READY_84   798
WAIT_FOR_READY_86   7CC
WAIT_FOR_READY_90   812
WAIT_FOR_READY_92   832
WAIT_FOR_READY_93   846
WAIT_FOR_READY_96   864
WAIT_FOR_READY_98   88A
WAIT_FOR_SRECORD    366
Z                   A92
_00000000           1B2
_00000001           1C6
_00000002           4A0
_00000003           87C
_00000004           4AE
_00000005           69C
_00000006           612
_00000007           87C
_00000008           806
_00000009           87C
_0000000A           9A4
_0000000B           9B0
_0000000C           B64
_0000000D           D32
_0000000E           D4C
_0000000F           D60
_00000010           D70
_00000011           D84
_10000000           402
_10000001           46A
_10000002           4B6
_10000003           51E
_10000004           528
_10000005           590
_10000006           5A4
_10000007           60C
_10000008           616
_10000009           696
_1000000A           622
_1000000B           68A
_1000000C           6AA
_1000000D           712
_1000000E           71C
_1000000F           784
_10000010           78E
_10000011           7F6
_10000012           880
_10000013           8E8
_10000014           D16
_10000015           D38
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A9E
_20000005           AAE
_20000006           AC2
_20000007           B66
_20000008           B80
_20000009           BC4
