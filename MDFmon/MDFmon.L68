00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 15:17:28

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; shared code between load and patch
00000000                             9  ; tidy up comments again, sigh
00000000                            10  ; also garbage on serial port when starting
00000000                            11  ; use DBLoop?
00000000                            12  ; think about size and do I need to slim things down
00000000                            13  
00000000                            14  
00000000                            15  ; ideas, but no room to do them
00000000                            16  ;------------------------------
00000000                            17  ; keep track of highest address hit during srec download
00000000                            18  ; implement backspace
00000000                            19  ; fix being able to enter random chars when W'ing
00000000                            20  ; ram check at startup?  Not sure if this is a good idea!
00000000                            21  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            22  
00000000                            23      ORG  $0
00000000                            24  
00000000  =00000000                 25  DEBUG               EQU 0
00000000                            26  
00000000                            27  ; constants
00000000  =00000000                 28  NULL                EQU 0
00000000  =00000009                 29  TAB                 EQU 9
00000000  =0000000D                 30  CR                  EQU 13
00000000  =0000000A                 31  LF                  EQU 10
00000000                            32  
00000000  =00000000                 33  ROM                 EQU $0
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35     
00000000  =00C00000                 36  DUART_BASE          EQU $C00000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  
00000000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           110          BTST #2,\2                              ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           113      ENDC
00000000                           114      
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll, /2 = working address register
00000000                           125  PRINT_CRLF MACRO
00000000                           126      LEA CRLF(PC),\2
00000000                           127      PRINT_STR \2,\1
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      BRA LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           143  PRINT_REG MACRO
00000000                           144      LEA ox(PC),\5
00000000                           145      PRINT_STR \5,\2
00000000                           146      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152      
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                            ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                    ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           195      BTST #0,\1                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           201      BTST #0,\1                                      ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; unprotect the EEPROM
00000000                           210  UNPROTECT MACRO
00000000                           211      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           212      NOP
00000000                           213      MOVE.W #$5555,$1554
00000000                           214      NOP
00000000                           215      MOVE.W #$8080,$2AAA
00000000                           216      NOP
00000000                           217      MOVE.W #$AAAA,$2AAA
00000000                           218      NOP
00000000                           219      MOVE.W #$5555,$1554
00000000                           220      NOP
00000000                           221      MOVE.W #$2020,$2AAA
00000000                           222      ENDM
00000000                           223      
00000000                           224  ; protect the EEPROM
00000000                           225  PROTECT MACRO
00000000                           226      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           227      MOVE.W #$5555,$1554
00000000                           228      MOVE.W #$A0A0,$2AAA
00000000                           229      ENDM
00000000                           230  
00000000                           231      
00000000                           232  ; read two hex digits from the download serial port and convert to a byte
00000000                           233  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           234  DOWNLOAD_BYTE MACRO
00000000                           235      MOVE.B #2,\4
00000000                           236      WHILE.B \4 <GT> 0 DO
00000000                           237          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           238          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           239          PRINT_CHAR \2,\3
00000000                           240          HEX2BIN \2,\2,\6
00000000                           241          OR.B \2,\1
00000000                           242          SUB.B #1,\4
00000000                           243      ENDW
00000000                           244      
00000000                           245      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           246      MOVE.B \1,\2
00000000                           247      ADD.L \1,\5
00000000                           248  
00000000                           249      ENDM
00000000                           250      
00000000                           251  ; write word to EEPROM
00000000                           252  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           253  PROGRAM MACRO
00000000                           254    MOVE.W \1,\2                          ; write the data
00000000                           255        
00000000                           256  WAIT_FOR_COMPLETE\@
00000000                           257          MOVE.W \2,\3
00000000                           258  
00000000                           259          IF.W \3 <NE> \1 THEN
00000000                           260              BRA WAIT_FOR_COMPLETE\@
00000000                           261          ENDI
00000000                           262          ENDM
00000000                           263          
00000000                           264  ; register catalogue
00000000                           265  ; D0 - used for simulator I/O
00000000                           266  ; D1 - used for simulator I/O
00000000                           267  ; D2 - read character
00000000                           268  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           269  ; D6 - working register used in R/W
00000000                           270  ; D7 - address accumulator, reset by download
00000000                           271  ; A0 - address of string to print 
00000000                           272  
00000000                           273  ; start vector
00000000= 00000000                 274  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 275  RESET    DC.L START                             ; RESET
00000008                           276      
00000008                           277  ; start of program  
00000008                           278  START
00000008  13FC 0000 00E00001       279      MOVE.B #0,DISPLAY
00000010                           280  
00000010                           281  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       282      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       283      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           284      
00000020                           285      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                286s     MOVE.W  #$50,D1
00000024  6000 000E                287s     BRA _20000001
00000028                           288s _20000000
00000028  13C1 00C00005            289          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     290          NOP
00000030                           291      ENDF
00000030  0441 0010                292s     SUB.W   #$10,D1
00000034                           293s _20000001
00000034  B27C 0010                294s     CMP.W   #$10,D1
00000038  6CEE                     295s     BGE _20000000
0000003A                           296  
0000003A                           297      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                298s     MOVE.W  #$50,D1
0000003E  6000 000E                299s     BRA _20000003
00000042                           300s _20000002
00000042  13C1 00C00015            301          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     302          NOP
0000004A                           303      ENDF
0000004A  0441 0010                304s     SUB.W   #$10,D1
0000004E                           305s _20000003
0000004E  B27C 0010                306s     CMP.W   #$10,D1
00000052  6CEE                     307s     BGE _20000002
00000054                           308    
00000054                           309  ;initialise UART
00000054  13FC 0000 00C00009       310      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       311      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       312      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           313  
0000006C                           314  ; channel A
0000006C  13FC 0013 00C00001       315      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       316      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       317      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       318      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           319  
0000008C                           320  ; channel B
0000008C  13FC 0013 00C00011       321      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       322      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       323      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       324      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           325  
000000AC                           326      ;PRINT_CHAR '.',D3                              ; give the serial port chance to settle after reset
000000AC                           327  
000000AC  13FC 0001 00E00001       328      MOVE.B #1,DISPLAY
000000B4                           329         
000000B4                           330m     PRINT_CRLF D3,A0
000000B4  41FA 1077                331m     LEA CRLF(PC),A0
000000B8                           332mm     PRINT_STR A0,D3
000000B8                           333mm LOOP_2
000000B8  0C10 0000                334mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000BC  6700 0016                335mm     BEQ EXIT_2
000000C0                           336mmm     PRINT_CHAR (A0)+,D3
000000C0                           337mmm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      338mmm     IFEQ DEBUG
000000C0  1639 00C00003            339mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000C6  0803 0002                340mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000CA  67F4                     341mmm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
000000CC  13D8 00C00007            342mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000D2                           343mmm     ENDC
000000D2                           344mmm     
000000D2                 FALSE     345mmm     IFNE DEBUG
000000D2                           346mmm     ENDC
000000D2                           347mmm 
000000D2                           348mmm     ENDM
000000D2  60E4                     349mm     BRA LOOP_2
000000D4                           350mm EXIT_2
000000D4                           351mm     ENDM
000000D4                           352m     ENDM
000000D4                           353  
000000D4  41FA 0EB8                354      LEA VERSION(PC),A0
000000D8                           355m     PRINT_STR A0,D3
000000D8                           356m LOOP_4
000000D8  0C10 0000                357m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000DC  6700 0016                358m     BEQ EXIT_4
000000E0                           359mm     PRINT_CHAR (A0)+,D3
000000E0                           360mm WAIT_FOR_READY_5                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E0                 TRUE      361mm     IFEQ DEBUG
000000E0  1639 00C00003            362mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000E6  0803 0002                363mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000EA  67F4                     364mm         BEQ WAIT_FOR_READY_5                    ; NO SPACE, CHECK AGAIN
000000EC  13D8 00C00007            365mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000F2                           366mm     ENDC
000000F2                           367mm     
000000F2                 FALSE     368mm     IFNE DEBUG
000000F2                           369mm     ENDC
000000F2                           370mm 
000000F2                           371mm     ENDM
000000F2  60E4                     372m     BRA LOOP_4
000000F4                           373m EXIT_4
000000F4                           374m     ENDM
000000F4                           375      
000000F4  41FA 0EB5                376      LEA HELPPROMPT(PC),A0
000000F8                           377m     PRINT_STR A0,D3
000000F8                           378m LOOP_6
000000F8  0C10 0000                379m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000FC  6700 0016                380m     BEQ EXIT_6
00000100                           381mm     PRINT_CHAR (A0)+,D3
00000100                           382mm WAIT_FOR_READY_7                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000100                 TRUE      383mm     IFEQ DEBUG
00000100  1639 00C00003            384mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000106  0803 0002                385mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000010A  67F4                     386mm         BEQ WAIT_FOR_READY_7                    ; NO SPACE, CHECK AGAIN
0000010C  13D8 00C00007            387mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000112                           388mm     ENDC
00000112                           389mm     
00000112                 FALSE     390mm     IFNE DEBUG
00000112                           391mm     ENDC
00000112                           392mm 
00000112                           393mm     ENDM
00000112  60E4                     394m     BRA LOOP_6
00000114                           395m EXIT_6
00000114                           396m     ENDM
00000114                           397      
00000114                           398m     PRINT_CRLF D3,A0
00000114  41FA 1017                399m     LEA CRLF(PC),A0
00000118                           400mm     PRINT_STR A0,D3
00000118                           401mm LOOP_9
00000118  0C10 0000                402mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000011C  6700 0016                403mm     BEQ EXIT_9
00000120                           404mmm     PRINT_CHAR (A0)+,D3
00000120                           405mmm WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000120                 TRUE      406mmm     IFEQ DEBUG
00000120  1639 00C00003            407mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000126  0803 0002                408mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000012A  67F4                     409mmm         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0000012C  13D8 00C00007            410mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000132                           411mmm     ENDC
00000132                           412mmm     
00000132                 FALSE     413mmm     IFNE DEBUG
00000132                           414mmm     ENDC
00000132                           415mmm 
00000132                           416mmm     ENDM
00000132  60E4                     417mm     BRA LOOP_9
00000134                           418mm EXIT_9
00000134                           419mm     ENDM
00000134                           420m     ENDM
00000134                           421  
00000134  7E00                     422      MOVE.L #0,D7                                    ; address accumulator
00000136                           423  
00000136  13FC 0002 00E00001       424      MOVE.B #2,DISPLAY
0000013E                           425  MAIN_LOOP
0000013E  41FA 0FF0                426      LEA PROMPT(PC),A0
00000142                           427m     PRINT_STR A0,D3
00000142                           428m LOOP_11
00000142  0C10 0000                429m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000146  6700 0016                430m     BEQ EXIT_11
0000014A                           431mm     PRINT_CHAR (A0)+,D3
0000014A                           432mm WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000014A                 TRUE      433mm     IFEQ DEBUG
0000014A  1639 00C00003            434mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000150  0803 0002                435mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000154  67F4                     436mm         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
00000156  13D8 00C00007            437mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000015C                           438mm     ENDC
0000015C                           439mm     
0000015C                 FALSE     440mm     IFNE DEBUG
0000015C                           441mm     ENDC
0000015C                           442mm 
0000015C                           443mm     ENDM
0000015C  60E4                     444m     BRA LOOP_11
0000015E                           445m EXIT_11
0000015E                           446m     ENDM
0000015E                           447      
0000015E                           448  GET_INPUT
0000015E                           449m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015E                           450m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015E                 TRUE      451m     IFEQ DEBUG
0000015E  1639 00C00003            452m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000164  0803 0000                453m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000168  67F4                     454m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
0000016A                           455m     ENDC
0000016A                           456m     
0000016A                           457mm     READ_CHAR D2
0000016A                 TRUE      458mm     IFEQ DEBUG
0000016A  1439 00C00007            459mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000170                           460mm     ENDC
00000170                 FALSE     461mm     IFNE DEBUG
00000170                           462mm     ENDC
00000170                           463mm      
00000170  B43C 001B                464mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000174  6700 FE92                465mm     BEQ START
00000178                           466mm     ENDM
00000178                           467m 
00000178                 TRUE      468m     IFEQ DEBUG
00000178                           469mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000178                           470mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000178                 TRUE      471mm     IFEQ DEBUG
00000178  1639 00C00003            472mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017E  0803 0002                473mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000182  67F4                     474mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
00000184  13C2 00C00007            475mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000018A                           476mm     ENDC
0000018A                           477mm     
0000018A                 FALSE     478mm     IFNE DEBUG
0000018A                           479mm     ENDC
0000018A                           480mm 
0000018A                           481mm     ENDM
0000018A                           482m     ENDC
0000018A                           483m     ENDM
0000018A                           484      
0000018A                           485      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000018A  B43C 0030                486s     CMP.B   #'0',D2
0000018E  6D00 000E                487s     BLT _00000000
00000192  B43C 0039                488s     CMP.B   #'9',D2
00000196  6E00 0006                489s     BGT _00000000
0000019A  6000 0DD4                490          BRA HEX_DIGIT
0000019E                           491      ENDI
0000019E                           492s _00000000
0000019E                           493      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019E  B43C 0041                494s     CMP.B   #'A',D2
000001A2  6D00 000E                495s     BLT _00000001
000001A6  B43C 0046                496s     CMP.B   #'F',D2
000001AA  6E00 0006                497s     BGT _00000001
000001AE  6000 0DC0                498          BRA HEX_DIGIT
000001B2                           499      ENDI
000001B2                           500s _00000001
000001B2                           501          
000001B2  B43C 0077                502      CMP.B #'w',D2
000001B6  6700 0126                503      BEQ W
000001BA                           504      
000001BA  B43C 006C                505      CMP.B #'l',D2
000001BE  6700 09A8                506      BEQ L 
000001C2                           507  
000001C2  B43C 0070                508      CMP.B #'p',D2
000001C6  6700 0BD0                509      BEQ P
000001CA                           510  
000001CA                           511m     PRINT_CRLF D3,A0
000001CA  41FA 0F61                512m     LEA CRLF(PC),A0
000001CE                           513mm     PRINT_STR A0,D3
000001CE                           514mm LOOP_17
000001CE  0C10 0000                515mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001D2  6700 0016                516mm     BEQ EXIT_17
000001D6                           517mmm     PRINT_CHAR (A0)+,D3
000001D6                           518mmm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001D6                 TRUE      519mmm     IFEQ DEBUG
000001D6  1639 00C00003            520mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001DC  0803 0002                521mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001E0  67F4                     522mmm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
000001E2  13D8 00C00007            523mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001E8                           524mmm     ENDC
000001E8                           525mmm     
000001E8                 FALSE     526mmm     IFNE DEBUG
000001E8                           527mmm     ENDC
000001E8                           528mmm 
000001E8                           529mmm     ENDM
000001E8  60E4                     530mm     BRA LOOP_17
000001EA                           531mm EXIT_17
000001EA                           532mm     ENDM
000001EA                           533m     ENDM
000001EA                           534   
000001EA  B43C 003F                535      CMP.B #'?',D2
000001EE  6700 004E                536      BEQ H
000001F2                           537   
000001F2  B43C 0076                538      CMP.B #'v',D2
000001F6  6700 004E                539      BEQ V
000001FA                           540      
000001FA  B43C 0072                541      CMP.B #'r',D2
000001FE  6700 006A                542      BEQ R
00000202                           543  
00000202  B43C 0073                544      CMP.B #'s',D2
00000206  6700 014A                545      BEQ S
0000020A                           546  
0000020A  B43C 0067                547      CMP.B #'g',D2
0000020E  6700 086E                548      BEQ G   
00000212                           549  
00000212  B43C 007A                550      CMP.B #'z',D2
00000216  6700 086E                551      BEQ Z   
0000021A                           552  
0000021A  41FA 0E72                553      LEA HUH(PC),A0
0000021E                           554m     PRINT_STR A0,D3
0000021E                           555m LOOP_19
0000021E  0C10 0000                556m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000222  6700 0016                557m     BEQ EXIT_19
00000226                           558mm     PRINT_CHAR (A0)+,D3
00000226                           559mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000226                 TRUE      560mm     IFEQ DEBUG
00000226  1639 00C00003            561mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000022C  0803 0002                562mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000230  67F4                     563mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
00000232  13D8 00C00007            564mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000238                           565mm     ENDC
00000238                           566mm     
00000238                 FALSE     567mm     IFNE DEBUG
00000238                           568mm     ENDC
00000238                           569mm 
00000238                           570mm     ENDM
00000238  60E4                     571m     BRA LOOP_19
0000023A                           572m EXIT_19
0000023A                           573m     ENDM
0000023A                           574                         
0000023A  6000 FF02                575      BRA MAIN_LOOP
0000023E                           576      
0000023E                           577  ; commands
0000023E                           578  H   
0000023E  41FA 0D7E                579      LEA HELP(PC),A0
00000242  6000 0006                580      BRA PRINTSTR
00000246                           581  
00000246                           582  V   
00000246  41FA 0D46                583      LEA VERSION(PC),A0
0000024A                           584  PRINTSTR
0000024A                           585m     PRINT_STR A0,D3       
0000024A                           586m LOOP_21
0000024A  0C10 0000                587m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024E  6700 0016                588m     BEQ EXIT_21
00000252                           589mm     PRINT_CHAR (A0)+,D3
00000252                           590mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000252                 TRUE      591mm     IFEQ DEBUG
00000252  1639 00C00003            592mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000258  0803 0002                593mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000025C  67F4                     594mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0000025E  13D8 00C00007            595mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000264                           596mm     ENDC
00000264                           597mm     
00000264                 FALSE     598mm     IFNE DEBUG
00000264                           599mm     ENDC
00000264                           600mm 
00000264                           601mm     ENDM
00000264  60E4                     602m     BRA LOOP_21
00000266                           603m EXIT_21
00000266                           604m     ENDM
00000266  6000 FED6                605      BRA MAIN_LOOP
0000026A                           606      
0000026A                           607  R   
0000026A  2047                     608      MOVE.L D7,A0                                    ; address accumulator -> address register
0000026C  7E00                     609      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000026E  2410                     610      MOVE.L (A0),D2                                  ; read the memory and print it
00000270                           611m     PRINT_REG D2,D3,D4,D5,A0
00000270  41FA 0EC1                612m     LEA OX(PC),A0
00000274                           613mm     PRINT_STR A0,D3
00000274                           614mm LOOP_24
00000274  0C10 0000                615mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000278  6700 0016                616mm     BEQ EXIT_24
0000027C                           617mmm     PRINT_CHAR (A0)+,D3
0000027C                           618mmm WAIT_FOR_READY_25                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      619mmm     IFEQ DEBUG
0000027C  1639 00C00003            620mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000282  0803 0002                621mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000286  67F4                     622mmm         BEQ WAIT_FOR_READY_25                   ; NO SPACE, CHECK AGAIN
00000288  13D8 00C00007            623mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028E                           624mmm     ENDC
0000028E                           625mmm     
0000028E                 FALSE     626mmm     IFNE DEBUG
0000028E                           627mmm     ENDC
0000028E                           628mmm 
0000028E                           629mmm     ENDM
0000028E  60E4                     630mm     BRA LOOP_24
00000290                           631mm EXIT_24
00000290                           632mm     ENDM
00000290  7A07                     633m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000292                           634m LOOP_23
00000292                           635mm     BIN2HEX D2,D4,A0
00000292  41FA 0E5E                636mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
00000296  E99A                     637mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000298  1802                     638mm     MOVE.B D2,D4
0000029A  0284 0000000F            639mm     ANDI.L #$F,D4
000002A0  1830 4000                640mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
000002A4                           641mm     ENDM
000002A4                           642mm     PRINT_CHAR D4,D3
000002A4                           643mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002A4                 TRUE      644mm     IFEQ DEBUG
000002A4  1639 00C00003            645mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002AA  0803 0002                646mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002AE  67F4                     647mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002B0  13C4 00C00007            648mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002B6                           649mm     ENDC
000002B6                           650mm     
000002B6                 FALSE     651mm     IFNE DEBUG
000002B6                           652mm     ENDC
000002B6                           653mm 
000002B6                           654mm     ENDM
000002B6  57CD FFDA                655m     DBEQ D5,LOOP_23
000002BA                           656m     ENDM
000002BA                           657m     PRINT_CRLF D3,A0
000002BA  41FA 0E71                658m     LEA CRLF(PC),A0
000002BE                           659mm     PRINT_STR A0,D3
000002BE                           660mm LOOP_29
000002BE  0C10 0000                661mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002C2  6700 0016                662mm     BEQ EXIT_29
000002C6                           663mmm     PRINT_CHAR (A0)+,D3
000002C6                           664mmm WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C6                 TRUE      665mmm     IFEQ DEBUG
000002C6  1639 00C00003            666mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002CC  0803 0002                667mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D0  67F4                     668mmm         BEQ WAIT_FOR_READY_30                   ; NO SPACE, CHECK AGAIN
000002D2  13D8 00C00007            669mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D8                           670mmm     ENDC
000002D8                           671mmm     
000002D8                 FALSE     672mmm     IFNE DEBUG
000002D8                           673mmm     ENDC
000002D8                           674mmm 
000002D8                           675mmm     ENDM
000002D8  60E4                     676mm     BRA LOOP_29
000002DA                           677mm EXIT_29
000002DA                           678mm     ENDM
000002DA                           679m     ENDM
000002DA  6000 FE62                680      BRA MAIN_LOOP
000002DE                           681  
000002DE                           682  W
000002DE  3C3C 0007                683      MOVE #7,D6                                      ; 7 bytes left to read
000002E2                           684      
000002E2                           685  READ_DATA_TO_POKE
000002E2  E98D                     686      LSL.L #4,D5                                     ; make what we have so far more significant
000002E4                           687m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002E4                           688m WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E4                 TRUE      689m     IFEQ DEBUG
000002E4  1639 00C00003            690m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EA  0803 0000                691m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002EE  67F4                     692m         BEQ WAIT_FOR_READY_31                   ; NOTHING, CHECK AGAIN
000002F0                           693m     ENDC
000002F0                           694m     
000002F0                           695mm     READ_CHAR D2
000002F0                 TRUE      696mm     IFEQ DEBUG
000002F0  1439 00C00007            697mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002F6                           698mm     ENDC
000002F6                 FALSE     699mm     IFNE DEBUG
000002F6                           700mm     ENDC
000002F6                           701mm      
000002F6  B43C 001B                702mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002FA  6700 FD0C                703mm     BEQ START
000002FE                           704mm     ENDM
000002FE                           705m 
000002FE                 TRUE      706m     IFEQ DEBUG
000002FE                           707mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000002FE                           708mm WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      709mm     IFEQ DEBUG
000002FE  1639 00C00003            710mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000304  0803 0002                711mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000308  67F4                     712mm         BEQ WAIT_FOR_READY_33                   ; NO SPACE, CHECK AGAIN
0000030A  13C2 00C00007            713mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000310                           714mm     ENDC
00000310                           715mm     
00000310                 FALSE     716mm     IFNE DEBUG
00000310                           717mm     ENDC
00000310                           718mm 
00000310                           719mm     ENDM
00000310                           720m     ENDC
00000310                           721m     ENDM
00000310                           722m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000310  41FA 0DF0                723m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000314  0402 0030                724m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000318  C4BC 000000FF            725m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000031E  1430 2000                726m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000322                           727m     ENDM
00000322  8A02                     728      OR.B D2,D5
00000324  57CE FFBC                729      DBEQ D6,READ_DATA_TO_POKE
00000328                           730      
00000328  2047                     731      MOVE.L D7,A0                                    ; address accumulator -> address register
0000032A  7E00                     732      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000032C                           733      
0000032C  2085                     734      MOVE.L D5,(A0)                                  ; write the data
0000032E                           735  
0000032E                           736m     PRINT_CRLF D3,A0
0000032E  41FA 0DFD                737m     LEA CRLF(PC),A0
00000332                           738mm     PRINT_STR A0,D3
00000332                           739mm LOOP_36
00000332  0C10 0000                740mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000336  6700 0016                741mm     BEQ EXIT_36
0000033A                           742mmm     PRINT_CHAR (A0)+,D3
0000033A                           743mmm WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033A                 TRUE      744mmm     IFEQ DEBUG
0000033A  1639 00C00003            745mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000340  0803 0002                746mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000344  67F4                     747mmm         BEQ WAIT_FOR_READY_37                   ; NO SPACE, CHECK AGAIN
00000346  13D8 00C00007            748mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000034C                           749mmm     ENDC
0000034C                           750mmm     
0000034C                 FALSE     751mmm     IFNE DEBUG
0000034C                           752mmm     ENDC
0000034C                           753mmm 
0000034C                           754mmm     ENDM
0000034C  60E4                     755mm     BRA LOOP_36
0000034E                           756mm EXIT_36
0000034E                           757mm     ENDM
0000034E                           758m     ENDM
0000034E  6000 FDEE                759      BRA MAIN_LOOP
00000352                           760  
00000352                           761  ; register map for S
00000352                           762  ; A0 - start address
00000352                           763  ; A1 - offset
00000352                           764  ; A2 - next address to write
00000352                           765  ; A3 - next location (jmp)
00000352                           766  ; A4 - Working Address Register
00000352                           767  ; D0 - record count
00000352                           768  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000352                           769  ; D2 - checksum
00000352                           770  ; D3 - data byte count
00000352                           771  ; D4 - read address, moved into A2
00000352                           772  ; D5 - temp
00000352                           773  ; D6 - temp
00000352                           774  ; D7 - temp
00000352                           775  S
00000352  2078 0000                776      MOVE.L 0,A0                                     ; start address -> A0
00000356  2247                     777      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000358                           778      
00000358  7000                     779      MOVE.L #0,D0                                    ; count of records read -> D0
0000035A                           780          
0000035A                           781  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000035A                           782m     DOWNLOAD D1                 
0000035A                           783m WAIT_FOR_READY_38                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                           784m 
0000035A  1239 00C00003            785m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000360  0801 0000                786m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000364  6700 0010                787m     BEQ CONTINUE_38                             ; NOTHING, CONTINUE
00000368                           788m  
00000368                           789mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000368                 TRUE      790mm     IFEQ DEBUG
00000368  1239 00C00007            791mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000036E                           792mm     ENDC
0000036E                 FALSE     793mm     IFNE DEBUG
0000036E                           794mm     ENDC
0000036E                           795mm      
0000036E  B23C 001B                796mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000372  6700 FC94                797mm     BEQ START
00000376                           798mm     ENDM
00000376                           799m CONTINUE_38
00000376  1239 00C00013            800m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000037C  0801 0000                801m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000380  67D8                     802m     BEQ WAIT_FOR_READY_38                           ; NOTHING, CHECK AGAIN
00000382                           803m     
00000382  1239 00C00017            804m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000388  13C1 00E00001            805m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000038E                           806m     
0000038E                           807m     ENDM
0000038E  B23C 0053                808      CMP.B #'S',D1                                   ; found S?    
00000392  66C6                     809      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000394                           810      
00000394                           811m     PRINT_CHAR #'S',D5                            ; print the S
00000394                           812m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000394                 TRUE      813m     IFEQ DEBUG
00000394  1A39 00C00003            814m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000039A  0805 0002                815m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000039E  67F4                     816m         BEQ WAIT_FOR_READY_40                   ; NO SPACE, CHECK AGAIN
000003A0  13FC 0053 00C00007       817m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003A8                           818m     ENDC
000003A8                           819m     
000003A8                 FALSE     820m     IFNE DEBUG
000003A8                           821m     ENDC
000003A8                           822m 
000003A8                           823m     ENDM
000003A8  5280                     824      ADD.L #1,D0                                     ; read another S record, increment count
000003AA                           825      
000003AA                           826m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003AA                           827m WAIT_FOR_READY_41                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AA                           828m 
000003AA  1239 00C00003            829m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003B0  0801 0000                830m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003B4  6700 0010                831m     BEQ CONTINUE_41                             ; NOTHING, CONTINUE
000003B8                           832m  
000003B8                           833mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003B8                 TRUE      834mm     IFEQ DEBUG
000003B8  1239 00C00007            835mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003BE                           836mm     ENDC
000003BE                 FALSE     837mm     IFNE DEBUG
000003BE                           838mm     ENDC
000003BE                           839mm      
000003BE  B23C 001B                840mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003C2  6700 FC44                841mm     BEQ START
000003C6                           842mm     ENDM
000003C6                           843m CONTINUE_41
000003C6  1239 00C00013            844m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003CC  0801 0000                845m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003D0  67D8                     846m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003D2                           847m     
000003D2  1239 00C00017            848m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003D8  13C1 00E00001            849m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003DE                           850m     
000003DE                           851m     ENDM
000003DE                           852m     PRINT_CHAR D1,D5
000003DE                           853m WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DE                 TRUE      854m     IFEQ DEBUG
000003DE  1A39 00C00003            855m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003E4  0805 0002                856m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003E8  67F4                     857m         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
000003EA  13C1 00C00007            858m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003F0                           859m     ENDC
000003F0                           860m     
000003F0                 FALSE     861m     IFNE DEBUG
000003F0                           862m     ENDC
000003F0                           863m 
000003F0                           864m     ENDM
000003F0                           865  
000003F0  7400                     866      MOVE.L #0,D2                                    ; clear the checksum
000003F2                           867  
000003F2                           868m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003F2  1E3C 0002                869m     MOVE.B #2,D7
000003F6                           870m     WHILE.B D7 <GT> 0 DO
000003F6                           871ms _10000000
000003F6  BE38 0000                872ms     CMP.B   0,D7
000003FA  6F00 0062                873ms     BLE _10000001
000003FE  E98B                     874m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000400                           875mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000400                           876mm WAIT_FOR_READY_45                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000400                           877mm 
00000400  1A39 00C00003            878mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000406  0805 0000                879mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000040A  6700 0010                880mm     BEQ CONTINUE_45                             ; NOTHING, CONTINUE
0000040E                           881mm  
0000040E                           882mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000040E                 TRUE      883mmm     IFEQ DEBUG
0000040E  1A39 00C00007            884mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000414                           885mmm     ENDC
00000414                 FALSE     886mmm     IFNE DEBUG
00000414                           887mmm     ENDC
00000414                           888mmm      
00000414  BA3C 001B                889mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000418  6700 FBEE                890mmm     BEQ START
0000041C                           891mmm     ENDM
0000041C                           892mm CONTINUE_45
0000041C  1A39 00C00013            893mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000422  0805 0000                894mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000426  67D8                     895mm     BEQ WAIT_FOR_READY_45                           ; NOTHING, CHECK AGAIN
00000428                           896mm     
00000428  1A39 00C00017            897mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000042E  13C5 00E00001            898mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000434                           899mm     
00000434                           900mm     ENDM
00000434                           901mm         PRINT_CHAR D5,D6
00000434                           902mm WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000434                 TRUE      903mm     IFEQ DEBUG
00000434  1C39 00C00003            904mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000043A  0806 0002                905mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000043E  67F4                     906mm         BEQ WAIT_FOR_READY_47                   ; NO SPACE, CHECK AGAIN
00000440  13C5 00C00007            907mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000446                           908mm     ENDC
00000446                           909mm     
00000446                 FALSE     910mm     IFNE DEBUG
00000446                           911mm     ENDC
00000446                           912mm 
00000446                           913mm     ENDM
00000446                           914mm         HEX2BIN D5,D5,A4
00000446  49FA 0CBA                915mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000044A  0405 0030                916mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000044E  CABC 000000FF            917mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000454  1A34 5000                918mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000458                           919mm     ENDM
00000458  8605                     920m         OR.B D5,D3
0000045A  5307                     921m         SUB.B #1,D7
0000045C                           922m     ENDW
0000045C  6098                     923ms     BRA _10000000
0000045E                           924ms _10000001
0000045E                           925m     
0000045E  7A00                     926m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000460  1A03                     927m     MOVE.B D3,D5
00000462  D483                     928m     ADD.L D3,D2
00000464                           929m 
00000464                           930m     ENDM
00000464                           931  
00000464                           932      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000464  B23C 0030                933s     CMP.B   #'0',D1
00000468  6600 002A                934s     BNE.L   _00000002
0000046C                           935m         PRINT_CRLF D5,A4
0000046C  49FA 0CBF                936m     LEA CRLF(PC),A4
00000470                           937mm     PRINT_STR A4,D5
00000470                           938mm LOOP_50
00000470  0C14 0000                939mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000474  6700 0016                940mm     BEQ EXIT_50
00000478                           941mmm     PRINT_CHAR (A4)+,D5
00000478                           942mmm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000478                 TRUE      943mmm     IFEQ DEBUG
00000478  1A39 00C00003            944mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000047E  0805 0002                945mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000482  67F4                     946mmm         BEQ WAIT_FOR_READY_51                   ; NO SPACE, CHECK AGAIN
00000484  13DC 00C00007            947mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000048A                           948mmm     ENDC
0000048A                           949mmm     
0000048A                 FALSE     950mmm     IFNE DEBUG
0000048A                           951mmm     ENDC
0000048A                           952mmm 
0000048A                           953mmm     ENDM
0000048A  60E4                     954mm     BRA LOOP_50
0000048C                           955mm EXIT_50
0000048C                           956mm     ENDM
0000048C                           957m     ENDM
0000048C  6000 FECC                958          BRA WAIT_FOR_SRECORD
00000490                           959      ELSE
00000490  6000 03DE                960s     BRA _00000003
00000494                           961s _00000002
00000494                           962          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00000494  B23C 0031                963s     CMP.B   #'1',D1
00000498  6708                     964s     BEQ.S   _00000004
0000049A  B23C 0032                965s     CMP.B   #'2',D1
0000049E  6600 01F0                966s     BNE.L   _00000005
000004A2                           967s _00000004
000004A2  5783                     968              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004A4                           969      
000004A4  7800                     970              MOVE.L #0,D4                            ; read two bytes of address
000004A6                           971m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004A6  1E3C 0002                972m     MOVE.B #2,D7
000004AA                           973m     WHILE.B D7 <GT> 0 DO
000004AA                           974ms _10000002
000004AA  BE38 0000                975ms     CMP.B   0,D7
000004AE  6F00 0062                976ms     BLE _10000003
000004B2  E98C                     977m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004B4                           978mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004B4                           979mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B4                           980mm 
000004B4  1A39 00C00003            981mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004BA  0805 0000                982mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004BE  6700 0010                983mm     BEQ CONTINUE_53                             ; NOTHING, CONTINUE
000004C2                           984mm  
000004C2                           985mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004C2                 TRUE      986mmm     IFEQ DEBUG
000004C2  1A39 00C00007            987mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C8                           988mmm     ENDC
000004C8                 FALSE     989mmm     IFNE DEBUG
000004C8                           990mmm     ENDC
000004C8                           991mmm      
000004C8  BA3C 001B                992mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004CC  6700 FB3A                993mmm     BEQ START
000004D0                           994mmm     ENDM
000004D0                           995mm CONTINUE_53
000004D0  1A39 00C00013            996mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004D6  0805 0000                997mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004DA  67D8                     998mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004DC                           999mm     
000004DC  1A39 00C00017           1000mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004E2  13C5 00E00001           1001mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E8                          1002mm     
000004E8                          1003mm     ENDM
000004E8                          1004mm         PRINT_CHAR D5,D6
000004E8                          1005mm WAIT_FOR_READY_55                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE     1006mm     IFEQ DEBUG
000004E8  1C39 00C00003           1007mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004EE  0806 0002               1008mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004F2  67F4                    1009mm         BEQ WAIT_FOR_READY_55                   ; NO SPACE, CHECK AGAIN
000004F4  13C5 00C00007           1010mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004FA                          1011mm     ENDC
000004FA                          1012mm     
000004FA                 FALSE    1013mm     IFNE DEBUG
000004FA                          1014mm     ENDC
000004FA                          1015mm 
000004FA                          1016mm     ENDM
000004FA                          1017mm         HEX2BIN D5,D5,A4
000004FA  49FA 0C06               1018mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004FE  0405 0030               1019mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000502  CABC 000000FF           1020mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000508  1A34 5000               1021mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000050C                          1022mm     ENDM
0000050C  8805                    1023m         OR.B D5,D4
0000050E  5307                    1024m         SUB.B #1,D7
00000510                          1025m     ENDW
00000510  6098                    1026ms     BRA _10000002
00000512                          1027ms _10000003
00000512                          1028m     
00000512  7A00                    1029m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000514  1A04                    1030m     MOVE.B D4,D5
00000516  D484                    1031m     ADD.L D4,D2
00000518                          1032m 
00000518                          1033m     ENDM
00000518                          1034m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000518  1E3C 0002               1035m     MOVE.B #2,D7
0000051C                          1036m     WHILE.B D7 <GT> 0 DO
0000051C                          1037ms _10000004
0000051C  BE38 0000               1038ms     CMP.B   0,D7
00000520  6F00 0062               1039ms     BLE _10000005
00000524  E98C                    1040m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000526                          1041mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000526                          1042mm WAIT_FOR_READY_58                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                          1043mm 
00000526  1A39 00C00003           1044mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000052C  0805 0000               1045mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000530  6700 0010               1046mm     BEQ CONTINUE_58                             ; NOTHING, CONTINUE
00000534                          1047mm  
00000534                          1048mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000534                 TRUE     1049mmm     IFEQ DEBUG
00000534  1A39 00C00007           1050mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000053A                          1051mmm     ENDC
0000053A                 FALSE    1052mmm     IFNE DEBUG
0000053A                          1053mmm     ENDC
0000053A                          1054mmm      
0000053A  BA3C 001B               1055mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000053E  6700 FAC8               1056mmm     BEQ START
00000542                          1057mmm     ENDM
00000542                          1058mm CONTINUE_58
00000542  1A39 00C00013           1059mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000548  0805 0000               1060mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000054C  67D8                    1061mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
0000054E                          1062mm     
0000054E  1A39 00C00017           1063mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000554  13C5 00E00001           1064mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000055A                          1065mm     
0000055A                          1066mm     ENDM
0000055A                          1067mm         PRINT_CHAR D5,D6
0000055A                          1068mm WAIT_FOR_READY_60                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000055A                 TRUE     1069mm     IFEQ DEBUG
0000055A  1C39 00C00003           1070mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000560  0806 0002               1071mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000564  67F4                    1072mm         BEQ WAIT_FOR_READY_60                   ; NO SPACE, CHECK AGAIN
00000566  13C5 00C00007           1073mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000056C                          1074mm     ENDC
0000056C                          1075mm     
0000056C                 FALSE    1076mm     IFNE DEBUG
0000056C                          1077mm     ENDC
0000056C                          1078mm 
0000056C                          1079mm     ENDM
0000056C                          1080mm         HEX2BIN D5,D5,A4
0000056C  49FA 0B94               1081mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000570  0405 0030               1082mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000574  CABC 000000FF           1083mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000057A  1A34 5000               1084mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000057E                          1085mm     ENDM
0000057E  8805                    1086m         OR.B D5,D4
00000580  5307                    1087m         SUB.B #1,D7
00000582                          1088m     ENDW
00000582  6098                    1089ms     BRA _10000004
00000584                          1090ms _10000005
00000584                          1091m     
00000584  7A00                    1092m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000586  1A04                    1093m     MOVE.B D4,D5
00000588  D484                    1094m     ADD.L D4,D2
0000058A                          1095m 
0000058A                          1096m     ENDM
0000058A                          1097              
0000058A                          1098              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
0000058A  B23C 0032               1099s     CMP.B   #'2',D1
0000058E  6600 0076               1100s     BNE.L   _00000006
00000592  5383                    1101                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000594                          1102m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00000594  1E3C 0002               1103m     MOVE.B #2,D7
00000598                          1104m     WHILE.B D7 <GT> 0 DO
00000598                          1105ms _10000006
00000598  BE38 0000               1106ms     CMP.B   0,D7
0000059C  6F00 0062               1107ms     BLE _10000007
000005A0  E98C                    1108m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005A2                          1109mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005A2                          1110mm WAIT_FOR_READY_63                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A2                          1111mm 
000005A2  1A39 00C00003           1112mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005A8  0805 0000               1113mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005AC  6700 0010               1114mm     BEQ CONTINUE_63                             ; NOTHING, CONTINUE
000005B0                          1115mm  
000005B0                          1116mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005B0                 TRUE     1117mmm     IFEQ DEBUG
000005B0  1A39 00C00007           1118mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005B6                          1119mmm     ENDC
000005B6                 FALSE    1120mmm     IFNE DEBUG
000005B6                          1121mmm     ENDC
000005B6                          1122mmm      
000005B6  BA3C 001B               1123mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005BA  6700 FA4C               1124mmm     BEQ START
000005BE                          1125mmm     ENDM
000005BE                          1126mm CONTINUE_63
000005BE  1A39 00C00013           1127mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005C4  0805 0000               1128mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005C8  67D8                    1129mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005CA                          1130mm     
000005CA  1A39 00C00017           1131mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005D0  13C5 00E00001           1132mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005D6                          1133mm     
000005D6                          1134mm     ENDM
000005D6                          1135mm         PRINT_CHAR D5,D6
000005D6                          1136mm WAIT_FOR_READY_65                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D6                 TRUE     1137mm     IFEQ DEBUG
000005D6  1C39 00C00003           1138mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005DC  0806 0002               1139mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005E0  67F4                    1140mm         BEQ WAIT_FOR_READY_65                   ; NO SPACE, CHECK AGAIN
000005E2  13C5 00C00007           1141mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005E8                          1142mm     ENDC
000005E8                          1143mm     
000005E8                 FALSE    1144mm     IFNE DEBUG
000005E8                          1145mm     ENDC
000005E8                          1146mm 
000005E8                          1147mm     ENDM
000005E8                          1148mm         HEX2BIN D5,D5,A4
000005E8  49FA 0B18               1149mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005EC  0405 0030               1150mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005F0  CABC 000000FF           1151mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005F6  1A34 5000               1152mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005FA                          1153mm     ENDM
000005FA  8805                    1154m         OR.B D5,D4
000005FC  5307                    1155m         SUB.B #1,D7
000005FE                          1156m     ENDW
000005FE  6098                    1157ms     BRA _10000006
00000600                          1158ms _10000007
00000600                          1159m     
00000600  7A00                    1160m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000602  1A04                    1161m     MOVE.B D4,D5
00000604  D484                    1162m     ADD.L D4,D2
00000606                          1163m 
00000606                          1164m     ENDM
00000606                          1165              ENDI
00000606                          1166s _00000006
00000606                          1167              
00000606  2444                    1168                  MOVE.L D4,A2                            ; put the address in an address register
00000608  D5C9                    1169              ADD.L A1,A2                             ; add in the offset
0000060A                          1170  
0000060A                          1171              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000060A                          1172s _10000008
0000060A  B63C 0000               1173s     CMP.B   #0,D3
0000060E  6F00 007A               1174s     BLE _10000009
00000612                          1175m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000612  1E3C 0002               1176m     MOVE.B #2,D7
00000616                          1177m     WHILE.B D7 <GT> 0 DO
00000616                          1178ms _1000000A
00000616  BE38 0000               1179ms     CMP.B   0,D7
0000061A  6F00 0062               1180ms     BLE _1000000B
0000061E  E989                    1181m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000620                          1182mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000620                          1183mm WAIT_FOR_READY_68                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                          1184mm 
00000620  1A39 00C00003           1185mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000626  0805 0000               1186mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000062A  6700 0010               1187mm     BEQ CONTINUE_68                             ; NOTHING, CONTINUE
0000062E                          1188mm  
0000062E                          1189mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000062E                 TRUE     1190mmm     IFEQ DEBUG
0000062E  1A39 00C00007           1191mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000634                          1192mmm     ENDC
00000634                 FALSE    1193mmm     IFNE DEBUG
00000634                          1194mmm     ENDC
00000634                          1195mmm      
00000634  BA3C 001B               1196mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000638  6700 F9CE               1197mmm     BEQ START
0000063C                          1198mmm     ENDM
0000063C                          1199mm CONTINUE_68
0000063C  1A39 00C00013           1200mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000642  0805 0000               1201mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000646  67D8                    1202mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
00000648                          1203mm     
00000648  1A39 00C00017           1204mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000064E  13C5 00E00001           1205mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000654                          1206mm     
00000654                          1207mm     ENDM
00000654                          1208mm         PRINT_CHAR D5,D6
00000654                          1209mm WAIT_FOR_READY_70                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000654                 TRUE     1210mm     IFEQ DEBUG
00000654  1C39 00C00003           1211mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000065A  0806 0002               1212mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000065E  67F4                    1213mm         BEQ WAIT_FOR_READY_70                   ; NO SPACE, CHECK AGAIN
00000660  13C5 00C00007           1214mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000666                          1215mm     ENDC
00000666                          1216mm     
00000666                 FALSE    1217mm     IFNE DEBUG
00000666                          1218mm     ENDC
00000666                          1219mm 
00000666                          1220mm     ENDM
00000666                          1221mm         HEX2BIN D5,D5,A4
00000666  49FA 0A9A               1222mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000066A  0405 0030               1223mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000066E  CABC 000000FF           1224mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000674  1A34 5000               1225mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000678                          1226mm     ENDM
00000678  8205                    1227m         OR.B D5,D1
0000067A  5307                    1228m         SUB.B #1,D7
0000067C                          1229m     ENDW
0000067C  6098                    1230ms     BRA _1000000A
0000067E                          1231ms _1000000B
0000067E                          1232m     
0000067E  7A00                    1233m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000680  1A01                    1234m     MOVE.B D1,D5
00000682  D481                    1235m     ADD.L D1,D2
00000684                          1236m 
00000684                          1237m     ENDM
00000684                          1238                          
00000684  14C1                    1239                  MOVE.B D1,(A2)+                     ; store it!
00000686                          1240  
00000686  5303                    1241                  SUB.B #1,D3                      ; 1 less byte to go
00000688                          1242              ENDW
00000688  6080                    1243s     BRA _10000008
0000068A                          1244s _10000009
0000068A                          1245          
0000068A  7200                    1246              MOVE.L #0,D1                         ; not done yet
0000068C                          1247          ELSE
0000068C  6000 01E2               1248s     BRA _00000007
00000690                          1249s _00000005
00000690                          1250              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000690  B23C 0038               1251s     CMP.B   #'8',D1
00000694  6600 0164               1252s     BNE.L   _00000008
00000698  7800                    1253                  MOVE.L #0,D4                    ; read the 24 bit start address
0000069A                          1254m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0000069A  1E3C 0002               1255m     MOVE.B #2,D7
0000069E                          1256m     WHILE.B D7 <GT> 0 DO
0000069E                          1257ms _1000000C
0000069E  BE38 0000               1258ms     CMP.B   0,D7
000006A2  6F00 0062               1259ms     BLE _1000000D
000006A6  E98C                    1260m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006A8                          1261mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006A8                          1262mm WAIT_FOR_READY_73                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A8                          1263mm 
000006A8  1A39 00C00003           1264mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006AE  0805 0000               1265mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006B2  6700 0010               1266mm     BEQ CONTINUE_73                             ; NOTHING, CONTINUE
000006B6                          1267mm  
000006B6                          1268mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006B6                 TRUE     1269mmm     IFEQ DEBUG
000006B6  1A39 00C00007           1270mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006BC                          1271mmm     ENDC
000006BC                 FALSE    1272mmm     IFNE DEBUG
000006BC                          1273mmm     ENDC
000006BC                          1274mmm      
000006BC  BA3C 001B               1275mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006C0  6700 F946               1276mmm     BEQ START
000006C4                          1277mmm     ENDM
000006C4                          1278mm CONTINUE_73
000006C4  1A39 00C00013           1279mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006CA  0805 0000               1280mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006CE  67D8                    1281mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
000006D0                          1282mm     
000006D0  1A39 00C00017           1283mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006D6  13C5 00E00001           1284mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006DC                          1285mm     
000006DC                          1286mm     ENDM
000006DC                          1287mm         PRINT_CHAR D5,D6
000006DC                          1288mm WAIT_FOR_READY_75                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DC                 TRUE     1289mm     IFEQ DEBUG
000006DC  1C39 00C00003           1290mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006E2  0806 0002               1291mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006E6  67F4                    1292mm         BEQ WAIT_FOR_READY_75                   ; NO SPACE, CHECK AGAIN
000006E8  13C5 00C00007           1293mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006EE                          1294mm     ENDC
000006EE                          1295mm     
000006EE                 FALSE    1296mm     IFNE DEBUG
000006EE                          1297mm     ENDC
000006EE                          1298mm 
000006EE                          1299mm     ENDM
000006EE                          1300mm         HEX2BIN D5,D5,A4
000006EE  49FA 0A12               1301mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006F2  0405 0030               1302mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006F6  CABC 000000FF           1303mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006FC  1A34 5000               1304mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000700                          1305mm     ENDM
00000700  8805                    1306m         OR.B D5,D4
00000702  5307                    1307m         SUB.B #1,D7
00000704                          1308m     ENDW
00000704  6098                    1309ms     BRA _1000000C
00000706                          1310ms _1000000D
00000706                          1311m     
00000706  7A00                    1312m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000708  1A04                    1313m     MOVE.B D4,D5
0000070A  D484                    1314m     ADD.L D4,D2
0000070C                          1315m 
0000070C                          1316m     ENDM
0000070C                          1317m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
0000070C  1E3C 0002               1318m     MOVE.B #2,D7
00000710                          1319m     WHILE.B D7 <GT> 0 DO
00000710                          1320ms _1000000E
00000710  BE38 0000               1321ms     CMP.B   0,D7
00000714  6F00 0062               1322ms     BLE _1000000F
00000718  E98C                    1323m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000071A                          1324mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071A                          1325mm WAIT_FOR_READY_78                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071A                          1326mm 
0000071A  1A39 00C00003           1327mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000720  0805 0000               1328mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000724  6700 0010               1329mm     BEQ CONTINUE_78                             ; NOTHING, CONTINUE
00000728                          1330mm  
00000728                          1331mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000728                 TRUE     1332mmm     IFEQ DEBUG
00000728  1A39 00C00007           1333mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000072E                          1334mmm     ENDC
0000072E                 FALSE    1335mmm     IFNE DEBUG
0000072E                          1336mmm     ENDC
0000072E                          1337mmm      
0000072E  BA3C 001B               1338mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000732  6700 F8D4               1339mmm     BEQ START
00000736                          1340mmm     ENDM
00000736                          1341mm CONTINUE_78
00000736  1A39 00C00013           1342mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000073C  0805 0000               1343mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000740  67D8                    1344mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000742                          1345mm     
00000742  1A39 00C00017           1346mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000748  13C5 00E00001           1347mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000074E                          1348mm     
0000074E                          1349mm     ENDM
0000074E                          1350mm         PRINT_CHAR D5,D6
0000074E                          1351mm WAIT_FOR_READY_80                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074E                 TRUE     1352mm     IFEQ DEBUG
0000074E  1C39 00C00003           1353mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000754  0806 0002               1354mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000758  67F4                    1355mm         BEQ WAIT_FOR_READY_80                   ; NO SPACE, CHECK AGAIN
0000075A  13C5 00C00007           1356mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000760                          1357mm     ENDC
00000760                          1358mm     
00000760                 FALSE    1359mm     IFNE DEBUG
00000760                          1360mm     ENDC
00000760                          1361mm 
00000760                          1362mm     ENDM
00000760                          1363mm         HEX2BIN D5,D5,A4
00000760  49FA 09A0               1364mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000764  0405 0030               1365mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000768  CABC 000000FF           1366mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000076E  1A34 5000               1367mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000772                          1368mm     ENDM
00000772  8805                    1369m         OR.B D5,D4
00000774  5307                    1370m         SUB.B #1,D7
00000776                          1371m     ENDW
00000776  6098                    1372ms     BRA _1000000E
00000778                          1373ms _1000000F
00000778                          1374m     
00000778  7A00                    1375m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000077A  1A04                    1376m     MOVE.B D4,D5
0000077C  D484                    1377m     ADD.L D4,D2
0000077E                          1378m 
0000077E                          1379m     ENDM
0000077E                          1380m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
0000077E  1E3C 0002               1381m     MOVE.B #2,D7
00000782                          1382m     WHILE.B D7 <GT> 0 DO
00000782                          1383ms _10000010
00000782  BE38 0000               1384ms     CMP.B   0,D7
00000786  6F00 0062               1385ms     BLE _10000011
0000078A  E98C                    1386m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000078C                          1387mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000078C                          1388mm WAIT_FOR_READY_83                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                          1389mm 
0000078C  1A39 00C00003           1390mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000792  0805 0000               1391mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000796  6700 0010               1392mm     BEQ CONTINUE_83                             ; NOTHING, CONTINUE
0000079A                          1393mm  
0000079A                          1394mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000079A                 TRUE     1395mmm     IFEQ DEBUG
0000079A  1A39 00C00007           1396mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007A0                          1397mmm     ENDC
000007A0                 FALSE    1398mmm     IFNE DEBUG
000007A0                          1399mmm     ENDC
000007A0                          1400mmm      
000007A0  BA3C 001B               1401mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007A4  6700 F862               1402mmm     BEQ START
000007A8                          1403mmm     ENDM
000007A8                          1404mm CONTINUE_83
000007A8  1A39 00C00013           1405mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007AE  0805 0000               1406mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007B2  67D8                    1407mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
000007B4                          1408mm     
000007B4  1A39 00C00017           1409mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007BA  13C5 00E00001           1410mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007C0                          1411mm     
000007C0                          1412mm     ENDM
000007C0                          1413mm         PRINT_CHAR D5,D6
000007C0                          1414mm WAIT_FOR_READY_85                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                 TRUE     1415mm     IFEQ DEBUG
000007C0  1C39 00C00003           1416mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007C6  0806 0002               1417mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007CA  67F4                    1418mm         BEQ WAIT_FOR_READY_85                   ; NO SPACE, CHECK AGAIN
000007CC  13C5 00C00007           1419mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007D2                          1420mm     ENDC
000007D2                          1421mm     
000007D2                 FALSE    1422mm     IFNE DEBUG
000007D2                          1423mm     ENDC
000007D2                          1424mm 
000007D2                          1425mm     ENDM
000007D2                          1426mm         HEX2BIN D5,D5,A4
000007D2  49FA 092E               1427mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007D6  0405 0030               1428mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007DA  CABC 000000FF           1429mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007E0  1A34 5000               1430mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007E4                          1431mm     ENDM
000007E4  8805                    1432m         OR.B D5,D4
000007E6  5307                    1433m         SUB.B #1,D7
000007E8                          1434m     ENDW
000007E8  6098                    1435ms     BRA _10000010
000007EA                          1436ms _10000011
000007EA                          1437m     
000007EA  7A00                    1438m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007EC  1A04                    1439m     MOVE.B D4,D5
000007EE  D484                    1440m     ADD.L D4,D2
000007F0                          1441m 
000007F0                          1442m     ENDM
000007F0                          1443                            
000007F0  2044                    1444                  MOVE.L D4,A0                    ; start address -> A0
000007F2  D1C9                    1445                  ADD.L A1,A0                         ; add in the offset
000007F4                          1446  
000007F4  72FF                    1447                  MOVE.L #$FFFFFFFF,D1             ; done
000007F6                          1448              ELSE
000007F6  6000 0078               1449s     BRA _00000009
000007FA                          1450s _00000008
000007FA                          1451m                 PRINT_CRLF D5,A4
000007FA  49FA 0931               1452m     LEA CRLF(PC),A4
000007FE                          1453mm     PRINT_STR A4,D5
000007FE                          1454mm LOOP_88
000007FE  0C14 0000               1455mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000802  6700 0016               1456mm     BEQ EXIT_88
00000806                          1457mmm     PRINT_CHAR (A4)+,D5
00000806                          1458mmm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000806                 TRUE     1459mmm     IFEQ DEBUG
00000806  1A39 00C00003           1460mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000080C  0805 0002               1461mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000810  67F4                    1462mmm         BEQ WAIT_FOR_READY_89                   ; NO SPACE, CHECK AGAIN
00000812  13DC 00C00007           1463mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000818                          1464mmm     ENDC
00000818                          1465mmm     
00000818                 FALSE    1466mmm     IFNE DEBUG
00000818                          1467mmm     ENDC
00000818                          1468mmm 
00000818                          1469mmm     ENDM
00000818  60E4                    1470mm     BRA LOOP_88
0000081A                          1471mm EXIT_88
0000081A                          1472mm     ENDM
0000081A                          1473m     ENDM
0000081A                          1474              
0000081A  49FA 089B               1475                  LEA UNREC(PC),A4                ; warn for unrecognised type
0000081E                          1476m                 PRINT_STR A4,D5
0000081E                          1477m LOOP_90
0000081E  0C14 0000               1478m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000822  6700 0016               1479m     BEQ EXIT_90
00000826                          1480mm     PRINT_CHAR (A4)+,D5
00000826                          1481mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1482mm     IFEQ DEBUG
00000826  1A39 00C00003           1483mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1484mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1485mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000832  13DC 00C00007           1486mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000838                          1487mm     ENDC
00000838                          1488mm     
00000838                 FALSE    1489mm     IFNE DEBUG
00000838                          1490mm     ENDC
00000838                          1491mm 
00000838                          1492mm     ENDM
00000838  60E4                    1493m     BRA LOOP_90
0000083A                          1494m EXIT_90
0000083A                          1495m     ENDM
0000083A                          1496m                 PRINT_CHAR D1,D5
0000083A                          1497m WAIT_FOR_READY_92                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083A                 TRUE     1498m     IFEQ DEBUG
0000083A  1A39 00C00003           1499m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000840  0805 0002               1500m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000844  67F4                    1501m         BEQ WAIT_FOR_READY_92                   ; NO SPACE, CHECK AGAIN
00000846  13C1 00C00007           1502m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000084C                          1503m     ENDC
0000084C                          1504m     
0000084C                 FALSE    1505m     IFNE DEBUG
0000084C                          1506m     ENDC
0000084C                          1507m 
0000084C                          1508m     ENDM
0000084C                          1509m                 PRINT_CRLF D5,A4
0000084C  49FA 08DF               1510m     LEA CRLF(PC),A4
00000850                          1511mm     PRINT_STR A4,D5
00000850                          1512mm LOOP_94
00000850  0C14 0000               1513mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000854  6700 0016               1514mm     BEQ EXIT_94
00000858                          1515mmm     PRINT_CHAR (A4)+,D5
00000858                          1516mmm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000858                 TRUE     1517mmm     IFEQ DEBUG
00000858  1A39 00C00003           1518mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000085E  0805 0002               1519mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000862  67F4                    1520mmm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00000864  13DC 00C00007           1521mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000086A                          1522mmm     ENDC
0000086A                          1523mmm     
0000086A                 FALSE    1524mmm     IFNE DEBUG
0000086A                          1525mmm     ENDC
0000086A                          1526mmm 
0000086A                          1527mmm     ENDM
0000086A  60E4                    1528mm     BRA LOOP_94
0000086C                          1529mm EXIT_94
0000086C                          1530mm     ENDM
0000086C                          1531m     ENDM
0000086C                          1532              
0000086C  6000 FAEC               1533                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000870                          1534              ENDI
00000870                          1535s _00000009
00000870                          1536          ENDI
00000870                          1537s _00000007
00000870                          1538      ENDI
00000870                          1539s _00000003
00000870                          1540      
00000870                          1541m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000870  1E3C 0002               1542m     MOVE.B #2,D7
00000874                          1543m     WHILE.B D7 <GT> 0 DO
00000874                          1544ms _10000012
00000874  BE38 0000               1545ms     CMP.B   0,D7
00000878  6F00 0062               1546ms     BLE _10000013
0000087C  E98C                    1547m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000087E                          1548mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000087E                          1549mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087E                          1550mm 
0000087E  1A39 00C00003           1551mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000884  0805 0000               1552mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000888  6700 0010               1553mm     BEQ CONTINUE_97                             ; NOTHING, CONTINUE
0000088C                          1554mm  
0000088C                          1555mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000088C                 TRUE     1556mmm     IFEQ DEBUG
0000088C  1A39 00C00007           1557mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000892                          1558mmm     ENDC
00000892                 FALSE    1559mmm     IFNE DEBUG
00000892                          1560mmm     ENDC
00000892                          1561mmm      
00000892  BA3C 001B               1562mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000896  6700 F770               1563mmm     BEQ START
0000089A                          1564mmm     ENDM
0000089A                          1565mm CONTINUE_97
0000089A  1A39 00C00013           1566mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008A0  0805 0000               1567mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008A4  67D8                    1568mm     BEQ WAIT_FOR_READY_97                           ; NOTHING, CHECK AGAIN
000008A6                          1569mm     
000008A6  1A39 00C00017           1570mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008AC  13C5 00E00001           1571mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008B2                          1572mm     
000008B2                          1573mm     ENDM
000008B2                          1574mm         PRINT_CHAR D5,D6
000008B2                          1575mm WAIT_FOR_READY_99                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B2                 TRUE     1576mm     IFEQ DEBUG
000008B2  1C39 00C00003           1577mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008B8  0806 0002               1578mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008BC  67F4                    1579mm         BEQ WAIT_FOR_READY_99                   ; NO SPACE, CHECK AGAIN
000008BE  13C5 00C00007           1580mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008C4                          1581mm     ENDC
000008C4                          1582mm     
000008C4                 FALSE    1583mm     IFNE DEBUG
000008C4                          1584mm     ENDC
000008C4                          1585mm 
000008C4                          1586mm     ENDM
000008C4                          1587mm         HEX2BIN D5,D5,A4
000008C4  49FA 083C               1588mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008C8  0405 0030               1589mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008CC  CABC 000000FF           1590mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008D2  1A34 5000               1591mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008D6                          1592mm     ENDM
000008D6  8805                    1593m         OR.B D5,D4
000008D8  5307                    1594m         SUB.B #1,D7
000008DA                          1595m     ENDW
000008DA  6098                    1596ms     BRA _10000012
000008DC                          1597ms _10000013
000008DC                          1598m     
000008DC  7A00                    1599m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008DE  1A04                    1600m     MOVE.B D4,D5
000008E0  D484                    1601m     ADD.L D4,D2
000008E2                          1602m 
000008E2                          1603m     ENDM
000008E2                          1604m     PRINT_CRLF D5,A4
000008E2  49FA 0849               1605m     LEA CRLF(PC),A4
000008E6                          1606mm     PRINT_STR A4,D5
000008E6                          1607mm LOOP_102
000008E6  0C14 0000               1608mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008EA  6700 0016               1609mm     BEQ EXIT_102
000008EE                          1610mmm     PRINT_CHAR (A4)+,D5
000008EE                          1611mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1612mmm     IFEQ DEBUG
000008EE  1A39 00C00003           1613mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008F4  0805 0002               1614mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1615mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
000008FA  13DC 00C00007           1616mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000900                          1617mmm     ENDC
00000900                          1618mmm     
00000900                 FALSE    1619mmm     IFNE DEBUG
00000900                          1620mmm     ENDC
00000900                          1621mmm 
00000900                          1622mmm     ENDM
00000900  60E4                    1623mm     BRA LOOP_102
00000902                          1624mm EXIT_102
00000902                          1625mm     ENDM
00000902                          1626m     ENDM
00000902                          1627          
00000902                          1628      IF.B D2 <NE> #$FF THEN.L
00000902  B43C 00FF               1629s     CMP.B   #$FF,D2
00000906  6700 0090               1630s     BEQ.L   _0000000A
0000090A  49FA 07C2               1631          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
0000090E                          1632m         PRINT_STR A4,D5
0000090E                          1633m LOOP_104
0000090E  0C14 0000               1634m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000912  6700 0016               1635m     BEQ EXIT_104
00000916                          1636mm     PRINT_CHAR (A4)+,D5
00000916                          1637mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                 TRUE     1638mm     IFEQ DEBUG
00000916  1A39 00C00003           1639mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000091C  0805 0002               1640mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000920  67F4                    1641mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000922  13DC 00C00007           1642mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000928                          1643mm     ENDC
00000928                          1644mm     
00000928                 FALSE    1645mm     IFNE DEBUG
00000928                          1646mm     ENDC
00000928                          1647mm 
00000928                          1648mm     ENDM
00000928  60E4                    1649m     BRA LOOP_104
0000092A                          1650m EXIT_104
0000092A                          1651m     ENDM
0000092A                          1652m         PRINT_REG D0,D5,D2,D6,A4
0000092A  49FA 0807               1653m     LEA OX(PC),A4
0000092E                          1654mm     PRINT_STR A4,D5
0000092E                          1655mm LOOP_107
0000092E  0C14 0000               1656mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000932  6700 0016               1657mm     BEQ EXIT_107
00000936                          1658mmm     PRINT_CHAR (A4)+,D5
00000936                          1659mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000936                 TRUE     1660mmm     IFEQ DEBUG
00000936  1A39 00C00003           1661mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000093C  0805 0002               1662mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000940  67F4                    1663mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000942  13DC 00C00007           1664mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000948                          1665mmm     ENDC
00000948                          1666mmm     
00000948                 FALSE    1667mmm     IFNE DEBUG
00000948                          1668mmm     ENDC
00000948                          1669mmm 
00000948                          1670mmm     ENDM
00000948  60E4                    1671mm     BRA LOOP_107
0000094A                          1672mm EXIT_107
0000094A                          1673mm     ENDM
0000094A  7C07                    1674m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000094C                          1675m LOOP_106
0000094C                          1676mm     BIN2HEX D0,D2,A4
0000094C  49FA 07A4               1677mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
00000950  E998                    1678mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000952  1400                    1679mm     MOVE.B D0,D2
00000954  0282 0000000F           1680mm     ANDI.L #$F,D2
0000095A  1434 2000               1681mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000095E                          1682mm     ENDM
0000095E                          1683mm     PRINT_CHAR D2,D5
0000095E                          1684mm WAIT_FOR_READY_110                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1685mm     IFEQ DEBUG
0000095E  1A39 00C00003           1686mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000964  0805 0002               1687mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000968  67F4                    1688mm         BEQ WAIT_FOR_READY_110                      ; NO SPACE, CHECK AGAIN
0000096A  13C2 00C00007           1689mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000970                          1690mm     ENDC
00000970                          1691mm     
00000970                 FALSE    1692mm     IFNE DEBUG
00000970                          1693mm     ENDC
00000970                          1694mm 
00000970                          1695mm     ENDM
00000970  57CE FFDA               1696m     DBEQ D6,LOOP_106
00000974                          1697m     ENDM
00000974                          1698m         PRINT_CRLF D5,A4
00000974  49FA 07B7               1699m     LEA CRLF(PC),A4
00000978                          1700mm     PRINT_STR A4,D5
00000978                          1701mm LOOP_112
00000978  0C14 0000               1702mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000097C  6700 0016               1703mm     BEQ EXIT_112
00000980                          1704mmm     PRINT_CHAR (A4)+,D5
00000980                          1705mmm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000980                 TRUE     1706mmm     IFEQ DEBUG
00000980  1A39 00C00003           1707mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000986  0805 0002               1708mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000098A  67F4                    1709mmm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
0000098C  13DC 00C00007           1710mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000992                          1711mmm     ENDC
00000992                          1712mmm     
00000992                 FALSE    1713mmm     IFNE DEBUG
00000992                          1714mmm     ENDC
00000992                          1715mmm 
00000992                          1716mmm     ENDM
00000992  60E4                    1717mm     BRA LOOP_112
00000994                          1718mm EXIT_112
00000994                          1719mm     ENDM
00000994                          1720m     ENDM
00000994  6000 F7A8               1721          BRA MAIN_LOOP
00000998                          1722      ENDI
00000998                          1723s _0000000A
00000998                          1724      
00000998                          1725      IF D1 <EQ> #0 THEN
00000998  B27C 0000               1726s     CMP.W   #0,D1
0000099C  6600 0006               1727s     BNE _0000000B
000009A0  6000 F9B8               1728        BRA WAIT_FOR_SRECORD            
000009A4                          1729      ENDI
000009A4                          1730s _0000000B
000009A4                          1731  DOWNLOAD_DONE
000009A4                          1732m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009A4  43FA 078D               1733m     LEA OX(PC),A1
000009A8                          1734mm     PRINT_STR A1,D5
000009A8                          1735mm LOOP_115
000009A8  0C11 0000               1736mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009AC  6700 0016               1737mm     BEQ EXIT_115
000009B0                          1738mmm     PRINT_CHAR (A1)+,D5
000009B0                          1739mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1740mmm     IFEQ DEBUG
000009B0  1A39 00C00003           1741mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B6  0805 0002               1742mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1743mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009BC  13D9 00C00007           1744mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009C2                          1745mmm     ENDC
000009C2                          1746mmm     
000009C2                 FALSE    1747mmm     IFNE DEBUG
000009C2                          1748mmm     ENDC
000009C2                          1749mmm 
000009C2                          1750mmm     ENDM
000009C2  60E4                    1751mm     BRA LOOP_115
000009C4                          1752mm EXIT_115
000009C4                          1753mm     ENDM
000009C4  7407                    1754m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009C6                          1755m LOOP_114
000009C6                          1756mm     BIN2HEX D0,D6,A1
000009C6  43FA 072A               1757mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009CA  E998                    1758mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009CC  1C00                    1759mm     MOVE.B D0,D6
000009CE  0286 0000000F           1760mm     ANDI.L #$F,D6
000009D4  1C31 6000               1761mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009D8                          1762mm     ENDM
000009D8                          1763mm     PRINT_CHAR D6,D5
000009D8                          1764mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1765mm     IFEQ DEBUG
000009D8  1A39 00C00003           1766mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1767mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1768mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
000009E4  13C6 00C00007           1769mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009EA                          1770mm     ENDC
000009EA                          1771mm     
000009EA                 FALSE    1772mm     IFNE DEBUG
000009EA                          1773mm     ENDC
000009EA                          1774mm 
000009EA                          1775mm     ENDM
000009EA  57CA FFDA               1776m     DBEQ D2,LOOP_114
000009EE                          1777m     ENDM
000009EE  43FA 06A5               1778      LEA READ(PC),A1
000009F2                          1779m     PRINT_STR A1,D5
000009F2                          1780m LOOP_119
000009F2  0C11 0000               1781m     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009F6  6700 0016               1782m     BEQ EXIT_119
000009FA                          1783mm     PRINT_CHAR (A1)+,D5
000009FA                          1784mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FA                 TRUE     1785mm     IFEQ DEBUG
000009FA  1A39 00C00003           1786mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A00  0805 0002               1787mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A04  67F4                    1788mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000A06  13D9 00C00007           1789mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A0C                          1790mm     ENDC
00000A0C                          1791mm     
00000A0C                 FALSE    1792mm     IFNE DEBUG
00000A0C                          1793mm     ENDC
00000A0C                          1794mm 
00000A0C                          1795mm     ENDM
00000A0C  60E4                    1796m     BRA LOOP_119
00000A0E                          1797m EXIT_119
00000A0E                          1798m     ENDM
00000A0E  2E08                    1799      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A10                          1800m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A10  43FA 0721               1801m     LEA OX(PC),A1
00000A14                          1802mm     PRINT_STR A1,D5
00000A14                          1803mm LOOP_122
00000A14  0C11 0000               1804mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A18  6700 0016               1805mm     BEQ EXIT_122
00000A1C                          1806mmm     PRINT_CHAR (A1)+,D5
00000A1C                          1807mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1C                 TRUE     1808mmm     IFEQ DEBUG
00000A1C  1A39 00C00003           1809mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A22  0805 0002               1810mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A26  67F4                    1811mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A28  13D9 00C00007           1812mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A2E                          1813mmm     ENDC
00000A2E                          1814mmm     
00000A2E                 FALSE    1815mmm     IFNE DEBUG
00000A2E                          1816mmm     ENDC
00000A2E                          1817mmm 
00000A2E                          1818mmm     ENDM
00000A2E  60E4                    1819mm     BRA LOOP_122
00000A30                          1820mm EXIT_122
00000A30                          1821mm     ENDM
00000A30  7407                    1822m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A32                          1823m LOOP_121
00000A32                          1824mm     BIN2HEX D7,D6,A1
00000A32  43FA 06BE               1825mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A36  E99F                    1826mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A38  1C07                    1827mm     MOVE.B D7,D6
00000A3A  0286 0000000F           1828mm     ANDI.L #$F,D6
00000A40  1C31 6000               1829mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A44                          1830mm     ENDM
00000A44                          1831mm     PRINT_CHAR D6,D5
00000A44                          1832mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A44                 TRUE     1833mm     IFEQ DEBUG
00000A44  1A39 00C00003           1834mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A4A  0805 0002               1835mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A4E  67F4                    1836mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000A50  13C6 00C00007           1837mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A56                          1838mm     ENDC
00000A56                          1839mm     
00000A56                 FALSE    1840mm     IFNE DEBUG
00000A56                          1841mm     ENDC
00000A56                          1842mm 
00000A56                          1843mm     ENDM
00000A56  57CA FFDA               1844m     DBEQ D2,LOOP_121
00000A5A                          1845m     ENDM
00000A5A                          1846m     PRINT_CRLF D5,A4     
00000A5A  49FA 06D1               1847m     LEA CRLF(PC),A4
00000A5E                          1848mm     PRINT_STR A4,D5
00000A5E                          1849mm LOOP_127
00000A5E  0C14 0000               1850mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A62  6700 0016               1851mm     BEQ EXIT_127
00000A66                          1852mmm     PRINT_CHAR (A4)+,D5
00000A66                          1853mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                 TRUE     1854mmm     IFEQ DEBUG
00000A66  1A39 00C00003           1855mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A6C  0805 0002               1856mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A70  67F4                    1857mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A72  13DC 00C00007           1858mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A78                          1859mmm     ENDC
00000A78                          1860mmm     
00000A78                 FALSE    1861mmm     IFNE DEBUG
00000A78                          1862mmm     ENDC
00000A78                          1863mmm 
00000A78                          1864mmm     ENDM
00000A78  60E4                    1865mm     BRA LOOP_127
00000A7A                          1866mm EXIT_127
00000A7A                          1867mm     ENDM
00000A7A                          1868m     ENDM
00000A7A                          1869          
00000A7A  6000 F6C2               1870      BRA MAIN_LOOP
00000A7E                          1871      
00000A7E                          1872  G
00000A7E  2047                    1873      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A80  3E3C 0000               1874      MOVE #0,D7                                      ; clear the now used address accumulator
00000A84  4ED0                    1875      JMP (A0)                                        ; jump to it!
00000A86                          1876      
00000A86                          1877  Z
00000A86  207C 00200000           1878      MOVE.L #RAM,A0                                  ; address of RAM
00000A8C                          1879      
00000A8C                          1880      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A8C  7000                    1881s     MOVE.L  #0,D0
00000A8E  6000 0012               1882s     BRA _20000005
00000A92                          1883s _20000004
00000A92  2200                    1884          MOVE.L D0,D1                              ; progress update
00000A94  E089                    1885          LSR.L #8,D1 
00000A96  E089                    1886          LSR.L #8,D1
00000A98  13C1 00E00001           1887          MOVE.B D1,DISPLAY
00000A9E                          1888  
00000A9E  20C0                    1889          MOVE.L D0,(A0)+
00000AA0                          1890      ENDF
00000AA0  5880                    1891s     ADD.L   #4,D0
00000AA2                          1892s _20000005
00000AA2  B0BC 00040000           1893s     CMP.L   #$40000,D0
00000AA8  6FE8                    1894s     BLE _20000004
00000AAA                          1895   
00000AAA  207C 00200000           1896      MOVE.L #RAM,A0                                    ; address of RAM
00000AB0                          1897     
00000AB0                          1898      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AB0  7000                    1899s     MOVE.L  #0,D0
00000AB2  6000 00A6               1900s     BRA _20000007
00000AB6                          1901s _20000006
00000AB6  2200                    1902          MOVE.L D0,D1                              ; progress update
00000AB8  E089                    1903          LSR.L #8,D1
00000ABA  E089                    1904          LSR.L #8,D1
00000ABC  13C1 00E00001           1905          MOVE.B D1,DISPLAY
00000AC2                          1906  
00000AC2  2218                    1907          MOVE.L (A0)+,D1
00000AC4                          1908            
00000AC4                          1909          IF.L D0 <NE> D1 THEN      
00000AC4  B081                    1910s     CMP.L   D1,D0
00000AC6  6700 0090               1911s     BEQ _0000000C
00000ACA  43FA 0614               1912              LEA RAM_ERROR(PC),A1
00000ACE                          1913m             PRINT_STR A1,D1
00000ACE                          1914m LOOP_129
00000ACE  0C11 0000               1915m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AD2  6700 0016               1916m     BEQ EXIT_129
00000AD6                          1917mm     PRINT_CHAR (A1)+,D1
00000AD6                          1918mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD6                 TRUE     1919mm     IFEQ DEBUG
00000AD6  1239 00C00003           1920mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000ADC  0801 0002               1921mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000AE0  67F4                    1922mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000AE2  13D9 00C00007           1923mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AE8                          1924mm     ENDC
00000AE8                          1925mm     
00000AE8                 FALSE    1926mm     IFNE DEBUG
00000AE8                          1927mm     ENDC
00000AE8                          1928mm 
00000AE8                          1929mm     ENDM
00000AE8  60E4                    1930m     BRA LOOP_129
00000AEA                          1931m EXIT_129
00000AEA                          1932m     ENDM
00000AEA  2208                    1933              MOVE.L A0,D1
00000AEC  5981                    1934              SUB.L #4,D1
00000AEE                          1935m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AEE  43FA 0643               1936m     LEA OX(PC),A1
00000AF2                          1937mm     PRINT_STR A1,D3
00000AF2                          1938mm LOOP_132
00000AF2  0C11 0000               1939mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AF6  6700 0016               1940mm     BEQ EXIT_132
00000AFA                          1941mmm     PRINT_CHAR (A1)+,D3
00000AFA                          1942mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFA                 TRUE     1943mmm     IFEQ DEBUG
00000AFA  1639 00C00003           1944mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B00  0803 0002               1945mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B04  67F4                    1946mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B06  13D9 00C00007           1947mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B0C                          1948mmm     ENDC
00000B0C                          1949mmm     
00000B0C                 FALSE    1950mmm     IFNE DEBUG
00000B0C                          1951mmm     ENDC
00000B0C                          1952mmm 
00000B0C                          1953mmm     ENDM
00000B0C  60E4                    1954mm     BRA LOOP_132
00000B0E                          1955mm EXIT_132
00000B0E                          1956mm     ENDM
00000B0E  7C07                    1957m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B10                          1958m LOOP_131
00000B10                          1959mm     BIN2HEX D1,D2,A1
00000B10  43FA 05E0               1960mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B14  E999                    1961mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B16  1401                    1962mm     MOVE.B D1,D2
00000B18  0282 0000000F           1963mm     ANDI.L #$F,D2
00000B1E  1431 2000               1964mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B22                          1965mm     ENDM
00000B22                          1966mm     PRINT_CHAR D2,D3
00000B22                          1967mm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B22                 TRUE     1968mm     IFEQ DEBUG
00000B22  1639 00C00003           1969mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B28  0803 0002               1970mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B2C  67F4                    1971mm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00000B2E  13C2 00C00007           1972mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B34                          1973mm     ENDC
00000B34                          1974mm     
00000B34                 FALSE    1975mm     IFNE DEBUG
00000B34                          1976mm     ENDC
00000B34                          1977mm 
00000B34                          1978mm     ENDM
00000B34  57CE FFDA               1979m     DBEQ D6,LOOP_131
00000B38                          1980m     ENDM
00000B38                          1981m             PRINT_CRLF D3,A1
00000B38  43FA 05F3               1982m     LEA CRLF(PC),A1
00000B3C                          1983mm     PRINT_STR A1,D3
00000B3C                          1984mm LOOP_137
00000B3C  0C11 0000               1985mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B40  6700 0016               1986mm     BEQ EXIT_137
00000B44                          1987mmm     PRINT_CHAR (A1)+,D3
00000B44                          1988mmm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B44                 TRUE     1989mmm     IFEQ DEBUG
00000B44  1639 00C00003           1990mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B4A  0803 0002               1991mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B4E  67F4                    1992mmm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B50  13D9 00C00007           1993mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B56                          1994mmm     ENDC
00000B56                          1995mmm     
00000B56                 FALSE    1996mmm     IFNE DEBUG
00000B56                          1997mmm     ENDC
00000B56                          1998mmm 
00000B56                          1999mmm     ENDM
00000B56  60E4                    2000mm     BRA LOOP_137
00000B58                          2001mm EXIT_137
00000B58                          2002mm     ENDM
00000B58                          2003m     ENDM
00000B58                          2004          ENDI 
00000B58                          2005s _0000000C
00000B58                          2006      ENDF
00000B58  5880                    2007s     ADD.L   #4,D0
00000B5A                          2008s _20000007
00000B5A  B0BC 00040000           2009s     CMP.L   #$40000,D0
00000B60  6F00 FF54               2010s     BLE _20000006
00000B64                          2011      
00000B64  6000 F5D8               2012      BRA MAIN_LOOP
00000B68                          2013    
00000B68                          2014  L
00000B68  7000                    2015      MOVE.L #0,D0                                    ; D0 will be the length  to write            
00000B6A  7200                    2016      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B6C                          2017  
00000B6C                          2018      FOR D2 = #0 TO #7 DO                          ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B6C  343C 0000               2019s     MOVE.W  #0,D2
00000B70  6000 0046               2020s     BRA _20000009
00000B74                          2021s _20000008
00000B74  E989                    2022          LSL.L #4,D1                                 ; make what we have so far more significant
00000B76                          2023m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B76                          2024m WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B76                 TRUE     2025m     IFEQ DEBUG
00000B76  1839 00C00003           2026m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B7C  0804 0000               2027m         BTST #0,D4                              ; CHECK FOR CHARACTER
00000B80  67F4                    2028m         BEQ WAIT_FOR_READY_139                      ; NOTHING, CHECK AGAIN
00000B82                          2029m     ENDC
00000B82                          2030m     
00000B82                          2031mm     READ_CHAR D3
00000B82                 TRUE     2032mm     IFEQ DEBUG
00000B82  1639 00C00007           2033mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B88                          2034mm     ENDC
00000B88                 FALSE    2035mm     IFNE DEBUG
00000B88                          2036mm     ENDC
00000B88                          2037mm      
00000B88  B63C 001B               2038mm     CMP.B #$1B,D3                               ; CHECK FOR ESCAPE AND GO TO START
00000B8C  6700 F47A               2039mm     BEQ START
00000B90                          2040mm     ENDM
00000B90                          2041m 
00000B90                 TRUE     2042m     IFEQ DEBUG
00000B90                          2043mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B90                          2044mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     2045mm     IFEQ DEBUG
00000B90  1839 00C00003           2046mm         MOVE.B DUART_SRA,D4                     ; READ STATUS REGISTER
00000B96  0804 0002               2047mm         BTST #2,D4                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    2048mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B9C  13C3 00C00007           2049mm         MOVE.B D3,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BA2                          2050mm     ENDC
00000BA2                          2051mm     
00000BA2                 FALSE    2052mm     IFNE DEBUG
00000BA2                          2053mm     ENDC
00000BA2                          2054mm 
00000BA2                          2055mm     ENDM
00000BA2                          2056m     ENDC
00000BA2                          2057m     ENDM
00000BA2                          2058m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BA2  41FA 055E               2059m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BA6  0403 0030               2060m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BAA  C6BC 000000FF           2061m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BB0  1630 3000               2062m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BB4                          2063m     ENDM
00000BB4  8203                    2064          OR.B D3,D1
00000BB6                          2065      ENDF
00000BB6  5242                    2066s     ADD.W   #1,D2
00000BB8                          2067s _20000009
00000BB8  B47C 0007               2068s     CMP.W   #7,D2
00000BBC  6FB6                    2069s     BLE _20000008
00000BBE                          2070      
00000BBE  3001                    2071      MOVE.W D1,D0                                  ; extract the LSword for the length
00000BC0  E089                    2072      LSR.L #8,D1                                   ; extract the MSword for the address
00000BC2  E089                    2073      LSR.L #8,D1                                   
00000BC4                          2074                        
00000BC4                          2075m     PRINT_CRLF D2,A1
00000BC4  43FA 0567               2076m     LEA CRLF(PC),A1
00000BC8                          2077mm     PRINT_STR A1,D2
00000BC8                          2078mm LOOP_144
00000BC8  0C11 0000               2079mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000BCC  6700 0016               2080mm     BEQ EXIT_144
00000BD0                          2081mmm     PRINT_CHAR (A1)+,D2
00000BD0                          2082mmm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     2083mmm     IFEQ DEBUG
00000BD0  1439 00C00003           2084mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000BD6  0802 0002               2085mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    2086mmm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000BDC  13D9 00C00007           2087mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BE2                          2088mmm     ENDC
00000BE2                          2089mmm     
00000BE2                 FALSE    2090mmm     IFNE DEBUG
00000BE2                          2091mmm     ENDC
00000BE2                          2092mmm 
00000BE2                          2093mmm     ENDM
00000BE2  60E4                    2094mm     BRA LOOP_144
00000BE4                          2095mm EXIT_144
00000BE4                          2096mm     ENDM
00000BE4                          2097m     ENDM
00000BE4                          2098  
00000BE4  2041                    2099      MOVE.L D1,A0                                ; target address
00000BE6                          2100      
00000BE6  2247                    2101      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BE8  7E00                    2102      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BEA                          2103  
00000BEA  5089                    2104      ADD.L #8,A1                                   ; skip the initial stack pointer and reset vector for now
00000BEC  5180                    2105      SUB.L #8,D0
00000BEE                          2106      
00000BEE                          2107m     UNPROTECT
00000BEE  31FC AAAA 2AAA          2108m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000BF4  4E71                    2109m     NOP
00000BF6  31FC 5555 1554          2110m     MOVE.W #$5555,$1554
00000BFC  4E71                    2111m     NOP
00000BFE  31FC 8080 2AAA          2112m     MOVE.W #$8080,$2AAA
00000C04  4E71                    2113m     NOP
00000C06  31FC AAAA 2AAA          2114m     MOVE.W #$AAAA,$2AAA
00000C0C  4E71                    2115m     NOP
00000C0E  31FC 5555 1554          2116m     MOVE.W #$5555,$1554
00000C14  4E71                    2117m     NOP
00000C16  31FC 2020 2AAA          2118m     MOVE.W #$2020,$2AAA
00000C1C                          2119m     ENDM
00000C1C                          2120      
00000C1C  45FA 04FB               2121      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00000C20                          2122m     PRINT_STR A2,D2
00000C20                          2123m LOOP_147
00000C20  0C12 0000               2124m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C24  6700 0016               2125m     BEQ EXIT_147
00000C28                          2126mm     PRINT_CHAR (A2)+,D2
00000C28                          2127mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C28                 TRUE     2128mm     IFEQ DEBUG
00000C28  1439 00C00003           2129mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000C2E  0802 0002               2130mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000C32  67F4                    2131mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C34  13DA 00C00007           2132mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C3A                          2133mm     ENDC
00000C3A                          2134mm     
00000C3A                 FALSE    2135mm     IFNE DEBUG
00000C3A                          2136mm     ENDC
00000C3A                          2137mm 
00000C3A                          2138mm     ENDM
00000C3A  60E4                    2139m     BRA LOOP_147
00000C3C                          2140m EXIT_147
00000C3C                          2141m     ENDM
00000C3C                          2142      
00000C3C  2409                    2143      MOVE.L A1,D2                
00000C3E                          2144m     PRINT_REG D2,D3,D4,D5,A2
00000C3E  45FA 04F3               2145m     LEA OX(PC),A2
00000C42                          2146mm     PRINT_STR A2,D3
00000C42                          2147mm LOOP_150
00000C42  0C12 0000               2148mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C46  6700 0016               2149mm     BEQ EXIT_150
00000C4A                          2150mmm     PRINT_CHAR (A2)+,D3
00000C4A                          2151mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2152mmm     IFEQ DEBUG
00000C4A  1639 00C00003           2153mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C50  0803 0002               2154mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2155mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C56  13DA 00C00007           2156mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C5C                          2157mmm     ENDC
00000C5C                          2158mmm     
00000C5C                 FALSE    2159mmm     IFNE DEBUG
00000C5C                          2160mmm     ENDC
00000C5C                          2161mmm 
00000C5C                          2162mmm     ENDM
00000C5C  60E4                    2163mm     BRA LOOP_150
00000C5E                          2164mm EXIT_150
00000C5E                          2165mm     ENDM
00000C5E  7A07                    2166m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C60                          2167m LOOP_149
00000C60                          2168mm     BIN2HEX D2,D4,A2
00000C60  45FA 0490               2169mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000C64  E99A                    2170mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C66  1802                    2171mm     MOVE.B D2,D4
00000C68  0284 0000000F           2172mm     ANDI.L #$F,D4
00000C6E  1832 4000               2173mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000C72                          2174mm     ENDM
00000C72                          2175mm     PRINT_CHAR D4,D3
00000C72                          2176mm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C72                 TRUE     2177mm     IFEQ DEBUG
00000C72  1639 00C00003           2178mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C78  0803 0002               2179mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C7C  67F4                    2180mm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C7E  13C4 00C00007           2181mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C84                          2182mm     ENDC
00000C84                          2183mm     
00000C84                 FALSE    2184mm     IFNE DEBUG
00000C84                          2185mm     ENDC
00000C84                          2186mm 
00000C84                          2187mm     ENDM
00000C84  57CD FFDA               2188m     DBEQ D5,LOOP_149
00000C88                          2189m     ENDM
00000C88                          2190  
00000C88  45FA 04AC               2191      LEA TO(PC),A2
00000C8C                          2192m     PRINT_STR A2,D3
00000C8C                          2193m LOOP_154
00000C8C  0C12 0000               2194m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C90  6700 0016               2195m     BEQ EXIT_154
00000C94                          2196mm     PRINT_CHAR (A2)+,D3
00000C94                          2197mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2198mm     IFEQ DEBUG
00000C94  1639 00C00003           2199mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C9A  0803 0002               2200mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2201mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000CA0  13DA 00C00007           2202mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CA6                          2203mm     ENDC
00000CA6                          2204mm     
00000CA6                 FALSE    2205mm     IFNE DEBUG
00000CA6                          2206mm     ENDC
00000CA6                          2207mm 
00000CA6                          2208mm     ENDM
00000CA6  60E4                    2209m     BRA LOOP_154
00000CA8                          2210m EXIT_154
00000CA8                          2211m     ENDM
00000CA8                          2212      
00000CA8  2408                    2213      MOVE.L A0,D2                
00000CAA                          2214m     PRINT_REG D2,D3,D4,D5,A2
00000CAA  45FA 0487               2215m     LEA OX(PC),A2
00000CAE                          2216mm     PRINT_STR A2,D3
00000CAE                          2217mm LOOP_157
00000CAE  0C12 0000               2218mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CB2  6700 0016               2219mm     BEQ EXIT_157
00000CB6                          2220mmm     PRINT_CHAR (A2)+,D3
00000CB6                          2221mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2222mmm     IFEQ DEBUG
00000CB6  1639 00C00003           2223mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CBC  0803 0002               2224mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2225mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000CC2  13DA 00C00007           2226mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CC8                          2227mmm     ENDC
00000CC8                          2228mmm     
00000CC8                 FALSE    2229mmm     IFNE DEBUG
00000CC8                          2230mmm     ENDC
00000CC8                          2231mmm 
00000CC8                          2232mmm     ENDM
00000CC8  60E4                    2233mm     BRA LOOP_157
00000CCA                          2234mm EXIT_157
00000CCA                          2235mm     ENDM
00000CCA  7A07                    2236m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCC                          2237m LOOP_156
00000CCC                          2238mm     BIN2HEX D2,D4,A2
00000CCC  45FA 0424               2239mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000CD0  E99A                    2240mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD2  1802                    2241mm     MOVE.B D2,D4
00000CD4  0284 0000000F           2242mm     ANDI.L #$F,D4
00000CDA  1832 4000               2243mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000CDE                          2244mm     ENDM
00000CDE                          2245mm     PRINT_CHAR D4,D3
00000CDE                          2246mm WAIT_FOR_READY_160                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDE                 TRUE     2247mm     IFEQ DEBUG
00000CDE  1639 00C00003           2248mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CE4  0803 0002               2249mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CE8  67F4                    2250mm         BEQ WAIT_FOR_READY_160                      ; NO SPACE, CHECK AGAIN
00000CEA  13C4 00C00007           2251mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CF0                          2252mm     ENDC
00000CF0                          2253mm     
00000CF0                 FALSE    2254mm     IFNE DEBUG
00000CF0                          2255mm     ENDC
00000CF0                          2256mm 
00000CF0                          2257mm     ENDM
00000CF0  57CD FFDA               2258m     DBEQ D5,LOOP_156
00000CF4                          2259m     ENDM
00000CF4                          2260  
00000CF4                          2261m     PRINT_CRLF D3,A2
00000CF4  45FA 0437               2262m     LEA CRLF(PC),A2
00000CF8                          2263mm     PRINT_STR A2,D3
00000CF8                          2264mm LOOP_162
00000CF8  0C12 0000               2265mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000CFC  6700 0016               2266mm     BEQ EXIT_162
00000D00                          2267mmm     PRINT_CHAR (A2)+,D3
00000D00                          2268mmm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2269mmm     IFEQ DEBUG
00000D00  1639 00C00003           2270mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D06  0803 0002               2271mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2272mmm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D0C  13DA 00C00007           2273mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000D12                          2274mmm     ENDC
00000D12                          2275mmm     
00000D12                 FALSE    2276mmm     IFNE DEBUG
00000D12                          2277mmm     ENDC
00000D12                          2278mmm 
00000D12                          2279mmm     ENDM
00000D12  60E4                    2280mm     BRA LOOP_162
00000D14                          2281mm EXIT_162
00000D14                          2282mm     ENDM
00000D14                          2283m     ENDM
00000D14                          2284  
00000D14                          2285      WHILE D0 <GT> #0 DO
00000D14                          2286s _10000014
00000D14  B07C 0000               2287s     CMP.W   #0,D0
00000D18  6F00 001C               2288s     BLE _10000015
00000D1C  5580                    2289          SUB.L #2,D0
00000D1E                          2290        
00000D1E  13D1 00E00001           2291          MOVE.B (A1),DISPLAY
00000D24                          2292m         PROGRAM (A1),(A0),D2
00000D24  3091                    2293m   MOVE.W (A1),(A0)                          ; WRITE THE DATA
00000D26                          2294m       
00000D26                          2295m WAIT_FOR_COMPLETE_164
00000D26  3410                    2296m         MOVE.W (A0),D2
00000D28                          2297m 
00000D28                          2298m         IF.W D2 <NE> (A1) THEN
00000D28  B451                    2299ms     CMP.W   (A1),D2
00000D2A  6700 0004               2300ms     BEQ _0000000D
00000D2E  60F6                    2301m             BRA WAIT_FOR_COMPLETE_164
00000D30                          2302m         ENDI
00000D30                          2303ms _0000000D
00000D30                          2304m         ENDM
00000D30                          2305                
00000D30  5488                    2306          ADD.L #2,A0
00000D32  5489                    2307          ADD.L #2,A1
00000D34                          2308      ENDW
00000D34  60DE                    2309s     BRA _10000014
00000D36                          2310s _10000015
00000D36                          2311      
00000D36                          2312m     PROGRAM #0, $0, D2                         ; we're done, can now update the SP and start vector
00000D36  31FC 0000 0000          2313m   MOVE.W #0,$0                          ; WRITE THE DATA
00000D3C                          2314m       
00000D3C                          2315m WAIT_FOR_COMPLETE_165
00000D3C  3438 0000               2316m         MOVE.W $0,D2
00000D40                          2317m 
00000D40                          2318m         IF.W D2 <NE> #0 THEN
00000D40  B47C 0000               2319ms     CMP.W   #0,D2
00000D44  6700 0004               2320ms     BEQ _0000000E
00000D48  60F2                    2321m             BRA WAIT_FOR_COMPLETE_165
00000D4A                          2322m         ENDI
00000D4A                          2323ms _0000000E
00000D4A                          2324m         ENDM
00000D4A                          2325m     PROGRAM #0, $2, D2                         ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D4A  31FC 0000 0002          2326m   MOVE.W #0,$2                          ; WRITE THE DATA
00000D50                          2327m       
00000D50                          2328m WAIT_FOR_COMPLETE_166
00000D50  3438 0002               2329m         MOVE.W $2,D2
00000D54                          2330m 
00000D54                          2331m         IF.W D2 <NE> #0 THEN
00000D54  B47C 0000               2332ms     CMP.W   #0,D2
00000D58  6700 0004               2333ms     BEQ _0000000F
00000D5C  60F2                    2334m             BRA WAIT_FOR_COMPLETE_166
00000D5E                          2335m         ENDI
00000D5E                          2336ms _0000000F
00000D5E                          2337m         ENDM
00000D5E                          2338  
00000D5E                          2339m     PROGRAM D1, $6, D2
00000D5E  31C1 0006               2340m   MOVE.W D1,$6                          ; WRITE THE DATA
00000D62                          2341m       
00000D62                          2342m WAIT_FOR_COMPLETE_167
00000D62  3438 0006               2343m         MOVE.W $6,D2
00000D66                          2344m 
00000D66                          2345m         IF.W D2 <NE> D1 THEN
00000D66  B441                    2346ms     CMP.W   D1,D2
00000D68  6700 0004               2347ms     BEQ _00000010
00000D6C  60F4                    2348m             BRA WAIT_FOR_COMPLETE_167
00000D6E                          2349m         ENDI
00000D6E                          2350ms _00000010
00000D6E                          2351m         ENDM
00000D6E  E089                    2352      LSR.L #8,D1
00000D70  E089                    2353      LSR.L #8,D1
00000D72                          2354m     PROGRAM D1, $4, D2                         
00000D72  31C1 0004               2355m   MOVE.W D1,$4                          ; WRITE THE DATA
00000D76                          2356m       
00000D76                          2357m WAIT_FOR_COMPLETE_168
00000D76  3438 0004               2358m         MOVE.W $4,D2
00000D7A                          2359m 
00000D7A                          2360m         IF.W D2 <NE> D1 THEN
00000D7A  B441                    2361ms     CMP.W   D1,D2
00000D7C  6700 0004               2362ms     BEQ _00000011
00000D80  60F4                    2363m             BRA WAIT_FOR_COMPLETE_168
00000D82                          2364m         ENDI
00000D82                          2365ms _00000011
00000D82                          2366m         ENDM
00000D82                          2367  
00000D82                          2368m     PROTECT
00000D82  31FC AAAA 2AAA          2369m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000D88  31FC 5555 1554          2370m     MOVE.W #$5555,$1554
00000D8E  31FC A0A0 2AAA          2371m     MOVE.W #$A0A0,$2AAA
00000D94                          2372m     ENDM
00000D94                          2373        
00000D94  6000 F3A8               2374      BRA MAIN_LOOP
00000D98                          2375      
00000D98                          2376  P
00000D98  7000                    2377      MOVE.L #0,D0                                    ; D0 will be the data to write            
00000D9A                          2378  
00000D9A                          2379      FOR D1 = #0 TO #3 DO                           ; read 2 bytes
00000D9A  323C 0000               2380s     MOVE.W  #0,D1
00000D9E  6000 0046               2381s     BRA _2000000B
00000DA2                          2382s _2000000A
00000DA2  E988                    2383          LSL.L #4,D0                                 ; make what we have so far more significant
00000DA4                          2384m         WAIT_CHAR D2,D3                             ; next character -> D2
00000DA4                          2385m WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA4                 TRUE     2386m     IFEQ DEBUG
00000DA4  1639 00C00003           2387m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DAA  0803 0000               2388m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000DAE  67F4                    2389m         BEQ WAIT_FOR_READY_170                      ; NOTHING, CHECK AGAIN
00000DB0                          2390m     ENDC
00000DB0                          2391m     
00000DB0                          2392mm     READ_CHAR D2
00000DB0                 TRUE     2393mm     IFEQ DEBUG
00000DB0  1439 00C00007           2394mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000DB6                          2395mm     ENDC
00000DB6                 FALSE    2396mm     IFNE DEBUG
00000DB6                          2397mm     ENDC
00000DB6                          2398mm      
00000DB6  B43C 001B               2399mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000DBA  6700 F24C               2400mm     BEQ START
00000DBE                          2401mm     ENDM
00000DBE                          2402m 
00000DBE                 TRUE     2403m     IFEQ DEBUG
00000DBE                          2404mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000DBE                          2405mm WAIT_FOR_READY_172                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBE                 TRUE     2406mm     IFEQ DEBUG
00000DBE  1639 00C00003           2407mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DC4  0803 0002               2408mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DC8  67F4                    2409mm         BEQ WAIT_FOR_READY_172                      ; NO SPACE, CHECK AGAIN
00000DCA  13C2 00C00007           2410mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000DD0                          2411mm     ENDC
00000DD0                          2412mm     
00000DD0                 FALSE    2413mm     IFNE DEBUG
00000DD0                          2414mm     ENDC
00000DD0                          2415mm 
00000DD0                          2416mm     ENDM
00000DD0                          2417m     ENDC
00000DD0                          2418m     ENDM
00000DD0                          2419m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000DD0  41FA 0330               2420m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000DD4  0402 0030               2421m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DD8  C4BC 000000FF           2422m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000DDE  1430 2000               2423m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000DE2                          2424m     ENDM
00000DE2  8002                    2425          OR.B D2,D0
00000DE4                          2426      ENDF
00000DE4  5241                    2427s     ADD.W   #1,D1
00000DE6                          2428s _2000000B
00000DE6  B27C 0003               2429s     CMP.W   #3,D1
00000DEA  6FB6                    2430s     BLE _2000000A
00000DEC                          2431         
00000DEC                          2432m     PRINT_CRLF D2,A1
00000DEC  43FA 033F               2433m     LEA CRLF(PC),A1
00000DF0                          2434mm     PRINT_STR A1,D2
00000DF0                          2435mm LOOP_175
00000DF0  0C11 0000               2436mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000DF4  6700 0016               2437mm     BEQ EXIT_175
00000DF8                          2438mmm     PRINT_CHAR (A1)+,D2
00000DF8                          2439mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF8                 TRUE     2440mmm     IFEQ DEBUG
00000DF8  1439 00C00003           2441mmm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000DFE  0802 0002               2442mmm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000E02  67F4                    2443mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000E04  13D9 00C00007           2444mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E0A                          2445mmm     ENDC
00000E0A                          2446mmm     
00000E0A                 FALSE    2447mmm     IFNE DEBUG
00000E0A                          2448mmm     ENDC
00000E0A                          2449mmm 
00000E0A                          2450mmm     ENDM
00000E0A  60E4                    2451mm     BRA LOOP_175
00000E0C                          2452mm EXIT_175
00000E0C                          2453mm     ENDM
00000E0C                          2454m     ENDM
00000E0C                          2455      
00000E0C  2047                    2456      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000E0E  7E00                    2457      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E10                          2458      
00000E10  31FC AAAA 2AAA          2459      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000E16                          2460  
00000E16                          2461m     UNPROTECT
00000E16  31FC AAAA 2AAA          2462m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E1C  4E71                    2463m     NOP
00000E1E  31FC 5555 1554          2464m     MOVE.W #$5555,$1554
00000E24  4E71                    2465m     NOP
00000E26  31FC 8080 2AAA          2466m     MOVE.W #$8080,$2AAA
00000E2C  4E71                    2467m     NOP
00000E2E  31FC AAAA 2AAA          2468m     MOVE.W #$AAAA,$2AAA
00000E34  4E71                    2469m     NOP
00000E36  31FC 5555 1554          2470m     MOVE.W #$5555,$1554
00000E3C  4E71                    2471m     NOP
00000E3E  31FC 2020 2AAA          2472m     MOVE.W #$2020,$2AAA
00000E44                          2473m     ENDM
00000E44                          2474            
00000E44  45FA 02D3               2475      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00000E48                          2476m     PRINT_STR A2,D2
00000E48                          2477m LOOP_178
00000E48  0C12 0000               2478m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000E4C  6700 0016               2479m     BEQ EXIT_178
00000E50                          2480mm     PRINT_CHAR (A2)+,D2
00000E50                          2481mm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E50                 TRUE     2482mm     IFEQ DEBUG
00000E50  1439 00C00003           2483mm         MOVE.B DUART_SRA,D2                     ; READ STATUS REGISTER
00000E56  0802 0002               2484mm         BTST #2,D2                              ; CHECK FOR SPACE TO SEND
00000E5A  67F4                    2485mm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000E5C  13DA 00C00007           2486mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E62                          2487mm     ENDC
00000E62                          2488mm     
00000E62                 FALSE    2489mm     IFNE DEBUG
00000E62                          2490mm     ENDC
00000E62                          2491mm 
00000E62                          2492mm     ENDM
00000E62  60E4                    2493m     BRA LOOP_178
00000E64                          2494m EXIT_178
00000E64                          2495m     ENDM
00000E64                          2496      
00000E64                          2497m     PRINT_CHAR '#',D3
00000E64                          2498m WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E64                 TRUE     2499m     IFEQ DEBUG
00000E64  1639 00C00003           2500m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E6A  0803 0002               2501m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E6E  67F4                    2502m         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E70  13F8 0023 00C00007      2503m         MOVE.B '#',DUART_TXA                    ; SEND THE NEXT CHARACTER
00000E78                          2504m     ENDC
00000E78                          2505m     
00000E78                 FALSE    2506m     IFNE DEBUG
00000E78                          2507m     ENDC
00000E78                          2508m 
00000E78                          2509m     ENDM
00000E78                          2510m     PRINT_REG D0,D3,D4,D5,A2
00000E78  45FA 02B9               2511m     LEA OX(PC),A2
00000E7C                          2512mm     PRINT_STR A2,D3
00000E7C                          2513mm LOOP_182
00000E7C  0C12 0000               2514mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000E80  6700 0016               2515mm     BEQ EXIT_182
00000E84                          2516mmm     PRINT_CHAR (A2)+,D3
00000E84                          2517mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E84                 TRUE     2518mmm     IFEQ DEBUG
00000E84  1639 00C00003           2519mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E8A  0803 0002               2520mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E8E  67F4                    2521mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000E90  13DA 00C00007           2522mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E96                          2523mmm     ENDC
00000E96                          2524mmm     
00000E96                 FALSE    2525mmm     IFNE DEBUG
00000E96                          2526mmm     ENDC
00000E96                          2527mmm 
00000E96                          2528mmm     ENDM
00000E96  60E4                    2529mm     BRA LOOP_182
00000E98                          2530mm EXIT_182
00000E98                          2531mm     ENDM
00000E98  7A07                    2532m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E9A                          2533m LOOP_181
00000E9A                          2534mm     BIN2HEX D0,D4,A2
00000E9A  45FA 0256               2535mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000E9E  E998                    2536mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EA0  1800                    2537mm     MOVE.B D0,D4
00000EA2  0284 0000000F           2538mm     ANDI.L #$F,D4
00000EA8  1832 4000               2539mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000EAC                          2540mm     ENDM
00000EAC                          2541mm     PRINT_CHAR D4,D3
00000EAC                          2542mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EAC                 TRUE     2543mm     IFEQ DEBUG
00000EAC  1639 00C00003           2544mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000EB2  0803 0002               2545mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000EB6  67F4                    2546mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00000EB8  13C4 00C00007           2547mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000EBE                          2548mm     ENDC
00000EBE                          2549mm     
00000EBE                 FALSE    2550mm     IFNE DEBUG
00000EBE                          2551mm     ENDC
00000EBE                          2552mm 
00000EBE                          2553mm     ENDM
00000EBE  57CD FFDA               2554m     DBEQ D5,LOOP_181
00000EC2                          2555m     ENDM
00000EC2                          2556  
00000EC2  45FA 0272               2557      LEA TO(PC),A2
00000EC6                          2558m     PRINT_STR A2,D3
00000EC6                          2559m LOOP_186
00000EC6  0C12 0000               2560m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000ECA  6700 0016               2561m     BEQ EXIT_186
00000ECE                          2562mm     PRINT_CHAR (A2)+,D3
00000ECE                          2563mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ECE                 TRUE     2564mm     IFEQ DEBUG
00000ECE  1639 00C00003           2565mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000ED4  0803 0002               2566mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000ED8  67F4                    2567mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000EDA  13DA 00C00007           2568mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000EE0                          2569mm     ENDC
00000EE0                          2570mm     
00000EE0                 FALSE    2571mm     IFNE DEBUG
00000EE0                          2572mm     ENDC
00000EE0                          2573mm 
00000EE0                          2574mm     ENDM
00000EE0  60E4                    2575m     BRA LOOP_186
00000EE2                          2576m EXIT_186
00000EE2                          2577m     ENDM
00000EE2                          2578      
00000EE2  2408                    2579      MOVE.L A0,D2                
00000EE4                          2580m     PRINT_REG D2,D3,D4,D5,A2
00000EE4  45FA 024D               2581m     LEA OX(PC),A2
00000EE8                          2582mm     PRINT_STR A2,D3
00000EE8                          2583mm LOOP_189
00000EE8  0C12 0000               2584mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000EEC  6700 0016               2585mm     BEQ EXIT_189
00000EF0                          2586mmm     PRINT_CHAR (A2)+,D3
00000EF0                          2587mmm WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF0                 TRUE     2588mmm     IFEQ DEBUG
00000EF0  1639 00C00003           2589mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000EF6  0803 0002               2590mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000EFA  67F4                    2591mmm         BEQ WAIT_FOR_READY_190                      ; NO SPACE, CHECK AGAIN
00000EFC  13DA 00C00007           2592mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000F02                          2593mmm     ENDC
00000F02                          2594mmm     
00000F02                 FALSE    2595mmm     IFNE DEBUG
00000F02                          2596mmm     ENDC
00000F02                          2597mmm 
00000F02                          2598mmm     ENDM
00000F02  60E4                    2599mm     BRA LOOP_189
00000F04                          2600mm EXIT_189
00000F04                          2601mm     ENDM
00000F04  7A07                    2602m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F06                          2603m LOOP_188
00000F06                          2604mm     BIN2HEX D2,D4,A2
00000F06  45FA 01EA               2605mm     LEA BIN2HEX_LUT(PC),A2                      ; LOAD THE LOOKUP TABLE
00000F0A  E99A                    2606mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F0C  1802                    2607mm     MOVE.B D2,D4
00000F0E  0284 0000000F           2608mm     ANDI.L #$F,D4
00000F14  1832 4000               2609mm     MOVE.B 0(A2,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000F18                          2610mm     ENDM
00000F18                          2611mm     PRINT_CHAR D4,D3
00000F18                          2612mm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F18                 TRUE     2613mm     IFEQ DEBUG
00000F18  1639 00C00003           2614mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F1E  0803 0002               2615mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F22  67F4                    2616mm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000F24  13C4 00C00007           2617mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000F2A                          2618mm     ENDC
00000F2A                          2619mm     
00000F2A                 FALSE    2620mm     IFNE DEBUG
00000F2A                          2621mm     ENDC
00000F2A                          2622mm 
00000F2A                          2623mm     ENDM
00000F2A  57CD FFDA               2624m     DBEQ D5,LOOP_188
00000F2E                          2625m     ENDM
00000F2E                          2626  
00000F2E                          2627m     PRINT_CRLF D3,A2
00000F2E  45FA 01FD               2628m     LEA CRLF(PC),A2
00000F32                          2629mm     PRINT_STR A2,D3
00000F32                          2630mm LOOP_194
00000F32  0C12 0000               2631mm     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000F36  6700 0016               2632mm     BEQ EXIT_194
00000F3A                          2633mmm     PRINT_CHAR (A2)+,D3
00000F3A                          2634mmm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F3A                 TRUE     2635mmm     IFEQ DEBUG
00000F3A  1639 00C00003           2636mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000F40  0803 0002               2637mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000F44  67F4                    2638mmm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F46  13DA 00C00007           2639mmm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000F4C                          2640mmm     ENDC
00000F4C                          2641mmm     
00000F4C                 FALSE    2642mmm     IFNE DEBUG
00000F4C                          2643mmm     ENDC
00000F4C                          2644mmm 
00000F4C                          2645mmm     ENDM
00000F4C  60E4                    2646mm     BRA LOOP_194
00000F4E                          2647mm EXIT_194
00000F4E                          2648mm     ENDM
00000F4E                          2649m     ENDM
00000F4E                          2650       
00000F4E                          2651m     PROGRAM D0,(A0),D2
00000F4E  3080                    2652m   MOVE.W D0,(A0)                            ; WRITE THE DATA
00000F50                          2653m       
00000F50                          2654m WAIT_FOR_COMPLETE_196
00000F50  3410                    2655m         MOVE.W (A0),D2
00000F52                          2656m 
00000F52                          2657m         IF.W D2 <NE> D0 THEN
00000F52  B440                    2658ms     CMP.W   D0,D2
00000F54  6700 0004               2659ms     BEQ _00000012
00000F58  60F6                    2660m             BRA WAIT_FOR_COMPLETE_196
00000F5A                          2661m         ENDI
00000F5A                          2662ms _00000012
00000F5A                          2663m         ENDM
00000F5A                          2664      
00000F5A                          2665m     PROTECT
00000F5A  31FC AAAA 2AAA          2666m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F60  31FC 5555 1554          2667m     MOVE.W #$5555,$1554
00000F66  31FC A0A0 2AAA          2668m     MOVE.W #$A0A0,$2AAA
00000F6C                          2669m     ENDM
00000F6C                          2670      
00000F6C  6000 F1D0               2671      BRA MAIN_LOOP
00000F70                          2672  
00000F70                          2673  HEX_DIGIT
00000F70  E98F                    2674      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000F72                          2675m     HEX2BIN D2,D2,A0
00000F72  41FA 018E               2676m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F76  0402 0030               2677m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F7A  C4BC 000000FF           2678m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000F80  1430 2000               2679m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000F84                          2680m     ENDM
00000F84  8E02                    2681      OR.B D2,D7  
00000F86  6000 F1D6               2682      BRA GET_INPUT
00000F8A                          2683  
00000F8A  FFFF FFFF               2684      SIMHALT                                     ; halt simulator
00000F8E                          2685  
00000F8E                          2686  ; strings
00000F8E= 4D 44 46 2D 6D 6F ...   2687  VERSION DC.B 'MDF-mon V1.65 (11/04/2021)',CR,LF,NULL
00000FAB= 50 72 65 73 73 20 ...   2688  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000FBE= 3F 09 09 09 68 65 ...   2689  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000FC8= 5B 76 5D 09 09 09 ...   2690          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000FD7= 78 78 78 78 78 78 ...   2691          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000FEF= 78 78 78 78 78 78 ...   2692          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000100F= 5B 73 5D 09 09 09 ...   2693          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00001029= 78 78 78 78 78 78 ...   2694          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
0000103A= 5B 7A 5D 09 09 09 ...   2695          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
0000104C= 78 78 78 78 78 78 ...   2696          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
0000106E= 78 78 78 78 78 78 ...   2697          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF,NULL
0000108E= 48 75 68 3F 0D 0A 00    2698  HUH     DC.B 'Huh?',CR,LF,NULL
00001095= 20 53 20 72 65 63 ...   2699  READ    DC.B ' S records read, start address = ',NULL
000010B7= 57 3A 20 55 6E 6B ...   2700  UNREC   DC.B 'W: Unknown Srec type: ',NULL
000010CE= 57 3A 20 43 53 20 ...   2701  CS_FAILURE   DC.B 'W: CS failure at ',NULL
000010E0= 57 3A 20 52 41 4D ...   2702  RAM_ERROR DC.B 'W: RAM error at: ',NULL
000010F2= 30 31 32 33 34 35 ...   2703  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001102= 00 01 02 03 04 05 ...   2704  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001119= 4C 6F 61 64 69 6E ...   2705  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
0000112D= 0D 0A 00                2706  CRLF    DC.B CR,LF,NULL
00001130= 3E 20 00                2707  PROMPT  DC.B '> ',NULL
00001133= 30 78 00                2708  ox      DC.B '0x',NULL
00001136= 20 2D 3E 20 00          2709  to      DC.B ' -> ',NULL
0000113B                          2710      
0000113B                          2711      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         10F2
CONTINUE_38         376
CONTINUE_41         3C6
CONTINUE_45         41C
CONTINUE_53         4D0
CONTINUE_58         542
CONTINUE_63         5BE
CONTINUE_68         63C
CONTINUE_73         6C4
CONTINUE_78         736
CONTINUE_83         7A8
CONTINUE_97         89A
CR                  D
CRLF                112D
CS_FAILURE          10CE
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       DB2
DOWNLOAD_DONE       9A4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            902
EXIT_104            92A
EXIT_107            94A
EXIT_11             15E
EXIT_112            994
EXIT_115            9C4
EXIT_119            A0E
EXIT_122            A30
EXIT_127            A7A
EXIT_129            AEA
EXIT_132            B0E
EXIT_137            B58
EXIT_144            BE4
EXIT_147            C3C
EXIT_150            C5E
EXIT_154            CA8
EXIT_157            CCA
EXIT_162            D14
EXIT_17             1EA
EXIT_175            E0C
EXIT_178            E64
EXIT_182            E98
EXIT_186            EE2
EXIT_189            F04
EXIT_19             23A
EXIT_194            F4E
EXIT_2              D4
EXIT_21             266
EXIT_24             290
EXIT_29             2DA
EXIT_36             34E
EXIT_4              F4
EXIT_50             48C
EXIT_6              114
EXIT_88             81A
EXIT_9              134
EXIT_90             83A
EXIT_94             86C
G                   A7E
GET_INPUT           15E
H                   23E
HELP                FBE
HELPPROMPT          FAB
HEX2BIN             137
HEX2BIN_LUT         1102
HEX_DIGIT           F70
HUH                 108E
L                   B68
LF                  A
LOADING             1119
LOOP_102            8E6
LOOP_104            90E
LOOP_106            94C
LOOP_107            92E
LOOP_11             142
LOOP_112            978
LOOP_114            9C6
LOOP_115            9A8
LOOP_119            9F2
LOOP_121            A32
LOOP_122            A14
LOOP_127            A5E
LOOP_129            ACE
LOOP_131            B10
LOOP_132            AF2
LOOP_137            B3C
LOOP_144            BC8
LOOP_147            C20
LOOP_149            C60
LOOP_150            C42
LOOP_154            C8C
LOOP_156            CCC
LOOP_157            CAE
LOOP_162            CF8
LOOP_17             1CE
LOOP_175            DF0
LOOP_178            E48
LOOP_181            E9A
LOOP_182            E7C
LOOP_186            EC6
LOOP_188            F06
LOOP_189            EE8
LOOP_19             21E
LOOP_194            F32
LOOP_2              B8
LOOP_21             24A
LOOP_23             292
LOOP_24             274
LOOP_29             2BE
LOOP_36             332
LOOP_4              D8
LOOP_50             470
LOOP_6              F8
LOOP_88             7FE
LOOP_9              118
LOOP_90             81E
LOOP_94             850
MAIN_LOOP           13E
NULL                0
OX                  1133
P                   D98
PRINTSTR            24A
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROGRAM             FD5
PROMPT              1130
PROTECT             D2D
R                   26A
RAM                 200000
RAM_ERROR           10E0
READ                1095
READ_CHAR           7E2
READ_DATA_TO_POKE   2E2
RESET               4
ROM                 0
S                   352
STACK               0
START               8
TAB                 9
TO                  1136
UNPROTECT           C2D
UNREC               10B7
V                   246
VERSION             F8E
W                   2DE
WAIT_CHAR           633
WAIT_FOR_COMPLETE_164  D26
WAIT_FOR_COMPLETE_165  D3C
WAIT_FOR_COMPLETE_166  D50
WAIT_FOR_COMPLETE_167  D62
WAIT_FOR_COMPLETE_168  D76
WAIT_FOR_COMPLETE_196  F50
WAIT_FOR_READY_10   120
WAIT_FOR_READY_103  8EE
WAIT_FOR_READY_105  916
WAIT_FOR_READY_108  936
WAIT_FOR_READY_110  95E
WAIT_FOR_READY_113  980
WAIT_FOR_READY_116  9B0
WAIT_FOR_READY_118  9D8
WAIT_FOR_READY_12   14A
WAIT_FOR_READY_120  9FA
WAIT_FOR_READY_123  A1C
WAIT_FOR_READY_125  A44
WAIT_FOR_READY_128  A66
WAIT_FOR_READY_13   15E
WAIT_FOR_READY_130  AD6
WAIT_FOR_READY_133  AFA
WAIT_FOR_READY_135  B22
WAIT_FOR_READY_138  B44
WAIT_FOR_READY_139  B76
WAIT_FOR_READY_141  B90
WAIT_FOR_READY_145  BD0
WAIT_FOR_READY_148  C28
WAIT_FOR_READY_15   178
WAIT_FOR_READY_151  C4A
WAIT_FOR_READY_153  C72
WAIT_FOR_READY_155  C94
WAIT_FOR_READY_158  CB6
WAIT_FOR_READY_160  CDE
WAIT_FOR_READY_163  D00
WAIT_FOR_READY_170  DA4
WAIT_FOR_READY_172  DBE
WAIT_FOR_READY_176  DF8
WAIT_FOR_READY_179  E50
WAIT_FOR_READY_18   1D6
WAIT_FOR_READY_180  E64
WAIT_FOR_READY_183  E84
WAIT_FOR_READY_185  EAC
WAIT_FOR_READY_187  ECE
WAIT_FOR_READY_190  EF0
WAIT_FOR_READY_192  F18
WAIT_FOR_READY_195  F3A
WAIT_FOR_READY_20   226
WAIT_FOR_READY_22   252
WAIT_FOR_READY_25   27C
WAIT_FOR_READY_27   2A4
WAIT_FOR_READY_3    C0
WAIT_FOR_READY_30   2C6
WAIT_FOR_READY_31   2E4
WAIT_FOR_READY_33   2FE
WAIT_FOR_READY_37   33A
WAIT_FOR_READY_38   35A
WAIT_FOR_READY_40   394
WAIT_FOR_READY_41   3AA
WAIT_FOR_READY_43   3DE
WAIT_FOR_READY_45   400
WAIT_FOR_READY_47   434
WAIT_FOR_READY_5    E0
WAIT_FOR_READY_51   478
WAIT_FOR_READY_53   4B4
WAIT_FOR_READY_55   4E8
WAIT_FOR_READY_58   526
WAIT_FOR_READY_60   55A
WAIT_FOR_READY_63   5A2
WAIT_FOR_READY_65   5D6
WAIT_FOR_READY_68   620
WAIT_FOR_READY_7    100
WAIT_FOR_READY_70   654
WAIT_FOR_READY_73   6A8
WAIT_FOR_READY_75   6DC
WAIT_FOR_READY_78   71A
WAIT_FOR_READY_80   74E
WAIT_FOR_READY_83   78C
WAIT_FOR_READY_85   7C0
WAIT_FOR_READY_89   806
WAIT_FOR_READY_91   826
WAIT_FOR_READY_92   83A
WAIT_FOR_READY_95   858
WAIT_FOR_READY_97   87E
WAIT_FOR_READY_99   8B2
WAIT_FOR_SRECORD    35A
Z                   A86
_00000000           19E
_00000001           1B2
_00000002           494
_00000003           870
_00000004           4A2
_00000005           690
_00000006           606
_00000007           870
_00000008           7FA
_00000009           870
_0000000A           998
_0000000B           9A4
_0000000C           B58
_0000000D           D30
_0000000E           D4A
_0000000F           D5E
_00000010           D6E
_00000011           D82
_00000012           F5A
_10000000           3F6
_10000001           45E
_10000002           4AA
_10000003           512
_10000004           51C
_10000005           584
_10000006           598
_10000007           600
_10000008           60A
_10000009           68A
_1000000A           616
_1000000B           67E
_1000000C           69E
_1000000D           706
_1000000E           710
_1000000F           778
_10000010           782
_10000011           7EA
_10000012           874
_10000013           8DC
_10000014           D14
_10000015           D36
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A92
_20000005           AA2
_20000006           AB6
_20000007           B5A
_20000008           B74
_20000009           BB8
_2000000A           DA2
_2000000B           DE6
