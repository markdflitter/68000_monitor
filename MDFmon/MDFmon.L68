00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 17:23:54

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000                             9  ; other ideas
00000000                            10  ;------------
00000000                            11  ; use DBLoop?
00000000                            12  ; keep track of highest address hit during srec download
00000000                            13  ; implement backspace
00000000                            14  ; fix being able to enter random chars when W'ing
00000000                            15  ; ram check at startup?  Not sure if this is a good idea!
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  
00000000                            18      ORG  $0
00000000                            19  
00000000  =00000000                 20  DEBUG               EQU 0
00000000                            21  
00000000                            22  ; constants
00000000  =00000000                 23  NULL                EQU 0
00000000  =00000009                 24  TAB                 EQU 9
00000000  =0000000D                 25  CR                  EQU 13
00000000  =0000000A                 26  LF                  EQU 10
00000000                            27  
00000000  =00000000                 28  ROM                 EQU $0
00000000  =00200000                 29  RAM                 EQU $200000
00000000                            30  
00000000  =00C00000                 31  DUART_BASE          EQU $C00000
00000000  =00000000                 32  DUART_MRA_          EQU $0
00000000  =00000001                 33  DUART_CSRA_         EQU $1
00000000  =00000001                 34  DUART_SRA_          EQU $1
00000000  =00000002                 35  DUART_CRA_          EQU $2
00000000  =00000003                 36  DUART_TXA_          EQU $3
00000000  =00000003                 37  DUART_RXA_          EQU $3
00000000  =00000004                 38  DUART_ACR_          EQU $4
00000000  =00000005                 39  DUART_IMR_          EQU $5
00000000  =00000008                 40  DUART_MRB_          EQU $8
00000000  =00000009                 41  DUART_CSRB_         EQU $9
00000000  =00000009                 42  DUART_SRB_          EQU $9
00000000  =0000000A                 43  DUART_CRB_          EQU $A
00000000  =0000000B                 44  DUART_TXB_          EQU $B
00000000  =0000000B                 45  DUART_RXB_          EQU $B
00000000  =0000000C                 46  DUART_IVR_          EQU $C
00000000  =0000000D                 47  DUART_OPCR_         EQU $D
00000000  =0000000E                 48  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 49  DUART_RESET_OPR_    EQU $F
00000000                            50  
00000000  =00C00001                 51  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 52  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 53  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 54  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 55  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 56  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            57  
00000000  =00C00011                 58  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 59  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 60  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 61  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 62  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 63  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            64  
00000000  =00C00009                 65  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 66  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 67  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 68  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 69  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 70  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            71  
00000000  =00E00000                 72  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 73  DISPLAY_            EQU $0
00000000  =00E00001                 74  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            75  
00000000                            76  ; macros
00000000                            77  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            78  ; the input register is changed during the process
00000000                            79  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            80  BIN2HEX MACRO
00000000                            81      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            82      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            83      MOVE.B \1,\2
00000000                            84      ANDI.L #$F,\2
00000000                            85      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            86      ENDM
00000000                            87  
00000000                            88  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            89  ; the input register is changed during the process
00000000                            90  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            91  HEX2BIN MACRO
00000000                            92      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            93      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            94      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            95      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            96      ENDM
00000000                            97  
00000000                            98  ; send a single char to the serial port
00000000                            99  ; \1 = char to send, \2 = data register to use for status poll
00000000                           100  ; will stamp on D0 and D1 in debug mode
00000000                           101  PRINT_CHAR MACRO
00000000                           102  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           103      IFEQ DEBUG
00000000                           104          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           105          BTST #2,\2                                  ; check for space to send
00000000                           106          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           107          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           108      ENDC
00000000                           109  
00000000                           110      IFNE DEBUG
00000000                           111          MOVE.B \1,D1
00000000                           112          MOVE.L #6,D0   
00000000                           113          TRAP #15                                    ; write to terminal in simulator
00000000                           114      ENDC
00000000                           115  
00000000                           116      ENDM
00000000                           117  
00000000                           118  ; send CR,LF to the serial port
00000000                           119  ; \1 = data register to use for status poll, /2 = working address register
00000000                           120  PRINT_CRLF MACRO
00000000                           121      LEA CRLF(PC),\2
00000000                           122      PRINT_STR \2,\1
00000000                           123      ENDM
00000000                           124  
00000000                           125  ; send C-style, zero terminated string to the serial port
00000000                           126  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           127  PRINT_STR MACRO
00000000                           128  LOOP\@
00000000                           129      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           130      BEQ EXIT\@
00000000                           131      PRINT_CHAR (\1)+,\2
00000000                           132      BRA LOOP\@
00000000                           133  EXIT\@
00000000                           134      ENDM
00000000                           135    
00000000                           136  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           137  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           138  PRINT_REG MACRO
00000000                           139      LEA ox(PC),\5
00000000                           140      PRINT_STR \5,\2
00000000                           141      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           142  LOOP\@
00000000                           143      BIN2HEX \1,\3,\5
00000000                           144      PRINT_CHAR \3,\2
00000000                           145      DBEQ \4,LOOP\@
00000000                           146      ENDM
00000000                           147  
00000000                           148  ; wait for a char from the serial port
00000000                           149  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           150  ; will stamp on D0 and D1 in debug mode
00000000                           151  WAIT_CHAR MACRO
00000000                           152  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           153      IFEQ DEBUG
00000000                           154          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           155          BTST #0,\2                                  ; check for character
00000000                           156          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           157      ENDC
00000000                           158  
00000000                           159      READ_CHAR \1
00000000                           160  
00000000                           161      IFEQ DEBUG
00000000                           162          PRINT_CHAR \1,\2                            ; echo it back
00000000                           163      ENDC
00000000                           164      ENDM
00000000                           165  
00000000                           166  ; read a char from the serial port - assumes that there is one!
00000000                           167  ; \ 1= data register for read char
00000000                           168  ; will stamp on D0 and D1 in debug mode
00000000                           169  READ_CHAR MACRO
00000000                           170      IFEQ DEBUG
00000000                           171          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           172      ENDC
00000000                           173      IFNE DEBUG
00000000                           174          MOVE.L #5,D0    
00000000                           175          TRAP #15                                    ; read from keyboard in simulator
00000000                           176          MOVE.L D1,\1
00000000                           177      ENDC
00000000                           178  
00000000                           179      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           180      BEQ START
00000000                           181      ENDM
00000000                           182  
00000000                           183  
00000000                           184  ; read data from the download serial port
00000000                           185  ; \ 1= data register for read char
00000000                           186  DOWNLOAD MACRO
00000000                           187  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           188  
00000000                           189      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           190      BTST #0,\1                                      ; check for character
00000000                           191      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           192  
00000000                           193      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           194  CONTINUE\@
00000000                           195      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           196      BTST #0,\1                                      ; check for character
00000000                           197      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           198      
00000000                           199      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           200      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           201  
00000000                           202      ENDM
00000000                           203  
00000000                           204  ; unprotect the EEPROM
00000000                           205  UNPROTECT MACRO
00000000                           206      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           207      NOP
00000000                           208      MOVE.W #$5555,$1554
00000000                           209      NOP
00000000                           210      MOVE.W #$8080,$2AAA
00000000                           211      NOP
00000000                           212      MOVE.W #$AAAA,$2AAA
00000000                           213      NOP
00000000                           214      MOVE.W #$5555,$1554
00000000                           215      NOP
00000000                           216      MOVE.W #$2020,$2AAA
00000000                           217      ENDM
00000000                           218      
00000000                           219  ; protect the EEPROM
00000000                           220  PROTECT MACRO
00000000                           221      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           222      MOVE.W #$5555,$1554
00000000                           223      MOVE.W #$A0A0,$2AAA
00000000                           224      ENDM
00000000                           225  
00000000                           226  
00000000                           227  ; read two hex digits from the download serial port and convert to a byte
00000000                           228  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           229  DOWNLOAD_BYTE MACRO
00000000                           230      MOVE.B #2,\4
00000000                           231      WHILE.B \4 <GT> 0 DO
00000000                           232          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           233          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           234          PRINT_CHAR \2,\3
00000000                           235          HEX2BIN \2,\2,\6
00000000                           236          OR.B \2,\1
00000000                           237          SUB.B #1,\4
00000000                           238      ENDW
00000000                           239  
00000000                           240      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           241      MOVE.B \1,\2
00000000                           242      ADD.L \1,\5
00000000                           243  
00000000                           244      ENDM
00000000                           245  
00000000                           246  ; write word to EEPROM
00000000                           247  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           248  PROGRAM MACRO
00000000                           249    MOVE.W \1,\2                                  ; write the data
00000000                           250  
00000000                           251  WAIT_FOR_COMPLETE\@
00000000                           252          MOVE.W \2,\3
00000000                           253  
00000000                           254          IF.W \3 <NE> \1 THEN
00000000                           255              BRA WAIT_FOR_COMPLETE\@
00000000                           256          ENDI
00000000                           257          ENDM
00000000                           258          
00000000                           259  ; register catalogue
00000000                           260  ; D0 - used for simulator I/O
00000000                           261  ; D1 - used for simulator I/O
00000000                           262  ; D2 - read character
00000000                           263  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           264  ; D6 - working register used in R/W
00000000                           265  ; D7 - address accumulator, reset by download
00000000                           266  ; A0 - address of string to print 
00000000                           267  
00000000                           268  ; start vector
00000000= 00000000                 269  STACK   DC.L $00000000                              ; STACK
00000004= 00000008                 270  RESET   DC.L START                                  ; RESET
00000008                           271  
00000008                           272  ; start of program  
00000008                           273  START
00000008  13FC 0000 00E00001       274      MOVE.B #0,DISPLAY
00000010                           275  
00000010                           276  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       277      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       278      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           279      
00000020                           280      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                281s     MOVE.W  #$50,D1
00000024  6000 000E                282s     BRA _20000001
00000028                           283s _20000000
00000028  13C1 00C00005            284          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     285          NOP
00000030                           286      ENDF
00000030  0441 0010                287s     SUB.W   #$10,D1
00000034                           288s _20000001
00000034  B27C 0010                289s     CMP.W   #$10,D1
00000038  6CEE                     290s     BGE _20000000
0000003A                           291  
0000003A                           292      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                293s     MOVE.W  #$50,D1
0000003E  6000 000E                294s     BRA _20000003
00000042                           295s _20000002
00000042  13C1 00C00015            296          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     297          NOP
0000004A                           298      ENDF
0000004A  0441 0010                299s     SUB.W   #$10,D1
0000004E                           300s _20000003
0000004E  B27C 0010                301s     CMP.W   #$10,D1
00000052  6CEE                     302s     BGE _20000002
00000054                           303      
00000054                           304  ;initialise UART
00000054  13FC 0000 00C00009       305      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       306      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       307      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           308  
0000006C                           309  ; channel A
0000006C  13FC 0013 00C00001       310      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       311      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       312      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       313      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           314  
0000008C                           315  ; channel B
0000008C  13FC 0013 00C00011       316      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       317      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       318      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       319      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           320  
000000AC                           321m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           322m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      323m     IFEQ DEBUG
000000AC  1239 00C00003            324m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                325m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     326m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       327m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           328m     ENDC
000000C0                           329m 
000000C0                 FALSE     330m     IFNE DEBUG
000000C0                           331m     ENDC
000000C0                           332m 
000000C0                           333m     ENDM
000000C0                           334m     PRINT_CHAR #0,D1
000000C0                           335m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      336m     IFEQ DEBUG
000000C0  1239 00C00003            337m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                338m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     339m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       340m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           341m     ENDC
000000D4                           342m 
000000D4                 FALSE     343m     IFNE DEBUG
000000D4                           344m     ENDC
000000D4                           345m 
000000D4                           346m     ENDM
000000D4                           347m     PRINT_CHAR #0,D1
000000D4                           348m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      349m     IFEQ DEBUG
000000D4  1239 00C00003            350m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                351m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     352m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       353m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           354m     ENDC
000000E8                           355m 
000000E8                 FALSE     356m     IFNE DEBUG
000000E8                           357m     ENDC
000000E8                           358m 
000000E8                           359m     ENDM
000000E8                           360  
000000E8  13FC 0001 00E00001       361      MOVE.B #1,DISPLAY
000000F0                           362  
000000F0                           363m     PRINT_CRLF D1,A0
000000F0  41FA 1071                364m     LEA CRLF(PC),A0
000000F4                           365mm     PRINT_STR A0,D1
000000F4                           366mm LOOP_5
000000F4  0C10 0000                367mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                368mm     BEQ EXIT_5
000000FC                           369mmm     PRINT_CHAR (A0)+,D1
000000FC                           370mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      371mmm     IFEQ DEBUG
000000FC  1239 00C00003            372mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                373mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     374mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            375mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           376mmm     ENDC
0000010E                           377mmm 
0000010E                 FALSE     378mmm     IFNE DEBUG
0000010E                           379mmm     ENDC
0000010E                           380mmm 
0000010E                           381mmm     ENDM
0000010E  60E4                     382mm     BRA LOOP_5
00000110                           383mm EXIT_5
00000110                           384mm     ENDM
00000110                           385m     ENDM
00000110  41FA 0EB2                386      LEA VERSION(PC),A0
00000114                           387m     PRINT_STR A0,D3
00000114                           388m LOOP_7
00000114  0C10 0000                389m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                390m     BEQ EXIT_7
0000011C                           391mm     PRINT_CHAR (A0)+,D3
0000011C                           392mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      393mm     IFEQ DEBUG
0000011C  1639 00C00003            394mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                395mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     396mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            397mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           398mm     ENDC
0000012E                           399mm 
0000012E                 FALSE     400mm     IFNE DEBUG
0000012E                           401mm     ENDC
0000012E                           402mm 
0000012E                           403mm     ENDM
0000012E  60E4                     404m     BRA LOOP_7
00000130                           405m EXIT_7
00000130                           406m     ENDM
00000130                           407  
00000130  41FA 0EAF                408      LEA HELPPROMPT(PC),A0
00000134                           409m     PRINT_STR A0,D3
00000134                           410m LOOP_9
00000134  0C10 0000                411m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                412m     BEQ EXIT_9
0000013C                           413mm     PRINT_CHAR (A0)+,D3
0000013C                           414mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      415mm     IFEQ DEBUG
0000013C  1639 00C00003            416mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                417mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     418mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            419mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           420mm     ENDC
0000014E                           421mm 
0000014E                 FALSE     422mm     IFNE DEBUG
0000014E                           423mm     ENDC
0000014E                           424mm 
0000014E                           425mm     ENDM
0000014E  60E4                     426m     BRA LOOP_9
00000150                           427m EXIT_9
00000150                           428m     ENDM
00000150                           429  
00000150                           430m     PRINT_CRLF D3,A0
00000150  41FA 1011                431m     LEA CRLF(PC),A0
00000154                           432mm     PRINT_STR A0,D3
00000154                           433mm LOOP_12
00000154  0C10 0000                434mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                435mm     BEQ EXIT_12
0000015C                           436mmm     PRINT_CHAR (A0)+,D3
0000015C                           437mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      438mmm     IFEQ DEBUG
0000015C  1639 00C00003            439mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                440mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     441mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            442mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           443mmm     ENDC
0000016E                           444mmm 
0000016E                 FALSE     445mmm     IFNE DEBUG
0000016E                           446mmm     ENDC
0000016E                           447mmm 
0000016E                           448mmm     ENDM
0000016E  60E4                     449mm     BRA LOOP_12
00000170                           450mm EXIT_12
00000170                           451mm     ENDM
00000170                           452m     ENDM
00000170                           453  
00000170  7E00                     454      MOVE.L #0,D7                                    ; address accumulator
00000172                           455  
00000172  13FC 0002 00E00001       456      MOVE.B #2,DISPLAY
0000017A                           457  MAIN_LOOP
0000017A  41FA 0FEA                458      LEA PROMPT(PC),A0
0000017E                           459m     PRINT_STR A0,D3
0000017E                           460m LOOP_14
0000017E  0C10 0000                461m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                462m     BEQ EXIT_14
00000186                           463mm     PRINT_CHAR (A0)+,D3
00000186                           464mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      465mm     IFEQ DEBUG
00000186  1639 00C00003            466mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                467mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     468mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            469mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           470mm     ENDC
00000198                           471mm 
00000198                 FALSE     472mm     IFNE DEBUG
00000198                           473mm     ENDC
00000198                           474mm 
00000198                           475mm     ENDM
00000198  60E4                     476m     BRA LOOP_14
0000019A                           477m EXIT_14
0000019A                           478m     ENDM
0000019A                           479  
0000019A                           480  GET_INPUT
0000019A                           481m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           482m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      483m     IFEQ DEBUG
0000019A  1639 00C00003            484m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                485m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     486m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           487m     ENDC
000001A6                           488m 
000001A6                           489mm     READ_CHAR D2
000001A6                 TRUE      490mm     IFEQ DEBUG
000001A6  1439 00C00007            491mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           492mm     ENDC
000001AC                 FALSE     493mm     IFNE DEBUG
000001AC                           494mm     ENDC
000001AC                           495mm 
000001AC  B43C 001B                496mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                497mm     BEQ START
000001B4                           498mm     ENDM
000001B4                           499m 
000001B4                 TRUE      500m     IFEQ DEBUG
000001B4                           501mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           502mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      503mm     IFEQ DEBUG
000001B4  1639 00C00003            504mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                505mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     506mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            507mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           508mm     ENDC
000001C6                           509mm 
000001C6                 FALSE     510mm     IFNE DEBUG
000001C6                           511mm     ENDC
000001C6                           512mm 
000001C6                           513mm     ENDM
000001C6                           514m     ENDC
000001C6                           515m     ENDM
000001C6                           516  
000001C6                           517      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                518s     CMP.B   #'0',D2
000001CA  6D00 000E                519s     BLT _00000000
000001CE  B43C 0039                520s     CMP.B   #'9',D2
000001D2  6E00 0006                521s     BGT _00000000
000001D6  6000 0DCE                522          BRA HEX_DIGIT
000001DA                           523      ENDI
000001DA                           524s _00000000
000001DA                           525      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                526s     CMP.B   #'A',D2
000001DE  6D00 000E                527s     BLT _00000001
000001E2  B43C 0046                528s     CMP.B   #'F',D2
000001E6  6E00 0006                529s     BGT _00000001
000001EA  6000 0DBA                530          BRA HEX_DIGIT
000001EE                           531      ENDI
000001EE                           532s _00000001
000001EE                           533  
000001EE  B43C 0077                534      CMP.B #'w',D2
000001F2  6700 0126                535      BEQ W
000001F6                           536  
000001F6  B43C 006C                537      CMP.B #'l',D2
000001FA  6700 09A8                538      BEQ L 
000001FE                           539  
000001FE  B43C 0070                540      CMP.B #'p',D2
00000202  6700 0BD0                541      BEQ P
00000206                           542  
00000206                           543m     PRINT_CRLF D3,A0
00000206  41FA 0F5B                544m     LEA CRLF(PC),A0
0000020A                           545mm     PRINT_STR A0,D3
0000020A                           546mm LOOP_20
0000020A  0C10 0000                547mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000020E  6700 0016                548mm     BEQ EXIT_20
00000212                           549mmm     PRINT_CHAR (A0)+,D3
00000212                           550mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000212                 TRUE      551mmm     IFEQ DEBUG
00000212  1639 00C00003            552mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000218  0803 0002                553mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000021C  67F4                     554mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000021E  13D8 00C00007            555mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000224                           556mmm     ENDC
00000224                           557mmm 
00000224                 FALSE     558mmm     IFNE DEBUG
00000224                           559mmm     ENDC
00000224                           560mmm 
00000224                           561mmm     ENDM
00000224  60E4                     562mm     BRA LOOP_20
00000226                           563mm EXIT_20
00000226                           564mm     ENDM
00000226                           565m     ENDM
00000226                           566   
00000226  B43C 003F                567      CMP.B #'?',D2
0000022A  6700 004E                568      BEQ H
0000022E                           569   
0000022E  B43C 0076                570      CMP.B #'v',D2
00000232  6700 004E                571      BEQ V
00000236                           572      
00000236  B43C 0072                573      CMP.B #'r',D2
0000023A  6700 006A                574      BEQ R
0000023E                           575  
0000023E  B43C 0073                576      CMP.B #'s',D2
00000242  6700 014A                577      BEQ S
00000246                           578  
00000246  B43C 0067                579      CMP.B #'g',D2
0000024A  6700 086E                580      BEQ G   
0000024E                           581  
0000024E  B43C 007A                582      CMP.B #'z',D2
00000252  6700 086E                583      BEQ Z   
00000256                           584  
00000256  41FA 0E6C                585      LEA HUH(PC),A0
0000025A                           586m     PRINT_STR A0,D3
0000025A                           587m LOOP_22
0000025A  0C10 0000                588m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000025E  6700 0016                589m     BEQ EXIT_22
00000262                           590mm     PRINT_CHAR (A0)+,D3
00000262                           591mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      592mm     IFEQ DEBUG
00000262  1639 00C00003            593mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000268  0803 0002                594mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000026C  67F4                     595mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000026E  13D8 00C00007            596mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000274                           597mm     ENDC
00000274                           598mm 
00000274                 FALSE     599mm     IFNE DEBUG
00000274                           600mm     ENDC
00000274                           601mm 
00000274                           602mm     ENDM
00000274  60E4                     603m     BRA LOOP_22
00000276                           604m EXIT_22
00000276                           605m     ENDM
00000276                           606  
00000276  6000 FF02                607      BRA MAIN_LOOP
0000027A                           608  
0000027A                           609  ; commands
0000027A                           610  H
0000027A  41FA 0D78                611      LEA HELP(PC),A0
0000027E  6000 0006                612      BRA PRINTSTR
00000282                           613  
00000282                           614  V
00000282  41FA 0D40                615      LEA VERSION(PC),A0
00000286                           616  PRINTSTR
00000286                           617m     PRINT_STR A0,D3    
00000286                           618m LOOP_24
00000286  0C10 0000                619m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000028A  6700 0016                620m     BEQ EXIT_24
0000028E                           621mm     PRINT_CHAR (A0)+,D3
0000028E                           622mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000028E                 TRUE      623mm     IFEQ DEBUG
0000028E  1639 00C00003            624mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000294  0803 0002                625mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000298  67F4                     626mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
0000029A  13D8 00C00007            627mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A0                           628mm     ENDC
000002A0                           629mm 
000002A0                 FALSE     630mm     IFNE DEBUG
000002A0                           631mm     ENDC
000002A0                           632mm 
000002A0                           633mm     ENDM
000002A0  60E4                     634m     BRA LOOP_24
000002A2                           635m EXIT_24
000002A2                           636m     ENDM
000002A2  6000 FED6                637      BRA MAIN_LOOP
000002A6                           638  
000002A6                           639  R
000002A6  2047                     640      MOVE.L D7,A0                                    ; address accumulator -> address register
000002A8  7E00                     641      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002AA  2410                     642      MOVE.L (A0),D2                                  ; read the memory and print it
000002AC                           643m     PRINT_REG D2,D3,D4,D5,A0
000002AC  41FA 0EBB                644m     LEA OX(PC),A0
000002B0                           645mm     PRINT_STR A0,D3
000002B0                           646mm LOOP_27
000002B0  0C10 0000                647mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002B4  6700 0016                648mm     BEQ EXIT_27
000002B8                           649mmm     PRINT_CHAR (A0)+,D3
000002B8                           650mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B8                 TRUE      651mmm     IFEQ DEBUG
000002B8  1639 00C00003            652mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002BE  0803 0002                653mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002C2  67F4                     654mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002C4  13D8 00C00007            655mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002CA                           656mmm     ENDC
000002CA                           657mmm 
000002CA                 FALSE     658mmm     IFNE DEBUG
000002CA                           659mmm     ENDC
000002CA                           660mmm 
000002CA                           661mmm     ENDM
000002CA  60E4                     662mm     BRA LOOP_27
000002CC                           663mm EXIT_27
000002CC                           664mm     ENDM
000002CC  7A07                     665m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002CE                           666m LOOP_26
000002CE                           667mm     BIN2HEX D2,D4,A0
000002CE  41FA 0E58                668mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002D2  E99A                     669mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002D4  1802                     670mm     MOVE.B D2,D4
000002D6  0284 0000000F            671mm     ANDI.L #$F,D4
000002DC  1830 4000                672mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002E0                           673mm     ENDM
000002E0                           674mm     PRINT_CHAR D4,D3
000002E0                           675mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E0                 TRUE      676mm     IFEQ DEBUG
000002E0  1639 00C00003            677mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E6  0803 0002                678mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002EA  67F4                     679mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002EC  13C4 00C00007            680mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002F2                           681mm     ENDC
000002F2                           682mm 
000002F2                 FALSE     683mm     IFNE DEBUG
000002F2                           684mm     ENDC
000002F2                           685mm 
000002F2                           686mm     ENDM
000002F2  57CD FFDA                687m     DBEQ D5,LOOP_26
000002F6                           688m     ENDM
000002F6                           689m     PRINT_CRLF D3,A0
000002F6  41FA 0E6B                690m     LEA CRLF(PC),A0
000002FA                           691mm     PRINT_STR A0,D3
000002FA                           692mm LOOP_32
000002FA  0C10 0000                693mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FE  6700 0016                694mm     BEQ EXIT_32
00000302                           695mmm     PRINT_CHAR (A0)+,D3
00000302                           696mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000302                 TRUE      697mmm     IFEQ DEBUG
00000302  1639 00C00003            698mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000308  0803 0002                699mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000030C  67F4                     700mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000030E  13D8 00C00007            701mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000314                           702mmm     ENDC
00000314                           703mmm 
00000314                 FALSE     704mmm     IFNE DEBUG
00000314                           705mmm     ENDC
00000314                           706mmm 
00000314                           707mmm     ENDM
00000314  60E4                     708mm     BRA LOOP_32
00000316                           709mm EXIT_32
00000316                           710mm     ENDM
00000316                           711m     ENDM
00000316  6000 FE62                712      BRA MAIN_LOOP
0000031A                           713  
0000031A                           714  W
0000031A  3C3C 0007                715      MOVE #7,D6                                      ; 7 bytes left to read
0000031E                           716      
0000031E                           717  READ_DATA_TO_POKE
0000031E  E98D                     718      LSL.L #4,D5                                     ; make what we have so far more significant
00000320                           719m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000320                           720m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000320                 TRUE      721m     IFEQ DEBUG
00000320  1639 00C00003            722m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000326  0803 0000                723m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000032A  67F4                     724m         BEQ WAIT_FOR_READY_34                       ; NOTHING, CHECK AGAIN
0000032C                           725m     ENDC
0000032C                           726m 
0000032C                           727mm     READ_CHAR D2
0000032C                 TRUE      728mm     IFEQ DEBUG
0000032C  1439 00C00007            729mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000332                           730mm     ENDC
00000332                 FALSE     731mm     IFNE DEBUG
00000332                           732mm     ENDC
00000332                           733mm 
00000332  B43C 001B                734mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000336  6700 FCD0                735mm     BEQ START
0000033A                           736mm     ENDM
0000033A                           737m 
0000033A                 TRUE      738m     IFEQ DEBUG
0000033A                           739mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000033A                           740mm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033A                 TRUE      741mm     IFEQ DEBUG
0000033A  1639 00C00003            742mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000340  0803 0002                743mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000344  67F4                     744mm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000346  13C2 00C00007            745mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000034C                           746mm     ENDC
0000034C                           747mm 
0000034C                 FALSE     748mm     IFNE DEBUG
0000034C                           749mm     ENDC
0000034C                           750mm 
0000034C                           751mm     ENDM
0000034C                           752m     ENDC
0000034C                           753m     ENDM
0000034C                           754m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0000034C  41FA 0DEA                755m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000350  0402 0030                756m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000354  C4BC 000000FF            757m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000035A  1430 2000                758m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000035E                           759m     ENDM
0000035E  8A02                     760      OR.B D2,D5
00000360  57CE FFBC                761      DBEQ D6,READ_DATA_TO_POKE
00000364                           762      
00000364  2047                     763      MOVE.L D7,A0                                    ; address accumulator -> address register
00000366  7E00                     764      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000368                           765      
00000368  2085                     766      MOVE.L D5,(A0)                                  ; write the data
0000036A                           767  
0000036A                           768m     PRINT_CRLF D3,A0
0000036A  41FA 0DF7                769m     LEA CRLF(PC),A0
0000036E                           770mm     PRINT_STR A0,D3
0000036E                           771mm LOOP_39
0000036E  0C10 0000                772mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000372  6700 0016                773mm     BEQ EXIT_39
00000376                           774mmm     PRINT_CHAR (A0)+,D3
00000376                           775mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000376                 TRUE      776mmm     IFEQ DEBUG
00000376  1639 00C00003            777mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000037C  0803 0002                778mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000380  67F4                     779mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
00000382  13D8 00C00007            780mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000388                           781mmm     ENDC
00000388                           782mmm 
00000388                 FALSE     783mmm     IFNE DEBUG
00000388                           784mmm     ENDC
00000388                           785mmm 
00000388                           786mmm     ENDM
00000388  60E4                     787mm     BRA LOOP_39
0000038A                           788mm EXIT_39
0000038A                           789mm     ENDM
0000038A                           790m     ENDM
0000038A  6000 FDEE                791      BRA MAIN_LOOP
0000038E                           792  
0000038E                           793  ; register map for S
0000038E                           794  ; A0 - start address
0000038E                           795  ; A1 - offset
0000038E                           796  ; A2 - next address to write
0000038E                           797  ; A3 - next location (jmp)
0000038E                           798  ; A4 - Working Address Register
0000038E                           799  ; D0 - record count
0000038E                           800  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000038E                           801  ; D2 - checksum
0000038E                           802  ; D3 - data byte count
0000038E                           803  ; D4 - read address, moved into A2
0000038E                           804  ; D5 - temp
0000038E                           805  ; D6 - temp
0000038E                           806  ; D7 - temp
0000038E                           807  S
0000038E  2078 0000                808      MOVE.L 0,A0                                     ; start address -> A0
00000392  2247                     809      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000394                           810      
00000394  7000                     811      MOVE.L #0,D0                                    ; count of records read -> D0
00000396                           812          
00000396                           813  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000396                           814m     DOWNLOAD D1
00000396                           815m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000396                           816m 
00000396  1239 00C00003            817m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000039C  0801 0000                818m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003A0  6700 0010                819m     BEQ CONTINUE_41                                 ; NOTHING, CONTINUE
000003A4                           820m 
000003A4                           821mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000003A4                 TRUE      822mm     IFEQ DEBUG
000003A4  1239 00C00007            823mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003AA                           824mm     ENDC
000003AA                 FALSE     825mm     IFNE DEBUG
000003AA                           826mm     ENDC
000003AA                           827mm 
000003AA  B23C 001B                828mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000003AE  6700 FC58                829mm     BEQ START
000003B2                           830mm     ENDM
000003B2                           831m CONTINUE_41
000003B2  1239 00C00013            832m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003B8  0801 0000                833m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003BC  67D8                     834m     BEQ WAIT_FOR_READY_41                           ; NOTHING, CHECK AGAIN
000003BE                           835m     
000003BE  1239 00C00017            836m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003C4  13C1 00E00001            837m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003CA                           838m 
000003CA                           839m     ENDM
000003CA  B23C 0053                840      CMP.B #'S',D1                                   ; found S?
000003CE  66C6                     841      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000003D0                           842      
000003D0                           843m     PRINT_CHAR #'S',D5                              ; print the S
000003D0                           844m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D0                 TRUE      845m     IFEQ DEBUG
000003D0  1A39 00C00003            846m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000003D6  0805 0002                847m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000003DA  67F4                     848m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
000003DC  13FC 0053 00C00007       849m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
000003E4                           850m     ENDC
000003E4                           851m 
000003E4                 FALSE     852m     IFNE DEBUG
000003E4                           853m     ENDC
000003E4                           854m 
000003E4                           855m     ENDM
000003E4  5280                     856      ADD.L #1,D0                                     ; read another S record, increment count
000003E6                           857      
000003E6                           858m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003E6                           859m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E6                           860m 
000003E6  1239 00C00003            861m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000003EC  0801 0000                862m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003F0  6700 0010                863m     BEQ CONTINUE_44                                 ; NOTHING, CONTINUE
000003F4                           864m 
000003F4                           865mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000003F4                 TRUE      866mm     IFEQ DEBUG
000003F4  1239 00C00007            867mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003FA                           868mm     ENDC
000003FA                 FALSE     869mm     IFNE DEBUG
000003FA                           870mm     ENDC
000003FA                           871mm 
000003FA  B23C 001B                872mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000003FE  6700 FC08                873mm     BEQ START
00000402                           874mm     ENDM
00000402                           875m CONTINUE_44
00000402  1239 00C00013            876m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000408  0801 0000                877m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000040C  67D8                     878m     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0000040E                           879m     
0000040E  1239 00C00017            880m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000414  13C1 00E00001            881m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000041A                           882m 
0000041A                           883m     ENDM
0000041A                           884m     PRINT_CHAR D1,D5
0000041A                           885m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000041A                 TRUE      886m     IFEQ DEBUG
0000041A  1A39 00C00003            887m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000420  0805 0002                888m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000424  67F4                     889m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000426  13C1 00C00007            890m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000042C                           891m     ENDC
0000042C                           892m 
0000042C                 FALSE     893m     IFNE DEBUG
0000042C                           894m     ENDC
0000042C                           895m 
0000042C                           896m     ENDM
0000042C                           897  
0000042C  7400                     898      MOVE.L #0,D2                                    ; clear the checksum
0000042E                           899  
0000042E                           900m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000042E  1E3C 0002                901m     MOVE.B #2,D7
00000432                           902m     WHILE.B D7 <GT> 0 DO
00000432                           903ms _10000000
00000432  BE38 0000                904ms     CMP.B   0,D7
00000436  6F00 0062                905ms     BLE _10000001
0000043A  E98B                     906m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000043C                           907mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000043C                           908mm WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043C                           909mm 
0000043C  1A39 00C00003            910mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000442  0805 0000                911mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000446  6700 0010                912mm     BEQ CONTINUE_48                                 ; NOTHING, CONTINUE
0000044A                           913mm 
0000044A                           914mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000044A                 TRUE      915mmm     IFEQ DEBUG
0000044A  1A39 00C00007            916mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000450                           917mmm     ENDC
00000450                 FALSE     918mmm     IFNE DEBUG
00000450                           919mmm     ENDC
00000450                           920mmm 
00000450  BA3C 001B                921mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000454  6700 FBB2                922mmm     BEQ START
00000458                           923mmm     ENDM
00000458                           924mm CONTINUE_48
00000458  1A39 00C00013            925mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000045E  0805 0000                926mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000462  67D8                     927mm     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
00000464                           928mm     
00000464  1A39 00C00017            929mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000046A  13C5 00E00001            930mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000470                           931mm 
00000470                           932mm     ENDM
00000470                           933mm         PRINT_CHAR D5,D6
00000470                           934mm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000470                 TRUE      935mm     IFEQ DEBUG
00000470  1C39 00C00003            936mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000476  0806 0002                937mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000047A  67F4                     938mm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
0000047C  13C5 00C00007            939mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000482                           940mm     ENDC
00000482                           941mm 
00000482                 FALSE     942mm     IFNE DEBUG
00000482                           943mm     ENDC
00000482                           944mm 
00000482                           945mm     ENDM
00000482                           946mm         HEX2BIN D5,D5,A4
00000482  49FA 0CB4                947mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000486  0405 0030                948mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000048A  CABC 000000FF            949mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000490  1A34 5000                950mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000494                           951mm     ENDM
00000494  8605                     952m         OR.B D5,D3
00000496  5307                     953m         SUB.B #1,D7
00000498                           954m     ENDW
00000498  6098                     955ms     BRA _10000000
0000049A                           956ms _10000001
0000049A                           957m 
0000049A  7A00                     958m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000049C  1A03                     959m     MOVE.B D3,D5
0000049E  D483                     960m     ADD.L D3,D2
000004A0                           961m 
000004A0                           962m     ENDM
000004A0                           963  
000004A0                           964      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004A0  B23C 0030                965s     CMP.B   #'0',D1
000004A4  6600 002A                966s     BNE.L   _00000002
000004A8                           967m         PRINT_CRLF D5,A4
000004A8  49FA 0CB9                968m     LEA CRLF(PC),A4
000004AC                           969mm     PRINT_STR A4,D5
000004AC                           970mm LOOP_53
000004AC  0C14 0000                971mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000004B0  6700 0016                972mm     BEQ EXIT_53
000004B4                           973mmm     PRINT_CHAR (A4)+,D5
000004B4                           974mmm WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B4                 TRUE      975mmm     IFEQ DEBUG
000004B4  1A39 00C00003            976mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000004BA  0805 0002                977mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000004BE  67F4                     978mmm         BEQ WAIT_FOR_READY_54                       ; NO SPACE, CHECK AGAIN
000004C0  13DC 00C00007            979mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004C6                           980mmm     ENDC
000004C6                           981mmm 
000004C6                 FALSE     982mmm     IFNE DEBUG
000004C6                           983mmm     ENDC
000004C6                           984mmm 
000004C6                           985mmm     ENDM
000004C6  60E4                     986mm     BRA LOOP_53
000004C8                           987mm EXIT_53
000004C8                           988mm     ENDM
000004C8                           989m     ENDM
000004C8  6000 FECC                990          BRA WAIT_FOR_SRECORD
000004CC                           991      ELSE
000004CC  6000 03DE                992s     BRA _00000003
000004D0                           993s _00000002
000004D0                           994          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000004D0  B23C 0031                995s     CMP.B   #'1',D1
000004D4  6708                     996s     BEQ.S   _00000004
000004D6  B23C 0032                997s     CMP.B   #'2',D1
000004DA  6600 01F0                998s     BNE.L   _00000005
000004DE                           999s _00000004
000004DE  5783                    1000              SUB.L #3,D3                         ; subtract three bytes for 16 bit address and 1 byte checksum
000004E0                          1001  
000004E0  7800                    1002              MOVE.L #0,D4                            ; read two bytes of address
000004E2                          1003m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000004E2  1E3C 0002               1004m     MOVE.B #2,D7
000004E6                          1005m     WHILE.B D7 <GT> 0 DO
000004E6                          1006ms _10000002
000004E6  BE38 0000               1007ms     CMP.B   0,D7
000004EA  6F00 0062               1008ms     BLE _10000003
000004EE  E98C                    1009m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000004F0                          1010mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004F0                          1011mm WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F0                          1012mm 
000004F0  1A39 00C00003           1013mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004F6  0805 0000               1014mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004FA  6700 0010               1015mm     BEQ CONTINUE_56                                 ; NOTHING, CONTINUE
000004FE                          1016mm 
000004FE                          1017mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000004FE                 TRUE     1018mmm     IFEQ DEBUG
000004FE  1A39 00C00007           1019mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000504                          1020mmm     ENDC
00000504                 FALSE    1021mmm     IFNE DEBUG
00000504                          1022mmm     ENDC
00000504                          1023mmm 
00000504  BA3C 001B               1024mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000508  6700 FAFE               1025mmm     BEQ START
0000050C                          1026mmm     ENDM
0000050C                          1027mm CONTINUE_56
0000050C  1A39 00C00013           1028mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000512  0805 0000               1029mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000516  67D8                    1030mm     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
00000518                          1031mm     
00000518  1A39 00C00017           1032mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000051E  13C5 00E00001           1033mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000524                          1034mm 
00000524                          1035mm     ENDM
00000524                          1036mm         PRINT_CHAR D5,D6
00000524                          1037mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000524                 TRUE     1038mm     IFEQ DEBUG
00000524  1C39 00C00003           1039mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000052A  0806 0002               1040mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000052E  67F4                    1041mm         BEQ WAIT_FOR_READY_58                       ; NO SPACE, CHECK AGAIN
00000530  13C5 00C00007           1042mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000536                          1043mm     ENDC
00000536                          1044mm 
00000536                 FALSE    1045mm     IFNE DEBUG
00000536                          1046mm     ENDC
00000536                          1047mm 
00000536                          1048mm     ENDM
00000536                          1049mm         HEX2BIN D5,D5,A4
00000536  49FA 0C00               1050mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000053A  0405 0030               1051mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000053E  CABC 000000FF           1052mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000544  1A34 5000               1053mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000548                          1054mm     ENDM
00000548  8805                    1055m         OR.B D5,D4
0000054A  5307                    1056m         SUB.B #1,D7
0000054C                          1057m     ENDW
0000054C  6098                    1058ms     BRA _10000002
0000054E                          1059ms _10000003
0000054E                          1060m 
0000054E  7A00                    1061m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000550  1A04                    1062m     MOVE.B D4,D5
00000552  D484                    1063m     ADD.L D4,D2
00000554                          1064m 
00000554                          1065m     ENDM
00000554                          1066m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000554  1E3C 0002               1067m     MOVE.B #2,D7
00000558                          1068m     WHILE.B D7 <GT> 0 DO
00000558                          1069ms _10000004
00000558  BE38 0000               1070ms     CMP.B   0,D7
0000055C  6F00 0062               1071ms     BLE _10000005
00000560  E98C                    1072m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000562                          1073mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000562                          1074mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000562                          1075mm 
00000562  1A39 00C00003           1076mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000568  0805 0000               1077mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000056C  6700 0010               1078mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000570                          1079mm 
00000570                          1080mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000570                 TRUE     1081mmm     IFEQ DEBUG
00000570  1A39 00C00007           1082mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000576                          1083mmm     ENDC
00000576                 FALSE    1084mmm     IFNE DEBUG
00000576                          1085mmm     ENDC
00000576                          1086mmm 
00000576  BA3C 001B               1087mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000057A  6700 FA8C               1088mmm     BEQ START
0000057E                          1089mmm     ENDM
0000057E                          1090mm CONTINUE_61
0000057E  1A39 00C00013           1091mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000584  0805 0000               1092mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000588  67D8                    1093mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
0000058A                          1094mm     
0000058A  1A39 00C00017           1095mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000590  13C5 00E00001           1096mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000596                          1097mm 
00000596                          1098mm     ENDM
00000596                          1099mm         PRINT_CHAR D5,D6
00000596                          1100mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000596                 TRUE     1101mm     IFEQ DEBUG
00000596  1C39 00C00003           1102mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000059C  0806 0002               1103mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000005A0  67F4                    1104mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000005A2  13C5 00C00007           1105mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A8                          1106mm     ENDC
000005A8                          1107mm 
000005A8                 FALSE    1108mm     IFNE DEBUG
000005A8                          1109mm     ENDC
000005A8                          1110mm 
000005A8                          1111mm     ENDM
000005A8                          1112mm         HEX2BIN D5,D5,A4
000005A8  49FA 0B8E               1113mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005AC  0405 0030               1114mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B0  CABC 000000FF           1115mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005B6  1A34 5000               1116mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005BA                          1117mm     ENDM
000005BA  8805                    1118m         OR.B D5,D4
000005BC  5307                    1119m         SUB.B #1,D7
000005BE                          1120m     ENDW
000005BE  6098                    1121ms     BRA _10000004
000005C0                          1122ms _10000005
000005C0                          1123m 
000005C0  7A00                    1124m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005C2  1A04                    1125m     MOVE.B D4,D5
000005C4  D484                    1126m     ADD.L D4,D2
000005C6                          1127m 
000005C6                          1128m     ENDM
000005C6                          1129  
000005C6                          1130              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000005C6  B23C 0032               1131s     CMP.B   #'2',D1
000005CA  6600 0076               1132s     BNE.L   _00000006
000005CE  5383                    1133                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005D0                          1134m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000005D0  1E3C 0002               1135m     MOVE.B #2,D7
000005D4                          1136m     WHILE.B D7 <GT> 0 DO
000005D4                          1137ms _10000006
000005D4  BE38 0000               1138ms     CMP.B   0,D7
000005D8  6F00 0062               1139ms     BLE _10000007
000005DC  E98C                    1140m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005DE                          1141mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005DE                          1142mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005DE                          1143mm 
000005DE  1A39 00C00003           1144mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005E4  0805 0000               1145mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005E8  6700 0010               1146mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005EC                          1147mm 
000005EC                          1148mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005EC                 TRUE     1149mmm     IFEQ DEBUG
000005EC  1A39 00C00007           1150mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005F2                          1151mmm     ENDC
000005F2                 FALSE    1152mmm     IFNE DEBUG
000005F2                          1153mmm     ENDC
000005F2                          1154mmm 
000005F2  BA3C 001B               1155mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005F6  6700 FA10               1156mmm     BEQ START
000005FA                          1157mmm     ENDM
000005FA                          1158mm CONTINUE_66
000005FA  1A39 00C00013           1159mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000600  0805 0000               1160mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000604  67D8                    1161mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
00000606                          1162mm     
00000606  1A39 00C00017           1163mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000060C  13C5 00E00001           1164mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000612                          1165mm 
00000612                          1166mm     ENDM
00000612                          1167mm         PRINT_CHAR D5,D6
00000612                          1168mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000612                 TRUE     1169mm     IFEQ DEBUG
00000612  1C39 00C00003           1170mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000618  0806 0002               1171mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000061C  67F4                    1172mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
0000061E  13C5 00C00007           1173mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000624                          1174mm     ENDC
00000624                          1175mm 
00000624                 FALSE    1176mm     IFNE DEBUG
00000624                          1177mm     ENDC
00000624                          1178mm 
00000624                          1179mm     ENDM
00000624                          1180mm         HEX2BIN D5,D5,A4
00000624  49FA 0B12               1181mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000628  0405 0030               1182mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000062C  CABC 000000FF           1183mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000632  1A34 5000               1184mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000636                          1185mm     ENDM
00000636  8805                    1186m         OR.B D5,D4
00000638  5307                    1187m         SUB.B #1,D7
0000063A                          1188m     ENDW
0000063A  6098                    1189ms     BRA _10000006
0000063C                          1190ms _10000007
0000063C                          1191m 
0000063C  7A00                    1192m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000063E  1A04                    1193m     MOVE.B D4,D5
00000640  D484                    1194m     ADD.L D4,D2
00000642                          1195m 
00000642                          1196m     ENDM
00000642                          1197              ENDI
00000642                          1198s _00000006
00000642                          1199  
00000642  2444                    1200              MOVE.L D4,A2                            ; put the address in an address register
00000644  D5C9                    1201              ADD.L A1,A2                             ; add in the offset
00000646                          1202  
00000646                          1203              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000646                          1204s _10000008
00000646  B63C 0000               1205s     CMP.B   #0,D3
0000064A  6F00 007A               1206s     BLE _10000009
0000064E                          1207m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000064E  1E3C 0002               1208m     MOVE.B #2,D7
00000652                          1209m     WHILE.B D7 <GT> 0 DO
00000652                          1210ms _1000000A
00000652  BE38 0000               1211ms     CMP.B   0,D7
00000656  6F00 0062               1212ms     BLE _1000000B
0000065A  E989                    1213m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
0000065C                          1214mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000065C                          1215mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000065C                          1216mm 
0000065C  1A39 00C00003           1217mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000662  0805 0000               1218mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000666  6700 0010               1219mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
0000066A                          1220mm 
0000066A                          1221mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000066A                 TRUE     1222mmm     IFEQ DEBUG
0000066A  1A39 00C00007           1223mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000670                          1224mmm     ENDC
00000670                 FALSE    1225mmm     IFNE DEBUG
00000670                          1226mmm     ENDC
00000670                          1227mmm 
00000670  BA3C 001B               1228mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000674  6700 F992               1229mmm     BEQ START
00000678                          1230mmm     ENDM
00000678                          1231mm CONTINUE_71
00000678  1A39 00C00013           1232mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000067E  0805 0000               1233mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000682  67D8                    1234mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
00000684                          1235mm     
00000684  1A39 00C00017           1236mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000068A  13C5 00E00001           1237mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000690                          1238mm 
00000690                          1239mm     ENDM
00000690                          1240mm         PRINT_CHAR D5,D6
00000690                          1241mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000690                 TRUE     1242mm     IFEQ DEBUG
00000690  1C39 00C00003           1243mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000696  0806 0002               1244mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000069A  67F4                    1245mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
0000069C  13C5 00C00007           1246mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A2                          1247mm     ENDC
000006A2                          1248mm 
000006A2                 FALSE    1249mm     IFNE DEBUG
000006A2                          1250mm     ENDC
000006A2                          1251mm 
000006A2                          1252mm     ENDM
000006A2                          1253mm         HEX2BIN D5,D5,A4
000006A2  49FA 0A94               1254mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006A6  0405 0030               1255mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006AA  CABC 000000FF           1256mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006B0  1A34 5000               1257mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006B4                          1258mm     ENDM
000006B4  8205                    1259m         OR.B D5,D1
000006B6  5307                    1260m         SUB.B #1,D7
000006B8                          1261m     ENDW
000006B8  6098                    1262ms     BRA _1000000A
000006BA                          1263ms _1000000B
000006BA                          1264m 
000006BA  7A00                    1265m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006BC  1A01                    1266m     MOVE.B D1,D5
000006BE  D481                    1267m     ADD.L D1,D2
000006C0                          1268m 
000006C0                          1269m     ENDM
000006C0                          1270   
000006C0  14C1                    1271                  MOVE.B D1,(A2)+                     ; store it!
000006C2                          1272  
000006C2  5303                    1273                  SUB.B #1,D3                         ; 1 less byte to go
000006C4                          1274              ENDW
000006C4  6080                    1275s     BRA _10000008
000006C6                          1276s _10000009
000006C6                          1277  
000006C6  7200                    1278              MOVE.L #0,D1                            ; not done yet
000006C8                          1279          ELSE
000006C8  6000 01E2               1280s     BRA _00000007
000006CC                          1281s _00000005
000006CC                          1282              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006CC  B23C 0038               1283s     CMP.B   #'8',D1
000006D0  6600 0164               1284s     BNE.L   _00000008
000006D4  7800                    1285                  MOVE.L #0,D4                        ; read the 24 bit start address
000006D6                          1286m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000006D6  1E3C 0002               1287m     MOVE.B #2,D7
000006DA                          1288m     WHILE.B D7 <GT> 0 DO
000006DA                          1289ms _1000000C
000006DA  BE38 0000               1290ms     CMP.B   0,D7
000006DE  6F00 0062               1291ms     BLE _1000000D
000006E2  E98C                    1292m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006E4                          1293mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006E4                          1294mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E4                          1295mm 
000006E4  1A39 00C00003           1296mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006EA  0805 0000               1297mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006EE  6700 0010               1298mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006F2                          1299mm 
000006F2                          1300mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006F2                 TRUE     1301mmm     IFEQ DEBUG
000006F2  1A39 00C00007           1302mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006F8                          1303mmm     ENDC
000006F8                 FALSE    1304mmm     IFNE DEBUG
000006F8                          1305mmm     ENDC
000006F8                          1306mmm 
000006F8  BA3C 001B               1307mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006FC  6700 F90A               1308mmm     BEQ START
00000700                          1309mmm     ENDM
00000700                          1310mm CONTINUE_76
00000700  1A39 00C00013           1311mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000706  0805 0000               1312mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000070A  67D8                    1313mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
0000070C                          1314mm     
0000070C  1A39 00C00017           1315mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000712  13C5 00E00001           1316mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000718                          1317mm 
00000718                          1318mm     ENDM
00000718                          1319mm         PRINT_CHAR D5,D6
00000718                          1320mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000718                 TRUE     1321mm     IFEQ DEBUG
00000718  1C39 00C00003           1322mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000071E  0806 0002               1323mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000722  67F4                    1324mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
00000724  13C5 00C00007           1325mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000072A                          1326mm     ENDC
0000072A                          1327mm 
0000072A                 FALSE    1328mm     IFNE DEBUG
0000072A                          1329mm     ENDC
0000072A                          1330mm 
0000072A                          1331mm     ENDM
0000072A                          1332mm         HEX2BIN D5,D5,A4
0000072A  49FA 0A0C               1333mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000072E  0405 0030               1334mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000732  CABC 000000FF           1335mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000738  1A34 5000               1336mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000073C                          1337mm     ENDM
0000073C  8805                    1338m         OR.B D5,D4
0000073E  5307                    1339m         SUB.B #1,D7
00000740                          1340m     ENDW
00000740  6098                    1341ms     BRA _1000000C
00000742                          1342ms _1000000D
00000742                          1343m 
00000742  7A00                    1344m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000744  1A04                    1345m     MOVE.B D4,D5
00000746  D484                    1346m     ADD.L D4,D2
00000748                          1347m 
00000748                          1348m     ENDM
00000748                          1349m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000748  1E3C 0002               1350m     MOVE.B #2,D7
0000074C                          1351m     WHILE.B D7 <GT> 0 DO
0000074C                          1352ms _1000000E
0000074C  BE38 0000               1353ms     CMP.B   0,D7
00000750  6F00 0062               1354ms     BLE _1000000F
00000754  E98C                    1355m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000756                          1356mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000756                          1357mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000756                          1358mm 
00000756  1A39 00C00003           1359mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075C  0805 0000               1360mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000760  6700 0010               1361mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
00000764                          1362mm 
00000764                          1363mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000764                 TRUE     1364mmm     IFEQ DEBUG
00000764  1A39 00C00007           1365mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000076A                          1366mmm     ENDC
0000076A                 FALSE    1367mmm     IFNE DEBUG
0000076A                          1368mmm     ENDC
0000076A                          1369mmm 
0000076A  BA3C 001B               1370mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000076E  6700 F898               1371mmm     BEQ START
00000772                          1372mmm     ENDM
00000772                          1373mm CONTINUE_81
00000772  1A39 00C00013           1374mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000778  0805 0000               1375mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000077C  67D8                    1376mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
0000077E                          1377mm     
0000077E  1A39 00C00017           1378mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000784  13C5 00E00001           1379mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000078A                          1380mm 
0000078A                          1381mm     ENDM
0000078A                          1382mm         PRINT_CHAR D5,D6
0000078A                          1383mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078A                 TRUE     1384mm     IFEQ DEBUG
0000078A  1C39 00C00003           1385mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000790  0806 0002               1386mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000794  67F4                    1387mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000796  13C5 00C00007           1388mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000079C                          1389mm     ENDC
0000079C                          1390mm 
0000079C                 FALSE    1391mm     IFNE DEBUG
0000079C                          1392mm     ENDC
0000079C                          1393mm 
0000079C                          1394mm     ENDM
0000079C                          1395mm         HEX2BIN D5,D5,A4
0000079C  49FA 099A               1396mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A0  0405 0030               1397mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007A4  CABC 000000FF           1398mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007AA  1A34 5000               1399mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007AE                          1400mm     ENDM
000007AE  8805                    1401m         OR.B D5,D4
000007B0  5307                    1402m         SUB.B #1,D7
000007B2                          1403m     ENDW
000007B2  6098                    1404ms     BRA _1000000E
000007B4                          1405ms _1000000F
000007B4                          1406m 
000007B4  7A00                    1407m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B6  1A04                    1408m     MOVE.B D4,D5
000007B8  D484                    1409m     ADD.L D4,D2
000007BA                          1410m 
000007BA                          1411m     ENDM
000007BA                          1412m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000007BA  1E3C 0002               1413m     MOVE.B #2,D7
000007BE                          1414m     WHILE.B D7 <GT> 0 DO
000007BE                          1415ms _10000010
000007BE  BE38 0000               1416ms     CMP.B   0,D7
000007C2  6F00 0062               1417ms     BLE _10000011
000007C6  E98C                    1418m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C8                          1419mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C8                          1420mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C8                          1421mm 
000007C8  1A39 00C00003           1422mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007CE  0805 0000               1423mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007D2  6700 0010               1424mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007D6                          1425mm 
000007D6                          1426mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007D6                 TRUE     1427mmm     IFEQ DEBUG
000007D6  1A39 00C00007           1428mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007DC                          1429mmm     ENDC
000007DC                 FALSE    1430mmm     IFNE DEBUG
000007DC                          1431mmm     ENDC
000007DC                          1432mmm 
000007DC  BA3C 001B               1433mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007E0  6700 F826               1434mmm     BEQ START
000007E4                          1435mmm     ENDM
000007E4                          1436mm CONTINUE_86
000007E4  1A39 00C00013           1437mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007EA  0805 0000               1438mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007EE  67D8                    1439mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007F0                          1440mm     
000007F0  1A39 00C00017           1441mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007F6  13C5 00E00001           1442mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007FC                          1443mm 
000007FC                          1444mm     ENDM
000007FC                          1445mm         PRINT_CHAR D5,D6
000007FC                          1446mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FC                 TRUE     1447mm     IFEQ DEBUG
000007FC  1C39 00C00003           1448mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000802  0806 0002               1449mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000806  67F4                    1450mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
00000808  13C5 00C00007           1451mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000080E                          1452mm     ENDC
0000080E                          1453mm 
0000080E                 FALSE    1454mm     IFNE DEBUG
0000080E                          1455mm     ENDC
0000080E                          1456mm 
0000080E                          1457mm     ENDM
0000080E                          1458mm         HEX2BIN D5,D5,A4
0000080E  49FA 0928               1459mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000812  0405 0030               1460mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000816  CABC 000000FF           1461mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000081C  1A34 5000               1462mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000820                          1463mm     ENDM
00000820  8805                    1464m         OR.B D5,D4
00000822  5307                    1465m         SUB.B #1,D7
00000824                          1466m     ENDW
00000824  6098                    1467ms     BRA _10000010
00000826                          1468ms _10000011
00000826                          1469m 
00000826  7A00                    1470m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000828  1A04                    1471m     MOVE.B D4,D5
0000082A  D484                    1472m     ADD.L D4,D2
0000082C                          1473m 
0000082C                          1474m     ENDM
0000082C                          1475  
0000082C  2044                    1476                  MOVE.L D4,A0                        ; start address -> A0
0000082E  D1C9                    1477                  ADD.L A1,A0                         ; add in the offset
00000830                          1478  
00000830  72FF                    1479                  MOVE.L #$FFFFFFFF,D1                ; done
00000832                          1480              ELSE
00000832  6000 0078               1481s     BRA _00000009
00000836                          1482s _00000008
00000836                          1483m                 PRINT_CRLF D5,A4
00000836  49FA 092B               1484m     LEA CRLF(PC),A4
0000083A                          1485mm     PRINT_STR A4,D5
0000083A                          1486mm LOOP_91
0000083A  0C14 0000               1487mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000083E  6700 0016               1488mm     BEQ EXIT_91
00000842                          1489mmm     PRINT_CHAR (A4)+,D5
00000842                          1490mmm WAIT_FOR_READY_92                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000842                 TRUE     1491mmm     IFEQ DEBUG
00000842  1A39 00C00003           1492mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000848  0805 0002               1493mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000084C  67F4                    1494mmm         BEQ WAIT_FOR_READY_92                       ; NO SPACE, CHECK AGAIN
0000084E  13DC 00C00007           1495mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000854                          1496mmm     ENDC
00000854                          1497mmm 
00000854                 FALSE    1498mmm     IFNE DEBUG
00000854                          1499mmm     ENDC
00000854                          1500mmm 
00000854                          1501mmm     ENDM
00000854  60E4                    1502mm     BRA LOOP_91
00000856                          1503mm EXIT_91
00000856                          1504mm     ENDM
00000856                          1505m     ENDM
00000856                          1506  
00000856  49FA 0895               1507                  LEA UNREC(PC),A4                    ; warn for unrecognised type
0000085A                          1508m                 PRINT_STR A4,D5
0000085A                          1509m LOOP_93
0000085A  0C14 0000               1510m     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000085E  6700 0016               1511m     BEQ EXIT_93
00000862                          1512mm     PRINT_CHAR (A4)+,D5
00000862                          1513mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000862                 TRUE     1514mm     IFEQ DEBUG
00000862  1A39 00C00003           1515mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000868  0805 0002               1516mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000086C  67F4                    1517mm         BEQ WAIT_FOR_READY_94                       ; NO SPACE, CHECK AGAIN
0000086E  13DC 00C00007           1518mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000874                          1519mm     ENDC
00000874                          1520mm 
00000874                 FALSE    1521mm     IFNE DEBUG
00000874                          1522mm     ENDC
00000874                          1523mm 
00000874                          1524mm     ENDM
00000874  60E4                    1525m     BRA LOOP_93
00000876                          1526m EXIT_93
00000876                          1527m     ENDM
00000876                          1528m                 PRINT_CHAR D1,D5
00000876                          1529m WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000876                 TRUE     1530m     IFEQ DEBUG
00000876  1A39 00C00003           1531m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000087C  0805 0002               1532m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000880  67F4                    1533m         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000882  13C1 00C00007           1534m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000888                          1535m     ENDC
00000888                          1536m 
00000888                 FALSE    1537m     IFNE DEBUG
00000888                          1538m     ENDC
00000888                          1539m 
00000888                          1540m     ENDM
00000888                          1541m                 PRINT_CRLF D5,A4
00000888  49FA 08D9               1542m     LEA CRLF(PC),A4
0000088C                          1543mm     PRINT_STR A4,D5
0000088C                          1544mm LOOP_97
0000088C  0C14 0000               1545mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000890  6700 0016               1546mm     BEQ EXIT_97
00000894                          1547mmm     PRINT_CHAR (A4)+,D5
00000894                          1548mmm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000894                 TRUE     1549mmm     IFEQ DEBUG
00000894  1A39 00C00003           1550mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000089A  0805 0002               1551mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000089E  67F4                    1552mmm         BEQ WAIT_FOR_READY_98                       ; NO SPACE, CHECK AGAIN
000008A0  13DC 00C00007           1553mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008A6                          1554mmm     ENDC
000008A6                          1555mmm 
000008A6                 FALSE    1556mmm     IFNE DEBUG
000008A6                          1557mmm     ENDC
000008A6                          1558mmm 
000008A6                          1559mmm     ENDM
000008A6  60E4                    1560mm     BRA LOOP_97
000008A8                          1561mm EXIT_97
000008A8                          1562mm     ENDM
000008A8                          1563m     ENDM
000008A8                          1564  
000008A8  6000 FAEC               1565                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
000008AC                          1566              ENDI
000008AC                          1567s _00000009
000008AC                          1568          ENDI
000008AC                          1569s _00000007
000008AC                          1570      ENDI
000008AC                          1571s _00000003
000008AC                          1572  
000008AC                          1573m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
000008AC  1E3C 0002               1574m     MOVE.B #2,D7
000008B0                          1575m     WHILE.B D7 <GT> 0 DO
000008B0                          1576ms _10000012
000008B0  BE38 0000               1577ms     CMP.B   0,D7
000008B4  6F00 0062               1578ms     BLE _10000013
000008B8  E98C                    1579m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008BA                          1580mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008BA                          1581mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BA                          1582mm 
000008BA  1A39 00C00003           1583mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C0  0805 0000               1584mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C4  6700 0010               1585mm     BEQ CONTINUE_100                                    ; NOTHING, CONTINUE
000008C8                          1586mm 
000008C8                          1587mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008C8                 TRUE     1588mmm     IFEQ DEBUG
000008C8  1A39 00C00007           1589mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008CE                          1590mmm     ENDC
000008CE                 FALSE    1591mmm     IFNE DEBUG
000008CE                          1592mmm     ENDC
000008CE                          1593mmm 
000008CE  BA3C 001B               1594mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008D2  6700 F734               1595mmm     BEQ START
000008D6                          1596mmm     ENDM
000008D6                          1597mm CONTINUE_100
000008D6  1A39 00C00013           1598mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DC  0805 0000               1599mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  67D8                    1600mm     BEQ WAIT_FOR_READY_100                          ; NOTHING, CHECK AGAIN
000008E2                          1601mm     
000008E2  1A39 00C00017           1602mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008E8  13C5 00E00001           1603mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008EE                          1604mm 
000008EE                          1605mm     ENDM
000008EE                          1606mm         PRINT_CHAR D5,D6
000008EE                          1607mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1608mm     IFEQ DEBUG
000008EE  1C39 00C00003           1609mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008F4  0806 0002               1610mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1611mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
000008FA  13C5 00C00007           1612mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000900                          1613mm     ENDC
00000900                          1614mm 
00000900                 FALSE    1615mm     IFNE DEBUG
00000900                          1616mm     ENDC
00000900                          1617mm 
00000900                          1618mm     ENDM
00000900                          1619mm         HEX2BIN D5,D5,A4
00000900  49FA 0836               1620mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000904  0405 0030               1621mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000908  CABC 000000FF           1622mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090E  1A34 5000               1623mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000912                          1624mm     ENDM
00000912  8805                    1625m         OR.B D5,D4
00000914  5307                    1626m         SUB.B #1,D7
00000916                          1627m     ENDW
00000916  6098                    1628ms     BRA _10000012
00000918                          1629ms _10000013
00000918                          1630m 
00000918  7A00                    1631m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000091A  1A04                    1632m     MOVE.B D4,D5
0000091C  D484                    1633m     ADD.L D4,D2
0000091E                          1634m 
0000091E                          1635m     ENDM
0000091E                          1636m     PRINT_CRLF D5,A4
0000091E  49FA 0843               1637m     LEA CRLF(PC),A4
00000922                          1638mm     PRINT_STR A4,D5
00000922                          1639mm LOOP_105
00000922  0C14 0000               1640mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000926  6700 0016               1641mm     BEQ EXIT_105
0000092A                          1642mmm     PRINT_CHAR (A4)+,D5
0000092A                          1643mmm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092A                 TRUE     1644mmm     IFEQ DEBUG
0000092A  1A39 00C00003           1645mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000930  0805 0002               1646mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000934  67F4                    1647mmm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000936  13DC 00C00007           1648mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000093C                          1649mmm     ENDC
0000093C                          1650mmm 
0000093C                 FALSE    1651mmm     IFNE DEBUG
0000093C                          1652mmm     ENDC
0000093C                          1653mmm 
0000093C                          1654mmm     ENDM
0000093C  60E4                    1655mm     BRA LOOP_105
0000093E                          1656mm EXIT_105
0000093E                          1657mm     ENDM
0000093E                          1658m     ENDM
0000093E                          1659  
0000093E                          1660      IF.B D2 <NE> #$FF THEN.L
0000093E  B43C 00FF               1661s     CMP.B   #$FF,D2
00000942  6700 0090               1662s     BEQ.L   _0000000A
00000946  49FA 07BC               1663          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
0000094A                          1664m         PRINT_STR A4,D5
0000094A                          1665m LOOP_107
0000094A  0C14 0000               1666m     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000094E  6700 0016               1667m     BEQ EXIT_107
00000952                          1668mm     PRINT_CHAR (A4)+,D5
00000952                          1669mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000952                 TRUE     1670mm     IFEQ DEBUG
00000952  1A39 00C00003           1671mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000958  0805 0002               1672mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000095C  67F4                    1673mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
0000095E  13DC 00C00007           1674mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000964                          1675mm     ENDC
00000964                          1676mm 
00000964                 FALSE    1677mm     IFNE DEBUG
00000964                          1678mm     ENDC
00000964                          1679mm 
00000964                          1680mm     ENDM
00000964  60E4                    1681m     BRA LOOP_107
00000966                          1682m EXIT_107
00000966                          1683m     ENDM
00000966                          1684m         PRINT_REG D0,D5,D2,D6,A4
00000966  49FA 0801               1685m     LEA OX(PC),A4
0000096A                          1686mm     PRINT_STR A4,D5
0000096A                          1687mm LOOP_110
0000096A  0C14 0000               1688mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000096E  6700 0016               1689mm     BEQ EXIT_110
00000972                          1690mmm     PRINT_CHAR (A4)+,D5
00000972                          1691mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000972                 TRUE     1692mmm     IFEQ DEBUG
00000972  1A39 00C00003           1693mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000978  0805 0002               1694mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000097C  67F4                    1695mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
0000097E  13DC 00C00007           1696mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000984                          1697mmm     ENDC
00000984                          1698mmm 
00000984                 FALSE    1699mmm     IFNE DEBUG
00000984                          1700mmm     ENDC
00000984                          1701mmm 
00000984                          1702mmm     ENDM
00000984  60E4                    1703mm     BRA LOOP_110
00000986                          1704mm EXIT_110
00000986                          1705mm     ENDM
00000986  7C07                    1706m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000988                          1707m LOOP_109
00000988                          1708mm     BIN2HEX D0,D2,A4
00000988  49FA 079E               1709mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000098C  E998                    1710mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000098E  1400                    1711mm     MOVE.B D0,D2
00000990  0282 0000000F           1712mm     ANDI.L #$F,D2
00000996  1434 2000               1713mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000099A                          1714mm     ENDM
0000099A                          1715mm     PRINT_CHAR D2,D5
0000099A                          1716mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099A                 TRUE     1717mm     IFEQ DEBUG
0000099A  1A39 00C00003           1718mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A0  0805 0002               1719mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A4  67F4                    1720mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009A6  13C2 00C00007           1721mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009AC                          1722mm     ENDC
000009AC                          1723mm 
000009AC                 FALSE    1724mm     IFNE DEBUG
000009AC                          1725mm     ENDC
000009AC                          1726mm 
000009AC                          1727mm     ENDM
000009AC  57CE FFDA               1728m     DBEQ D6,LOOP_109
000009B0                          1729m     ENDM
000009B0                          1730m         PRINT_CRLF D5,A4
000009B0  49FA 07B1               1731m     LEA CRLF(PC),A4
000009B4                          1732mm     PRINT_STR A4,D5
000009B4                          1733mm LOOP_115
000009B4  0C14 0000               1734mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009B8  6700 0016               1735mm     BEQ EXIT_115
000009BC                          1736mmm     PRINT_CHAR (A4)+,D5
000009BC                          1737mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BC                 TRUE     1738mmm     IFEQ DEBUG
000009BC  1A39 00C00003           1739mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009C2  0805 0002               1740mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009C6  67F4                    1741mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009C8  13DC 00C00007           1742mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009CE                          1743mmm     ENDC
000009CE                          1744mmm 
000009CE                 FALSE    1745mmm     IFNE DEBUG
000009CE                          1746mmm     ENDC
000009CE                          1747mmm 
000009CE                          1748mmm     ENDM
000009CE  60E4                    1749mm     BRA LOOP_115
000009D0                          1750mm EXIT_115
000009D0                          1751mm     ENDM
000009D0                          1752m     ENDM
000009D0  6000 F7A8               1753          BRA MAIN_LOOP
000009D4                          1754      ENDI
000009D4                          1755s _0000000A
000009D4                          1756  
000009D4                          1757      IF D1 <EQ> #0 THEN
000009D4  B27C 0000               1758s     CMP.W   #0,D1
000009D8  6600 0006               1759s     BNE _0000000B
000009DC  6000 F9B8               1760        BRA WAIT_FOR_SRECORD
000009E0                          1761      ENDI
000009E0                          1762s _0000000B
000009E0                          1763  DOWNLOAD_DONE
000009E0                          1764m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009E0  43FA 0787               1765m     LEA OX(PC),A1
000009E4                          1766mm     PRINT_STR A1,D5
000009E4                          1767mm LOOP_118
000009E4  0C11 0000               1768mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000009E8  6700 0016               1769mm     BEQ EXIT_118
000009EC                          1770mmm     PRINT_CHAR (A1)+,D5
000009EC                          1771mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EC                 TRUE     1772mmm     IFEQ DEBUG
000009EC  1A39 00C00003           1773mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009F2  0805 0002               1774mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009F6  67F4                    1775mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
000009F8  13D9 00C00007           1776mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009FE                          1777mmm     ENDC
000009FE                          1778mmm 
000009FE                 FALSE    1779mmm     IFNE DEBUG
000009FE                          1780mmm     ENDC
000009FE                          1781mmm 
000009FE                          1782mmm     ENDM
000009FE  60E4                    1783mm     BRA LOOP_118
00000A00                          1784mm EXIT_118
00000A00                          1785mm     ENDM
00000A00  7407                    1786m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A02                          1787m LOOP_117
00000A02                          1788mm     BIN2HEX D0,D6,A1
00000A02  43FA 0724               1789mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A06  E998                    1790mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A08  1C00                    1791mm     MOVE.B D0,D6
00000A0A  0286 0000000F           1792mm     ANDI.L #$F,D6
00000A10  1C31 6000               1793mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A14                          1794mm     ENDM
00000A14                          1795mm     PRINT_CHAR D6,D5
00000A14                          1796mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A14                 TRUE     1797mm     IFEQ DEBUG
00000A14  1A39 00C00003           1798mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A1A  0805 0002               1799mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A1E  67F4                    1800mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A20  13C6 00C00007           1801mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A26                          1802mm     ENDC
00000A26                          1803mm 
00000A26                 FALSE    1804mm     IFNE DEBUG
00000A26                          1805mm     ENDC
00000A26                          1806mm 
00000A26                          1807mm     ENDM
00000A26  57CA FFDA               1808m     DBEQ D2,LOOP_117
00000A2A                          1809m     ENDM
00000A2A  43FA 069F               1810      LEA READ(PC),A1
00000A2E                          1811m     PRINT_STR A1,D5
00000A2E                          1812m LOOP_122
00000A2E  0C11 0000               1813m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A32  6700 0016               1814m     BEQ EXIT_122
00000A36                          1815mm     PRINT_CHAR (A1)+,D5
00000A36                          1816mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A36                 TRUE     1817mm     IFEQ DEBUG
00000A36  1A39 00C00003           1818mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A3C  0805 0002               1819mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A40  67F4                    1820mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A42  13D9 00C00007           1821mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A48                          1822mm     ENDC
00000A48                          1823mm 
00000A48                 FALSE    1824mm     IFNE DEBUG
00000A48                          1825mm     ENDC
00000A48                          1826mm 
00000A48                          1827mm     ENDM
00000A48  60E4                    1828m     BRA LOOP_122
00000A4A                          1829m EXIT_122
00000A4A                          1830m     ENDM
00000A4A  2E08                    1831      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A4C                          1832m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A4C  43FA 071B               1833m     LEA OX(PC),A1
00000A50                          1834mm     PRINT_STR A1,D5
00000A50                          1835mm LOOP_125
00000A50  0C11 0000               1836mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A54  6700 0016               1837mm     BEQ EXIT_125
00000A58                          1838mmm     PRINT_CHAR (A1)+,D5
00000A58                          1839mmm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A58                 TRUE     1840mmm     IFEQ DEBUG
00000A58  1A39 00C00003           1841mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A5E  0805 0002               1842mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A62  67F4                    1843mmm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A64  13D9 00C00007           1844mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A6A                          1845mmm     ENDC
00000A6A                          1846mmm 
00000A6A                 FALSE    1847mmm     IFNE DEBUG
00000A6A                          1848mmm     ENDC
00000A6A                          1849mmm 
00000A6A                          1850mmm     ENDM
00000A6A  60E4                    1851mm     BRA LOOP_125
00000A6C                          1852mm EXIT_125
00000A6C                          1853mm     ENDM
00000A6C  7407                    1854m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A6E                          1855m LOOP_124
00000A6E                          1856mm     BIN2HEX D7,D6,A1
00000A6E  43FA 06B8               1857mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A72  E99F                    1858mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A74  1C07                    1859mm     MOVE.B D7,D6
00000A76  0286 0000000F           1860mm     ANDI.L #$F,D6
00000A7C  1C31 6000               1861mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A80                          1862mm     ENDM
00000A80                          1863mm     PRINT_CHAR D6,D5
00000A80                          1864mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1865mm     IFEQ DEBUG
00000A80  1A39 00C00003           1866mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A86  0805 0002               1867mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1868mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000A8C  13C6 00C00007           1869mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A92                          1870mm     ENDC
00000A92                          1871mm 
00000A92                 FALSE    1872mm     IFNE DEBUG
00000A92                          1873mm     ENDC
00000A92                          1874mm 
00000A92                          1875mm     ENDM
00000A92  57CA FFDA               1876m     DBEQ D2,LOOP_124
00000A96                          1877m     ENDM
00000A96                          1878m     PRINT_CRLF D5,A4
00000A96  49FA 06CB               1879m     LEA CRLF(PC),A4
00000A9A                          1880mm     PRINT_STR A4,D5
00000A9A                          1881mm LOOP_130
00000A9A  0C14 0000               1882mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A9E  6700 0016               1883mm     BEQ EXIT_130
00000AA2                          1884mmm     PRINT_CHAR (A4)+,D5
00000AA2                          1885mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA2                 TRUE     1886mmm     IFEQ DEBUG
00000AA2  1A39 00C00003           1887mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA8  0805 0002               1888mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAC  67F4                    1889mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AAE  13DC 00C00007           1890mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB4                          1891mmm     ENDC
00000AB4                          1892mmm 
00000AB4                 FALSE    1893mmm     IFNE DEBUG
00000AB4                          1894mmm     ENDC
00000AB4                          1895mmm 
00000AB4                          1896mmm     ENDM
00000AB4  60E4                    1897mm     BRA LOOP_130
00000AB6                          1898mm EXIT_130
00000AB6                          1899mm     ENDM
00000AB6                          1900m     ENDM
00000AB6                          1901  
00000AB6  6000 F6C2               1902      BRA MAIN_LOOP
00000ABA                          1903  
00000ABA                          1904  G
00000ABA  2047                    1905      MOVE.L D7,A0                                    ; address accumulator -> address register
00000ABC  3E3C 0000               1906      MOVE #0,D7                                      ; clear the now used address accumulator
00000AC0  4ED0                    1907      JMP (A0)                                        ; jump to it!
00000AC2                          1908  
00000AC2                          1909  Z
00000AC2  207C 00200000           1910      MOVE.L #RAM,A0                                  ; address of RAM
00000AC8                          1911      
00000AC8                          1912      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; write
00000AC8  7000                    1913s     MOVE.L  #0,D0
00000ACA  6000 0012               1914s     BRA _20000005
00000ACE                          1915s _20000004
00000ACE  2200                    1916          MOVE.L D0,D1                                ; progress update
00000AD0  E089                    1917          LSR.L #8,D1 
00000AD2  E089                    1918          LSR.L #8,D1
00000AD4  13C1 00E00001           1919          MOVE.B D1,DISPLAY
00000ADA                          1920  
00000ADA  20C0                    1921          MOVE.L D0,(A0)+
00000ADC                          1922      ENDF
00000ADC  5880                    1923s     ADD.L   #4,D0
00000ADE                          1924s _20000005
00000ADE  B0BC 00040000           1925s     CMP.L   #$40000,D0
00000AE4  6FE8                    1926s     BLE _20000004
00000AE6                          1927  
00000AE6  207C 00200000           1928      MOVE.L #RAM,A0                                  ; address of RAM
00000AEC                          1929  
00000AEC                          1930      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AEC  7000                    1931s     MOVE.L  #0,D0
00000AEE  6000 00A6               1932s     BRA _20000007
00000AF2                          1933s _20000006
00000AF2  2200                    1934          MOVE.L D0,D1                                ; progress update
00000AF4  E089                    1935          LSR.L #8,D1
00000AF6  E089                    1936          LSR.L #8,D1
00000AF8  13C1 00E00001           1937          MOVE.B D1,DISPLAY
00000AFE                          1938  
00000AFE  2218                    1939          MOVE.L (A0)+,D1
00000B00                          1940  
00000B00                          1941          IF.L D0 <NE> D1 THEN
00000B00  B081                    1942s     CMP.L   D1,D0
00000B02  6700 0090               1943s     BEQ _0000000C
00000B06  43FA 060E               1944              LEA RAM_ERROR(PC),A1
00000B0A                          1945m             PRINT_STR A1,D1
00000B0A                          1946m LOOP_132
00000B0A  0C11 0000               1947m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B0E  6700 0016               1948m     BEQ EXIT_132
00000B12                          1949mm     PRINT_CHAR (A1)+,D1
00000B12                          1950mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B12                 TRUE     1951mm     IFEQ DEBUG
00000B12  1239 00C00003           1952mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B18  0801 0002               1953mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B1C  67F4                    1954mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B1E  13D9 00C00007           1955mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B24                          1956mm     ENDC
00000B24                          1957mm 
00000B24                 FALSE    1958mm     IFNE DEBUG
00000B24                          1959mm     ENDC
00000B24                          1960mm 
00000B24                          1961mm     ENDM
00000B24  60E4                    1962m     BRA LOOP_132
00000B26                          1963m EXIT_132
00000B26                          1964m     ENDM
00000B26  2208                    1965              MOVE.L A0,D1
00000B28  5981                    1966              SUB.L #4,D1
00000B2A                          1967m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B2A  43FA 063D               1968m     LEA OX(PC),A1
00000B2E                          1969mm     PRINT_STR A1,D3
00000B2E                          1970mm LOOP_135
00000B2E  0C11 0000               1971mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B32  6700 0016               1972mm     BEQ EXIT_135
00000B36                          1973mmm     PRINT_CHAR (A1)+,D3
00000B36                          1974mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B36                 TRUE     1975mmm     IFEQ DEBUG
00000B36  1639 00C00003           1976mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B3C  0803 0002               1977mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B40  67F4                    1978mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B42  13D9 00C00007           1979mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B48                          1980mmm     ENDC
00000B48                          1981mmm 
00000B48                 FALSE    1982mmm     IFNE DEBUG
00000B48                          1983mmm     ENDC
00000B48                          1984mmm 
00000B48                          1985mmm     ENDM
00000B48  60E4                    1986mm     BRA LOOP_135
00000B4A                          1987mm EXIT_135
00000B4A                          1988mm     ENDM
00000B4A  7C07                    1989m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B4C                          1990m LOOP_134
00000B4C                          1991mm     BIN2HEX D1,D2,A1
00000B4C  43FA 05DA               1992mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B50  E999                    1993mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B52  1401                    1994mm     MOVE.B D1,D2
00000B54  0282 0000000F           1995mm     ANDI.L #$F,D2
00000B5A  1431 2000               1996mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000B5E                          1997mm     ENDM
00000B5E                          1998mm     PRINT_CHAR D2,D3
00000B5E                          1999mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5E                 TRUE     2000mm     IFEQ DEBUG
00000B5E  1639 00C00003           2001mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B64  0803 0002               2002mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B68  67F4                    2003mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B6A  13C2 00C00007           2004mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B70                          2005mm     ENDC
00000B70                          2006mm 
00000B70                 FALSE    2007mm     IFNE DEBUG
00000B70                          2008mm     ENDC
00000B70                          2009mm 
00000B70                          2010mm     ENDM
00000B70  57CE FFDA               2011m     DBEQ D6,LOOP_134
00000B74                          2012m     ENDM
00000B74                          2013m             PRINT_CRLF D3,A1
00000B74  43FA 05ED               2014m     LEA CRLF(PC),A1
00000B78                          2015mm     PRINT_STR A1,D3
00000B78                          2016mm LOOP_140
00000B78  0C11 0000               2017mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B7C  6700 0016               2018mm     BEQ EXIT_140
00000B80                          2019mmm     PRINT_CHAR (A1)+,D3
00000B80                          2020mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B80                 TRUE     2021mmm     IFEQ DEBUG
00000B80  1639 00C00003           2022mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B86  0803 0002               2023mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B8A  67F4                    2024mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B8C  13D9 00C00007           2025mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B92                          2026mmm     ENDC
00000B92                          2027mmm 
00000B92                 FALSE    2028mmm     IFNE DEBUG
00000B92                          2029mmm     ENDC
00000B92                          2030mmm 
00000B92                          2031mmm     ENDM
00000B92  60E4                    2032mm     BRA LOOP_140
00000B94                          2033mm EXIT_140
00000B94                          2034mm     ENDM
00000B94                          2035m     ENDM
00000B94                          2036          ENDI 
00000B94                          2037s _0000000C
00000B94                          2038      ENDF
00000B94  5880                    2039s     ADD.L   #4,D0
00000B96                          2040s _20000007
00000B96  B0BC 00040000           2041s     CMP.L   #$40000,D0
00000B9C  6F00 FF54               2042s     BLE _20000006
00000BA0                          2043  
00000BA0  6000 F5D8               2044      BRA MAIN_LOOP
00000BA4                          2045  
00000BA4                          2046  L
00000BA4  7000                    2047      MOVE.L #0,D0                                    ; D0 will be the length  to write              
00000BA6  7200                    2048      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000BA8                          2049  
00000BA8                          2050      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000BA8  343C 0000               2051s     MOVE.W  #0,D2
00000BAC  6000 0046               2052s     BRA _20000009
00000BB0                          2053s _20000008
00000BB0  E989                    2054          LSL.L #4,D1                                 ; make what we have so far more significant
00000BB2                          2055m         WAIT_CHAR D3,D4                             ; next character -> D2
00000BB2                          2056m WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB2                 TRUE     2057m     IFEQ DEBUG
00000BB2  1839 00C00003           2058m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BB8  0804 0000               2059m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000BBC  67F4                    2060m         BEQ WAIT_FOR_READY_142                      ; NOTHING, CHECK AGAIN
00000BBE                          2061m     ENDC
00000BBE                          2062m 
00000BBE                          2063mm     READ_CHAR D3
00000BBE                 TRUE     2064mm     IFEQ DEBUG
00000BBE  1639 00C00007           2065mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000BC4                          2066mm     ENDC
00000BC4                 FALSE    2067mm     IFNE DEBUG
00000BC4                          2068mm     ENDC
00000BC4                          2069mm 
00000BC4  B63C 001B               2070mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000BC8  6700 F43E               2071mm     BEQ START
00000BCC                          2072mm     ENDM
00000BCC                          2073m 
00000BCC                 TRUE     2074m     IFEQ DEBUG
00000BCC                          2075mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000BCC                          2076mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCC                 TRUE     2077mm     IFEQ DEBUG
00000BCC  1839 00C00003           2078mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BD2  0804 0002               2079mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000BD6  67F4                    2080mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000BD8  13C3 00C00007           2081mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BDE                          2082mm     ENDC
00000BDE                          2083mm 
00000BDE                 FALSE    2084mm     IFNE DEBUG
00000BDE                          2085mm     ENDC
00000BDE                          2086mm 
00000BDE                          2087mm     ENDM
00000BDE                          2088m     ENDC
00000BDE                          2089m     ENDM
00000BDE                          2090m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BDE  41FA 0558               2091m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BE2  0403 0030               2092m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BE6  C6BC 000000FF           2093m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BEC  1630 3000               2094m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BF0                          2095m     ENDM
00000BF0  8203                    2096          OR.B D3,D1
00000BF2                          2097      ENDF
00000BF2  5242                    2098s     ADD.W   #1,D2
00000BF4                          2099s _20000009
00000BF4  B47C 0007               2100s     CMP.W   #7,D2
00000BF8  6FB6                    2101s     BLE _20000008
00000BFA                          2102  
00000BFA  3001                    2103      MOVE.W D1,D0                                    ; extract the LSword for the length
00000BFC  E089                    2104      LSR.L #8,D1                                     ; extract the MSword for the address
00000BFE  E089                    2105      LSR.L #8,D1
00000C00                          2106  
00000C00                          2107m     PRINT_CRLF D2,A1
00000C00  43FA 0561               2108m     LEA CRLF(PC),A1
00000C04                          2109mm     PRINT_STR A1,D2
00000C04                          2110mm LOOP_147
00000C04  0C11 0000               2111mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C08  6700 0016               2112mm     BEQ EXIT_147
00000C0C                          2113mmm     PRINT_CHAR (A1)+,D2
00000C0C                          2114mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C0C                 TRUE     2115mmm     IFEQ DEBUG
00000C0C  1439 00C00003           2116mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C12  0802 0002               2117mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C16  67F4                    2118mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C18  13D9 00C00007           2119mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C1E                          2120mmm     ENDC
00000C1E                          2121mmm 
00000C1E                 FALSE    2122mmm     IFNE DEBUG
00000C1E                          2123mmm     ENDC
00000C1E                          2124mmm 
00000C1E                          2125mmm     ENDM
00000C1E  60E4                    2126mm     BRA LOOP_147
00000C20                          2127mm EXIT_147
00000C20                          2128mm     ENDM
00000C20                          2129m     ENDM
00000C20                          2130  
00000C20  2041                    2131      MOVE.L D1,A0                                    ; target address
00000C22                          2132  
00000C22  2247                    2133      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C24  7E00                    2134      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C26                          2135  
00000C26  5089                    2136      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000C28  5180                    2137      SUB.L #8,D0
00000C2A                          2138  
00000C2A                          2139m     UNPROTECT
00000C2A  31FC AAAA 2AAA          2140m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000C30  4E71                    2141m     NOP
00000C32  31FC 5555 1554          2142m     MOVE.W #$5555,$1554
00000C38  4E71                    2143m     NOP
00000C3A  31FC 8080 2AAA          2144m     MOVE.W #$8080,$2AAA
00000C40  4E71                    2145m     NOP
00000C42  31FC AAAA 2AAA          2146m     MOVE.W #$AAAA,$2AAA
00000C48  4E71                    2147m     NOP
00000C4A  31FC 5555 1554          2148m     MOVE.W #$5555,$1554
00000C50  4E71                    2149m     NOP
00000C52  31FC 2020 2AAA          2150m     MOVE.W #$2020,$2AAA
00000C58                          2151m     ENDM
00000C58                          2152  
00000C58  45FA 04F5               2153      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000C5C                          2154m     PRINT_STR A2,D2
00000C5C                          2155m LOOP_150
00000C5C  0C12 0000               2156m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C60  6700 0016               2157m     BEQ EXIT_150
00000C64                          2158mm     PRINT_CHAR (A2)+,D2
00000C64                          2159mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C64                 TRUE     2160mm     IFEQ DEBUG
00000C64  1439 00C00003           2161mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C6A  0802 0002               2162mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C6E  67F4                    2163mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C70  13DA 00C00007           2164mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C76                          2165mm     ENDC
00000C76                          2166mm 
00000C76                 FALSE    2167mm     IFNE DEBUG
00000C76                          2168mm     ENDC
00000C76                          2169mm 
00000C76                          2170mm     ENDM
00000C76  60E4                    2171m     BRA LOOP_150
00000C78                          2172m EXIT_150
00000C78                          2173m     ENDM
00000C78                          2174  
00000C78  2409                    2175      MOVE.L A1,D2
00000C7A                          2176m     PRINT_REG D2,D3,D4,D5,A2
00000C7A  45FA 04ED               2177m     LEA OX(PC),A2
00000C7E                          2178mm     PRINT_STR A2,D3
00000C7E                          2179mm LOOP_153
00000C7E  0C12 0000               2180mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C82  6700 0016               2181mm     BEQ EXIT_153
00000C86                          2182mmm     PRINT_CHAR (A2)+,D3
00000C86                          2183mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C86                 TRUE     2184mmm     IFEQ DEBUG
00000C86  1639 00C00003           2185mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C8C  0803 0002               2186mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C90  67F4                    2187mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C92  13DA 00C00007           2188mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C98                          2189mmm     ENDC
00000C98                          2190mmm 
00000C98                 FALSE    2191mmm     IFNE DEBUG
00000C98                          2192mmm     ENDC
00000C98                          2193mmm 
00000C98                          2194mmm     ENDM
00000C98  60E4                    2195mm     BRA LOOP_153
00000C9A                          2196mm EXIT_153
00000C9A                          2197mm     ENDM
00000C9A  7A07                    2198m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C9C                          2199m LOOP_152
00000C9C                          2200mm     BIN2HEX D2,D4,A2
00000C9C  45FA 048A               2201mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000CA0  E99A                    2202mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CA2  1802                    2203mm     MOVE.B D2,D4
00000CA4  0284 0000000F           2204mm     ANDI.L #$F,D4
00000CAA  1832 4000               2205mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000CAE                          2206mm     ENDM
00000CAE                          2207mm     PRINT_CHAR D4,D3
00000CAE                          2208mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAE                 TRUE     2209mm     IFEQ DEBUG
00000CAE  1639 00C00003           2210mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CB4  0803 0002               2211mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CB8  67F4                    2212mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CBA  13C4 00C00007           2213mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CC0                          2214mm     ENDC
00000CC0                          2215mm 
00000CC0                 FALSE    2216mm     IFNE DEBUG
00000CC0                          2217mm     ENDC
00000CC0                          2218mm 
00000CC0                          2219mm     ENDM
00000CC0  57CD FFDA               2220m     DBEQ D5,LOOP_152
00000CC4                          2221m     ENDM
00000CC4                          2222  
00000CC4  45FA 04A6               2223      LEA TO(PC),A2
00000CC8                          2224m     PRINT_STR A2,D3
00000CC8                          2225m LOOP_157
00000CC8  0C12 0000               2226m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CCC  6700 0016               2227m     BEQ EXIT_157
00000CD0                          2228mm     PRINT_CHAR (A2)+,D3
00000CD0                          2229mm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD0                 TRUE     2230mm     IFEQ DEBUG
00000CD0  1639 00C00003           2231mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CD6  0803 0002               2232mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CDA  67F4                    2233mm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000CDC  13DA 00C00007           2234mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE2                          2235mm     ENDC
00000CE2                          2236mm 
00000CE2                 FALSE    2237mm     IFNE DEBUG
00000CE2                          2238mm     ENDC
00000CE2                          2239mm 
00000CE2                          2240mm     ENDM
00000CE2  60E4                    2241m     BRA LOOP_157
00000CE4                          2242m EXIT_157
00000CE4                          2243m     ENDM
00000CE4                          2244  
00000CE4  2408                    2245      MOVE.L A0,D2
00000CE6                          2246m     PRINT_REG D2,D3,D4,D5,A2
00000CE6  45FA 0481               2247m     LEA OX(PC),A2
00000CEA                          2248mm     PRINT_STR A2,D3
00000CEA                          2249mm LOOP_160
00000CEA  0C12 0000               2250mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CEE  6700 0016               2251mm     BEQ EXIT_160
00000CF2                          2252mmm     PRINT_CHAR (A2)+,D3
00000CF2                          2253mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF2                 TRUE     2254mmm     IFEQ DEBUG
00000CF2  1639 00C00003           2255mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CF8  0803 0002               2256mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CFC  67F4                    2257mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000CFE  13DA 00C00007           2258mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D04                          2259mmm     ENDC
00000D04                          2260mmm 
00000D04                 FALSE    2261mmm     IFNE DEBUG
00000D04                          2262mmm     ENDC
00000D04                          2263mmm 
00000D04                          2264mmm     ENDM
00000D04  60E4                    2265mm     BRA LOOP_160
00000D06                          2266mm EXIT_160
00000D06                          2267mm     ENDM
00000D06  7A07                    2268m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D08                          2269m LOOP_159
00000D08                          2270mm     BIN2HEX D2,D4,A2
00000D08  45FA 041E               2271mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D0C  E99A                    2272mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D0E  1802                    2273mm     MOVE.B D2,D4
00000D10  0284 0000000F           2274mm     ANDI.L #$F,D4
00000D16  1832 4000               2275mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D1A                          2276mm     ENDM
00000D1A                          2277mm     PRINT_CHAR D4,D3
00000D1A                          2278mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D1A                 TRUE     2279mm     IFEQ DEBUG
00000D1A  1639 00C00003           2280mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D20  0803 0002               2281mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D24  67F4                    2282mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D26  13C4 00C00007           2283mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D2C                          2284mm     ENDC
00000D2C                          2285mm 
00000D2C                 FALSE    2286mm     IFNE DEBUG
00000D2C                          2287mm     ENDC
00000D2C                          2288mm 
00000D2C                          2289mm     ENDM
00000D2C  57CD FFDA               2290m     DBEQ D5,LOOP_159
00000D30                          2291m     ENDM
00000D30                          2292  
00000D30                          2293m     PRINT_CRLF D3,A2
00000D30  45FA 0431               2294m     LEA CRLF(PC),A2
00000D34                          2295mm     PRINT_STR A2,D3
00000D34                          2296mm LOOP_165
00000D34  0C12 0000               2297mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D38  6700 0016               2298mm     BEQ EXIT_165
00000D3C                          2299mmm     PRINT_CHAR (A2)+,D3
00000D3C                          2300mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3C                 TRUE     2301mmm     IFEQ DEBUG
00000D3C  1639 00C00003           2302mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D42  0803 0002               2303mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D46  67F4                    2304mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D48  13DA 00C00007           2305mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D4E                          2306mmm     ENDC
00000D4E                          2307mmm 
00000D4E                 FALSE    2308mmm     IFNE DEBUG
00000D4E                          2309mmm     ENDC
00000D4E                          2310mmm 
00000D4E                          2311mmm     ENDM
00000D4E  60E4                    2312mm     BRA LOOP_165
00000D50                          2313mm EXIT_165
00000D50                          2314mm     ENDM
00000D50                          2315m     ENDM
00000D50                          2316  
00000D50                          2317      WHILE D0 <GT> #0 DO
00000D50                          2318s _10000014
00000D50  B07C 0000               2319s     CMP.W   #0,D0
00000D54  6F00 001C               2320s     BLE _10000015
00000D58  5580                    2321          SUB.L #2,D0
00000D5A                          2322  
00000D5A  13D1 00E00001           2323          MOVE.B (A1),DISPLAY
00000D60                          2324m         PROGRAM (A1),(A0),D2
00000D60  3091                    2325m   MOVE.W (A1),(A0)                                  ; WRITE THE DATA
00000D62                          2326m 
00000D62                          2327m WAIT_FOR_COMPLETE_167
00000D62  3410                    2328m         MOVE.W (A0),D2
00000D64                          2329m 
00000D64                          2330m         IF.W D2 <NE> (A1) THEN
00000D64  B451                    2331ms     CMP.W   (A1),D2
00000D66  6700 0004               2332ms     BEQ _0000000D
00000D6A  60F6                    2333m             BRA WAIT_FOR_COMPLETE_167
00000D6C                          2334m         ENDI
00000D6C                          2335ms _0000000D
00000D6C                          2336m         ENDM
00000D6C                          2337  
00000D6C  5488                    2338          ADD.L #2,A0
00000D6E  5489                    2339          ADD.L #2,A1
00000D70                          2340      ENDW
00000D70  60DE                    2341s     BRA _10000014
00000D72                          2342s _10000015
00000D72                          2343  
00000D72                          2344m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000D72  31FC 0000 0000          2345m   MOVE.W #0,$0                                  ; WRITE THE DATA
00000D78                          2346m 
00000D78                          2347m WAIT_FOR_COMPLETE_168
00000D78  3438 0000               2348m         MOVE.W $0,D2
00000D7C                          2349m 
00000D7C                          2350m         IF.W D2 <NE> #0 THEN
00000D7C  B47C 0000               2351ms     CMP.W   #0,D2
00000D80  6700 0004               2352ms     BEQ _0000000E
00000D84  60F2                    2353m             BRA WAIT_FOR_COMPLETE_168
00000D86                          2354m         ENDI
00000D86                          2355ms _0000000E
00000D86                          2356m         ENDM
00000D86                          2357m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D86  31FC 0000 0002          2358m   MOVE.W #0,$2                                  ; WRITE THE DATA
00000D8C                          2359m 
00000D8C                          2360m WAIT_FOR_COMPLETE_169
00000D8C  3438 0002               2361m         MOVE.W $2,D2
00000D90                          2362m 
00000D90                          2363m         IF.W D2 <NE> #0 THEN
00000D90  B47C 0000               2364ms     CMP.W   #0,D2
00000D94  6700 0004               2365ms     BEQ _0000000F
00000D98  60F2                    2366m             BRA WAIT_FOR_COMPLETE_169
00000D9A                          2367m         ENDI
00000D9A                          2368ms _0000000F
00000D9A                          2369m         ENDM
00000D9A                          2370  
00000D9A                          2371m     PROGRAM D1, $6, D2
00000D9A  31C1 0006               2372m   MOVE.W D1,$6                                  ; WRITE THE DATA
00000D9E                          2373m 
00000D9E                          2374m WAIT_FOR_COMPLETE_170
00000D9E  3438 0006               2375m         MOVE.W $6,D2
00000DA2                          2376m 
00000DA2                          2377m         IF.W D2 <NE> D1 THEN
00000DA2  B441                    2378ms     CMP.W   D1,D2
00000DA4  6700 0004               2379ms     BEQ _00000010
00000DA8  60F4                    2380m             BRA WAIT_FOR_COMPLETE_170
00000DAA                          2381m         ENDI
00000DAA                          2382ms _00000010
00000DAA                          2383m         ENDM
00000DAA  E089                    2384      LSR.L #8,D1
00000DAC  E089                    2385      LSR.L #8,D1
00000DAE                          2386m     PROGRAM D1, $4, D2
00000DAE  31C1 0004               2387m   MOVE.W D1,$4                                  ; WRITE THE DATA
00000DB2                          2388m 
00000DB2                          2389m WAIT_FOR_COMPLETE_171
00000DB2  3438 0004               2390m         MOVE.W $4,D2
00000DB6                          2391m 
00000DB6                          2392m         IF.W D2 <NE> D1 THEN
00000DB6  B441                    2393ms     CMP.W   D1,D2
00000DB8  6700 0004               2394ms     BEQ _00000011
00000DBC  60F4                    2395m             BRA WAIT_FOR_COMPLETE_171
00000DBE                          2396m         ENDI
00000DBE                          2397ms _00000011
00000DBE                          2398m         ENDM
00000DBE                          2399  
00000DBE                          2400m     PROTECT
00000DBE  31FC AAAA 2AAA          2401m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000DC4  31FC 5555 1554          2402m     MOVE.W #$5555,$1554
00000DCA  31FC A0A0 2AAA          2403m     MOVE.W #$A0A0,$2AAA
00000DD0                          2404m     ENDM
00000DD0                          2405  
00000DD0  6000 F3A8               2406      BRA MAIN_LOOP
00000DD4                          2407  
00000DD4                          2408  P
00000DD4  7000                    2409      MOVE.L #0,D0                                    ; D0 will be the data to write
00000DD6                          2410  
00000DD6                          2411      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000DD6  323C 0000               2412s     MOVE.W  #0,D1
00000DDA  6000 0046               2413s     BRA _2000000B
00000DDE                          2414s _2000000A
00000DDE  E988                    2415          LSL.L #4,D0                                 ; make what we have so far more significant
00000DE0                          2416m         WAIT_CHAR D2,D3                             ; next character -> D2
00000DE0                          2417m WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE0                 TRUE     2418m     IFEQ DEBUG
00000DE0  1639 00C00003           2419m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DE6  0803 0000               2420m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000DEA  67F4                    2421m         BEQ WAIT_FOR_READY_173                      ; NOTHING, CHECK AGAIN
00000DEC                          2422m     ENDC
00000DEC                          2423m 
00000DEC                          2424mm     READ_CHAR D2
00000DEC                 TRUE     2425mm     IFEQ DEBUG
00000DEC  1439 00C00007           2426mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000DF2                          2427mm     ENDC
00000DF2                 FALSE    2428mm     IFNE DEBUG
00000DF2                          2429mm     ENDC
00000DF2                          2430mm 
00000DF2  B43C 001B               2431mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000DF6  6700 F210               2432mm     BEQ START
00000DFA                          2433mm     ENDM
00000DFA                          2434m 
00000DFA                 TRUE     2435m     IFEQ DEBUG
00000DFA                          2436mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000DFA                          2437mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DFA                 TRUE     2438mm     IFEQ DEBUG
00000DFA  1639 00C00003           2439mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E00  0803 0002               2440mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E04  67F4                    2441mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00000E06  13C2 00C00007           2442mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E0C                          2443mm     ENDC
00000E0C                          2444mm 
00000E0C                 FALSE    2445mm     IFNE DEBUG
00000E0C                          2446mm     ENDC
00000E0C                          2447mm 
00000E0C                          2448mm     ENDM
00000E0C                          2449m     ENDC
00000E0C                          2450m     ENDM
00000E0C                          2451m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E0C  41FA 032A               2452m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E10  0402 0030               2453m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E14  C4BC 000000FF           2454m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E1A  1430 2000               2455m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E1E                          2456m     ENDM
00000E1E  8002                    2457          OR.B D2,D0
00000E20                          2458      ENDF
00000E20  5241                    2459s     ADD.W   #1,D1
00000E22                          2460s _2000000B
00000E22  B27C 0003               2461s     CMP.W   #3,D1
00000E26  6FB6                    2462s     BLE _2000000A
00000E28                          2463  
00000E28                          2464m     PRINT_CRLF D2,A1
00000E28  43FA 0339               2465m     LEA CRLF(PC),A1
00000E2C                          2466mm     PRINT_STR A1,D2
00000E2C                          2467mm LOOP_178
00000E2C  0C11 0000               2468mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E30  6700 0016               2469mm     BEQ EXIT_178
00000E34                          2470mmm     PRINT_CHAR (A1)+,D2
00000E34                          2471mmm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E34                 TRUE     2472mmm     IFEQ DEBUG
00000E34  1439 00C00003           2473mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E3A  0802 0002               2474mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E3E  67F4                    2475mmm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000E40  13D9 00C00007           2476mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E46                          2477mmm     ENDC
00000E46                          2478mmm 
00000E46                 FALSE    2479mmm     IFNE DEBUG
00000E46                          2480mmm     ENDC
00000E46                          2481mmm 
00000E46                          2482mmm     ENDM
00000E46  60E4                    2483mm     BRA LOOP_178
00000E48                          2484mm EXIT_178
00000E48                          2485mm     ENDM
00000E48                          2486m     ENDM
00000E48                          2487  
00000E48  2047                    2488      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000E4A  7E00                    2489      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E4C                          2490  
00000E4C                          2491m     UNPROTECT
00000E4C  31FC AAAA 2AAA          2492m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E52  4E71                    2493m     NOP
00000E54  31FC 5555 1554          2494m     MOVE.W #$5555,$1554
00000E5A  4E71                    2495m     NOP
00000E5C  31FC 8080 2AAA          2496m     MOVE.W #$8080,$2AAA
00000E62  4E71                    2497m     NOP
00000E64  31FC AAAA 2AAA          2498m     MOVE.W #$AAAA,$2AAA
00000E6A  4E71                    2499m     NOP
00000E6C  31FC 5555 1554          2500m     MOVE.W #$5555,$1554
00000E72  4E71                    2501m     NOP
00000E74  31FC 2020 2AAA          2502m     MOVE.W #$2020,$2AAA
00000E7A                          2503m     ENDM
00000E7A                          2504               
00000E7A  45FA 02D3               2505      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000E7E                          2506m     PRINT_STR A2,D2
00000E7E                          2507m LOOP_181
00000E7E  0C12 0000               2508m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E82  6700 0016               2509m     BEQ EXIT_181
00000E86                          2510mm     PRINT_CHAR (A2)+,D2
00000E86                          2511mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E86                 TRUE     2512mm     IFEQ DEBUG
00000E86  1439 00C00003           2513mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E8C  0802 0002               2514mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E90  67F4                    2515mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000E92  13DA 00C00007           2516mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E98                          2517mm     ENDC
00000E98                          2518mm 
00000E98                 FALSE    2519mm     IFNE DEBUG
00000E98                          2520mm     ENDC
00000E98                          2521mm 
00000E98                          2522mm     ENDM
00000E98  60E4                    2523m     BRA LOOP_181
00000E9A                          2524m EXIT_181
00000E9A                          2525m     ENDM
00000E9A                          2526  
00000E9A                          2527m     PRINT_CHAR '#',D3
00000E9A                          2528m WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E9A                 TRUE     2529m     IFEQ DEBUG
00000E9A  1639 00C00003           2530m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EA0  0803 0002               2531m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EA4  67F4                    2532m         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000EA6  13F8 0023 00C00007      2533m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000EAE                          2534m     ENDC
00000EAE                          2535m 
00000EAE                 FALSE    2536m     IFNE DEBUG
00000EAE                          2537m     ENDC
00000EAE                          2538m 
00000EAE                          2539m     ENDM
00000EAE                          2540m     PRINT_REG D0,D3,D4,D5,A2
00000EAE  45FA 02B9               2541m     LEA OX(PC),A2
00000EB2                          2542mm     PRINT_STR A2,D3
00000EB2                          2543mm LOOP_185
00000EB2  0C12 0000               2544mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EB6  6700 0016               2545mm     BEQ EXIT_185
00000EBA                          2546mmm     PRINT_CHAR (A2)+,D3
00000EBA                          2547mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EBA                 TRUE     2548mmm     IFEQ DEBUG
00000EBA  1639 00C00003           2549mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EC0  0803 0002               2550mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EC4  67F4                    2551mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00000EC6  13DA 00C00007           2552mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ECC                          2553mmm     ENDC
00000ECC                          2554mmm 
00000ECC                 FALSE    2555mmm     IFNE DEBUG
00000ECC                          2556mmm     ENDC
00000ECC                          2557mmm 
00000ECC                          2558mmm     ENDM
00000ECC  60E4                    2559mm     BRA LOOP_185
00000ECE                          2560mm EXIT_185
00000ECE                          2561mm     ENDM
00000ECE  7A07                    2562m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000ED0                          2563m LOOP_184
00000ED0                          2564mm     BIN2HEX D0,D4,A2
00000ED0  45FA 0256               2565mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000ED4  E998                    2566mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000ED6  1800                    2567mm     MOVE.B D0,D4
00000ED8  0284 0000000F           2568mm     ANDI.L #$F,D4
00000EDE  1832 4000               2569mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EE2                          2570mm     ENDM
00000EE2                          2571mm     PRINT_CHAR D4,D3
00000EE2                          2572mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE2                 TRUE     2573mm     IFEQ DEBUG
00000EE2  1639 00C00003           2574mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EE8  0803 0002               2575mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EEC  67F4                    2576mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000EEE  13C4 00C00007           2577mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EF4                          2578mm     ENDC
00000EF4                          2579mm 
00000EF4                 FALSE    2580mm     IFNE DEBUG
00000EF4                          2581mm     ENDC
00000EF4                          2582mm 
00000EF4                          2583mm     ENDM
00000EF4  57CD FFDA               2584m     DBEQ D5,LOOP_184
00000EF8                          2585m     ENDM
00000EF8                          2586  
00000EF8  45FA 0272               2587      LEA TO(PC),A2
00000EFC                          2588m     PRINT_STR A2,D3
00000EFC                          2589m LOOP_189
00000EFC  0C12 0000               2590m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F00  6700 0016               2591m     BEQ EXIT_189
00000F04                          2592mm     PRINT_CHAR (A2)+,D3
00000F04                          2593mm WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F04                 TRUE     2594mm     IFEQ DEBUG
00000F04  1639 00C00003           2595mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F0A  0803 0002               2596mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F0E  67F4                    2597mm         BEQ WAIT_FOR_READY_190                      ; NO SPACE, CHECK AGAIN
00000F10  13DA 00C00007           2598mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F16                          2599mm     ENDC
00000F16                          2600mm 
00000F16                 FALSE    2601mm     IFNE DEBUG
00000F16                          2602mm     ENDC
00000F16                          2603mm 
00000F16                          2604mm     ENDM
00000F16  60E4                    2605m     BRA LOOP_189
00000F18                          2606m EXIT_189
00000F18                          2607m     ENDM
00000F18                          2608  
00000F18  2408                    2609      MOVE.L A0,D2
00000F1A                          2610m     PRINT_REG D2,D3,D4,D5,A2
00000F1A  45FA 024D               2611m     LEA OX(PC),A2
00000F1E                          2612mm     PRINT_STR A2,D3
00000F1E                          2613mm LOOP_192
00000F1E  0C12 0000               2614mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F22  6700 0016               2615mm     BEQ EXIT_192
00000F26                          2616mmm     PRINT_CHAR (A2)+,D3
00000F26                          2617mmm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F26                 TRUE     2618mmm     IFEQ DEBUG
00000F26  1639 00C00003           2619mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2C  0803 0002               2620mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F30  67F4                    2621mmm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F32  13DA 00C00007           2622mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F38                          2623mmm     ENDC
00000F38                          2624mmm 
00000F38                 FALSE    2625mmm     IFNE DEBUG
00000F38                          2626mmm     ENDC
00000F38                          2627mmm 
00000F38                          2628mmm     ENDM
00000F38  60E4                    2629mm     BRA LOOP_192
00000F3A                          2630mm EXIT_192
00000F3A                          2631mm     ENDM
00000F3A  7A07                    2632m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F3C                          2633m LOOP_191
00000F3C                          2634mm     BIN2HEX D2,D4,A2
00000F3C  45FA 01EA               2635mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F40  E99A                    2636mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F42  1802                    2637mm     MOVE.B D2,D4
00000F44  0284 0000000F           2638mm     ANDI.L #$F,D4
00000F4A  1832 4000               2639mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F4E                          2640mm     ENDM
00000F4E                          2641mm     PRINT_CHAR D4,D3
00000F4E                          2642mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F4E                 TRUE     2643mm     IFEQ DEBUG
00000F4E  1639 00C00003           2644mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F54  0803 0002               2645mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F58  67F4                    2646mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F5A  13C4 00C00007           2647mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F60                          2648mm     ENDC
00000F60                          2649mm 
00000F60                 FALSE    2650mm     IFNE DEBUG
00000F60                          2651mm     ENDC
00000F60                          2652mm 
00000F60                          2653mm     ENDM
00000F60  57CD FFDA               2654m     DBEQ D5,LOOP_191
00000F64                          2655m     ENDM
00000F64                          2656  
00000F64                          2657m     PRINT_CRLF D3,A2
00000F64  45FA 01FD               2658m     LEA CRLF(PC),A2
00000F68                          2659mm     PRINT_STR A2,D3
00000F68                          2660mm LOOP_197
00000F68  0C12 0000               2661mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F6C  6700 0016               2662mm     BEQ EXIT_197
00000F70                          2663mmm     PRINT_CHAR (A2)+,D3
00000F70                          2664mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F70                 TRUE     2665mmm     IFEQ DEBUG
00000F70  1639 00C00003           2666mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F76  0803 0002               2667mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F7A  67F4                    2668mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000F7C  13DA 00C00007           2669mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F82                          2670mmm     ENDC
00000F82                          2671mmm 
00000F82                 FALSE    2672mmm     IFNE DEBUG
00000F82                          2673mmm     ENDC
00000F82                          2674mmm 
00000F82                          2675mmm     ENDM
00000F82  60E4                    2676mm     BRA LOOP_197
00000F84                          2677mm EXIT_197
00000F84                          2678mm     ENDM
00000F84                          2679m     ENDM
00000F84                          2680  
00000F84                          2681m     PROGRAM D0,(A0),D2
00000F84  3080                    2682m   MOVE.W D0,(A0)                                    ; WRITE THE DATA
00000F86                          2683m 
00000F86                          2684m WAIT_FOR_COMPLETE_199
00000F86  3410                    2685m         MOVE.W (A0),D2
00000F88                          2686m 
00000F88                          2687m         IF.W D2 <NE> D0 THEN
00000F88  B440                    2688ms     CMP.W   D0,D2
00000F8A  6700 0004               2689ms     BEQ _00000012
00000F8E  60F6                    2690m             BRA WAIT_FOR_COMPLETE_199
00000F90                          2691m         ENDI
00000F90                          2692ms _00000012
00000F90                          2693m         ENDM
00000F90                          2694  
00000F90                          2695m     PROTECT
00000F90  31FC AAAA 2AAA          2696m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F96  31FC 5555 1554          2697m     MOVE.W #$5555,$1554
00000F9C  31FC A0A0 2AAA          2698m     MOVE.W #$A0A0,$2AAA
00000FA2                          2699m     ENDM
00000FA2                          2700  
00000FA2  6000 F1D6               2701      BRA MAIN_LOOP
00000FA6                          2702  
00000FA6                          2703  HEX_DIGIT
00000FA6  E98F                    2704      LSL.L #4,D7                                     ; add the next digit in the next 4 bits
00000FA8                          2705m     HEX2BIN D2,D2,A0
00000FA8  41FA 018E               2706m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000FAC  0402 0030               2707m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FB0  C4BC 000000FF           2708m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000FB6  1430 2000               2709m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000FBA                          2710m     ENDM
00000FBA  8E02                    2711      OR.B D2,D7  
00000FBC  6000 F1DC               2712      BRA GET_INPUT
00000FC0                          2713  
00000FC0  FFFF FFFF               2714      SIMHALT                                         ; halt simulator
00000FC4                          2715  
00000FC4                          2716  ; strings
00000FC4= 4D 44 46 2D 6D 6F ...   2717  VERSION DC.B 'MDF-mon V1.68 (11/04/2021)',CR,LF,NULL
00000FE1= 50 72 65 73 73 20 ...   2718  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000FF4= 3F 09 09 09 68 65 ...   2719  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000FFE= 5B 76 5D 09 09 09 ...   2720          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
0000100D= 78 78 78 78 78 78 ...   2721          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001025= 78 78 78 78 78 78 ...   2722          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001045= 5B 73 5D 09 09 09 ...   2723          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
0000105F= 78 78 78 78 78 78 ...   2724          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001070= 5B 7A 5D 09 09 09 ...   2725          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001082= 78 78 78 78 78 78 ...   2726          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
000010A4= 78 78 78 78 78 78 ...   2727          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF,NULL
000010C4= 48 75 68 3F 0D 0A 00    2728  HUH  DC.B 'Huh?',CR,LF,NULL
000010CB= 20 53 20 72 65 63 ...   2729  READ    DC.B ' S records read, start address = ',NULL
000010ED= 57 3A 20 55 6E 6B ...   2730  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001104= 57 3A 20 43 53 20 ...   2731  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001116= 57 3A 20 52 41 4D ...   2732  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
00001128= 30 31 32 33 34 35 ...   2733  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001138= 00 01 02 03 04 05 ...   2734  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000114F= 4C 6F 61 64 69 6E ...   2735  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001163= 0D 0A 00                2736  CRLF    DC.B CR,LF,NULL
00001166= 3E 20 00                2737  PROMPT  DC.B '> ',NULL
00001169= 30 78 00                2738  ox      DC.B '0x',NULL
0000116C= 20 2D 3E 20 00          2739  to      DC.B ' -> ',NULL
00001171                          2740  
00001171                          2741      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1128
CONTINUE_100        8D6
CONTINUE_41         3B2
CONTINUE_44         402
CONTINUE_48         458
CONTINUE_56         50C
CONTINUE_61         57E
CONTINUE_66         5FA
CONTINUE_71         678
CONTINUE_76         700
CONTINUE_81         772
CONTINUE_86         7E4
CR                  D
CRLF                1163
CS_FAILURE          1104
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       9E0
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_105            93E
EXIT_107            966
EXIT_110            986
EXIT_115            9D0
EXIT_118            A00
EXIT_12             170
EXIT_122            A4A
EXIT_125            A6C
EXIT_130            AB6
EXIT_132            B26
EXIT_135            B4A
EXIT_14             19A
EXIT_140            B94
EXIT_147            C20
EXIT_150            C78
EXIT_153            C9A
EXIT_157            CE4
EXIT_160            D06
EXIT_165            D50
EXIT_178            E48
EXIT_181            E9A
EXIT_185            ECE
EXIT_189            F18
EXIT_192            F3A
EXIT_197            F84
EXIT_20             226
EXIT_22             276
EXIT_24             2A2
EXIT_27             2CC
EXIT_32             316
EXIT_39             38A
EXIT_5              110
EXIT_53             4C8
EXIT_7              130
EXIT_9              150
EXIT_91             856
EXIT_93             876
EXIT_97             8A8
G                   ABA
GET_INPUT           19A
H                   27A
HELP                FF4
HELPPROMPT          FE1
HEX2BIN             10B
HEX2BIN_LUT         1138
HEX_DIGIT           FA6
HUH                 10C4
L                   BA4
LF                  A
LOADING             114F
LOOP_105            922
LOOP_107            94A
LOOP_109            988
LOOP_110            96A
LOOP_115            9B4
LOOP_117            A02
LOOP_118            9E4
LOOP_12             154
LOOP_122            A2E
LOOP_124            A6E
LOOP_125            A50
LOOP_130            A9A
LOOP_132            B0A
LOOP_134            B4C
LOOP_135            B2E
LOOP_14             17E
LOOP_140            B78
LOOP_147            C04
LOOP_150            C5C
LOOP_152            C9C
LOOP_153            C7E
LOOP_157            CC8
LOOP_159            D08
LOOP_160            CEA
LOOP_165            D34
LOOP_178            E2C
LOOP_181            E7E
LOOP_184            ED0
LOOP_185            EB2
LOOP_189            EFC
LOOP_191            F3C
LOOP_192            F1E
LOOP_197            F68
LOOP_20             20A
LOOP_22             25A
LOOP_24             286
LOOP_26             2CE
LOOP_27             2B0
LOOP_32             2FA
LOOP_39             36E
LOOP_5              F4
LOOP_53             4AC
LOOP_7              114
LOOP_9              134
LOOP_91             83A
LOOP_93             85A
LOOP_97             88C
MAIN_LOOP           17A
NULL                0
OX                  1169
P                   DD4
PRINTSTR            286
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              1166
PROTECT             A40
R                   2A6
RAM                 200000
RAM_ERROR           1116
READ                10CB
READ_CHAR           62D
READ_DATA_TO_POKE   31E
RESET               4
ROM                 0
S                   38E
STACK               0
START               8
TAB                 9
TO                  116C
UNPROTECT           979
UNREC               10ED
V                   282
VERSION             FC4
W                   31A
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_167  D62
WAIT_FOR_COMPLETE_168  D78
WAIT_FOR_COMPLETE_169  D8C
WAIT_FOR_COMPLETE_170  D9E
WAIT_FOR_COMPLETE_171  DB2
WAIT_FOR_COMPLETE_199  F86
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8BA
WAIT_FOR_READY_102  8EE
WAIT_FOR_READY_106  92A
WAIT_FOR_READY_108  952
WAIT_FOR_READY_111  972
WAIT_FOR_READY_113  99A
WAIT_FOR_READY_116  9BC
WAIT_FOR_READY_119  9EC
WAIT_FOR_READY_121  A14
WAIT_FOR_READY_123  A36
WAIT_FOR_READY_126  A58
WAIT_FOR_READY_128  A80
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  AA2
WAIT_FOR_READY_133  B12
WAIT_FOR_READY_136  B36
WAIT_FOR_READY_138  B5E
WAIT_FOR_READY_141  B80
WAIT_FOR_READY_142  BB2
WAIT_FOR_READY_144  BCC
WAIT_FOR_READY_148  C0C
WAIT_FOR_READY_15   186
WAIT_FOR_READY_151  C64
WAIT_FOR_READY_154  C86
WAIT_FOR_READY_156  CAE
WAIT_FOR_READY_158  CD0
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  CF2
WAIT_FOR_READY_163  D1A
WAIT_FOR_READY_166  D3C
WAIT_FOR_READY_173  DE0
WAIT_FOR_READY_175  DFA
WAIT_FOR_READY_179  E34
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_182  E86
WAIT_FOR_READY_183  E9A
WAIT_FOR_READY_186  EBA
WAIT_FOR_READY_188  EE2
WAIT_FOR_READY_190  F04
WAIT_FOR_READY_193  F26
WAIT_FOR_READY_195  F4E
WAIT_FOR_READY_198  F70
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_21   212
WAIT_FOR_READY_23   262
WAIT_FOR_READY_25   28E
WAIT_FOR_READY_28   2B8
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2E0
WAIT_FOR_READY_33   302
WAIT_FOR_READY_34   320
WAIT_FOR_READY_36   33A
WAIT_FOR_READY_40   376
WAIT_FOR_READY_41   396
WAIT_FOR_READY_43   3D0
WAIT_FOR_READY_44   3E6
WAIT_FOR_READY_46   41A
WAIT_FOR_READY_48   43C
WAIT_FOR_READY_50   470
WAIT_FOR_READY_54   4B4
WAIT_FOR_READY_56   4F0
WAIT_FOR_READY_58   524
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   562
WAIT_FOR_READY_63   596
WAIT_FOR_READY_66   5DE
WAIT_FOR_READY_68   612
WAIT_FOR_READY_71   65C
WAIT_FOR_READY_73   690
WAIT_FOR_READY_76   6E4
WAIT_FOR_READY_78   718
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   756
WAIT_FOR_READY_83   78A
WAIT_FOR_READY_86   7C8
WAIT_FOR_READY_88   7FC
WAIT_FOR_READY_92   842
WAIT_FOR_READY_94   862
WAIT_FOR_READY_95   876
WAIT_FOR_READY_98   894
WAIT_FOR_SRECORD    396
Z                   AC2
_00000000           1DA
_00000001           1EE
_00000002           4D0
_00000003           8AC
_00000004           4DE
_00000005           6CC
_00000006           642
_00000007           8AC
_00000008           836
_00000009           8AC
_0000000A           9D4
_0000000B           9E0
_0000000C           B94
_0000000D           D6C
_0000000E           D86
_0000000F           D9A
_00000010           DAA
_00000011           DBE
_00000012           F90
_10000000           432
_10000001           49A
_10000002           4E6
_10000003           54E
_10000004           558
_10000005           5C0
_10000006           5D4
_10000007           63C
_10000008           646
_10000009           6C6
_1000000A           652
_1000000B           6BA
_1000000C           6DA
_1000000D           742
_1000000E           74C
_1000000F           7B4
_10000010           7BE
_10000011           826
_10000012           8B0
_10000013           918
_10000014           D50
_10000015           D72
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           ACE
_20000005           ADE
_20000006           AF2
_20000007           B96
_20000008           BB0
_20000009           BF4
_2000000A           DDE
_2000000B           E22
