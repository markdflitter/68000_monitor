00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 31/03/2021 10:32:05

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; WRITE doesn't seem to work for reals - it writes to the correct place, but the wrong data
00000000                             9  ; can do WWWWW in the input loop - it doesn't validate
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00E00000                 14  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 15  DISPLAY_            EQU $0
00000000  =00E00001                 16  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            17  
00000000  =00D30000                 18  DUART_BASE          EQU $D30000
00000000  =00000000                 19  DUART_MRA_          EQU $0
00000000  =00000001                 20  DUART_CSRA_         EQU $1
00000000  =00000001                 21  DUART_SRA_          EQU $1
00000000  =00000002                 22  DUART_CRA_          EQU $2
00000000  =00000003                 23  DUART_TXA_          EQU $3
00000000  =00000003                 24  DUART_RXA_          EQU $3
00000000  =00000004                 25  DUART_ACR_          EQU $4
00000000  =00000005                 26  DUART_IMR_          EQU $5
00000000  =00000008                 27  DUART_MRB_          EQU $8
00000000  =00000009                 28  DUART_CSRB_         EQU $9
00000000  =00000009                 29  DUART_SRB_          EQU $9
00000000  =0000000A                 30  DUART_CRB_          EQU $A
00000000  =0000000B                 31  DUART_TXB_          EQU $B
00000000  =0000000B                 32  DUART_RXB_          EQU $B
00000000  =0000000C                 33  DUART_IVR_          EQU $C
00000000  =0000000D                 34  DUART_OPCR_         EQU $D
00000000  =0000000E                 35  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 36  DUART_RESET_OPR_    EQU $F
00000000                            37  RRRR
00000000  =00D30001                 38  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 39  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 40  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 41  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 42  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 43  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            44  
00000000  =00D30011                 45  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 46  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 47  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 48  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 49  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 50  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            51  
00000000  =00D30009                 52  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 53  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 54  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 55  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 56  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 57  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            58  
00000000                            59  ; macros
00000000                            60  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            61  ; the input register is changed during the process
00000000                            62  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            63  BIN2HEX MACRO
00000000                            64    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            65    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            66    MOVE.B \1,\2
00000000                            67    ANDI.L #$F,\2
00000000                            68    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            69    ENDM
00000000                            70  
00000000                            71  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            72  ; the input register is changed during the process
00000000                            73  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            74  HEX2BIN MACRO
00000000                            75    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            76    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            77    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            78    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            79    ENDM
00000000                            80  
00000000                            81  ; send a single char to the serial port
00000000                            82  ; \1 = char to send, \2 = data register to use for status poll
00000000                            83  ; will stamp on D3 and D2 in debug mode
00000000                            84  PRINT_CHAR MACRO
00000000                            85  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            86      IFEQ DEBUG
00000000                            87        MOVE.B DUART_SRA,\2           ; read status register
00000000                            88        BTST #2,\2                    ; check for space to send
00000000                            89        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            90        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            91      ENDC
00000000                            92      
00000000                            93      IFNE DEBUG
00000000                            94        MOVE.B \1,D1
00000000                            95        MOVE.L #6,D0   
00000000                            96        TRAP #15                      ; write to terminal in simulator
00000000                            97      ENDC
00000000                            98  
00000000                            99      ENDM
00000000                           100  
00000000                           101  ; send CR,LF to the serial port
00000000                           102  ; \1 = data register to use for status poll
00000000                           103  PRINT_CRLF MACRO                  
00000000                           104      PRINT_CHAR #13,\1             ; CR
00000000                           105      PRINT_CHAR #10,\1             ; LF
00000000                           106      ENDM
00000000                           107  
00000000                           108  ; send C-style, zero terminated string to the serial port
00000000                           109  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           110  PRINT_STR MACRO
00000000                           111  LOOP\@
00000000                           112      CMP.B #0,(\1)                 ; 0 -> done
00000000                           113      BEQ EXIT\@
00000000                           114      PRINT_CHAR (\1)+,\2
00000000                           115      JMP LOOP\@
00000000                           116  EXIT\@
00000000                           117      ENDM
00000000                           118    
00000000                           119  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           120  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           121  PRINT_REG MACRO
00000000                           122      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           123  LOOP\@
00000000                           124      BIN2HEX \1,\3,\5
00000000                           125      PRINT_CHAR \3,\2
00000000                           126      DBEQ \4,LOOP\@
00000000                           127      ENDM
00000000                           128    
00000000                           129  ; read a char from the serial port
00000000                           130  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           131  ; will stamp on D3 and D2 in debug mode
00000000                           132  READ_CHAR MACRO
00000000                           133  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           134  
00000000                           135      IFEQ DEBUG
00000000                           136        MOVE.B DUART_SRA,\2         ; read status register
00000000                           137        BTST #0,\2                    ; check for character
00000000                           138        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           139      ENDC
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           143      ENDC
00000000                           144      IFNE DEBUG
00000000                           145        MOVE.L #5,D0    
00000000                           146        TRAP #15                    ; read from keyboard in simulator
00000000                           147        MOVE.L D1,\1
00000000                           148      ENDC
00000000                           149       
00000000                           150      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           151      BEQ RESTART
00000000                           152  
00000000                           153      IFEQ DEBUG
00000000                           154        PRINT_CHAR \1,\2            ; echo it back
00000000                           155      ENDC
00000000                           156      ENDM
00000000                           157  
00000000                           158  ; register catalogue
00000000                           159  ; D0 - used for simulator I/O
00000000                           160  ; D1 - used for simulator I/O
00000000                           161  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           162  ; D4 - read character
00000000                           163  ; D5 - data to write / data read
00000000                           164  ; D6 - working register used in R/W
00000000                           165  ; D7 - address accumulator
00000000                           166  ; A0 - address of string to print / address for R or W
00000000                           167  
00000000                           168  ; start vector
00000000                           169      ORG  $0
00000000= 00000000                 170      DC.L $00000000              ; PC
00000004= 00000000                 171      DC.L $00000000              ; SP
00000008                           172      
00000008                           173  ; start of program  
00000008                           174  START
00000008  13FC 0000 00E00001       175      MOVE.B #0,DISPLAY
00000010                           176     
00000010                           177  ;initialise UART
00000010  13FC 0000 00D30009       178      MOVE.B #$0,DUART_ACR            
00000018  13FC 0000 00D3000B       179      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000020  13FC 0000 00D3001B       180      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000028                           181  
00000028                           182  ; channel A
00000028  13FC 0003 00D30001       183      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000030  13FC 0007 00D30001       184      MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000038  13FC 00BB 00D30003       185      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
00000040  13FC 0005 00D30005       186      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000048                           187  
00000048                           188  ; channel B
00000048  13FC 0003 00D30011       189      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
00000050  13FC 0047 00D30011       190      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
00000058  13FC 00BB 00D30013       191      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
00000060  13FC 0005 00D30015       192      MOVE.B #$5,DUART_CRB            ; enable rx & tx
00000068                           193  
00000068                           194  WARM_START
00000068  13FC 0001 00E00001       195      MOVE.B #1,DISPLAY
00000070                           196         
00000070  41F9 00000730            197      LEA VERSION,A0
00000076                           198m     PRINT_STR A0,D3
00000094                           199m     PRINT_CRLF D3
000000BC                           200m     PRINT_CHAR #7,D3
000000D0                           201  
000000D0  7E00                     202      MOVE.L #0,D7                    ; address accumulator
000000D2                           203  
000000D2  13FC 0002 00E00001       204      MOVE.B #2,DISPLAY
000000DA                           205  MAIN_LOOP
000000DA                           206m     PRINT_CHAR #'>',D3               ; prompt
000000EE                           207m     PRINT_CHAR #32,D3                ; space
00000102                           208      
00000102                           209  GET_INPUT
00000102                           210m     READ_CHAR D4,D3                  ; fetch character from serial port -> D4
0000012E                           211      
0000012E  B83C 0030                212      CMP.B #'0',D4
00000132  6700 048C                213      BEQ HEX_DIGIT
00000136  B83C 0031                214      CMP.B #'1',D4
0000013A  6700 0484                215      BEQ HEX_DIGIT
0000013E  B83C 0032                216      CMP.B #'2',D4
00000142  6700 047C                217      BEQ HEX_DIGIT
00000146  B83C 0033                218      CMP.B #'3',D4
0000014A  6700 0474                219      BEQ HEX_DIGIT
0000014E  B83C 0034                220      CMP.B #'4',D4
00000152  6700 046C                221      BEQ HEX_DIGIT
00000156  B83C 0035                222      CMP.B #'5',D4
0000015A  6700 0464                223      BEQ HEX_DIGIT
0000015E  B83C 0036                224      CMP.B #'6',D4
00000162  6700 045C                225      BEQ HEX_DIGIT
00000166  B83C 0037                226      CMP.B #'7',D4
0000016A  6700 0454                227      BEQ HEX_DIGIT
0000016E  B83C 0038                228      CMP.B #'8',D4
00000172  6700 044C                229      BEQ HEX_DIGIT
00000176  B83C 0039                230      CMP.B #'9',D4
0000017A  6700 0444                231      BEQ HEX_DIGIT
0000017E  B83C 0041                232      CMP.B #'A',D4
00000182  6700 043C                233      BEQ HEX_DIGIT
00000186  B83C 0042                234      CMP.B #'B',D4
0000018A  6700 0434                235      BEQ HEX_DIGIT
0000018E  B83C 0043                236      CMP.B #'C',D4
00000192  6700 042C                237      BEQ HEX_DIGIT
00000196  B83C 0044                238      CMP.B #'D',D4
0000019A  6700 0424                239      BEQ HEX_DIGIT
0000019E  B83C 0045                240      CMP.B #'E',D4
000001A2  6700 041C                241      BEQ HEX_DIGIT
000001A6  B83C 0046                242      CMP.B #'F',D4
000001AA  6700 0414                243      BEQ HEX_DIGIT
000001AE                           244      
000001AE  B83C 0057                245      CMP.B #'W',D4
000001B2  6700 0262                246      BEQ W
000001B6                           247  
000001B6                           248m     PRINT_CRLF D3
000001DE                           249   
000001DE  B83C 003F                250      CMP.B #'?',D4
000001E2  6700 00D6                251      BEQ H
000001E6                           252  
000001E6  B83C 0056                253      CMP.B #'V',D4
000001EA  6700 00F6                254      BEQ V
000001EE                           255      
000001EE  B83C 0052                256      CMP.B #'R',D4
000001F2  6700 0116                257      BEQ R
000001F6                           258  
000001F6  B83C 0053                259      CMP.B #'S',D4
000001FA  6700 038C                260      BEQ S
000001FE                           261  
000001FE  B83C 0047                262      CMP.B #'G',D4
00000202  6700 03B4                263      BEQ G   
00000206                           264  
00000206  41F9 000007A7            265      LEA HUH,A0
0000020C                           266m     PRINT_STR A0,D3
0000022A                           267                         
0000022A  4EF8 00DA                268      JMP MAIN_LOOP
0000022E                           269  
0000022E                           270  RESTART
0000022E                           271m     PRINT_CRLF D3
00000256                           272     
00000256  13FC 000A 00D30005       273      MOVE.B #$A,DUART_CRA            ; disable rx & tx
0000025E  13FC 0010 00D30005       274      MOVE.B #$10,DUART_CRA           ; reset MRA pointer
00000266                           275  
00000266  13FC 0000 00D30009       276      MOVE.B #$0,DUART_ACR            
0000026E  13FC 0000 00D3000B       277      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000276  13FC 0000 00D3001B       278      MOVE.B #$0,DUART_OPCR           ; enable all outputs
0000027E                           279  
0000027E                           280  ; channel A
0000027E  13FC 0003 00D30001       281      MOVE.B #$03,DUART_MRA           ; no flow control, no parity, 8 data bits
00000286                           282      ;MOVE.B #$07,DUART_MRA           ; auto echo and 1 stop bit
00000286  13FC 00BB 00D30003       283      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
0000028E  13FC 0005 00D30005       284      MOVE.B #$5,DUART_CRA            ; enable rx & tx
00000296                           285  
00000296                           286  ; channel B
00000296  13FC 0003 00D30011       287      MOVE.B #$03,DUART_MRB           ; no flow control, no parity, 8 data bits
0000029E  13FC 0047 00D30011       288      MOVE.B #$47,DUART_MRB           ; auto echo and 1 stop bit
000002A6  13FC 00BB 00D30013       289      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000002AE  13FC 0005 00D30015       290      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000002B6                           291  
000002B6                           292  
000002B6                           293  
000002B6  4EF8 0068                294      JMP WARM_START
000002BA                           295  
000002BA                           296  ; commands
000002BA  41F9 0000074C            297  H   LEA HELP,A0
000002C0                           298m     PRINT_STR A0,D3
000002DE  4EF8 00DA                299      JMP MAIN_LOOP
000002E2                           300  
000002E2  41F9 00000730            301  V   LEA VERSION,A0
000002E8                           302m     PRINT_STR A0,D3       
00000306  4EF8 00DA                303      JMP MAIN_LOOP
0000030A                           304      
0000030A                           305  R   
0000030A                           306m     PRINT_REG D7,D3,D2,D6,A0
00000336                           307m     PRINT_CRLF D3
0000035E  2047                     308      MOVE.L D7,A0                    ; address accumulator -> address register
00000360  3A10                     309      MOVE.W (A0),D5                  ; read the memory and print it
00000362  CABC 0000FFFF            310      AND.L #$FFFF,D5
00000368                           311m     PRINT_REG D7,D3,D2,D6,A0
00000394                           312m     PRINT_CRLF D3
000003BC                           313m     PRINT_REG D5,D3,D7,D6,A0
000003E8                           314m     PRINT_CRLF D3
00000410  7E00                     315      MOVE.L #0,D7                    ; clear the now used address accumulator
00000412  4EF8 00DA                316      JMP MAIN_LOOP
00000416                           317  
00000416  7A00                     318  W   MOVE.L #0,D5                    ; D5 will be the value to write            
00000418                           319  
00000418                           320m     READ_CHAR D4,D3                 ; read most significant character -> D4
00000444                           321m     HEX2BIN D4,D4,A0                ; convert to binary -> D4
00000458  1A04                     322      MOVE.B D4,D5                    ; put at bottom of D5
0000045A                           323  
0000045A                           324      ;MOVE #6,D6                      ; 7 bytes left to read
0000045A                           325      
0000045A                           326  READ_DATA
0000045A                           327      ;LSL.L #4,D5                     ; make what we have so far more significant
0000045A                           328      ;READ_CHAR D4,D3                 ; next character -> D4
0000045A                           329      ;HEX2BIN D4,D4,A0                ; convert to binary -> D4
0000045A                           330      ;OR.B D4,D5
0000045A                           331      ;ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
0000045A                           332      ;DBEQ D6,READ_DATA
0000045A                           333      
0000045A                           334m     PRINT_CRLF D3
00000482                           335m     PRINT_REG D7,D3,D2,D6,A1
000004AE                           336m     PRINT_CRLF D3
000004D6                           337m     PRINT_REG D4,D3,D2,D6,A1
00000502                           338m     PRINT_CRLF D3
0000052A                           339m     PRINT_REG D5,D3,D2,D6,A1
00000556                           340  
00000556  2047                     341      MOVE.L D7,A0                    ; address accumulator -> address register
00000558  7E00                     342      MOVE.L #0,D7                    ; clear the now used address accumulator
0000055A                           343      
0000055A  2084                     344      MOVE.L D4,(A0)                  ; write the data
0000055C                           345  
0000055C                           346m     PRINT_CRLF D3
00000584  4EF8 00DA                347      JMP MAIN_LOOP
00000588                           348  
00000588                           349m S   READ_CHAR D4,D3                  ; fetch character from serial port -> D4
000005B4  4EF8 0588                350      JMP S
000005B8                           351  
000005B8  2047                     352  G   MOVE.L D7,A0                    ; address accumulator -> address register
000005BA  3E3C 0000                353      MOVE #0,D7                      ; clear the now used address accumulator
000005BE  4ED0                     354      JMP (A0)                        ; jump to it!
000005C0                           355          
000005C0                           356  HEX_DIGIT
000005C0  E98F                     357      LSL.L #4,D7                    ; add the next digit in the next 4 bits
000005C2                           358m     PRINT_CRLF D3
000005EA                           359m     PRINT_REG D7,D3,D2,D6,A1
00000616                           360     
00000616                           361m     PRINT_CRLF D3
0000063E                           362m     PRINT_REG D4,D3,D2,D6,A1
0000066A                           363  
0000066A                           364m     HEX2BIN D4,D4,A0
0000067E                           365  
0000067E                           366m     PRINT_CRLF D3
000006A6                           367m     PRINT_REG D4,D3,D2,D6,A1
000006D2                           368  
000006D2  8E04                     369      OR.B D4,D7
000006D4                           370      
000006D4                           371m     PRINT_CRLF D3
000006FC                           372m     PRINT_REG D7,D3,D2,D6,A1
00000728                           373    
00000728  4EF8 0102                374      JMP GET_INPUT
0000072C                           375  
0000072C  FFFF FFFF                376      SIMHALT                         ; halt simulator
00000730                           377  
00000730                           378  ; strings
00000730= 4D 44 46 2D 6D 6F ...    379  VERSION DC.B 'MDF-mon V1.5 (31/03/2021)',13,10,0
0000074C= 3F 20 48 65 6C 70 ...    380  HELP    DC.B '? Help',13,10,'V Version',13,10,'nnnnnnnnR Read',13,10,'nnnnnnnnWnn Write',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
000007A7= 48 75 68 3F 0D 0A 00     381  HUH     DC.B 'Huh?',13,10,0
000007AE= 55 6E 69 6D 70 6C ...    382  UNIMP   DC.B 'Unimplemented',13,10,0
000007BE= 30 31 32 33 34 35 ...    383  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000007CE= 00 01 02 03 04 05 ...    384  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000007E5                           385      
000007E5                           386      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         7BE
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_1              94
EXIT_14             22A
EXIT_19             2DE
EXIT_21             306
G                   5B8
GET_INPUT           102
H                   2BA
HELP                74C
HEX2BIN             12B
HEX2BIN_LUT         7CE
HEX_DIGIT           5C0
HUH                 7A7
LOOP_1              76
LOOP_14             20C
LOOP_19             2C0
LOOP_21             2E8
LOOP_23             30C
LOOP_29             36A
LOOP_35             3BE
LOOP_47             484
LOOP_53             4D8
LOOP_59             52C
LOOP_70             5EC
LOOP_76             640
LOOP_83             6A8
LOOP_89             6FE
MAIN_LOOP           DA
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   30A
READ_CHAR           5D1
READ_DATA           45A
RESTART             22E
RRRR                0
S                   588
START               8
UNIMP               7AE
V                   2E2
VERSION             730
W                   416
WAIT_FOR_READY_10   11C
WAIT_FOR_READY_12   1B6
WAIT_FOR_READY_13   1CA
WAIT_FOR_READY_15   214
WAIT_FOR_READY_17   22E
WAIT_FOR_READY_18   242
WAIT_FOR_READY_2    7E
WAIT_FOR_READY_20   2C8
WAIT_FOR_READY_22   2F0
WAIT_FOR_READY_25   320
WAIT_FOR_READY_27   336
WAIT_FOR_READY_28   34A
WAIT_FOR_READY_31   37E
WAIT_FOR_READY_33   394
WAIT_FOR_READY_34   3A8
WAIT_FOR_READY_37   3D2
WAIT_FOR_READY_39   3E8
WAIT_FOR_READY_4    94
WAIT_FOR_READY_40   3FC
WAIT_FOR_READY_41   418
WAIT_FOR_READY_42   432
WAIT_FOR_READY_45   45A
WAIT_FOR_READY_46   46E
WAIT_FOR_READY_49   498
WAIT_FOR_READY_5    A8
WAIT_FOR_READY_51   4AE
WAIT_FOR_READY_52   4C2
WAIT_FOR_READY_55   4EC
WAIT_FOR_READY_57   502
WAIT_FOR_READY_58   516
WAIT_FOR_READY_6    BC
WAIT_FOR_READY_61   540
WAIT_FOR_READY_63   55C
WAIT_FOR_READY_64   570
WAIT_FOR_READY_65   588
WAIT_FOR_READY_66   5A2
WAIT_FOR_READY_68   5C2
WAIT_FOR_READY_69   5D6
WAIT_FOR_READY_7    DA
WAIT_FOR_READY_72   600
WAIT_FOR_READY_74   616
WAIT_FOR_READY_75   62A
WAIT_FOR_READY_78   654
WAIT_FOR_READY_8    EE
WAIT_FOR_READY_81   67E
WAIT_FOR_READY_82   692
WAIT_FOR_READY_85   6BC
WAIT_FOR_READY_87   6D4
WAIT_FOR_READY_88   6E8
WAIT_FOR_READY_9    102
WAIT_FOR_READY_91   712
WARM_START          68
