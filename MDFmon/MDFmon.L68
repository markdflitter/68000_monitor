00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/04/2021 12:57:54

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000                             9  ; other ideas
00000000                            10  ;------------
00000000                            11  ; use DBLoop?
00000000                            12  ; keep track of highest address hit during srec download
00000000                            13  ; implement backspace
00000000                            14  ; fix being able to enter random chars when W'ing
00000000                            15  ; ram check at startup?  Not sure if this is a good idea!
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  
00000000                            18      ORG  $0
00000000                            19  
00000000  =00000000                 20  DEBUG               EQU 0
00000000                            21  
00000000                            22  ; constants
00000000  =00000000                 23  NULL                EQU 0
00000000  =00000009                 24  TAB                 EQU 9
00000000  =0000000D                 25  CR                  EQU 13
00000000  =0000000A                 26  LF                  EQU 10
00000000                            27  
00000000  =00000000                 28  ROM                 EQU $0
00000000  =00200000                 29  RAM                 EQU $200000
00000000                            30  
00000000  =00C00000                 31  DUART_BASE          EQU $C00000
00000000  =00000000                 32  DUART_MRA_          EQU $0
00000000  =00000001                 33  DUART_CSRA_         EQU $1
00000000  =00000001                 34  DUART_SRA_          EQU $1
00000000  =00000002                 35  DUART_CRA_          EQU $2
00000000  =00000003                 36  DUART_TXA_          EQU $3
00000000  =00000003                 37  DUART_RXA_          EQU $3
00000000  =00000004                 38  DUART_ACR_          EQU $4
00000000  =00000005                 39  DUART_IMR_          EQU $5
00000000  =00000008                 40  DUART_MRB_          EQU $8
00000000  =00000009                 41  DUART_CSRB_         EQU $9
00000000  =00000009                 42  DUART_SRB_          EQU $9
00000000  =0000000A                 43  DUART_CRB_          EQU $A
00000000  =0000000B                 44  DUART_TXB_          EQU $B
00000000  =0000000B                 45  DUART_RXB_          EQU $B
00000000  =0000000C                 46  DUART_IVR_          EQU $C
00000000  =0000000D                 47  DUART_OPCR_         EQU $D
00000000  =0000000E                 48  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 49  DUART_RESET_OPR_    EQU $F
00000000                            50  
00000000  =00C00001                 51  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 52  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 53  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 54  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 55  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 56  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            57  
00000000  =00C00011                 58  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 59  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 60  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 61  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 62  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 63  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            64  
00000000  =00C00009                 65  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 66  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 67  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 68  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 69  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 70  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            71  
00000000  =00E00000                 72  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 73  DISPLAY_            EQU $0
00000000  =00E00001                 74  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            75  
00000000                            76  ; macros
00000000                            77  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            78  ; the input register is changed during the process
00000000                            79  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            80  BIN2HEX MACRO
00000000                            81      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            82      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            83      MOVE.B \1,\2
00000000                            84      ANDI.L #$F,\2
00000000                            85      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            86      ENDM
00000000                            87  
00000000                            88  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            89  ; the input register is changed during the process
00000000                            90  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            91  HEX2BIN MACRO
00000000                            92      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            93      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            94      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            95      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            96      ENDM
00000000                            97  
00000000                            98  ; send a single char to the serial port
00000000                            99  ; \1 = char to send, \2 = data register to use for status poll
00000000                           100  ; will stamp on D0 and D1 in debug mode
00000000                           101  PRINT_CHAR MACRO
00000000                           102  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           103      IFEQ DEBUG
00000000                           104          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           105          BTST #2,\2                                  ; check for space to send
00000000                           106          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           107          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           108      ENDC
00000000                           109  
00000000                           110      IFNE DEBUG
00000000                           111          MOVE.B \1,D1
00000000                           112          MOVE.L #6,D0   
00000000                           113          TRAP #15                                    ; write to terminal in simulator
00000000                           114      ENDC
00000000                           115  
00000000                           116      ENDM
00000000                           117  
00000000                           118  ; send CR,LF to the serial port
00000000                           119  ; \1 = data register to use for status poll, /2 = working address register
00000000                           120  PRINT_CRLF MACRO
00000000                           121      LEA CRLF(PC),\2
00000000                           122      PRINT_STR \2,\1
00000000                           123      ENDM
00000000                           124  
00000000                           125  ; send C-style, zero terminated string to the serial port
00000000                           126  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           127  PRINT_STR MACRO
00000000                           128  LOOP\@
00000000                           129      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           130      BEQ EXIT\@
00000000                           131      PRINT_CHAR (\1)+,\2
00000000                           132      BRA LOOP\@
00000000                           133  EXIT\@
00000000                           134      ENDM
00000000                           135    
00000000                           136  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           137  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           138  PRINT_REG MACRO
00000000                           139      LEA ox(PC),\5
00000000                           140      PRINT_STR \5,\2
00000000                           141      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           142  LOOP\@
00000000                           143      BIN2HEX \1,\3,\5
00000000                           144      PRINT_CHAR \3,\2
00000000                           145      DBEQ \4,LOOP\@
00000000                           146      ENDM
00000000                           147  
00000000                           148  ; wait for a char from the serial port
00000000                           149  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           150  ; will stamp on D0 and D1 in debug mode
00000000                           151  WAIT_CHAR MACRO
00000000                           152  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           153      IFEQ DEBUG
00000000                           154          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           155          BTST #0,\2                                  ; check for character
00000000                           156          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           157      ENDC
00000000                           158  
00000000                           159      READ_CHAR \1
00000000                           160  
00000000                           161      IFEQ DEBUG
00000000                           162          PRINT_CHAR \1,\2                            ; echo it back
00000000                           163      ENDC
00000000                           164      ENDM
00000000                           165  
00000000                           166  ; read a char from the serial port - assumes that there is one!
00000000                           167  ; \ 1= data register for read char
00000000                           168  ; will stamp on D0 and D1 in debug mode
00000000                           169  READ_CHAR MACRO
00000000                           170      IFEQ DEBUG
00000000                           171          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           172      ENDC
00000000                           173      IFNE DEBUG
00000000                           174          MOVE.L #5,D0    
00000000                           175          TRAP #15                                    ; read from keyboard in simulator
00000000                           176          MOVE.L D1,\1
00000000                           177      ENDC
00000000                           178  
00000000                           179      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           180      BEQ START
00000000                           181      ENDM
00000000                           182  
00000000                           183  
00000000                           184  ; read data from the download serial port
00000000                           185  ; \ 1= data register for read char
00000000                           186  DOWNLOAD MACRO
00000000                           187  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           188  
00000000                           189      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           190      BTST #0,\1                                      ; check for character
00000000                           191      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           192  
00000000                           193      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           194  CONTINUE\@
00000000                           195      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           196      BTST #0,\1                                      ; check for character
00000000                           197      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           198      
00000000                           199      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           200      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           201  
00000000                           202      ENDM
00000000                           203  
00000000                           204  ; unprotect the EEPROM
00000000                           205  UNPROTECT MACRO
00000000                           206      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           207      NOP
00000000                           208      MOVE.W #$5555,$1554
00000000                           209      NOP
00000000                           210      MOVE.W #$8080,$2AAA
00000000                           211      NOP
00000000                           212      MOVE.W #$AAAA,$2AAA
00000000                           213      NOP
00000000                           214      MOVE.W #$5555,$1554
00000000                           215      NOP
00000000                           216      MOVE.W #$2020,$2AAA
00000000                           217      ENDM
00000000                           218      
00000000                           219  ; protect the EEPROM
00000000                           220  PROTECT MACRO
00000000                           221      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           222      MOVE.W #$5555,$1554
00000000                           223      MOVE.W #$A0A0,$2AAA
00000000                           224      ENDM
00000000                           225  
00000000                           226  
00000000                           227  ; read two hex digits from the download serial port and convert to a byte
00000000                           228  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           229  DOWNLOAD_BYTE MACRO
00000000                           230      MOVE.B #2,\4
00000000                           231      WHILE.B \4 <GT> 0 DO
00000000                           232          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           233          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           234          PRINT_CHAR \2,\3
00000000                           235          HEX2BIN \2,\2,\6
00000000                           236          OR.B \2,\1
00000000                           237          SUB.B #1,\4
00000000                           238      ENDW
00000000                           239  
00000000                           240      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           241      MOVE.B \1,\2
00000000                           242      ADD.L \1,\5
00000000                           243  
00000000                           244      ENDM
00000000                           245  
00000000                           246  ; write word to EEPROM
00000000                           247  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           248  PROGRAM MACRO
00000000                           249    MOVE.W \1,\2                                      ; write the data
00000000                           250  
00000000                           251  WAIT_FOR_COMPLETE\@
00000000                           252          MOVE.W \2,\3
00000000                           253  
00000000                           254          IF.W \3 <NE> \1 THEN
00000000                           255              BRA WAIT_FOR_COMPLETE\@
00000000                           256          ENDI
00000000                           257          ENDM
00000000                           258          
00000000                           259  ; register catalogue
00000000                           260  ; D0 - used for simulator I/O
00000000                           261  ; D1 - used for simulator I/O
00000000                           262  ; D2 - read character
00000000                           263  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           264  ; D6 - working register used in R/W
00000000                           265  ; D7 - address accumulator, reset by download
00000000                           266  ; A0 - address of string to print 
00000000                           267  
00000000                           268  ; start vector
00000000= 00000000                 269  STACK   DC.L $00000000                              ; STACK
00000004= 00000008                 270  RESET   DC.L START                                  ; RESET
00000008                           271  
00000008                           272  ; start of program  
00000008                           273  START
00000008  13FC 0000 00E00001       274      MOVE.B #0,DISPLAY
00000010                           275  
00000010                           276  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       277      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       278      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           279      
00000020                           280      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                281s     MOVE.W  #$50,D1
00000024  6000 000E                282s     BRA _20000001
00000028                           283s _20000000
00000028  13C1 00C00005            284          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     285          NOP
00000030                           286      ENDF
00000030  0441 0010                287s     SUB.W   #$10,D1
00000034                           288s _20000001
00000034  B27C 0010                289s     CMP.W   #$10,D1
00000038  6CEE                     290s     BGE _20000000
0000003A                           291  
0000003A                           292      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                293s     MOVE.W  #$50,D1
0000003E  6000 000E                294s     BRA _20000003
00000042                           295s _20000002
00000042  13C1 00C00015            296          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     297          NOP
0000004A                           298      ENDF
0000004A  0441 0010                299s     SUB.W   #$10,D1
0000004E                           300s _20000003
0000004E  B27C 0010                301s     CMP.W   #$10,D1
00000052  6CEE                     302s     BGE _20000002
00000054                           303      
00000054                           304  ;initialise UART
00000054  13FC 0000 00C00009       305      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       306      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       307      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           308  
0000006C                           309  ; channel A
0000006C  13FC 0013 00C00001       310      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       311      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       312      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       313      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           314  
0000008C                           315  ; channel B
0000008C  13FC 0013 00C00011       316      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       317      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       318      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       319      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           320  
000000AC                           321m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           322m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      323m     IFEQ DEBUG
000000AC  1239 00C00003            324m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                325m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     326m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       327m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           328m     ENDC
000000C0                           329m 
000000C0                 FALSE     330m     IFNE DEBUG
000000C0                           331m     ENDC
000000C0                           332m 
000000C0                           333m     ENDM
000000C0                           334m     PRINT_CHAR #0,D1
000000C0                           335m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      336m     IFEQ DEBUG
000000C0  1239 00C00003            337m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                338m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     339m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       340m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           341m     ENDC
000000D4                           342m 
000000D4                 FALSE     343m     IFNE DEBUG
000000D4                           344m     ENDC
000000D4                           345m 
000000D4                           346m     ENDM
000000D4                           347m     PRINT_CHAR #0,D1
000000D4                           348m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      349m     IFEQ DEBUG
000000D4  1239 00C00003            350m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                351m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     352m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       353m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           354m     ENDC
000000E8                           355m 
000000E8                 FALSE     356m     IFNE DEBUG
000000E8                           357m     ENDC
000000E8                           358m 
000000E8                           359m     ENDM
000000E8                           360  
000000E8  13FC 0001 00E00001       361      MOVE.B #1,DISPLAY
000000F0                           362  
000000F0                           363m     PRINT_CRLF D1,A0
000000F0  41FA 1178                364m     LEA CRLF(PC),A0
000000F4                           365mm     PRINT_STR A0,D1
000000F4                           366mm LOOP_5
000000F4  0C10 0000                367mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                368mm     BEQ EXIT_5
000000FC                           369mmm     PRINT_CHAR (A0)+,D1
000000FC                           370mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      371mmm     IFEQ DEBUG
000000FC  1239 00C00003            372mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                373mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     374mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            375mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           376mmm     ENDC
0000010E                           377mmm 
0000010E                 FALSE     378mmm     IFNE DEBUG
0000010E                           379mmm     ENDC
0000010E                           380mmm 
0000010E                           381mmm     ENDM
0000010E  60E4                     382mm     BRA LOOP_5
00000110                           383mm EXIT_5
00000110                           384mm     ENDM
00000110                           385m     ENDM
00000110  41FA 1166                386      LEA VERSION(PC),A0
00000114                           387m     PRINT_STR A0,D3
00000114                           388m LOOP_7
00000114  0C10 0000                389m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                390m     BEQ EXIT_7
0000011C                           391mm     PRINT_CHAR (A0)+,D3
0000011C                           392mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      393mm     IFEQ DEBUG
0000011C  1639 00C00003            394mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                395mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     396mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            397mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           398mm     ENDC
0000012E                           399mm 
0000012E                 FALSE     400mm     IFNE DEBUG
0000012E                           401mm     ENDC
0000012E                           402mm 
0000012E                           403mm     ENDM
0000012E  60E4                     404m     BRA LOOP_7
00000130                           405m EXIT_7
00000130                           406m     ENDM
00000130                           407  
00000130  41FA 0F96                408      LEA HELPPROMPT(PC),A0
00000134                           409m     PRINT_STR A0,D3
00000134                           410m LOOP_9
00000134  0C10 0000                411m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                412m     BEQ EXIT_9
0000013C                           413mm     PRINT_CHAR (A0)+,D3
0000013C                           414mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      415mm     IFEQ DEBUG
0000013C  1639 00C00003            416mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                417mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     418mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            419mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           420mm     ENDC
0000014E                           421mm 
0000014E                 FALSE     422mm     IFNE DEBUG
0000014E                           423mm     ENDC
0000014E                           424mm 
0000014E                           425mm     ENDM
0000014E  60E4                     426m     BRA LOOP_9
00000150                           427m EXIT_9
00000150                           428m     ENDM
00000150                           429  
00000150                           430m     PRINT_CRLF D3,A0
00000150  41FA 1118                431m     LEA CRLF(PC),A0
00000154                           432mm     PRINT_STR A0,D3
00000154                           433mm LOOP_12
00000154  0C10 0000                434mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                435mm     BEQ EXIT_12
0000015C                           436mmm     PRINT_CHAR (A0)+,D3
0000015C                           437mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      438mmm     IFEQ DEBUG
0000015C  1639 00C00003            439mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                440mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     441mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            442mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           443mmm     ENDC
0000016E                           444mmm 
0000016E                 FALSE     445mmm     IFNE DEBUG
0000016E                           446mmm     ENDC
0000016E                           447mmm 
0000016E                           448mmm     ENDM
0000016E  60E4                     449mm     BRA LOOP_12
00000170                           450mm EXIT_12
00000170                           451mm     ENDM
00000170                           452m     ENDM
00000170                           453  
00000170  7E00                     454      MOVE.L #0,D7                                    ; address accumulator
00000172                           455  
00000172  13FC 0002 00E00001       456      MOVE.B #2,DISPLAY
0000017A                           457  MAIN_LOOP
0000017A  41FA 10F1                458      LEA PROMPT(PC),A0
0000017E                           459m     PRINT_STR A0,D3
0000017E                           460m LOOP_14
0000017E  0C10 0000                461m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                462m     BEQ EXIT_14
00000186                           463mm     PRINT_CHAR (A0)+,D3
00000186                           464mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      465mm     IFEQ DEBUG
00000186  1639 00C00003            466mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                467mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     468mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            469mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           470mm     ENDC
00000198                           471mm 
00000198                 FALSE     472mm     IFNE DEBUG
00000198                           473mm     ENDC
00000198                           474mm 
00000198                           475mm     ENDM
00000198  60E4                     476m     BRA LOOP_14
0000019A                           477m EXIT_14
0000019A                           478m     ENDM
0000019A                           479  
0000019A                           480  GET_INPUT
0000019A                           481m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           482m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      483m     IFEQ DEBUG
0000019A  1639 00C00003            484m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                485m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     486m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           487m     ENDC
000001A6                           488m 
000001A6                           489mm     READ_CHAR D2
000001A6                 TRUE      490mm     IFEQ DEBUG
000001A6  1439 00C00007            491mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           492mm     ENDC
000001AC                 FALSE     493mm     IFNE DEBUG
000001AC                           494mm     ENDC
000001AC                           495mm 
000001AC  B43C 001B                496mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                497mm     BEQ START
000001B4                           498mm     ENDM
000001B4                           499m 
000001B4                 TRUE      500m     IFEQ DEBUG
000001B4                           501mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           502mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      503mm     IFEQ DEBUG
000001B4  1639 00C00003            504mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                505mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     506mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            507mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           508mm     ENDC
000001C6                           509mm 
000001C6                 FALSE     510mm     IFNE DEBUG
000001C6                           511mm     ENDC
000001C6                           512mm 
000001C6                           513mm     ENDM
000001C6                           514m     ENDC
000001C6                           515m     ENDM
000001C6                           516  
000001C6                           517      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                518s     CMP.B   #'0',D2
000001CA  6D00 000E                519s     BLT _00000000
000001CE  B43C 0039                520s     CMP.B   #'9',D2
000001D2  6E00 0006                521s     BGT _00000000
000001D6  6000 0ED2                522          BRA HEX_DIGIT
000001DA                           523      ENDI
000001DA                           524s _00000000
000001DA                           525      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                526s     CMP.B   #'A',D2
000001DE  6D00 000E                527s     BLT _00000001
000001E2  B43C 0046                528s     CMP.B   #'F',D2
000001E6  6E00 0006                529s     BGT _00000001
000001EA  6000 0EBE                530          BRA HEX_DIGIT
000001EE                           531      ENDI
000001EE                           532s _00000001
000001EE                           533  
000001EE  B43C 0077                534      CMP.B #'w',D2
000001F2  6700 0192                535      BEQ W
000001F6                           536  
000001F6  B43C 006C                537      CMP.B #'l',D2
000001FA  6700 0A14                538      BEQ L 
000001FE                           539  
000001FE  B43C 0070                540      CMP.B #'p',D2
00000202  6700 0C3C                541      BEQ P
00000206                           542  
00000206  B43C 006D                543      CMP.B #'m',D2
0000020A  6700 0E06                544      BEQ M
0000020E                           545  
0000020E                           546m     PRINT_CRLF D3,A0
0000020E  41FA 105A                547m     LEA CRLF(PC),A0
00000212                           548mm     PRINT_STR A0,D3
00000212                           549mm LOOP_20
00000212  0C10 0000                550mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                551mm     BEQ EXIT_20
0000021A                           552mmm     PRINT_CHAR (A0)+,D3
0000021A                           553mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      554mmm     IFEQ DEBUG
0000021A  1639 00C00003            555mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                556mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     557mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            558mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           559mmm     ENDC
0000022C                           560mmm 
0000022C                 FALSE     561mmm     IFNE DEBUG
0000022C                           562mmm     ENDC
0000022C                           563mmm 
0000022C                           564mmm     ENDM
0000022C  60E4                     565mm     BRA LOOP_20
0000022E                           566mm EXIT_20
0000022E                           567mm     ENDM
0000022E                           568m     ENDM
0000022E                           569   
0000022E  B43C 003F                570      CMP.B #'?',D2
00000232  6700 004E                571      BEQ H
00000236                           572   
00000236  B43C 0076                573      CMP.B #'v',D2
0000023A  6700 004E                574      BEQ V
0000023E                           575      
0000023E  B43C 0072                576      CMP.B #'r',D2
00000242  6700 006A                577      BEQ R
00000246                           578  
00000246  B43C 0073                579      CMP.B #'s',D2
0000024A  6700 01AE                580      BEQ S
0000024E                           581  
0000024E  B43C 0067                582      CMP.B #'g',D2
00000252  6700 08D2                583      BEQ G   
00000256                           584  
00000256  B43C 007A                585      CMP.B #'z',D2
0000025A  6700 08D2                586      BEQ Z   
0000025E                           587  
0000025E  41FA 0F6B                588      LEA HUH(PC),A0
00000262                           589m     PRINT_STR A0,D3
00000262                           590m LOOP_22
00000262  0C10 0000                591m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000266  6700 0016                592m     BEQ EXIT_22
0000026A                           593mm     PRINT_CHAR (A0)+,D3
0000026A                           594mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      595mm     IFEQ DEBUG
0000026A  1639 00C00003            596mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000270  0803 0002                597mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000274  67F4                     598mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000276  13D8 00C00007            599mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000027C                           600mm     ENDC
0000027C                           601mm 
0000027C                 FALSE     602mm     IFNE DEBUG
0000027C                           603mm     ENDC
0000027C                           604mm 
0000027C                           605mm     ENDM
0000027C  60E4                     606m     BRA LOOP_22
0000027E                           607m EXIT_22
0000027E                           608m     ENDM
0000027E                           609  
0000027E  6000 FEFA                610      BRA MAIN_LOOP
00000282                           611  
00000282                           612  ; commands
00000282                           613  H
00000282  41FA 0E57                614      LEA HELP(PC),A0
00000286  6000 0006                615      BRA PRINTSTR
0000028A                           616  
0000028A                           617  V
0000028A  41FA 0FEC                618      LEA VERSION(PC),A0
0000028E                           619  PRINTSTR
0000028E                           620m     PRINT_STR A0,D3    
0000028E                           621m LOOP_24
0000028E  0C10 0000                622m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000292  6700 0016                623m     BEQ EXIT_24
00000296                           624mm     PRINT_CHAR (A0)+,D3
00000296                           625mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000296                 TRUE      626mm     IFEQ DEBUG
00000296  1639 00C00003            627mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000029C  0803 0002                628mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A0  67F4                     629mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002A2  13D8 00C00007            630mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A8                           631mm     ENDC
000002A8                           632mm 
000002A8                 FALSE     633mm     IFNE DEBUG
000002A8                           634mm     ENDC
000002A8                           635mm 
000002A8                           636mm     ENDM
000002A8  60E4                     637m     BRA LOOP_24
000002AA                           638m EXIT_24
000002AA                           639m     ENDM
000002AA  6000 FECE                640      BRA MAIN_LOOP
000002AE                           641  
000002AE                           642  R
000002AE  2047                     643      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B0  7E00                     644      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002B2  2410                     645      MOVE.L (A0),D2                                  ; read the memory and print it
000002B4                           646m     PRINT_REG D2,D3,D4,D5,A0
000002B4  41FA 0FBA                647m     LEA OX(PC),A0
000002B8                           648mm     PRINT_STR A0,D3
000002B8                           649mm LOOP_27
000002B8  0C10 0000                650mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BC  6700 0016                651mm     BEQ EXIT_27
000002C0                           652mmm     PRINT_CHAR (A0)+,D3
000002C0                           653mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      654mmm     IFEQ DEBUG
000002C0  1639 00C00003            655mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002C6  0803 0002                656mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002CA  67F4                     657mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002CC  13D8 00C00007            658mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D2                           659mmm     ENDC
000002D2                           660mmm 
000002D2                 FALSE     661mmm     IFNE DEBUG
000002D2                           662mmm     ENDC
000002D2                           663mmm 
000002D2                           664mmm     ENDM
000002D2  60E4                     665mm     BRA LOOP_27
000002D4                           666mm EXIT_27
000002D4                           667mm     ENDM
000002D4  7A07                     668m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002D6                           669m LOOP_26
000002D6                           670mm     BIN2HEX D2,D4,A0
000002D6  41FA 0F57                671mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002DA  E99A                     672mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002DC  1802                     673mm     MOVE.B D2,D4
000002DE  0284 0000000F            674mm     ANDI.L #$F,D4
000002E4  1830 4000                675mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002E8                           676mm     ENDM
000002E8                           677mm     PRINT_CHAR D4,D3
000002E8                           678mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      679mm     IFEQ DEBUG
000002E8  1639 00C00003            680mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EE  0803 0002                681mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002F2  67F4                     682mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002F4  13C4 00C00007            683mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002FA                           684mm     ENDC
000002FA                           685mm 
000002FA                 FALSE     686mm     IFNE DEBUG
000002FA                           687mm     ENDC
000002FA                           688mm 
000002FA                           689mm     ENDM
000002FA  57CD FFDA                690m     DBEQ D5,LOOP_26
000002FE                           691m     ENDM
000002FE                           692      
000002FE                           693m     PRINT_CHAR #32,D3
000002FE                           694m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      695m     IFEQ DEBUG
000002FE  1639 00C00003            696m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                697m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     698m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
0000030A  13FC 0020 00C00007       699m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000312                           700m     ENDC
00000312                           701m 
00000312                 FALSE     702m     IFNE DEBUG
00000312                           703m     ENDC
00000312                           704m 
00000312                           705m     ENDM
00000312                           706  
00000312  E19A                     707      ROL.L #8,D2
00000314                           708m     PRINT_CHAR D2,D3
00000314                           709m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000314                 TRUE      710m     IFEQ DEBUG
00000314  1639 00C00003            711m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000031A  0803 0002                712m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000031E  67F4                     713m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000320  13C2 00C00007            714m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000326                           715m     ENDC
00000326                           716m 
00000326                 FALSE     717m     IFNE DEBUG
00000326                           718m     ENDC
00000326                           719m 
00000326                           720m     ENDM
00000326  E19A                     721      ROL.L #8,D2
00000328                           722m     PRINT_CHAR D2,D3
00000328                           723m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      724m     IFEQ DEBUG
00000328  1639 00C00003            725m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                726m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     727m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000334  13C2 00C00007            728m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000033A                           729m     ENDC
0000033A                           730m 
0000033A                 FALSE     731m     IFNE DEBUG
0000033A                           732m     ENDC
0000033A                           733m 
0000033A                           734m     ENDM
0000033A  E19A                     735      ROL.L #8,D2
0000033C                           736m     PRINT_CHAR D2,D3
0000033C                           737m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      738m     IFEQ DEBUG
0000033C  1639 00C00003            739m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0002                740m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000346  67F4                     741m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000348  13C2 00C00007            742m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000034E                           743m     ENDC
0000034E                           744m 
0000034E                 FALSE     745m     IFNE DEBUG
0000034E                           746m     ENDC
0000034E                           747m 
0000034E                           748m     ENDM
0000034E  E19A                     749      ROL.L #8,D2
00000350                           750m     PRINT_CHAR D2,D3
00000350                           751m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      752m     IFEQ DEBUG
00000350  1639 00C00003            753m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                754m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     755m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
0000035C  13C2 00C00007            756m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000362                           757m     ENDC
00000362                           758m 
00000362                 FALSE     759m     IFNE DEBUG
00000362                           760m     ENDC
00000362                           761m 
00000362                           762m     ENDM
00000362                           763  
00000362                           764m     PRINT_CRLF D3,A0
00000362  41FA 0F06                765m     LEA CRLF(PC),A0
00000366                           766mm     PRINT_STR A0,D3
00000366                           767mm LOOP_37
00000366  0C10 0000                768mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000036A  6700 0016                769mm     BEQ EXIT_37
0000036E                           770mmm     PRINT_CHAR (A0)+,D3
0000036E                           771mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      772mmm     IFEQ DEBUG
0000036E  1639 00C00003            773mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000374  0803 0002                774mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000378  67F4                     775mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000037A  13D8 00C00007            776mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000380                           777mmm     ENDC
00000380                           778mmm 
00000380                 FALSE     779mmm     IFNE DEBUG
00000380                           780mmm     ENDC
00000380                           781mmm 
00000380                           782mmm     ENDM
00000380  60E4                     783mm     BRA LOOP_37
00000382                           784mm EXIT_37
00000382                           785mm     ENDM
00000382                           786m     ENDM
00000382                           787      
00000382  6000 FDF6                788      BRA MAIN_LOOP
00000386                           789  
00000386                           790  W
00000386  3C3C 0007                791      MOVE #7,D6                                      ; 7 bytes left to read
0000038A                           792      
0000038A                           793  READ_DATA_TO_POKE
0000038A  E98D                     794      LSL.L #4,D5                                     ; make what we have so far more significant
0000038C                           795m     WAIT_CHAR D2,D3                                 ; next character -> D2
0000038C                           796m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038C                 TRUE      797m     IFEQ DEBUG
0000038C  1639 00C00003            798m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000392  0803 0000                799m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000396  67F4                     800m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
00000398                           801m     ENDC
00000398                           802m 
00000398                           803mm     READ_CHAR D2
00000398                 TRUE      804mm     IFEQ DEBUG
00000398  1439 00C00007            805mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000039E                           806mm     ENDC
0000039E                 FALSE     807mm     IFNE DEBUG
0000039E                           808mm     ENDC
0000039E                           809mm 
0000039E  B43C 001B                810mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003A2  6700 FC64                811mm     BEQ START
000003A6                           812mm     ENDM
000003A6                           813m 
000003A6                 TRUE      814m     IFEQ DEBUG
000003A6                           815mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003A6                           816mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A6                 TRUE      817mm     IFEQ DEBUG
000003A6  1639 00C00003            818mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003AC  0803 0002                819mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B0  67F4                     820mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003B2  13C2 00C00007            821mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003B8                           822mm     ENDC
000003B8                           823mm 
000003B8                 FALSE     824mm     IFNE DEBUG
000003B8                           825mm     ENDC
000003B8                           826mm 
000003B8                           827mm     ENDM
000003B8                           828m     ENDC
000003B8                           829m     ENDM
000003B8                           830m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003B8  41FA 0E85                831m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003BC  0402 0030                832m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C4BC 000000FF            833m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003C6  1430 2000                834m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003CA                           835m     ENDM
000003CA  8A02                     836      OR.B D2,D5
000003CC  57CE FFBC                837      DBEQ D6,READ_DATA_TO_POKE
000003D0                           838      
000003D0  2047                     839      MOVE.L D7,A0                                    ; address accumulator -> address register
000003D2  7E00                     840      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003D4                           841      
000003D4  2085                     842      MOVE.L D5,(A0)                                  ; write the data
000003D6                           843  
000003D6                           844m     PRINT_CRLF D3,A0
000003D6  41FA 0E92                845m     LEA CRLF(PC),A0
000003DA                           846mm     PRINT_STR A0,D3
000003DA                           847mm LOOP_44
000003DA  0C10 0000                848mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003DE  6700 0016                849mm     BEQ EXIT_44
000003E2                           850mmm     PRINT_CHAR (A0)+,D3
000003E2                           851mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E2                 TRUE      852mmm     IFEQ DEBUG
000003E2  1639 00C00003            853mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E8  0803 0002                854mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003EC  67F4                     855mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003EE  13D8 00C00007            856mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003F4                           857mmm     ENDC
000003F4                           858mmm 
000003F4                 FALSE     859mmm     IFNE DEBUG
000003F4                           860mmm     ENDC
000003F4                           861mmm 
000003F4                           862mmm     ENDM
000003F4  60E4                     863mm     BRA LOOP_44
000003F6                           864mm EXIT_44
000003F6                           865mm     ENDM
000003F6                           866m     ENDM
000003F6  6000 FD82                867      BRA MAIN_LOOP
000003FA                           868  
000003FA                           869  ; register map for S
000003FA                           870  ; A0 - start address
000003FA                           871  ; A1 - offset
000003FA                           872  ; A2 - next address to write
000003FA                           873  ; A3 - next location (jmp)
000003FA                           874  ; A4 - Working Address Register
000003FA                           875  ; D0 - record count
000003FA                           876  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000003FA                           877  ; D2 - checksum
000003FA                           878  ; D3 - data byte count
000003FA                           879  ; D4 - read address, moved into A2
000003FA                           880  ; D5 - temp
000003FA                           881  ; D6 - temp
000003FA                           882  ; D7 - temp
000003FA                           883  S
000003FA  2078 0000                884      MOVE.L 0,A0                                     ; start address -> A0
000003FE  2247                     885      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000400                           886      
00000400  7000                     887      MOVE.L #0,D0                                    ; count of records read -> D0
00000402                           888          
00000402                           889  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000402                           890m     DOWNLOAD D1
00000402                           891m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           892m 
00000402  1239 00C00003            893m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000408  0801 0000                894m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000040C  6700 0010                895m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000410                           896m 
00000410                           897mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000410                 TRUE      898mm     IFEQ DEBUG
00000410  1239 00C00007            899mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000416                           900mm     ENDC
00000416                 FALSE     901mm     IFNE DEBUG
00000416                           902mm     ENDC
00000416                           903mm 
00000416  B23C 001B                904mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000041A  6700 FBEC                905mm     BEQ START
0000041E                           906mm     ENDM
0000041E                           907m CONTINUE_46
0000041E  1239 00C00013            908m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000424  0801 0000                909m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000428  67D8                     910m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
0000042A                           911m     
0000042A  1239 00C00017            912m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000430  13C1 00E00001            913m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000436                           914m 
00000436                           915m     ENDM
00000436  B23C 0053                916      CMP.B #'S',D1                                   ; found S?
0000043A  66C6                     917      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000043C                           918      
0000043C                           919m     PRINT_CHAR #'S',D5                              ; print the S
0000043C                           920m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043C                 TRUE      921m     IFEQ DEBUG
0000043C  1A39 00C00003            922m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000442  0805 0002                923m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000446  67F4                     924m         BEQ WAIT_FOR_READY_48                       ; NO SPACE, CHECK AGAIN
00000448  13FC 0053 00C00007       925m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000450                           926m     ENDC
00000450                           927m 
00000450                 FALSE     928m     IFNE DEBUG
00000450                           929m     ENDC
00000450                           930m 
00000450                           931m     ENDM
00000450  5280                     932      ADD.L #1,D0                                     ; read another S record, increment count
00000452                           933      
00000452                           934m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000452                           935m WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000452                           936m 
00000452  1239 00C00003            937m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000458  0801 0000                938m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000045C  6700 0010                939m     BEQ CONTINUE_49                                 ; NOTHING, CONTINUE
00000460                           940m 
00000460                           941mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000460                 TRUE      942mm     IFEQ DEBUG
00000460  1239 00C00007            943mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000466                           944mm     ENDC
00000466                 FALSE     945mm     IFNE DEBUG
00000466                           946mm     ENDC
00000466                           947mm 
00000466  B23C 001B                948mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000046A  6700 FB9C                949mm     BEQ START
0000046E                           950mm     ENDM
0000046E                           951m CONTINUE_49
0000046E  1239 00C00013            952m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000474  0801 0000                953m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000478  67D8                     954m     BEQ WAIT_FOR_READY_49                           ; NOTHING, CHECK AGAIN
0000047A                           955m     
0000047A  1239 00C00017            956m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000480  13C1 00E00001            957m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000486                           958m 
00000486                           959m     ENDM
00000486                           960m     PRINT_CHAR D1,D5
00000486                           961m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000486                 TRUE      962m     IFEQ DEBUG
00000486  1A39 00C00003            963m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000048C  0805 0002                964m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000490  67F4                     965m         BEQ WAIT_FOR_READY_51                       ; NO SPACE, CHECK AGAIN
00000492  13C1 00C00007            966m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000498                           967m     ENDC
00000498                           968m 
00000498                 FALSE     969m     IFNE DEBUG
00000498                           970m     ENDC
00000498                           971m 
00000498                           972m     ENDM
00000498                           973  
00000498  7400                     974      MOVE.L #0,D2                                    ; clear the checksum
0000049A                           975  
0000049A                           976m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000049A  1E3C 0002                977m     MOVE.B #2,D7
0000049E                           978m     WHILE.B D7 <GT> 0 DO
0000049E                           979ms _10000000
0000049E  BE38 0000                980ms     CMP.B   0,D7
000004A2  6F00 0062                981ms     BLE _10000001
000004A6  E98B                     982m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000004A8                           983mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004A8                           984mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A8                           985mm 
000004A8  1A39 00C00003            986mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004AE  0805 0000                987mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004B2  6700 0010                988mm     BEQ CONTINUE_53                                 ; NOTHING, CONTINUE
000004B6                           989mm 
000004B6                           990mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000004B6                 TRUE      991mmm     IFEQ DEBUG
000004B6  1A39 00C00007            992mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004BC                           993mmm     ENDC
000004BC                 FALSE     994mmm     IFNE DEBUG
000004BC                           995mmm     ENDC
000004BC                           996mmm 
000004BC  BA3C 001B                997mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000004C0  6700 FB46                998mmm     BEQ START
000004C4                           999mmm     ENDM
000004C4                          1000mm CONTINUE_53
000004C4  1A39 00C00013           1001mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004CA  0805 0000               1002mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004CE  67D8                    1003mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D0                          1004mm     
000004D0  1A39 00C00017           1005mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004D6  13C5 00E00001           1006mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004DC                          1007mm 
000004DC                          1008mm     ENDM
000004DC                          1009mm         PRINT_CHAR D5,D6
000004DC                          1010mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DC                 TRUE     1011mm     IFEQ DEBUG
000004DC  1C39 00C00003           1012mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000004E2  0806 0002               1013mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000004E6  67F4                    1014mm         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
000004E8  13C5 00C00007           1015mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004EE                          1016mm     ENDC
000004EE                          1017mm 
000004EE                 FALSE    1018mm     IFNE DEBUG
000004EE                          1019mm     ENDC
000004EE                          1020mm 
000004EE                          1021mm     ENDM
000004EE                          1022mm         HEX2BIN D5,D5,A4
000004EE  49FA 0D4F               1023mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004F2  0405 0030               1024mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004F6  CABC 000000FF           1025mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000004FC  1A34 5000               1026mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000500                          1027mm     ENDM
00000500  8605                    1028m         OR.B D5,D3
00000502  5307                    1029m         SUB.B #1,D7
00000504                          1030m     ENDW
00000504  6098                    1031ms     BRA _10000000
00000506                          1032ms _10000001
00000506                          1033m 
00000506  7A00                    1034m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000508  1A03                    1035m     MOVE.B D3,D5
0000050A  D483                    1036m     ADD.L D3,D2
0000050C                          1037m 
0000050C                          1038m     ENDM
0000050C                          1039  
0000050C                          1040      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000050C  B23C 0030               1041s     CMP.B   #'0',D1
00000510  6600 002A               1042s     BNE.L   _00000002
00000514                          1043m         PRINT_CRLF D5,A4
00000514  49FA 0D54               1044m     LEA CRLF(PC),A4
00000518                          1045mm     PRINT_STR A4,D5
00000518                          1046mm LOOP_58
00000518  0C14 0000               1047mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000051C  6700 0016               1048mm     BEQ EXIT_58
00000520                          1049mmm     PRINT_CHAR (A4)+,D5
00000520                          1050mmm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000520                 TRUE     1051mmm     IFEQ DEBUG
00000520  1A39 00C00003           1052mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000526  0805 0002               1053mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000052A  67F4                    1054mmm         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
0000052C  13DC 00C00007           1055mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000532                          1056mmm     ENDC
00000532                          1057mmm 
00000532                 FALSE    1058mmm     IFNE DEBUG
00000532                          1059mmm     ENDC
00000532                          1060mmm 
00000532                          1061mmm     ENDM
00000532  60E4                    1062mm     BRA LOOP_58
00000534                          1063mm EXIT_58
00000534                          1064mm     ENDM
00000534                          1065m     ENDM
00000534  6000 FECC               1066          BRA WAIT_FOR_SRECORD
00000538                          1067      ELSE
00000538  6000 03DE               1068s     BRA _00000003
0000053C                          1069s _00000002
0000053C                          1070          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000053C  B23C 0031               1071s     CMP.B   #'1',D1
00000540  6708                    1072s     BEQ.S   _00000004
00000542  B23C 0032               1073s     CMP.B   #'2',D1
00000546  6600 01F0               1074s     BNE.L   _00000005
0000054A                          1075s _00000004
0000054A  5783                    1076              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000054C                          1077  
0000054C  7800                    1078              MOVE.L #0,D4                            ; read two bytes of address
0000054E                          1079m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
0000054E  1E3C 0002               1080m     MOVE.B #2,D7
00000552                          1081m     WHILE.B D7 <GT> 0 DO
00000552                          1082ms _10000002
00000552  BE38 0000               1083ms     CMP.B   0,D7
00000556  6F00 0062               1084ms     BLE _10000003
0000055A  E98C                    1085m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000055C                          1086mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000055C                          1087mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000055C                          1088mm 
0000055C  1A39 00C00003           1089mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000562  0805 0000               1090mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000566  6700 0010               1091mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000056A                          1092mm 
0000056A                          1093mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000056A                 TRUE     1094mmm     IFEQ DEBUG
0000056A  1A39 00C00007           1095mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000570                          1096mmm     ENDC
00000570                 FALSE    1097mmm     IFNE DEBUG
00000570                          1098mmm     ENDC
00000570                          1099mmm 
00000570  BA3C 001B               1100mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000574  6700 FA92               1101mmm     BEQ START
00000578                          1102mmm     ENDM
00000578                          1103mm CONTINUE_61
00000578  1A39 00C00013           1104mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000057E  0805 0000               1105mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000582  67D8                    1106mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000584                          1107mm     
00000584  1A39 00C00017           1108mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000058A  13C5 00E00001           1109mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000590                          1110mm 
00000590                          1111mm     ENDM
00000590                          1112mm         PRINT_CHAR D5,D6
00000590                          1113mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000590                 TRUE     1114mm     IFEQ DEBUG
00000590  1C39 00C00003           1115mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000596  0806 0002               1116mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000059A  67F4                    1117mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
0000059C  13C5 00C00007           1118mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A2                          1119mm     ENDC
000005A2                          1120mm 
000005A2                 FALSE    1121mm     IFNE DEBUG
000005A2                          1122mm     ENDC
000005A2                          1123mm 
000005A2                          1124mm     ENDM
000005A2                          1125mm         HEX2BIN D5,D5,A4
000005A2  49FA 0C9B               1126mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005A6  0405 0030               1127mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AA  CABC 000000FF           1128mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005B0  1A34 5000               1129mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B4                          1130mm     ENDM
000005B4  8805                    1131m         OR.B D5,D4
000005B6  5307                    1132m         SUB.B #1,D7
000005B8                          1133m     ENDW
000005B8  6098                    1134ms     BRA _10000002
000005BA                          1135ms _10000003
000005BA                          1136m 
000005BA  7A00                    1137m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005BC  1A04                    1138m     MOVE.B D4,D5
000005BE  D484                    1139m     ADD.L D4,D2
000005C0                          1140m 
000005C0                          1141m     ENDM
000005C0                          1142m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000005C0  1E3C 0002               1143m     MOVE.B #2,D7
000005C4                          1144m     WHILE.B D7 <GT> 0 DO
000005C4                          1145ms _10000004
000005C4  BE38 0000               1146ms     CMP.B   0,D7
000005C8  6F00 0062               1147ms     BLE _10000005
000005CC  E98C                    1148m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005CE                          1149mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005CE                          1150mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                          1151mm 
000005CE  1A39 00C00003           1152mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005D4  0805 0000               1153mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D8  6700 0010               1154mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005DC                          1155mm 
000005DC                          1156mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005DC                 TRUE     1157mmm     IFEQ DEBUG
000005DC  1A39 00C00007           1158mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005E2                          1159mmm     ENDC
000005E2                 FALSE    1160mmm     IFNE DEBUG
000005E2                          1161mmm     ENDC
000005E2                          1162mmm 
000005E2  BA3C 001B               1163mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005E6  6700 FA20               1164mmm     BEQ START
000005EA                          1165mmm     ENDM
000005EA                          1166mm CONTINUE_66
000005EA  1A39 00C00013           1167mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F0  0805 0000               1168mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005F4  67D8                    1169mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
000005F6                          1170mm     
000005F6  1A39 00C00017           1171mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005FC  13C5 00E00001           1172mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000602                          1173mm 
00000602                          1174mm     ENDM
00000602                          1175mm         PRINT_CHAR D5,D6
00000602                          1176mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000602                 TRUE     1177mm     IFEQ DEBUG
00000602  1C39 00C00003           1178mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000608  0806 0002               1179mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000060C  67F4                    1180mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
0000060E  13C5 00C00007           1181mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000614                          1182mm     ENDC
00000614                          1183mm 
00000614                 FALSE    1184mm     IFNE DEBUG
00000614                          1185mm     ENDC
00000614                          1186mm 
00000614                          1187mm     ENDM
00000614                          1188mm         HEX2BIN D5,D5,A4
00000614  49FA 0C29               1189mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000618  0405 0030               1190mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000061C  CABC 000000FF           1191mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000622  1A34 5000               1192mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000626                          1193mm     ENDM
00000626  8805                    1194m         OR.B D5,D4
00000628  5307                    1195m         SUB.B #1,D7
0000062A                          1196m     ENDW
0000062A  6098                    1197ms     BRA _10000004
0000062C                          1198ms _10000005
0000062C                          1199m 
0000062C  7A00                    1200m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000062E  1A04                    1201m     MOVE.B D4,D5
00000630  D484                    1202m     ADD.L D4,D2
00000632                          1203m 
00000632                          1204m     ENDM
00000632                          1205  
00000632                          1206              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000632  B23C 0032               1207s     CMP.B   #'2',D1
00000636  6600 0076               1208s     BNE.L   _00000006
0000063A  5383                    1209                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000063C                          1210m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000063C  1E3C 0002               1211m     MOVE.B #2,D7
00000640                          1212m     WHILE.B D7 <GT> 0 DO
00000640                          1213ms _10000006
00000640  BE38 0000               1214ms     CMP.B   0,D7
00000644  6F00 0062               1215ms     BLE _10000007
00000648  E98C                    1216m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000064A                          1217mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000064A                          1218mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000064A                          1219mm 
0000064A  1A39 00C00003           1220mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000650  0805 0000               1221mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000654  6700 0010               1222mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
00000658                          1223mm 
00000658                          1224mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000658                 TRUE     1225mmm     IFEQ DEBUG
00000658  1A39 00C00007           1226mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000065E                          1227mmm     ENDC
0000065E                 FALSE    1228mmm     IFNE DEBUG
0000065E                          1229mmm     ENDC
0000065E                          1230mmm 
0000065E  BA3C 001B               1231mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000662  6700 F9A4               1232mmm     BEQ START
00000666                          1233mmm     ENDM
00000666                          1234mm CONTINUE_71
00000666  1A39 00C00013           1235mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000066C  0805 0000               1236mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000670  67D8                    1237mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
00000672                          1238mm     
00000672  1A39 00C00017           1239mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000678  13C5 00E00001           1240mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000067E                          1241mm 
0000067E                          1242mm     ENDM
0000067E                          1243mm         PRINT_CHAR D5,D6
0000067E                          1244mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000067E                 TRUE     1245mm     IFEQ DEBUG
0000067E  1C39 00C00003           1246mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000684  0806 0002               1247mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000688  67F4                    1248mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
0000068A  13C5 00C00007           1249mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000690                          1250mm     ENDC
00000690                          1251mm 
00000690                 FALSE    1252mm     IFNE DEBUG
00000690                          1253mm     ENDC
00000690                          1254mm 
00000690                          1255mm     ENDM
00000690                          1256mm         HEX2BIN D5,D5,A4
00000690  49FA 0BAD               1257mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000694  0405 0030               1258mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000698  CABC 000000FF           1259mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000069E  1A34 5000               1260mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006A2                          1261mm     ENDM
000006A2  8805                    1262m         OR.B D5,D4
000006A4  5307                    1263m         SUB.B #1,D7
000006A6                          1264m     ENDW
000006A6  6098                    1265ms     BRA _10000006
000006A8                          1266ms _10000007
000006A8                          1267m 
000006A8  7A00                    1268m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006AA  1A04                    1269m     MOVE.B D4,D5
000006AC  D484                    1270m     ADD.L D4,D2
000006AE                          1271m 
000006AE                          1272m     ENDM
000006AE                          1273              ENDI
000006AE                          1274s _00000006
000006AE                          1275  
000006AE  2444                    1276              MOVE.L D4,A2                            ; put the address in an address register
000006B0  D5C9                    1277              ADD.L A1,A2                             ; add in the offset
000006B2                          1278  
000006B2                          1279              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000006B2                          1280s _10000008
000006B2  B63C 0000               1281s     CMP.B   #0,D3
000006B6  6F00 007A               1282s     BLE _10000009
000006BA                          1283m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000006BA  1E3C 0002               1284m     MOVE.B #2,D7
000006BE                          1285m     WHILE.B D7 <GT> 0 DO
000006BE                          1286ms _1000000A
000006BE  BE38 0000               1287ms     CMP.B   0,D7
000006C2  6F00 0062               1288ms     BLE _1000000B
000006C6  E989                    1289m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000006C8                          1290mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006C8                          1291mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006C8                          1292mm 
000006C8  1A39 00C00003           1293mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006CE  0805 0000               1294mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006D2  6700 0010               1295mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006D6                          1296mm 
000006D6                          1297mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006D6                 TRUE     1298mmm     IFEQ DEBUG
000006D6  1A39 00C00007           1299mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006DC                          1300mmm     ENDC
000006DC                 FALSE    1301mmm     IFNE DEBUG
000006DC                          1302mmm     ENDC
000006DC                          1303mmm 
000006DC  BA3C 001B               1304mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006E0  6700 F926               1305mmm     BEQ START
000006E4                          1306mmm     ENDM
000006E4                          1307mm CONTINUE_76
000006E4  1A39 00C00013           1308mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006EA  0805 0000               1309mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006EE  67D8                    1310mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
000006F0                          1311mm     
000006F0  1A39 00C00017           1312mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006F6  13C5 00E00001           1313mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006FC                          1314mm 
000006FC                          1315mm     ENDM
000006FC                          1316mm         PRINT_CHAR D5,D6
000006FC                          1317mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                 TRUE     1318mm     IFEQ DEBUG
000006FC  1C39 00C00003           1319mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000702  0806 0002               1320mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000706  67F4                    1321mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
00000708  13C5 00C00007           1322mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000070E                          1323mm     ENDC
0000070E                          1324mm 
0000070E                 FALSE    1325mm     IFNE DEBUG
0000070E                          1326mm     ENDC
0000070E                          1327mm 
0000070E                          1328mm     ENDM
0000070E                          1329mm         HEX2BIN D5,D5,A4
0000070E  49FA 0B2F               1330mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000712  0405 0030               1331mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000716  CABC 000000FF           1332mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000071C  1A34 5000               1333mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000720                          1334mm     ENDM
00000720  8205                    1335m         OR.B D5,D1
00000722  5307                    1336m         SUB.B #1,D7
00000724                          1337m     ENDW
00000724  6098                    1338ms     BRA _1000000A
00000726                          1339ms _1000000B
00000726                          1340m 
00000726  7A00                    1341m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000728  1A01                    1342m     MOVE.B D1,D5
0000072A  D481                    1343m     ADD.L D1,D2
0000072C                          1344m 
0000072C                          1345m     ENDM
0000072C                          1346   
0000072C  14C1                    1347                  MOVE.B D1,(A2)+                     ; store it!
0000072E                          1348  
0000072E  5303                    1349                  SUB.B #1,D3                         ; 1 less byte to go
00000730                          1350              ENDW
00000730  6080                    1351s     BRA _10000008
00000732                          1352s _10000009
00000732                          1353  
00000732  7200                    1354              MOVE.L #0,D1                            ; not done yet
00000734                          1355          ELSE
00000734  6000 01E2               1356s     BRA _00000007
00000738                          1357s _00000005
00000738                          1358              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000738  B23C 0038               1359s     CMP.B   #'8',D1
0000073C  6600 0164               1360s     BNE.L   _00000008
00000740  7800                    1361                  MOVE.L #0,D4                        ; read the 24 bit start address
00000742                          1362m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000742  1E3C 0002               1363m     MOVE.B #2,D7
00000746                          1364m     WHILE.B D7 <GT> 0 DO
00000746                          1365ms _1000000C
00000746  BE38 0000               1366ms     CMP.B   0,D7
0000074A  6F00 0062               1367ms     BLE _1000000D
0000074E  E98C                    1368m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000750                          1369mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000750                          1370mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000750                          1371mm 
00000750  1A39 00C00003           1372mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000756  0805 0000               1373mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000075A  6700 0010               1374mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
0000075E                          1375mm 
0000075E                          1376mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075E                 TRUE     1377mmm     IFEQ DEBUG
0000075E  1A39 00C00007           1378mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000764                          1379mmm     ENDC
00000764                 FALSE    1380mmm     IFNE DEBUG
00000764                          1381mmm     ENDC
00000764                          1382mmm 
00000764  BA3C 001B               1383mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000768  6700 F89E               1384mmm     BEQ START
0000076C                          1385mmm     ENDM
0000076C                          1386mm CONTINUE_81
0000076C  1A39 00C00013           1387mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000772  0805 0000               1388mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000776  67D8                    1389mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00000778                          1390mm     
00000778  1A39 00C00017           1391mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077E  13C5 00E00001           1392mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000784                          1393mm 
00000784                          1394mm     ENDM
00000784                          1395mm         PRINT_CHAR D5,D6
00000784                          1396mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                 TRUE     1397mm     IFEQ DEBUG
00000784  1C39 00C00003           1398mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000078A  0806 0002               1399mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078E  67F4                    1400mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000790  13C5 00C00007           1401mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000796                          1402mm     ENDC
00000796                          1403mm 
00000796                 FALSE    1404mm     IFNE DEBUG
00000796                          1405mm     ENDC
00000796                          1406mm 
00000796                          1407mm     ENDM
00000796                          1408mm         HEX2BIN D5,D5,A4
00000796  49FA 0AA7               1409mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000079A  0405 0030               1410mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079E  CABC 000000FF           1411mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A4  1A34 5000               1412mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A8                          1413mm     ENDM
000007A8  8805                    1414m         OR.B D5,D4
000007AA  5307                    1415m         SUB.B #1,D7
000007AC                          1416m     ENDW
000007AC  6098                    1417ms     BRA _1000000C
000007AE                          1418ms _1000000D
000007AE                          1419m 
000007AE  7A00                    1420m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B0  1A04                    1421m     MOVE.B D4,D5
000007B2  D484                    1422m     ADD.L D4,D2
000007B4                          1423m 
000007B4                          1424m     ENDM
000007B4                          1425m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000007B4  1E3C 0002               1426m     MOVE.B #2,D7
000007B8                          1427m     WHILE.B D7 <GT> 0 DO
000007B8                          1428ms _1000000E
000007B8  BE38 0000               1429ms     CMP.B   0,D7
000007BC  6F00 0062               1430ms     BLE _1000000F
000007C0  E98C                    1431m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C2                          1432mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C2                          1433mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C2                          1434mm 
000007C2  1A39 00C00003           1435mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007C8  0805 0000               1436mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CC  6700 0010               1437mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007D0                          1438mm 
000007D0                          1439mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007D0                 TRUE     1440mmm     IFEQ DEBUG
000007D0  1A39 00C00007           1441mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007D6                          1442mmm     ENDC
000007D6                 FALSE    1443mmm     IFNE DEBUG
000007D6                          1444mmm     ENDC
000007D6                          1445mmm 
000007D6  BA3C 001B               1446mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007DA  6700 F82C               1447mmm     BEQ START
000007DE                          1448mmm     ENDM
000007DE                          1449mm CONTINUE_86
000007DE  1A39 00C00013           1450mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E4  0805 0000               1451mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E8  67D8                    1452mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007EA                          1453mm     
000007EA  1A39 00C00017           1454mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007F0  13C5 00E00001           1455mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F6                          1456mm 
000007F6                          1457mm     ENDM
000007F6                          1458mm         PRINT_CHAR D5,D6
000007F6                          1459mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F6                 TRUE     1460mm     IFEQ DEBUG
000007F6  1C39 00C00003           1461mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007FC  0806 0002               1462mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000800  67F4                    1463mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
00000802  13C5 00C00007           1464mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000808                          1465mm     ENDC
00000808                          1466mm 
00000808                 FALSE    1467mm     IFNE DEBUG
00000808                          1468mm     ENDC
00000808                          1469mm 
00000808                          1470mm     ENDM
00000808                          1471mm         HEX2BIN D5,D5,A4
00000808  49FA 0A35               1472mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080C  0405 0030               1473mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000810  CABC 000000FF           1474mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000816  1A34 5000               1475mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000081A                          1476mm     ENDM
0000081A  8805                    1477m         OR.B D5,D4
0000081C  5307                    1478m         SUB.B #1,D7
0000081E                          1479m     ENDW
0000081E  6098                    1480ms     BRA _1000000E
00000820                          1481ms _1000000F
00000820                          1482m 
00000820  7A00                    1483m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000822  1A04                    1484m     MOVE.B D4,D5
00000824  D484                    1485m     ADD.L D4,D2
00000826                          1486m 
00000826                          1487m     ENDM
00000826                          1488m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000826  1E3C 0002               1489m     MOVE.B #2,D7
0000082A                          1490m     WHILE.B D7 <GT> 0 DO
0000082A                          1491ms _10000010
0000082A  BE38 0000               1492ms     CMP.B   0,D7
0000082E  6F00 0062               1493ms     BLE _10000011
00000832  E98C                    1494m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000834                          1495mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000834                          1496mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000834                          1497mm 
00000834  1A39 00C00003           1498mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000083A  0805 0000               1499mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000083E  6700 0010               1500mm     BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
00000842                          1501mm 
00000842                          1502mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000842                 TRUE     1503mmm     IFEQ DEBUG
00000842  1A39 00C00007           1504mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000848                          1505mmm     ENDC
00000848                 FALSE    1506mmm     IFNE DEBUG
00000848                          1507mmm     ENDC
00000848                          1508mmm 
00000848  BA3C 001B               1509mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000084C  6700 F7BA               1510mmm     BEQ START
00000850                          1511mmm     ENDM
00000850                          1512mm CONTINUE_91
00000850  1A39 00C00013           1513mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000856  0805 0000               1514mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085A  67D8                    1515mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
0000085C                          1516mm     
0000085C  1A39 00C00017           1517mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000862  13C5 00E00001           1518mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000868                          1519mm 
00000868                          1520mm     ENDM
00000868                          1521mm         PRINT_CHAR D5,D6
00000868                          1522mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000868                 TRUE     1523mm     IFEQ DEBUG
00000868  1C39 00C00003           1524mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000086E  0806 0002               1525mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000872  67F4                    1526mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
00000874  13C5 00C00007           1527mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000087A                          1528mm     ENDC
0000087A                          1529mm 
0000087A                 FALSE    1530mm     IFNE DEBUG
0000087A                          1531mm     ENDC
0000087A                          1532mm 
0000087A                          1533mm     ENDM
0000087A                          1534mm         HEX2BIN D5,D5,A4
0000087A  49FA 09C3               1535mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000087E  0405 0030               1536mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000882  CABC 000000FF           1537mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000888  1A34 5000               1538mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000088C                          1539mm     ENDM
0000088C  8805                    1540m         OR.B D5,D4
0000088E  5307                    1541m         SUB.B #1,D7
00000890                          1542m     ENDW
00000890  6098                    1543ms     BRA _10000010
00000892                          1544ms _10000011
00000892                          1545m 
00000892  7A00                    1546m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000894  1A04                    1547m     MOVE.B D4,D5
00000896  D484                    1548m     ADD.L D4,D2
00000898                          1549m 
00000898                          1550m     ENDM
00000898                          1551  
00000898  2044                    1552                  MOVE.L D4,A0                        ; start address -> A0
0000089A  D1C9                    1553                  ADD.L A1,A0                         ; add in the offset
0000089C                          1554  
0000089C  72FF                    1555                  MOVE.L #$FFFFFFFF,D1                ; done
0000089E                          1556              ELSE
0000089E  6000 0078               1557s     BRA _00000009
000008A2                          1558s _00000008
000008A2                          1559m                 PRINT_CRLF D5,A4
000008A2  49FA 09C6               1560m     LEA CRLF(PC),A4
000008A6                          1561mm     PRINT_STR A4,D5
000008A6                          1562mm LOOP_96
000008A6  0C14 0000               1563mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008AA  6700 0016               1564mm     BEQ EXIT_96
000008AE                          1565mmm     PRINT_CHAR (A4)+,D5
000008AE                          1566mmm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AE                 TRUE     1567mmm     IFEQ DEBUG
000008AE  1A39 00C00003           1568mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008B4  0805 0002               1569mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008B8  67F4                    1570mmm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
000008BA  13DC 00C00007           1571mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008C0                          1572mmm     ENDC
000008C0                          1573mmm 
000008C0                 FALSE    1574mmm     IFNE DEBUG
000008C0                          1575mmm     ENDC
000008C0                          1576mmm 
000008C0                          1577mmm     ENDM
000008C0  60E4                    1578mm     BRA LOOP_96
000008C2                          1579mm EXIT_96
000008C2                          1580mm     ENDM
000008C2                          1581m     ENDM
000008C2                          1582  
000008C2  49FA 0930               1583                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008C6                          1584m                 PRINT_STR A4,D5
000008C6                          1585m LOOP_98
000008C6  0C14 0000               1586m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008CA  6700 0016               1587m     BEQ EXIT_98
000008CE                          1588mm     PRINT_CHAR (A4)+,D5
000008CE                          1589mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008CE                 TRUE     1590mm     IFEQ DEBUG
000008CE  1A39 00C00003           1591mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008D4  0805 0002               1592mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008D8  67F4                    1593mm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
000008DA  13DC 00C00007           1594mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008E0                          1595mm     ENDC
000008E0                          1596mm 
000008E0                 FALSE    1597mm     IFNE DEBUG
000008E0                          1598mm     ENDC
000008E0                          1599mm 
000008E0                          1600mm     ENDM
000008E0  60E4                    1601m     BRA LOOP_98
000008E2                          1602m EXIT_98
000008E2                          1603m     ENDM
000008E2                          1604m                 PRINT_CHAR D1,D5
000008E2                          1605m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E2                 TRUE     1606m     IFEQ DEBUG
000008E2  1A39 00C00003           1607m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008E8  0805 0002               1608m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008EC  67F4                    1609m         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000008EE  13C1 00C00007           1610m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008F4                          1611m     ENDC
000008F4                          1612m 
000008F4                 FALSE    1613m     IFNE DEBUG
000008F4                          1614m     ENDC
000008F4                          1615m 
000008F4                          1616m     ENDM
000008F4                          1617m                 PRINT_CRLF D5,A4
000008F4  49FA 0974               1618m     LEA CRLF(PC),A4
000008F8                          1619mm     PRINT_STR A4,D5
000008F8                          1620mm LOOP_102
000008F8  0C14 0000               1621mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008FC  6700 0016               1622mm     BEQ EXIT_102
00000900                          1623mmm     PRINT_CHAR (A4)+,D5
00000900                          1624mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000900                 TRUE     1625mmm     IFEQ DEBUG
00000900  1A39 00C00003           1626mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000906  0805 0002               1627mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000090A  67F4                    1628mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
0000090C  13DC 00C00007           1629mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000912                          1630mmm     ENDC
00000912                          1631mmm 
00000912                 FALSE    1632mmm     IFNE DEBUG
00000912                          1633mmm     ENDC
00000912                          1634mmm 
00000912                          1635mmm     ENDM
00000912  60E4                    1636mm     BRA LOOP_102
00000914                          1637mm EXIT_102
00000914                          1638mm     ENDM
00000914                          1639m     ENDM
00000914                          1640  
00000914  6000 FAEC               1641                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000918                          1642              ENDI
00000918                          1643s _00000009
00000918                          1644          ENDI
00000918                          1645s _00000007
00000918                          1646      ENDI
00000918                          1647s _00000003
00000918                          1648  
00000918                          1649m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000918  1E3C 0002               1650m     MOVE.B #2,D7
0000091C                          1651m     WHILE.B D7 <GT> 0 DO
0000091C                          1652ms _10000012
0000091C  BE38 0000               1653ms     CMP.B   0,D7
00000920  6F00 0062               1654ms     BLE _10000013
00000924  E98C                    1655m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000926                          1656mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000926                          1657mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000926                          1658mm 
00000926  1A39 00C00003           1659mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000092C  0805 0000               1660mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000930  6700 0010               1661mm     BEQ CONTINUE_105                                    ; NOTHING, CONTINUE
00000934                          1662mm 
00000934                          1663mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000934                 TRUE     1664mmm     IFEQ DEBUG
00000934  1A39 00C00007           1665mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000093A                          1666mmm     ENDC
0000093A                 FALSE    1667mmm     IFNE DEBUG
0000093A                          1668mmm     ENDC
0000093A                          1669mmm 
0000093A  BA3C 001B               1670mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000093E  6700 F6C8               1671mmm     BEQ START
00000942                          1672mmm     ENDM
00000942                          1673mm CONTINUE_105
00000942  1A39 00C00013           1674mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000948  0805 0000               1675mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094C  67D8                    1676mm     BEQ WAIT_FOR_READY_105                          ; NOTHING, CHECK AGAIN
0000094E                          1677mm     
0000094E  1A39 00C00017           1678mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000954  13C5 00E00001           1679mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000095A                          1680mm 
0000095A                          1681mm     ENDM
0000095A                          1682mm         PRINT_CHAR D5,D6
0000095A                          1683mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095A                 TRUE     1684mm     IFEQ DEBUG
0000095A  1C39 00C00003           1685mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000960  0806 0002               1686mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000964  67F4                    1687mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000966  13C5 00C00007           1688mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000096C                          1689mm     ENDC
0000096C                          1690mm 
0000096C                 FALSE    1691mm     IFNE DEBUG
0000096C                          1692mm     ENDC
0000096C                          1693mm 
0000096C                          1694mm     ENDM
0000096C                          1695mm         HEX2BIN D5,D5,A4
0000096C  49FA 08D1               1696mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000970  0405 0030               1697mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000974  CABC 000000FF           1698mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000097A  1A34 5000               1699mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000097E                          1700mm     ENDM
0000097E  8805                    1701m         OR.B D5,D4
00000980  5307                    1702m         SUB.B #1,D7
00000982                          1703m     ENDW
00000982  6098                    1704ms     BRA _10000012
00000984                          1705ms _10000013
00000984                          1706m 
00000984  7A00                    1707m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000986  1A04                    1708m     MOVE.B D4,D5
00000988  D484                    1709m     ADD.L D4,D2
0000098A                          1710m 
0000098A                          1711m     ENDM
0000098A                          1712m     PRINT_CRLF D5,A4
0000098A  49FA 08DE               1713m     LEA CRLF(PC),A4
0000098E                          1714mm     PRINT_STR A4,D5
0000098E                          1715mm LOOP_110
0000098E  0C14 0000               1716mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000992  6700 0016               1717mm     BEQ EXIT_110
00000996                          1718mmm     PRINT_CHAR (A4)+,D5
00000996                          1719mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000996                 TRUE     1720mmm     IFEQ DEBUG
00000996  1A39 00C00003           1721mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000099C  0805 0002               1722mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A0  67F4                    1723mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009A2  13DC 00C00007           1724mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009A8                          1725mmm     ENDC
000009A8                          1726mmm 
000009A8                 FALSE    1727mmm     IFNE DEBUG
000009A8                          1728mmm     ENDC
000009A8                          1729mmm 
000009A8                          1730mmm     ENDM
000009A8  60E4                    1731mm     BRA LOOP_110
000009AA                          1732mm EXIT_110
000009AA                          1733mm     ENDM
000009AA                          1734m     ENDM
000009AA                          1735  
000009AA                          1736      IF.B D2 <NE> #$FF THEN.L
000009AA  B43C 00FF               1737s     CMP.B   #$FF,D2
000009AE  6700 0090               1738s     BEQ.L   _0000000A
000009B2  49FA 0857               1739          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009B6                          1740m         PRINT_STR A4,D5
000009B6                          1741m LOOP_112
000009B6  0C14 0000               1742m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009BA  6700 0016               1743m     BEQ EXIT_112
000009BE                          1744mm     PRINT_CHAR (A4)+,D5
000009BE                          1745mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BE                 TRUE     1746mm     IFEQ DEBUG
000009BE  1A39 00C00003           1747mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009C4  0805 0002               1748mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009C8  67F4                    1749mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009CA  13DC 00C00007           1750mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009D0                          1751mm     ENDC
000009D0                          1752mm 
000009D0                 FALSE    1753mm     IFNE DEBUG
000009D0                          1754mm     ENDC
000009D0                          1755mm 
000009D0                          1756mm     ENDM
000009D0  60E4                    1757m     BRA LOOP_112
000009D2                          1758m EXIT_112
000009D2                          1759m     ENDM
000009D2                          1760m         PRINT_REG D0,D5,D2,D6,A4
000009D2  49FA 089C               1761m     LEA OX(PC),A4
000009D6                          1762mm     PRINT_STR A4,D5
000009D6                          1763mm LOOP_115
000009D6  0C14 0000               1764mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009DA  6700 0016               1765mm     BEQ EXIT_115
000009DE                          1766mmm     PRINT_CHAR (A4)+,D5
000009DE                          1767mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009DE                 TRUE     1768mmm     IFEQ DEBUG
000009DE  1A39 00C00003           1769mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009E4  0805 0002               1770mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009E8  67F4                    1771mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009EA  13DC 00C00007           1772mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F0                          1773mmm     ENDC
000009F0                          1774mmm 
000009F0                 FALSE    1775mmm     IFNE DEBUG
000009F0                          1776mmm     ENDC
000009F0                          1777mmm 
000009F0                          1778mmm     ENDM
000009F0  60E4                    1779mm     BRA LOOP_115
000009F2                          1780mm EXIT_115
000009F2                          1781mm     ENDM
000009F2  7C07                    1782m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009F4                          1783m LOOP_114
000009F4                          1784mm     BIN2HEX D0,D2,A4
000009F4  49FA 0839               1785mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009F8  E998                    1786mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009FA  1400                    1787mm     MOVE.B D0,D2
000009FC  0282 0000000F           1788mm     ANDI.L #$F,D2
00000A02  1434 2000               1789mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000A06                          1790mm     ENDM
00000A06                          1791mm     PRINT_CHAR D2,D5
00000A06                          1792mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A06                 TRUE     1793mm     IFEQ DEBUG
00000A06  1A39 00C00003           1794mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A0C  0805 0002               1795mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A10  67F4                    1796mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A12  13C2 00C00007           1797mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A18                          1798mm     ENDC
00000A18                          1799mm 
00000A18                 FALSE    1800mm     IFNE DEBUG
00000A18                          1801mm     ENDC
00000A18                          1802mm 
00000A18                          1803mm     ENDM
00000A18  57CE FFDA               1804m     DBEQ D6,LOOP_114
00000A1C                          1805m     ENDM
00000A1C                          1806m         PRINT_CRLF D5,A4
00000A1C  49FA 084C               1807m     LEA CRLF(PC),A4
00000A20                          1808mm     PRINT_STR A4,D5
00000A20                          1809mm LOOP_120
00000A20  0C14 0000               1810mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A24  6700 0016               1811mm     BEQ EXIT_120
00000A28                          1812mmm     PRINT_CHAR (A4)+,D5
00000A28                          1813mmm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A28                 TRUE     1814mmm     IFEQ DEBUG
00000A28  1A39 00C00003           1815mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2E  0805 0002               1816mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A32  67F4                    1817mmm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A34  13DC 00C00007           1818mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A3A                          1819mmm     ENDC
00000A3A                          1820mmm 
00000A3A                 FALSE    1821mmm     IFNE DEBUG
00000A3A                          1822mmm     ENDC
00000A3A                          1823mmm 
00000A3A                          1824mmm     ENDM
00000A3A  60E4                    1825mm     BRA LOOP_120
00000A3C                          1826mm EXIT_120
00000A3C                          1827mm     ENDM
00000A3C                          1828m     ENDM
00000A3C  6000 F73C               1829          BRA MAIN_LOOP
00000A40                          1830      ENDI
00000A40                          1831s _0000000A
00000A40                          1832  
00000A40                          1833      IF D1 <EQ> #0 THEN
00000A40  B27C 0000               1834s     CMP.W   #0,D1
00000A44  6600 0006               1835s     BNE _0000000B
00000A48  6000 F9B8               1836        BRA WAIT_FOR_SRECORD
00000A4C                          1837      ENDI
00000A4C                          1838s _0000000B
00000A4C                          1839  DOWNLOAD_DONE
00000A4C                          1840m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A4C  43FA 0822               1841m     LEA OX(PC),A1
00000A50                          1842mm     PRINT_STR A1,D5
00000A50                          1843mm LOOP_123
00000A50  0C11 0000               1844mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A54  6700 0016               1845mm     BEQ EXIT_123
00000A58                          1846mmm     PRINT_CHAR (A1)+,D5
00000A58                          1847mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A58                 TRUE     1848mmm     IFEQ DEBUG
00000A58  1A39 00C00003           1849mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A5E  0805 0002               1850mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A62  67F4                    1851mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A64  13D9 00C00007           1852mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A6A                          1853mmm     ENDC
00000A6A                          1854mmm 
00000A6A                 FALSE    1855mmm     IFNE DEBUG
00000A6A                          1856mmm     ENDC
00000A6A                          1857mmm 
00000A6A                          1858mmm     ENDM
00000A6A  60E4                    1859mm     BRA LOOP_123
00000A6C                          1860mm EXIT_123
00000A6C                          1861mm     ENDM
00000A6C  7407                    1862m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A6E                          1863m LOOP_122
00000A6E                          1864mm     BIN2HEX D0,D6,A1
00000A6E  43FA 07BF               1865mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A72  E998                    1866mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A74  1C00                    1867mm     MOVE.B D0,D6
00000A76  0286 0000000F           1868mm     ANDI.L #$F,D6
00000A7C  1C31 6000               1869mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A80                          1870mm     ENDM
00000A80                          1871mm     PRINT_CHAR D6,D5
00000A80                          1872mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1873mm     IFEQ DEBUG
00000A80  1A39 00C00003           1874mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A86  0805 0002               1875mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1876mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A8C  13C6 00C00007           1877mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A92                          1878mm     ENDC
00000A92                          1879mm 
00000A92                 FALSE    1880mm     IFNE DEBUG
00000A92                          1881mm     ENDC
00000A92                          1882mm 
00000A92                          1883mm     ENDM
00000A92  57CA FFDA               1884m     DBEQ D2,LOOP_122
00000A96                          1885m     ENDM
00000A96  43FA 073A               1886      LEA READ(PC),A1
00000A9A                          1887m     PRINT_STR A1,D5
00000A9A                          1888m LOOP_127
00000A9A  0C11 0000               1889m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A9E  6700 0016               1890m     BEQ EXIT_127
00000AA2                          1891mm     PRINT_CHAR (A1)+,D5
00000AA2                          1892mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA2                 TRUE     1893mm     IFEQ DEBUG
00000AA2  1A39 00C00003           1894mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA8  0805 0002               1895mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAC  67F4                    1896mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000AAE  13D9 00C00007           1897mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB4                          1898mm     ENDC
00000AB4                          1899mm 
00000AB4                 FALSE    1900mm     IFNE DEBUG
00000AB4                          1901mm     ENDC
00000AB4                          1902mm 
00000AB4                          1903mm     ENDM
00000AB4  60E4                    1904m     BRA LOOP_127
00000AB6                          1905m EXIT_127
00000AB6                          1906m     ENDM
00000AB6  2E08                    1907      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AB8                          1908m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000AB8  43FA 07B6               1909m     LEA OX(PC),A1
00000ABC                          1910mm     PRINT_STR A1,D5
00000ABC                          1911mm LOOP_130
00000ABC  0C11 0000               1912mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AC0  6700 0016               1913mm     BEQ EXIT_130
00000AC4                          1914mmm     PRINT_CHAR (A1)+,D5
00000AC4                          1915mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC4                 TRUE     1916mmm     IFEQ DEBUG
00000AC4  1A39 00C00003           1917mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ACA  0805 0002               1918mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACE  67F4                    1919mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AD0  13D9 00C00007           1920mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD6                          1921mmm     ENDC
00000AD6                          1922mmm 
00000AD6                 FALSE    1923mmm     IFNE DEBUG
00000AD6                          1924mmm     ENDC
00000AD6                          1925mmm 
00000AD6                          1926mmm     ENDM
00000AD6  60E4                    1927mm     BRA LOOP_130
00000AD8                          1928mm EXIT_130
00000AD8                          1929mm     ENDM
00000AD8  7407                    1930m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000ADA                          1931m LOOP_129
00000ADA                          1932mm     BIN2HEX D7,D6,A1
00000ADA  43FA 0753               1933mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000ADE  E99F                    1934mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AE0  1C07                    1935mm     MOVE.B D7,D6
00000AE2  0286 0000000F           1936mm     ANDI.L #$F,D6
00000AE8  1C31 6000               1937mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AEC                          1938mm     ENDM
00000AEC                          1939mm     PRINT_CHAR D6,D5
00000AEC                          1940mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AEC                 TRUE     1941mm     IFEQ DEBUG
00000AEC  1A39 00C00003           1942mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF2  0805 0002               1943mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AF6  67F4                    1944mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000AF8  13C6 00C00007           1945mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AFE                          1946mm     ENDC
00000AFE                          1947mm 
00000AFE                 FALSE    1948mm     IFNE DEBUG
00000AFE                          1949mm     ENDC
00000AFE                          1950mm 
00000AFE                          1951mm     ENDM
00000AFE  57CA FFDA               1952m     DBEQ D2,LOOP_129
00000B02                          1953m     ENDM
00000B02                          1954m     PRINT_CRLF D5,A4
00000B02  49FA 0766               1955m     LEA CRLF(PC),A4
00000B06                          1956mm     PRINT_STR A4,D5
00000B06                          1957mm LOOP_135
00000B06  0C14 0000               1958mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B0A  6700 0016               1959mm     BEQ EXIT_135
00000B0E                          1960mmm     PRINT_CHAR (A4)+,D5
00000B0E                          1961mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0E                 TRUE     1962mmm     IFEQ DEBUG
00000B0E  1A39 00C00003           1963mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B14  0805 0002               1964mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B18  67F4                    1965mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B1A  13DC 00C00007           1966mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B20                          1967mmm     ENDC
00000B20                          1968mmm 
00000B20                 FALSE    1969mmm     IFNE DEBUG
00000B20                          1970mmm     ENDC
00000B20                          1971mmm 
00000B20                          1972mmm     ENDM
00000B20  60E4                    1973mm     BRA LOOP_135
00000B22                          1974mm EXIT_135
00000B22                          1975mm     ENDM
00000B22                          1976m     ENDM
00000B22                          1977  
00000B22  6000 F656               1978      BRA MAIN_LOOP
00000B26                          1979  
00000B26                          1980  G
00000B26  2047                    1981      MOVE.L D7,A0                                    ; address accumulator -> address register
00000B28  3E3C 0000               1982      MOVE #0,D7                                      ; clear the now used address accumulator
00000B2C  4ED0                    1983      JMP (A0)                                        ; jump to it!
00000B2E                          1984  
00000B2E                          1985  Z
00000B2E  207C 00200000           1986      MOVE.L #RAM,A0                                  ; address of RAM
00000B34                          1987      
00000B34                          1988      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; write
00000B34  7000                    1989s     MOVE.L  #0,D0
00000B36  6000 0012               1990s     BRA _20000005
00000B3A                          1991s _20000004
00000B3A  2200                    1992          MOVE.L D0,D1                                ; progress update
00000B3C  E089                    1993          LSR.L #8,D1 
00000B3E  E089                    1994          LSR.L #8,D1
00000B40  13C1 00E00001           1995          MOVE.B D1,DISPLAY
00000B46                          1996  
00000B46  20C0                    1997          MOVE.L D0,(A0)+
00000B48                          1998      ENDF
00000B48  5880                    1999s     ADD.L   #4,D0
00000B4A                          2000s _20000005
00000B4A  B0BC 00040000           2001s     CMP.L   #$40000,D0
00000B50  6FE8                    2002s     BLE _20000004
00000B52                          2003  
00000B52  207C 00200000           2004      MOVE.L #RAM,A0                                  ; address of RAM
00000B58                          2005  
00000B58                          2006      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000B58  7000                    2007s     MOVE.L  #0,D0
00000B5A  6000 00A6               2008s     BRA _20000007
00000B5E                          2009s _20000006
00000B5E  2200                    2010          MOVE.L D0,D1                                ; progress update
00000B60  E089                    2011          LSR.L #8,D1
00000B62  E089                    2012          LSR.L #8,D1
00000B64  13C1 00E00001           2013          MOVE.B D1,DISPLAY
00000B6A                          2014  
00000B6A  2218                    2015          MOVE.L (A0)+,D1
00000B6C                          2016  
00000B6C                          2017          IF.L D0 <NE> D1 THEN
00000B6C  B081                    2018s     CMP.L   D1,D0
00000B6E  6700 0090               2019s     BEQ _0000000C
00000B72  43FA 06A9               2020              LEA RAM_ERROR(PC),A1
00000B76                          2021m             PRINT_STR A1,D1
00000B76                          2022m LOOP_137
00000B76  0C11 0000               2023m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B7A  6700 0016               2024m     BEQ EXIT_137
00000B7E                          2025mm     PRINT_CHAR (A1)+,D1
00000B7E                          2026mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     2027mm     IFEQ DEBUG
00000B7E  1239 00C00003           2028mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B84  0801 0002               2029mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B88  67F4                    2030mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000B8A  13D9 00C00007           2031mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B90                          2032mm     ENDC
00000B90                          2033mm 
00000B90                 FALSE    2034mm     IFNE DEBUG
00000B90                          2035mm     ENDC
00000B90                          2036mm 
00000B90                          2037mm     ENDM
00000B90  60E4                    2038m     BRA LOOP_137
00000B92                          2039m EXIT_137
00000B92                          2040m     ENDM
00000B92  2208                    2041              MOVE.L A0,D1
00000B94  5981                    2042              SUB.L #4,D1
00000B96                          2043m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B96  43FA 06D8               2044m     LEA OX(PC),A1
00000B9A                          2045mm     PRINT_STR A1,D3
00000B9A                          2046mm LOOP_140
00000B9A  0C11 0000               2047mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B9E  6700 0016               2048mm     BEQ EXIT_140
00000BA2                          2049mmm     PRINT_CHAR (A1)+,D3
00000BA2                          2050mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA2                 TRUE     2051mmm     IFEQ DEBUG
00000BA2  1639 00C00003           2052mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BA8  0803 0002               2053mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BAC  67F4                    2054mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000BAE  13D9 00C00007           2055mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB4                          2056mmm     ENDC
00000BB4                          2057mmm 
00000BB4                 FALSE    2058mmm     IFNE DEBUG
00000BB4                          2059mmm     ENDC
00000BB4                          2060mmm 
00000BB4                          2061mmm     ENDM
00000BB4  60E4                    2062mm     BRA LOOP_140
00000BB6                          2063mm EXIT_140
00000BB6                          2064mm     ENDM
00000BB6  7C07                    2065m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BB8                          2066m LOOP_139
00000BB8                          2067mm     BIN2HEX D1,D2,A1
00000BB8  43FA 0675               2068mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BBC  E999                    2069mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BBE  1401                    2070mm     MOVE.B D1,D2
00000BC0  0282 0000000F           2071mm     ANDI.L #$F,D2
00000BC6  1431 2000               2072mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000BCA                          2073mm     ENDM
00000BCA                          2074mm     PRINT_CHAR D2,D3
00000BCA                          2075mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCA                 TRUE     2076mm     IFEQ DEBUG
00000BCA  1639 00C00003           2077mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BD0  0803 0002               2078mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BD4  67F4                    2079mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000BD6  13C2 00C00007           2080mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BDC                          2081mm     ENDC
00000BDC                          2082mm 
00000BDC                 FALSE    2083mm     IFNE DEBUG
00000BDC                          2084mm     ENDC
00000BDC                          2085mm 
00000BDC                          2086mm     ENDM
00000BDC  57CE FFDA               2087m     DBEQ D6,LOOP_139
00000BE0                          2088m     ENDM
00000BE0                          2089m             PRINT_CRLF D3,A1
00000BE0  43FA 0688               2090m     LEA CRLF(PC),A1
00000BE4                          2091mm     PRINT_STR A1,D3
00000BE4                          2092mm LOOP_145
00000BE4  0C11 0000               2093mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BE8  6700 0016               2094mm     BEQ EXIT_145
00000BEC                          2095mmm     PRINT_CHAR (A1)+,D3
00000BEC                          2096mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEC                 TRUE     2097mmm     IFEQ DEBUG
00000BEC  1639 00C00003           2098mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BF2  0803 0002               2099mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BF6  67F4                    2100mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000BF8  13D9 00C00007           2101mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BFE                          2102mmm     ENDC
00000BFE                          2103mmm 
00000BFE                 FALSE    2104mmm     IFNE DEBUG
00000BFE                          2105mmm     ENDC
00000BFE                          2106mmm 
00000BFE                          2107mmm     ENDM
00000BFE  60E4                    2108mm     BRA LOOP_145
00000C00                          2109mm EXIT_145
00000C00                          2110mm     ENDM
00000C00                          2111m     ENDM
00000C00                          2112          ENDI 
00000C00                          2113s _0000000C
00000C00                          2114      ENDF
00000C00  5880                    2115s     ADD.L   #4,D0
00000C02                          2116s _20000007
00000C02  B0BC 00040000           2117s     CMP.L   #$40000,D0
00000C08  6F00 FF54               2118s     BLE _20000006
00000C0C                          2119  
00000C0C  6000 F56C               2120      BRA MAIN_LOOP
00000C10                          2121  
00000C10                          2122  L
00000C10  7000                    2123      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C12  7200                    2124      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C14                          2125  
00000C14                          2126      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C14  343C 0000               2127s     MOVE.W  #0,D2
00000C18  6000 0046               2128s     BRA _20000009
00000C1C                          2129s _20000008
00000C1C  E989                    2130          LSL.L #4,D1                                 ; make what we have so far more significant
00000C1E                          2131m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C1E                          2132m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1E                 TRUE     2133m     IFEQ DEBUG
00000C1E  1839 00C00003           2134m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C24  0804 0000               2135m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000C28  67F4                    2136m         BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00000C2A                          2137m     ENDC
00000C2A                          2138m 
00000C2A                          2139mm     READ_CHAR D3
00000C2A                 TRUE     2140mm     IFEQ DEBUG
00000C2A  1639 00C00007           2141mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000C30                          2142mm     ENDC
00000C30                 FALSE    2143mm     IFNE DEBUG
00000C30                          2144mm     ENDC
00000C30                          2145mm 
00000C30  B63C 001B               2146mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000C34  6700 F3D2               2147mm     BEQ START
00000C38                          2148mm     ENDM
00000C38                          2149m 
00000C38                 TRUE     2150m     IFEQ DEBUG
00000C38                          2151mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000C38                          2152mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C38                 TRUE     2153mm     IFEQ DEBUG
00000C38  1839 00C00003           2154mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C3E  0804 0002               2155mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000C42  67F4                    2156mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C44  13C3 00C00007           2157mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C4A                          2158mm     ENDC
00000C4A                          2159mm 
00000C4A                 FALSE    2160mm     IFNE DEBUG
00000C4A                          2161mm     ENDC
00000C4A                          2162mm 
00000C4A                          2163mm     ENDM
00000C4A                          2164m     ENDC
00000C4A                          2165m     ENDM
00000C4A                          2166m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C4A  41FA 05F3               2167m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C4E  0403 0030               2168m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C52  C6BC 000000FF           2169m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000C58  1630 3000               2170m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C5C                          2171m     ENDM
00000C5C  8203                    2172          OR.B D3,D1
00000C5E                          2173      ENDF
00000C5E  5242                    2174s     ADD.W   #1,D2
00000C60                          2175s _20000009
00000C60  B47C 0007               2176s     CMP.W   #7,D2
00000C64  6FB6                    2177s     BLE _20000008
00000C66                          2178  
00000C66  3001                    2179      MOVE.W D1,D0                                    ; extract the LSword for the length
00000C68  E089                    2180      LSR.L #8,D1                                     ; extract the MSword for the address
00000C6A  E089                    2181      LSR.L #8,D1
00000C6C                          2182  
00000C6C                          2183m     PRINT_CRLF D2,A1
00000C6C  43FA 05FC               2184m     LEA CRLF(PC),A1
00000C70                          2185mm     PRINT_STR A1,D2
00000C70                          2186mm LOOP_152
00000C70  0C11 0000               2187mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C74  6700 0016               2188mm     BEQ EXIT_152
00000C78                          2189mmm     PRINT_CHAR (A1)+,D2
00000C78                          2190mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C78                 TRUE     2191mmm     IFEQ DEBUG
00000C78  1439 00C00003           2192mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C7E  0802 0002               2193mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C82  67F4                    2194mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C84  13D9 00C00007           2195mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C8A                          2196mmm     ENDC
00000C8A                          2197mmm 
00000C8A                 FALSE    2198mmm     IFNE DEBUG
00000C8A                          2199mmm     ENDC
00000C8A                          2200mmm 
00000C8A                          2201mmm     ENDM
00000C8A  60E4                    2202mm     BRA LOOP_152
00000C8C                          2203mm EXIT_152
00000C8C                          2204mm     ENDM
00000C8C                          2205m     ENDM
00000C8C                          2206  
00000C8C  2041                    2207      MOVE.L D1,A0                                    ; target address
00000C8E                          2208  
00000C8E  2247                    2209      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C90  7E00                    2210      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C92                          2211  
00000C92  5089                    2212      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000C94  5180                    2213      SUB.L #8,D0
00000C96                          2214  
00000C96                          2215m     UNPROTECT
00000C96  31FC AAAA 2AAA          2216m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000C9C  4E71                    2217m     NOP
00000C9E  31FC 5555 1554          2218m     MOVE.W #$5555,$1554
00000CA4  4E71                    2219m     NOP
00000CA6  31FC 8080 2AAA          2220m     MOVE.W #$8080,$2AAA
00000CAC  4E71                    2221m     NOP
00000CAE  31FC AAAA 2AAA          2222m     MOVE.W #$AAAA,$2AAA
00000CB4  4E71                    2223m     NOP
00000CB6  31FC 5555 1554          2224m     MOVE.W #$5555,$1554
00000CBC  4E71                    2225m     NOP
00000CBE  31FC 2020 2AAA          2226m     MOVE.W #$2020,$2AAA
00000CC4                          2227m     ENDM
00000CC4                          2228  
00000CC4  45FA 0590               2229      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000CC8                          2230m     PRINT_STR A2,D2
00000CC8                          2231m LOOP_155
00000CC8  0C12 0000               2232m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CCC  6700 0016               2233m     BEQ EXIT_155
00000CD0                          2234mm     PRINT_CHAR (A2)+,D2
00000CD0                          2235mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD0                 TRUE     2236mm     IFEQ DEBUG
00000CD0  1439 00C00003           2237mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CD6  0802 0002               2238mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CDA  67F4                    2239mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CDC  13DA 00C00007           2240mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE2                          2241mm     ENDC
00000CE2                          2242mm 
00000CE2                 FALSE    2243mm     IFNE DEBUG
00000CE2                          2244mm     ENDC
00000CE2                          2245mm 
00000CE2                          2246mm     ENDM
00000CE2  60E4                    2247m     BRA LOOP_155
00000CE4                          2248m EXIT_155
00000CE4                          2249m     ENDM
00000CE4                          2250  
00000CE4  2409                    2251      MOVE.L A1,D2
00000CE6                          2252m     PRINT_REG D2,D3,D4,D5,A2
00000CE6  45FA 0588               2253m     LEA OX(PC),A2
00000CEA                          2254mm     PRINT_STR A2,D3
00000CEA                          2255mm LOOP_158
00000CEA  0C12 0000               2256mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CEE  6700 0016               2257mm     BEQ EXIT_158
00000CF2                          2258mmm     PRINT_CHAR (A2)+,D3
00000CF2                          2259mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CF2                 TRUE     2260mmm     IFEQ DEBUG
00000CF2  1639 00C00003           2261mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CF8  0803 0002               2262mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CFC  67F4                    2263mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000CFE  13DA 00C00007           2264mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D04                          2265mmm     ENDC
00000D04                          2266mmm 
00000D04                 FALSE    2267mmm     IFNE DEBUG
00000D04                          2268mmm     ENDC
00000D04                          2269mmm 
00000D04                          2270mmm     ENDM
00000D04  60E4                    2271mm     BRA LOOP_158
00000D06                          2272mm EXIT_158
00000D06                          2273mm     ENDM
00000D06  7A07                    2274m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D08                          2275m LOOP_157
00000D08                          2276mm     BIN2HEX D2,D4,A2
00000D08  45FA 0525               2277mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D0C  E99A                    2278mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D0E  1802                    2279mm     MOVE.B D2,D4
00000D10  0284 0000000F           2280mm     ANDI.L #$F,D4
00000D16  1832 4000               2281mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D1A                          2282mm     ENDM
00000D1A                          2283mm     PRINT_CHAR D4,D3
00000D1A                          2284mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D1A                 TRUE     2285mm     IFEQ DEBUG
00000D1A  1639 00C00003           2286mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D20  0803 0002               2287mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D24  67F4                    2288mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D26  13C4 00C00007           2289mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D2C                          2290mm     ENDC
00000D2C                          2291mm 
00000D2C                 FALSE    2292mm     IFNE DEBUG
00000D2C                          2293mm     ENDC
00000D2C                          2294mm 
00000D2C                          2295mm     ENDM
00000D2C  57CD FFDA               2296m     DBEQ D5,LOOP_157
00000D30                          2297m     ENDM
00000D30                          2298  
00000D30  45FA 0541               2299      LEA TO(PC),A2
00000D34                          2300m     PRINT_STR A2,D3
00000D34                          2301m LOOP_162
00000D34  0C12 0000               2302m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D38  6700 0016               2303m     BEQ EXIT_162
00000D3C                          2304mm     PRINT_CHAR (A2)+,D3
00000D3C                          2305mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3C                 TRUE     2306mm     IFEQ DEBUG
00000D3C  1639 00C00003           2307mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D42  0803 0002               2308mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D46  67F4                    2309mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D48  13DA 00C00007           2310mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D4E                          2311mm     ENDC
00000D4E                          2312mm 
00000D4E                 FALSE    2313mm     IFNE DEBUG
00000D4E                          2314mm     ENDC
00000D4E                          2315mm 
00000D4E                          2316mm     ENDM
00000D4E  60E4                    2317m     BRA LOOP_162
00000D50                          2318m EXIT_162
00000D50                          2319m     ENDM
00000D50                          2320  
00000D50  2408                    2321      MOVE.L A0,D2
00000D52                          2322m     PRINT_REG D2,D3,D4,D5,A2
00000D52  45FA 051C               2323m     LEA OX(PC),A2
00000D56                          2324mm     PRINT_STR A2,D3
00000D56                          2325mm LOOP_165
00000D56  0C12 0000               2326mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D5A  6700 0016               2327mm     BEQ EXIT_165
00000D5E                          2328mmm     PRINT_CHAR (A2)+,D3
00000D5E                          2329mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5E                 TRUE     2330mmm     IFEQ DEBUG
00000D5E  1639 00C00003           2331mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D64  0803 0002               2332mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D68  67F4                    2333mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D6A  13DA 00C00007           2334mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D70                          2335mmm     ENDC
00000D70                          2336mmm 
00000D70                 FALSE    2337mmm     IFNE DEBUG
00000D70                          2338mmm     ENDC
00000D70                          2339mmm 
00000D70                          2340mmm     ENDM
00000D70  60E4                    2341mm     BRA LOOP_165
00000D72                          2342mm EXIT_165
00000D72                          2343mm     ENDM
00000D72  7A07                    2344m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D74                          2345m LOOP_164
00000D74                          2346mm     BIN2HEX D2,D4,A2
00000D74  45FA 04B9               2347mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D78  E99A                    2348mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D7A  1802                    2349mm     MOVE.B D2,D4
00000D7C  0284 0000000F           2350mm     ANDI.L #$F,D4
00000D82  1832 4000               2351mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D86                          2352mm     ENDM
00000D86                          2353mm     PRINT_CHAR D4,D3
00000D86                          2354mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D86                 TRUE     2355mm     IFEQ DEBUG
00000D86  1639 00C00003           2356mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D8C  0803 0002               2357mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D90  67F4                    2358mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000D92  13C4 00C00007           2359mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D98                          2360mm     ENDC
00000D98                          2361mm 
00000D98                 FALSE    2362mm     IFNE DEBUG
00000D98                          2363mm     ENDC
00000D98                          2364mm 
00000D98                          2365mm     ENDM
00000D98  57CD FFDA               2366m     DBEQ D5,LOOP_164
00000D9C                          2367m     ENDM
00000D9C                          2368  
00000D9C                          2369m     PRINT_CRLF D3,A2
00000D9C  45FA 04CC               2370m     LEA CRLF(PC),A2
00000DA0                          2371mm     PRINT_STR A2,D3
00000DA0                          2372mm LOOP_170
00000DA0  0C12 0000               2373mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DA4  6700 0016               2374mm     BEQ EXIT_170
00000DA8                          2375mmm     PRINT_CHAR (A2)+,D3
00000DA8                          2376mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA8                 TRUE     2377mmm     IFEQ DEBUG
00000DA8  1639 00C00003           2378mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DAE  0803 0002               2379mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DB2  67F4                    2380mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DB4  13DA 00C00007           2381mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DBA                          2382mmm     ENDC
00000DBA                          2383mmm 
00000DBA                 FALSE    2384mmm     IFNE DEBUG
00000DBA                          2385mmm     ENDC
00000DBA                          2386mmm 
00000DBA                          2387mmm     ENDM
00000DBA  60E4                    2388mm     BRA LOOP_170
00000DBC                          2389mm EXIT_170
00000DBC                          2390mm     ENDM
00000DBC                          2391m     ENDM
00000DBC                          2392  
00000DBC                          2393      WHILE D0 <GT> #0 DO
00000DBC                          2394s _10000014
00000DBC  B07C 0000               2395s     CMP.W   #0,D0
00000DC0  6F00 001C               2396s     BLE _10000015
00000DC4  5580                    2397          SUB.L #2,D0
00000DC6                          2398  
00000DC6  13D1 00E00001           2399          MOVE.B (A1),DISPLAY
00000DCC                          2400m         PROGRAM (A1),(A0),D2
00000DCC  3091                    2401m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000DCE                          2402m 
00000DCE                          2403m WAIT_FOR_COMPLETE_172
00000DCE  3410                    2404m         MOVE.W (A0),D2
00000DD0                          2405m 
00000DD0                          2406m         IF.W D2 <NE> (A1) THEN
00000DD0  B451                    2407ms     CMP.W   (A1),D2
00000DD2  6700 0004               2408ms     BEQ _0000000D
00000DD6  60F6                    2409m             BRA WAIT_FOR_COMPLETE_172
00000DD8                          2410m         ENDI
00000DD8                          2411ms _0000000D
00000DD8                          2412m         ENDM
00000DD8                          2413  
00000DD8  5488                    2414          ADD.L #2,A0
00000DDA  5489                    2415          ADD.L #2,A1
00000DDC                          2416      ENDW
00000DDC  60DE                    2417s     BRA _10000014
00000DDE                          2418s _10000015
00000DDE                          2419  
00000DDE                          2420m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000DDE  31FC 0000 0000          2421m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000DE4                          2422m 
00000DE4                          2423m WAIT_FOR_COMPLETE_173
00000DE4  3438 0000               2424m         MOVE.W $0,D2
00000DE8                          2425m 
00000DE8                          2426m         IF.W D2 <NE> #0 THEN
00000DE8  B47C 0000               2427ms     CMP.W   #0,D2
00000DEC  6700 0004               2428ms     BEQ _0000000E
00000DF0  60F2                    2429m             BRA WAIT_FOR_COMPLETE_173
00000DF2                          2430m         ENDI
00000DF2                          2431ms _0000000E
00000DF2                          2432m         ENDM
00000DF2                          2433m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000DF2  31FC 0000 0002          2434m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000DF8                          2435m 
00000DF8                          2436m WAIT_FOR_COMPLETE_174
00000DF8  3438 0002               2437m         MOVE.W $2,D2
00000DFC                          2438m 
00000DFC                          2439m         IF.W D2 <NE> #0 THEN
00000DFC  B47C 0000               2440ms     CMP.W   #0,D2
00000E00  6700 0004               2441ms     BEQ _0000000F
00000E04  60F2                    2442m             BRA WAIT_FOR_COMPLETE_174
00000E06                          2443m         ENDI
00000E06                          2444ms _0000000F
00000E06                          2445m         ENDM
00000E06                          2446  
00000E06                          2447m     PROGRAM D1, $6, D2
00000E06  31C1 0006               2448m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000E0A                          2449m 
00000E0A                          2450m WAIT_FOR_COMPLETE_175
00000E0A  3438 0006               2451m         MOVE.W $6,D2
00000E0E                          2452m 
00000E0E                          2453m         IF.W D2 <NE> D1 THEN
00000E0E  B441                    2454ms     CMP.W   D1,D2
00000E10  6700 0004               2455ms     BEQ _00000010
00000E14  60F4                    2456m             BRA WAIT_FOR_COMPLETE_175
00000E16                          2457m         ENDI
00000E16                          2458ms _00000010
00000E16                          2459m         ENDM
00000E16  E089                    2460      LSR.L #8,D1
00000E18  E089                    2461      LSR.L #8,D1
00000E1A                          2462m     PROGRAM D1, $4, D2
00000E1A  31C1 0004               2463m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000E1E                          2464m 
00000E1E                          2465m WAIT_FOR_COMPLETE_176
00000E1E  3438 0004               2466m         MOVE.W $4,D2
00000E22                          2467m 
00000E22                          2468m         IF.W D2 <NE> D1 THEN
00000E22  B441                    2469ms     CMP.W   D1,D2
00000E24  6700 0004               2470ms     BEQ _00000011
00000E28  60F4                    2471m             BRA WAIT_FOR_COMPLETE_176
00000E2A                          2472m         ENDI
00000E2A                          2473ms _00000011
00000E2A                          2474m         ENDM
00000E2A                          2475  
00000E2A                          2476m     PROTECT
00000E2A  31FC AAAA 2AAA          2477m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000E30  31FC 5555 1554          2478m     MOVE.W #$5555,$1554
00000E36  31FC A0A0 2AAA          2479m     MOVE.W #$A0A0,$2AAA
00000E3C                          2480m     ENDM
00000E3C                          2481  
00000E3C  6000 F33C               2482      BRA MAIN_LOOP
00000E40                          2483  
00000E40                          2484  P
00000E40  7000                    2485      MOVE.L #0,D0                                    ; D0 will be the data to write
00000E42                          2486  
00000E42                          2487      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000E42  323C 0000               2488s     MOVE.W  #0,D1
00000E46  6000 0046               2489s     BRA _2000000B
00000E4A                          2490s _2000000A
00000E4A  E988                    2491          LSL.L #4,D0                                 ; make what we have so far more significant
00000E4C                          2492m         WAIT_CHAR D2,D3                             ; next character -> D2
00000E4C                          2493m WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2494m     IFEQ DEBUG
00000E4C  1639 00C00003           2495m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E52  0803 0000               2496m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E56  67F4                    2497m         BEQ WAIT_FOR_READY_178                      ; NOTHING, CHECK AGAIN
00000E58                          2498m     ENDC
00000E58                          2499m 
00000E58                          2500mm     READ_CHAR D2
00000E58                 TRUE     2501mm     IFEQ DEBUG
00000E58  1439 00C00007           2502mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000E5E                          2503mm     ENDC
00000E5E                 FALSE    2504mm     IFNE DEBUG
00000E5E                          2505mm     ENDC
00000E5E                          2506mm 
00000E5E  B43C 001B               2507mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000E62  6700 F1A4               2508mm     BEQ START
00000E66                          2509mm     ENDM
00000E66                          2510m 
00000E66                 TRUE     2511m     IFEQ DEBUG
00000E66                          2512mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000E66                          2513mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E66                 TRUE     2514mm     IFEQ DEBUG
00000E66  1639 00C00003           2515mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E6C  0803 0002               2516mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E70  67F4                    2517mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E72  13C2 00C00007           2518mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E78                          2519mm     ENDC
00000E78                          2520mm 
00000E78                 FALSE    2521mm     IFNE DEBUG
00000E78                          2522mm     ENDC
00000E78                          2523mm 
00000E78                          2524mm     ENDM
00000E78                          2525m     ENDC
00000E78                          2526m     ENDM
00000E78                          2527m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E78  41FA 03C5               2528m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E7C  0402 0030               2529m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E80  C4BC 000000FF           2530m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E86  1430 2000               2531m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E8A                          2532m     ENDM
00000E8A  8002                    2533          OR.B D2,D0
00000E8C                          2534      ENDF
00000E8C  5241                    2535s     ADD.W   #1,D1
00000E8E                          2536s _2000000B
00000E8E  B27C 0003               2537s     CMP.W   #3,D1
00000E92  6FB6                    2538s     BLE _2000000A
00000E94                          2539  
00000E94                          2540m     PRINT_CRLF D2,A1
00000E94  43FA 03D4               2541m     LEA CRLF(PC),A1
00000E98                          2542mm     PRINT_STR A1,D2
00000E98                          2543mm LOOP_183
00000E98  0C11 0000               2544mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E9C  6700 0016               2545mm     BEQ EXIT_183
00000EA0                          2546mmm     PRINT_CHAR (A1)+,D2
00000EA0                          2547mmm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA0                 TRUE     2548mmm     IFEQ DEBUG
00000EA0  1439 00C00003           2549mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EA6  0802 0002               2550mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EAA  67F4                    2551mmm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00000EAC  13D9 00C00007           2552mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB2                          2553mmm     ENDC
00000EB2                          2554mmm 
00000EB2                 FALSE    2555mmm     IFNE DEBUG
00000EB2                          2556mmm     ENDC
00000EB2                          2557mmm 
00000EB2                          2558mmm     ENDM
00000EB2  60E4                    2559mm     BRA LOOP_183
00000EB4                          2560mm EXIT_183
00000EB4                          2561mm     ENDM
00000EB4                          2562m     ENDM
00000EB4                          2563  
00000EB4  2047                    2564      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000EB6  7E00                    2565      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EB8                          2566  
00000EB8                          2567m     UNPROTECT
00000EB8  31FC AAAA 2AAA          2568m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EBE  4E71                    2569m     NOP
00000EC0  31FC 5555 1554          2570m     MOVE.W #$5555,$1554
00000EC6  4E71                    2571m     NOP
00000EC8  31FC 8080 2AAA          2572m     MOVE.W #$8080,$2AAA
00000ECE  4E71                    2573m     NOP
00000ED0  31FC AAAA 2AAA          2574m     MOVE.W #$AAAA,$2AAA
00000ED6  4E71                    2575m     NOP
00000ED8  31FC 5555 1554          2576m     MOVE.W #$5555,$1554
00000EDE  4E71                    2577m     NOP
00000EE0  31FC 2020 2AAA          2578m     MOVE.W #$2020,$2AAA
00000EE6                          2579m     ENDM
00000EE6                          2580               
00000EE6  45FA 036E               2581      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000EEA                          2582m     PRINT_STR A2,D2
00000EEA                          2583m LOOP_186
00000EEA  0C12 0000               2584m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EEE  6700 0016               2585m     BEQ EXIT_186
00000EF2                          2586mm     PRINT_CHAR (A2)+,D2
00000EF2                          2587mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF2                 TRUE     2588mm     IFEQ DEBUG
00000EF2  1439 00C00003           2589mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EF8  0802 0002               2590mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EFC  67F4                    2591mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000EFE  13DA 00C00007           2592mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F04                          2593mm     ENDC
00000F04                          2594mm 
00000F04                 FALSE    2595mm     IFNE DEBUG
00000F04                          2596mm     ENDC
00000F04                          2597mm 
00000F04                          2598mm     ENDM
00000F04  60E4                    2599m     BRA LOOP_186
00000F06                          2600m EXIT_186
00000F06                          2601m     ENDM
00000F06                          2602  
00000F06                          2603m     PRINT_CHAR '#',D3
00000F06                          2604m WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F06                 TRUE     2605m     IFEQ DEBUG
00000F06  1639 00C00003           2606m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F0C  0803 0002               2607m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F10  67F4                    2608m         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000F12  13F8 0023 00C00007      2609m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000F1A                          2610m     ENDC
00000F1A                          2611m 
00000F1A                 FALSE    2612m     IFNE DEBUG
00000F1A                          2613m     ENDC
00000F1A                          2614m 
00000F1A                          2615m     ENDM
00000F1A                          2616m     PRINT_REG D0,D3,D4,D5,A2
00000F1A  45FA 0354               2617m     LEA OX(PC),A2
00000F1E                          2618mm     PRINT_STR A2,D3
00000F1E                          2619mm LOOP_190
00000F1E  0C12 0000               2620mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F22  6700 0016               2621mm     BEQ EXIT_190
00000F26                          2622mmm     PRINT_CHAR (A2)+,D3
00000F26                          2623mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F26                 TRUE     2624mmm     IFEQ DEBUG
00000F26  1639 00C00003           2625mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2C  0803 0002               2626mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F30  67F4                    2627mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
00000F32  13DA 00C00007           2628mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F38                          2629mmm     ENDC
00000F38                          2630mmm 
00000F38                 FALSE    2631mmm     IFNE DEBUG
00000F38                          2632mmm     ENDC
00000F38                          2633mmm 
00000F38                          2634mmm     ENDM
00000F38  60E4                    2635mm     BRA LOOP_190
00000F3A                          2636mm EXIT_190
00000F3A                          2637mm     ENDM
00000F3A  7A07                    2638m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F3C                          2639m LOOP_189
00000F3C                          2640mm     BIN2HEX D0,D4,A2
00000F3C  45FA 02F1               2641mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F40  E998                    2642mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F42  1800                    2643mm     MOVE.B D0,D4
00000F44  0284 0000000F           2644mm     ANDI.L #$F,D4
00000F4A  1832 4000               2645mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F4E                          2646mm     ENDM
00000F4E                          2647mm     PRINT_CHAR D4,D3
00000F4E                          2648mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F4E                 TRUE     2649mm     IFEQ DEBUG
00000F4E  1639 00C00003           2650mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F54  0803 0002               2651mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F58  67F4                    2652mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F5A  13C4 00C00007           2653mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F60                          2654mm     ENDC
00000F60                          2655mm 
00000F60                 FALSE    2656mm     IFNE DEBUG
00000F60                          2657mm     ENDC
00000F60                          2658mm 
00000F60                          2659mm     ENDM
00000F60  57CD FFDA               2660m     DBEQ D5,LOOP_189
00000F64                          2661m     ENDM
00000F64                          2662  
00000F64  45FA 030D               2663      LEA TO(PC),A2
00000F68                          2664m     PRINT_STR A2,D3
00000F68                          2665m LOOP_194
00000F68  0C12 0000               2666m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F6C  6700 0016               2667m     BEQ EXIT_194
00000F70                          2668mm     PRINT_CHAR (A2)+,D3
00000F70                          2669mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F70                 TRUE     2670mm     IFEQ DEBUG
00000F70  1639 00C00003           2671mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F76  0803 0002               2672mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F7A  67F4                    2673mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F7C  13DA 00C00007           2674mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F82                          2675mm     ENDC
00000F82                          2676mm 
00000F82                 FALSE    2677mm     IFNE DEBUG
00000F82                          2678mm     ENDC
00000F82                          2679mm 
00000F82                          2680mm     ENDM
00000F82  60E4                    2681m     BRA LOOP_194
00000F84                          2682m EXIT_194
00000F84                          2683m     ENDM
00000F84                          2684  
00000F84  2408                    2685      MOVE.L A0,D2
00000F86                          2686m     PRINT_REG D2,D3,D4,D5,A2
00000F86  45FA 02E8               2687m     LEA OX(PC),A2
00000F8A                          2688mm     PRINT_STR A2,D3
00000F8A                          2689mm LOOP_197
00000F8A  0C12 0000               2690mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F8E  6700 0016               2691mm     BEQ EXIT_197
00000F92                          2692mmm     PRINT_CHAR (A2)+,D3
00000F92                          2693mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F92                 TRUE     2694mmm     IFEQ DEBUG
00000F92  1639 00C00003           2695mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F98  0803 0002               2696mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F9C  67F4                    2697mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000F9E  13DA 00C00007           2698mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA4                          2699mmm     ENDC
00000FA4                          2700mmm 
00000FA4                 FALSE    2701mmm     IFNE DEBUG
00000FA4                          2702mmm     ENDC
00000FA4                          2703mmm 
00000FA4                          2704mmm     ENDM
00000FA4  60E4                    2705mm     BRA LOOP_197
00000FA6                          2706mm EXIT_197
00000FA6                          2707mm     ENDM
00000FA6  7A07                    2708m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FA8                          2709m LOOP_196
00000FA8                          2710mm     BIN2HEX D2,D4,A2
00000FA8  45FA 0285               2711mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FAC  E99A                    2712mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FAE  1802                    2713mm     MOVE.B D2,D4
00000FB0  0284 0000000F           2714mm     ANDI.L #$F,D4
00000FB6  1832 4000               2715mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FBA                          2716mm     ENDM
00000FBA                          2717mm     PRINT_CHAR D4,D3
00000FBA                          2718mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FBA                 TRUE     2719mm     IFEQ DEBUG
00000FBA  1639 00C00003           2720mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FC0  0803 0002               2721mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FC4  67F4                    2722mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00000FC6  13C4 00C00007           2723mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FCC                          2724mm     ENDC
00000FCC                          2725mm 
00000FCC                 FALSE    2726mm     IFNE DEBUG
00000FCC                          2727mm     ENDC
00000FCC                          2728mm 
00000FCC                          2729mm     ENDM
00000FCC  57CD FFDA               2730m     DBEQ D5,LOOP_196
00000FD0                          2731m     ENDM
00000FD0                          2732  
00000FD0                          2733m     PRINT_CRLF D3,A2
00000FD0  45FA 0298               2734m     LEA CRLF(PC),A2
00000FD4                          2735mm     PRINT_STR A2,D3
00000FD4                          2736mm LOOP_202
00000FD4  0C12 0000               2737mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FD8  6700 0016               2738mm     BEQ EXIT_202
00000FDC                          2739mmm     PRINT_CHAR (A2)+,D3
00000FDC                          2740mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FDC                 TRUE     2741mmm     IFEQ DEBUG
00000FDC  1639 00C00003           2742mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FE2  0803 0002               2743mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FE6  67F4                    2744mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00000FE8  13DA 00C00007           2745mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FEE                          2746mmm     ENDC
00000FEE                          2747mmm 
00000FEE                 FALSE    2748mmm     IFNE DEBUG
00000FEE                          2749mmm     ENDC
00000FEE                          2750mmm 
00000FEE                          2751mmm     ENDM
00000FEE  60E4                    2752mm     BRA LOOP_202
00000FF0                          2753mm EXIT_202
00000FF0                          2754mm     ENDM
00000FF0                          2755m     ENDM
00000FF0                          2756  
00000FF0                          2757m     PROGRAM D0,(A0),D2
00000FF0  3080                    2758m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FF2                          2759m 
00000FF2                          2760m WAIT_FOR_COMPLETE_204
00000FF2  3410                    2761m         MOVE.W (A0),D2
00000FF4                          2762m 
00000FF4                          2763m         IF.W D2 <NE> D0 THEN
00000FF4  B440                    2764ms     CMP.W   D0,D2
00000FF6  6700 0004               2765ms     BEQ _00000012
00000FFA  60F6                    2766m             BRA WAIT_FOR_COMPLETE_204
00000FFC                          2767m         ENDI
00000FFC                          2768ms _00000012
00000FFC                          2769m         ENDM
00000FFC                          2770  
00000FFC                          2771m     PROTECT
00000FFC  31FC AAAA 2AAA          2772m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001002  31FC 5555 1554          2773m     MOVE.W #$5555,$1554
00001008  31FC A0A0 2AAA          2774m     MOVE.W #$A0A0,$2AAA
0000100E                          2775m     ENDM
0000100E                          2776  
0000100E  6000 F16A               2777      BRA MAIN_LOOP
00001012                          2778      
00001012                          2779  M
00001012  7000                    2780      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001014  7200                    2781      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001016                          2782  
00001016                          2783      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001016  343C 0000               2784s     MOVE.W  #0,D2
0000101A  6000 0046               2785s     BRA _2000000D
0000101E                          2786s _2000000C
0000101E  E989                    2787          LSL.L #4,D1                                     ; make what we have so far more significant
00001020                          2788m         WAIT_CHAR D3,D4                                 ; next character -> D2
00001020                          2789m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001020                 TRUE     2790m     IFEQ DEBUG
00001020  1839 00C00003           2791m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001026  0804 0000               2792m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000102A  67F4                    2793m         BEQ WAIT_FOR_READY_206                      ; NOTHING, CHECK AGAIN
0000102C                          2794m     ENDC
0000102C                          2795m 
0000102C                          2796mm     READ_CHAR D3
0000102C                 TRUE     2797mm     IFEQ DEBUG
0000102C  1639 00C00007           2798mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001032                          2799mm     ENDC
00001032                 FALSE    2800mm     IFNE DEBUG
00001032                          2801mm     ENDC
00001032                          2802mm 
00001032  B63C 001B               2803mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001036  6700 EFD0               2804mm     BEQ START
0000103A                          2805mm     ENDM
0000103A                          2806m 
0000103A                 TRUE     2807m     IFEQ DEBUG
0000103A                          2808mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000103A                          2809mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103A                 TRUE     2810mm     IFEQ DEBUG
0000103A  1839 00C00003           2811mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001040  0804 0002               2812mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001044  67F4                    2813mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
00001046  13C3 00C00007           2814mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000104C                          2815mm     ENDC
0000104C                          2816mm 
0000104C                 FALSE    2817mm     IFNE DEBUG
0000104C                          2818mm     ENDC
0000104C                          2819mm 
0000104C                          2820mm     ENDM
0000104C                          2821m     ENDC
0000104C                          2822m     ENDM
0000104C                          2823m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
0000104C  41FA 01F1               2824m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001050  0403 0030               2825m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001054  C6BC 000000FF           2826m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
0000105A  1630 3000               2827m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
0000105E                          2828m     ENDM
0000105E  8203                    2829          OR.B D3,D1
00001060                          2830      ENDF
00001060  5242                    2831s     ADD.W   #1,D2
00001062                          2832s _2000000D
00001062  B47C 0007               2833s     CMP.W   #7,D2
00001066  6FB6                    2834s     BLE _2000000C
00001068                          2835m     PRINT_CRLF D2,A1
00001068  43FA 0200               2836m     LEA CRLF(PC),A1
0000106C                          2837mm     PRINT_STR A1,D2
0000106C                          2838mm LOOP_211
0000106C  0C11 0000               2839mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001070  6700 0016               2840mm     BEQ EXIT_211
00001074                          2841mmm     PRINT_CHAR (A1)+,D2
00001074                          2842mmm WAIT_FOR_READY_212                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001074                 TRUE     2843mmm     IFEQ DEBUG
00001074  1439 00C00003           2844mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000107A  0802 0002               2845mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000107E  67F4                    2846mmm         BEQ WAIT_FOR_READY_212                      ; NO SPACE, CHECK AGAIN
00001080  13D9 00C00007           2847mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001086                          2848mmm     ENDC
00001086                          2849mmm 
00001086                 FALSE    2850mmm     IFNE DEBUG
00001086                          2851mmm     ENDC
00001086                          2852mmm 
00001086                          2853mmm     ENDM
00001086  60E4                    2854mm     BRA LOOP_211
00001088                          2855mm EXIT_211
00001088                          2856mm     ENDM
00001088                          2857m     ENDM
00001088                          2858  
00001088  3001                    2859      MOVE.W D1,D0                                        ; extract the LSword for the length
0000108A  E089                    2860      LSR.L #8,D1                                         ; extract the MSword for the address
0000108C  E089                    2861      LSR.L #8,D1
0000108E                          2862  
0000108E  2241                    2863      MOVE.L D1,A1
00001090                          2864      
00001090  2047                    2865      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001092                          2866      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001092                          2867  
00001092                          2868      WHILE D0 <GT> #0 DO
00001092                          2869s _10000016
00001092  B07C 0000               2870s     CMP.W   #0,D0
00001096  6F00 000E               2871s     BLE _10000017
0000109A  5580                    2872          SUB.L #2,D0
0000109C                          2873  
0000109C  13D1 00E00001           2874          MOVE.B (A1),DISPLAY
000010A2  30D9                    2875          MOVE.W (A1)+,(A0)+
000010A4                          2876      ENDW
000010A4  60EC                    2877s     BRA _10000016
000010A6                          2878s _10000017
000010A6                          2879      
000010A6  6000 F0D2               2880      BRA MAIN_LOOP
000010AA                          2881  
000010AA                          2882  HEX_DIGIT
000010AA  E98F                    2883      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000010AC                          2884m     HEX2BIN D2,D2,A0
000010AC  41FA 0191               2885m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000010B0  0402 0030               2886m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010B4  C4BC 000000FF           2887m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000010BA  1430 2000               2888m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000010BE                          2889m     ENDM
000010BE  8E02                    2890      OR.B D2,D7  
000010C0  6000 F0D8               2891      BRA GET_INPUT
000010C4                          2892  
000010C4  FFFF FFFF               2893      SIMHALT                                             ; halt simulator
000010C8                          2894  
000010C8                          2895  ; strings
000010C8= 50 72 65 73 73 20 ...   2896  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
000010DB= 3F 09 09 09 68 65 ...   2897  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
000010E5= 5B 76 5D 09 09 09 ...   2898          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
000010F4= 78 78 78 78 78 78 ...   2899          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000110C= 78 78 78 78 78 78 ...   2900          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000112C= 5B 73 5D 09 09 09 ...   2901          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00001146= 78 78 78 78 78 78 ...   2902          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001157= 5B 7A 5D 09 09 09 ...   2903          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001169= 78 78 78 78 78 78 ...   2904          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
0000118A= 78 78 78 78 78 78 ...   2905          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000011A9= 78 78 78 78 78 78 ...   2906          DC.B 'xxxxxxxx[m]xxxx',TAB,TAB,'monitor to RAM',CR,LF,NULL
000011CB= 48 75 68 3F 0D 0A 00    2907  HUH  DC.B 'Huh?',CR,LF,NULL
000011D2= 20 53 20 72 65 63 ...   2908  READ    DC.B ' S records read, start address = ',NULL
000011F4= 57 3A 20 55 6E 6B ...   2909  UNREC   DC.B 'W: Unknown Srec type: ',NULL
0000120B= 57 3A 20 43 53 20 ...   2910  CS_FAILURE  DC.B 'W: CS failure at ',NULL
0000121D= 57 3A 20 52 41 4D ...   2911  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
0000122F= 30 31 32 33 34 35 ...   2912  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000123F= 00 01 02 03 04 05 ...   2913  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001256= 4C 6F 61 64 69 6E ...   2914  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
0000126A= 0D 0A 00                2915  CRLF    DC.B CR,LF,NULL
0000126D= 3E 20 00                2916  PROMPT  DC.B '> ',NULL
00001270= 30 78 00                2917  ox      DC.B '0x',NULL
00001273= 20 2D 3E 20 00          2918  to      DC.B ' -> ',NULL
00001278= 4D 44 46 2D 6D 6F ...   2919  VERSION DC.B 'MDF-mon V1.72 (12/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001295                          2920  
00001295                          2921      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         122F
CONTINUE_105        942
CONTINUE_46         41E
CONTINUE_49         46E
CONTINUE_53         4C4
CONTINUE_61         578
CONTINUE_66         5EA
CONTINUE_71         666
CONTINUE_76         6E4
CONTINUE_81         76C
CONTINUE_86         7DE
CONTINUE_91         850
CR                  D
CRLF                126A
CS_FAILURE          120B
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A4C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            914
EXIT_110            9AA
EXIT_112            9D2
EXIT_115            9F2
EXIT_12             170
EXIT_120            A3C
EXIT_123            A6C
EXIT_127            AB6
EXIT_130            AD8
EXIT_135            B22
EXIT_137            B92
EXIT_14             19A
EXIT_140            BB6
EXIT_145            C00
EXIT_152            C8C
EXIT_155            CE4
EXIT_158            D06
EXIT_162            D50
EXIT_165            D72
EXIT_170            DBC
EXIT_183            EB4
EXIT_186            F06
EXIT_190            F3A
EXIT_194            F84
EXIT_197            FA6
EXIT_20             22E
EXIT_202            FF0
EXIT_211            1088
EXIT_22             27E
EXIT_24             2AA
EXIT_27             2D4
EXIT_37             382
EXIT_44             3F6
EXIT_5              110
EXIT_58             534
EXIT_7              130
EXIT_9              150
EXIT_96             8C2
EXIT_98             8E2
G                   B26
GET_INPUT           19A
H                   282
HELP                10DB
HELPPROMPT          10C8
HEX2BIN             10B
HEX2BIN_LUT         123F
HEX_DIGIT           10AA
HUH                 11CB
L                   C10
LF                  A
LOADING             1256
LOOP_102            8F8
LOOP_110            98E
LOOP_112            9B6
LOOP_114            9F4
LOOP_115            9D6
LOOP_12             154
LOOP_120            A20
LOOP_122            A6E
LOOP_123            A50
LOOP_127            A9A
LOOP_129            ADA
LOOP_130            ABC
LOOP_135            B06
LOOP_137            B76
LOOP_139            BB8
LOOP_14             17E
LOOP_140            B9A
LOOP_145            BE4
LOOP_152            C70
LOOP_155            CC8
LOOP_157            D08
LOOP_158            CEA
LOOP_162            D34
LOOP_164            D74
LOOP_165            D56
LOOP_170            DA0
LOOP_183            E98
LOOP_186            EEA
LOOP_189            F3C
LOOP_190            F1E
LOOP_194            F68
LOOP_196            FA8
LOOP_197            F8A
LOOP_20             212
LOOP_202            FD4
LOOP_211            106C
LOOP_22             262
LOOP_24             28E
LOOP_26             2D6
LOOP_27             2B8
LOOP_37             366
LOOP_44             3DA
LOOP_5              F4
LOOP_58             518
LOOP_7              114
LOOP_9              134
LOOP_96             8A6
LOOP_98             8C6
M                   1012
MAIN_LOOP           17A
NULL                0
OX                  1270
P                   E40
PRINTSTR            28E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              126D
PROTECT             A40
R                   2AE
RAM                 200000
RAM_ERROR           121D
READ                11D2
READ_CHAR           62D
READ_DATA_TO_POKE   38A
RESET               4
ROM                 0
S                   3FA
STACK               0
START               8
TAB                 9
TO                  1273
UNPROTECT           979
UNREC               11F4
V                   28A
VERSION             1278
W                   386
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_172  DCE
WAIT_FOR_COMPLETE_173  DE4
WAIT_FOR_COMPLETE_174  DF8
WAIT_FOR_COMPLETE_175  E0A
WAIT_FOR_COMPLETE_176  E1E
WAIT_FOR_COMPLETE_204  FF2
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8E2
WAIT_FOR_READY_103  900
WAIT_FOR_READY_105  926
WAIT_FOR_READY_107  95A
WAIT_FOR_READY_111  996
WAIT_FOR_READY_113  9BE
WAIT_FOR_READY_116  9DE
WAIT_FOR_READY_118  A06
WAIT_FOR_READY_121  A28
WAIT_FOR_READY_124  A58
WAIT_FOR_READY_126  A80
WAIT_FOR_READY_128  AA2
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  AC4
WAIT_FOR_READY_133  AEC
WAIT_FOR_READY_136  B0E
WAIT_FOR_READY_138  B7E
WAIT_FOR_READY_141  BA2
WAIT_FOR_READY_143  BCA
WAIT_FOR_READY_146  BEC
WAIT_FOR_READY_147  C1E
WAIT_FOR_READY_149  C38
WAIT_FOR_READY_15   186
WAIT_FOR_READY_153  C78
WAIT_FOR_READY_156  CD0
WAIT_FOR_READY_159  CF2
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  D1A
WAIT_FOR_READY_163  D3C
WAIT_FOR_READY_166  D5E
WAIT_FOR_READY_168  D86
WAIT_FOR_READY_171  DA8
WAIT_FOR_READY_178  E4C
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  E66
WAIT_FOR_READY_184  EA0
WAIT_FOR_READY_187  EF2
WAIT_FOR_READY_188  F06
WAIT_FOR_READY_191  F26
WAIT_FOR_READY_193  F4E
WAIT_FOR_READY_195  F70
WAIT_FOR_READY_198  F92
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_200  FBA
WAIT_FOR_READY_203  FDC
WAIT_FOR_READY_206  1020
WAIT_FOR_READY_208  103A
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_212  1074
WAIT_FOR_READY_23   26A
WAIT_FOR_READY_25   296
WAIT_FOR_READY_28   2C0
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2E8
WAIT_FOR_READY_31   2FE
WAIT_FOR_READY_32   314
WAIT_FOR_READY_33   328
WAIT_FOR_READY_34   33C
WAIT_FOR_READY_35   350
WAIT_FOR_READY_38   36E
WAIT_FOR_READY_39   38C
WAIT_FOR_READY_41   3A6
WAIT_FOR_READY_45   3E2
WAIT_FOR_READY_46   402
WAIT_FOR_READY_48   43C
WAIT_FOR_READY_49   452
WAIT_FOR_READY_51   486
WAIT_FOR_READY_53   4A8
WAIT_FOR_READY_55   4DC
WAIT_FOR_READY_59   520
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   55C
WAIT_FOR_READY_63   590
WAIT_FOR_READY_66   5CE
WAIT_FOR_READY_68   602
WAIT_FOR_READY_71   64A
WAIT_FOR_READY_73   67E
WAIT_FOR_READY_76   6C8
WAIT_FOR_READY_78   6FC
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   750
WAIT_FOR_READY_83   784
WAIT_FOR_READY_86   7C2
WAIT_FOR_READY_88   7F6
WAIT_FOR_READY_91   834
WAIT_FOR_READY_93   868
WAIT_FOR_READY_97   8AE
WAIT_FOR_READY_99   8CE
WAIT_FOR_SRECORD    402
Z                   B2E
_00000000           1DA
_00000001           1EE
_00000002           53C
_00000003           918
_00000004           54A
_00000005           738
_00000006           6AE
_00000007           918
_00000008           8A2
_00000009           918
_0000000A           A40
_0000000B           A4C
_0000000C           C00
_0000000D           DD8
_0000000E           DF2
_0000000F           E06
_00000010           E16
_00000011           E2A
_00000012           FFC
_10000000           49E
_10000001           506
_10000002           552
_10000003           5BA
_10000004           5C4
_10000005           62C
_10000006           640
_10000007           6A8
_10000008           6B2
_10000009           732
_1000000A           6BE
_1000000B           726
_1000000C           746
_1000000D           7AE
_1000000E           7B8
_1000000F           820
_10000010           82A
_10000011           892
_10000012           91C
_10000013           984
_10000014           DBC
_10000015           DDE
_10000016           1092
_10000017           10A6
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           B3A
_20000005           B4A
_20000006           B5E
_20000007           C02
_20000008           C1C
_20000009           C60
_2000000A           E4A
_2000000B           E8E
_2000000C           101E
_2000000D           1062
