00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 06/04/2021 17:53:37

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; FIX RESET VECTOR
00000000                             9  ; backspace?
00000000                            10  ; use the software protect and then wire up the write and oe lines permanently for the eeprom
00000000                            11    ; i'd need to write the unprotect pattern and then the reprotect at the end
00000000                            12    ; and, at that point we shouldn't be anywhere near ROM, so it shouldn't get corrupted: the inversion should also
00000000                            13  ; add LDS and UDS with an OR gate
00000000                            14  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            15  ; copy the monitor to RAM to make it easier to test the write to EEPROM
00000000                            16  ; lots of repeated code in download
00000000                            17  ;ram CHECK AT STARTUP??? WIOLL PREVEWNT RUNNIG CODE FROM RAM THOUGH, SO need cold/warm start
00000000                            18  ; check for escape during Z
00000000                            19  ; fix the DUART base address
00000000                            20  ; tidy up layout (indentation and comments)
00000000                            21  ; stop using two registers in download
00000000                            22  ; add a .W and .B variants of PRINT_REG
00000000                            23  ; implement DOWNLOAD_BYTE to remove repeated code
00000000                            24  ; fix being able to enter random chars when W'ing
00000000                            25  ;JMP -> BRA
00000000                            26  
00000000                            27  
00000000                            28      ORG  $0
00000000                            29      ;ORG  $200000
00000000                            30  
00000000  =00000000                 31  DEBUG               EQU 0
00000000                            32  
00000000                            33  
00000000                            34  ; constants
00000000  =00000000                 35  ROM                 EQU $0
00000000  =00200000                 36  RAM                 EQU $200000
00000000                            37  
00000000  =00E00000                 38  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 39  DISPLAY_            EQU $0
00000000  =00E00001                 40  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            41     
00000000  =00D30000                 42  DUART_BASE          EQU $D30000
00000000  =00000000                 43  DUART_MRA_          EQU $0
00000000  =00000001                 44  DUART_CSRA_         EQU $1
00000000  =00000001                 45  DUART_SRA_          EQU $1
00000000  =00000002                 46  DUART_CRA_          EQU $2
00000000  =00000003                 47  DUART_TXA_          EQU $3
00000000  =00000003                 48  DUART_RXA_          EQU $3
00000000  =00000004                 49  DUART_ACR_          EQU $4
00000000  =00000005                 50  DUART_IMR_          EQU $5
00000000  =00000008                 51  DUART_MRB_          EQU $8
00000000  =00000009                 52  DUART_CSRB_         EQU $9
00000000  =00000009                 53  DUART_SRB_          EQU $9
00000000  =0000000A                 54  DUART_CRB_          EQU $A
00000000  =0000000B                 55  DUART_TXB_          EQU $B
00000000  =0000000B                 56  DUART_RXB_          EQU $B
00000000  =0000000C                 57  DUART_IVR_          EQU $C
00000000  =0000000D                 58  DUART_OPCR_         EQU $D
00000000  =0000000E                 59  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 60  DUART_RESET_OPR_    EQU $F
00000000                            61  RRRR
00000000  =00D30001                 62  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 63  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 64  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 65  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 66  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 67  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            68  
00000000  =00D30011                 69  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 70  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 71  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 72  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 73  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 74  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            75  
00000000  =00D30009                 76  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 77  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 78  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 79  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 80  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 81  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            82  
00000000                            83  ; macros
00000000                            84  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            85  ; the input register is changed during the process
00000000                            86  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            87  BIN2HEX MACRO
00000000                            88    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            89    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            90    MOVE.B \1,\2
00000000                            91    ANDI.L #$F,\2
00000000                            92    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            93    ENDM
00000000                            94  
00000000                            95  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            96  ; the input register is changed during the process
00000000                            97  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            98  HEX2BIN MACRO
00000000                            99    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                           100    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                           101    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                           102    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                           103    ENDM
00000000                           104  
00000000                           105  ; send a single char to the serial port
00000000                           106  ; \1 = char to send, \2 = data register to use for status poll
00000000                           107  ; will stamp on D0 and D1 in debug mode
00000000                           108  PRINT_CHAR MACRO
00000000                           109  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           110      IFEQ DEBUG
00000000                           111        MOVE.B DUART_SRA,\2           ; read status register
00000000                           112        BTST #2,\2                    ; check for space to send
00000000                           113        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                           114        MOVE.B \1,DUART_TXA           ; send the next character
00000000                           115      ENDC
00000000                           116      
00000000                           117      IFNE DEBUG
00000000                           118        MOVE.B \1,D1
00000000                           119        MOVE.L #6,D0   
00000000                           120        TRAP #15                      ; write to terminal in simulator
00000000                           121      ENDC
00000000                           122  
00000000                           123      ENDM
00000000                           124  
00000000                           125  ; send CR,LF to the serial port
00000000                           126  ; \1 = data register to use for status poll
00000000                           127  PRINT_CRLF MACRO                  
00000000                           128      PRINT_CHAR #13,\1             ; CR
00000000                           129      PRINT_CHAR #10,\1             ; LF
00000000                           130      ENDM
00000000                           131  
00000000                           132  ; send C-style, zero terminated string to the serial port
00000000                           133  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           134  PRINT_STR MACRO
00000000                           135  LOOP\@
00000000                           136      CMP.B #0,(\1)                 ; 0 -> done
00000000                           137      BEQ EXIT\@
00000000                           138      PRINT_CHAR (\1)+,\2
00000000                           139      JMP LOOP\@
00000000                           140  EXIT\@
00000000                           141      ENDM
00000000                           142    
00000000                           143  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           144  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           145  PRINT_REG MACRO
00000000                           146      PRINT_CHAR #'0',\2          ;0x header
00000000                           147      PRINT_CHAR #'x',\2
00000000                           148      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           149  LOOP\@
00000000                           150      BIN2HEX \1,\3,\5
00000000                           151      PRINT_CHAR \3,\2
00000000                           152      DBEQ \4,LOOP\@
00000000                           153      ENDM
00000000                           154    
00000000                           155  ; wait for a char from the serial port
00000000                           156  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           157  ; will stamp on D0 and D1 in debug mode
00000000                           158  WAIT_CHAR MACRO
00000000                           159  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           160  
00000000                           161      IFEQ DEBUG
00000000                           162        MOVE.B DUART_SRA,\2         ; read status register
00000000                           163        BTST #0,\2                    ; check for character
00000000                           164        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           165      ENDC
00000000                           166      
00000000                           167      READ_CHAR \1
00000000                           168  
00000000                           169      IFEQ DEBUG
00000000                           170        PRINT_CHAR \1,\2            ; echo it back
00000000                           171      ENDC
00000000                           172      ENDM
00000000                           173      
00000000                           174  ; read a char from the serial port - assumes that there is one!
00000000                           175  ; \ 1= data register for read char
00000000                           176  ; will stamp on D0 and D1 in debug mode
00000000                           177  READ_CHAR MACRO
00000000                           178      IFEQ DEBUG
00000000                           179        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           180      ENDC
00000000                           181      IFNE DEBUG
00000000                           182        MOVE.L #5,D0    
00000000                           183        TRAP #15                    ; read from keyboard in simulator
00000000                           184        MOVE.L D1,\1
00000000                           185      ENDC
00000000                           186       
00000000                           187      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           188      BEQ START
00000000                           189      ENDM
00000000                           190      
00000000                           191      
00000000                           192  ; read data from the download serial port
00000000                           193  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           194  DOWNLOAD MACRO
00000000                           195  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           196  
00000000                           197      MOVE.B DUART_SRA,\2           ; check for command
00000000                           198      BTST #0,\2                    ; check for character
00000000                           199      BEQ CONTINUE\@                ; nothing, continue
00000000                           200   
00000000                           201      READ_CHAR \1
00000000                           202  CONTINUE\@
00000000                           203      MOVE.B DUART_SRB,\2         ; read status register
00000000                           204      BTST #0,\2                  ; check for character
00000000                           205      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           206      
00000000                           207      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           208      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           209      
00000000                           210      ENDM
00000000                           211  
00000000                           212  
00000000                           213  ; register catalogue
00000000                           214  ; D0 - used for simulator I/O
00000000                           215  ; D1 - used for simulator I/O
00000000                           216  ; D2 - read character
00000000                           217  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           218  ; D4 - count of S records read
00000000                           219  ; D5 - data to write / data read / byte count for S record load
00000000                           220  ; D6 - working register used in R/W and download
00000000                           221  ; D7 - address accumulator / reset by download
00000000                           222  ; A0 - address of string to print 
00000000                           223  
00000000                           224  ; start vector
00000000= 00000000                 225  STACK    DC.L $00000000              ; STACK
00000004= 00000008                 226  RESET    DC.L START                  ; RESET
00000008                           227      
00000008                           228  ; start of program  
00000008                           229  START
00000008  13FC 0000 00E00001       230      MOVE.B #0,DISPLAY
00000010                           231  
00000010                           232  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       233      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       234      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     235      NOP
00000022  13FC 0040 00D30005       236      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     237      NOP
0000002C  13FC 0030 00D30005       238      MOVE.B #$30,DUART_CRA
00000034  4E71                     239      NOP
00000036  13FC 0020 00D30005       240      MOVE.B #$20,DUART_CRA
0000003E  4E71                     241      NOP
00000040  13FC 0010 00D30005       242      MOVE.B #$10,DUART_CRA   
00000048                           243  
00000048  13FC 000A 00D30015       244      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       245      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     246      NOP
0000005A  13FC 0040 00D30015       247      MOVE.B #$40,DUART_CRB           
00000062  4E71                     248      NOP
00000064  13FC 0030 00D30015       249      MOVE.B #$30,DUART_CRB
0000006C  4E71                     250      NOP
0000006E  13FC 0020 00D30015       251      MOVE.B #$20,DUART_CRB
00000076  4E71                     252      NOP
00000078  13FC 0010 00D30015       253      MOVE.B #$10,DUART_CRB   
00000080                           254  
00000080                           255  ;initialise UART
00000080  13FC 0000 00D30009       256      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       257      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       258      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           259  
00000098                           260  ; channel A
00000098  13FC 0013 00D30001       261      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       262      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       263      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       264      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           265  
000000B8                           266  ; channel B
000000B8  13FC 0013 00D30011       267      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       268      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       269      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       270      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           271  
000000D8                           272m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           273m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      274m     IFEQ DEBUG
000000D8  1639 00D30003            275m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                276m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     277m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       278m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           279m     ENDC
000000EC                           280m     
000000EC                 FALSE     281m     IFNE DEBUG
000000EC                           282m     ENDC
000000EC                           283m 
000000EC                           284m     ENDM
000000EC                           285  
000000EC  13FC 0001 00E00001       286      MOVE.B #1,DISPLAY
000000F4                           287         
000000F4                           288m     PRINT_CRLF D3
000000F4                           289mm     PRINT_CHAR #13,D3             ; CR
000000F4                           290mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      291mm     IFEQ DEBUG
000000F4  1639 00D30003            292mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                293mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     294mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       295mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           296mm     ENDC
00000108                           297mm     
00000108                 FALSE     298mm     IFNE DEBUG
00000108                           299mm     ENDC
00000108                           300mm 
00000108                           301mm     ENDM
00000108                           302mm     PRINT_CHAR #10,D3             ; LF
00000108                           303mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      304mm     IFEQ DEBUG
00000108  1639 00D30003            305mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                306mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     307mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       308mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           309mm     ENDC
0000011C                           310mm     
0000011C                 FALSE     311mm     IFNE DEBUG
0000011C                           312mm     ENDC
0000011C                           313mm 
0000011C                           314mm     ENDM
0000011C                           315m     ENDM
0000011C                           316  
0000011C  41F9 000019AE            317      LEA VERSION,A0
00000122                           318m     PRINT_STR A0,D3
00000122                           319m LOOP_5
00000122  0C10 0000                320m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                321m     BEQ EXIT_5
0000012A                           322mm     PRINT_CHAR (A0)+,D3
0000012A                           323mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      324mm     IFEQ DEBUG
0000012A  1639 00D30003            325mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                326mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     327mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            328mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           329mm     ENDC
0000013C                           330mm     
0000013C                 FALSE     331mm     IFNE DEBUG
0000013C                           332mm     ENDC
0000013C                           333mm 
0000013C                           334mm     ENDM
0000013C  4EF8 0122                335m     JMP LOOP_5
00000140                           336m EXIT_5
00000140                           337m     ENDM
00000140                           338m     PRINT_CRLF D3
00000140                           339mm     PRINT_CHAR #13,D3             ; CR
00000140                           340mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      341mm     IFEQ DEBUG
00000140  1639 00D30003            342mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                343mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     344mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       345mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           346mm     ENDC
00000154                           347mm     
00000154                 FALSE     348mm     IFNE DEBUG
00000154                           349mm     ENDC
00000154                           350mm 
00000154                           351mm     ENDM
00000154                           352mm     PRINT_CHAR #10,D3             ; LF
00000154                           353mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      354mm     IFEQ DEBUG
00000154  1639 00D30003            355mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                356mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     357mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       358mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           359mm     ENDC
00000168                           360mm     
00000168                 FALSE     361mm     IFNE DEBUG
00000168                           362mm     ENDC
00000168                           363mm 
00000168                           364mm     ENDM
00000168                           365m     ENDM
00000168                           366m     PRINT_CHAR #7,D3
00000168                           367m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      368m     IFEQ DEBUG
00000168  1639 00D30003            369m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                370m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     371m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       372m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           373m     ENDC
0000017C                           374m     
0000017C                 FALSE     375m     IFNE DEBUG
0000017C                           376m     ENDC
0000017C                           377m 
0000017C                           378m     ENDM
0000017C                           379  
0000017C  7E00                     380      MOVE.L #0,D7                    ; address accumulator
0000017E                           381  
0000017E  13FC 0002 00E00001       382      MOVE.B #2,DISPLAY
00000186                           383  MAIN_LOOP
00000186                           384m     PRINT_CHAR #'>',D3               ; prompt
00000186                           385m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      386m     IFEQ DEBUG
00000186  1639 00D30003            387m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                388m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     389m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       390m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           391m     ENDC
0000019A                           392m     
0000019A                 FALSE     393m     IFNE DEBUG
0000019A                           394m     ENDC
0000019A                           395m 
0000019A                           396m     ENDM
0000019A                           397m     PRINT_CHAR #32,D3                ; space
0000019A                           398m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      399m     IFEQ DEBUG
0000019A  1639 00D30003            400m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                401m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     402m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       403m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           404m     ENDC
000001AE                           405m     
000001AE                 FALSE     406m     IFNE DEBUG
000001AE                           407m     ENDC
000001AE                           408m 
000001AE                           409m     ENDM
000001AE                           410      
000001AE                           411  GET_INPUT
000001AE                           412m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           413m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           414m 
000001AE                 TRUE      415m     IFEQ DEBUG
000001AE  1639 00D30003            416m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                417m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     418m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           419m     ENDC
000001BA                           420m     
000001BA                           421mm     READ_CHAR D2
000001BA                 TRUE      422mm     IFEQ DEBUG
000001BA  1439 00D30007            423mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           424mm     ENDC
000001C0                 FALSE     425mm     IFNE DEBUG
000001C0                           426mm     ENDC
000001C0                           427mm      
000001C0  B43C 001B                428mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                429mm     BEQ START
000001C8                           430mm     ENDM
000001C8                           431m 
000001C8                 TRUE      432m     IFEQ DEBUG
000001C8                           433mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           434mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      435mm     IFEQ DEBUG
000001C8  1639 00D30003            436mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                437mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     438mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            439mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           440mm     ENDC
000001DA                           441mm     
000001DA                 FALSE     442mm     IFNE DEBUG
000001DA                           443mm     ENDC
000001DA                           444mm 
000001DA                           445mm     ENDM
000001DA                           446m     ENDC
000001DA                           447m     ENDM
000001DA                           448      
000001DA  B43C 0030                449      CMP.B #'0',D2
000001DE  6700 17AE                450      BEQ HEX_DIGIT
000001E2  B43C 0031                451      CMP.B #'1',D2
000001E6  6700 17A6                452      BEQ HEX_DIGIT
000001EA  B43C 0032                453      CMP.B #'2',D2
000001EE  6700 179E                454      BEQ HEX_DIGIT
000001F2  B43C 0033                455      CMP.B #'3',D2
000001F6  6700 1796                456      BEQ HEX_DIGIT
000001FA  B43C 0034                457      CMP.B #'4',D2
000001FE  6700 178E                458      BEQ HEX_DIGIT
00000202  B43C 0035                459      CMP.B #'5',D2
00000206  6700 1786                460      BEQ HEX_DIGIT
0000020A  B43C 0036                461      CMP.B #'6',D2
0000020E  6700 177E                462      BEQ HEX_DIGIT
00000212  B43C 0037                463      CMP.B #'7',D2
00000216  6700 1776                464      BEQ HEX_DIGIT
0000021A  B43C 0038                465      CMP.B #'8',D2
0000021E  6700 176E                466      BEQ HEX_DIGIT
00000222  B43C 0039                467      CMP.B #'9',D2
00000226  6700 1766                468      BEQ HEX_DIGIT
0000022A  B43C 0041                469      CMP.B #'A',D2
0000022E  6700 175E                470      BEQ HEX_DIGIT
00000232  B43C 0042                471      CMP.B #'B',D2
00000236  6700 1756                472      BEQ HEX_DIGIT
0000023A  B43C 0043                473      CMP.B #'C',D2
0000023E  6700 174E                474      BEQ HEX_DIGIT
00000242  B43C 0044                475      CMP.B #'D',D2
00000246  6700 1746                476      BEQ HEX_DIGIT
0000024A  B43C 0045                477      CMP.B #'E',D2
0000024E  6700 173E                478      BEQ HEX_DIGIT
00000252  B43C 0046                479      CMP.B #'F',D2
00000256  6700 1736                480      BEQ HEX_DIGIT
0000025A                           481      
0000025A  B43C 0057                482      CMP.B #'W',D2
0000025E  6700 0168                483      BEQ W
00000262                           484      
00000262  B43C 004C                485      CMP.B #'L',D2
00000266  6700 15C2                486      BEQ L 
0000026A                           487  
0000026A                           488m     PRINT_CRLF D3
0000026A                           489mm     PRINT_CHAR #13,D3             ; CR
0000026A                           490mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      491mm     IFEQ DEBUG
0000026A  1639 00D30003            492mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000270  0803 0002                493mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000274  67F4                     494mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
00000276  13FC 000D 00D30007       495mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000027E                           496mm     ENDC
0000027E                           497mm     
0000027E                 FALSE     498mm     IFNE DEBUG
0000027E                           499mm     ENDC
0000027E                           500mm 
0000027E                           501mm     ENDM
0000027E                           502mm     PRINT_CHAR #10,D3             ; LF
0000027E                           503mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027E                 TRUE      504mm     IFEQ DEBUG
0000027E  1639 00D30003            505mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000284  0803 0002                506mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000288  67F4                     507mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
0000028A  13FC 000A 00D30007       508mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000292                           509mm     ENDC
00000292                           510mm     
00000292                 FALSE     511mm     IFNE DEBUG
00000292                           512mm     ENDC
00000292                           513mm 
00000292                           514mm     ENDM
00000292                           515m     ENDM
00000292                           516   
00000292  B43C 003F                517      CMP.B #'?',D2
00000296  6700 005A                518      BEQ H
0000029A                           519  
0000029A  B43C 0056                520      CMP.B #'V',D2
0000029E  6700 007A                521      BEQ V
000002A2                           522      
000002A2  B43C 0052                523      CMP.B #'R',D2
000002A6  6700 009A                524      BEQ R
000002AA                           525  
000002AA  B43C 0053                526      CMP.B #'S',D2
000002AE  6700 01DE                527      BEQ S
000002B2                           528  
000002B2  B43C 0047                529      CMP.B #'G',D2
000002B6  6700 1462                530      BEQ G   
000002BA                           531  
000002BA  B43C 005A                532      CMP.B #'Z',D2
000002BE  6700 1462                533      BEQ Z   
000002C2                           534  
000002C2  B43C 0058                535      CMP.B #'X',D2
000002C6  6700 16BE                536      BEQ X
000002CA                           537  
000002CA  41F9 00001A71            538      LEA HUH,A0
000002D0                           539m     PRINT_STR A0,D3
000002D0                           540m LOOP_19
000002D0  0C10 0000                541m     CMP.B #0,(A0)                 ; 0 -> DONE
000002D4  6700 0018                542m     BEQ EXIT_19
000002D8                           543mm     PRINT_CHAR (A0)+,D3
000002D8                           544mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D8                 TRUE      545mm     IFEQ DEBUG
000002D8  1639 00D30003            546mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002DE  0803 0002                547mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002E2  67F4                     548mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002E4  13D8 00D30007            549mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002EA                           550mm     ENDC
000002EA                           551mm     
000002EA                 FALSE     552mm     IFNE DEBUG
000002EA                           553mm     ENDC
000002EA                           554mm 
000002EA                           555mm     ENDM
000002EA  4EF8 02D0                556m     JMP LOOP_19
000002EE                           557m EXIT_19
000002EE                           558m     ENDM
000002EE                           559                         
000002EE  4EF8 0186                560      JMP MAIN_LOOP
000002F2                           561      
000002F2                           562  ; commands
000002F2  41F9 000019CB            563  H   LEA HELP,A0
000002F8                           564m     PRINT_STR A0,D3
000002F8                           565m LOOP_21
000002F8  0C10 0000                566m     CMP.B #0,(A0)                 ; 0 -> DONE
000002FC  6700 0018                567m     BEQ EXIT_21
00000300                           568mm     PRINT_CHAR (A0)+,D3
00000300                           569mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000300                 TRUE      570mm     IFEQ DEBUG
00000300  1639 00D30003            571mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000306  0803 0002                572mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000030A  67F4                     573mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
0000030C  13D8 00D30007            574mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000312                           575mm     ENDC
00000312                           576mm     
00000312                 FALSE     577mm     IFNE DEBUG
00000312                           578mm     ENDC
00000312                           579mm 
00000312                           580mm     ENDM
00000312  4EF8 02F8                581m     JMP LOOP_21
00000316                           582m EXIT_21
00000316                           583m     ENDM
00000316  4EF8 0186                584      JMP MAIN_LOOP
0000031A                           585  
0000031A  41F9 000019AE            586  V   LEA VERSION,A0
00000320                           587m     PRINT_STR A0,D3       
00000320                           588m LOOP_23
00000320  0C10 0000                589m     CMP.B #0,(A0)                 ; 0 -> DONE
00000324  6700 0018                590m     BEQ EXIT_23
00000328                           591mm     PRINT_CHAR (A0)+,D3
00000328                           592mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      593mm     IFEQ DEBUG
00000328  1639 00D30003            594mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000032E  0803 0002                595mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000332  67F4                     596mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
00000334  13D8 00D30007            597mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000033A                           598mm     ENDC
0000033A                           599mm     
0000033A                 FALSE     600mm     IFNE DEBUG
0000033A                           601mm     ENDC
0000033A                           602mm 
0000033A                           603mm     ENDM
0000033A  4EF8 0320                604m     JMP LOOP_23
0000033E                           605m EXIT_23
0000033E                           606m     ENDM
0000033E  4EF8 0186                607      JMP MAIN_LOOP
00000342                           608      
00000342                           609  R   
00000342  2047                     610      MOVE.L D7,A0                    ; address accumulator -> address register
00000344  2A10                     611      MOVE.L (A0),D5                  ; read the memory and print it
00000346                           612m     PRINT_REG D5,D3,D7,D6,A0
00000346                           613mm     PRINT_CHAR #'0',D3          ;0X HEADER
00000346                           614mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000346                 TRUE      615mm     IFEQ DEBUG
00000346  1639 00D30003            616mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000034C  0803 0002                617mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000350  67F4                     618mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
00000352  13FC 0030 00D30007       619mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
0000035A                           620mm     ENDC
0000035A                           621mm     
0000035A                 FALSE     622mm     IFNE DEBUG
0000035A                           623mm     ENDC
0000035A                           624mm 
0000035A                           625mm     ENDM
0000035A                           626mm     PRINT_CHAR #'x',D3
0000035A                           627mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000035A                 TRUE      628mm     IFEQ DEBUG
0000035A  1639 00D30003            629mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000360  0803 0002                630mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000364  67F4                     631mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
00000366  13FC 0078 00D30007       632mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0000036E                           633mm     ENDC
0000036E                           634mm     
0000036E                 FALSE     635mm     IFNE DEBUG
0000036E                           636mm     ENDC
0000036E                           637mm 
0000036E                           638mm     ENDM
0000036E  7C07                     639m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000370                           640m LOOP_25
00000370                           641mm     BIN2HEX D5,D7,A0
00000370  41F9 00001B0E            642mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000376  E99D                     643mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000378  1E05                     644mm   MOVE.B D5,D7
0000037A  0287 0000000F            645mm   ANDI.L #$F,D7
00000380  1E30 7000                646mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000384                           647mm   ENDM
00000384                           648mm     PRINT_CHAR D7,D3
00000384                           649mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000384                 TRUE      650mm     IFEQ DEBUG
00000384  1639 00D30003            651mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000038A  0803 0002                652mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000038E  67F4                     653mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000390  13C7 00D30007            654mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000396                           655mm     ENDC
00000396                           656mm     
00000396                 FALSE     657mm     IFNE DEBUG
00000396                           658mm     ENDC
00000396                           659mm 
00000396                           660mm     ENDM
00000396  57CE FFD8                661m     DBEQ D6,LOOP_25
0000039A                           662m     ENDM
0000039A                           663m     PRINT_CRLF D3
0000039A                           664mm     PRINT_CHAR #13,D3             ; CR
0000039A                           665mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039A                 TRUE      666mm     IFEQ DEBUG
0000039A  1639 00D30003            667mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003A0  0803 0002                668mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003A4  67F4                     669mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
000003A6  13FC 000D 00D30007       670mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000003AE                           671mm     ENDC
000003AE                           672mm     
000003AE                 FALSE     673mm     IFNE DEBUG
000003AE                           674mm     ENDC
000003AE                           675mm 
000003AE                           676mm     ENDM
000003AE                           677mm     PRINT_CHAR #10,D3             ; LF
000003AE                           678mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AE                 TRUE      679mm     IFEQ DEBUG
000003AE  1639 00D30003            680mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003B4  0803 0002                681mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003B8  67F4                     682mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
000003BA  13FC 000A 00D30007       683mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000003C2                           684mm     ENDC
000003C2                           685mm     
000003C2                 FALSE     686mm     IFNE DEBUG
000003C2                           687mm     ENDC
000003C2                           688mm 
000003C2                           689mm     ENDM
000003C2                           690m     ENDM
000003C2  7E00                     691      MOVE.L #0,D7                    ; clear the now used address accumulator
000003C4  4EF8 0186                692      JMP MAIN_LOOP
000003C8                           693  
000003C8  7A00                     694  W   MOVE.L #0,D5                    ; D5 will be the value to write            
000003CA                           695  
000003CA                           696m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
000003CA                           697m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003CA                           698m 
000003CA                 TRUE      699m     IFEQ DEBUG
000003CA  1639 00D30003            700m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003D0  0803 0000                701m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003D4  67F4                     702m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
000003D6                           703m     ENDC
000003D6                           704m     
000003D6                           705mm     READ_CHAR D2
000003D6                 TRUE      706mm     IFEQ DEBUG
000003D6  1439 00D30007            707mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003DC                           708mm     ENDC
000003DC                 FALSE     709mm     IFNE DEBUG
000003DC                           710mm     ENDC
000003DC                           711mm      
000003DC  B43C 001B                712mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003E0  6700 FC26                713mm     BEQ START
000003E4                           714mm     ENDM
000003E4                           715m 
000003E4                 TRUE      716m     IFEQ DEBUG
000003E4                           717mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003E4                           718mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E4                 TRUE      719mm     IFEQ DEBUG
000003E4  1639 00D30003            720mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003EA  0803 0002                721mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003EE  67F4                     722mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
000003F0  13C2 00D30007            723mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003F6                           724mm     ENDC
000003F6                           725mm     
000003F6                 FALSE     726mm     IFNE DEBUG
000003F6                           727mm     ENDC
000003F6                           728mm 
000003F6                           729mm     ENDM
000003F6                           730m     ENDC
000003F6                           731m     ENDM
000003F6                           732m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003F6  41F9 00001B1E            733m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003FC  0402 0030                734m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000400  C4BC 000000FF            735m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000406  1430 2000                736m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000040A                           737m   ENDM
0000040A  1A02                     738      MOVE.B D2,D5                    ; put at bottom of D5
0000040C                           739  
0000040C  3C3C 0006                740      MOVE #6,D6                      ; 7 bytes left to read
00000410                           741      
00000410                           742  READ_DATA_TO_POKE
00000410  E98D                     743      LSL.L #4,D5                     ; make what we have so far more significant
00000412                           744m     WAIT_CHAR D2,D3                 ; next character -> D2
00000412                           745m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000412                           746m 
00000412                 TRUE      747m     IFEQ DEBUG
00000412  1639 00D30003            748m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000418  0803 0000                749m       BTST #0,D3                    ; CHECK FOR CHARACTER
0000041C  67F4                     750m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
0000041E                           751m     ENDC
0000041E                           752m     
0000041E                           753mm     READ_CHAR D2
0000041E                 TRUE      754mm     IFEQ DEBUG
0000041E  1439 00D30007            755mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000424                           756mm     ENDC
00000424                 FALSE     757mm     IFNE DEBUG
00000424                           758mm     ENDC
00000424                           759mm      
00000424  B43C 001B                760mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000428  6700 FBDE                761mm     BEQ START
0000042C                           762mm     ENDM
0000042C                           763m 
0000042C                 TRUE      764m     IFEQ DEBUG
0000042C                           765mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0000042C                           766mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042C                 TRUE      767mm     IFEQ DEBUG
0000042C  1639 00D30003            768mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000432  0803 0002                769mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000436  67F4                     770mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00000438  13C2 00D30007            771mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000043E                           772mm     ENDC
0000043E                           773mm     
0000043E                 FALSE     774mm     IFNE DEBUG
0000043E                           775mm     ENDC
0000043E                           776mm 
0000043E                           777mm     ENDM
0000043E                           778m     ENDC
0000043E                           779m     ENDM
0000043E                           780m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
0000043E  41F9 00001B1E            781m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000444  0402 0030                782m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000448  C4BC 000000FF            783m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000044E  1430 2000                784m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000452                           785m   ENDM
00000452  8A02                     786      OR.B D2,D5
00000454  023C 00FB                787      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000458  57CE FFB6                788      DBEQ D6,READ_DATA_TO_POKE
0000045C                           789      
0000045C  2047                     790      MOVE.L D7,A0                    ; address accumulator -> address register
0000045E  7E00                     791      MOVE.L #0,D7                    ; clear the now used address accumulator
00000460                           792      
00000460  2085                     793      MOVE.L D5,(A0)                  ; write the data
00000462                           794  
00000462                           795m     PRINT_CRLF D3
00000462                           796mm     PRINT_CHAR #13,D3             ; CR
00000462                           797mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000462                 TRUE      798mm     IFEQ DEBUG
00000462  1639 00D30003            799mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000468  0803 0002                800mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000046C  67F4                     801mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
0000046E  13FC 000D 00D30007       802mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000476                           803mm     ENDC
00000476                           804mm     
00000476                 FALSE     805mm     IFNE DEBUG
00000476                           806mm     ENDC
00000476                           807mm 
00000476                           808mm     ENDM
00000476                           809mm     PRINT_CHAR #10,D3             ; LF
00000476                           810mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000476                 TRUE      811mm     IFEQ DEBUG
00000476  1639 00D30003            812mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000047C  0803 0002                813mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000480  67F4                     814mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
00000482  13FC 000A 00D30007       815mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000048A                           816mm     ENDC
0000048A                           817mm     
0000048A                 FALSE     818mm     IFNE DEBUG
0000048A                           819mm     ENDC
0000048A                           820mm 
0000048A                           821mm     ENDM
0000048A                           822m     ENDM
0000048A  4EF8 0186                823      JMP MAIN_LOOP
0000048E                           824  
0000048E                           825  
0000048E  2647                     826  S   MOVE.L D7,A3                    ; grab the address accumulator
00000490  7800                     827      MOVE.L #0,D4                    ; count of records read -> D4
00000492  2478 0000                828      MOVE.L 0,A2                     ; start address -> A2
00000496                           829      
00000496                           830  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
00000496                           831m     DOWNLOAD D2,D3                  
00000496                           832m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000496                           833m 
00000496  1639 00D30003            834m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000049C  0803 0000                835m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004A0  6700 0010                836m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
000004A4                           837m  
000004A4                           838mm     READ_CHAR D2
000004A4                 TRUE      839mm     IFEQ DEBUG
000004A4  1439 00D30007            840mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000004AA                           841mm     ENDC
000004AA                 FALSE     842mm     IFNE DEBUG
000004AA                           843mm     ENDC
000004AA                           844mm      
000004AA  B43C 001B                845mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000004AE  6700 FB58                846mm     BEQ START
000004B2                           847mm     ENDM
000004B2                           848m CONTINUE_44
000004B2  1639 00D30013            849m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004B8  0803 0000                850m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004BC  67D8                     851m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004BE                           852m     
000004BE  1439 00D30017            853m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004C4  13C2 00E00001            854m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004CA                           855m     
000004CA                           856m     ENDM
000004CA  B43C 0053                857      CMP.B #'S',D2                   ; found S?    
000004CE  66C6                     858      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
000004D0                           859      
000004D0  5284                     860      ADD.L #1,D4                     ; read another S record, increment count
000004D2                           861      
000004D2                           862m     DOWNLOAD D7,D3                  ; read the record digit
000004D2                           863m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                           864m 
000004D2  1639 00D30003            865m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004D8  0803 0000                866m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004DC  6700 0010                867m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004E0                           868m  
000004E0                           869mm     READ_CHAR D7
000004E0                 TRUE      870mm     IFEQ DEBUG
000004E0  1E39 00D30007            871mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
000004E6                           872mm     ENDC
000004E6                 FALSE     873mm     IFNE DEBUG
000004E6                           874mm     ENDC
000004E6                           875mm      
000004E6  BE3C 001B                876mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
000004EA  6700 FB1C                877mm     BEQ START
000004EE                           878mm     ENDM
000004EE                           879m CONTINUE_46
000004EE  1639 00D30013            880m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004F4  0803 0000                881m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004F8  67D8                     882m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
000004FA                           883m     
000004FA  1E39 00D30017            884m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
00000500  13C7 00E00001            885m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
00000506                           886m     
00000506                           887m     ENDM
00000506                           888  
00000506  7C00                     889      MOVE.L #0,D6                    ; checksum
00000508                           890  
00000508  7A00                     891      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
0000050A                           892m     DOWNLOAD D2,D3              
0000050A                           893m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                           894m 
0000050A  1639 00D30003            895m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000510  0803 0000                896m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000514  6700 0010                897m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
00000518                           898m  
00000518                           899mm     READ_CHAR D2
00000518                 TRUE      900mm     IFEQ DEBUG
00000518  1439 00D30007            901mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000051E                           902mm     ENDC
0000051E                 FALSE     903mm     IFNE DEBUG
0000051E                           904mm     ENDC
0000051E                           905mm      
0000051E  B43C 001B                906mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000522  6700 FAE4                907mm     BEQ START
00000526                           908mm     ENDM
00000526                           909m CONTINUE_48
00000526  1639 00D30013            910m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000052C  0803 0000                911m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000530  67D8                     912m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00000532                           913m     
00000532  1439 00D30017            914m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000538  13C2 00E00001            915m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000053E                           916m     
0000053E                           917m     ENDM
0000053E                           918m     HEX2BIN D2,D2,A0
0000053E  41F9 00001B1E            919m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000544  0402 0030                920m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000548  C4BC 000000FF            921m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000054E  1430 2000                922m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000552                           923m   ENDM
00000552  8A82                     924      OR.L D2,D5
00000554  E98D                     925      LSL.L #4,D5    
00000556                           926m     DOWNLOAD D2,D3
00000556                           927m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000556                           928m 
00000556  1639 00D30003            929m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000055C  0803 0000                930m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000560  6700 0010                931m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
00000564                           932m  
00000564                           933mm     READ_CHAR D2
00000564                 TRUE      934mm     IFEQ DEBUG
00000564  1439 00D30007            935mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000056A                           936mm     ENDC
0000056A                 FALSE     937mm     IFNE DEBUG
0000056A                           938mm     ENDC
0000056A                           939mm      
0000056A  B43C 001B                940mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000056E  6700 FA98                941mm     BEQ START
00000572                           942mm     ENDM
00000572                           943m CONTINUE_51
00000572  1639 00D30013            944m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000578  0803 0000                945m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000057C  67D8                     946m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
0000057E                           947m     
0000057E  1439 00D30017            948m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000584  13C2 00E00001            949m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000058A                           950m     
0000058A                           951m     ENDM
0000058A                           952m     HEX2BIN D2,D2,A0  
0000058A  41F9 00001B1E            953m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000590  0402 0030                954m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000594  C4BC 000000FF            955m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000059A  1430 2000                956m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000059E                           957m   ENDM
0000059E  8A82                     958      OR.L D2,D5
000005A0                           959                  
000005A0  DC85                     960      ADD.L D5,D6                     ; add byte count into checksum
000005A2                           961  
000005A2                           962      IF.B D7 <EQ> #'0' THEN.L        ; header
000005A2  BE3C 0030                963s     CMP.B   #'0',D7
000005A6  6600 0228                964s     BNE.L   _00000000
000005AA  7E00                     965          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
000005AC                           966m         DOWNLOAD D2,D3              ; top byte
000005AC                           967m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005AC                           968m 
000005AC  1639 00D30003            969m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005B2  0803 0000                970m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005B6  6700 0010                971m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
000005BA                           972m  
000005BA                           973mm     READ_CHAR D2
000005BA                 TRUE      974mm     IFEQ DEBUG
000005BA  1439 00D30007            975mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005C0                           976mm     ENDC
000005C0                 FALSE     977mm     IFNE DEBUG
000005C0                           978mm     ENDC
000005C0                           979mm      
000005C0  B43C 001B                980mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005C4  6700 FA42                981mm     BEQ START
000005C8                           982mm     ENDM
000005C8                           983m CONTINUE_54
000005C8  1639 00D30013            984m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005CE  0803 0000                985m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005D2  67D8                     986m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
000005D4                           987m     
000005D4  1439 00D30017            988m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005DA  13C2 00E00001            989m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005E0                           990m     
000005E0                           991m     ENDM
000005E0                           992m         HEX2BIN D2,D2,A0
000005E0  41F9 00001B1E            993m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005E6  0402 0030                994m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005EA  C4BC 000000FF            995m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005F0  1430 2000                996m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005F4                           997m   ENDM
000005F4  8E82                     998          OR.L D2,D7
000005F6  E98F                     999          LSL.L #4,D7
000005F8                          1000m         DOWNLOAD D2,D3         
000005F8                          1001m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F8                          1002m 
000005F8  1639 00D30003           1003m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005FE  0803 0000               1004m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000602  6700 0010               1005m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
00000606                          1006m  
00000606                          1007mm     READ_CHAR D2
00000606                 TRUE     1008mm     IFEQ DEBUG
00000606  1439 00D30007           1009mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000060C                          1010mm     ENDC
0000060C                 FALSE    1011mm     IFNE DEBUG
0000060C                          1012mm     ENDC
0000060C                          1013mm      
0000060C  B43C 001B               1014mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000610  6700 F9F6               1015mm     BEQ START
00000614                          1016mm     ENDM
00000614                          1017m CONTINUE_57
00000614  1639 00D30013           1018m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000061A  0803 0000               1019m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000061E  67D8                    1020m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
00000620                          1021m     
00000620  1439 00D30017           1022m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000626  13C2 00E00001           1023m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000062C                          1024m     
0000062C                          1025m     ENDM
0000062C                          1026m         HEX2BIN D2,D2,A0
0000062C  41F9 00001B1E           1027m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000632  0402 0030               1028m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000636  C4BC 000000FF           1029m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000063C  1430 2000               1030m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000640                          1031m   ENDM
00000640  8E82                    1032          OR.L D2,D7
00000642                          1033          
00000642  DC87                    1034          ADD.L D7,D6                 ; add top byte of address into checksum
00000644                          1035  
00000644  E98F                    1036          LSL.L #4,D7                 ; bottom byte
00000646                          1037m         DOWNLOAD D2,D3
00000646                          1038m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000646                          1039m 
00000646  1639 00D30003           1040m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000064C  0803 0000               1041m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000650  6700 0010               1042m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
00000654                          1043m  
00000654                          1044mm     READ_CHAR D2
00000654                 TRUE     1045mm     IFEQ DEBUG
00000654  1439 00D30007           1046mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000065A                          1047mm     ENDC
0000065A                 FALSE    1048mm     IFNE DEBUG
0000065A                          1049mm     ENDC
0000065A                          1050mm      
0000065A  B43C 001B               1051mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000065E  6700 F9A8               1052mm     BEQ START
00000662                          1053mm     ENDM
00000662                          1054m CONTINUE_60
00000662  1639 00D30013           1055m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000668  0803 0000               1056m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000066C  67D8                    1057m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
0000066E                          1058m     
0000066E  1439 00D30017           1059m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000674  13C2 00E00001           1060m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000067A                          1061m     
0000067A                          1062m     ENDM
0000067A                          1063m         HEX2BIN D2,D2,A0
0000067A  41F9 00001B1E           1064m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000680  0402 0030               1065m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000684  C4BC 000000FF           1066m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000068A  1430 2000               1067m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000068E                          1068m   ENDM
0000068E  8E82                    1069          OR.L D2,D7
00000690  E98F                    1070          LSL.L #4,D7        
00000692                          1071m         DOWNLOAD D2,D3
00000692                          1072m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000692                          1073m 
00000692  1639 00D30003           1074m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000698  0803 0000               1075m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000069C  6700 0010               1076m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
000006A0                          1077m  
000006A0                          1078mm     READ_CHAR D2
000006A0                 TRUE     1079mm     IFEQ DEBUG
000006A0  1439 00D30007           1080mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006A6                          1081mm     ENDC
000006A6                 FALSE    1082mm     IFNE DEBUG
000006A6                          1083mm     ENDC
000006A6                          1084mm      
000006A6  B43C 001B               1085mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006AA  6700 F95C               1086mm     BEQ START
000006AE                          1087mm     ENDM
000006AE                          1088m CONTINUE_63
000006AE  1639 00D30013           1089m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006B4  0803 0000               1090m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006B8  67D8                    1091m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
000006BA                          1092m     
000006BA  1439 00D30017           1093m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006C0  13C2 00E00001           1094m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006C6                          1095m     
000006C6                          1096m     ENDM
000006C6                          1097m         HEX2BIN D2,D2,A0
000006C6  41F9 00001B1E           1098m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000006CC  0402 0030               1099m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006D0  C4BC 000000FF           1100m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000006D6  1430 2000               1101m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006DA                          1102m   ENDM
000006DA  8E82                    1103          OR.L D2,D7
000006DC                          1104          
000006DC  7400                    1105          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
000006DE  1407                    1106          MOVE.B D7,D2
000006E0  DC82                    1107          ADD.L D2,D6
000006E2                          1108          
000006E2  5785                    1109          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006E4                          1110          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006E4                          1111s _10000000
000006E4  BABC 00000000           1112s     CMP.L   #0,D5
000006EA  6F00 00B4               1113s     BLE _10000001
000006EE  5385                    1114            SUB.L #1,D5
000006F0                          1115              
000006F0  7E00                    1116            MOVE.L #0,D7              ; D7 holds the byte
000006F2                          1117              
000006F2                          1118m           DOWNLOAD D2,D3            ; MS 4 bits
000006F2                          1119m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F2                          1120m 
000006F2  1639 00D30003           1121m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006F8  0803 0000               1122m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006FC  6700 0010               1123m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
00000700                          1124m  
00000700                          1125mm     READ_CHAR D2
00000700                 TRUE     1126mm     IFEQ DEBUG
00000700  1439 00D30007           1127mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000706                          1128mm     ENDC
00000706                 FALSE    1129mm     IFNE DEBUG
00000706                          1130mm     ENDC
00000706                          1131mm      
00000706  B43C 001B               1132mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000070A  6700 F8FC               1133mm     BEQ START
0000070E                          1134mm     ENDM
0000070E                          1135m CONTINUE_66
0000070E  1639 00D30013           1136m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000714  0803 0000               1137m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000718  67D8                    1138m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
0000071A                          1139m     
0000071A  1439 00D30017           1140m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000720  13C2 00E00001           1141m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000726                          1142m     
00000726                          1143m     ENDM
00000726                          1144m           HEX2BIN D2,D2,A0
00000726  41F9 00001B1E           1145m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000072C  0402 0030               1146m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000730  C4BC 000000FF           1147m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000736  1430 2000               1148m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000073A                          1149m   ENDM
0000073A  8E82                    1150            OR.L D2,D7
0000073C  E98F                    1151            LSL.L #4,D7
0000073E                          1152               
0000073E                          1153m           DOWNLOAD D2,D3            ; LS 4 bits    
0000073E                          1154m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000073E                          1155m 
0000073E  1639 00D30003           1156m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000744  0803 0000               1157m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000748  6700 0010               1158m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
0000074C                          1159m  
0000074C                          1160mm     READ_CHAR D2
0000074C                 TRUE     1161mm     IFEQ DEBUG
0000074C  1439 00D30007           1162mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000752                          1163mm     ENDC
00000752                 FALSE    1164mm     IFNE DEBUG
00000752                          1165mm     ENDC
00000752                          1166mm      
00000752  B43C 001B               1167mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000756  6700 F8B0               1168mm     BEQ START
0000075A                          1169mm     ENDM
0000075A                          1170m CONTINUE_69
0000075A  1639 00D30013           1171m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000760  0803 0000               1172m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000764  67D8                    1173m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
00000766                          1174m     
00000766  1439 00D30017           1175m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000076C  13C2 00E00001           1176m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000772                          1177m     
00000772                          1178m     ENDM
00000772                          1179m           HEX2BIN D2,D2,A0
00000772  41F9 00001B1E           1180m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000778  0402 0030               1181m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000077C  C4BC 000000FF           1182m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000782  1430 2000               1183m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000786                          1184m   ENDM
00000786  8E82                    1185            OR.L D2,D7
00000788                          1186              
00000788  DC87                    1187            ADD.L D7,D6               ; add into checksum
0000078A                          1188            
0000078A                          1189m           PRINT_CHAR D7,D3          ; assume ASCII and print it
0000078A                          1190m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078A                 TRUE     1191m     IFEQ DEBUG
0000078A  1639 00D30003           1192m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000790  0803 0002               1193m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000794  67F4                    1194m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
00000796  13C7 00D30007           1195m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000079C                          1196m     ENDC
0000079C                          1197m     
0000079C                 FALSE    1198m     IFNE DEBUG
0000079C                          1199m     ENDC
0000079C                          1200m 
0000079C                          1201m     ENDM
0000079C                          1202          ENDW
0000079C  6000 FF46               1203s     BRA _10000000
000007A0                          1204s _10000001
000007A0                          1205m         PRINT_CRLF D3
000007A0                          1206mm     PRINT_CHAR #13,D3             ; CR
000007A0                          1207mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A0                 TRUE     1208mm     IFEQ DEBUG
000007A0  1639 00D30003           1209mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007A6  0803 0002               1210mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007AA  67F4                    1211mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
000007AC  13FC 000D 00D30007      1212mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000007B4                          1213mm     ENDC
000007B4                          1214mm     
000007B4                 FALSE    1215mm     IFNE DEBUG
000007B4                          1216mm     ENDC
000007B4                          1217mm 
000007B4                          1218mm     ENDM
000007B4                          1219mm     PRINT_CHAR #10,D3             ; LF
000007B4                          1220mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007B4                 TRUE     1221mm     IFEQ DEBUG
000007B4  1639 00D30003           1222mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007BA  0803 0002               1223mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007BE  67F4                    1224mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
000007C0  13FC 000A 00D30007      1225mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000007C8                          1226mm     ENDC
000007C8                          1227mm     
000007C8                 FALSE    1228mm     IFNE DEBUG
000007C8                          1229mm     ENDC
000007C8                          1230mm 
000007C8                          1231mm     ENDM
000007C8                          1232m     ENDM
000007C8  43F8 0496               1233         LEA WAIT_FOR_SRECORD,A1            
000007CC                          1234      ELSE
000007CC  6000 0D06               1235s     BRA _00000001
000007D0                          1236s _00000000
000007D0                          1237        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit address data record
000007D0  BE3C 0031               1238s     CMP.B   #'1',D7
000007D4  6600 04F4               1239s     BNE.L   _00000002
000007D8  7E00                    1240          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007DA                          1241m         DOWNLOAD D2,D3              ; top byte
000007DA                          1242m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DA                          1243m 
000007DA  1639 00D30003           1244m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007E0  0803 0000               1245m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007E4  6700 0010               1246m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
000007E8                          1247m  
000007E8                          1248mm     READ_CHAR D2
000007E8                 TRUE     1249mm     IFEQ DEBUG
000007E8  1439 00D30007           1250mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007EE                          1251mm     ENDC
000007EE                 FALSE    1252mm     IFNE DEBUG
000007EE                          1253mm     ENDC
000007EE                          1254mm      
000007EE  B43C 001B               1255mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007F2  6700 F814               1256mm     BEQ START
000007F6                          1257mm     ENDM
000007F6                          1258m CONTINUE_76
000007F6  1639 00D30013           1259m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007FC  0803 0000               1260m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000800  67D8                    1261m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
00000802                          1262m     
00000802  1439 00D30017           1263m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000808  13C2 00E00001           1264m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000080E                          1265m     
0000080E                          1266m     ENDM
0000080E                          1267m         PRINT_CHAR D2,D3
0000080E                          1268m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080E                 TRUE     1269m     IFEQ DEBUG
0000080E  1639 00D30003           1270m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000814  0803 0002               1271m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000818  67F4                    1272m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
0000081A  13C2 00D30007           1273m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000820                          1274m     ENDC
00000820                          1275m     
00000820                 FALSE    1276m     IFNE DEBUG
00000820                          1277m     ENDC
00000820                          1278m 
00000820                          1279m     ENDM
00000820                          1280m         HEX2BIN D2,D2,A0
00000820  41F9 00001B1E           1281m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000826  0402 0030               1282m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000082A  C4BC 000000FF           1283m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000830  1430 2000               1284m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000834                          1285m   ENDM
00000834  8E82                    1286          OR.L D2,D7
00000836  E98F                    1287          LSL.L #4,D7
00000838                          1288m         DOWNLOAD D2,D3         
00000838                          1289m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000838                          1290m 
00000838  1639 00D30003           1291m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000083E  0803 0000               1292m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000842  6700 0010               1293m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
00000846                          1294m  
00000846                          1295mm     READ_CHAR D2
00000846                 TRUE     1296mm     IFEQ DEBUG
00000846  1439 00D30007           1297mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000084C                          1298mm     ENDC
0000084C                 FALSE    1299mm     IFNE DEBUG
0000084C                          1300mm     ENDC
0000084C                          1301mm      
0000084C  B43C 001B               1302mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000850  6700 F7B6               1303mm     BEQ START
00000854                          1304mm     ENDM
00000854                          1305m CONTINUE_80
00000854  1639 00D30013           1306m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000085A  0803 0000               1307m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000085E  67D8                    1308m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
00000860                          1309m     
00000860  1439 00D30017           1310m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000866  13C2 00E00001           1311m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000086C                          1312m     
0000086C                          1313m     ENDM
0000086C                          1314m         PRINT_CHAR D2,D3
0000086C                          1315m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000086C                 TRUE     1316m     IFEQ DEBUG
0000086C  1639 00D30003           1317m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000872  0803 0002               1318m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000876  67F4                    1319m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
00000878  13C2 00D30007           1320m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000087E                          1321m     ENDC
0000087E                          1322m     
0000087E                 FALSE    1323m     IFNE DEBUG
0000087E                          1324m     ENDC
0000087E                          1325m 
0000087E                          1326m     ENDM
0000087E                          1327m         HEX2BIN D2,D2,A0
0000087E  41F9 00001B1E           1328m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000884  0402 0030               1329m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000888  C4BC 000000FF           1330m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000088E  1430 2000               1331m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000892                          1332m   ENDM
00000892  8E82                    1333          OR.L D2,D7
00000894                          1334          
00000894  DC87                    1335          ADD.L D7,D6                 ; add top byte of address into checksum
00000896                          1336  
00000896  E98F                    1337          LSL.L #4,D7                 ; bottom byte
00000898                          1338m         DOWNLOAD D2,D3
00000898                          1339m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000898                          1340m 
00000898  1639 00D30003           1341m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000089E  0803 0000               1342m     BTST #0,D3                    ; CHECK FOR CHARACTER
000008A2  6700 0010               1343m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
000008A6                          1344m  
000008A6                          1345mm     READ_CHAR D2
000008A6                 TRUE     1346mm     IFEQ DEBUG
000008A6  1439 00D30007           1347mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000008AC                          1348mm     ENDC
000008AC                 FALSE    1349mm     IFNE DEBUG
000008AC                          1350mm     ENDC
000008AC                          1351mm      
000008AC  B43C 001B               1352mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008B0  6700 F756               1353mm     BEQ START
000008B4                          1354mm     ENDM
000008B4                          1355m CONTINUE_84
000008B4  1639 00D30013           1356m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008BA  0803 0000               1357m     BTST #0,D3                  ; CHECK FOR CHARACTER
000008BE  67D8                    1358m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
000008C0                          1359m     
000008C0  1439 00D30017           1360m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000008C6  13C2 00E00001           1361m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000008CC                          1362m     
000008CC                          1363m     ENDM
000008CC                          1364m         PRINT_CHAR D2,D3
000008CC                          1365m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008CC                 TRUE     1366m     IFEQ DEBUG
000008CC  1639 00D30003           1367m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008D2  0803 0002               1368m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008D6  67F4                    1369m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
000008D8  13C2 00D30007           1370m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000008DE                          1371m     ENDC
000008DE                          1372m     
000008DE                 FALSE    1373m     IFNE DEBUG
000008DE                          1374m     ENDC
000008DE                          1375m 
000008DE                          1376m     ENDM
000008DE                          1377m         HEX2BIN D2,D2,A0
000008DE  41F9 00001B1E           1378m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000008E4  0402 0030               1379m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008E8  C4BC 000000FF           1380m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000008EE  1430 2000               1381m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000008F2                          1382m   ENDM
000008F2  8E82                    1383          OR.L D2,D7
000008F4  E98F                    1384          LSL.L #4,D7        
000008F6                          1385m         DOWNLOAD D2,D3
000008F6                          1386m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F6                          1387m 
000008F6  1639 00D30003           1388m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000008FC  0803 0000               1389m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000900  6700 0010               1390m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
00000904                          1391m  
00000904                          1392mm     READ_CHAR D2
00000904                 TRUE     1393mm     IFEQ DEBUG
00000904  1439 00D30007           1394mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000090A                          1395mm     ENDC
0000090A                 FALSE    1396mm     IFNE DEBUG
0000090A                          1397mm     ENDC
0000090A                          1398mm      
0000090A  B43C 001B               1399mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000090E  6700 F6F8               1400mm     BEQ START
00000912                          1401mm     ENDM
00000912                          1402m CONTINUE_88
00000912  1639 00D30013           1403m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000918  0803 0000               1404m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000091C  67D8                    1405m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
0000091E                          1406m     
0000091E  1439 00D30017           1407m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000924  13C2 00E00001           1408m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000092A                          1409m     
0000092A                          1410m     ENDM
0000092A                          1411m         PRINT_CHAR D2,D3
0000092A                          1412m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092A                 TRUE     1413m     IFEQ DEBUG
0000092A  1639 00D30003           1414m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000930  0803 0002               1415m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000934  67F4                    1416m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
00000936  13C2 00D30007           1417m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
0000093C                          1418m     ENDC
0000093C                          1419m     
0000093C                 FALSE    1420m     IFNE DEBUG
0000093C                          1421m     ENDC
0000093C                          1422m 
0000093C                          1423m     ENDM
0000093C                          1424m         HEX2BIN D2,D2,A0
0000093C  41F9 00001B1E           1425m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000942  0402 0030               1426m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000946  C4BC 000000FF           1427m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000094C  1430 2000               1428m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000950                          1429m   ENDM
00000950  8E82                    1430          OR.L D2,D7
00000952                          1431          
00000952  7400                    1432          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000954  1407                    1433          MOVE.B D7,D2
00000956  DC82                    1434          ADD.L D2,D6
00000958                          1435          
00000958  DE8B                    1436          ADD.L A3,D7                 ; add in the offset
0000095A                          1437          
0000095A  5785                    1438          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
0000095C                          1439          
0000095C  0807 0000               1440          BTST #0,D7                  ; deal with odd addresses
00000960                          1441  
00000960  2247                    1442          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000962  6700 00D0               1443          BEQ EVEN
00000966                          1444                  
00000966  5385                    1445          SUB.L #1,D5
00000968  5389                    1446          SUB.L #1,A1
0000096A                          1447          
0000096A  7E00                    1448          MOVE.L #0,D7
0000096C                          1449m         DOWNLOAD D2,D3            ; MS 4 bits
0000096C                          1450m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000096C                          1451m 
0000096C  1639 00D30003           1452m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000972  0803 0000               1453m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000976  6700 0010               1454m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
0000097A                          1455m  
0000097A                          1456mm     READ_CHAR D2
0000097A                 TRUE     1457mm     IFEQ DEBUG
0000097A  1439 00D30007           1458mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000980                          1459mm     ENDC
00000980                 FALSE    1460mm     IFNE DEBUG
00000980                          1461mm     ENDC
00000980                          1462mm      
00000980  B43C 001B               1463mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000984  6700 F682               1464mm     BEQ START
00000988                          1465mm     ENDM
00000988                          1466m CONTINUE_92
00000988  1639 00D30013           1467m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000098E  0803 0000               1468m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000992  67D8                    1469m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
00000994                          1470m     
00000994  1439 00D30017           1471m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000099A  13C2 00E00001           1472m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009A0                          1473m     
000009A0                          1474m     ENDM
000009A0                          1475m         PRINT_CHAR D2,D3
000009A0                          1476m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A0                 TRUE     1477m     IFEQ DEBUG
000009A0  1639 00D30003           1478m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009A6  0803 0002               1479m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009AA  67F4                    1480m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
000009AC  13C2 00D30007           1481m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000009B2                          1482m     ENDC
000009B2                          1483m     
000009B2                 FALSE    1484m     IFNE DEBUG
000009B2                          1485m     ENDC
000009B2                          1486m 
000009B2                          1487m     ENDM
000009B2                          1488m         HEX2BIN D2,D2,A0
000009B2  41F9 00001B1E           1489m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000009B8  0402 0030               1490m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009BC  C4BC 000000FF           1491m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009C2  1430 2000               1492m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009C6                          1493m   ENDM
000009C6  8E82                    1494          OR.L D2,D7
000009C8  E98F                    1495          LSL.L #4,D7
000009CA                          1496               
000009CA                          1497m         DOWNLOAD D2,D3            ; LS 4 bits    
000009CA                          1498m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009CA                          1499m 
000009CA  1639 00D30003           1500m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000009D0  0803 0000               1501m     BTST #0,D3                    ; CHECK FOR CHARACTER
000009D4  6700 0010               1502m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
000009D8                          1503m  
000009D8                          1504mm     READ_CHAR D2
000009D8                 TRUE     1505mm     IFEQ DEBUG
000009D8  1439 00D30007           1506mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000009DE                          1507mm     ENDC
000009DE                 FALSE    1508mm     IFNE DEBUG
000009DE                          1509mm     ENDC
000009DE                          1510mm      
000009DE  B43C 001B               1511mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000009E2  6700 F624               1512mm     BEQ START
000009E6                          1513mm     ENDM
000009E6                          1514m CONTINUE_96
000009E6  1639 00D30013           1515m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000009EC  0803 0000               1516m     BTST #0,D3                  ; CHECK FOR CHARACTER
000009F0  67D8                    1517m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
000009F2                          1518m     
000009F2  1439 00D30017           1519m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000009F8  13C2 00E00001           1520m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009FE                          1521m     
000009FE                          1522m     ENDM
000009FE                          1523m         PRINT_CHAR D2,D3
000009FE                          1524m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FE                 TRUE     1525m     IFEQ DEBUG
000009FE  1639 00D30003           1526m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A04  0803 0002               1527m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A08  67F4                    1528m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
00000A0A  13C2 00D30007           1529m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A10                          1530m     ENDC
00000A10                          1531m     
00000A10                 FALSE    1532m     IFNE DEBUG
00000A10                          1533m     ENDC
00000A10                          1534m 
00000A10                          1535m     ENDM
00000A10                          1536m         HEX2BIN D2,D2,A0
00000A10  41F9 00001B1E           1537m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A16  0402 0030               1538m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A1A  C4BC 000000FF           1539m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A20  1430 2000               1540m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A24                          1541m   ENDM
00000A24  8E82                    1542          OR.L D2,D7
00000A26                          1543                          
00000A26  DC87                    1544          ADD.L D7,D6               ; add into checksum
00000A28                          1545                        
00000A28  3611                    1546          MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00000A2A                          1547          
00000A2A  0243 FF00               1548          ANDI.W #$FF00,D3
00000A2E  8647                    1549          OR.W D7,D3
00000A30                          1550          
00000A30  3283                    1551          MOVE.W D3,(A1)           ; store it!
00000A32  5489                    1552          ADD.L #2,A1
00000A34                          1553  EVEN        
00000A34                          1554          WHILE.L D5 <GE> #2 DO       ; read the data bytes
00000A34                          1555s _10000002
00000A34  BABC 00000002           1556s     CMP.L   #2,D5
00000A3A  6D00 018A               1557s     BLT _10000003
00000A3E  5585                    1558              SUB.L #2,D5
00000A40  7E00                    1559              MOVE.L #0,D7              ; D7 holds the word
00000A42                          1560              
00000A42                          1561m             DOWNLOAD D2,D3            ; MS 4 bits
00000A42                          1562m WAIT_FOR_READY_100                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A42                          1563m 
00000A42  1639 00D30003           1564m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A48  0803 0000               1565m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A4C  6700 0010               1566m     BEQ CONTINUE_100                ; NOTHING, CONTINUE
00000A50                          1567m  
00000A50                          1568mm     READ_CHAR D2
00000A50                 TRUE     1569mm     IFEQ DEBUG
00000A50  1439 00D30007           1570mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A56                          1571mm     ENDC
00000A56                 FALSE    1572mm     IFNE DEBUG
00000A56                          1573mm     ENDC
00000A56                          1574mm      
00000A56  B43C 001B               1575mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A5A  6700 F5AC               1576mm     BEQ START
00000A5E                          1577mm     ENDM
00000A5E                          1578m CONTINUE_100
00000A5E  1639 00D30013           1579m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A64  0803 0000               1580m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A68  67D8                    1581m     BEQ WAIT_FOR_READY_100        ; NOTHING, CHECK AGAIN
00000A6A                          1582m     
00000A6A  1439 00D30017           1583m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A70  13C2 00E00001           1584m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000A76                          1585m     
00000A76                          1586m     ENDM
00000A76                          1587m             PRINT_CHAR D2,D3
00000A76                          1588m WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A76                 TRUE     1589m     IFEQ DEBUG
00000A76  1639 00D30003           1590m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A7C  0803 0002               1591m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A80  67F4                    1592m       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00000A82  13C2 00D30007           1593m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A88                          1594m     ENDC
00000A88                          1595m     
00000A88                 FALSE    1596m     IFNE DEBUG
00000A88                          1597m     ENDC
00000A88                          1598m 
00000A88                          1599m     ENDM
00000A88                          1600m             HEX2BIN D2,D2,A0
00000A88  41F9 00001B1E           1601m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A8E  0402 0030               1602m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A92  C4BC 000000FF           1603m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A98  1430 2000               1604m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A9C                          1605m   ENDM
00000A9C  8E82                    1606              OR.L D2,D7
00000A9E  E98F                    1607              LSL.L #4,D7
00000AA0                          1608               
00000AA0                          1609m             DOWNLOAD D2,D3            ; LS 4 bits    
00000AA0                          1610m WAIT_FOR_READY_104                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA0                          1611m 
00000AA0  1639 00D30003           1612m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AA6  0803 0000               1613m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AAA  6700 0010               1614m     BEQ CONTINUE_104                ; NOTHING, CONTINUE
00000AAE                          1615m  
00000AAE                          1616mm     READ_CHAR D2
00000AAE                 TRUE     1617mm     IFEQ DEBUG
00000AAE  1439 00D30007           1618mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AB4                          1619mm     ENDC
00000AB4                 FALSE    1620mm     IFNE DEBUG
00000AB4                          1621mm     ENDC
00000AB4                          1622mm      
00000AB4  B43C 001B               1623mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AB8  6700 F54E               1624mm     BEQ START
00000ABC                          1625mm     ENDM
00000ABC                          1626m CONTINUE_104
00000ABC  1639 00D30013           1627m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000AC2  0803 0000               1628m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000AC6  67D8                    1629m     BEQ WAIT_FOR_READY_104        ; NOTHING, CHECK AGAIN
00000AC8                          1630m     
00000AC8  1439 00D30017           1631m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000ACE  13C2 00E00001           1632m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000AD4                          1633m     
00000AD4                          1634m     ENDM
00000AD4                          1635m             PRINT_CHAR D2,D3
00000AD4                          1636m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD4                 TRUE     1637m     IFEQ DEBUG
00000AD4  1639 00D30003           1638m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000ADA  0803 0002               1639m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000ADE  67F4                    1640m       BEQ WAIT_FOR_READY_106          ; NO SPACE, CHECK AGAIN
00000AE0  13C2 00D30007           1641m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000AE6                          1642m     ENDC
00000AE6                          1643m     
00000AE6                 FALSE    1644m     IFNE DEBUG
00000AE6                          1645m     ENDC
00000AE6                          1646m 
00000AE6                          1647m     ENDM
00000AE6                          1648m             HEX2BIN D2,D2,A0
00000AE6  41F9 00001B1E           1649m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000AEC  0402 0030               1650m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AF0  C4BC 000000FF           1651m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000AF6  1430 2000               1652m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000AFA                          1653m   ENDM
00000AFA  8E82                    1654              OR.L D2,D7
00000AFC                          1655                          
00000AFC  DC87                    1656              ADD.L D7,D6               ; add into checksum
00000AFE                          1657              
00000AFE  E98F                    1658              LSL.L #4,D7
00000B00                          1659m             DOWNLOAD D2,D3            ; MS 4 bits
00000B00                          1660m WAIT_FOR_READY_108                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B00                          1661m 
00000B00  1639 00D30003           1662m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B06  0803 0000               1663m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B0A  6700 0010               1664m     BEQ CONTINUE_108                ; NOTHING, CONTINUE
00000B0E                          1665m  
00000B0E                          1666mm     READ_CHAR D2
00000B0E                 TRUE     1667mm     IFEQ DEBUG
00000B0E  1439 00D30007           1668mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B14                          1669mm     ENDC
00000B14                 FALSE    1670mm     IFNE DEBUG
00000B14                          1671mm     ENDC
00000B14                          1672mm      
00000B14  B43C 001B               1673mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B18  6700 F4EE               1674mm     BEQ START
00000B1C                          1675mm     ENDM
00000B1C                          1676m CONTINUE_108
00000B1C  1639 00D30013           1677m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B22  0803 0000               1678m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B26  67D8                    1679m     BEQ WAIT_FOR_READY_108        ; NOTHING, CHECK AGAIN
00000B28                          1680m     
00000B28  1439 00D30017           1681m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B2E  13C2 00E00001           1682m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B34                          1683m     
00000B34                          1684m     ENDM
00000B34                          1685m             PRINT_CHAR D2,D3
00000B34                          1686m WAIT_FOR_READY_110                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B34                 TRUE     1687m     IFEQ DEBUG
00000B34  1639 00D30003           1688m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000B3A  0803 0002               1689m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000B3E  67F4                    1690m       BEQ WAIT_FOR_READY_110          ; NO SPACE, CHECK AGAIN
00000B40  13C2 00D30007           1691m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000B46                          1692m     ENDC
00000B46                          1693m     
00000B46                 FALSE    1694m     IFNE DEBUG
00000B46                          1695m     ENDC
00000B46                          1696m 
00000B46                          1697m     ENDM
00000B46                          1698m             HEX2BIN D2,D2,A0
00000B46  41F9 00001B1E           1699m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B4C  0402 0030               1700m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B50  C4BC 000000FF           1701m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B56  1430 2000               1702m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B5A                          1703m   ENDM
00000B5A  8E82                    1704              OR.L D2,D7
00000B5C                          1705               
00000B5C  E98F                    1706              LSL.L #4,D7
00000B5E                          1707m             DOWNLOAD D2,D3            ; LS 4 bits    
00000B5E                          1708m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5E                          1709m 
00000B5E  1639 00D30003           1710m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B64  0803 0000               1711m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B68  6700 0010               1712m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00000B6C                          1713m  
00000B6C                          1714mm     READ_CHAR D2
00000B6C                 TRUE     1715mm     IFEQ DEBUG
00000B6C  1439 00D30007           1716mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B72                          1717mm     ENDC
00000B72                 FALSE    1718mm     IFNE DEBUG
00000B72                          1719mm     ENDC
00000B72                          1720mm      
00000B72  B43C 001B               1721mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B76  6700 F490               1722mm     BEQ START
00000B7A                          1723mm     ENDM
00000B7A                          1724m CONTINUE_112
00000B7A  1639 00D30013           1725m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B80  0803 0000               1726m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B84  67D8                    1727m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00000B86                          1728m     
00000B86  1439 00D30017           1729m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B8C  13C2 00E00001           1730m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B92                          1731m     
00000B92                          1732m     ENDM
00000B92                          1733m             PRINT_CHAR D2,D3
00000B92                          1734m WAIT_FOR_READY_114                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B92                 TRUE     1735m     IFEQ DEBUG
00000B92  1639 00D30003           1736m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000B98  0803 0002               1737m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000B9C  67F4                    1738m       BEQ WAIT_FOR_READY_114          ; NO SPACE, CHECK AGAIN
00000B9E  13C2 00D30007           1739m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000BA4                          1740m     ENDC
00000BA4                          1741m     
00000BA4                 FALSE    1742m     IFNE DEBUG
00000BA4                          1743m     ENDC
00000BA4                          1744m 
00000BA4                          1745m     ENDM
00000BA4                          1746m             HEX2BIN D2,D2,A0
00000BA4  41F9 00001B1E           1747m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000BAA  0402 0030               1748m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BAE  C4BC 000000FF           1749m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000BB4  1430 2000               1750m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BB8                          1751m   ENDM
00000BB8  8E82                    1752              OR.L D2,D7
00000BBA                          1753              
00000BBA  7400                    1754              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00000BBC  1407                    1755              MOVE.B D7,D2
00000BBE  DC82                    1756              ADD.L D2,D6
00000BC0                          1757              
00000BC0  32C7                    1758              MOVE.W D7,(A1)+          ; store it!
00000BC2                          1759          ENDW
00000BC2  6000 FE70               1760s     BRA _10000002
00000BC6                          1761s _10000003
00000BC6                          1762          
00000BC6                          1763          IF D5 <EQ> #1 THEN
00000BC6  BA7C 0001               1764s     CMP.W   #1,D5
00000BCA  6600 00CE               1765s     BNE _00000003
00000BCE  7E00                    1766              MOVE.L #0,D7              ; D7 holds the word
00000BD0                          1767                      
00000BD0                          1768m             DOWNLOAD D2,D3            ; MS 4 bits
00000BD0                          1769m WAIT_FOR_READY_116                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                          1770m 
00000BD0  1639 00D30003           1771m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000BD6  0803 0000               1772m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000BDA  6700 0010               1773m     BEQ CONTINUE_116                ; NOTHING, CONTINUE
00000BDE                          1774m  
00000BDE                          1775mm     READ_CHAR D2
00000BDE                 TRUE     1776mm     IFEQ DEBUG
00000BDE  1439 00D30007           1777mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000BE4                          1778mm     ENDC
00000BE4                 FALSE    1779mm     IFNE DEBUG
00000BE4                          1780mm     ENDC
00000BE4                          1781mm      
00000BE4  B43C 001B               1782mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BE8  6700 F41E               1783mm     BEQ START
00000BEC                          1784mm     ENDM
00000BEC                          1785m CONTINUE_116
00000BEC  1639 00D30013           1786m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BF2  0803 0000               1787m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BF6  67D8                    1788m     BEQ WAIT_FOR_READY_116        ; NOTHING, CHECK AGAIN
00000BF8                          1789m     
00000BF8  1439 00D30017           1790m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BFE  13C2 00E00001           1791m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000C04                          1792m     
00000C04                          1793m     ENDM
00000C04                          1794m             PRINT_CHAR D2,D3
00000C04                          1795m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C04                 TRUE     1796m     IFEQ DEBUG
00000C04  1639 00D30003           1797m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C0A  0803 0002               1798m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C0E  67F4                    1799m       BEQ WAIT_FOR_READY_118          ; NO SPACE, CHECK AGAIN
00000C10  13C2 00D30007           1800m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C16                          1801m     ENDC
00000C16                          1802m     
00000C16                 FALSE    1803m     IFNE DEBUG
00000C16                          1804m     ENDC
00000C16                          1805m 
00000C16                          1806m     ENDM
00000C16                          1807m             HEX2BIN D2,D2,A0
00000C16  41F9 00001B1E           1808m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C1C  0402 0030               1809m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C20  C4BC 000000FF           1810m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C26  1430 2000               1811m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C2A                          1812m   ENDM
00000C2A  8E82                    1813              OR.L D2,D7
00000C2C  E98F                    1814              LSL.L #4,D7
00000C2E                          1815               
00000C2E                          1816m             DOWNLOAD D2,D3            ; LS 4 bits    
00000C2E                          1817m WAIT_FOR_READY_120                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2E                          1818m 
00000C2E  1639 00D30003           1819m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000C34  0803 0000               1820m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000C38  6700 0010               1821m     BEQ CONTINUE_120                ; NOTHING, CONTINUE
00000C3C                          1822m  
00000C3C                          1823mm     READ_CHAR D2
00000C3C                 TRUE     1824mm     IFEQ DEBUG
00000C3C  1439 00D30007           1825mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000C42                          1826mm     ENDC
00000C42                 FALSE    1827mm     IFNE DEBUG
00000C42                          1828mm     ENDC
00000C42                          1829mm      
00000C42  B43C 001B               1830mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000C46  6700 F3C0               1831mm     BEQ START
00000C4A                          1832mm     ENDM
00000C4A                          1833m CONTINUE_120
00000C4A  1639 00D30013           1834m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000C50  0803 0000               1835m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000C54  67D8                    1836m     BEQ WAIT_FOR_READY_120        ; NOTHING, CHECK AGAIN
00000C56                          1837m     
00000C56  1439 00D30017           1838m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000C5C  13C2 00E00001           1839m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000C62                          1840m     
00000C62                          1841m     ENDM
00000C62                          1842m             PRINT_CHAR D2,D3
00000C62                          1843m WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C62                 TRUE     1844m     IFEQ DEBUG
00000C62  1639 00D30003           1845m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C68  0803 0002               1846m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C6C  67F4                    1847m       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00000C6E  13C2 00D30007           1848m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C74                          1849m     ENDC
00000C74                          1850m     
00000C74                 FALSE    1851m     IFNE DEBUG
00000C74                          1852m     ENDC
00000C74                          1853m 
00000C74                          1854m     ENDM
00000C74                          1855m             HEX2BIN D2,D2,A0
00000C74  41F9 00001B1E           1856m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C7A  0402 0030               1857m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C7E  C4BC 000000FF           1858m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C84  1430 2000               1859m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C88                          1860m   ENDM
00000C88  8E82                    1861              OR.L D2,D7
00000C8A                          1862                          
00000C8A  DC87                    1863              ADD.L D7,D6               ; add into checksum
00000C8C                          1864              
00000C8C  3611                    1865              MOVE.W (A1),D3            ; get the current data and replace the top byte
00000C8E  E18F                    1866              LSL.L #8,D7
00000C90  C6BC 000000FF           1867              AND.L #$00FF,D3
00000C96  8687                    1868              OR.L D7,D3
00000C98                          1869  
00000C98  32C3                    1870              MOVE.W D3,(A1)+          ; store it!
00000C9A                          1871          ENDI
00000C9A                          1872s _00000003
00000C9A                          1873    
00000C9A                          1874m         PRINT_CRLF D3
00000C9A                          1875mm     PRINT_CHAR #13,D3             ; CR
00000C9A                          1876mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C9A                 TRUE     1877mm     IFEQ DEBUG
00000C9A  1639 00D30003           1878mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000CA0  0803 0002               1879mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000CA4  67F4                    1880mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00000CA6  13FC 000D 00D30007      1881mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000CAE                          1882mm     ENDC
00000CAE                          1883mm     
00000CAE                 FALSE    1884mm     IFNE DEBUG
00000CAE                          1885mm     ENDC
00000CAE                          1886mm 
00000CAE                          1887mm     ENDM
00000CAE                          1888mm     PRINT_CHAR #10,D3             ; LF
00000CAE                          1889mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAE                 TRUE     1890mm     IFEQ DEBUG
00000CAE  1639 00D30003           1891mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000CB4  0803 0002               1892mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000CB8  67F4                    1893mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00000CBA  13FC 000A 00D30007      1894mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000CC2                          1895mm     ENDC
00000CC2                          1896mm     
00000CC2                 FALSE    1897mm     IFNE DEBUG
00000CC2                          1898mm     ENDC
00000CC2                          1899mm 
00000CC2                          1900mm     ENDM
00000CC2                          1901m     ENDM
00000CC2  43F8 0496               1902          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00000CC6                          1903        ELSE
00000CC6  6000 080C               1904s     BRA _00000004
00000CCA                          1905s _00000002
00000CCA                          1906          IF.B D7 <EQ> #'2' THEN.L      ; 24 bit address data record
00000CCA  BE3C 0032               1907s     CMP.B   #'2',D7
00000CCE  6600 05B8               1908s     BNE.L   _00000005
00000CD2  7E00                    1909            MOVE.L #0,D7                ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000CD4                          1910m           DOWNLOAD D2,D3              ; top byte
00000CD4                          1911m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD4                          1912m 
00000CD4  1639 00D30003           1913m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CDA  0803 0000               1914m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CDE  6700 0010               1915m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00000CE2                          1916m  
00000CE2                          1917mm     READ_CHAR D2
00000CE2                 TRUE     1918mm     IFEQ DEBUG
00000CE2  1439 00D30007           1919mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CE8                          1920mm     ENDC
00000CE8                 FALSE    1921mm     IFNE DEBUG
00000CE8                          1922mm     ENDC
00000CE8                          1923mm      
00000CE8  B43C 001B               1924mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CEC  6700 F31A               1925mm     BEQ START
00000CF0                          1926mm     ENDM
00000CF0                          1927m CONTINUE_127
00000CF0  1639 00D30013           1928m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000CF6  0803 0000               1929m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000CFA  67D8                    1930m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00000CFC                          1931m     
00000CFC  1439 00D30017           1932m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000D02  13C2 00E00001           1933m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000D08                          1934m     
00000D08                          1935m     ENDM
00000D08                          1936m           PRINT_CHAR D2,D3
00000D08                          1937m WAIT_FOR_READY_129                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D08                 TRUE     1938m     IFEQ DEBUG
00000D08  1639 00D30003           1939m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D0E  0803 0002               1940m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D12  67F4                    1941m       BEQ WAIT_FOR_READY_129          ; NO SPACE, CHECK AGAIN
00000D14  13C2 00D30007           1942m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D1A                          1943m     ENDC
00000D1A                          1944m     
00000D1A                 FALSE    1945m     IFNE DEBUG
00000D1A                          1946m     ENDC
00000D1A                          1947m 
00000D1A                          1948m     ENDM
00000D1A                          1949m           HEX2BIN D2,D2,A0
00000D1A  41F9 00001B1E           1950m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D20  0402 0030               1951m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D24  C4BC 000000FF           1952m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D2A  1430 2000               1953m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D2E                          1954m   ENDM
00000D2E  8E82                    1955            OR.L D2,D7
00000D30  E98F                    1956            LSL.L #4,D7
00000D32                          1957m           DOWNLOAD D2,D3         
00000D32                          1958m WAIT_FOR_READY_131                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D32                          1959m 
00000D32  1639 00D30003           1960m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000D38  0803 0000               1961m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000D3C  6700 0010               1962m     BEQ CONTINUE_131                ; NOTHING, CONTINUE
00000D40                          1963m  
00000D40                          1964mm     READ_CHAR D2
00000D40                 TRUE     1965mm     IFEQ DEBUG
00000D40  1439 00D30007           1966mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000D46                          1967mm     ENDC
00000D46                 FALSE    1968mm     IFNE DEBUG
00000D46                          1969mm     ENDC
00000D46                          1970mm      
00000D46  B43C 001B               1971mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000D4A  6700 F2BC               1972mm     BEQ START
00000D4E                          1973mm     ENDM
00000D4E                          1974m CONTINUE_131
00000D4E  1639 00D30013           1975m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000D54  0803 0000               1976m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000D58  67D8                    1977m     BEQ WAIT_FOR_READY_131        ; NOTHING, CHECK AGAIN
00000D5A                          1978m     
00000D5A  1439 00D30017           1979m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000D60  13C2 00E00001           1980m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000D66                          1981m     
00000D66                          1982m     ENDM
00000D66                          1983m           PRINT_CHAR D2,D3
00000D66                          1984m WAIT_FOR_READY_133                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D66                 TRUE     1985m     IFEQ DEBUG
00000D66  1639 00D30003           1986m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D6C  0803 0002               1987m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D70  67F4                    1988m       BEQ WAIT_FOR_READY_133          ; NO SPACE, CHECK AGAIN
00000D72  13C2 00D30007           1989m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D78                          1990m     ENDC
00000D78                          1991m     
00000D78                 FALSE    1992m     IFNE DEBUG
00000D78                          1993m     ENDC
00000D78                          1994m 
00000D78                          1995m     ENDM
00000D78                          1996m           HEX2BIN D2,D2,A0
00000D78  41F9 00001B1E           1997m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D7E  0402 0030               1998m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D82  C4BC 000000FF           1999m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D88  1430 2000               2000m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D8C                          2001m   ENDM
00000D8C  8E82                    2002            OR.L D2,D7
00000D8E                          2003          
00000D8E  DC87                    2004            ADD.L D7,D6                 ; add top byte of address into checksum
00000D90                          2005  
00000D90  E98F                    2006            LSL.L #4,D7                 ; middle byte
00000D92                          2007m           DOWNLOAD D2,D3
00000D92                          2008m WAIT_FOR_READY_135                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D92                          2009m 
00000D92  1639 00D30003           2010m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000D98  0803 0000               2011m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000D9C  6700 0010               2012m     BEQ CONTINUE_135                ; NOTHING, CONTINUE
00000DA0                          2013m  
00000DA0                          2014mm     READ_CHAR D2
00000DA0                 TRUE     2015mm     IFEQ DEBUG
00000DA0  1439 00D30007           2016mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000DA6                          2017mm     ENDC
00000DA6                 FALSE    2018mm     IFNE DEBUG
00000DA6                          2019mm     ENDC
00000DA6                          2020mm      
00000DA6  B43C 001B               2021mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000DAA  6700 F25C               2022mm     BEQ START
00000DAE                          2023mm     ENDM
00000DAE                          2024m CONTINUE_135
00000DAE  1639 00D30013           2025m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000DB4  0803 0000               2026m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000DB8  67D8                    2027m     BEQ WAIT_FOR_READY_135        ; NOTHING, CHECK AGAIN
00000DBA                          2028m     
00000DBA  1439 00D30017           2029m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000DC0  13C2 00E00001           2030m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000DC6                          2031m     
00000DC6                          2032m     ENDM
00000DC6                          2033m           PRINT_CHAR D2,D3
00000DC6                          2034m WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC6                 TRUE     2035m     IFEQ DEBUG
00000DC6  1639 00D30003           2036m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DCC  0803 0002               2037m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DD0  67F4                    2038m       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00000DD2  13C2 00D30007           2039m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DD8                          2040m     ENDC
00000DD8                          2041m     
00000DD8                 FALSE    2042m     IFNE DEBUG
00000DD8                          2043m     ENDC
00000DD8                          2044m 
00000DD8                          2045m     ENDM
00000DD8                          2046m           HEX2BIN D2,D2,A0
00000DD8  41F9 00001B1E           2047m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000DDE  0402 0030               2048m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DE2  C4BC 000000FF           2049m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000DE8  1430 2000               2050m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000DEC                          2051m   ENDM
00000DEC  8E82                    2052            OR.L D2,D7
00000DEE  E98F                    2053            LSL.L #4,D7        
00000DF0                          2054m           DOWNLOAD D2,D3
00000DF0                          2055m WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF0                          2056m 
00000DF0  1639 00D30003           2057m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000DF6  0803 0000               2058m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000DFA  6700 0010               2059m     BEQ CONTINUE_139                ; NOTHING, CONTINUE
00000DFE                          2060m  
00000DFE                          2061mm     READ_CHAR D2
00000DFE                 TRUE     2062mm     IFEQ DEBUG
00000DFE  1439 00D30007           2063mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000E04                          2064mm     ENDC
00000E04                 FALSE    2065mm     IFNE DEBUG
00000E04                          2066mm     ENDC
00000E04                          2067mm      
00000E04  B43C 001B               2068mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000E08  6700 F1FE               2069mm     BEQ START
00000E0C                          2070mm     ENDM
00000E0C                          2071m CONTINUE_139
00000E0C  1639 00D30013           2072m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000E12  0803 0000               2073m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000E16  67D8                    2074m     BEQ WAIT_FOR_READY_139        ; NOTHING, CHECK AGAIN
00000E18                          2075m     
00000E18  1439 00D30017           2076m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000E1E  13C2 00E00001           2077m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000E24                          2078m     
00000E24                          2079m     ENDM
00000E24                          2080m           PRINT_CHAR D2,D3
00000E24                          2081m WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E24                 TRUE     2082m     IFEQ DEBUG
00000E24  1639 00D30003           2083m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E2A  0803 0002               2084m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E2E  67F4                    2085m       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00000E30  13C2 00D30007           2086m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E36                          2087m     ENDC
00000E36                          2088m     
00000E36                 FALSE    2089m     IFNE DEBUG
00000E36                          2090m     ENDC
00000E36                          2091m 
00000E36                          2092m     ENDM
00000E36                          2093m           HEX2BIN D2,D2,A0
00000E36  41F9 00001B1E           2094m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000E3C  0402 0030               2095m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E40  C4BC 000000FF           2096m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000E46  1430 2000               2097m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000E4A                          2098m   ENDM
00000E4A  8E82                    2099            OR.L D2,D7
00000E4C                          2100          
00000E4C  7400                    2101            MOVE.L #0,D2                 ; rextract middle byte of address and add into checksum
00000E4E  1407                    2102            MOVE.B D7,D2
00000E50  DC82                    2103            ADD.L D2,D6
00000E52                          2104            
00000E52  E98F                    2105            LSL.L #4,D7                 ; bottom byte
00000E54                          2106m           DOWNLOAD D2,D3
00000E54                          2107m WAIT_FOR_READY_143                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E54                          2108m 
00000E54  1639 00D30003           2109m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000E5A  0803 0000               2110m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000E5E  6700 0010               2111m     BEQ CONTINUE_143                ; NOTHING, CONTINUE
00000E62                          2112m  
00000E62                          2113mm     READ_CHAR D2
00000E62                 TRUE     2114mm     IFEQ DEBUG
00000E62  1439 00D30007           2115mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000E68                          2116mm     ENDC
00000E68                 FALSE    2117mm     IFNE DEBUG
00000E68                          2118mm     ENDC
00000E68                          2119mm      
00000E68  B43C 001B               2120mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000E6C  6700 F19A               2121mm     BEQ START
00000E70                          2122mm     ENDM
00000E70                          2123m CONTINUE_143
00000E70  1639 00D30013           2124m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000E76  0803 0000               2125m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000E7A  67D8                    2126m     BEQ WAIT_FOR_READY_143        ; NOTHING, CHECK AGAIN
00000E7C                          2127m     
00000E7C  1439 00D30017           2128m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000E82  13C2 00E00001           2129m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000E88                          2130m     
00000E88                          2131m     ENDM
00000E88                          2132m           PRINT_CHAR D2,D3
00000E88                          2133m WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E88                 TRUE     2134m     IFEQ DEBUG
00000E88  1639 00D30003           2135m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E8E  0803 0002               2136m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E92  67F4                    2137m       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00000E94  13C2 00D30007           2138m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E9A                          2139m     ENDC
00000E9A                          2140m     
00000E9A                 FALSE    2141m     IFNE DEBUG
00000E9A                          2142m     ENDC
00000E9A                          2143m 
00000E9A                          2144m     ENDM
00000E9A                          2145m           HEX2BIN D2,D2,A0
00000E9A  41F9 00001B1E           2146m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000EA0  0402 0030               2147m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EA4  C4BC 000000FF           2148m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000EAA  1430 2000               2149m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000EAE                          2150m   ENDM
00000EAE  8E82                    2151            OR.L D2,D7
00000EB0  E98F                    2152            LSL.L #4,D7        
00000EB2                          2153m           DOWNLOAD D2,D3
00000EB2                          2154m WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB2                          2155m 
00000EB2  1639 00D30003           2156m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000EB8  0803 0000               2157m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000EBC  6700 0010               2158m     BEQ CONTINUE_147                ; NOTHING, CONTINUE
00000EC0                          2159m  
00000EC0                          2160mm     READ_CHAR D2
00000EC0                 TRUE     2161mm     IFEQ DEBUG
00000EC0  1439 00D30007           2162mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000EC6                          2163mm     ENDC
00000EC6                 FALSE    2164mm     IFNE DEBUG
00000EC6                          2165mm     ENDC
00000EC6                          2166mm      
00000EC6  B43C 001B               2167mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000ECA  6700 F13C               2168mm     BEQ START
00000ECE                          2169mm     ENDM
00000ECE                          2170m CONTINUE_147
00000ECE  1639 00D30013           2171m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000ED4  0803 0000               2172m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000ED8  67D8                    2173m     BEQ WAIT_FOR_READY_147        ; NOTHING, CHECK AGAIN
00000EDA                          2174m     
00000EDA  1439 00D30017           2175m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000EE0  13C2 00E00001           2176m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000EE6                          2177m     
00000EE6                          2178m     ENDM
00000EE6                          2179m           PRINT_CHAR D2,D3
00000EE6                          2180m WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE6                 TRUE     2181m     IFEQ DEBUG
00000EE6  1639 00D30003           2182m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EEC  0803 0002               2183m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EF0  67F4                    2184m       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00000EF2  13C2 00D30007           2185m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000EF8                          2186m     ENDC
00000EF8                          2187m     
00000EF8                 FALSE    2188m     IFNE DEBUG
00000EF8                          2189m     ENDC
00000EF8                          2190m 
00000EF8                          2191m     ENDM
00000EF8                          2192m           HEX2BIN D2,D2,A0
00000EF8  41F9 00001B1E           2193m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000EFE  0402 0030               2194m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F02  C4BC 000000FF           2195m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000F08  1430 2000               2196m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000F0C                          2197m   ENDM
00000F0C  8E82                    2198            OR.L D2,D7
00000F0E                          2199          
00000F0E  7400                    2200            MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
00000F10  1407                    2201            MOVE.B D7,D2
00000F12  DC82                    2202            ADD.L D2,D6
00000F14                          2203          
00000F14  2247                    2204            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000F16  D3CB                    2205            ADD.L A3,A1                 ; add in the offset
00000F18                          2206            
00000F18  0807 0000               2207            BTST #0,D7                  ; deal with odd addresses
00000F1C                          2208  
00000F1C  2247                    2209            MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000F1E  6700 00D0               2210            BEQ EVEN2
00000F22                          2211                  
00000F22  5385                    2212            SUB.L #1,D5
00000F24  5389                    2213            SUB.L #1,A1
00000F26                          2214          
00000F26  7E00                    2215            MOVE.L #0,D7
00000F28                          2216m           DOWNLOAD D2,D3            ; MS 4 bits
00000F28                          2217m WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F28                          2218m 
00000F28  1639 00D30003           2219m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000F2E  0803 0000               2220m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000F32  6700 0010               2221m     BEQ CONTINUE_151                ; NOTHING, CONTINUE
00000F36                          2222m  
00000F36                          2223mm     READ_CHAR D2
00000F36                 TRUE     2224mm     IFEQ DEBUG
00000F36  1439 00D30007           2225mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000F3C                          2226mm     ENDC
00000F3C                 FALSE    2227mm     IFNE DEBUG
00000F3C                          2228mm     ENDC
00000F3C                          2229mm      
00000F3C  B43C 001B               2230mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000F40  6700 F0C6               2231mm     BEQ START
00000F44                          2232mm     ENDM
00000F44                          2233m CONTINUE_151
00000F44  1639 00D30013           2234m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000F4A  0803 0000               2235m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000F4E  67D8                    2236m     BEQ WAIT_FOR_READY_151        ; NOTHING, CHECK AGAIN
00000F50                          2237m     
00000F50  1439 00D30017           2238m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000F56  13C2 00E00001           2239m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000F5C                          2240m     
00000F5C                          2241m     ENDM
00000F5C                          2242m           PRINT_CHAR D2,D3
00000F5C                          2243m WAIT_FOR_READY_153                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F5C                 TRUE     2244m     IFEQ DEBUG
00000F5C  1639 00D30003           2245m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000F62  0803 0002               2246m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000F66  67F4                    2247m       BEQ WAIT_FOR_READY_153          ; NO SPACE, CHECK AGAIN
00000F68  13C2 00D30007           2248m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000F6E                          2249m     ENDC
00000F6E                          2250m     
00000F6E                 FALSE    2251m     IFNE DEBUG
00000F6E                          2252m     ENDC
00000F6E                          2253m 
00000F6E                          2254m     ENDM
00000F6E                          2255m           HEX2BIN D2,D2,A0
00000F6E  41F9 00001B1E           2256m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000F74  0402 0030               2257m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F78  C4BC 000000FF           2258m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000F7E  1430 2000               2259m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000F82                          2260m   ENDM
00000F82  8E82                    2261            OR.L D2,D7
00000F84  E98F                    2262            LSL.L #4,D7
00000F86                          2263               
00000F86                          2264m           DOWNLOAD D2,D3            ; LS 4 bits    
00000F86                          2265m WAIT_FOR_READY_155                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F86                          2266m 
00000F86  1639 00D30003           2267m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000F8C  0803 0000               2268m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000F90  6700 0010               2269m     BEQ CONTINUE_155                ; NOTHING, CONTINUE
00000F94                          2270m  
00000F94                          2271mm     READ_CHAR D2
00000F94                 TRUE     2272mm     IFEQ DEBUG
00000F94  1439 00D30007           2273mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000F9A                          2274mm     ENDC
00000F9A                 FALSE    2275mm     IFNE DEBUG
00000F9A                          2276mm     ENDC
00000F9A                          2277mm      
00000F9A  B43C 001B               2278mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000F9E  6700 F068               2279mm     BEQ START
00000FA2                          2280mm     ENDM
00000FA2                          2281m CONTINUE_155
00000FA2  1639 00D30013           2282m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000FA8  0803 0000               2283m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000FAC  67D8                    2284m     BEQ WAIT_FOR_READY_155        ; NOTHING, CHECK AGAIN
00000FAE                          2285m     
00000FAE  1439 00D30017           2286m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000FB4  13C2 00E00001           2287m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000FBA                          2288m     
00000FBA                          2289m     ENDM
00000FBA                          2290m           PRINT_CHAR D2,D3
00000FBA                          2291m WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FBA                 TRUE     2292m     IFEQ DEBUG
00000FBA  1639 00D30003           2293m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000FC0  0803 0002               2294m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000FC4  67F4                    2295m       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00000FC6  13C2 00D30007           2296m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000FCC                          2297m     ENDC
00000FCC                          2298m     
00000FCC                 FALSE    2299m     IFNE DEBUG
00000FCC                          2300m     ENDC
00000FCC                          2301m 
00000FCC                          2302m     ENDM
00000FCC                          2303m           HEX2BIN D2,D2,A0
00000FCC  41F9 00001B1E           2304m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000FD2  0402 0030               2305m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FD6  C4BC 000000FF           2306m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000FDC  1430 2000               2307m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000FE0                          2308m   ENDM
00000FE0  8E82                    2309            OR.L D2,D7
00000FE2                          2310                          
00000FE2  DC87                    2311            ADD.L D7,D6               ; add into checksum
00000FE4                          2312                        
00000FE4  3611                    2313            MOVE.W (A1),D3            ; get the current data and replace the bottom byte
00000FE6                          2314          
00000FE6  0243 FF00               2315            ANDI.W #$FF00,D3
00000FEA  8647                    2316            OR.W D7,D3
00000FEC                          2317          
00000FEC  3283                    2318            MOVE.W D3,(A1)           ; store it!
00000FEE  5489                    2319            ADD.L #2,A1
00000FF0                          2320  EVEN2
00000FF0  5985                    2321            SUB.L #4,D5                 ; subtract four bytes for 24 bit address and 1 byte checksum
00000FF2                          2322            WHILE.L D5 <GE> #2 DO       ; read the data bytes
00000FF2                          2323s _10000004
00000FF2  BABC 00000002           2324s     CMP.L   #2,D5
00000FF8  6D00 018A               2325s     BLT _10000005
00000FFC  5585                    2326              SUB.L #2,D5
00000FFE                          2327              
00000FFE  7E00                    2328              MOVE.L #0,D7              ; D7 holds the word
00001000                          2329              
00001000                          2330m             DOWNLOAD D2,D3            ; MS 4 bits
00001000                          2331m WAIT_FOR_READY_159                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001000                          2332m 
00001000  1639 00D30003           2333m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001006  0803 0000               2334m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000100A  6700 0010               2335m     BEQ CONTINUE_159                ; NOTHING, CONTINUE
0000100E                          2336m  
0000100E                          2337mm     READ_CHAR D2
0000100E                 TRUE     2338mm     IFEQ DEBUG
0000100E  1439 00D30007           2339mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001014                          2340mm     ENDC
00001014                 FALSE    2341mm     IFNE DEBUG
00001014                          2342mm     ENDC
00001014                          2343mm      
00001014  B43C 001B               2344mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001018  6700 EFEE               2345mm     BEQ START
0000101C                          2346mm     ENDM
0000101C                          2347m CONTINUE_159
0000101C  1639 00D30013           2348m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001022  0803 0000               2349m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001026  67D8                    2350m     BEQ WAIT_FOR_READY_159        ; NOTHING, CHECK AGAIN
00001028                          2351m     
00001028  1439 00D30017           2352m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000102E  13C2 00E00001           2353m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001034                          2354m     
00001034                          2355m     ENDM
00001034                          2356m             PRINT_CHAR D2,D3
00001034                          2357m WAIT_FOR_READY_161                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001034                 TRUE     2358m     IFEQ DEBUG
00001034  1639 00D30003           2359m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000103A  0803 0002               2360m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000103E  67F4                    2361m       BEQ WAIT_FOR_READY_161          ; NO SPACE, CHECK AGAIN
00001040  13C2 00D30007           2362m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001046                          2363m     ENDC
00001046                          2364m     
00001046                 FALSE    2365m     IFNE DEBUG
00001046                          2366m     ENDC
00001046                          2367m 
00001046                          2368m     ENDM
00001046                          2369m             HEX2BIN D2,D2,A0
00001046  41F9 00001B1E           2370m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000104C  0402 0030               2371m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001050  C4BC 000000FF           2372m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001056  1430 2000               2373m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000105A                          2374m   ENDM
0000105A  8E82                    2375              OR.L D2,D7
0000105C  E98F                    2376              LSL.L #4,D7
0000105E                          2377               
0000105E                          2378m             DOWNLOAD D2,D3            ; LS 4 bits    
0000105E                          2379m WAIT_FOR_READY_163                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000105E                          2380m 
0000105E  1639 00D30003           2381m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001064  0803 0000               2382m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001068  6700 0010               2383m     BEQ CONTINUE_163                ; NOTHING, CONTINUE
0000106C                          2384m  
0000106C                          2385mm     READ_CHAR D2
0000106C                 TRUE     2386mm     IFEQ DEBUG
0000106C  1439 00D30007           2387mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001072                          2388mm     ENDC
00001072                 FALSE    2389mm     IFNE DEBUG
00001072                          2390mm     ENDC
00001072                          2391mm      
00001072  B43C 001B               2392mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001076  6700 EF90               2393mm     BEQ START
0000107A                          2394mm     ENDM
0000107A                          2395m CONTINUE_163
0000107A  1639 00D30013           2396m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001080  0803 0000               2397m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001084  67D8                    2398m     BEQ WAIT_FOR_READY_163        ; NOTHING, CHECK AGAIN
00001086                          2399m     
00001086  1439 00D30017           2400m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000108C  13C2 00E00001           2401m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001092                          2402m     
00001092                          2403m     ENDM
00001092                          2404m             PRINT_CHAR D2,D3
00001092                          2405m WAIT_FOR_READY_165                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001092                 TRUE     2406m     IFEQ DEBUG
00001092  1639 00D30003           2407m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001098  0803 0002               2408m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000109C  67F4                    2409m       BEQ WAIT_FOR_READY_165          ; NO SPACE, CHECK AGAIN
0000109E  13C2 00D30007           2410m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000010A4                          2411m     ENDC
000010A4                          2412m     
000010A4                 FALSE    2413m     IFNE DEBUG
000010A4                          2414m     ENDC
000010A4                          2415m 
000010A4                          2416m     ENDM
000010A4                          2417m             HEX2BIN D2,D2,A0
000010A4  41F9 00001B1E           2418m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000010AA  0402 0030               2419m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010AE  C4BC 000000FF           2420m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000010B4  1430 2000               2421m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000010B8                          2422m   ENDM
000010B8  8E82                    2423              OR.L D2,D7
000010BA                          2424                          
000010BA  DC87                    2425              ADD.L D7,D6               ; add into checksum
000010BC                          2426              
000010BC  E98F                    2427              LSL.L #4,D7
000010BE                          2428m             DOWNLOAD D2,D3            ; MS 4 bits
000010BE                          2429m WAIT_FOR_READY_167                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010BE                          2430m 
000010BE  1639 00D30003           2431m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000010C4  0803 0000               2432m     BTST #0,D3                    ; CHECK FOR CHARACTER
000010C8  6700 0010               2433m     BEQ CONTINUE_167                ; NOTHING, CONTINUE
000010CC                          2434m  
000010CC                          2435mm     READ_CHAR D2
000010CC                 TRUE     2436mm     IFEQ DEBUG
000010CC  1439 00D30007           2437mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000010D2                          2438mm     ENDC
000010D2                 FALSE    2439mm     IFNE DEBUG
000010D2                          2440mm     ENDC
000010D2                          2441mm      
000010D2  B43C 001B               2442mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000010D6  6700 EF30               2443mm     BEQ START
000010DA                          2444mm     ENDM
000010DA                          2445m CONTINUE_167
000010DA  1639 00D30013           2446m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000010E0  0803 0000               2447m     BTST #0,D3                  ; CHECK FOR CHARACTER
000010E4  67D8                    2448m     BEQ WAIT_FOR_READY_167        ; NOTHING, CHECK AGAIN
000010E6                          2449m     
000010E6  1439 00D30017           2450m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000010EC  13C2 00E00001           2451m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000010F2                          2452m     
000010F2                          2453m     ENDM
000010F2                          2454m             PRINT_CHAR D2,D3
000010F2                          2455m WAIT_FOR_READY_169                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010F2                 TRUE     2456m     IFEQ DEBUG
000010F2  1639 00D30003           2457m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000010F8  0803 0002               2458m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000010FC  67F4                    2459m       BEQ WAIT_FOR_READY_169          ; NO SPACE, CHECK AGAIN
000010FE  13C2 00D30007           2460m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001104                          2461m     ENDC
00001104                          2462m     
00001104                 FALSE    2463m     IFNE DEBUG
00001104                          2464m     ENDC
00001104                          2465m 
00001104                          2466m     ENDM
00001104                          2467m             HEX2BIN D2,D2,A0
00001104  41F9 00001B1E           2468m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000110A  0402 0030               2469m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000110E  C4BC 000000FF           2470m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001114  1430 2000               2471m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001118                          2472m   ENDM
00001118  8E82                    2473              OR.L D2,D7
0000111A                          2474               
0000111A  E98F                    2475              LSL.L #4,D7
0000111C                          2476m             DOWNLOAD D2,D3            ; LS 4 bits    
0000111C                          2477m WAIT_FOR_READY_171                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000111C                          2478m 
0000111C  1639 00D30003           2479m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001122  0803 0000               2480m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001126  6700 0010               2481m     BEQ CONTINUE_171                ; NOTHING, CONTINUE
0000112A                          2482m  
0000112A                          2483mm     READ_CHAR D2
0000112A                 TRUE     2484mm     IFEQ DEBUG
0000112A  1439 00D30007           2485mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001130                          2486mm     ENDC
00001130                 FALSE    2487mm     IFNE DEBUG
00001130                          2488mm     ENDC
00001130                          2489mm      
00001130  B43C 001B               2490mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001134  6700 EED2               2491mm     BEQ START
00001138                          2492mm     ENDM
00001138                          2493m CONTINUE_171
00001138  1639 00D30013           2494m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000113E  0803 0000               2495m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001142  67D8                    2496m     BEQ WAIT_FOR_READY_171        ; NOTHING, CHECK AGAIN
00001144                          2497m     
00001144  1439 00D30017           2498m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000114A  13C2 00E00001           2499m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001150                          2500m     
00001150                          2501m     ENDM
00001150                          2502m             PRINT_CHAR D2,D3
00001150                          2503m WAIT_FOR_READY_173                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001150                 TRUE     2504m     IFEQ DEBUG
00001150  1639 00D30003           2505m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001156  0803 0002               2506m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000115A  67F4                    2507m       BEQ WAIT_FOR_READY_173          ; NO SPACE, CHECK AGAIN
0000115C  13C2 00D30007           2508m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001162                          2509m     ENDC
00001162                          2510m     
00001162                 FALSE    2511m     IFNE DEBUG
00001162                          2512m     ENDC
00001162                          2513m 
00001162                          2514m     ENDM
00001162                          2515m             HEX2BIN D2,D2,A0
00001162  41F9 00001B1E           2516m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001168  0402 0030               2517m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000116C  C4BC 000000FF           2518m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001172  1430 2000               2519m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001176                          2520m   ENDM
00001176  8E82                    2521              OR.L D2,D7
00001178                          2522              
00001178  7400                    2523              MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
0000117A  1407                    2524              MOVE.B D7,D2
0000117C  DC82                    2525              ADD.L D2,D6
0000117E                          2526              
0000117E  32C7                    2527              MOVE.W D7,(A1)+             ; store it!
00001180                          2528              
00001180                          2529            ENDW
00001180  6000 FE70               2530s     BRA _10000004
00001184                          2531s _10000005
00001184                          2532              
00001184                          2533            IF D5 <EQ> #1 THEN
00001184  BA7C 0001               2534s     CMP.W   #1,D5
00001188  6600 00CE               2535s     BNE _00000006
0000118C  7E00                    2536              MOVE.L #0,D7              ; D7 holds the word
0000118E                          2537                      
0000118E                          2538m             DOWNLOAD D2,D3            ; MS 4 bits
0000118E                          2539m WAIT_FOR_READY_175                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000118E                          2540m 
0000118E  1639 00D30003           2541m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001194  0803 0000               2542m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001198  6700 0010               2543m     BEQ CONTINUE_175                ; NOTHING, CONTINUE
0000119C                          2544m  
0000119C                          2545mm     READ_CHAR D2
0000119C                 TRUE     2546mm     IFEQ DEBUG
0000119C  1439 00D30007           2547mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000011A2                          2548mm     ENDC
000011A2                 FALSE    2549mm     IFNE DEBUG
000011A2                          2550mm     ENDC
000011A2                          2551mm      
000011A2  B43C 001B               2552mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000011A6  6700 EE60               2553mm     BEQ START
000011AA                          2554mm     ENDM
000011AA                          2555m CONTINUE_175
000011AA  1639 00D30013           2556m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000011B0  0803 0000               2557m     BTST #0,D3                  ; CHECK FOR CHARACTER
000011B4  67D8                    2558m     BEQ WAIT_FOR_READY_175        ; NOTHING, CHECK AGAIN
000011B6                          2559m     
000011B6  1439 00D30017           2560m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000011BC  13C2 00E00001           2561m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000011C2                          2562m     
000011C2                          2563m     ENDM
000011C2                          2564m             PRINT_CHAR D2,D3
000011C2                          2565m WAIT_FOR_READY_177                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C2                 TRUE     2566m     IFEQ DEBUG
000011C2  1639 00D30003           2567m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000011C8  0803 0002               2568m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000011CC  67F4                    2569m       BEQ WAIT_FOR_READY_177          ; NO SPACE, CHECK AGAIN
000011CE  13C2 00D30007           2570m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000011D4                          2571m     ENDC
000011D4                          2572m     
000011D4                 FALSE    2573m     IFNE DEBUG
000011D4                          2574m     ENDC
000011D4                          2575m 
000011D4                          2576m     ENDM
000011D4                          2577m             HEX2BIN D2,D2,A0
000011D4  41F9 00001B1E           2578m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000011DA  0402 0030               2579m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000011DE  C4BC 000000FF           2580m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000011E4  1430 2000               2581m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000011E8                          2582m   ENDM
000011E8  8E82                    2583              OR.L D2,D7
000011EA  E98F                    2584              LSL.L #4,D7
000011EC                          2585               
000011EC                          2586m             DOWNLOAD D2,D3            ; LS 4 bits    
000011EC                          2587m WAIT_FOR_READY_179                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EC                          2588m 
000011EC  1639 00D30003           2589m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000011F2  0803 0000               2590m     BTST #0,D3                    ; CHECK FOR CHARACTER
000011F6  6700 0010               2591m     BEQ CONTINUE_179                ; NOTHING, CONTINUE
000011FA                          2592m  
000011FA                          2593mm     READ_CHAR D2
000011FA                 TRUE     2594mm     IFEQ DEBUG
000011FA  1439 00D30007           2595mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001200                          2596mm     ENDC
00001200                 FALSE    2597mm     IFNE DEBUG
00001200                          2598mm     ENDC
00001200                          2599mm      
00001200  B43C 001B               2600mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001204  6700 EE02               2601mm     BEQ START
00001208                          2602mm     ENDM
00001208                          2603m CONTINUE_179
00001208  1639 00D30013           2604m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000120E  0803 0000               2605m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001212  67D8                    2606m     BEQ WAIT_FOR_READY_179        ; NOTHING, CHECK AGAIN
00001214                          2607m     
00001214  1439 00D30017           2608m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000121A  13C2 00E00001           2609m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001220                          2610m     
00001220                          2611m     ENDM
00001220                          2612m             PRINT_CHAR D2,D3
00001220                          2613m WAIT_FOR_READY_181                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001220                 TRUE     2614m     IFEQ DEBUG
00001220  1639 00D30003           2615m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001226  0803 0002               2616m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000122A  67F4                    2617m       BEQ WAIT_FOR_READY_181          ; NO SPACE, CHECK AGAIN
0000122C  13C2 00D30007           2618m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001232                          2619m     ENDC
00001232                          2620m     
00001232                 FALSE    2621m     IFNE DEBUG
00001232                          2622m     ENDC
00001232                          2623m 
00001232                          2624m     ENDM
00001232                          2625m             HEX2BIN D2,D2,A0
00001232  41F9 00001B1E           2626m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001238  0402 0030               2627m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000123C  C4BC 000000FF           2628m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001242  1430 2000               2629m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001246                          2630m   ENDM
00001246  8E82                    2631              OR.L D2,D7
00001248                          2632                          
00001248  DC87                    2633              ADD.L D7,D6               ; add into checksum
0000124A                          2634              
0000124A  3611                    2635              MOVE.W (A1),D3            ; get the current data and replace the top byte
0000124C  E18F                    2636              LSL.L #8,D7
0000124E  C6BC 000000FF           2637              AND.L #$00FF,D3
00001254  8687                    2638              OR.L D7,D3
00001256                          2639  
00001256  32C3                    2640              MOVE.W D3,(A1)+          ; store it!
00001258                          2641            ENDI
00001258                          2642s _00000006
00001258                          2643m           PRINT_CRLF D3
00001258                          2644mm     PRINT_CHAR #13,D3             ; CR
00001258                          2645mm WAIT_FOR_READY_184                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001258                 TRUE     2646mm     IFEQ DEBUG
00001258  1639 00D30003           2647mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000125E  0803 0002               2648mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001262  67F4                    2649mm       BEQ WAIT_FOR_READY_184          ; NO SPACE, CHECK AGAIN
00001264  13FC 000D 00D30007      2650mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000126C                          2651mm     ENDC
0000126C                          2652mm     
0000126C                 FALSE    2653mm     IFNE DEBUG
0000126C                          2654mm     ENDC
0000126C                          2655mm 
0000126C                          2656mm     ENDM
0000126C                          2657mm     PRINT_CHAR #10,D3             ; LF
0000126C                          2658mm WAIT_FOR_READY_185                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000126C                 TRUE     2659mm     IFEQ DEBUG
0000126C  1639 00D30003           2660mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001272  0803 0002               2661mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001276  67F4                    2662mm       BEQ WAIT_FOR_READY_185          ; NO SPACE, CHECK AGAIN
00001278  13FC 000A 00D30007      2663mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001280                          2664mm     ENDC
00001280                          2665mm     
00001280                 FALSE    2666mm     IFNE DEBUG
00001280                          2667mm     ENDC
00001280                          2668mm 
00001280                          2669mm     ENDM
00001280                          2670m     ENDM
00001280  43F8 0496               2671            LEA WAIT_FOR_SRECORD,A1     ; next place to go
00001284                          2672          ELSE
00001284  6000 024E               2673s     BRA _00000007
00001288                          2674s _00000005
00001288                          2675            IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00001288  BE3C 0038               2676s     CMP.B   #'8',D7
0000128C  6600 01E4               2677s     BNE.L   _00000008
00001290  7E00                    2678              MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00001292                          2679m             DOWNLOAD D2,D3            ; top byte
00001292                          2680m WAIT_FOR_READY_186                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001292                          2681m 
00001292  1639 00D30003           2682m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001298  0803 0000               2683m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000129C  6700 0010               2684m     BEQ CONTINUE_186                ; NOTHING, CONTINUE
000012A0                          2685m  
000012A0                          2686mm     READ_CHAR D2
000012A0                 TRUE     2687mm     IFEQ DEBUG
000012A0  1439 00D30007           2688mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000012A6                          2689mm     ENDC
000012A6                 FALSE    2690mm     IFNE DEBUG
000012A6                          2691mm     ENDC
000012A6                          2692mm      
000012A6  B43C 001B               2693mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000012AA  6700 ED5C               2694mm     BEQ START
000012AE                          2695mm     ENDM
000012AE                          2696m CONTINUE_186
000012AE  1639 00D30013           2697m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000012B4  0803 0000               2698m     BTST #0,D3                  ; CHECK FOR CHARACTER
000012B8  67D8                    2699m     BEQ WAIT_FOR_READY_186        ; NOTHING, CHECK AGAIN
000012BA                          2700m     
000012BA  1439 00D30017           2701m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000012C0  13C2 00E00001           2702m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000012C6                          2703m     
000012C6                          2704m     ENDM
000012C6                          2705m             HEX2BIN D2,D2,A0
000012C6  41F9 00001B1E           2706m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000012CC  0402 0030               2707m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012D0  C4BC 000000FF           2708m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000012D6  1430 2000               2709m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000012DA                          2710m   ENDM
000012DA  8E82                    2711              OR.L D2,D7
000012DC  E98F                    2712              LSL.L #4,D7
000012DE                          2713m             DOWNLOAD D2,D3         
000012DE                          2714m WAIT_FOR_READY_189                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DE                          2715m 
000012DE  1639 00D30003           2716m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000012E4  0803 0000               2717m     BTST #0,D3                    ; CHECK FOR CHARACTER
000012E8  6700 0010               2718m     BEQ CONTINUE_189                ; NOTHING, CONTINUE
000012EC                          2719m  
000012EC                          2720mm     READ_CHAR D2
000012EC                 TRUE     2721mm     IFEQ DEBUG
000012EC  1439 00D30007           2722mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000012F2                          2723mm     ENDC
000012F2                 FALSE    2724mm     IFNE DEBUG
000012F2                          2725mm     ENDC
000012F2                          2726mm      
000012F2  B43C 001B               2727mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000012F6  6700 ED10               2728mm     BEQ START
000012FA                          2729mm     ENDM
000012FA                          2730m CONTINUE_189
000012FA  1639 00D30013           2731m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001300  0803 0000               2732m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001304  67D8                    2733m     BEQ WAIT_FOR_READY_189        ; NOTHING, CHECK AGAIN
00001306                          2734m     
00001306  1439 00D30017           2735m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000130C  13C2 00E00001           2736m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001312                          2737m     
00001312                          2738m     ENDM
00001312                          2739m             HEX2BIN D2,D2,A0
00001312  41F9 00001B1E           2740m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001318  0402 0030               2741m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000131C  C4BC 000000FF           2742m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001322  1430 2000               2743m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001326                          2744m   ENDM
00001326  8E82                    2745              OR.L D2,D7
00001328                          2746          
00001328  DC87                    2747              ADD.L D7,D6               ; add top byte of address into checksum
0000132A                          2748  
0000132A  E98F                    2749              LSL.L #4,D7               ; middle byte
0000132C                          2750m             DOWNLOAD D2,D3
0000132C                          2751m WAIT_FOR_READY_192                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000132C                          2752m 
0000132C  1639 00D30003           2753m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001332  0803 0000               2754m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001336  6700 0010               2755m     BEQ CONTINUE_192                ; NOTHING, CONTINUE
0000133A                          2756m  
0000133A                          2757mm     READ_CHAR D2
0000133A                 TRUE     2758mm     IFEQ DEBUG
0000133A  1439 00D30007           2759mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001340                          2760mm     ENDC
00001340                 FALSE    2761mm     IFNE DEBUG
00001340                          2762mm     ENDC
00001340                          2763mm      
00001340  B43C 001B               2764mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001344  6700 ECC2               2765mm     BEQ START
00001348                          2766mm     ENDM
00001348                          2767m CONTINUE_192
00001348  1639 00D30013           2768m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000134E  0803 0000               2769m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001352  67D8                    2770m     BEQ WAIT_FOR_READY_192        ; NOTHING, CHECK AGAIN
00001354                          2771m     
00001354  1439 00D30017           2772m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000135A  13C2 00E00001           2773m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001360                          2774m     
00001360                          2775m     ENDM
00001360                          2776m             HEX2BIN D2,D2,A0
00001360  41F9 00001B1E           2777m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001366  0402 0030               2778m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000136A  C4BC 000000FF           2779m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001370  1430 2000               2780m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001374                          2781m   ENDM
00001374  8E82                    2782              OR.L D2,D7
00001376  E98F                    2783              LSL.L #4,D7        
00001378                          2784m             DOWNLOAD D2,D3
00001378                          2785m WAIT_FOR_READY_195                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001378                          2786m 
00001378  1639 00D30003           2787m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000137E  0803 0000               2788m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001382  6700 0010               2789m     BEQ CONTINUE_195                ; NOTHING, CONTINUE
00001386                          2790m  
00001386                          2791mm     READ_CHAR D2
00001386                 TRUE     2792mm     IFEQ DEBUG
00001386  1439 00D30007           2793mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000138C                          2794mm     ENDC
0000138C                 FALSE    2795mm     IFNE DEBUG
0000138C                          2796mm     ENDC
0000138C                          2797mm      
0000138C  B43C 001B               2798mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001390  6700 EC76               2799mm     BEQ START
00001394                          2800mm     ENDM
00001394                          2801m CONTINUE_195
00001394  1639 00D30013           2802m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000139A  0803 0000               2803m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000139E  67D8                    2804m     BEQ WAIT_FOR_READY_195        ; NOTHING, CHECK AGAIN
000013A0                          2805m     
000013A0  1439 00D30017           2806m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000013A6  13C2 00E00001           2807m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000013AC                          2808m     
000013AC                          2809m     ENDM
000013AC                          2810m             HEX2BIN D2,D2,A0
000013AC  41F9 00001B1E           2811m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000013B2  0402 0030               2812m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000013B6  C4BC 000000FF           2813m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000013BC  1430 2000               2814m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000013C0                          2815m   ENDM
000013C0  8E82                    2816              OR.L D2,D7
000013C2                          2817          
000013C2  7400                    2818              MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
000013C4  1407                    2819              MOVE.B D7,D2
000013C6  DC82                    2820              ADD.L D2,D6
000013C8                          2821            
000013C8  E98F                    2822              LSL.L #4,D7               ; bottom byte
000013CA                          2823m             DOWNLOAD D2,D3
000013CA                          2824m WAIT_FOR_READY_198                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013CA                          2825m 
000013CA  1639 00D30003           2826m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000013D0  0803 0000               2827m     BTST #0,D3                    ; CHECK FOR CHARACTER
000013D4  6700 0010               2828m     BEQ CONTINUE_198                ; NOTHING, CONTINUE
000013D8                          2829m  
000013D8                          2830mm     READ_CHAR D2
000013D8                 TRUE     2831mm     IFEQ DEBUG
000013D8  1439 00D30007           2832mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000013DE                          2833mm     ENDC
000013DE                 FALSE    2834mm     IFNE DEBUG
000013DE                          2835mm     ENDC
000013DE                          2836mm      
000013DE  B43C 001B               2837mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000013E2  6700 EC24               2838mm     BEQ START
000013E6                          2839mm     ENDM
000013E6                          2840m CONTINUE_198
000013E6  1639 00D30013           2841m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000013EC  0803 0000               2842m     BTST #0,D3                  ; CHECK FOR CHARACTER
000013F0  67D8                    2843m     BEQ WAIT_FOR_READY_198        ; NOTHING, CHECK AGAIN
000013F2                          2844m     
000013F2  1439 00D30017           2845m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000013F8  13C2 00E00001           2846m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000013FE                          2847m     
000013FE                          2848m     ENDM
000013FE                          2849m             HEX2BIN D2,D2,A0
000013FE  41F9 00001B1E           2850m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001404  0402 0030               2851m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001408  C4BC 000000FF           2852m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000140E  1430 2000               2853m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001412                          2854m   ENDM
00001412  8E82                    2855              OR.L D2,D7
00001414  E98F                    2856              LSL.L #4,D7        
00001416                          2857m             DOWNLOAD D2,D3
00001416                          2858m WAIT_FOR_READY_201                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001416                          2859m 
00001416  1639 00D30003           2860m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000141C  0803 0000               2861m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001420  6700 0010               2862m     BEQ CONTINUE_201                ; NOTHING, CONTINUE
00001424                          2863m  
00001424                          2864mm     READ_CHAR D2
00001424                 TRUE     2865mm     IFEQ DEBUG
00001424  1439 00D30007           2866mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000142A                          2867mm     ENDC
0000142A                 FALSE    2868mm     IFNE DEBUG
0000142A                          2869mm     ENDC
0000142A                          2870mm      
0000142A  B43C 001B               2871mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000142E  6700 EBD8               2872mm     BEQ START
00001432                          2873mm     ENDM
00001432                          2874m CONTINUE_201
00001432  1639 00D30013           2875m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001438  0803 0000               2876m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000143C  67D8                    2877m     BEQ WAIT_FOR_READY_201        ; NOTHING, CHECK AGAIN
0000143E                          2878m     
0000143E  1439 00D30017           2879m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001444  13C2 00E00001           2880m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000144A                          2881m     
0000144A                          2882m     ENDM
0000144A                          2883m             HEX2BIN D2,D2,A0
0000144A  41F9 00001B1E           2884m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001450  0402 0030               2885m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001454  C4BC 000000FF           2886m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000145A  1430 2000               2887m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000145E                          2888m   ENDM
0000145E  8E82                    2889              OR.L D2,D7
00001460                          2890          
00001460  7400                    2891              MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00001462  1407                    2892              MOVE.B D7,D2
00001464  DC82                    2893              ADD.L D2,D6
00001466                          2894            
00001466  2447                    2895              MOVE.L D7,A2              ; start address -> A2
00001468                          2896          
00001468  43F9 00001620           2897              LEA DOWNLOAD_DONE,A1      ; next place to go
0000146E                          2898            ELSE
0000146E  6000 0064               2899s     BRA _00000009
00001472                          2900s _00000008
00001472  41F9 00001AAA           2901              LEA UNREC,A0              ; warn for unrecognised type
00001478                          2902m             PRINT_STR A0,D3
00001478                          2903m LOOP_204
00001478  0C10 0000               2904m     CMP.B #0,(A0)                 ; 0 -> DONE
0000147C  6700 0018               2905m     BEQ EXIT_204
00001480                          2906mm     PRINT_CHAR (A0)+,D3
00001480                          2907mm WAIT_FOR_READY_205                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001480                 TRUE     2908mm     IFEQ DEBUG
00001480  1639 00D30003           2909mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001486  0803 0002               2910mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000148A  67F4                    2911mm       BEQ WAIT_FOR_READY_205          ; NO SPACE, CHECK AGAIN
0000148C  13D8 00D30007           2912mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00001492                          2913mm     ENDC
00001492                          2914mm     
00001492                 FALSE    2915mm     IFNE DEBUG
00001492                          2916mm     ENDC
00001492                          2917mm 
00001492                          2918mm     ENDM
00001492  4EF8 1478               2919m     JMP LOOP_204
00001496                          2920m EXIT_204
00001496                          2921m     ENDM
00001496                          2922m             PRINT_CHAR D7,D3
00001496                          2923m WAIT_FOR_READY_206                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001496                 TRUE     2924m     IFEQ DEBUG
00001496  1639 00D30003           2925m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000149C  0803 0002               2926m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014A0  67F4                    2927m       BEQ WAIT_FOR_READY_206          ; NO SPACE, CHECK AGAIN
000014A2  13C7 00D30007           2928m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
000014A8                          2929m     ENDC
000014A8                          2930m     
000014A8                 FALSE    2931m     IFNE DEBUG
000014A8                          2932m     ENDC
000014A8                          2933m 
000014A8                          2934m     ENDM
000014A8                          2935m             PRINT_CRLF D3
000014A8                          2936mm     PRINT_CHAR #13,D3             ; CR
000014A8                          2937mm WAIT_FOR_READY_208                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014A8                 TRUE     2938mm     IFEQ DEBUG
000014A8  1639 00D30003           2939mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000014AE  0803 0002               2940mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014B2  67F4                    2941mm       BEQ WAIT_FOR_READY_208          ; NO SPACE, CHECK AGAIN
000014B4  13FC 000D 00D30007      2942mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000014BC                          2943mm     ENDC
000014BC                          2944mm     
000014BC                 FALSE    2945mm     IFNE DEBUG
000014BC                          2946mm     ENDC
000014BC                          2947mm 
000014BC                          2948mm     ENDM
000014BC                          2949mm     PRINT_CHAR #10,D3             ; LF
000014BC                          2950mm WAIT_FOR_READY_209                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014BC                 TRUE     2951mm     IFEQ DEBUG
000014BC  1639 00D30003           2952mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000014C2  0803 0002               2953mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000014C6  67F4                    2954mm       BEQ WAIT_FOR_READY_209          ; NO SPACE, CHECK AGAIN
000014C8  13FC 000A 00D30007      2955mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000014D0                          2956mm     ENDC
000014D0                          2957mm     
000014D0                 FALSE    2958mm     IFNE DEBUG
000014D0                          2959mm     ENDC
000014D0                          2960mm 
000014D0                          2961mm     ENDM
000014D0                          2962m     ENDM
000014D0                          2963      
000014D0  4EF8 0496               2964              JMP WAIT_FOR_SRECORD      ; ignore any other type    
000014D4                          2965            ENDI
000014D4                          2966s _00000009
000014D4                          2967          ENDI
000014D4                          2968s _00000007
000014D4                          2969        ENDI
000014D4                          2970s _00000004
000014D4                          2971      ENDI
000014D4                          2972s _00000001
000014D4                          2973      
000014D4  4686                    2974      NOT.L D6                        ; ones complement the checksum
000014D6  0286 000000FF           2975      ANDI.L #$FF,D6                  ; and take the LSByte
000014DC                          2976          
000014DC  7E00                    2977      MOVE.L #0,D7                    ; read the checksum from the data stream
000014DE                          2978m     DOWNLOAD D2,D3                  ; top byte
000014DE                          2979m WAIT_FOR_READY_210                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014DE                          2980m 
000014DE  1639 00D30003           2981m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000014E4  0803 0000               2982m     BTST #0,D3                    ; CHECK FOR CHARACTER
000014E8  6700 0010               2983m     BEQ CONTINUE_210                ; NOTHING, CONTINUE
000014EC                          2984m  
000014EC                          2985mm     READ_CHAR D2
000014EC                 TRUE     2986mm     IFEQ DEBUG
000014EC  1439 00D30007           2987mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000014F2                          2988mm     ENDC
000014F2                 FALSE    2989mm     IFNE DEBUG
000014F2                          2990mm     ENDC
000014F2                          2991mm      
000014F2  B43C 001B               2992mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000014F6  6700 EB10               2993mm     BEQ START
000014FA                          2994mm     ENDM
000014FA                          2995m CONTINUE_210
000014FA  1639 00D30013           2996m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00001500  0803 0000               2997m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001504  67D8                    2998m     BEQ WAIT_FOR_READY_210        ; NOTHING, CHECK AGAIN
00001506                          2999m     
00001506  1439 00D30017           3000m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000150C  13C2 00E00001           3001m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00001512                          3002m     
00001512                          3003m     ENDM
00001512                          3004m     HEX2BIN D2,D2,A0
00001512  41F9 00001B1E           3005m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001518  0402 0030               3006m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000151C  C4BC 000000FF           3007m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001522  1430 2000               3008m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001526                          3009m   ENDM
00001526  8E82                    3010      OR.L D2,D7
00001528  E98F                    3011      LSL.L #4,D7
0000152A                          3012m     DOWNLOAD D2,D3                  ; bottom byte
0000152A                          3013m WAIT_FOR_READY_213                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000152A                          3014m 
0000152A  1639 00D30003           3015m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00001530  0803 0000               3016m     BTST #0,D3                    ; CHECK FOR CHARACTER
00001534  6700 0010               3017m     BEQ CONTINUE_213                ; NOTHING, CONTINUE
00001538                          3018m  
00001538                          3019mm     READ_CHAR D2
00001538                 TRUE     3020mm     IFEQ DEBUG
00001538  1439 00D30007           3021mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000153E                          3022mm     ENDC
0000153E                 FALSE    3023mm     IFNE DEBUG
0000153E                          3024mm     ENDC
0000153E                          3025mm      
0000153E  B43C 001B               3026mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001542  6700 EAC4               3027mm     BEQ START
00001546                          3028mm     ENDM
00001546                          3029m CONTINUE_213
00001546  1639 00D30013           3030m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000154C  0803 0000               3031m     BTST #0,D3                  ; CHECK FOR CHARACTER
00001550  67D8                    3032m     BEQ WAIT_FOR_READY_213        ; NOTHING, CHECK AGAIN
00001552                          3033m     
00001552  1439 00D30017           3034m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00001558  13C2 00E00001           3035m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000155E                          3036m     
0000155E                          3037m     ENDM
0000155E                          3038m     HEX2BIN D2,D2,A0
0000155E  41F9 00001B1E           3039m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001564  0402 0030               3040m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001568  C4BC 000000FF           3041m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000156E  1430 2000               3042m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00001572                          3043m   ENDM
00001572  8E82                    3044      OR.L D2,D7
00001574                          3045                  
00001574                          3046      IF.B D7 <NE> D6 THEN.L
00001574  BE06                    3047s     CMP.B   D6,D7
00001576  6700 00A6               3048s     BEQ.L   _0000000A
0000157A  41F9 00001AD0           3049        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00001580                          3050m       PRINT_STR A0,D3
00001580                          3051m LOOP_216
00001580  0C10 0000               3052m     CMP.B #0,(A0)                 ; 0 -> DONE
00001584  6700 0018               3053m     BEQ EXIT_216
00001588                          3054mm     PRINT_CHAR (A0)+,D3
00001588                          3055mm WAIT_FOR_READY_217                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001588                 TRUE     3056mm     IFEQ DEBUG
00001588  1639 00D30003           3057mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000158E  0803 0002               3058mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001592  67F4                    3059mm       BEQ WAIT_FOR_READY_217          ; NO SPACE, CHECK AGAIN
00001594  13D8 00D30007           3060mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000159A                          3061mm     ENDC
0000159A                          3062mm     
0000159A                 FALSE    3063mm     IFNE DEBUG
0000159A                          3064mm     ENDC
0000159A                          3065mm 
0000159A                          3066mm     ENDM
0000159A  4EF8 1580               3067m     JMP LOOP_216
0000159E                          3068m EXIT_216
0000159E                          3069m     ENDM
0000159E                          3070m       PRINT_REG D4,D3,D6,D7,A0
0000159E                          3071mm     PRINT_CHAR #'0',D3          ;0X HEADER
0000159E                          3072mm WAIT_FOR_READY_219                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000159E                 TRUE     3073mm     IFEQ DEBUG
0000159E  1639 00D30003           3074mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015A4  0803 0002               3075mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015A8  67F4                    3076mm       BEQ WAIT_FOR_READY_219          ; NO SPACE, CHECK AGAIN
000015AA  13FC 0030 00D30007      3077mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000015B2                          3078mm     ENDC
000015B2                          3079mm     
000015B2                 FALSE    3080mm     IFNE DEBUG
000015B2                          3081mm     ENDC
000015B2                          3082mm 
000015B2                          3083mm     ENDM
000015B2                          3084mm     PRINT_CHAR #'x',D3
000015B2                          3085mm WAIT_FOR_READY_220                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015B2                 TRUE     3086mm     IFEQ DEBUG
000015B2  1639 00D30003           3087mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015B8  0803 0002               3088mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015BC  67F4                    3089mm       BEQ WAIT_FOR_READY_220          ; NO SPACE, CHECK AGAIN
000015BE  13FC 0078 00D30007      3090mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000015C6                          3091mm     ENDC
000015C6                          3092mm     
000015C6                 FALSE    3093mm     IFNE DEBUG
000015C6                          3094mm     ENDC
000015C6                          3095mm 
000015C6                          3096mm     ENDM
000015C6  7E07                    3097m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000015C8                          3098m LOOP_218
000015C8                          3099mm     BIN2HEX D4,D6,A0
000015C8  41F9 00001B0E           3100mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
000015CE  E99C                    3101mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000015D0  1C04                    3102mm   MOVE.B D4,D6
000015D2  0286 0000000F           3103mm   ANDI.L #$F,D6
000015D8  1C30 6000               3104mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
000015DC                          3105mm   ENDM
000015DC                          3106mm     PRINT_CHAR D6,D3
000015DC                          3107mm WAIT_FOR_READY_222                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015DC                 TRUE     3108mm     IFEQ DEBUG
000015DC  1639 00D30003           3109mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015E2  0803 0002               3110mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015E6  67F4                    3111mm       BEQ WAIT_FOR_READY_222          ; NO SPACE, CHECK AGAIN
000015E8  13C6 00D30007           3112mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
000015EE                          3113mm     ENDC
000015EE                          3114mm     
000015EE                 FALSE    3115mm     IFNE DEBUG
000015EE                          3116mm     ENDC
000015EE                          3117mm 
000015EE                          3118mm     ENDM
000015EE  57CF FFD8               3119m     DBEQ D7,LOOP_218
000015F2                          3120m     ENDM
000015F2                          3121m       PRINT_CRLF D3
000015F2                          3122mm     PRINT_CHAR #13,D3             ; CR
000015F2                          3123mm WAIT_FOR_READY_224                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015F2                 TRUE     3124mm     IFEQ DEBUG
000015F2  1639 00D30003           3125mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000015F8  0803 0002               3126mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000015FC  67F4                    3127mm       BEQ WAIT_FOR_READY_224          ; NO SPACE, CHECK AGAIN
000015FE  13FC 000D 00D30007      3128mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00001606                          3129mm     ENDC
00001606                          3130mm     
00001606                 FALSE    3131mm     IFNE DEBUG
00001606                          3132mm     ENDC
00001606                          3133mm 
00001606                          3134mm     ENDM
00001606                          3135mm     PRINT_CHAR #10,D3             ; LF
00001606                          3136mm WAIT_FOR_READY_225                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001606                 TRUE     3137mm     IFEQ DEBUG
00001606  1639 00D30003           3138mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000160C  0803 0002               3139mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001610  67F4                    3140mm       BEQ WAIT_FOR_READY_225          ; NO SPACE, CHECK AGAIN
00001612  13FC 000A 00D30007      3141mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000161A                          3142mm     ENDC
0000161A                          3143mm     
0000161A                 FALSE    3144mm     IFNE DEBUG
0000161A                          3145mm     ENDC
0000161A                          3146mm 
0000161A                          3147mm     ENDM
0000161A                          3148m     ENDM
0000161A  4EF8 0186               3149        JMP MAIN_LOOP
0000161E                          3150      ENDI
0000161E                          3151s _0000000A
0000161E                          3152      
0000161E  4ED1                    3153      JMP (A1)
00001620                          3154  DOWNLOAD_DONE
00001620                          3155m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00001620                          3156mm     PRINT_CHAR #'0',D3          ;0X HEADER
00001620                          3157mm WAIT_FOR_READY_227                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001620                 TRUE     3158mm     IFEQ DEBUG
00001620  1639 00D30003           3159mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001626  0803 0002               3160mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000162A  67F4                    3161mm       BEQ WAIT_FOR_READY_227          ; NO SPACE, CHECK AGAIN
0000162C  13FC 0030 00D30007      3162mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00001634                          3163mm     ENDC
00001634                          3164mm     
00001634                 FALSE    3165mm     IFNE DEBUG
00001634                          3166mm     ENDC
00001634                          3167mm 
00001634                          3168mm     ENDM
00001634                          3169mm     PRINT_CHAR #'x',D3
00001634                          3170mm WAIT_FOR_READY_228                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001634                 TRUE     3171mm     IFEQ DEBUG
00001634  1639 00D30003           3172mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000163A  0803 0002               3173mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000163E  67F4                    3174mm       BEQ WAIT_FOR_READY_228          ; NO SPACE, CHECK AGAIN
00001640  13FC 0078 00D30007      3175mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00001648                          3176mm     ENDC
00001648                          3177mm     
00001648                 FALSE    3178mm     IFNE DEBUG
00001648                          3179mm     ENDC
00001648                          3180mm 
00001648                          3181mm     ENDM
00001648  7C07                    3182m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000164A                          3183m LOOP_226
0000164A                          3184mm     BIN2HEX D4,D7,A0
0000164A  41F9 00001B0E           3185mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00001650  E99C                    3186mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001652  1E04                    3187mm   MOVE.B D4,D7
00001654  0287 0000000F           3188mm   ANDI.L #$F,D7
0000165A  1E30 7000               3189mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0000165E                          3190mm   ENDM
0000165E                          3191mm     PRINT_CHAR D7,D3
0000165E                          3192mm WAIT_FOR_READY_230                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000165E                 TRUE     3193mm     IFEQ DEBUG
0000165E  1639 00D30003           3194mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001664  0803 0002               3195mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001668  67F4                    3196mm       BEQ WAIT_FOR_READY_230          ; NO SPACE, CHECK AGAIN
0000166A  13C7 00D30007           3197mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00001670                          3198mm     ENDC
00001670                          3199mm     
00001670                 FALSE    3200mm     IFNE DEBUG
00001670                          3201mm     ENDC
00001670                          3202mm 
00001670                          3203mm     ENDM
00001670  57CE FFD8               3204m     DBEQ D6,LOOP_226
00001674                          3205m     ENDM
00001674  41F9 00001A88           3206      LEA READ,A0
0000167A                          3207m     PRINT_STR A0,D3
0000167A                          3208m LOOP_231
0000167A  0C10 0000               3209m     CMP.B #0,(A0)                 ; 0 -> DONE
0000167E  6700 0018               3210m     BEQ EXIT_231
00001682                          3211mm     PRINT_CHAR (A0)+,D3
00001682                          3212mm WAIT_FOR_READY_232                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001682                 TRUE     3213mm     IFEQ DEBUG
00001682  1639 00D30003           3214mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001688  0803 0002               3215mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000168C  67F4                    3216mm       BEQ WAIT_FOR_READY_232          ; NO SPACE, CHECK AGAIN
0000168E  13D8 00D30007           3217mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00001694                          3218mm     ENDC
00001694                          3219mm     
00001694                 FALSE    3220mm     IFNE DEBUG
00001694                          3221mm     ENDC
00001694                          3222mm 
00001694                          3223mm     ENDM
00001694  4EF8 167A               3224m     JMP LOOP_231
00001698                          3225m EXIT_231
00001698                          3226m     ENDM
00001698  2E0A                    3227      MOVE.L A2,D7                    ; set address accumulator to start address
0000169A                          3228m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
0000169A                          3229mm     PRINT_CHAR #'0',D3          ;0X HEADER
0000169A                          3230mm WAIT_FOR_READY_234                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000169A                 TRUE     3231mm     IFEQ DEBUG
0000169A  1639 00D30003           3232mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016A0  0803 0002               3233mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016A4  67F4                    3234mm       BEQ WAIT_FOR_READY_234          ; NO SPACE, CHECK AGAIN
000016A6  13FC 0030 00D30007      3235mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000016AE                          3236mm     ENDC
000016AE                          3237mm     
000016AE                 FALSE    3238mm     IFNE DEBUG
000016AE                          3239mm     ENDC
000016AE                          3240mm 
000016AE                          3241mm     ENDM
000016AE                          3242mm     PRINT_CHAR #'x',D3
000016AE                          3243mm WAIT_FOR_READY_235                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016AE                 TRUE     3244mm     IFEQ DEBUG
000016AE  1639 00D30003           3245mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016B4  0803 0002               3246mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016B8  67F4                    3247mm       BEQ WAIT_FOR_READY_235          ; NO SPACE, CHECK AGAIN
000016BA  13FC 0078 00D30007      3248mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000016C2                          3249mm     ENDC
000016C2                          3250mm     
000016C2                 FALSE    3251mm     IFNE DEBUG
000016C2                          3252mm     ENDC
000016C2                          3253mm 
000016C2                          3254mm     ENDM
000016C2  7C07                    3255m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000016C4                          3256m LOOP_233
000016C4                          3257mm     BIN2HEX D7,D2,A0
000016C4  41F9 00001B0E           3258mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
000016CA  E99F                    3259mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000016CC  1407                    3260mm   MOVE.B D7,D2
000016CE  0282 0000000F           3261mm   ANDI.L #$F,D2
000016D4  1430 2000               3262mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
000016D8                          3263mm   ENDM
000016D8                          3264mm     PRINT_CHAR D2,D3
000016D8                          3265mm WAIT_FOR_READY_237                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016D8                 TRUE     3266mm     IFEQ DEBUG
000016D8  1639 00D30003           3267mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016DE  0803 0002               3268mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016E2  67F4                    3269mm       BEQ WAIT_FOR_READY_237          ; NO SPACE, CHECK AGAIN
000016E4  13C2 00D30007           3270mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000016EA                          3271mm     ENDC
000016EA                          3272mm     
000016EA                 FALSE    3273mm     IFNE DEBUG
000016EA                          3274mm     ENDC
000016EA                          3275mm 
000016EA                          3276mm     ENDM
000016EA  57CE FFD8               3277m     DBEQ D6,LOOP_233
000016EE                          3278m     ENDM
000016EE                          3279m     PRINT_CRLF D3     
000016EE                          3280mm     PRINT_CHAR #13,D3             ; CR
000016EE                          3281mm WAIT_FOR_READY_239                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016EE                 TRUE     3282mm     IFEQ DEBUG
000016EE  1639 00D30003           3283mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000016F4  0803 0002               3284mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000016F8  67F4                    3285mm       BEQ WAIT_FOR_READY_239          ; NO SPACE, CHECK AGAIN
000016FA  13FC 000D 00D30007      3286mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00001702                          3287mm     ENDC
00001702                          3288mm     
00001702                 FALSE    3289mm     IFNE DEBUG
00001702                          3290mm     ENDC
00001702                          3291mm 
00001702                          3292mm     ENDM
00001702                          3293mm     PRINT_CHAR #10,D3             ; LF
00001702                          3294mm WAIT_FOR_READY_240                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001702                 TRUE     3295mm     IFEQ DEBUG
00001702  1639 00D30003           3296mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001708  0803 0002               3297mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000170C  67F4                    3298mm       BEQ WAIT_FOR_READY_240          ; NO SPACE, CHECK AGAIN
0000170E  13FC 000A 00D30007      3299mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001716                          3300mm     ENDC
00001716                          3301mm     
00001716                 FALSE    3302mm     IFNE DEBUG
00001716                          3303mm     ENDC
00001716                          3304mm 
00001716                          3305mm     ENDM
00001716                          3306m     ENDM
00001716                          3307          
00001716  4EF8 0186               3308      JMP MAIN_LOOP
0000171A                          3309      
0000171A  2047                    3310  G   MOVE.L D7,A0                    ; address accumulator -> address register
0000171C  3E3C 0000               3311      MOVE #0,D7                      ; clear the now used address accumulator
00001720  4ED0                    3312      JMP (A0)                        ; jump to it!
00001722                          3313      
00001722  207C 00200000           3314  Z   MOVE.L #RAM,A0                  ; address of RAM
00001728  7000                    3315      MOVE.L #0,D0                    ; number of bytes
0000172A                          3316     
0000172A                          3317      WHILE.L D0 <LE> #$40000 DO      ; read the data bytes
0000172A                          3318s _10000006
0000172A  B0BC 00040000           3319s     CMP.L   #$40000,D0
00001730  6E00 001A               3320s     BGT _10000007
00001734                          3321         
00001734  2200                    3322        MOVE.L D0,D1                  ; progress update
00001736  E089                    3323        LSR.L #8,D1 
00001738  E089                    3324        LSR.L #8,D1
0000173A  0281 0000000F           3325        ANDI.L #$F,D1
00001740  13C1 00E00001           3326        MOVE.B D1,DISPLAY
00001746                          3327  
00001746  20C0                    3328        MOVE.L D0,(A0)+ 
00001748  5880                    3329        ADD.L #4,D0
0000174A                          3330      ENDW
0000174A  60DE                    3331s     BRA _10000006
0000174C                          3332s _10000007
0000174C                          3333   
0000174C  207C 00200000           3334      MOVE.L #RAM,A0              ; address of RAM
00001752  7000                    3335      MOVE.L #0,D0                ; number of bytes
00001754                          3336     
00001754                          3337      WHILE.L D0 <LE> #$40000 DO ; read the data bytes
00001754                          3338s _10000008
00001754  B0BC 00040000           3339s     CMP.L   #$40000,D0
0000175A  6E00 00CA               3340s     BGT _10000009
0000175E                          3341  
0000175E  2200                    3342        MOVE.L D0,D1              ; progress update
00001760  E089                    3343        LSR.L #8,D1
00001762  E089                    3344        LSR.L #8,D1
00001764  0281 0000000F           3345        ANDI.L #$F,D1
0000176A  13C1 00E00001           3346        MOVE.B D1,DISPLAY
00001770                          3347  
00001770  2218                    3348        MOVE.L (A0)+,D1
00001772                          3349        
00001772                          3350        IF.L D0 <EQ> D1 THEN
00001772  B081                    3351s     CMP.L   D1,D0
00001774  6600 0006               3352s     BNE _0000000B
00001778  6000 00A6               3353          BRA OK
0000177C                          3354        ENDI 
0000177C                          3355s _0000000B
0000177C                          3356        
0000177C  43F9 00001AF6           3357        LEA RAM_ERROR,A1
00001782                          3358m       PRINT_STR A1,D1
00001782                          3359m LOOP_241
00001782  0C11 0000               3360m     CMP.B #0,(A1)                 ; 0 -> DONE
00001786  6700 0018               3361m     BEQ EXIT_241
0000178A                          3362mm     PRINT_CHAR (A1)+,D1
0000178A                          3363mm WAIT_FOR_READY_242                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000178A                 TRUE     3364mm     IFEQ DEBUG
0000178A  1239 00D30003           3365mm       MOVE.B DUART_SRA,D1           ; READ STATUS REGISTER
00001790  0801 0002               3366mm       BTST #2,D1                    ; CHECK FOR SPACE TO SEND
00001794  67F4                    3367mm       BEQ WAIT_FOR_READY_242          ; NO SPACE, CHECK AGAIN
00001796  13D9 00D30007           3368mm       MOVE.B (A1)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000179C                          3369mm     ENDC
0000179C                          3370mm     
0000179C                 FALSE    3371mm     IFNE DEBUG
0000179C                          3372mm     ENDC
0000179C                          3373mm 
0000179C                          3374mm     ENDM
0000179C  4EF8 1782               3375m     JMP LOOP_241
000017A0                          3376m EXIT_241
000017A0                          3377m     ENDM
000017A0  2208                    3378        MOVE.L A0,D1
000017A2  5981                    3379        SUB.L #4,D1
000017A4                          3380m       PRINT_REG D1,D3,D2,D6,A1       ; print out failure address
000017A4                          3381mm     PRINT_CHAR #'0',D3          ;0X HEADER
000017A4                          3382mm WAIT_FOR_READY_244                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017A4                 TRUE     3383mm     IFEQ DEBUG
000017A4  1639 00D30003           3384mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000017AA  0803 0002               3385mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000017AE  67F4                    3386mm       BEQ WAIT_FOR_READY_244          ; NO SPACE, CHECK AGAIN
000017B0  13FC 0030 00D30007      3387mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
000017B8                          3388mm     ENDC
000017B8                          3389mm     
000017B8                 FALSE    3390mm     IFNE DEBUG
000017B8                          3391mm     ENDC
000017B8                          3392mm 
000017B8                          3393mm     ENDM
000017B8                          3394mm     PRINT_CHAR #'x',D3
000017B8                          3395mm WAIT_FOR_READY_245                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017B8                 TRUE     3396mm     IFEQ DEBUG
000017B8  1639 00D30003           3397mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000017BE  0803 0002               3398mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000017C2  67F4                    3399mm       BEQ WAIT_FOR_READY_245          ; NO SPACE, CHECK AGAIN
000017C4  13FC 0078 00D30007      3400mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
000017CC                          3401mm     ENDC
000017CC                          3402mm     
000017CC                 FALSE    3403mm     IFNE DEBUG
000017CC                          3404mm     ENDC
000017CC                          3405mm 
000017CC                          3406mm     ENDM
000017CC  7C07                    3407m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000017CE                          3408m LOOP_243
000017CE                          3409mm     BIN2HEX D1,D2,A1
000017CE  43F9 00001B0E           3410mm   LEA BIN2HEX_LUT,A1                ; LOAD THE LOOKUP TABLE
000017D4  E999                    3411mm   ROL.L #4,D1                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000017D6  1401                    3412mm   MOVE.B D1,D2
000017D8  0282 0000000F           3413mm   ANDI.L #$F,D2
000017DE  1431 2000               3414mm   MOVE.B 0(A1,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
000017E2                          3415mm   ENDM
000017E2                          3416mm     PRINT_CHAR D2,D3
000017E2                          3417mm WAIT_FOR_READY_247                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017E2                 TRUE     3418mm     IFEQ DEBUG
000017E2  1639 00D30003           3419mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000017E8  0803 0002               3420mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000017EC  67F4                    3421mm       BEQ WAIT_FOR_READY_247          ; NO SPACE, CHECK AGAIN
000017EE  13C2 00D30007           3422mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000017F4                          3423mm     ENDC
000017F4                          3424mm     
000017F4                 FALSE    3425mm     IFNE DEBUG
000017F4                          3426mm     ENDC
000017F4                          3427mm 
000017F4                          3428mm     ENDM
000017F4  57CE FFD8               3429m     DBEQ D6,LOOP_243
000017F8                          3430m     ENDM
000017F8                          3431m       PRINT_CRLF D3
000017F8                          3432mm     PRINT_CHAR #13,D3             ; CR
000017F8                          3433mm WAIT_FOR_READY_249                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017F8                 TRUE     3434mm     IFEQ DEBUG
000017F8  1639 00D30003           3435mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000017FE  0803 0002               3436mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001802  67F4                    3437mm       BEQ WAIT_FOR_READY_249          ; NO SPACE, CHECK AGAIN
00001804  13FC 000D 00D30007      3438mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000180C                          3439mm     ENDC
0000180C                          3440mm     
0000180C                 FALSE    3441mm     IFNE DEBUG
0000180C                          3442mm     ENDC
0000180C                          3443mm 
0000180C                          3444mm     ENDM
0000180C                          3445mm     PRINT_CHAR #10,D3             ; LF
0000180C                          3446mm WAIT_FOR_READY_250                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000180C                 TRUE     3447mm     IFEQ DEBUG
0000180C  1639 00D30003           3448mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001812  0803 0002               3449mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001816  67F4                    3450mm       BEQ WAIT_FOR_READY_250          ; NO SPACE, CHECK AGAIN
00001818  13FC 000A 00D30007      3451mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00001820                          3452mm     ENDC
00001820                          3453mm     
00001820                 FALSE    3454mm     IFNE DEBUG
00001820                          3455mm     ENDC
00001820                          3456mm 
00001820                          3457mm     ENDM
00001820                          3458m     ENDM
00001820                          3459  OK    
00001820  5880                    3460        ADD.L #4,D0
00001822                          3461      ENDW
00001822  6000 FF30               3462s     BRA _10000008
00001826                          3463s _10000009
00001826                          3464      
00001826  4EF8 0186               3465      JMP MAIN_LOOP
0000182A                          3466    
0000182A  7A00                    3467  L   MOVE.L #0,D5                    ; D5 will be the length  to write            
0000182C                          3468  
0000182C                          3469m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
0000182C                          3470m WAIT_FOR_READY_251                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000182C                          3471m 
0000182C                 TRUE     3472m     IFEQ DEBUG
0000182C  1639 00D30003           3473m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00001832  0803 0000               3474m       BTST #0,D3                    ; CHECK FOR CHARACTER
00001836  67F4                    3475m       BEQ WAIT_FOR_READY_251          ; NOTHING, CHECK AGAIN
00001838                          3476m     ENDC
00001838                          3477m     
00001838                          3478mm     READ_CHAR D2
00001838                 TRUE     3479mm     IFEQ DEBUG
00001838  1439 00D30007           3480mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000183E                          3481mm     ENDC
0000183E                 FALSE    3482mm     IFNE DEBUG
0000183E                          3483mm     ENDC
0000183E                          3484mm      
0000183E  B43C 001B               3485mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00001842  6700 E7C4               3486mm     BEQ START
00001846                          3487mm     ENDM
00001846                          3488m 
00001846                 TRUE     3489m     IFEQ DEBUG
00001846                          3490mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
00001846                          3491mm WAIT_FOR_READY_253                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001846                 TRUE     3492mm     IFEQ DEBUG
00001846  1639 00D30003           3493mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000184C  0803 0002               3494mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001850  67F4                    3495mm       BEQ WAIT_FOR_READY_253          ; NO SPACE, CHECK AGAIN
00001852  13C2 00D30007           3496mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00001858                          3497mm     ENDC
00001858                          3498mm     
00001858                 FALSE    3499mm     IFNE DEBUG
00001858                          3500mm     ENDC
00001858                          3501mm 
00001858                          3502mm     ENDM
00001858                          3503m     ENDC
00001858                          3504m     ENDM
00001858                          3505m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00001858  41F9 00001B1E           3506m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000185E  0402 0030               3507m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001862  C4BC 000000FF           3508m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00001868  1430 2000               3509m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000186C                          3510m   ENDM
0000186C  1A02                    3511      MOVE.B D2,D5                    ; put at bottom of D5
0000186E                          3512  
0000186E  3C3C 0002               3513      MOVE #2,D6                      ; 3 bytes left to read
00001872                          3514      
00001872                          3515  READ_LENGTH
00001872  E98D                    3516      LSL.L #4,D5                     ; make what we have so far more significant
00001874                          3517m     WAIT_CHAR D2,D3                 ; next character -> D2
00001874                          3518m WAIT_FOR_READY_255                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001874                          3519m 
00001874                 TRUE     3520m     IFEQ DEBUG
00001874  1639 00D30003           3521m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
0000187A  0803 0000               3522m       BTST #0,D3                    ; CHECK FOR CHARACTER
0000187E  67F4                    3523m       BEQ WAIT_FOR_READY_255          ; NOTHING, CHECK AGAIN
00001880                          3524m     ENDC
00001880                          3525m     
00001880                          3526mm     READ_CHAR D2
00001880                 TRUE     3527mm     IFEQ DEBUG
00001880  1439 00D30007           3528mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00001886                          3529mm     ENDC
00001886                 FALSE    3530mm     IFNE DEBUG
00001886                          3531mm     ENDC
00001886                          3532mm      
00001886  B43C 001B               3533mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000188A  6700 E77C               3534mm     BEQ START
0000188E                          3535mm     ENDM
0000188E                          3536m 
0000188E                 TRUE     3537m     IFEQ DEBUG
0000188E                          3538mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
0000188E                          3539mm WAIT_FOR_READY_257                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000188E                 TRUE     3540mm     IFEQ DEBUG
0000188E  1639 00D30003           3541mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001894  0803 0002               3542mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001898  67F4                    3543mm       BEQ WAIT_FOR_READY_257          ; NO SPACE, CHECK AGAIN
0000189A  13C2 00D30007           3544mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000018A0                          3545mm     ENDC
000018A0                          3546mm     
000018A0                 FALSE    3547mm     IFNE DEBUG
000018A0                          3548mm     ENDC
000018A0                          3549mm 
000018A0                          3550mm     ENDM
000018A0                          3551m     ENDC
000018A0                          3552m     ENDM
000018A0                          3553m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000018A0  41F9 00001B1E           3554m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000018A6  0402 0030               3555m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000018AA  C4BC 000000FF           3556m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000018B0  1430 2000               3557m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000018B4                          3558m   ENDM
000018B4  8A02                    3559      OR.B D2,D5
000018B6  023C 00FB               3560      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
000018BA  57CE FFB6               3561      DBEQ D6,READ_LENGTH
000018BE                          3562          
000018BE                          3563m     PRINT_CRLF D3
000018BE                          3564mm     PRINT_CHAR #13,D3             ; CR
000018BE                          3565mm WAIT_FOR_READY_260                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018BE                 TRUE     3566mm     IFEQ DEBUG
000018BE  1639 00D30003           3567mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000018C4  0803 0002               3568mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000018C8  67F4                    3569mm       BEQ WAIT_FOR_READY_260          ; NO SPACE, CHECK AGAIN
000018CA  13FC 000D 00D30007      3570mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
000018D2                          3571mm     ENDC
000018D2                          3572mm     
000018D2                 FALSE    3573mm     IFNE DEBUG
000018D2                          3574mm     ENDC
000018D2                          3575mm 
000018D2                          3576mm     ENDM
000018D2                          3577mm     PRINT_CHAR #10,D3             ; LF
000018D2                          3578mm WAIT_FOR_READY_261                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018D2                 TRUE     3579mm     IFEQ DEBUG
000018D2  1639 00D30003           3580mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000018D8  0803 0002               3581mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000018DC  67F4                    3582mm       BEQ WAIT_FOR_READY_261          ; NO SPACE, CHECK AGAIN
000018DE  13FC 000A 00D30007      3583mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000018E6                          3584mm     ENDC
000018E6                          3585mm     
000018E6                 FALSE    3586mm     IFNE DEBUG
000018E6                          3587mm     ENDC
000018E6                          3588mm 
000018E6                          3589mm     ENDM
000018E6                          3590m     ENDM
000018E6                          3591  
000018E6  207C 00000000           3592      MOVE.L #ROM,A0                  ; start of ROM
000018EC                          3593      
000018EC  2247                    3594      MOVE.L D7,A1                    ; address accumulator -> address register
000018EE  7E00                    3595      MOVE.L #0,D7                    ; clear the now used address accumulator
000018F0                          3596  
000018F0  023C 00FB               3597      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
000018F4                          3598      WHILE D5 <GT> #0 DO
000018F4                          3599s _1000000A
000018F4  BA7C 0000               3600s     CMP.W   #0,D5
000018F8  6F00 0088               3601s     BLE _1000000B
000018FC  5985                    3602        SUB.L #4,D5
000018FE  20D9                    3603        MOVE.L (A1)+,(A0)+            ; write the data
00001900                          3604    
00001900  2008                    3605        MOVE.L A0,D0
00001902                          3606m       PRINT_REG D0,D3,D7,D6,A2
00001902                          3607mm     PRINT_CHAR #'0',D3          ;0X HEADER
00001902                          3608mm WAIT_FOR_READY_263                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001902                 TRUE     3609mm     IFEQ DEBUG
00001902  1639 00D30003           3610mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001908  0803 0002               3611mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000190C  67F4                    3612mm       BEQ WAIT_FOR_READY_263          ; NO SPACE, CHECK AGAIN
0000190E  13FC 0030 00D30007      3613mm       MOVE.B #'0',DUART_TXA           ; SEND THE NEXT CHARACTER
00001916                          3614mm     ENDC
00001916                          3615mm     
00001916                 FALSE    3616mm     IFNE DEBUG
00001916                          3617mm     ENDC
00001916                          3618mm 
00001916                          3619mm     ENDM
00001916                          3620mm     PRINT_CHAR #'x',D3
00001916                          3621mm WAIT_FOR_READY_264                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001916                 TRUE     3622mm     IFEQ DEBUG
00001916  1639 00D30003           3623mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000191C  0803 0002               3624mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001920  67F4                    3625mm       BEQ WAIT_FOR_READY_264          ; NO SPACE, CHECK AGAIN
00001922  13FC 0078 00D30007      3626mm       MOVE.B #'x',DUART_TXA           ; SEND THE NEXT CHARACTER
0000192A                          3627mm     ENDC
0000192A                          3628mm     
0000192A                 FALSE    3629mm     IFNE DEBUG
0000192A                          3630mm     ENDC
0000192A                          3631mm 
0000192A                          3632mm     ENDM
0000192A  7C07                    3633m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000192C                          3634m LOOP_262
0000192C                          3635mm     BIN2HEX D0,D7,A2
0000192C  45F9 00001B0E           3636mm   LEA BIN2HEX_LUT,A2                ; LOAD THE LOOKUP TABLE
00001932  E998                    3637mm   ROL.L #4,D0                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001934  1E00                    3638mm   MOVE.B D0,D7
00001936  0287 0000000F           3639mm   ANDI.L #$F,D7
0000193C  1E32 7000               3640mm   MOVE.B 0(A2,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00001940                          3641mm   ENDM
00001940                          3642mm     PRINT_CHAR D7,D3
00001940                          3643mm WAIT_FOR_READY_266                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001940                 TRUE     3644mm     IFEQ DEBUG
00001940  1639 00D30003           3645mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001946  0803 0002               3646mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000194A  67F4                    3647mm       BEQ WAIT_FOR_READY_266          ; NO SPACE, CHECK AGAIN
0000194C  13C7 00D30007           3648mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00001952                          3649mm     ENDC
00001952                          3650mm     
00001952                 FALSE    3651mm     IFNE DEBUG
00001952                          3652mm     ENDC
00001952                          3653mm 
00001952                          3654mm     ENDM
00001952  57CE FFD8               3655m     DBEQ D6,LOOP_262
00001956                          3656m     ENDM
00001956                          3657m       PRINT_CRLF D3
00001956                          3658mm     PRINT_CHAR #13,D3             ; CR
00001956                          3659mm WAIT_FOR_READY_268                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001956                 TRUE     3660mm     IFEQ DEBUG
00001956  1639 00D30003           3661mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000195C  0803 0002               3662mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001960  67F4                    3663mm       BEQ WAIT_FOR_READY_268          ; NO SPACE, CHECK AGAIN
00001962  13FC 000D 00D30007      3664mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000196A                          3665mm     ENDC
0000196A                          3666mm     
0000196A                 FALSE    3667mm     IFNE DEBUG
0000196A                          3668mm     ENDC
0000196A                          3669mm 
0000196A                          3670mm     ENDM
0000196A                          3671mm     PRINT_CHAR #10,D3             ; LF
0000196A                          3672mm WAIT_FOR_READY_269                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000196A                 TRUE     3673mm     IFEQ DEBUG
0000196A  1639 00D30003           3674mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00001970  0803 0002               3675mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00001974  67F4                    3676mm       BEQ WAIT_FOR_READY_269          ; NO SPACE, CHECK AGAIN
00001976  13FC 000A 00D30007      3677mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000197E                          3678mm     ENDC
0000197E                          3679mm     
0000197E                 FALSE    3680mm     IFNE DEBUG
0000197E                          3681mm     ENDC
0000197E                          3682mm 
0000197E                          3683mm     ENDM
0000197E                          3684m     ENDM
0000197E                          3685      ENDW    
0000197E  6000 FF74               3686s     BRA _1000000A
00001982                          3687s _1000000B
00001982                          3688  
00001982  4EF8 0186               3689      JMP MAIN_LOOP
00001986                          3690      
00001986  207C 00000000           3691  X   MOVE.L #0,A0
0000198C  4ED0                    3692      JMP (A0)
0000198E                          3693  
0000198E                          3694  HEX_DIGIT
0000198E  E98F                    3695      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00001990                          3696m     HEX2BIN D2,D2,A0
00001990  41F9 00001B1E           3697m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00001996  0402 0030               3698m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000199A  C4BC 000000FF           3699m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000019A0  1430 2000               3700m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000019A4                          3701m   ENDM
000019A4  8E02                    3702      OR.B D2,D7  
000019A6  4EF8 01AE               3703      JMP GET_INPUT
000019AA                          3704  
000019AA  FFFF FFFF               3705      SIMHALT                         ; halt simulator
000019AE                          3706  
000019AE                          3707  ; strings
000019AE= 4D 44 46 2D 6D 6F ...   3708  VERSION DC.B 'MDF-mon V1.21 (06/04/2021)',13,10,0
000019CB= 3F 20 48 65 6C 70 ...   3709  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,'X exit to ROM',13,10,0
00001A71= 48 75 68 3F 0D 0A 00    3710  HUH     DC.B 'Huh?',13,10,0
00001A78= 55 6E 69 6D 70 6C ...   3711  UNIMP   DC.B 'Unimplemented',13,10,0
00001A88= 20 53 20 72 65 63 ...   3712  READ    DC.B ' S records read, start address = ',0
00001AAA= 57 41 52 4E 49 4E ...   3713  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00001AD0= 57 41 52 4E 49 4E ...   3714  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00001AF6= 57 41 52 4E 49 4E ...   3715  RAM_ERROR DC.B 'WARNING: RAM error at: ',0
00001B0E= 30 31 32 33 34 35 ...   3716  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001B1E= 00 01 02 03 04 05 ...   3717  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001B35                          3718      
00001B35                          3719      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1B0E
CONTINUE_100        A5E
CONTINUE_104        ABC
CONTINUE_108        B1C
CONTINUE_112        B7A
CONTINUE_116        BEC
CONTINUE_120        C4A
CONTINUE_127        CF0
CONTINUE_131        D4E
CONTINUE_135        DAE
CONTINUE_139        E0C
CONTINUE_143        E70
CONTINUE_147        ECE
CONTINUE_151        F44
CONTINUE_155        FA2
CONTINUE_159        101C
CONTINUE_163        107A
CONTINUE_167        10DA
CONTINUE_171        1138
CONTINUE_175        11AA
CONTINUE_179        1208
CONTINUE_186        12AE
CONTINUE_189        12FA
CONTINUE_192        1348
CONTINUE_195        1394
CONTINUE_198        13E6
CONTINUE_201        1432
CONTINUE_210        14FA
CONTINUE_213        1546
CONTINUE_44         4B2
CONTINUE_46         4EE
CONTINUE_48         526
CONTINUE_51         572
CONTINUE_54         5C8
CONTINUE_57         614
CONTINUE_60         662
CONTINUE_63         6AE
CONTINUE_66         70E
CONTINUE_69         75A
CONTINUE_76         7F6
CONTINUE_80         854
CONTINUE_84         8B4
CONTINUE_88         912
CONTINUE_92         988
CONTINUE_96         9E6
CS_FAILURE          1AD0
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E6
DOWNLOAD_DONE       1620
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EVEN                A34
EVEN2               FF0
EXIT_19             2EE
EXIT_204            1496
EXIT_21             316
EXIT_216            159E
EXIT_23             33E
EXIT_231            1698
EXIT_241            17A0
EXIT_5              140
G                   171A
GET_INPUT           1AE
H                   2F2
HELP                19CB
HEX2BIN             12B
HEX2BIN_LUT         1B1E
HEX_DIGIT           198E
HUH                 1A71
L                   182A
LOOP_19             2D0
LOOP_204            1478
LOOP_21             2F8
LOOP_216            1580
LOOP_218            15C8
LOOP_226            164A
LOOP_23             320
LOOP_231            167A
LOOP_233            16C4
LOOP_241            1782
LOOP_243            17CE
LOOP_25             370
LOOP_262            192C
LOOP_5              122
MAIN_LOOP           186
OK                  1820
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   342
RAM                 200000
RAM_ERROR           1AF6
READ                1A88
READ_CHAR           79D
READ_DATA_TO_POKE   410
READ_LENGTH         1872
RESET               4
ROM                 0
RRRR                0
S                   48E
STACK               0
START               8
UNIMP               1A78
UNREC               1AAA
V                   31A
VERSION             19AE
W                   3C8
WAIT_CHAR           615
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_100  A42
WAIT_FOR_READY_102  A76
WAIT_FOR_READY_104  AA0
WAIT_FOR_READY_106  AD4
WAIT_FOR_READY_108  B00
WAIT_FOR_READY_11   186
WAIT_FOR_READY_110  B34
WAIT_FOR_READY_112  B5E
WAIT_FOR_READY_114  B92
WAIT_FOR_READY_116  BD0
WAIT_FOR_READY_118  C04
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_120  C2E
WAIT_FOR_READY_122  C62
WAIT_FOR_READY_125  C9A
WAIT_FOR_READY_126  CAE
WAIT_FOR_READY_127  CD4
WAIT_FOR_READY_129  D08
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_131  D32
WAIT_FOR_READY_133  D66
WAIT_FOR_READY_135  D92
WAIT_FOR_READY_137  DC6
WAIT_FOR_READY_139  DF0
WAIT_FOR_READY_141  E24
WAIT_FOR_READY_143  E54
WAIT_FOR_READY_145  E88
WAIT_FOR_READY_147  EB2
WAIT_FOR_READY_149  EE6
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  F28
WAIT_FOR_READY_153  F5C
WAIT_FOR_READY_155  F86
WAIT_FOR_READY_157  FBA
WAIT_FOR_READY_159  1000
WAIT_FOR_READY_161  1034
WAIT_FOR_READY_163  105E
WAIT_FOR_READY_165  1092
WAIT_FOR_READY_167  10BE
WAIT_FOR_READY_169  10F2
WAIT_FOR_READY_17   26A
WAIT_FOR_READY_171  111C
WAIT_FOR_READY_173  1150
WAIT_FOR_READY_175  118E
WAIT_FOR_READY_177  11C2
WAIT_FOR_READY_179  11EC
WAIT_FOR_READY_18   27E
WAIT_FOR_READY_181  1220
WAIT_FOR_READY_184  1258
WAIT_FOR_READY_185  126C
WAIT_FOR_READY_186  1292
WAIT_FOR_READY_189  12DE
WAIT_FOR_READY_192  132C
WAIT_FOR_READY_195  1378
WAIT_FOR_READY_198  13CA
WAIT_FOR_READY_20   2D8
WAIT_FOR_READY_201  1416
WAIT_FOR_READY_205  1480
WAIT_FOR_READY_206  1496
WAIT_FOR_READY_208  14A8
WAIT_FOR_READY_209  14BC
WAIT_FOR_READY_210  14DE
WAIT_FOR_READY_213  152A
WAIT_FOR_READY_217  1588
WAIT_FOR_READY_219  159E
WAIT_FOR_READY_22   300
WAIT_FOR_READY_220  15B2
WAIT_FOR_READY_222  15DC
WAIT_FOR_READY_224  15F2
WAIT_FOR_READY_225  1606
WAIT_FOR_READY_227  1620
WAIT_FOR_READY_228  1634
WAIT_FOR_READY_230  165E
WAIT_FOR_READY_232  1682
WAIT_FOR_READY_234  169A
WAIT_FOR_READY_235  16AE
WAIT_FOR_READY_237  16D8
WAIT_FOR_READY_239  16EE
WAIT_FOR_READY_24   328
WAIT_FOR_READY_240  1702
WAIT_FOR_READY_242  178A
WAIT_FOR_READY_244  17A4
WAIT_FOR_READY_245  17B8
WAIT_FOR_READY_247  17E2
WAIT_FOR_READY_249  17F8
WAIT_FOR_READY_250  180C
WAIT_FOR_READY_251  182C
WAIT_FOR_READY_253  1846
WAIT_FOR_READY_255  1874
WAIT_FOR_READY_257  188E
WAIT_FOR_READY_26   346
WAIT_FOR_READY_260  18BE
WAIT_FOR_READY_261  18D2
WAIT_FOR_READY_263  1902
WAIT_FOR_READY_264  1916
WAIT_FOR_READY_266  1940
WAIT_FOR_READY_268  1956
WAIT_FOR_READY_269  196A
WAIT_FOR_READY_27   35A
WAIT_FOR_READY_29   384
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   39A
WAIT_FOR_READY_32   3AE
WAIT_FOR_READY_33   3CA
WAIT_FOR_READY_35   3E4
WAIT_FOR_READY_37   412
WAIT_FOR_READY_39   42C
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   462
WAIT_FOR_READY_43   476
WAIT_FOR_READY_44   496
WAIT_FOR_READY_46   4D2
WAIT_FOR_READY_48   50A
WAIT_FOR_READY_51   556
WAIT_FOR_READY_54   5AC
WAIT_FOR_READY_57   5F8
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_60   646
WAIT_FOR_READY_63   692
WAIT_FOR_READY_66   6F2
WAIT_FOR_READY_69   73E
WAIT_FOR_READY_72   78A
WAIT_FOR_READY_74   7A0
WAIT_FOR_READY_75   7B4
WAIT_FOR_READY_76   7DA
WAIT_FOR_READY_78   80E
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   838
WAIT_FOR_READY_82   86C
WAIT_FOR_READY_84   898
WAIT_FOR_READY_86   8CC
WAIT_FOR_READY_88   8F6
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   92A
WAIT_FOR_READY_92   96C
WAIT_FOR_READY_94   9A0
WAIT_FOR_READY_96   9CA
WAIT_FOR_READY_98   9FE
WAIT_FOR_SRECORD    496
X                   1986
Z                   1722
_00000000           7D0
_00000001           14D4
_00000002           CCA
_00000003           C9A
_00000004           14D4
_00000005           1288
_00000006           1258
_00000007           14D4
_00000008           1472
_00000009           14D4
_0000000A           161E
_0000000B           177C
_10000000           6E4
_10000001           7A0
_10000002           A34
_10000003           BC6
_10000004           FF2
_10000005           1184
_10000006           172A
_10000007           174C
_10000008           1754
_10000009           1826
_1000000A           18F4
_1000000B           1982
