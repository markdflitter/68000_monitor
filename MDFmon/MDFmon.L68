00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 08:00:58

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; include the checksum in download_byte
00000000                             9  ; revisit register usage in S record download - should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            10  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            11  ; Review for any other savings
00000000                            12  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            13  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            14  
00000000                            15  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            16  ; keep track of highest address hit during srec download
00000000                            17  ; fix the reset vector so that it jumps to the start
00000000                            18  ; Replace JMP -> BRA
00000000                            19  ; implement backspace
00000000                            20  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            21  ; fix being able to enter random chars when W'ing
00000000                            22  ; ram check at startup?  Not sure if this is a good idea!
00000000                            23  ; byte W?
00000000                            24  
00000000                            25      ;ORG  $0
00200000                            26      ORG  $200000
00200000                            27  
00200000  =00000000                 28  DEBUG               EQU 0
00200000                            29  
00200000                            30  ; constants
00200000  =00000000                 31  ROM                 EQU $0
00200000  =00200000                 32  RAM                 EQU $200000
00200000                            33     
00200000  =00C00000                 34  DUART_BASE          EQU $C00000
00200000  =00000000                 35  DUART_MRA_          EQU $0
00200000  =00000001                 36  DUART_CSRA_         EQU $1
00200000  =00000001                 37  DUART_SRA_          EQU $1
00200000  =00000002                 38  DUART_CRA_          EQU $2
00200000  =00000003                 39  DUART_TXA_          EQU $3
00200000  =00000003                 40  DUART_RXA_          EQU $3
00200000  =00000004                 41  DUART_ACR_          EQU $4
00200000  =00000005                 42  DUART_IMR_          EQU $5
00200000  =00000008                 43  DUART_MRB_          EQU $8
00200000  =00000009                 44  DUART_CSRB_         EQU $9
00200000  =00000009                 45  DUART_SRB_          EQU $9
00200000  =0000000A                 46  DUART_CRB_          EQU $A
00200000  =0000000B                 47  DUART_TXB_          EQU $B
00200000  =0000000B                 48  DUART_RXB_          EQU $B
00200000  =0000000C                 49  DUART_IVR_          EQU $C
00200000  =0000000D                 50  DUART_OPCR_         EQU $D
00200000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00200000                            53  
00200000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            60  
00200000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            67  
00200000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            74  
00200000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 76  DISPLAY_            EQU $0
00200000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            78  
00200000                            79  ; macros
00200000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            81  ; the input register is changed during the process
00200000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            83  BIN2HEX MACRO
00200000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            86      MOVE.B \1,\2
00200000                            87      ANDI.L #$F,\2
00200000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            89      ENDM
00200000                            90  
00200000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            92  ; the input register is changed during the process
00200000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            94  HEX2BIN MACRO
00200000                            95      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00200000                            96      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00200000                            97      AND.L #$FF,\1                               ; ignore the top 3 bytes
00200000                            98      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00200000                            99      ENDM
00200000                           100  
00200000                           101  ; send a single char to the serial port
00200000                           102  ; \1 = char to send, \2 = data register to use for status poll
00200000                           103  ; will stamp on D0 and D1 in debug mode
00200000                           104  PRINT_CHAR MACRO
00200000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           106      IFEQ DEBUG
00200000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           108          BTST #2,\2                              ; check for space to send
00200000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           111      ENDC
00200000                           112      
00200000                           113      IFNE DEBUG
00200000                           114          MOVE.B \1,D1
00200000                           115          MOVE.L #6,D0   
00200000                           116          TRAP #15                                ; write to terminal in simulator
00200000                           117      ENDC
00200000                           118  
00200000                           119      ENDM
00200000                           120  
00200000                           121  ; send CR,LF to the serial port
00200000                           122  ; \1 = data register to use for status poll
00200000                           123  PRINT_CRLF MACRO
00200000                           124      PRINT_CHAR #13,\1                           ; CR
00200000                           125      PRINT_CHAR #10,\1                           ; LF
00200000                           126      ENDM
00200000                           127  
00200000                           128  ; send C-style, zero terminated string to the serial port
00200000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           130  PRINT_STR MACRO
00200000                           131  LOOP\@
00200000                           132      CMP.B #0,(\1)                               ; 0 -> done
00200000                           133      BEQ EXIT\@
00200000                           134      PRINT_CHAR (\1)+,\2
00200000                           135      JMP LOOP\@
00200000                           136  EXIT\@
00200000                           137      ENDM
00200000                           138    
00200000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00200000                           141  PRINT_REG MACRO
00200000                           142      PRINT_CHAR #'0',\2                          ;0x header
00200000                           143      PRINT_CHAR #'x',\2
00200000                           144      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00200000                           145  LOOP\@
00200000                           146      BIN2HEX \1,\3,\5
00200000                           147      PRINT_CHAR \3,\2
00200000                           148      DBEQ \4,LOOP\@
00200000                           149      ENDM
00200000                           150    
00200000                           151  ; wait for a char from the serial port
00200000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           153  ; will stamp on D0 and D1 in debug mode
00200000                           154  WAIT_CHAR MACRO
00200000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           156  
00200000                           157      IFEQ DEBUG
00200000                           158          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           159          BTST #0,\2                              ; check for character
00200000                           160          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           161      ENDC
00200000                           162      
00200000                           163      READ_CHAR \1
00200000                           164  
00200000                           165      IFEQ DEBUG
00200000                           166          PRINT_CHAR \1,\2                        ; echo it back
00200000                           167      ENDC
00200000                           168      ENDM
00200000                           169      
00200000                           170  ; read a char from the serial port - assumes that there is one!
00200000                           171  ; \ 1= data register for read char
00200000                           172  ; will stamp on D0 and D1 in debug mode
00200000                           173  READ_CHAR MACRO
00200000                           174      IFEQ DEBUG
00200000                           175          MOVE.B DUART_RXA,\1                     ; got a character, read it
00200000                           176      ENDC
00200000                           177      IFNE DEBUG
00200000                           178          MOVE.L #5,D0    
00200000                           179          TRAP #15                                ; read from keyboard in simulator
00200000                           180          MOVE.L D1,\1
00200000                           181      ENDC
00200000                           182       
00200000                           183      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           184      BEQ START
00200000                           185      ENDM
00200000                           186      
00200000                           187      
00200000                           188  ; read data from the download serial port
00200000                           189  ; \ 1= data register for read char
00200000                           190  DOWNLOAD MACRO
00200000                           191  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           192  
00200000                           193      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           194      BTST #0,\1                                  ; check for character
00200000                           195      BEQ CONTINUE\@                              ; nothing, continue
00200000                           196   
00200000                           197      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           198  CONTINUE\@
00200000                           199      MOVE.B DUART_SRB,\1                         ; read download status register
00200000                           200      BTST #0,\1                                  ; check for character
00200000                           201      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00200000                           202      
00200000                           203      MOVE.B DUART_RXB,\1                         ; got a character, read it
00200000                           204      MOVE.B \1,DISPLAY                           ; echo to the display
00200000                           205      
00200000                           206      ENDM
00200000                           207      
00200000                           208  ; read two hex digits from the download serial port and convert to a byte
00200000                           209  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = working address register, 
00200000                           210  DOWNLOAD_BYTE MACRO
00200000                           211      MOVE.B #2,\4
00200000                           212      WHILE.B \4 <GT> 0 DO
00200000                           213          DOWNLOAD \1                                ; read first (most significant) char, convert to 4 bits and shift to top
00200000                           214          PRINT_CHAR \1,\3
00200000                           215          HEX2BIN \1,\1,\5
00200000                           216          OR.B \1,\2
00200000                           217          LSL.L #4,\2
00200000                           218          SUB.B #1,\4
00200000                           219      ENDW
00200000                           220      ENDM
00200000                           221      
00200000                           222  
00200000                           223  ; register catalogue
00200000                           224  ; D0 - used for simulator I/O
00200000                           225  ; D1 - used for simulator I/O
00200000                           226  ; D2 - read character
00200000                           227  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           228  ; D4 - count of S records read
00200000                           229  ; D5 - data to write / data read / byte count for S record load
00200000                           230  ; D6 - working register used in R/W and download
00200000                           231  ; D7 - address accumulator / reset by download
00200000                           232  ; A0 - address of string to print 
00200000                           233  
00200000                           234  ; start vector
00200000= 00000000                 235  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 236  RESET    DC.L START                             ; RESET
00200008                           237      
00200008                           238  ; start of program  
00200008                           239  START
00200008  13FC 0000 00E00001       240      MOVE.B #0,DISPLAY
00200010                           241  
00200010                           242  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       243      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00200018  13FC 0050 00C00005       244      MOVE.B #$50,DUART_CRA                       ; reset everyting
00200020  4E71                     245      NOP
00200022  13FC 0040 00C00005       246      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     247      NOP
0020002C  13FC 0030 00C00005       248      MOVE.B #$30,DUART_CRA
00200034  4E71                     249      NOP
00200036  13FC 0020 00C00005       250      MOVE.B #$20,DUART_CRA
0020003E  4E71                     251      NOP
00200040  13FC 0010 00C00005       252      MOVE.B #$10,DUART_CRA   
00200048                           253  
00200048  13FC 000A 00C00015       254      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00200050  13FC 0050 00C00015       255      MOVE.B #$50,DUART_CRB                       ; reset everyting
00200058  4E71                     256      NOP
0020005A  13FC 0040 00C00015       257      MOVE.B #$40,DUART_CRB           
00200062  4E71                     258      NOP
00200064  13FC 0030 00C00015       259      MOVE.B #$30,DUART_CRB
0020006C  4E71                     260      NOP
0020006E  13FC 0020 00C00015       261      MOVE.B #$20,DUART_CRB
00200076  4E71                     262      NOP
00200078  13FC 0010 00C00015       263      MOVE.B #$10,DUART_CRB   
00200080                           264  
00200080                           265  ;initialise UART
00200080  13FC 0000 00C00009       266      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       267      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00200090  13FC 0000 00C0001B       268      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00200098                           269  
00200098                           270  ; channel A
00200098  13FC 0013 00C00001       271      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       272      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
002000A8  13FC 00CC 00C00003       273      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
002000B0  13FC 0005 00C00005       274      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
002000B8                           275  
002000B8                           276  ; channel B
002000B8  13FC 0013 00C00011       277      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       278      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
002000C8  13FC 00CC 00C00013       279      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
002000D0  13FC 0005 00C00015       280      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
002000D8                           281  
002000D8                           282m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
002000D8                           283m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      284m     IFEQ DEBUG
002000D8  1639 00C00003            285m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                286m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     287m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       288m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           289m     ENDC
002000EC                           290m     
002000EC                 FALSE     291m     IFNE DEBUG
002000EC                           292m     ENDC
002000EC                           293m 
002000EC                           294m     ENDM
002000EC                           295  
002000EC  13FC 0001 00E00001       296      MOVE.B #1,DISPLAY
002000F4                           297         
002000F4                           298m     PRINT_CRLF D3
002000F4                           299mm     PRINT_CHAR #13,D3                           ; CR
002000F4                           300mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      301mm     IFEQ DEBUG
002000F4  1639 00C00003            302mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                303mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     304mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       305mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           306mm     ENDC
00200108                           307mm     
00200108                 FALSE     308mm     IFNE DEBUG
00200108                           309mm     ENDC
00200108                           310mm 
00200108                           311mm     ENDM
00200108                           312mm     PRINT_CHAR #10,D3                           ; LF
00200108                           313mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      314mm     IFEQ DEBUG
00200108  1639 00C00003            315mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                316mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     317mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       318mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           319mm     ENDC
0020011C                           320mm     
0020011C                 FALSE     321mm     IFNE DEBUG
0020011C                           322mm     ENDC
0020011C                           323mm 
0020011C                           324mm     ENDM
0020011C                           325m     ENDM
0020011C                           326  
0020011C  41F9 00200EE6            327      LEA VERSION,A0
00200122                           328m     PRINT_STR A0,D3
00200122                           329m LOOP_5
00200122  0C10 0000                330m     CMP.B #0,(A0)                               ; 0 -> DONE
00200126  6700 001A                331m     BEQ EXIT_5
0020012A                           332mm     PRINT_CHAR (A0)+,D3
0020012A                           333mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      334mm     IFEQ DEBUG
0020012A  1639 00C00003            335mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                336mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     337mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            338mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           339mm     ENDC
0020013C                           340mm     
0020013C                 FALSE     341mm     IFNE DEBUG
0020013C                           342mm     ENDC
0020013C                           343mm 
0020013C                           344mm     ENDM
0020013C  4EF9 00200122            345m     JMP LOOP_5
00200142                           346m EXIT_5
00200142                           347m     ENDM
00200142                           348m     PRINT_CRLF D3
00200142                           349mm     PRINT_CHAR #13,D3                           ; CR
00200142                           350mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200142                 TRUE      351mm     IFEQ DEBUG
00200142  1639 00C00003            352mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200148  0803 0002                353mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020014C  67F4                     354mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014E  13FC 000D 00C00007       355mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200156                           356mm     ENDC
00200156                           357mm     
00200156                 FALSE     358mm     IFNE DEBUG
00200156                           359mm     ENDC
00200156                           360mm 
00200156                           361mm     ENDM
00200156                           362mm     PRINT_CHAR #10,D3                           ; LF
00200156                           363mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200156                 TRUE      364mm     IFEQ DEBUG
00200156  1639 00C00003            365mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020015C  0803 0002                366mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200160  67F4                     367mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00200162  13FC 000A 00C00007       368mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020016A                           369mm     ENDC
0020016A                           370mm     
0020016A                 FALSE     371mm     IFNE DEBUG
0020016A                           372mm     ENDC
0020016A                           373mm 
0020016A                           374mm     ENDM
0020016A                           375m     ENDM
0020016A                           376m     PRINT_CHAR #7,D3
0020016A                           377m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020016A                 TRUE      378m     IFEQ DEBUG
0020016A  1639 00C00003            379m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200170  0803 0002                380m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200174  67F4                     381m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00200176  13FC 0007 00C00007       382m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020017E                           383m     ENDC
0020017E                           384m     
0020017E                 FALSE     385m     IFNE DEBUG
0020017E                           386m     ENDC
0020017E                           387m 
0020017E                           388m     ENDM
0020017E                           389  
0020017E  7E00                     390      MOVE.L #0,D7                                ; address accumulator
00200180                           391  
00200180  13FC 0002 00E00001       392      MOVE.B #2,DISPLAY
00200188                           393  MAIN_LOOP
00200188                           394m     PRINT_CHAR #'>',D3                          ; prompt
00200188                           395m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200188                 TRUE      396m     IFEQ DEBUG
00200188  1639 00C00003            397m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018E  0803 0002                398m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200192  67F4                     399m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200194  13FC 003E 00C00007       400m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020019C                           401m     ENDC
0020019C                           402m     
0020019C                 FALSE     403m     IFNE DEBUG
0020019C                           404m     ENDC
0020019C                           405m 
0020019C                           406m     ENDM
0020019C                           407m     PRINT_CHAR #32,D3                           ; space
0020019C                           408m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020019C                 TRUE      409m     IFEQ DEBUG
0020019C  1639 00C00003            410m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001A2  0803 0002                411m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001A6  67F4                     412m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
002001A8  13FC 0020 00C00007       413m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
002001B0                           414m     ENDC
002001B0                           415m     
002001B0                 FALSE     416m     IFNE DEBUG
002001B0                           417m     ENDC
002001B0                           418m 
002001B0                           419m     ENDM
002001B0                           420      
002001B0                           421  GET_INPUT
002001B0                           422m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
002001B0                           423m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B0                           424m 
002001B0                 TRUE      425m     IFEQ DEBUG
002001B0  1639 00C00003            426m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B6  0803 0000                427m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001BA  67F4                     428m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
002001BC                           429m     ENDC
002001BC                           430m     
002001BC                           431mm     READ_CHAR D2
002001BC                 TRUE      432mm     IFEQ DEBUG
002001BC  1439 00C00007            433mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002001C2                           434mm     ENDC
002001C2                 FALSE     435mm     IFNE DEBUG
002001C2                           436mm     ENDC
002001C2                           437mm      
002001C2  B43C 001B                438mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001C6  6700 FE40                439mm     BEQ START
002001CA                           440mm     ENDM
002001CA                           441m 
002001CA                 TRUE      442m     IFEQ DEBUG
002001CA                           443mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002001CA                           444mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001CA                 TRUE      445mm     IFEQ DEBUG
002001CA  1639 00C00003            446mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001D0  0803 0002                447mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001D4  67F4                     448mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
002001D6  13C2 00C00007            449mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001DC                           450mm     ENDC
002001DC                           451mm     
002001DC                 FALSE     452mm     IFNE DEBUG
002001DC                           453mm     ENDC
002001DC                           454mm 
002001DC                           455mm     ENDM
002001DC                           456m     ENDC
002001DC                           457m     ENDM
002001DC                           458      
002001DC  B43C 0030                459      CMP.B #'0',D2
002001E0  6700 0CE2                460      BEQ HEX_DIGIT
002001E4  B43C 0031                461      CMP.B #'1',D2
002001E8  6700 0CDA                462      BEQ HEX_DIGIT
002001EC  B43C 0032                463      CMP.B #'2',D2
002001F0  6700 0CD2                464      BEQ HEX_DIGIT
002001F4  B43C 0033                465      CMP.B #'3',D2
002001F8  6700 0CCA                466      BEQ HEX_DIGIT
002001FC  B43C 0034                467      CMP.B #'4',D2
00200200  6700 0CC2                468      BEQ HEX_DIGIT
00200204  B43C 0035                469      CMP.B #'5',D2
00200208  6700 0CBA                470      BEQ HEX_DIGIT
0020020C  B43C 0036                471      CMP.B #'6',D2
00200210  6700 0CB2                472      BEQ HEX_DIGIT
00200214  B43C 0037                473      CMP.B #'7',D2
00200218  6700 0CAA                474      BEQ HEX_DIGIT
0020021C  B43C 0038                475      CMP.B #'8',D2
00200220  6700 0CA2                476      BEQ HEX_DIGIT
00200224  B43C 0039                477      CMP.B #'9',D2
00200228  6700 0C9A                478      BEQ HEX_DIGIT
0020022C  B43C 0041                479      CMP.B #'A',D2
00200230  6700 0C92                480      BEQ HEX_DIGIT
00200234  B43C 0042                481      CMP.B #'B',D2
00200238  6700 0C8A                482      BEQ HEX_DIGIT
0020023C  B43C 0043                483      CMP.B #'C',D2
00200240  6700 0C82                484      BEQ HEX_DIGIT
00200244  B43C 0044                485      CMP.B #'D',D2
00200248  6700 0C7A                486      BEQ HEX_DIGIT
0020024C  B43C 0045                487      CMP.B #'E',D2
00200250  6700 0C72                488      BEQ HEX_DIGIT
00200254  B43C 0046                489      CMP.B #'F',D2
00200258  6700 0C6A                490      BEQ HEX_DIGIT
0020025C                           491      
0020025C  B43C 0057                492      CMP.B #'W',D2
00200260  6700 016E                493      BEQ W
00200264                           494      
00200264  B43C 004C                495      CMP.B #'L',D2
00200268  6700 0AE4                496      BEQ L 
0020026C                           497  
0020026C                           498m     PRINT_CRLF D3
0020026C                           499mm     PRINT_CHAR #13,D3                           ; CR
0020026C                           500mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020026C                 TRUE      501mm     IFEQ DEBUG
0020026C  1639 00C00003            502mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200272  0803 0002                503mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200276  67F4                     504mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00200278  13FC 000D 00C00007       505mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200280                           506mm     ENDC
00200280                           507mm     
00200280                 FALSE     508mm     IFNE DEBUG
00200280                           509mm     ENDC
00200280                           510mm 
00200280                           511mm     ENDM
00200280                           512mm     PRINT_CHAR #10,D3                           ; LF
00200280                           513mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200280                 TRUE      514mm     IFEQ DEBUG
00200280  1639 00C00003            515mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200286  0803 0002                516mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020028A  67F4                     517mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0020028C  13FC 000A 00C00007       518mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200294                           519mm     ENDC
00200294                           520mm     
00200294                 FALSE     521mm     IFNE DEBUG
00200294                           522mm     ENDC
00200294                           523mm 
00200294                           524mm     ENDM
00200294                           525m     ENDM
00200294                           526   
00200294  B43C 003F                527      CMP.B #'?',D2
00200298  6700 0056                528      BEQ H
0020029C                           529  
0020029C  B43C 0056                530      CMP.B #'V',D2
002002A0  6700 007A                531      BEQ V
002002A4                           532      
002002A4  B43C 0052                533      CMP.B #'R',D2
002002A8  6700 009E                534      BEQ R
002002AC                           535  
002002AC  B43C 0053                536      CMP.B #'S',D2
002002B0  6700 01E6                537      BEQ S
002002B4                           538  
002002B4  B43C 0047                539      CMP.B #'G',D2
002002B8  6700 0980                540      BEQ G   
002002BC                           541  
002002BC  B43C 005A                542      CMP.B #'Z',D2
002002C0  6700 0980                543      BEQ Z   
002002C4                           544  
002002C4  41F9 00200F9A            545      LEA HUH,A0
002002CA                           546m     PRINT_STR A0,D3
002002CA                           547m LOOP_19
002002CA  0C10 0000                548m     CMP.B #0,(A0)                               ; 0 -> DONE
002002CE  6700 001A                549m     BEQ EXIT_19
002002D2                           550mm     PRINT_CHAR (A0)+,D3
002002D2                           551mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002D2                 TRUE      552mm     IFEQ DEBUG
002002D2  1639 00C00003            553mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002D8  0803 0002                554mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002DC  67F4                     555mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
002002DE  13D8 00C00007            556mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002E4                           557mm     ENDC
002002E4                           558mm     
002002E4                 FALSE     559mm     IFNE DEBUG
002002E4                           560mm     ENDC
002002E4                           561mm 
002002E4                           562mm     ENDM
002002E4  4EF9 002002CA            563m     JMP LOOP_19
002002EA                           564m EXIT_19
002002EA                           565m     ENDM
002002EA                           566                         
002002EA  4EF9 00200188            567      JMP MAIN_LOOP
002002F0                           568      
002002F0                           569  ; commands
002002F0                           570  H   
002002F0  41F9 00200F03            571      LEA HELP,A0
002002F6                           572m     PRINT_STR A0,D3
002002F6                           573m LOOP_21
002002F6  0C10 0000                574m     CMP.B #0,(A0)                               ; 0 -> DONE
002002FA  6700 001A                575m     BEQ EXIT_21
002002FE                           576mm     PRINT_CHAR (A0)+,D3
002002FE                           577mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002FE                 TRUE      578mm     IFEQ DEBUG
002002FE  1639 00C00003            579mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200304  0803 0002                580mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200308  67F4                     581mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
0020030A  13D8 00C00007            582mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200310                           583mm     ENDC
00200310                           584mm     
00200310                 FALSE     585mm     IFNE DEBUG
00200310                           586mm     ENDC
00200310                           587mm 
00200310                           588mm     ENDM
00200310  4EF9 002002F6            589m     JMP LOOP_21
00200316                           590m EXIT_21
00200316                           591m     ENDM
00200316  4EF9 00200188            592      JMP MAIN_LOOP
0020031C                           593  
0020031C                           594  V   
0020031C  41F9 00200EE6            595      LEA VERSION,A0
00200322                           596m     PRINT_STR A0,D3       
00200322                           597m LOOP_23
00200322  0C10 0000                598m     CMP.B #0,(A0)                               ; 0 -> DONE
00200326  6700 001A                599m     BEQ EXIT_23
0020032A                           600mm     PRINT_CHAR (A0)+,D3
0020032A                           601mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020032A                 TRUE      602mm     IFEQ DEBUG
0020032A  1639 00C00003            603mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200330  0803 0002                604mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200334  67F4                     605mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00200336  13D8 00C00007            606mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020033C                           607mm     ENDC
0020033C                           608mm     
0020033C                 FALSE     609mm     IFNE DEBUG
0020033C                           610mm     ENDC
0020033C                           611mm 
0020033C                           612mm     ENDM
0020033C  4EF9 00200322            613m     JMP LOOP_23
00200342                           614m EXIT_23
00200342                           615m     ENDM
00200342  4EF9 00200188            616      JMP MAIN_LOOP
00200348                           617      
00200348                           618  R   
00200348  2047                     619      MOVE.L D7,A0                                ; address accumulator -> address register
0020034A  2A10                     620      MOVE.L (A0),D5                              ; read the memory and print it
0020034C                           621m     PRINT_REG D5,D3,D7,D6,A0
0020034C                           622mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0020034C                           623mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020034C                 TRUE      624mm     IFEQ DEBUG
0020034C  1639 00C00003            625mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200352  0803 0002                626mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200356  67F4                     627mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
00200358  13FC 0030 00C00007       628mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200360                           629mm     ENDC
00200360                           630mm     
00200360                 FALSE     631mm     IFNE DEBUG
00200360                           632mm     ENDC
00200360                           633mm 
00200360                           634mm     ENDM
00200360                           635mm     PRINT_CHAR #'x',D3
00200360                           636mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200360                 TRUE      637mm     IFEQ DEBUG
00200360  1639 00C00003            638mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200366  0803 0002                639mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020036A  67F4                     640mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0020036C  13FC 0078 00C00007       641mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200374                           642mm     ENDC
00200374                           643mm     
00200374                 FALSE     644mm     IFNE DEBUG
00200374                           645mm     ENDC
00200374                           646mm 
00200374                           647mm     ENDM
00200374  7C07                     648m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200376                           649m LOOP_25
00200376                           650mm     BIN2HEX D5,D7,A0
00200376  41F9 00200FFE            651mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020037C  E99D                     652mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0020037E  1E05                     653mm     MOVE.B D5,D7
00200380  0287 0000000F            654mm     ANDI.L #$F,D7
00200386  1E30 7000                655mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0020038A                           656mm     ENDM
0020038A                           657mm     PRINT_CHAR D7,D3
0020038A                           658mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020038A                 TRUE      659mm     IFEQ DEBUG
0020038A  1639 00C00003            660mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200390  0803 0002                661mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200394  67F4                     662mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200396  13C7 00C00007            663mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020039C                           664mm     ENDC
0020039C                           665mm     
0020039C                 FALSE     666mm     IFNE DEBUG
0020039C                           667mm     ENDC
0020039C                           668mm 
0020039C                           669mm     ENDM
0020039C  57CE FFD8                670m     DBEQ D6,LOOP_25
002003A0                           671m     ENDM
002003A0                           672m     PRINT_CRLF D3
002003A0                           673mm     PRINT_CHAR #13,D3                           ; CR
002003A0                           674mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003A0                 TRUE      675mm     IFEQ DEBUG
002003A0  1639 00C00003            676mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A6  0803 0002                677mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003AA  67F4                     678mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
002003AC  13FC 000D 00C00007       679mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B4                           680mm     ENDC
002003B4                           681mm     
002003B4                 FALSE     682mm     IFNE DEBUG
002003B4                           683mm     ENDC
002003B4                           684mm 
002003B4                           685mm     ENDM
002003B4                           686mm     PRINT_CHAR #10,D3                           ; LF
002003B4                           687mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003B4                 TRUE      688mm     IFEQ DEBUG
002003B4  1639 00C00003            689mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003BA  0803 0002                690mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003BE  67F4                     691mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
002003C0  13FC 000A 00C00007       692mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003C8                           693mm     ENDC
002003C8                           694mm     
002003C8                 FALSE     695mm     IFNE DEBUG
002003C8                           696mm     ENDC
002003C8                           697mm 
002003C8                           698mm     ENDM
002003C8                           699m     ENDM
002003C8  7E00                     700      MOVE.L #0,D7                                ; clear the now used address accumulator
002003CA  4EF9 00200188            701      JMP MAIN_LOOP
002003D0                           702  
002003D0                           703  W
002003D0  7A00                     704      MOVE.L #0,D5                                ; D5 will be the value to write            
002003D2                           705  
002003D2                           706m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
002003D2                           707m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003D2                           708m 
002003D2                 TRUE      709m     IFEQ DEBUG
002003D2  1639 00C00003            710m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003D8  0803 0000                711m         BTST #0,D3                              ; CHECK FOR CHARACTER
002003DC  67F4                     712m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
002003DE                           713m     ENDC
002003DE                           714m     
002003DE                           715mm     READ_CHAR D2
002003DE                 TRUE      716mm     IFEQ DEBUG
002003DE  1439 00C00007            717mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002003E4                           718mm     ENDC
002003E4                 FALSE     719mm     IFNE DEBUG
002003E4                           720mm     ENDC
002003E4                           721mm      
002003E4  B43C 001B                722mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002003E8  6700 FC1E                723mm     BEQ START
002003EC                           724mm     ENDM
002003EC                           725m 
002003EC                 TRUE      726m     IFEQ DEBUG
002003EC                           727mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
002003EC                           728mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003EC                 TRUE      729mm     IFEQ DEBUG
002003EC  1639 00C00003            730mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003F2  0803 0002                731mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003F6  67F4                     732mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
002003F8  13C2 00C00007            733mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002003FE                           734mm     ENDC
002003FE                           735mm     
002003FE                 FALSE     736mm     IFNE DEBUG
002003FE                           737mm     ENDC
002003FE                           738mm 
002003FE                           739mm     ENDM
002003FE                           740m     ENDC
002003FE                           741m     ENDM
002003FE                           742m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
002003FE  41F9 0020100E            743m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200404  0402 0030                744m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200408  C4BC 000000FF            745m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020040E  1430 2000                746m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200412                           747m     ENDM
00200412  1A02                     748      MOVE.B D2,D5                                ; put at bottom of D5
00200414                           749  
00200414  3C3C 0006                750      MOVE #6,D6                                  ; 7 bytes left to read
00200418                           751      
00200418                           752  READ_DATA_TO_POKE
00200418  E98D                     753      LSL.L #4,D5                                 ; make what we have so far more significant
0020041A                           754m     WAIT_CHAR D2,D3                             ; next character -> D2
0020041A                           755m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020041A                           756m 
0020041A                 TRUE      757m     IFEQ DEBUG
0020041A  1639 00C00003            758m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200420  0803 0000                759m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200424  67F4                     760m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00200426                           761m     ENDC
00200426                           762m     
00200426                           763mm     READ_CHAR D2
00200426                 TRUE      764mm     IFEQ DEBUG
00200426  1439 00C00007            765mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020042C                           766mm     ENDC
0020042C                 FALSE     767mm     IFNE DEBUG
0020042C                           768mm     ENDC
0020042C                           769mm      
0020042C  B43C 001B                770mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200430  6700 FBD6                771mm     BEQ START
00200434                           772mm     ENDM
00200434                           773m 
00200434                 TRUE      774m     IFEQ DEBUG
00200434                           775mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200434                           776mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200434                 TRUE      777mm     IFEQ DEBUG
00200434  1639 00C00003            778mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020043A  0803 0002                779mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020043E  67F4                     780mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200440  13C2 00C00007            781mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200446                           782mm     ENDC
00200446                           783mm     
00200446                 FALSE     784mm     IFNE DEBUG
00200446                           785mm     ENDC
00200446                           786mm 
00200446                           787mm     ENDM
00200446                           788m     ENDC
00200446                           789m     ENDM
00200446                           790m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200446  41F9 0020100E            791m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020044C  0402 0030                792m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200450  C4BC 000000FF            793m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200456  1430 2000                794m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020045A                           795m     ENDM
0020045A  8A02                     796      OR.B D2,D5
0020045C  023C 00FB                797      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200460  57CE FFB6                798      DBEQ D6,READ_DATA_TO_POKE
00200464                           799      
00200464  2047                     800      MOVE.L D7,A0                                ; address accumulator -> address register
00200466  7E00                     801      MOVE.L #0,D7                                ; clear the now used address accumulator
00200468                           802      
00200468  2085                     803      MOVE.L D5,(A0)                              ; write the data
0020046A                           804  
0020046A                           805m     PRINT_CRLF D3
0020046A                           806mm     PRINT_CHAR #13,D3                           ; CR
0020046A                           807mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020046A                 TRUE      808mm     IFEQ DEBUG
0020046A  1639 00C00003            809mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200470  0803 0002                810mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200474  67F4                     811mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00200476  13FC 000D 00C00007       812mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020047E                           813mm     ENDC
0020047E                           814mm     
0020047E                 FALSE     815mm     IFNE DEBUG
0020047E                           816mm     ENDC
0020047E                           817mm 
0020047E                           818mm     ENDM
0020047E                           819mm     PRINT_CHAR #10,D3                           ; LF
0020047E                           820mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020047E                 TRUE      821mm     IFEQ DEBUG
0020047E  1639 00C00003            822mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200484  0803 0002                823mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200488  67F4                     824mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0020048A  13FC 000A 00C00007       825mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200492                           826mm     ENDC
00200492                           827mm     
00200492                 FALSE     828mm     IFNE DEBUG
00200492                           829mm     ENDC
00200492                           830mm 
00200492                           831mm     ENDM
00200492                           832m     ENDM
00200492  4EF9 00200188            833      JMP MAIN_LOOP
00200498                           834  
00200498                           835          
00200498                           836  S
00200498  2647                     837      MOVE.L D7,A3                                ; grab the address accumulator
0020049A  7800                     838      MOVE.L #0,D4                                ; count of records read -> D4
0020049C  2478 0000                839      MOVE.L 0,A2                                 ; start address -> A2
002004A0                           840      
002004A0                           841  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
002004A0                           842m     DOWNLOAD D2                 
002004A0                           843m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004A0                           844m 
002004A0  1439 00C00003            845m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002004A6  0802 0000                846m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004AA  6700 0010                847m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
002004AE                           848m  
002004AE                           849mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002004AE                 TRUE      850mm     IFEQ DEBUG
002004AE  1439 00C00007            851mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002004B4                           852mm     ENDC
002004B4                 FALSE     853mm     IFNE DEBUG
002004B4                           854mm     ENDC
002004B4                           855mm      
002004B4  B43C 001B                856mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002004B8  6700 FB4E                857mm     BEQ START
002004BC                           858mm     ENDM
002004BC                           859m CONTINUE_44
002004BC  1439 00C00013            860m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
002004C2  0802 0000                861m     BTST #0,D2                                  ; CHECK FOR CHARACTER
002004C6  67D8                     862m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
002004C8                           863m     
002004C8  1439 00C00017            864m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002004CE  13C2 00E00001            865m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002004D4                           866m     
002004D4                           867m     ENDM
002004D4  B43C 0053                868      CMP.B #'S',D2                               ; found S?    
002004D8  66C6                     869      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
002004DA                           870      
002004DA                           871m     PRINT_CHAR #'S',D3                          ; print it
002004DA                           872m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004DA                 TRUE      873m     IFEQ DEBUG
002004DA  1639 00C00003            874m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002004E0  0803 0002                875m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002004E4  67F4                     876m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004E6  13FC 0053 00C00007       877m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
002004EE                           878m     ENDC
002004EE                           879m     
002004EE                 FALSE     880m     IFNE DEBUG
002004EE                           881m     ENDC
002004EE                           882m 
002004EE                           883m     ENDM
002004EE  5284                     884      ADD.L #1,D4                                 ; read another S record, increment count
002004F0                           885      
002004F0                           886m     DOWNLOAD D0                                 ; read the record identifier
002004F0                           887m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004F0                           888m 
002004F0  1039 00C00003            889m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
002004F6  0800 0000                890m     BTST #0,D0                                  ; CHECK FOR CHARACTER
002004FA  6700 0010                891m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
002004FE                           892m  
002004FE                           893mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
002004FE                 TRUE      894mm     IFEQ DEBUG
002004FE  1039 00C00007            895mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
00200504                           896mm     ENDC
00200504                 FALSE     897mm     IFNE DEBUG
00200504                           898mm     ENDC
00200504                           899mm      
00200504  B03C 001B                900mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
00200508  6700 FAFE                901mm     BEQ START
0020050C                           902mm     ENDM
0020050C                           903m CONTINUE_47
0020050C  1039 00C00013            904m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
00200512  0800 0000                905m     BTST #0,D0                                  ; CHECK FOR CHARACTER
00200516  67D8                     906m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00200518                           907m     
00200518  1039 00C00017            908m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
0020051E  13C0 00E00001            909m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
00200524                           910m     
00200524                           911m     ENDM
00200524                           912m     PRINT_CHAR D0,D3                            ; print it
00200524                           913m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200524                 TRUE      914m     IFEQ DEBUG
00200524  1639 00C00003            915m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020052A  0803 0002                916m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020052E  67F4                     917m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
00200530  13C0 00C00007            918m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200536                           919m     ENDC
00200536                           920m     
00200536                 FALSE     921m     IFNE DEBUG
00200536                           922m     ENDC
00200536                           923m 
00200536                           924m     ENDM
00200536                           925  
00200536  7C00                     926      MOVE.L #0,D6                                ; clear the checksum
00200538                           927  
00200538  7A00                     928      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
0020053A                           929m     DOWNLOAD_BYTE D2,D5,D3,D1,A0                               
0020053A  123C 0002                930m     MOVE.B #2,D1
0020053E                           931m     WHILE.B D1 <GT> 0 DO
0020053E                           932ms _10000000
0020053E  B238 0000                933ms     CMP.B   0,D1
00200542  6F00 0064                934ms     BLE _10000001
00200546                           935mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200546                           936mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200546                           937mm 
00200546  1439 00C00003            938mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020054C  0802 0000                939mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200550  6700 0010                940mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
00200554                           941mm  
00200554                           942mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200554                 TRUE      943mmm     IFEQ DEBUG
00200554  1439 00C00007            944mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020055A                           945mmm     ENDC
0020055A                 FALSE     946mmm     IFNE DEBUG
0020055A                           947mmm     ENDC
0020055A                           948mmm      
0020055A  B43C 001B                949mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020055E  6700 FAA8                950mmm     BEQ START
00200562                           951mmm     ENDM
00200562                           952mm CONTINUE_51
00200562  1439 00C00013            953mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200568  0802 0000                954mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020056C  67D8                     955mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
0020056E                           956mm     
0020056E  1439 00C00017            957mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200574  13C2 00E00001            958mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020057A                           959mm     
0020057A                           960mm     ENDM
0020057A                           961mm         PRINT_CHAR D2,D3
0020057A                           962mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020057A                 TRUE      963mm     IFEQ DEBUG
0020057A  1639 00C00003            964mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200580  0803 0002                965mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200584  67F4                     966mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00200586  13C2 00C00007            967mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020058C                           968mm     ENDC
0020058C                           969mm     
0020058C                 FALSE     970mm     IFNE DEBUG
0020058C                           971mm     ENDC
0020058C                           972mm 
0020058C                           973mm     ENDM
0020058C                           974mm         HEX2BIN D2,D2,A0
0020058C  41F9 0020100E            975mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200592  0402 0030                976mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200596  C4BC 000000FF            977mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0020059C  1430 2000                978mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002005A0                           979mm     ENDM
002005A0  8A02                     980m         OR.B D2,D5
002005A2  E98D                     981m         LSL.L #4,D5
002005A4  5301                     982m         SUB.B #1,D1
002005A6                           983m     ENDW
002005A6  6096                     984ms     BRA _10000000
002005A8                           985ms _10000001
002005A8                           986m     ENDM
002005A8  DC85                     987      ADD.L D5,D6                                 ; add to checksum
002005AA                           988  
002005AA                           989      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
002005AA  B03C 0030                990s     CMP.B   #'0',D0
002005AE  6600 0032                991s     BNE.L   _00000000
002005B2                           992m         PRINT_CRLF D3
002005B2                           993mm     PRINT_CHAR #13,D3                           ; CR
002005B2                           994mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005B2                 TRUE      995mm     IFEQ DEBUG
002005B2  1639 00C00003            996mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005B8  0803 0002                997mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005BC  67F4                     998mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
002005BE  13FC 000D 00C00007       999mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005C6                          1000mm     ENDC
002005C6                          1001mm     
002005C6                 FALSE    1002mm     IFNE DEBUG
002005C6                          1003mm     ENDC
002005C6                          1004mm 
002005C6                          1005mm     ENDM
002005C6                          1006mm     PRINT_CHAR #10,D3                           ; LF
002005C6                          1007mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005C6                 TRUE     1008mm     IFEQ DEBUG
002005C6  1639 00C00003           1009mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002005CC  0803 0002               1010mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002005D0  67F4                    1011mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
002005D2  13FC 000A 00C00007      1012mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002005DA                          1013mm     ENDC
002005DA                          1014mm     
002005DA                 FALSE    1015mm     IFNE DEBUG
002005DA                          1016mm     ENDC
002005DA                          1017mm 
002005DA                          1018mm     ENDM
002005DA                          1019m     ENDM
002005DA  6000 FEC4               1020          BRA WAIT_FOR_SRECORD
002005DE                          1021      ELSE
002005DE  6000 040C               1022s     BRA _00000001
002005E2                          1023s _00000000
002005E2                          1024          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
002005E2  B03C 0031               1025s     CMP.B   #'1',D0
002005E6  6708                    1026s     BEQ.S   _00000002
002005E8  B03C 0032               1027s     CMP.B   #'2',D0
002005EC  6600 01FE               1028s     BNE.L   _00000003
002005F0                          1029s _00000002
002005F0  5785                    1030              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
002005F2                          1031      
002005F2  7E00                    1032              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
002005F4                          1033m             DOWNLOAD_BYTE D2,D7,D3,D1,A0        ; first byte                           
002005F4  123C 0002               1034m     MOVE.B #2,D1
002005F8                          1035m     WHILE.B D1 <GT> 0 DO
002005F8                          1036ms _10000002
002005F8  B238 0000               1037ms     CMP.B   0,D1
002005FC  6F00 0064               1038ms     BLE _10000003
00200600                          1039mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200600                          1040mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200600                          1041mm 
00200600  1439 00C00003           1042mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200606  0802 0000               1043mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020060A  6700 0010               1044mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
0020060E                          1045mm  
0020060E                          1046mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0020060E                 TRUE     1047mmm     IFEQ DEBUG
0020060E  1439 00C00007           1048mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200614                          1049mmm     ENDC
00200614                 FALSE    1050mmm     IFNE DEBUG
00200614                          1051mmm     ENDC
00200614                          1052mmm      
00200614  B43C 001B               1053mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200618  6700 F9EE               1054mmm     BEQ START
0020061C                          1055mmm     ENDM
0020061C                          1056mm CONTINUE_59
0020061C  1439 00C00013           1057mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200622  0802 0000               1058mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200626  67D8                    1059mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
00200628                          1060mm     
00200628  1439 00C00017           1061mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0020062E  13C2 00E00001           1062mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200634                          1063mm     
00200634                          1064mm     ENDM
00200634                          1065mm         PRINT_CHAR D2,D3
00200634                          1066mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200634                 TRUE     1067mm     IFEQ DEBUG
00200634  1639 00C00003           1068mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020063A  0803 0002               1069mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020063E  67F4                    1070mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
00200640  13C2 00C00007           1071mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200646                          1072mm     ENDC
00200646                          1073mm     
00200646                 FALSE    1074mm     IFNE DEBUG
00200646                          1075mm     ENDC
00200646                          1076mm 
00200646                          1077mm     ENDM
00200646                          1078mm         HEX2BIN D2,D2,A0
00200646  41F9 0020100E           1079mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020064C  0402 0030               1080mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200650  C4BC 000000FF           1081mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200656  1430 2000               1082mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020065A                          1083mm     ENDM
0020065A  8E02                    1084m         OR.B D2,D7
0020065C  E98F                    1085m         LSL.L #4,D7
0020065E  5301                    1086m         SUB.B #1,D1
00200660                          1087m     ENDW
00200660  6096                    1088ms     BRA _10000002
00200662                          1089ms _10000003
00200662                          1090m     ENDM
00200662  DC87                    1091              ADD.L D7,D6                         ; add into checksum
00200664                          1092  
00200664  E98F                    1093              LSL.L #4,D7                         ; second byte
00200666                          1094m             DOWNLOAD_BYTE D2,D7,D3,D1,A0       
00200666  123C 0002               1095m     MOVE.B #2,D1
0020066A                          1096m     WHILE.B D1 <GT> 0 DO
0020066A                          1097ms _10000004
0020066A  B238 0000               1098ms     CMP.B   0,D1
0020066E  6F00 0064               1099ms     BLE _10000005
00200672                          1100mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200672                          1101mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200672                          1102mm 
00200672  1439 00C00003           1103mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200678  0802 0000               1104mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020067C  6700 0010               1105mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
00200680                          1106mm  
00200680                          1107mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200680                 TRUE     1108mmm     IFEQ DEBUG
00200680  1439 00C00007           1109mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200686                          1110mmm     ENDC
00200686                 FALSE    1111mmm     IFNE DEBUG
00200686                          1112mmm     ENDC
00200686                          1113mmm      
00200686  B43C 001B               1114mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020068A  6700 F97C               1115mmm     BEQ START
0020068E                          1116mmm     ENDM
0020068E                          1117mm CONTINUE_64
0020068E  1439 00C00013           1118mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200694  0802 0000               1119mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200698  67D8                    1120mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
0020069A                          1121mm     
0020069A  1439 00C00017           1122mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002006A0  13C2 00E00001           1123mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002006A6                          1124mm     
002006A6                          1125mm     ENDM
002006A6                          1126mm         PRINT_CHAR D2,D3
002006A6                          1127mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006A6                 TRUE     1128mm     IFEQ DEBUG
002006A6  1639 00C00003           1129mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002006AC  0803 0002               1130mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002006B0  67F4                    1131mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
002006B2  13C2 00C00007           1132mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006B8                          1133mm     ENDC
002006B8                          1134mm     
002006B8                 FALSE    1135mm     IFNE DEBUG
002006B8                          1136mm     ENDC
002006B8                          1137mm 
002006B8                          1138mm     ENDM
002006B8                          1139mm         HEX2BIN D2,D2,A0
002006B8  41F9 0020100E           1140mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002006BE  0402 0030               1141mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006C2  C4BC 000000FF           1142mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002006C8  1430 2000               1143mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002006CC                          1144mm     ENDM
002006CC  8E02                    1145m         OR.B D2,D7
002006CE  E98F                    1146m         LSL.L #4,D7
002006D0  5301                    1147m         SUB.B #1,D1
002006D2                          1148m     ENDW
002006D2  6096                    1149ms     BRA _10000004
002006D4                          1150ms _10000005
002006D4                          1151m     ENDM
002006D4  7400                    1152              MOVE.L #0,D2                        ; rextract latest byte of address and add into checksum
002006D6  1407                    1153              MOVE.B D7,D2
002006D8  DC82                    1154              ADD.L D2,D6
002006DA                          1155              
002006DA                          1156              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
002006DA  B03C 0032               1157s     CMP.B   #'2',D0
002006DE  6600 007A               1158s     BNE.L   _00000004
002006E2  5385                    1159                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address
002006E4                          1160      
002006E4  E98F                    1161                  LSL.L #4,D7                     ; third byte
002006E6                          1162m                 DOWNLOAD_BYTE D2,D7,D3,D1,A0       
002006E6  123C 0002               1163m     MOVE.B #2,D1
002006EA                          1164m     WHILE.B D1 <GT> 0 DO
002006EA                          1165ms _10000006
002006EA  B238 0000               1166ms     CMP.B   0,D1
002006EE  6F00 0064               1167ms     BLE _10000007
002006F2                          1168mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002006F2                          1169mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006F2                          1170mm 
002006F2  1439 00C00003           1171mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002006F8  0802 0000               1172mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002006FC  6700 0010               1173mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00200700                          1174mm  
00200700                          1175mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200700                 TRUE     1176mmm     IFEQ DEBUG
00200700  1439 00C00007           1177mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200706                          1178mmm     ENDC
00200706                 FALSE    1179mmm     IFNE DEBUG
00200706                          1180mmm     ENDC
00200706                          1181mmm      
00200706  B43C 001B               1182mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020070A  6700 F8FC               1183mmm     BEQ START
0020070E                          1184mmm     ENDM
0020070E                          1185mm CONTINUE_69
0020070E  1439 00C00013           1186mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200714  0802 0000               1187mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200718  67D8                    1188mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
0020071A                          1189mm     
0020071A  1439 00C00017           1190mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200720  13C2 00E00001           1191mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200726                          1192mm     
00200726                          1193mm     ENDM
00200726                          1194mm         PRINT_CHAR D2,D3
00200726                          1195mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200726                 TRUE     1196mm     IFEQ DEBUG
00200726  1639 00C00003           1197mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020072C  0803 0002               1198mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200730  67F4                    1199mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
00200732  13C2 00C00007           1200mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200738                          1201mm     ENDC
00200738                          1202mm     
00200738                 FALSE    1203mm     IFNE DEBUG
00200738                          1204mm     ENDC
00200738                          1205mm 
00200738                          1206mm     ENDM
00200738                          1207mm         HEX2BIN D2,D2,A0
00200738  41F9 0020100E           1208mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020073E  0402 0030               1209mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200742  C4BC 000000FF           1210mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200748  1430 2000               1211mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020074C                          1212mm     ENDM
0020074C  8E02                    1213m         OR.B D2,D7
0020074E  E98F                    1214m         LSL.L #4,D7
00200750  5301                    1215m         SUB.B #1,D1
00200752                          1216m     ENDW
00200752  6096                    1217ms     BRA _10000006
00200754                          1218ms _10000007
00200754                          1219m     ENDM
00200754  7400                    1220                  MOVE.L #0,D2                    ; rextract latest byte of address and add into checksum
00200756  1407                    1221                  MOVE.B D7,D2
00200758  DC82                    1222                  ADD.L D2,D6
0020075A                          1223              ENDI
0020075A                          1224s _00000004
0020075A                          1225              
0020075A  2247                    1226              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
0020075C  D3CB                    1227              ADD.L A3,A1                         ; add in the offset
0020075E                          1228          
0020075E                          1229              WHILE.L D5 <GT> #0 DO               ; read the data bytes
0020075E                          1230s _10000008
0020075E  BABC 00000000           1231s     CMP.L   #0,D5
00200764  6F00 007C               1232s     BLE _10000009
00200768  7E00                    1233                  MOVE.L #0,D7                    ; D7 holds the byte
0020076A                          1234m                 DOWNLOAD_BYTE D2,D7,D3,D1,A0    ; read it                               
0020076A  123C 0002               1235m     MOVE.B #2,D1
0020076E                          1236m     WHILE.B D1 <GT> 0 DO
0020076E                          1237ms _1000000A
0020076E  B238 0000               1238ms     CMP.B   0,D1
00200772  6F00 0064               1239ms     BLE _1000000B
00200776                          1240mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200776                          1241mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200776                          1242mm 
00200776  1439 00C00003           1243mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020077C  0802 0000               1244mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200780  6700 0010               1245mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00200784                          1246mm  
00200784                          1247mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200784                 TRUE     1248mmm     IFEQ DEBUG
00200784  1439 00C00007           1249mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0020078A                          1250mmm     ENDC
0020078A                 FALSE    1251mmm     IFNE DEBUG
0020078A                          1252mmm     ENDC
0020078A                          1253mmm      
0020078A  B43C 001B               1254mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020078E  6700 F878               1255mmm     BEQ START
00200792                          1256mmm     ENDM
00200792                          1257mm CONTINUE_74
00200792  1439 00C00013           1258mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200798  0802 0000               1259mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020079C  67D8                    1260mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
0020079E                          1261mm     
0020079E  1439 00C00017           1262mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002007A4  13C2 00E00001           1263mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002007AA                          1264mm     
002007AA                          1265mm     ENDM
002007AA                          1266mm         PRINT_CHAR D2,D3
002007AA                          1267mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007AA                 TRUE     1268mm     IFEQ DEBUG
002007AA  1639 00C00003           1269mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002007B0  0803 0002               1270mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002007B4  67F4                    1271mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
002007B6  13C2 00C00007           1272mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007BC                          1273mm     ENDC
002007BC                          1274mm     
002007BC                 FALSE    1275mm     IFNE DEBUG
002007BC                          1276mm     ENDC
002007BC                          1277mm 
002007BC                          1278mm     ENDM
002007BC                          1279mm         HEX2BIN D2,D2,A0
002007BC  41F9 0020100E           1280mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002007C2  0402 0030               1281mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007C6  C4BC 000000FF           1282mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002007CC  1430 2000               1283mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002007D0                          1284mm     ENDM
002007D0  8E02                    1285m         OR.B D2,D7
002007D2  E98F                    1286m         LSL.L #4,D7
002007D4  5301                    1287m         SUB.B #1,D1
002007D6                          1288m     ENDW
002007D6  6096                    1289ms     BRA _1000000A
002007D8                          1290ms _1000000B
002007D8                          1291m     ENDM
002007D8  DC87                    1292                  ADD.L D7,D6                     ; add into checksum
002007DA                          1293                          
002007DA  12C7                    1294                  MOVE.B D7,(A1)+                 ; store it!
002007DC                          1295  
002007DC  5385                    1296                  SUB.L #1,D5                     ; 1 less byte to go
002007DE                          1297              ENDW
002007DE  6000 FF7E               1298s     BRA _10000008
002007E2                          1299s _10000009
002007E2                          1300          
002007E2  43F9 002004A0           1301              LEA WAIT_FOR_SRECORD,A1             ; next place to go
002007E8                          1302          ELSE
002007E8  6000 0202               1303s     BRA _00000005
002007EC                          1304s _00000003
002007EC                          1305              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
002007EC  B03C 0038               1306s     CMP.B   #'8',D0
002007F0  6600 016C               1307s     BNE.L   _00000006
002007F4  7E00                    1308                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
002007F6                          1309m                 DOWNLOAD_BYTE D2,D7,D3,D1,A0    ; read byte             
002007F6  123C 0002               1310m     MOVE.B #2,D1
002007FA                          1311m     WHILE.B D1 <GT> 0 DO
002007FA                          1312ms _1000000C
002007FA  B238 0000               1313ms     CMP.B   0,D1
002007FE  6F00 0064               1314ms     BLE _1000000D
00200802                          1315mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200802                          1316mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200802                          1317mm 
00200802  1439 00C00003           1318mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200808  0802 0000               1319mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020080C  6700 0010               1320mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
00200810                          1321mm  
00200810                          1322mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200810                 TRUE     1323mmm     IFEQ DEBUG
00200810  1439 00C00007           1324mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200816                          1325mmm     ENDC
00200816                 FALSE    1326mmm     IFNE DEBUG
00200816                          1327mmm     ENDC
00200816                          1328mmm      
00200816  B43C 001B               1329mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020081A  6700 F7EC               1330mmm     BEQ START
0020081E                          1331mmm     ENDM
0020081E                          1332mm CONTINUE_79
0020081E  1439 00C00013           1333mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200824  0802 0000               1334mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200828  67D8                    1335mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
0020082A                          1336mm     
0020082A  1439 00C00017           1337mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200830  13C2 00E00001           1338mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200836                          1339mm     
00200836                          1340mm     ENDM
00200836                          1341mm         PRINT_CHAR D2,D3
00200836                          1342mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200836                 TRUE     1343mm     IFEQ DEBUG
00200836  1639 00C00003           1344mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020083C  0803 0002               1345mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200840  67F4                    1346mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00200842  13C2 00C00007           1347mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200848                          1348mm     ENDC
00200848                          1349mm     
00200848                 FALSE    1350mm     IFNE DEBUG
00200848                          1351mm     ENDC
00200848                          1352mm 
00200848                          1353mm     ENDM
00200848                          1354mm         HEX2BIN D2,D2,A0
00200848  41F9 0020100E           1355mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0020084E  0402 0030               1356mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200852  C4BC 000000FF           1357mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200858  1430 2000               1358mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0020085C                          1359mm     ENDM
0020085C  8E02                    1360m         OR.B D2,D7
0020085E  E98F                    1361m         LSL.L #4,D7
00200860  5301                    1362m         SUB.B #1,D1
00200862                          1363m     ENDW
00200862  6096                    1364ms     BRA _1000000C
00200864                          1365ms _1000000D
00200864                          1366m     ENDM
00200864  DC87                    1367                  ADD.L D7,D6                     ; add top byte of address into checksum
00200866                          1368  
00200866  E98F                    1369                  LSL.L #4,D7                     ; middle byte
00200868                          1370m                 DOWNLOAD_BYTE D2,D7,D3,D1,A0    ; read byte             
00200868  123C 0002               1371m     MOVE.B #2,D1
0020086C                          1372m     WHILE.B D1 <GT> 0 DO
0020086C                          1373ms _1000000E
0020086C  B238 0000               1374ms     CMP.B   0,D1
00200870  6F00 0064               1375ms     BLE _1000000F
00200874                          1376mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200874                          1377mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200874                          1378mm 
00200874  1439 00C00003           1379mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0020087A  0802 0000               1380mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020087E  6700 0010               1381mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
00200882                          1382mm  
00200882                          1383mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200882                 TRUE     1384mmm     IFEQ DEBUG
00200882  1439 00C00007           1385mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200888                          1386mmm     ENDC
00200888                 FALSE    1387mmm     IFNE DEBUG
00200888                          1388mmm     ENDC
00200888                          1389mmm      
00200888  B43C 001B               1390mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020088C  6700 F77A               1391mmm     BEQ START
00200890                          1392mmm     ENDM
00200890                          1393mm CONTINUE_84
00200890  1439 00C00013           1394mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200896  0802 0000               1395mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0020089A  67D8                    1396mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
0020089C                          1397mm     
0020089C  1439 00C00017           1398mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
002008A2  13C2 00E00001           1399mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
002008A8                          1400mm     
002008A8                          1401mm     ENDM
002008A8                          1402mm         PRINT_CHAR D2,D3
002008A8                          1403mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008A8                 TRUE     1404mm     IFEQ DEBUG
002008A8  1639 00C00003           1405mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002008AE  0803 0002               1406mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002008B2  67F4                    1407mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
002008B4  13C2 00C00007           1408mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008BA                          1409mm     ENDC
002008BA                          1410mm     
002008BA                 FALSE    1411mm     IFNE DEBUG
002008BA                          1412mm     ENDC
002008BA                          1413mm 
002008BA                          1414mm     ENDM
002008BA                          1415mm         HEX2BIN D2,D2,A0
002008BA  41F9 0020100E           1416mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
002008C0  0402 0030               1417mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002008C4  C4BC 000000FF           1418mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
002008CA  1430 2000               1419mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
002008CE                          1420mm     ENDM
002008CE  8E02                    1421m         OR.B D2,D7
002008D0  E98F                    1422m         LSL.L #4,D7
002008D2  5301                    1423m         SUB.B #1,D1
002008D4                          1424m     ENDW
002008D4  6096                    1425ms     BRA _1000000E
002008D6                          1426ms _1000000F
002008D6                          1427m     ENDM
002008D6  7400                    1428                  MOVE.L #0,D2                    ; rextract middle byte of address and add into checksum
002008D8  1407                    1429                  MOVE.B D7,D2
002008DA  DC82                    1430                  ADD.L D2,D6
002008DC                          1431                    
002008DC  E98F                    1432                  LSL.L #4,D7                     ; bottom byte
002008DE                          1433m                 DOWNLOAD_BYTE D2,D7,D3,D1,A0    ; read byte                             
002008DE  123C 0002               1434m     MOVE.B #2,D1
002008E2                          1435m     WHILE.B D1 <GT> 0 DO
002008E2                          1436ms _10000010
002008E2  B238 0000               1437ms     CMP.B   0,D1
002008E6  6F00 0064               1438ms     BLE _10000011
002008EA                          1439mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
002008EA                          1440mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008EA                          1441mm 
002008EA  1439 00C00003           1442mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
002008F0  0802 0000               1443mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
002008F4  6700 0010               1444mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
002008F8                          1445mm  
002008F8                          1446mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
002008F8                 TRUE     1447mmm     IFEQ DEBUG
002008F8  1439 00C00007           1448mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
002008FE                          1449mmm     ENDC
002008FE                 FALSE    1450mmm     IFNE DEBUG
002008FE                          1451mmm     ENDC
002008FE                          1452mmm      
002008FE  B43C 001B               1453mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200902  6700 F704               1454mmm     BEQ START
00200906                          1455mmm     ENDM
00200906                          1456mm CONTINUE_89
00200906  1439 00C00013           1457mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0020090C  0802 0000               1458mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200910  67D8                    1459mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00200912                          1460mm     
00200912  1439 00C00017           1461mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200918  13C2 00E00001           1462mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0020091E                          1463mm     
0020091E                          1464mm     ENDM
0020091E                          1465mm         PRINT_CHAR D2,D3
0020091E                          1466mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020091E                 TRUE     1467mm     IFEQ DEBUG
0020091E  1639 00C00003           1468mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200924  0803 0002               1469mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200928  67F4                    1470mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
0020092A  13C2 00C00007           1471mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200930                          1472mm     ENDC
00200930                          1473mm     
00200930                 FALSE    1474mm     IFNE DEBUG
00200930                          1475mm     ENDC
00200930                          1476mm 
00200930                          1477mm     ENDM
00200930                          1478mm         HEX2BIN D2,D2,A0
00200930  41F9 0020100E           1479mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200936  0402 0030               1480mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020093A  C4BC 000000FF           1481mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200940  1430 2000               1482mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200944                          1483mm     ENDM
00200944  8E02                    1484m         OR.B D2,D7
00200946  E98F                    1485m         LSL.L #4,D7
00200948  5301                    1486m         SUB.B #1,D1
0020094A                          1487m     ENDW
0020094A  6096                    1488ms     BRA _10000010
0020094C                          1489ms _10000011
0020094C                          1490m     ENDM
0020094C  7400                    1491                  MOVE.L #0,D2                    ; rextract bottom byte of address and add into checksum
0020094E  1407                    1492                  MOVE.B D7,D2
00200950  DC82                    1493                  ADD.L D2,D6
00200952                          1494                    
00200952  2447                    1495                  MOVE.L D7,A2                    ; start address -> A2
00200954                          1496                  
00200954  43F9 00200B3C           1497                  LEA DOWNLOAD_DONE,A1            ; next place to go
0020095A                          1498              ELSE
0020095A  6000 0090               1499s     BRA _00000007
0020095E                          1500s _00000006
0020095E                          1501m                 PRINT_CRLF D3
0020095E                          1502mm     PRINT_CHAR #13,D3                           ; CR
0020095E                          1503mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020095E                 TRUE     1504mm     IFEQ DEBUG
0020095E  1639 00C00003           1505mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200964  0803 0002               1506mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200968  67F4                    1507mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
0020096A  13FC 000D 00C00007      1508mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200972                          1509mm     ENDC
00200972                          1510mm     
00200972                 FALSE    1511mm     IFNE DEBUG
00200972                          1512mm     ENDC
00200972                          1513mm 
00200972                          1514mm     ENDM
00200972                          1515mm     PRINT_CHAR #10,D3                           ; LF
00200972                          1516mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200972                 TRUE     1517mm     IFEQ DEBUG
00200972  1639 00C00003           1518mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200978  0803 0002               1519mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020097C  67F4                    1520mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
0020097E  13FC 000A 00C00007      1521mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200986                          1522mm     ENDC
00200986                          1523mm     
00200986                 FALSE    1524mm     IFNE DEBUG
00200986                          1525mm     ENDC
00200986                          1526mm 
00200986                          1527mm     ENDM
00200986                          1528m     ENDM
00200986                          1529              
00200986  41F9 00200FC3           1530                  LEA UNREC,A0                    ; warn for unrecognised type
0020098C                          1531m                 PRINT_STR A0,D3
0020098C                          1532m LOOP_96
0020098C  0C10 0000               1533m     CMP.B #0,(A0)                               ; 0 -> DONE
00200990  6700 001A               1534m     BEQ EXIT_96
00200994                          1535mm     PRINT_CHAR (A0)+,D3
00200994                          1536mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200994                 TRUE     1537mm     IFEQ DEBUG
00200994  1639 00C00003           1538mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020099A  0803 0002               1539mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020099E  67F4                    1540mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
002009A0  13D8 00C00007           1541mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002009A6                          1542mm     ENDC
002009A6                          1543mm     
002009A6                 FALSE    1544mm     IFNE DEBUG
002009A6                          1545mm     ENDC
002009A6                          1546mm 
002009A6                          1547mm     ENDM
002009A6  4EF9 0020098C           1548m     JMP LOOP_96
002009AC                          1549m EXIT_96
002009AC                          1550m     ENDM
002009AC                          1551m                 PRINT_CHAR D7,D3
002009AC                          1552m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009AC                 TRUE     1553m     IFEQ DEBUG
002009AC  1639 00C00003           1554m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009B2  0803 0002               1555m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009B6  67F4                    1556m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
002009B8  13C7 00C00007           1557m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002009BE                          1558m     ENDC
002009BE                          1559m     
002009BE                 FALSE    1560m     IFNE DEBUG
002009BE                          1561m     ENDC
002009BE                          1562m 
002009BE                          1563m     ENDM
002009BE                          1564m                 PRINT_CRLF D3
002009BE                          1565mm     PRINT_CHAR #13,D3                           ; CR
002009BE                          1566mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BE                 TRUE     1567mm     IFEQ DEBUG
002009BE  1639 00C00003           1568mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009C4  0803 0002               1569mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009C8  67F4                    1570mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
002009CA  13FC 000D 00C00007      1571mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009D2                          1572mm     ENDC
002009D2                          1573mm     
002009D2                 FALSE    1574mm     IFNE DEBUG
002009D2                          1575mm     ENDC
002009D2                          1576mm 
002009D2                          1577mm     ENDM
002009D2                          1578mm     PRINT_CHAR #10,D3                           ; LF
002009D2                          1579mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D2                 TRUE     1580mm     IFEQ DEBUG
002009D2  1639 00C00003           1581mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002009D8  0803 0002               1582mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002009DC  67F4                    1583mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
002009DE  13FC 000A 00C00007      1584mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009E6                          1585mm     ENDC
002009E6                          1586mm     
002009E6                 FALSE    1587mm     IFNE DEBUG
002009E6                          1588mm     ENDC
002009E6                          1589mm 
002009E6                          1590mm     ENDM
002009E6                          1591m     ENDM
002009E6                          1592              
002009E6  4EF9 002004A0           1593                  JMP WAIT_FOR_SRECORD            ; ignore any other type    
002009EC                          1594              ENDI
002009EC                          1595s _00000007
002009EC                          1596          ENDI
002009EC                          1597s _00000005
002009EC                          1598      ENDI
002009EC                          1599s _00000001
002009EC                          1600      
002009EC  4686                    1601      NOT.L D6                                    ; ones complement the checksum
002009EE  0286 000000FF           1602      ANDI.L #$FF,D6                              ; and take the LSByte
002009F4                          1603          
002009F4  7E00                    1604      MOVE.L #0,D7                                ; read the checksum from the data stream
002009F6                          1605m     DOWNLOAD_BYTE D2,D7,D3,D1,A0                            
002009F6  123C 0002               1606m     MOVE.B #2,D1
002009FA                          1607m     WHILE.B D1 <GT> 0 DO
002009FA                          1608ms _10000012
002009FA  B238 0000               1609ms     CMP.B   0,D1
002009FE  6F00 0064               1610ms     BLE _10000013
00200A02                          1611mm         DOWNLOAD D2                                ; READ FIRST (MOST SIGNIFICANT) CHAR, CONVERT TO 4 BITS AND SHIFT TO TOP
00200A02                          1612mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A02                          1613mm 
00200A02  1439 00C00003           1614mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00200A08  0802 0000               1615mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A0C  6700 0010               1616mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
00200A10                          1617mm  
00200A10                          1618mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00200A10                 TRUE     1619mmm     IFEQ DEBUG
00200A10  1439 00C00007           1620mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200A16                          1621mmm     ENDC
00200A16                 FALSE    1622mmm     IFNE DEBUG
00200A16                          1623mmm     ENDC
00200A16                          1624mmm      
00200A16  B43C 001B               1625mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200A1A  6700 F5EC               1626mmm     BEQ START
00200A1E                          1627mmm     ENDM
00200A1E                          1628mm CONTINUE_103
00200A1E  1439 00C00013           1629mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00200A24  0802 0000               1630mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00200A28  67D8                    1631mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00200A2A                          1632mm     
00200A2A  1439 00C00017           1633mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00200A30  13C2 00E00001           1634mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00200A36                          1635mm     
00200A36                          1636mm     ENDM
00200A36                          1637mm         PRINT_CHAR D2,D3
00200A36                          1638mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A36                 TRUE     1639mm     IFEQ DEBUG
00200A36  1639 00C00003           1640mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A3C  0803 0002               1641mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A40  67F4                    1642mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00200A42  13C2 00C00007           1643mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A48                          1644mm     ENDC
00200A48                          1645mm     
00200A48                 FALSE    1646mm     IFNE DEBUG
00200A48                          1647mm     ENDC
00200A48                          1648mm 
00200A48                          1649mm     ENDM
00200A48                          1650mm         HEX2BIN D2,D2,A0
00200A48  41F9 0020100E           1651mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200A4E  0402 0030               1652mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200A52  C4BC 000000FF           1653mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200A58  1430 2000               1654mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200A5C                          1655mm     ENDM
00200A5C  8E02                    1656m         OR.B D2,D7
00200A5E  E98F                    1657m         LSL.L #4,D7
00200A60  5301                    1658m         SUB.B #1,D1
00200A62                          1659m     ENDW
00200A62  6096                    1660ms     BRA _10000012
00200A64                          1661ms _10000013
00200A64                          1662m     ENDM
00200A64                          1663m     PRINT_CRLF D3
00200A64                          1664mm     PRINT_CHAR #13,D3                           ; CR
00200A64                          1665mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A64                 TRUE     1666mm     IFEQ DEBUG
00200A64  1639 00C00003           1667mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A6A  0803 0002               1668mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A6E  67F4                    1669mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00200A70  13FC 000D 00C00007      1670mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A78                          1671mm     ENDC
00200A78                          1672mm     
00200A78                 FALSE    1673mm     IFNE DEBUG
00200A78                          1674mm     ENDC
00200A78                          1675mm 
00200A78                          1676mm     ENDM
00200A78                          1677mm     PRINT_CHAR #10,D3                           ; LF
00200A78                          1678mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A78                 TRUE     1679mm     IFEQ DEBUG
00200A78  1639 00C00003           1680mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200A7E  0803 0002               1681mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200A82  67F4                    1682mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00200A84  13FC 000A 00C00007      1683mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A8C                          1684mm     ENDC
00200A8C                          1685mm     
00200A8C                 FALSE    1686mm     IFNE DEBUG
00200A8C                          1687mm     ENDC
00200A8C                          1688mm 
00200A8C                          1689mm     ENDM
00200A8C                          1690m     ENDM
00200A8C                          1691  
00200A8C                          1692      IF.B D7 <NE> D6 THEN.L
00200A8C  BE06                    1693s     CMP.B   D6,D7
00200A8E  6700 00AA               1694s     BEQ.L   _00000008
00200A92  41F9 00200FDA           1695          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00200A98                          1696m         PRINT_STR A0,D3
00200A98                          1697m LOOP_110
00200A98  0C10 0000               1698m     CMP.B #0,(A0)                               ; 0 -> DONE
00200A9C  6700 001A               1699m     BEQ EXIT_110
00200AA0                          1700mm     PRINT_CHAR (A0)+,D3
00200AA0                          1701mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AA0                 TRUE     1702mm     IFEQ DEBUG
00200AA0  1639 00C00003           1703mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AA6  0803 0002               1704mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AAA  67F4                    1705mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200AAC  13D8 00C00007           1706mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200AB2                          1707mm     ENDC
00200AB2                          1708mm     
00200AB2                 FALSE    1709mm     IFNE DEBUG
00200AB2                          1710mm     ENDC
00200AB2                          1711mm 
00200AB2                          1712mm     ENDM
00200AB2  4EF9 00200A98           1713m     JMP LOOP_110
00200AB8                          1714m EXIT_110
00200AB8                          1715m     ENDM
00200AB8                          1716m         PRINT_REG D4,D3,D6,D7,A0
00200AB8                          1717mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200AB8                          1718mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB8                 TRUE     1719mm     IFEQ DEBUG
00200AB8  1639 00C00003           1720mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200ABE  0803 0002               1721mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AC2  67F4                    1722mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00200AC4  13FC 0030 00C00007      1723mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200ACC                          1724mm     ENDC
00200ACC                          1725mm     
00200ACC                 FALSE    1726mm     IFNE DEBUG
00200ACC                          1727mm     ENDC
00200ACC                          1728mm 
00200ACC                          1729mm     ENDM
00200ACC                          1730mm     PRINT_CHAR #'x',D3
00200ACC                          1731mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200ACC                 TRUE     1732mm     IFEQ DEBUG
00200ACC  1639 00C00003           1733mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AD2  0803 0002               1734mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200AD6  67F4                    1735mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200AD8  13FC 0078 00C00007      1736mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AE0                          1737mm     ENDC
00200AE0                          1738mm     
00200AE0                 FALSE    1739mm     IFNE DEBUG
00200AE0                          1740mm     ENDC
00200AE0                          1741mm 
00200AE0                          1742mm     ENDM
00200AE0  7E07                    1743m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AE2                          1744m LOOP_112
00200AE2                          1745mm     BIN2HEX D4,D6,A0
00200AE2  41F9 00200FFE           1746mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200AE8  E99C                    1747mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200AEA  1C04                    1748mm     MOVE.B D4,D6
00200AEC  0286 0000000F           1749mm     ANDI.L #$F,D6
00200AF2  1C30 6000               1750mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200AF6                          1751mm     ENDM
00200AF6                          1752mm     PRINT_CHAR D6,D3
00200AF6                          1753mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AF6                 TRUE     1754mm     IFEQ DEBUG
00200AF6  1639 00C00003           1755mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200AFC  0803 0002               1756mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B00  67F4                    1757mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00200B02  13C6 00C00007           1758mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B08                          1759mm     ENDC
00200B08                          1760mm     
00200B08                 FALSE    1761mm     IFNE DEBUG
00200B08                          1762mm     ENDC
00200B08                          1763mm 
00200B08                          1764mm     ENDM
00200B08  57CF FFD8               1765m     DBEQ D7,LOOP_112
00200B0C                          1766m     ENDM
00200B0C                          1767m         PRINT_CRLF D3
00200B0C                          1768mm     PRINT_CHAR #13,D3                           ; CR
00200B0C                          1769mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0C                 TRUE     1770mm     IFEQ DEBUG
00200B0C  1639 00C00003           1771mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B12  0803 0002               1772mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B16  67F4                    1773mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00200B18  13FC 000D 00C00007      1774mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B20                          1775mm     ENDC
00200B20                          1776mm     
00200B20                 FALSE    1777mm     IFNE DEBUG
00200B20                          1778mm     ENDC
00200B20                          1779mm 
00200B20                          1780mm     ENDM
00200B20                          1781mm     PRINT_CHAR #10,D3                           ; LF
00200B20                          1782mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B20                 TRUE     1783mm     IFEQ DEBUG
00200B20  1639 00C00003           1784mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B26  0803 0002               1785mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B2A  67F4                    1786mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200B2C  13FC 000A 00C00007      1787mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B34                          1788mm     ENDC
00200B34                          1789mm     
00200B34                 FALSE    1790mm     IFNE DEBUG
00200B34                          1791mm     ENDC
00200B34                          1792mm 
00200B34                          1793mm     ENDM
00200B34                          1794m     ENDM
00200B34  4EF9 00200188           1795          JMP MAIN_LOOP
00200B3A                          1796      ENDI
00200B3A                          1797s _00000008
00200B3A                          1798      
00200B3A  4ED1                    1799      JMP (A1)
00200B3C                          1800  DOWNLOAD_DONE
00200B3C                          1801m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00200B3C                          1802mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200B3C                          1803mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B3C                 TRUE     1804mm     IFEQ DEBUG
00200B3C  1639 00C00003           1805mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B42  0803 0002               1806mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B46  67F4                    1807mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200B48  13FC 0030 00C00007      1808mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B50                          1809mm     ENDC
00200B50                          1810mm     
00200B50                 FALSE    1811mm     IFNE DEBUG
00200B50                          1812mm     ENDC
00200B50                          1813mm 
00200B50                          1814mm     ENDM
00200B50                          1815mm     PRINT_CHAR #'x',D3
00200B50                          1816mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B50                 TRUE     1817mm     IFEQ DEBUG
00200B50  1639 00C00003           1818mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B56  0803 0002               1819mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B5A  67F4                    1820mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200B5C  13FC 0078 00C00007      1821mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200B64                          1822mm     ENDC
00200B64                          1823mm     
00200B64                 FALSE    1824mm     IFNE DEBUG
00200B64                          1825mm     ENDC
00200B64                          1826mm 
00200B64                          1827mm     ENDM
00200B64  7C07                    1828m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200B66                          1829m LOOP_120
00200B66                          1830mm     BIN2HEX D4,D7,A0
00200B66  41F9 00200FFE           1831mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200B6C  E99C                    1832mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200B6E  1E04                    1833mm     MOVE.B D4,D7
00200B70  0287 0000000F           1834mm     ANDI.L #$F,D7
00200B76  1E30 7000               1835mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00200B7A                          1836mm     ENDM
00200B7A                          1837mm     PRINT_CHAR D7,D3
00200B7A                          1838mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B7A                 TRUE     1839mm     IFEQ DEBUG
00200B7A  1639 00C00003           1840mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200B80  0803 0002               1841mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200B84  67F4                    1842mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00200B86  13C7 00C00007           1843mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B8C                          1844mm     ENDC
00200B8C                          1845mm     
00200B8C                 FALSE    1846mm     IFNE DEBUG
00200B8C                          1847mm     ENDC
00200B8C                          1848mm 
00200B8C                          1849mm     ENDM
00200B8C  57CE FFD8               1850m     DBEQ D6,LOOP_120
00200B90                          1851m     ENDM
00200B90  41F9 00200FA1           1852      LEA READ,A0
00200B96                          1853m     PRINT_STR A0,D3
00200B96                          1854m LOOP_125
00200B96  0C10 0000               1855m     CMP.B #0,(A0)                               ; 0 -> DONE
00200B9A  6700 001A               1856m     BEQ EXIT_125
00200B9E                          1857mm     PRINT_CHAR (A0)+,D3
00200B9E                          1858mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B9E                 TRUE     1859mm     IFEQ DEBUG
00200B9E  1639 00C00003           1860mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BA4  0803 0002               1861mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BA8  67F4                    1862mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200BAA  13D8 00C00007           1863mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200BB0                          1864mm     ENDC
00200BB0                          1865mm     
00200BB0                 FALSE    1866mm     IFNE DEBUG
00200BB0                          1867mm     ENDC
00200BB0                          1868mm 
00200BB0                          1869mm     ENDM
00200BB0  4EF9 00200B96           1870m     JMP LOOP_125
00200BB6                          1871m EXIT_125
00200BB6                          1872m     ENDM
00200BB6  2E0A                    1873      MOVE.L A2,D7                                ; set address accumulator to start address
00200BB8                          1874m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00200BB8                          1875mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200BB8                          1876mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BB8                 TRUE     1877mm     IFEQ DEBUG
00200BB8  1639 00C00003           1878mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BBE  0803 0002               1879mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BC2  67F4                    1880mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00200BC4  13FC 0030 00C00007      1881mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BCC                          1882mm     ENDC
00200BCC                          1883mm     
00200BCC                 FALSE    1884mm     IFNE DEBUG
00200BCC                          1885mm     ENDC
00200BCC                          1886mm 
00200BCC                          1887mm     ENDM
00200BCC                          1888mm     PRINT_CHAR #'x',D3
00200BCC                          1889mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BCC                 TRUE     1890mm     IFEQ DEBUG
00200BCC  1639 00C00003           1891mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BD2  0803 0002               1892mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BD6  67F4                    1893mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200BD8  13FC 0078 00C00007      1894mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BE0                          1895mm     ENDC
00200BE0                          1896mm     
00200BE0                 FALSE    1897mm     IFNE DEBUG
00200BE0                          1898mm     ENDC
00200BE0                          1899mm 
00200BE0                          1900mm     ENDM
00200BE0  7C07                    1901m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200BE2                          1902m LOOP_127
00200BE2                          1903mm     BIN2HEX D7,D2,A0
00200BE2  41F9 00200FFE           1904mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200BE8  E99F                    1905mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200BEA  1407                    1906mm     MOVE.B D7,D2
00200BEC  0282 0000000F           1907mm     ANDI.L #$F,D2
00200BF2  1430 2000               1908mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200BF6                          1909mm     ENDM
00200BF6                          1910mm     PRINT_CHAR D2,D3
00200BF6                          1911mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BF6                 TRUE     1912mm     IFEQ DEBUG
00200BF6  1639 00C00003           1913mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BFC  0803 0002               1914mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C00  67F4                    1915mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200C02  13C2 00C00007           1916mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C08                          1917mm     ENDC
00200C08                          1918mm     
00200C08                 FALSE    1919mm     IFNE DEBUG
00200C08                          1920mm     ENDC
00200C08                          1921mm 
00200C08                          1922mm     ENDM
00200C08  57CE FFD8               1923m     DBEQ D6,LOOP_127
00200C0C                          1924m     ENDM
00200C0C                          1925m     PRINT_CRLF D3     
00200C0C                          1926mm     PRINT_CHAR #13,D3                           ; CR
00200C0C                          1927mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C0C                 TRUE     1928mm     IFEQ DEBUG
00200C0C  1639 00C00003           1929mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C12  0803 0002               1930mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C16  67F4                    1931mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00200C18  13FC 000D 00C00007      1932mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C20                          1933mm     ENDC
00200C20                          1934mm     
00200C20                 FALSE    1935mm     IFNE DEBUG
00200C20                          1936mm     ENDC
00200C20                          1937mm 
00200C20                          1938mm     ENDM
00200C20                          1939mm     PRINT_CHAR #10,D3                           ; LF
00200C20                          1940mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C20                 TRUE     1941mm     IFEQ DEBUG
00200C20  1639 00C00003           1942mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C26  0803 0002               1943mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C2A  67F4                    1944mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00200C2C  13FC 000A 00C00007      1945mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C34                          1946mm     ENDC
00200C34                          1947mm     
00200C34                 FALSE    1948mm     IFNE DEBUG
00200C34                          1949mm     ENDC
00200C34                          1950mm 
00200C34                          1951mm     ENDM
00200C34                          1952m     ENDM
00200C34                          1953          
00200C34  4EF9 00200188           1954      JMP MAIN_LOOP
00200C3A                          1955      
00200C3A                          1956  G
00200C3A  2047                    1957      MOVE.L D7,A0                                ; address accumulator -> address register
00200C3C  3E3C 0000               1958      MOVE #0,D7                                  ; clear the now used address accumulator
00200C40  4ED0                    1959      JMP (A0)                                    ; jump to it!
00200C42                          1960      
00200C42                          1961  Z
00200C42  207C 00200000           1962      MOVE.L #RAM,A0                              ; address of RAM
00200C48  7000                    1963      MOVE.L #0,D0                                ; number of bytes
00200C4A                          1964     
00200C4A                          1965      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C4A                          1966s _10000014
00200C4A  B0BC 00040000           1967s     CMP.L   #$40000,D0
00200C50  6E00 001A               1968s     BGT _10000015
00200C54  2200                    1969          MOVE.L D0,D1                            ; progress update
00200C56  E089                    1970          LSR.L #8,D1 
00200C58  E089                    1971          LSR.L #8,D1
00200C5A  0281 0000000F           1972          ANDI.L #$F,D1
00200C60  13C1 00E00001           1973          MOVE.B D1,DISPLAY
00200C66                          1974  
00200C66  20C0                    1975          MOVE.L D0,(A0)+ 
00200C68  5880                    1976          ADD.L #4,D0
00200C6A                          1977      ENDW
00200C6A  60DE                    1978s     BRA _10000014
00200C6C                          1979s _10000015
00200C6C                          1980   
00200C6C  207C 00200000           1981      MOVE.L #RAM,A0                              ; address of RAM
00200C72  7000                    1982      MOVE.L #0,D0                                ; number of bytes
00200C74                          1983     
00200C74                          1984      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200C74                          1985s _10000016
00200C74  B0BC 00040000           1986s     CMP.L   #$40000,D0
00200C7A  6E00 00CC               1987s     BGT _10000017
00200C7E  2200                    1988          MOVE.L D0,D1                            ; progress update
00200C80  E089                    1989          LSR.L #8,D1
00200C82  E089                    1990          LSR.L #8,D1
00200C84  0281 0000000F           1991          ANDI.L #$F,D1
00200C8A  13C1 00E00001           1992          MOVE.B D1,DISPLAY
00200C90                          1993  
00200C90  2218                    1994          MOVE.L (A0)+,D1
00200C92                          1995            
00200C92                          1996          IF.L D0 <EQ> D1 THEN
00200C92  B081                    1997s     CMP.L   D1,D0
00200C94  6600 0006               1998s     BNE _00000009
00200C98  6000 00A8               1999              BRA OK
00200C9C                          2000          ENDI 
00200C9C                          2001s _00000009
00200C9C                          2002            
00200C9C  43F9 00200FEC           2003          LEA RAM_ERROR,A1
00200CA2                          2004m         PRINT_STR A1,D1
00200CA2                          2005m LOOP_135
00200CA2  0C11 0000               2006m     CMP.B #0,(A1)                               ; 0 -> DONE
00200CA6  6700 001A               2007m     BEQ EXIT_135
00200CAA                          2008mm     PRINT_CHAR (A1)+,D1
00200CAA                          2009mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CAA                 TRUE     2010mm     IFEQ DEBUG
00200CAA  1239 00C00003           2011mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200CB0  0801 0002               2012mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200CB4  67F4                    2013mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200CB6  13D9 00C00007           2014mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200CBC                          2015mm     ENDC
00200CBC                          2016mm     
00200CBC                 FALSE    2017mm     IFNE DEBUG
00200CBC                          2018mm     ENDC
00200CBC                          2019mm 
00200CBC                          2020mm     ENDM
00200CBC  4EF9 00200CA2           2021m     JMP LOOP_135
00200CC2                          2022m EXIT_135
00200CC2                          2023m     ENDM
00200CC2  2208                    2024          MOVE.L A0,D1
00200CC4  5981                    2025          SUB.L #4,D1
00200CC6                          2026m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200CC6                          2027mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00200CC6                          2028mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CC6                 TRUE     2029mm     IFEQ DEBUG
00200CC6  1639 00C00003           2030mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CCC  0803 0002               2031mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CD0  67F4                    2032mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00200CD2  13FC 0030 00C00007      2033mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CDA                          2034mm     ENDC
00200CDA                          2035mm     
00200CDA                 FALSE    2036mm     IFNE DEBUG
00200CDA                          2037mm     ENDC
00200CDA                          2038mm 
00200CDA                          2039mm     ENDM
00200CDA                          2040mm     PRINT_CHAR #'x',D3
00200CDA                          2041mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CDA                 TRUE     2042mm     IFEQ DEBUG
00200CDA  1639 00C00003           2043mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CE0  0803 0002               2044mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CE4  67F4                    2045mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00200CE6  13FC 0078 00C00007      2046mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200CEE                          2047mm     ENDC
00200CEE                          2048mm     
00200CEE                 FALSE    2049mm     IFNE DEBUG
00200CEE                          2050mm     ENDC
00200CEE                          2051mm 
00200CEE                          2052mm     ENDM
00200CEE  7C07                    2053m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200CF0                          2054m LOOP_137
00200CF0                          2055mm     BIN2HEX D1,D2,A1
00200CF0  43F9 00200FFE           2056mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200CF6  E999                    2057mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200CF8  1401                    2058mm     MOVE.B D1,D2
00200CFA  0282 0000000F           2059mm     ANDI.L #$F,D2
00200D00  1431 2000               2060mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200D04                          2061mm     ENDM
00200D04                          2062mm     PRINT_CHAR D2,D3
00200D04                          2063mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D04                 TRUE     2064mm     IFEQ DEBUG
00200D04  1639 00C00003           2065mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D0A  0803 0002               2066mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D0E  67F4                    2067mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00200D10  13C2 00C00007           2068mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D16                          2069mm     ENDC
00200D16                          2070mm     
00200D16                 FALSE    2071mm     IFNE DEBUG
00200D16                          2072mm     ENDC
00200D16                          2073mm 
00200D16                          2074mm     ENDM
00200D16  57CE FFD8               2075m     DBEQ D6,LOOP_137
00200D1A                          2076m     ENDM
00200D1A                          2077m         PRINT_CRLF D3
00200D1A                          2078mm     PRINT_CHAR #13,D3                           ; CR
00200D1A                          2079mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D1A                 TRUE     2080mm     IFEQ DEBUG
00200D1A  1639 00C00003           2081mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D20  0803 0002               2082mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D24  67F4                    2083mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00200D26  13FC 000D 00C00007      2084mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D2E                          2085mm     ENDC
00200D2E                          2086mm     
00200D2E                 FALSE    2087mm     IFNE DEBUG
00200D2E                          2088mm     ENDC
00200D2E                          2089mm 
00200D2E                          2090mm     ENDM
00200D2E                          2091mm     PRINT_CHAR #10,D3                           ; LF
00200D2E                          2092mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D2E                 TRUE     2093mm     IFEQ DEBUG
00200D2E  1639 00C00003           2094mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D34  0803 0002               2095mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D38  67F4                    2096mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200D3A  13FC 000A 00C00007      2097mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D42                          2098mm     ENDC
00200D42                          2099mm     
00200D42                 FALSE    2100mm     IFNE DEBUG
00200D42                          2101mm     ENDC
00200D42                          2102mm 
00200D42                          2103mm     ENDM
00200D42                          2104m     ENDM
00200D42                          2105  OK    
00200D42  5880                    2106          ADD.L #4,D0
00200D44                          2107      ENDW
00200D44  6000 FF2E               2108s     BRA _10000016
00200D48                          2109s _10000017
00200D48                          2110      
00200D48  4EF9 00200188           2111      JMP MAIN_LOOP
00200D4E                          2112    
00200D4E                          2113  L
00200D4E  7A00                    2114      MOVE.L #0,D5                                ; D5 will be the length  to write            
00200D50                          2115  
00200D50                          2116m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200D50                          2117m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D50                          2118m 
00200D50                 TRUE     2119m     IFEQ DEBUG
00200D50  1639 00C00003           2120m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D56  0803 0000               2121m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200D5A  67F4                    2122m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00200D5C                          2123m     ENDC
00200D5C                          2124m     
00200D5C                          2125mm     READ_CHAR D2
00200D5C                 TRUE     2126mm     IFEQ DEBUG
00200D5C  1439 00C00007           2127mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200D62                          2128mm     ENDC
00200D62                 FALSE    2129mm     IFNE DEBUG
00200D62                          2130mm     ENDC
00200D62                          2131mm      
00200D62  B43C 001B               2132mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200D66  6700 F2A0               2133mm     BEQ START
00200D6A                          2134mm     ENDM
00200D6A                          2135m 
00200D6A                 TRUE     2136m     IFEQ DEBUG
00200D6A                          2137mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200D6A                          2138mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D6A                 TRUE     2139mm     IFEQ DEBUG
00200D6A  1639 00C00003           2140mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D70  0803 0002               2141mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D74  67F4                    2142mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00200D76  13C2 00C00007           2143mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200D7C                          2144mm     ENDC
00200D7C                          2145mm     
00200D7C                 FALSE    2146mm     IFNE DEBUG
00200D7C                          2147mm     ENDC
00200D7C                          2148mm 
00200D7C                          2149mm     ENDM
00200D7C                          2150m     ENDC
00200D7C                          2151m     ENDM
00200D7C                          2152m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200D7C  41F9 0020100E           2153m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200D82  0402 0030               2154m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200D86  C4BC 000000FF           2155m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200D8C  1430 2000               2156m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200D90                          2157m     ENDM
00200D90  1A02                    2158      MOVE.B D2,D5                                ; put at bottom of D5
00200D92                          2159  
00200D92  3C3C 0002               2160      MOVE #2,D6                                  ; 3 bytes left to read
00200D96                          2161      
00200D96                          2162  READ_LENGTH
00200D96  E98D                    2163      LSL.L #4,D5                                 ; make what we have so far more significant
00200D98                          2164m     WAIT_CHAR D2,D3                             ; next character -> D2
00200D98                          2165m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D98                          2166m 
00200D98                 TRUE     2167m     IFEQ DEBUG
00200D98  1639 00C00003           2168m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D9E  0803 0000               2169m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200DA2  67F4                    2170m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00200DA4                          2171m     ENDC
00200DA4                          2172m     
00200DA4                          2173mm     READ_CHAR D2
00200DA4                 TRUE     2174mm     IFEQ DEBUG
00200DA4  1439 00C00007           2175mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00200DAA                          2176mm     ENDC
00200DAA                 FALSE    2177mm     IFNE DEBUG
00200DAA                          2178mm     ENDC
00200DAA                          2179mm      
00200DAA  B43C 001B               2180mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200DAE  6700 F258               2181mm     BEQ START
00200DB2                          2182mm     ENDM
00200DB2                          2183m 
00200DB2                 TRUE     2184m     IFEQ DEBUG
00200DB2                          2185mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00200DB2                          2186mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DB2                 TRUE     2187mm     IFEQ DEBUG
00200DB2  1639 00C00003           2188mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DB8  0803 0002               2189mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DBC  67F4                    2190mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00200DBE  13C2 00C00007           2191mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200DC4                          2192mm     ENDC
00200DC4                          2193mm     
00200DC4                 FALSE    2194mm     IFNE DEBUG
00200DC4                          2195mm     ENDC
00200DC4                          2196mm 
00200DC4                          2197mm     ENDM
00200DC4                          2198m     ENDC
00200DC4                          2199m     ENDM
00200DC4                          2200m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00200DC4  41F9 0020100E           2201m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200DCA  0402 0030               2202m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DCE  C4BC 000000FF           2203m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200DD4  1430 2000               2204m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200DD8                          2205m     ENDM
00200DD8  8A02                    2206      OR.B D2,D5
00200DDA  023C 00FB               2207      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200DDE  57CE FFB6               2208      DBEQ D6,READ_LENGTH
00200DE2                          2209          
00200DE2                          2210m     PRINT_CRLF D3
00200DE2                          2211mm     PRINT_CHAR #13,D3                           ; CR
00200DE2                          2212mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DE2                 TRUE     2213mm     IFEQ DEBUG
00200DE2  1639 00C00003           2214mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DE8  0803 0002               2215mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200DEC  67F4                    2216mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00200DEE  13FC 000D 00C00007      2217mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200DF6                          2218mm     ENDC
00200DF6                          2219mm     
00200DF6                 FALSE    2220mm     IFNE DEBUG
00200DF6                          2221mm     ENDC
00200DF6                          2222mm 
00200DF6                          2223mm     ENDM
00200DF6                          2224mm     PRINT_CHAR #10,D3                           ; LF
00200DF6                          2225mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200DF6                 TRUE     2226mm     IFEQ DEBUG
00200DF6  1639 00C00003           2227mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200DFC  0803 0002               2228mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E00  67F4                    2229mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00200E02  13FC 000A 00C00007      2230mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200E0A                          2231mm     ENDC
00200E0A                          2232mm     
00200E0A                 FALSE    2233mm     IFNE DEBUG
00200E0A                          2234mm     ENDC
00200E0A                          2235mm 
00200E0A                          2236mm     ENDM
00200E0A                          2237m     ENDM
00200E0A                          2238  
00200E0A  207C 00000000           2239      MOVE.L #ROM,A0                              ; start of ROM
00200E10                          2240      
00200E10  2247                    2241      MOVE.L D7,A1                                ; address accumulator -> address register
00200E12  7E00                    2242      MOVE.L #0,D7                                ; clear the now used address accumulator
00200E14                          2243      
00200E14  267C 00002AAA           2244      MOVE.L #$2AAA,A3
00200E1A  36BC AAAA               2245      MOVE.W #$AAAA,(A3)
00200E1E  267C 00001554           2246      MOVE.L #$1554,A3
00200E24  36BC 5555               2247      MOVE.W #$5555,(A3)
00200E28  267C 00002AAA           2248      MOVE.L #$2AAA,A3
00200E2E  36BC 8080               2249      MOVE.W #$8080,(A3)
00200E32  267C 00002AAA           2250      MOVE.L #$2AAA,A3
00200E38  36BC AAAA               2251      MOVE.W #$AAAA,(A3)
00200E3C  267C 00001554           2252      MOVE.L #$1554,A3
00200E42  36BC 5555               2253      MOVE.W #$5555,(A3)
00200E46  267C 00002AAA           2254      MOVE.L #$2AAA,A3
00200E4C  36BC 2020               2255      MOVE.W #$2020,(A3)
00200E50                          2256      
00200E50  45F9 00201025           2257      LEA LOADING,A2                              ; important for timing
00200E56                          2258m     PRINT_STR A2,D3
00200E56                          2259m LOOP_156
00200E56  0C12 0000               2260m     CMP.B #0,(A2)                               ; 0 -> DONE
00200E5A  6700 001A               2261m     BEQ EXIT_156
00200E5E                          2262mm     PRINT_CHAR (A2)+,D3
00200E5E                          2263mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200E5E                 TRUE     2264mm     IFEQ DEBUG
00200E5E  1639 00C00003           2265mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200E64  0803 0002               2266mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200E68  67F4                    2267mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00200E6A  13DA 00C00007           2268mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200E70                          2269mm     ENDC
00200E70                          2270mm     
00200E70                 FALSE    2271mm     IFNE DEBUG
00200E70                          2272mm     ENDC
00200E70                          2273mm 
00200E70                          2274mm     ENDM
00200E70  4EF9 00200E56           2275m     JMP LOOP_156
00200E76                          2276m EXIT_156
00200E76                          2277m     ENDM
00200E76                          2278  
00200E76  023C 00FB               2279      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00200E7A                          2280      
00200E7A                          2281      WHILE D5 <GT> #0 DO
00200E7A                          2282s _10000018
00200E7A  BA7C 0000               2283s     CMP.W   #0,D5
00200E7E  6F00 0020               2284s     BLE _10000019
00200E82  5585                    2285          SUB.L #2,D5
00200E84                          2286            
00200E84  13D1 00E00001           2287          MOVE.B (A1),DISPLAY
00200E8A  3091                    2288          MOVE.W (A1),(A0)                        ; write the data
00200E8C                          2289        
00200E8C                          2290  WAIT_FOR_COMPLETE
00200E8C  3410                    2291          MOVE.W (A0),D2
00200E8E                          2292  
00200E8E                          2293          IF D2 <NE> (A1) THEN
00200E8E  B451                    2294s     CMP.W   (A1),D2
00200E90  6700 0008               2295s     BEQ _0000000A
00200E94  4EF9 00200E8C           2296              JMP WAIT_FOR_COMPLETE
00200E9A                          2297          ENDI
00200E9A                          2298s _0000000A
00200E9A                          2299        
00200E9A  5488                    2300          ADD.L #2,A0
00200E9C  5489                    2301          ADD.L #2,A1
00200E9E                          2302      ENDW  
00200E9E  60DA                    2303s     BRA _10000018
00200EA0                          2304s _10000019
00200EA0                          2305      
00200EA0  267C 00002AAA           2306      MOVE.L #$2AAA,A3
00200EA6  36BC AAAA               2307      MOVE.W #$AAAA,(A3)
00200EAA  267C 00001554           2308      MOVE.L #$1554,A3
00200EB0  36BC 5555               2309      MOVE.W #$5555,(A3)
00200EB4  267C 00002AAA           2310      MOVE.L #$2AAA,A3
00200EBA  36BC A0A0               2311      MOVE.W #$A0A0,(A3)
00200EBE                          2312              
00200EBE  4EF9 00200188           2313      JMP MAIN_LOOP
00200EC4                          2314          
00200EC4                          2315  HEX_DIGIT
00200EC4  E98F                    2316      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200EC6                          2317m     HEX2BIN D2,D2,A0
00200EC6  41F9 0020100E           2318m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00200ECC  0402 0030               2319m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200ED0  C4BC 000000FF           2320m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00200ED6  1430 2000               2321m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00200EDA                          2322m     ENDM
00200EDA  8E02                    2323      OR.B D2,D7  
00200EDC  4EF9 002001B0           2324      JMP GET_INPUT
00200EE2                          2325  
00200EE2  FFFF FFFF               2326      SIMHALT                                     ; halt simulator
00200EE6                          2327  
00200EE6                          2328  ; strings
00200EE6= 4D 44 46 2D 6D 6F ...   2329  VERSION DC.B 'MDF-mon V1.47 (10/04/2021)',13,10,0
00200F03= 3F 20 48 65 6C 70 ...   2330  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00200F9A= 48 75 68 3F 0D 0A 00    2331  HUH     DC.B 'Huh?',13,10,0
00200FA1= 20 53 20 72 65 63 ...   2332  READ    DC.B ' S records read, start address = ',0
00200FC3= 57 3A 20 55 6E 6B ...   2333  UNREC   DC.B 'W: Unknown Srec type: ',0
00200FDA= 57 3A 20 43 53 20 ...   2334  CS_FAILURE   DC.B 'W: CS failure at ',0
00200FEC= 57 3A 20 52 41 4D ...   2335  RAM_ERROR DC.B 'W: RAM error at: ',0
00200FFE= 30 31 32 33 34 35 ...   2336  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0020100E= 00 01 02 03 04 05 ...   2337  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00201025= 4C 6F 61 64 69 6E ...   2338  LOADING  DC.B 'Loading EEPROM...',13,11,0
00201039                          2339      
00201039                          2340      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200FFE
CONTINUE_103        200A1E
CONTINUE_44         2004BC
CONTINUE_47         20050C
CONTINUE_51         200562
CONTINUE_59         20061C
CONTINUE_64         20068E
CONTINUE_69         20070E
CONTINUE_74         200792
CONTINUE_79         20081E
CONTINUE_84         200890
CONTINUE_89         200906
CS_FAILURE          200FDA
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       200B3C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            200AB8
EXIT_125            200BB6
EXIT_135            200CC2
EXIT_156            200E76
EXIT_19             2002EA
EXIT_21             200316
EXIT_23             200342
EXIT_5              200142
EXIT_96             2009AC
G                   200C3A
GET_INPUT           2001B0
H                   2002F0
HELP                200F03
HEX2BIN             134
HEX2BIN_LUT         20100E
HEX_DIGIT           200EC4
HUH                 200F9A
L                   200D4E
LOADING             201025
LOOP_110            200A98
LOOP_112            200AE2
LOOP_120            200B66
LOOP_125            200B96
LOOP_127            200BE2
LOOP_135            200CA2
LOOP_137            200CF0
LOOP_156            200E56
LOOP_19             2002CA
LOOP_21             2002F6
LOOP_23             200322
LOOP_25             200376
LOOP_5              200122
LOOP_96             20098C
MAIN_LOOP           200188
OK                  200D42
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   200348
RAM                 200000
RAM_ERROR           200FEC
READ                200FA1
READ_CHAR           805
READ_DATA_TO_POKE   200418
READ_LENGTH         200D96
RESET               200004
ROM                 0
S                   200498
STACK               200000
START               200008
UNREC               200FC3
V                   20031C
VERSION             200EE6
W                   2003D0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   200E8C
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   20016A
WAIT_FOR_READY_100  2009BE
WAIT_FOR_READY_101  2009D2
WAIT_FOR_READY_103  200A02
WAIT_FOR_READY_105  200A36
WAIT_FOR_READY_108  200A64
WAIT_FOR_READY_109  200A78
WAIT_FOR_READY_11   200188
WAIT_FOR_READY_111  200AA0
WAIT_FOR_READY_113  200AB8
WAIT_FOR_READY_114  200ACC
WAIT_FOR_READY_116  200AF6
WAIT_FOR_READY_118  200B0C
WAIT_FOR_READY_119  200B20
WAIT_FOR_READY_12   20019C
WAIT_FOR_READY_121  200B3C
WAIT_FOR_READY_122  200B50
WAIT_FOR_READY_124  200B7A
WAIT_FOR_READY_126  200B9E
WAIT_FOR_READY_128  200BB8
WAIT_FOR_READY_129  200BCC
WAIT_FOR_READY_13   2001B0
WAIT_FOR_READY_131  200BF6
WAIT_FOR_READY_133  200C0C
WAIT_FOR_READY_134  200C20
WAIT_FOR_READY_136  200CAA
WAIT_FOR_READY_138  200CC6
WAIT_FOR_READY_139  200CDA
WAIT_FOR_READY_141  200D04
WAIT_FOR_READY_143  200D1A
WAIT_FOR_READY_144  200D2E
WAIT_FOR_READY_145  200D50
WAIT_FOR_READY_147  200D6A
WAIT_FOR_READY_149  200D98
WAIT_FOR_READY_15   2001CA
WAIT_FOR_READY_151  200DB2
WAIT_FOR_READY_154  200DE2
WAIT_FOR_READY_155  200DF6
WAIT_FOR_READY_157  200E5E
WAIT_FOR_READY_17   20026C
WAIT_FOR_READY_18   200280
WAIT_FOR_READY_20   2002D2
WAIT_FOR_READY_22   2002FE
WAIT_FOR_READY_24   20032A
WAIT_FOR_READY_26   20034C
WAIT_FOR_READY_27   200360
WAIT_FOR_READY_29   20038A
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_31   2003A0
WAIT_FOR_READY_32   2003B4
WAIT_FOR_READY_33   2003D2
WAIT_FOR_READY_35   2003EC
WAIT_FOR_READY_37   20041A
WAIT_FOR_READY_39   200434
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_42   20046A
WAIT_FOR_READY_43   20047E
WAIT_FOR_READY_44   2004A0
WAIT_FOR_READY_46   2004DA
WAIT_FOR_READY_47   2004F0
WAIT_FOR_READY_49   200524
WAIT_FOR_READY_51   200546
WAIT_FOR_READY_53   20057A
WAIT_FOR_READY_56   2005B2
WAIT_FOR_READY_57   2005C6
WAIT_FOR_READY_59   200600
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_61   200634
WAIT_FOR_READY_64   200672
WAIT_FOR_READY_66   2006A6
WAIT_FOR_READY_69   2006F2
WAIT_FOR_READY_71   200726
WAIT_FOR_READY_74   200776
WAIT_FOR_READY_76   2007AA
WAIT_FOR_READY_79   200802
WAIT_FOR_READY_8    200142
WAIT_FOR_READY_81   200836
WAIT_FOR_READY_84   200874
WAIT_FOR_READY_86   2008A8
WAIT_FOR_READY_89   2008EA
WAIT_FOR_READY_9    200156
WAIT_FOR_READY_91   20091E
WAIT_FOR_READY_94   20095E
WAIT_FOR_READY_95   200972
WAIT_FOR_READY_97   200994
WAIT_FOR_READY_98   2009AC
WAIT_FOR_SRECORD    2004A0
Z                   200C42
_00000000           2005E2
_00000001           2009EC
_00000002           2005F0
_00000003           2007EC
_00000004           20075A
_00000005           2009EC
_00000006           20095E
_00000007           2009EC
_00000008           200B3A
_00000009           200C9C
_0000000A           200E9A
_10000000           20053E
_10000001           2005A8
_10000002           2005F8
_10000003           200662
_10000004           20066A
_10000005           2006D4
_10000006           2006EA
_10000007           200754
_10000008           20075E
_10000009           2007E2
_1000000A           20076E
_1000000B           2007D8
_1000000C           2007FA
_1000000D           200864
_1000000E           20086C
_1000000F           2008D6
_10000010           2008E2
_10000011           20094C
_10000012           2009FA
_10000013           200A64
_10000014           200C4A
_10000015           200C6C
_10000016           200C74
_10000017           200D48
_10000018           200E7A
_10000019           200EA0
