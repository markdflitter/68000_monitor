00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 18:55:02

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                             9  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            10  
00000000                            11  ; ideas, but no room to do them
00000000                            12  ;------------------------------
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20      ;ORG  $200000
00000000                            21  
00000000  =00000000                 22  DEBUG               EQU 0
00000000                            23  
00000000                            24  ; constants
00000000  =00000000                 25  NULL                EQU 0
00000000  =00000009                 26  TAB                 EQU 9
00000000  =0000000D                 27  CR                  EQU 13
00000000  =0000000A                 28  LF                  EQU 10
00000000                            29  
00000000  =00000000                 30  ROM                 EQU $0
00000000  =00200000                 31  RAM                 EQU $200000
00000000                            32     
00000000  =00C00000                 33  DUART_BASE          EQU $C00000
00000000  =00000000                 34  DUART_MRA_          EQU $0
00000000  =00000001                 35  DUART_CSRA_         EQU $1
00000000  =00000001                 36  DUART_SRA_          EQU $1
00000000  =00000002                 37  DUART_CRA_          EQU $2
00000000  =00000003                 38  DUART_TXA_          EQU $3
00000000  =00000003                 39  DUART_RXA_          EQU $3
00000000  =00000004                 40  DUART_ACR_          EQU $4
00000000  =00000005                 41  DUART_IMR_          EQU $5
00000000  =00000008                 42  DUART_MRB_          EQU $8
00000000  =00000009                 43  DUART_CSRB_         EQU $9
00000000  =00000009                 44  DUART_SRB_          EQU $9
00000000  =0000000A                 45  DUART_CRB_          EQU $A
00000000  =0000000B                 46  DUART_TXB_          EQU $B
00000000  =0000000B                 47  DUART_RXB_          EQU $B
00000000  =0000000C                 48  DUART_IVR_          EQU $C
00000000  =0000000D                 49  DUART_OPCR_         EQU $D
00000000  =0000000E                 50  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 51  DUART_RESET_OPR_    EQU $F
00000000                            52  
00000000  =00C00001                 53  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 54  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 55  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 56  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 57  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 58  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            59  
00000000  =00C00011                 60  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 61  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 62  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 63  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 64  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 65  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            66  
00000000  =00C00009                 67  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 68  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 69  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 70  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 71  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 72  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            73  
00000000  =00E00000                 74  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 75  DISPLAY_            EQU $0
00000000  =00E00001                 76  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            77  
00000000                            78  ; macros
00000000                            79  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            80  ; the input register is changed during the process
00000000                            81  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            82  BIN2HEX MACRO
00000000                            83      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            84      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            85      MOVE.B \1,\2
00000000                            86      ANDI.L #$F,\2
00000000                            87      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            88      ENDM
00000000                            89  
00000000                            90  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            91  ; the input register is changed during the process
00000000                            92  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            93  HEX2BIN MACRO
00000000                            94      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00000000                            95      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            96      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            97      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                            98      ENDM
00000000                            99  
00000000                           100  ; send a single char to the serial port
00000000                           101  ; \1 = char to send, \2 = data register to use for status poll
00000000                           102  ; will stamp on D0 and D1 in debug mode
00000000                           103  PRINT_CHAR MACRO
00000000                           104  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           105      IFEQ DEBUG
00000000                           106          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           107          BTST #2,\2                              ; check for space to send
00000000                           108          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           109          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           110      ENDC
00000000                           111      
00000000                           112      IFNE DEBUG
00000000                           113          MOVE.B \1,D1
00000000                           114          MOVE.L #6,D0   
00000000                           115          TRAP #15                                ; write to terminal in simulator
00000000                           116      ENDC
00000000                           117  
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send CR,LF to the serial port
00000000                           121  ; \1 = data register to use for status poll, /2 = working address register
00000000                           122  PRINT_CRLF MACRO
00000000                           123      LEA CRLF,\2
00000000                           124      PRINT_STR \2,\1
00000000                           125      ENDM
00000000                           126  
00000000                           127  ; send C-style, zero terminated string to the serial port
00000000                           128  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           129  PRINT_STR MACRO
00000000                           130  LOOP\@
00000000                           131      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           132      BEQ EXIT\@
00000000                           133      PRINT_CHAR (\1)+,\2
00000000                           134      BRA LOOP\@
00000000                           135  EXIT\@
00000000                           136      ENDM
00000000                           137    
00000000                           138  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           139  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           140  PRINT_REG MACRO
00000000                           141      LEA ox,\5
00000000                           142      PRINT_STR \5,\2
00000000                           143      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           144  LOOP\@
00000000                           145      BIN2HEX \1,\3,\5
00000000                           146      PRINT_CHAR \3,\2
00000000                           147      DBEQ \4,LOOP\@
00000000                           148      ENDM
00000000                           149      
00000000                           150  ; wait for a char from the serial port
00000000                           151  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  WAIT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #0,\2                              ; check for character
00000000                           158          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           159      ENDC
00000000                           160      
00000000                           161      READ_CHAR \1
00000000                           162  
00000000                           163      IFEQ DEBUG
00000000                           164          PRINT_CHAR \1,\2                            ; echo it back
00000000                           165      ENDC
00000000                           166      ENDM
00000000                           167      
00000000                           168  ; read a char from the serial port - assumes that there is one!
00000000                           169  ; \ 1= data register for read char
00000000                           170  ; will stamp on D0 and D1 in debug mode
00000000                           171  READ_CHAR MACRO
00000000                           172      IFEQ DEBUG
00000000                           173          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           174      ENDC
00000000                           175      IFNE DEBUG
00000000                           176          MOVE.L #5,D0    
00000000                           177          TRAP #15                                    ; read from keyboard in simulator
00000000                           178          MOVE.L D1,\1
00000000                           179      ENDC
00000000                           180       
00000000                           181      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           182      BEQ START
00000000                           183      ENDM
00000000                           184      
00000000                           185      
00000000                           186  ; read data from the download serial port
00000000                           187  ; \ 1= data register for read char
00000000                           188  DOWNLOAD MACRO
00000000                           189  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           190  
00000000                           191      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           192      BTST #0,\1                                  ; check for character
00000000                           193      BEQ CONTINUE\@                              ; nothing, continue
00000000                           194   
00000000                           195      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           196  CONTINUE\@
00000000                           197      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           198      BTST #0,\1                                      ; check for character
00000000                           199      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           200      
00000000                           201      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           202      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           203      
00000000                           204      ENDM
00000000                           205      
00000000                           206  ; read two hex digits from the download serial port and convert to a byte
00000000                           207  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           208  DOWNLOAD_BYTE MACRO
00000000                           209      MOVE.B #2,\4
00000000                           210      WHILE.B \4 <GT> 0 DO
00000000                           211          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           212          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           213          PRINT_CHAR \2,\3
00000000                           214          HEX2BIN \2,\2,\6
00000000                           215          OR.B \2,\1
00000000                           216          SUB.B #1,\4
00000000                           217      ENDW
00000000                           218      
00000000                           219      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           220      MOVE.B \1,\2
00000000                           221      ADD.L \1,\5
00000000                           222  
00000000                           223      ENDM
00000000                           224      
00000000                           225  
00000000                           226  ; register catalogue
00000000                           227  ; D0 - used for simulator I/O
00000000                           228  ; D1 - used for simulator I/O
00000000                           229  ; D2 - read character
00000000                           230  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           231  ; D6 - working register used in R/W
00000000                           232  ; D7 - address accumulator, reset by download
00000000                           233  ; A0 - address of string to print 
00000000                           234  
00000000                           235  ; start vector
00000000= 00000000                 236  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 237  RESET    DC.L START                             ; RESET
00000008                           238      
00000008                           239  ; start of program  
00000008                           240  START
00000008  13FC 0000 00E00001       241      MOVE.B #0,DISPLAY
00000010                           242  
00000010                           243  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       244      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       245      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           246      
00000020                           247      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                248s     MOVE.W  #$50,D1
00000024  6000 000E                249s     BRA _20000001
00000028                           250s _20000000
00000028  13C1 00C00005            251          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     252          NOP
00000030                           253      ENDF
00000030  0441 0010                254s     SUB.W   #$10,D1
00000034                           255s _20000001
00000034  B27C 0010                256s     CMP.W   #$10,D1
00000038  6CEE                     257s     BGE _20000000
0000003A                           258  
0000003A                           259      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                260s     MOVE.W  #$50,D1
0000003E  6000 000E                261s     BRA _20000003
00000042                           262s _20000002
00000042  13C1 00C00015            263          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     264          NOP
0000004A                           265      ENDF
0000004A  0441 0010                266s     SUB.W   #$10,D1
0000004E                           267s _20000003
0000004E  B27C 0010                268s     CMP.W   #$10,D1
00000052  6CEE                     269s     BGE _20000002
00000054                           270    
00000054                           271  ;initialise UART
00000054  13FC 0000 00C00009       272      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       273      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       274      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           275  
0000006C                           276  ; channel A
0000006C  13FC 0013 00C00001       277      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       278      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       279      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       280      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           281  
0000008C                           282  ; channel B
0000008C  13FC 0013 00C00011       283      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       284      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       285      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       286      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           287  
000000AC                           288m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000AC                           289m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      290m     IFEQ DEBUG
000000AC  1639 00C00003            291m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000B2  0803 0002                292m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000B6  67F4                     293m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000B8  13F8 002E 00C00007       294m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000C0                           295m     ENDC
000000C0                           296m     
000000C0                 FALSE     297m     IFNE DEBUG
000000C0                           298m     ENDC
000000C0                           299m 
000000C0                           300m     ENDM
000000C0                           301  
000000C0  13FC 0001 00E00001       302      MOVE.B #1,DISPLAY
000000C8                           303         
000000C8                           304m     PRINT_CRLF D3,A0
000000C8  41F9 00000E2E            305m     LEA CRLF,A0
000000CE                           306mm     PRINT_STR A0,D3
000000CE                           307mm LOOP_3
000000CE  0C10 0000                308mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000D2  6700 0016                309mm     BEQ EXIT_3
000000D6                           310mmm     PRINT_CHAR (A0)+,D3
000000D6                           311mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D6                 TRUE      312mmm     IFEQ DEBUG
000000D6  1639 00C00003            313mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DC  0803 0002                314mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E0  67F4                     315mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
000000E2  13D8 00C00007            316mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000E8                           317mmm     ENDC
000000E8                           318mmm     
000000E8                 FALSE     319mmm     IFNE DEBUG
000000E8                           320mmm     ENDC
000000E8                           321mmm 
000000E8                           322mmm     ENDM
000000E8  60E4                     323mm     BRA LOOP_3
000000EA                           324mm EXIT_3
000000EA                           325mm     ENDM
000000EA                           326m     ENDM
000000EA                           327  
000000EA  41F9 00000CC2            328      LEA VERSION,A0
000000F0                           329m     PRINT_STR A0,D3
000000F0                           330m LOOP_5
000000F0  0C10 0000                331m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000F4  6700 0016                332m     BEQ EXIT_5
000000F8                           333mm     PRINT_CHAR (A0)+,D3
000000F8                           334mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F8                 TRUE      335mm     IFEQ DEBUG
000000F8  1639 00C00003            336mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FE  0803 0002                337mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000102  67F4                     338mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000104  13D8 00C00007            339mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000010A                           340mm     ENDC
0000010A                           341mm     
0000010A                 FALSE     342mm     IFNE DEBUG
0000010A                           343mm     ENDC
0000010A                           344mm 
0000010A                           345mm     ENDM
0000010A  60E4                     346m     BRA LOOP_5
0000010C                           347m EXIT_5
0000010C                           348m     ENDM
0000010C                           349m     PRINT_CRLF D3,A0
0000010C  41F9 00000E2E            350m     LEA CRLF,A0
00000112                           351mm     PRINT_STR A0,D3
00000112                           352mm LOOP_8
00000112  0C10 0000                353mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000116  6700 0016                354mm     BEQ EXIT_8
0000011A                           355mmm     PRINT_CHAR (A0)+,D3
0000011A                           356mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011A                 TRUE      357mmm     IFEQ DEBUG
0000011A  1639 00C00003            358mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000120  0803 0002                359mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000124  67F4                     360mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000126  13D8 00C00007            361mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000012C                           362mmm     ENDC
0000012C                           363mmm     
0000012C                 FALSE     364mmm     IFNE DEBUG
0000012C                           365mmm     ENDC
0000012C                           366mmm 
0000012C                           367mmm     ENDM
0000012C  60E4                     368mm     BRA LOOP_8
0000012E                           369mm EXIT_8
0000012E                           370mm     ENDM
0000012E                           371m     ENDM
0000012E                           372  
0000012E  7E00                     373      MOVE.L #0,D7                                    ; address accumulator
00000130                           374  
00000130  13FC 0002 00E00001       375      MOVE.B #2,DISPLAY
00000138                           376  MAIN_LOOP
00000138  41F9 00000E31            377      LEA PROMPT,A0
0000013E                           378m     PRINT_STR A0,D3
0000013E                           379m LOOP_10
0000013E  0C10 0000                380m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000142  6700 0016                381m     BEQ EXIT_10
00000146                           382mm     PRINT_CHAR (A0)+,D3
00000146                           383mm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000146                 TRUE      384mm     IFEQ DEBUG
00000146  1639 00C00003            385mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000014C  0803 0002                386mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000150  67F4                     387mm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000152  13D8 00C00007            388mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000158                           389mm     ENDC
00000158                           390mm     
00000158                 FALSE     391mm     IFNE DEBUG
00000158                           392mm     ENDC
00000158                           393mm 
00000158                           394mm     ENDM
00000158  60E4                     395m     BRA LOOP_10
0000015A                           396m EXIT_10
0000015A                           397m     ENDM
0000015A                           398      
0000015A                           399  GET_INPUT
0000015A                           400m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
0000015A                           401m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015A                 TRUE      402m     IFEQ DEBUG
0000015A  1639 00C00003            403m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000160  0803 0000                404m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000164  67F4                     405m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
00000166                           406m     ENDC
00000166                           407m     
00000166                           408mm     READ_CHAR D2
00000166                 TRUE      409mm     IFEQ DEBUG
00000166  1439 00C00007            410mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000016C                           411mm     ENDC
0000016C                 FALSE     412mm     IFNE DEBUG
0000016C                           413mm     ENDC
0000016C                           414mm      
0000016C  B43C 001B                415mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000170  6700 FE96                416mm     BEQ START
00000174                           417mm     ENDM
00000174                           418m 
00000174                 TRUE      419m     IFEQ DEBUG
00000174                           420mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000174                           421mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000174                 TRUE      422mm     IFEQ DEBUG
00000174  1639 00C00003            423mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000017A  0803 0002                424mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000017E  67F4                     425mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
00000180  13C2 00C00007            426mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000186                           427mm     ENDC
00000186                           428mm     
00000186                 FALSE     429mm     IFNE DEBUG
00000186                           430mm     ENDC
00000186                           431mm 
00000186                           432mm     ENDM
00000186                           433m     ENDC
00000186                           434m     ENDM
00000186                           435      
00000186                           436      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000186  B43C 0030                437s     CMP.B   #'0',D2
0000018A  6D00 000E                438s     BLT _00000000
0000018E  B43C 0039                439s     CMP.B   #'9',D2
00000192  6E00 0006                440s     BGT _00000000
00000196  6000 0B0A                441          BRA HEX_DIGIT
0000019A                           442      ENDI
0000019A                           443s _00000000
0000019A                           444      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000019A  B43C 0041                445s     CMP.B   #'A',D2
0000019E  6D00 000E                446s     BLT _00000001
000001A2  B43C 0046                447s     CMP.B   #'F',D2
000001A6  6E00 0006                448s     BGT _00000001
000001AA  6000 0AF6                449          BRA HEX_DIGIT
000001AE                           450      ENDI
000001AE                           451s _00000001
000001AE                           452          
000001AE  B43C 0077                453      CMP.B #'w',D2
000001B2  6700 012C                454      BEQ W
000001B6                           455      
000001B6  B43C 006C                456      CMP.B #'l',D2
000001BA  6700 09E6                457      BEQ L 
000001BE                           458  
000001BE                           459m     PRINT_CRLF D3,A0
000001BE  41F9 00000E2E            460m     LEA CRLF,A0
000001C4                           461mm     PRINT_STR A0,D3
000001C4                           462mm LOOP_16
000001C4  0C10 0000                463mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001C8  6700 0016                464mm     BEQ EXIT_16
000001CC                           465mmm     PRINT_CHAR (A0)+,D3
000001CC                           466mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CC                 TRUE      467mmm     IFEQ DEBUG
000001CC  1639 00C00003            468mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001D2  0803 0002                469mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D6  67F4                     470mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
000001D8  13D8 00C00007            471mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001DE                           472mmm     ENDC
000001DE                           473mmm     
000001DE                 FALSE     474mmm     IFNE DEBUG
000001DE                           475mmm     ENDC
000001DE                           476mmm 
000001DE                           477mmm     ENDM
000001DE  60E4                     478mm     BRA LOOP_16
000001E0                           479mm EXIT_16
000001E0                           480mm     ENDM
000001E0                           481m     ENDM
000001E0                           482   
000001E0  B43C 003F                483      CMP.B #'?',D2
000001E4  6700 0050                484      BEQ H
000001E8                           485   
000001E8  B43C 0076                486      CMP.B #'v',D2
000001EC  6700 0052                487      BEQ V
000001F0                           488      
000001F0  B43C 0072                489      CMP.B #'r',D2
000001F4  6700 0070                490      BEQ R
000001F8                           491  
000001F8  B43C 0073                492      CMP.B #'s',D2
000001FC  6700 015A                493      BEQ S
00000200                           494  
00000200  B43C 0067                495      CMP.B #'g',D2
00000204  6700 08AA                496      BEQ G   
00000208                           497  
00000208  B43C 007A                498      CMP.B #'z',D2
0000020C  6700 08AA                499      BEQ Z   
00000210                           500  
00000210  41F9 00000D8F            501      LEA HUH,A0
00000216                           502m     PRINT_STR A0,D3
00000216                           503m LOOP_18
00000216  0C10 0000                504m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000021A  6700 0016                505m     BEQ EXIT_18
0000021E                           506mm     PRINT_CHAR (A0)+,D3
0000021E                           507mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021E                 TRUE      508mm     IFEQ DEBUG
0000021E  1639 00C00003            509mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000224  0803 0002                510mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000228  67F4                     511mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000022A  13D8 00C00007            512mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000230                           513mm     ENDC
00000230                           514mm     
00000230                 FALSE     515mm     IFNE DEBUG
00000230                           516mm     ENDC
00000230                           517mm 
00000230                           518mm     ENDM
00000230  60E4                     519m     BRA LOOP_18
00000232                           520m EXIT_18
00000232                           521m     ENDM
00000232                           522                         
00000232  6000 FF04                523      BRA MAIN_LOOP
00000236                           524      
00000236                           525  ; commands
00000236                           526  H   
00000236  41F9 00000CDF            527      LEA HELP,A0
0000023C  6000 0008                528      BRA PRINTSTR
00000240                           529  
00000240                           530  V   
00000240  41F9 00000CC2            531      LEA VERSION,A0
00000246                           532  PRINTSTR
00000246                           533m     PRINT_STR A0,D3       
00000246                           534m LOOP_20
00000246  0C10 0000                535m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000024A  6700 0016                536m     BEQ EXIT_20
0000024E                           537mm     PRINT_CHAR (A0)+,D3
0000024E                           538mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024E                 TRUE      539mm     IFEQ DEBUG
0000024E  1639 00C00003            540mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000254  0803 0002                541mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000258  67F4                     542mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000025A  13D8 00C00007            543mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000260                           544mm     ENDC
00000260                           545mm     
00000260                 FALSE     546mm     IFNE DEBUG
00000260                           547mm     ENDC
00000260                           548mm 
00000260                           549mm     ENDM
00000260  60E4                     550m     BRA LOOP_20
00000262                           551m EXIT_20
00000262                           552m     ENDM
00000262  6000 FED4                553      BRA MAIN_LOOP
00000266                           554      
00000266                           555  R   
00000266  2047                     556      MOVE.L D7,A0                                    ; address accumulator -> address register
00000268  7E00                     557      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000026A  2410                     558      MOVE.L (A0),D2                                  ; read the memory and print it
0000026C                           559m     PRINT_REG D2,D3,D4,D5,A0
0000026C  41F9 00000E34            560m     LEA OX,A0
00000272                           561mm     PRINT_STR A0,D3
00000272                           562mm LOOP_23
00000272  0C10 0000                563mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000276  6700 0016                564mm     BEQ EXIT_23
0000027A                           565mmm     PRINT_CHAR (A0)+,D3
0000027A                           566mmm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027A                 TRUE      567mmm     IFEQ DEBUG
0000027A  1639 00C00003            568mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000280  0803 0002                569mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000284  67F4                     570mmm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000286  13D8 00C00007            571mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000028C                           572mmm     ENDC
0000028C                           573mmm     
0000028C                 FALSE     574mmm     IFNE DEBUG
0000028C                           575mmm     ENDC
0000028C                           576mmm 
0000028C                           577mmm     ENDM
0000028C  60E4                     578mm     BRA LOOP_23
0000028E                           579mm EXIT_23
0000028E                           580mm     ENDM
0000028E  7A07                     581m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000290                           582m LOOP_22
00000290                           583mm     BIN2HEX D2,D4,A0
00000290  41F9 00000DF3            584mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000296  E99A                     585mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000298  1802                     586mm     MOVE.B D2,D4
0000029A  0284 0000000F            587mm     ANDI.L #$F,D4
000002A0  1830 4000                588mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
000002A4                           589mm     ENDM
000002A4                           590mm     PRINT_CHAR D4,D3
000002A4                           591mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002A4                 TRUE      592mm     IFEQ DEBUG
000002A4  1639 00C00003            593mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002AA  0803 0002                594mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002AE  67F4                     595mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002B0  13C4 00C00007            596mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002B6                           597mm     ENDC
000002B6                           598mm     
000002B6                 FALSE     599mm     IFNE DEBUG
000002B6                           600mm     ENDC
000002B6                           601mm 
000002B6                           602mm     ENDM
000002B6  57CD FFD8                603m     DBEQ D5,LOOP_22
000002BA                           604m     ENDM
000002BA                           605m     PRINT_CRLF D3,A0
000002BA  41F9 00000E2E            606m     LEA CRLF,A0
000002C0                           607mm     PRINT_STR A0,D3
000002C0                           608mm LOOP_28
000002C0  0C10 0000                609mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002C4  6700 0016                610mm     BEQ EXIT_28
000002C8                           611mmm     PRINT_CHAR (A0)+,D3
000002C8                           612mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      613mmm     IFEQ DEBUG
000002C8  1639 00C00003            614mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002CE  0803 0002                615mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002D2  67F4                     616mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            617mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002DA                           618mmm     ENDC
000002DA                           619mmm     
000002DA                 FALSE     620mmm     IFNE DEBUG
000002DA                           621mmm     ENDC
000002DA                           622mmm 
000002DA                           623mmm     ENDM
000002DA  60E4                     624mm     BRA LOOP_28
000002DC                           625mm EXIT_28
000002DC                           626mm     ENDM
000002DC                           627m     ENDM
000002DC  6000 FE5A                628      BRA MAIN_LOOP
000002E0                           629  
000002E0                           630  W
000002E0  3C3C 0007                631      MOVE #7,D6                                      ; 7 bytes left to read
000002E4                           632      
000002E4                           633  READ_DATA_TO_POKE
000002E4  E98D                     634      LSL.L #4,D5                                     ; make what we have so far more significant
000002E6                           635m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002E6                           636m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E6                 TRUE      637m     IFEQ DEBUG
000002E6  1639 00C00003            638m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EC  0803 0000                639m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002F0  67F4                     640m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
000002F2                           641m     ENDC
000002F2                           642m     
000002F2                           643mm     READ_CHAR D2
000002F2                 TRUE      644mm     IFEQ DEBUG
000002F2  1439 00C00007            645mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002F8                           646mm     ENDC
000002F8                 FALSE     647mm     IFNE DEBUG
000002F8                           648mm     ENDC
000002F8                           649mm      
000002F8  B43C 001B                650mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002FC  6700 FD0A                651mm     BEQ START
00000300                           652mm     ENDM
00000300                           653m 
00000300                 TRUE      654m     IFEQ DEBUG
00000300                           655mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000300                           656mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000300                 TRUE      657mm     IFEQ DEBUG
00000300  1639 00C00003            658mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000306  0803 0002                659mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000030A  67F4                     660mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
0000030C  13C2 00C00007            661mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000312                           662mm     ENDC
00000312                           663mm     
00000312                 FALSE     664mm     IFNE DEBUG
00000312                           665mm     ENDC
00000312                           666mm 
00000312                           667mm     ENDM
00000312                           668m     ENDC
00000312                           669m     ENDM
00000312                           670m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000312  41F9 00000E03            671m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000318  0402 0030                672m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000031C  C4BC 000000FF            673m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000322  1430 2000                674m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000326                           675m     ENDM
00000326  8A02                     676      OR.B D2,D5
00000328  57CE FFBA                677      DBEQ D6,READ_DATA_TO_POKE
0000032C                           678      
0000032C  2047                     679      MOVE.L D7,A0                                    ; address accumulator -> address register
0000032E  7E00                     680      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000330                           681      
00000330  2085                     682      MOVE.L D5,(A0)                                  ; write the data
00000332                           683  
00000332                           684m     PRINT_CRLF D3,A0
00000332  41F9 00000E2E            685m     LEA CRLF,A0
00000338                           686mm     PRINT_STR A0,D3
00000338                           687mm LOOP_35
00000338  0C10 0000                688mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000033C  6700 0016                689mm     BEQ EXIT_35
00000340                           690mmm     PRINT_CHAR (A0)+,D3
00000340                           691mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000340                 TRUE      692mmm     IFEQ DEBUG
00000340  1639 00C00003            693mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000346  0803 0002                694mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000034A  67F4                     695mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
0000034C  13D8 00C00007            696mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000352                           697mmm     ENDC
00000352                           698mmm     
00000352                 FALSE     699mmm     IFNE DEBUG
00000352                           700mmm     ENDC
00000352                           701mmm 
00000352                           702mmm     ENDM
00000352  60E4                     703mm     BRA LOOP_35
00000354                           704mm EXIT_35
00000354                           705mm     ENDM
00000354                           706m     ENDM
00000354  6000 FDE2                707      BRA MAIN_LOOP
00000358                           708  
00000358                           709  ; register map for S
00000358                           710  ; A0 - start address
00000358                           711  ; A1 - offset
00000358                           712  ; A2 - next address to write
00000358                           713  ; A3 - next location (jmp)
00000358                           714  ; A4 - Working Address Register
00000358                           715  ; D0 - record count
00000358                           716  ; D1 - 'S', record type, data byte
00000358                           717  ; D2 - checksum
00000358                           718  ; D3 - data byte count
00000358                           719  ; D4 - read address, moved into A2
00000358                           720  ; D5 - temp
00000358                           721  ; D6 - temp
00000358                           722  ; D7 - temp
00000358                           723  S
00000358  2078 0000                724      MOVE.L 0,A0                                     ; start address -> A0
0000035C  2247                     725      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000035E                           726      
0000035E  7000                     727      MOVE.L #0,D0                                    ; count of records read -> D0
00000360                           728          
00000360                           729  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000360                           730m     DOWNLOAD D1                 
00000360                           731m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000360                           732m 
00000360  1239 00C00003            733m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000366  0801 0000                734m     BTST #0,D1                                  ; CHECK FOR CHARACTER
0000036A  6700 0010                735m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
0000036E                           736m  
0000036E                           737mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000036E                 TRUE      738mm     IFEQ DEBUG
0000036E  1239 00C00007            739mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000374                           740mm     ENDC
00000374                 FALSE     741mm     IFNE DEBUG
00000374                           742mm     ENDC
00000374                           743mm      
00000374  B23C 001B                744mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000378  6700 FC8E                745mm     BEQ START
0000037C                           746mm     ENDM
0000037C                           747m CONTINUE_37
0000037C  1239 00C00013            748m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000382  0801 0000                749m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000386  67D8                     750m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
00000388                           751m     
00000388  1239 00C00017            752m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000038E  13C1 00E00001            753m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000394                           754m     
00000394                           755m     ENDM
00000394  B23C 0053                756      CMP.B #'S',D1                                   ; found S?    
00000398  66C6                     757      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000039A                           758      
0000039A                           759m     PRINT_CHAR #'S',D5                            ; print the S
0000039A                           760m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039A                 TRUE      761m     IFEQ DEBUG
0000039A  1A39 00C00003            762m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003A0  0805 0002                763m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003A4  67F4                     764m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003A6  13FC 0053 00C00007       765m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000003AE                           766m     ENDC
000003AE                           767m     
000003AE                 FALSE     768m     IFNE DEBUG
000003AE                           769m     ENDC
000003AE                           770m 
000003AE                           771m     ENDM
000003AE  5280                     772      ADD.L #1,D0                                     ; read another S record, increment count
000003B0                           773      
000003B0                           774m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000003B0                           775m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B0                           776m 
000003B0  1239 00C00003            777m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
000003B6  0801 0000                778m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003BA  6700 0010                779m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003BE                           780m  
000003BE                           781mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003BE                 TRUE      782mm     IFEQ DEBUG
000003BE  1239 00C00007            783mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003C4                           784mm     ENDC
000003C4                 FALSE     785mm     IFNE DEBUG
000003C4                           786mm     ENDC
000003C4                           787mm      
000003C4  B23C 001B                788mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003C8  6700 FC3E                789mm     BEQ START
000003CC                           790mm     ENDM
000003CC                           791m CONTINUE_40
000003CC  1239 00C00013            792m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003D2  0801 0000                793m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003D6  67D8                     794m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
000003D8                           795m     
000003D8  1239 00C00017            796m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003DE  13C1 00E00001            797m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003E4                           798m     
000003E4                           799m     ENDM
000003E4                           800m     PRINT_CHAR D1,D5
000003E4                           801m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E4                 TRUE      802m     IFEQ DEBUG
000003E4  1A39 00C00003            803m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003EA  0805 0002                804m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003EE  67F4                     805m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
000003F0  13C1 00C00007            806m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003F6                           807m     ENDC
000003F6                           808m     
000003F6                 FALSE     809m     IFNE DEBUG
000003F6                           810m     ENDC
000003F6                           811m 
000003F6                           812m     ENDM
000003F6                           813  
000003F6  7400                     814      MOVE.L #0,D2                                    ; clear the checksum
000003F8                           815  
000003F8                           816m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003F8  1E3C 0002                817m     MOVE.B #2,D7
000003FC                           818m     WHILE.B D7 <GT> 0 DO
000003FC                           819ms _10000000
000003FC  BE38 0000                820ms     CMP.B   0,D7
00000400  6F00 0064                821ms     BLE _10000001
00000404  E98B                     822m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00000406                           823mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000406                           824mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000406                           825mm 
00000406  1A39 00C00003            826mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000040C  0805 0000                827mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000410  6700 0010                828mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00000414                           829mm  
00000414                           830mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000414                 TRUE      831mmm     IFEQ DEBUG
00000414  1A39 00C00007            832mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000041A                           833mmm     ENDC
0000041A                 FALSE     834mmm     IFNE DEBUG
0000041A                           835mmm     ENDC
0000041A                           836mmm      
0000041A  BA3C 001B                837mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000041E  6700 FBE8                838mmm     BEQ START
00000422                           839mmm     ENDM
00000422                           840mm CONTINUE_44
00000422  1A39 00C00013            841mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000428  0805 0000                842mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000042C  67D8                     843mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0000042E                           844mm     
0000042E  1A39 00C00017            845mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000434  13C5 00E00001            846mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000043A                           847mm     
0000043A                           848mm     ENDM
0000043A                           849mm         PRINT_CHAR D5,D6
0000043A                           850mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043A                 TRUE      851mm     IFEQ DEBUG
0000043A  1C39 00C00003            852mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000440  0806 0002                853mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000444  67F4                     854mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000446  13C5 00C00007            855mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000044C                           856mm     ENDC
0000044C                           857mm     
0000044C                 FALSE     858mm     IFNE DEBUG
0000044C                           859mm     ENDC
0000044C                           860mm 
0000044C                           861mm     ENDM
0000044C                           862mm         HEX2BIN D5,D5,A4
0000044C  49F9 00000E03            863mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00000452  0405 0030                864mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000456  CABC 000000FF            865mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000045C  1A34 5000                866mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000460                           867mm     ENDM
00000460  8605                     868m         OR.B D5,D3
00000462  5307                     869m         SUB.B #1,D7
00000464                           870m     ENDW
00000464  6096                     871ms     BRA _10000000
00000466                           872ms _10000001
00000466                           873m     
00000466  7A00                     874m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000468  1A03                     875m     MOVE.B D3,D5
0000046A  D483                     876m     ADD.L D3,D2
0000046C                           877m 
0000046C                           878m     ENDM
0000046C                           879  
0000046C                           880      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000046C  B23C 0030                881s     CMP.B   #'0',D1
00000470  6600 002C                882s     BNE.L   _00000002
00000474                           883m         PRINT_CRLF D5,A4
00000474  49F9 00000E2E            884m     LEA CRLF,A4
0000047A                           885mm     PRINT_STR A4,D5
0000047A                           886mm LOOP_49
0000047A  0C14 0000                887mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000047E  6700 0016                888mm     BEQ EXIT_49
00000482                           889mmm     PRINT_CHAR (A4)+,D5
00000482                           890mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000482                 TRUE      891mmm     IFEQ DEBUG
00000482  1A39 00C00003            892mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000488  0805 0002                893mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000048C  67F4                     894mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
0000048E  13DC 00C00007            895mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000494                           896mmm     ENDC
00000494                           897mmm     
00000494                 FALSE     898mmm     IFNE DEBUG
00000494                           899mmm     ENDC
00000494                           900mmm 
00000494                           901mmm     ENDM
00000494  60E4                     902mm     BRA LOOP_49
00000496                           903mm EXIT_49
00000496                           904mm     ENDM
00000496                           905m     ENDM
00000496  6000 FEC8                906          BRA WAIT_FOR_SRECORD
0000049A                           907      ELSE
0000049A  6000 03F8                908s     BRA _00000003
0000049E                           909s _00000002
0000049E                           910          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
0000049E  B23C 0031                911s     CMP.B   #'1',D1
000004A2  6708                     912s     BEQ.S   _00000004
000004A4  B23C 0032                913s     CMP.B   #'2',D1
000004A8  6600 01FC                914s     BNE.L   _00000005
000004AC                           915s _00000004
000004AC  5783                     916              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004AE                           917      
000004AE  7800                     918              MOVE.L #0,D4                            ; read two bytes of address
000004B0                           919m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
000004B0  1E3C 0002                920m     MOVE.B #2,D7
000004B4                           921m     WHILE.B D7 <GT> 0 DO
000004B4                           922ms _10000002
000004B4  BE38 0000                923ms     CMP.B   0,D7
000004B8  6F00 0064                924ms     BLE _10000003
000004BC  E98C                     925m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004BE                           926mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004BE                           927mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                           928mm 
000004BE  1A39 00C00003            929mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004C4  0805 0000                930mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004C8  6700 0010                931mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
000004CC                           932mm  
000004CC                           933mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004CC                 TRUE      934mmm     IFEQ DEBUG
000004CC  1A39 00C00007            935mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004D2                           936mmm     ENDC
000004D2                 FALSE     937mmm     IFNE DEBUG
000004D2                           938mmm     ENDC
000004D2                           939mmm      
000004D2  BA3C 001B                940mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004D6  6700 FB30                941mmm     BEQ START
000004DA                           942mmm     ENDM
000004DA                           943mm CONTINUE_52
000004DA  1A39 00C00013            944mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004E0  0805 0000                945mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004E4  67D8                     946mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
000004E6                           947mm     
000004E6  1A39 00C00017            948mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004EC  13C5 00E00001            949mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004F2                           950mm     
000004F2                           951mm     ENDM
000004F2                           952mm         PRINT_CHAR D5,D6
000004F2                           953mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      954mm     IFEQ DEBUG
000004F2  1C39 00C00003            955mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004F8  0806 0002                956mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004FC  67F4                     957mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
000004FE  13C5 00C00007            958mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000504                           959mm     ENDC
00000504                           960mm     
00000504                 FALSE     961mm     IFNE DEBUG
00000504                           962mm     ENDC
00000504                           963mm 
00000504                           964mm     ENDM
00000504                           965mm         HEX2BIN D5,D5,A4
00000504  49F9 00000E03            966mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000050A  0405 0030                967mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000050E  CABC 000000FF            968mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000514  1A34 5000                969mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000518                           970mm     ENDM
00000518  8805                     971m         OR.B D5,D4
0000051A  5307                     972m         SUB.B #1,D7
0000051C                           973m     ENDW
0000051C  6096                     974ms     BRA _10000002
0000051E                           975ms _10000003
0000051E                           976m     
0000051E  7A00                     977m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000520  1A04                     978m     MOVE.B D4,D5
00000522  D484                     979m     ADD.L D4,D2
00000524                           980m 
00000524                           981m     ENDM
00000524                           982m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000524  1E3C 0002                983m     MOVE.B #2,D7
00000528                           984m     WHILE.B D7 <GT> 0 DO
00000528                           985ms _10000004
00000528  BE38 0000                986ms     CMP.B   0,D7
0000052C  6F00 0064                987ms     BLE _10000005
00000530  E98C                     988m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000532                           989mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000532                           990mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000532                           991mm 
00000532  1A39 00C00003            992mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000538  0805 0000                993mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000053C  6700 0010                994mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000540                           995mm  
00000540                           996mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000540                 TRUE      997mmm     IFEQ DEBUG
00000540  1A39 00C00007            998mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000546                           999mmm     ENDC
00000546                 FALSE    1000mmm     IFNE DEBUG
00000546                          1001mmm     ENDC
00000546                          1002mmm      
00000546  BA3C 001B               1003mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000054A  6700 FABC               1004mmm     BEQ START
0000054E                          1005mmm     ENDM
0000054E                          1006mm CONTINUE_57
0000054E  1A39 00C00013           1007mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000554  0805 0000               1008mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000558  67D8                    1009mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000055A                          1010mm     
0000055A  1A39 00C00017           1011mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000560  13C5 00E00001           1012mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000566                          1013mm     
00000566                          1014mm     ENDM
00000566                          1015mm         PRINT_CHAR D5,D6
00000566                          1016mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000566                 TRUE     1017mm     IFEQ DEBUG
00000566  1C39 00C00003           1018mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000056C  0806 0002               1019mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000570  67F4                    1020mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
00000572  13C5 00C00007           1021mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000578                          1022mm     ENDC
00000578                          1023mm     
00000578                 FALSE    1024mm     IFNE DEBUG
00000578                          1025mm     ENDC
00000578                          1026mm 
00000578                          1027mm     ENDM
00000578                          1028mm         HEX2BIN D5,D5,A4
00000578  49F9 00000E03           1029mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000057E  0405 0030               1030mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000582  CABC 000000FF           1031mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000588  1A34 5000               1032mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000058C                          1033mm     ENDM
0000058C  8805                    1034m         OR.B D5,D4
0000058E  5307                    1035m         SUB.B #1,D7
00000590                          1036m     ENDW
00000590  6096                    1037ms     BRA _10000004
00000592                          1038ms _10000005
00000592                          1039m     
00000592  7A00                    1040m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000594  1A04                    1041m     MOVE.B D4,D5
00000596  D484                    1042m     ADD.L D4,D2
00000598                          1043m 
00000598                          1044m     ENDM
00000598                          1045              
00000598                          1046              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000598  B23C 0032               1047s     CMP.B   #'2',D1
0000059C  6600 0078               1048s     BNE.L   _00000006
000005A0  5383                    1049                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005A2                          1050m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
000005A2  1E3C 0002               1051m     MOVE.B #2,D7
000005A6                          1052m     WHILE.B D7 <GT> 0 DO
000005A6                          1053ms _10000006
000005A6  BE38 0000               1054ms     CMP.B   0,D7
000005AA  6F00 0064               1055ms     BLE _10000007
000005AE  E98C                    1056m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000005B0                          1057mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005B0                          1058mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                          1059mm 
000005B0  1A39 00C00003           1060mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000005B6  0805 0000               1061mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005BA  6700 0010               1062mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
000005BE                          1063mm  
000005BE                          1064mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005BE                 TRUE     1065mmm     IFEQ DEBUG
000005BE  1A39 00C00007           1066mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005C4                          1067mmm     ENDC
000005C4                 FALSE    1068mmm     IFNE DEBUG
000005C4                          1069mmm     ENDC
000005C4                          1070mmm      
000005C4  BA3C 001B               1071mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005C8  6700 FA3E               1072mmm     BEQ START
000005CC                          1073mmm     ENDM
000005CC                          1074mm CONTINUE_62
000005CC  1A39 00C00013           1075mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005D2  0805 0000               1076mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D6  67D8                    1077mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
000005D8                          1078mm     
000005D8  1A39 00C00017           1079mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005DE  13C5 00E00001           1080mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005E4                          1081mm     
000005E4                          1082mm     ENDM
000005E4                          1083mm         PRINT_CHAR D5,D6
000005E4                          1084mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E4                 TRUE     1085mm     IFEQ DEBUG
000005E4  1C39 00C00003           1086mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005EA  0806 0002               1087mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005EE  67F4                    1088mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
000005F0  13C5 00C00007           1089mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005F6                          1090mm     ENDC
000005F6                          1091mm     
000005F6                 FALSE    1092mm     IFNE DEBUG
000005F6                          1093mm     ENDC
000005F6                          1094mm 
000005F6                          1095mm     ENDM
000005F6                          1096mm         HEX2BIN D5,D5,A4
000005F6  49F9 00000E03           1097mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000005FC  0405 0030               1098mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000600  CABC 000000FF           1099mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000606  1A34 5000               1100mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000060A                          1101mm     ENDM
0000060A  8805                    1102m         OR.B D5,D4
0000060C  5307                    1103m         SUB.B #1,D7
0000060E                          1104m     ENDW
0000060E  6096                    1105ms     BRA _10000006
00000610                          1106ms _10000007
00000610                          1107m     
00000610  7A00                    1108m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000612  1A04                    1109m     MOVE.B D4,D5
00000614  D484                    1110m     ADD.L D4,D2
00000616                          1111m 
00000616                          1112m     ENDM
00000616                          1113              ENDI
00000616                          1114s _00000006
00000616                          1115              
00000616  2444                    1116                  MOVE.L D4,A2                            ; put the address in an address register
00000618  D5C9                    1117              ADD.L A1,A2                             ; add in the offset
0000061A                          1118  
0000061A                          1119              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
0000061A                          1120s _10000008
0000061A  B63C 0000               1121s     CMP.B   #0,D3
0000061E  6F00 007E               1122s     BLE _10000009
00000622                          1123m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
00000622  1E3C 0002               1124m     MOVE.B #2,D7
00000626                          1125m     WHILE.B D7 <GT> 0 DO
00000626                          1126ms _1000000A
00000626  BE38 0000               1127ms     CMP.B   0,D7
0000062A  6F00 0064               1128ms     BLE _1000000B
0000062E  E989                    1129m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00000630                          1130mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000630                          1131mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000630                          1132mm 
00000630  1A39 00C00003           1133mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000636  0805 0000               1134mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000063A  6700 0010               1135mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
0000063E                          1136mm  
0000063E                          1137mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000063E                 TRUE     1138mmm     IFEQ DEBUG
0000063E  1A39 00C00007           1139mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000644                          1140mmm     ENDC
00000644                 FALSE    1141mmm     IFNE DEBUG
00000644                          1142mmm     ENDC
00000644                          1143mmm      
00000644  BA3C 001B               1144mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000648  6700 F9BE               1145mmm     BEQ START
0000064C                          1146mmm     ENDM
0000064C                          1147mm CONTINUE_67
0000064C  1A39 00C00013           1148mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000652  0805 0000               1149mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000656  67D8                    1150mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000658                          1151mm     
00000658  1A39 00C00017           1152mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000065E  13C5 00E00001           1153mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000664                          1154mm     
00000664                          1155mm     ENDM
00000664                          1156mm         PRINT_CHAR D5,D6
00000664                          1157mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000664                 TRUE     1158mm     IFEQ DEBUG
00000664  1C39 00C00003           1159mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000066A  0806 0002               1160mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000066E  67F4                    1161mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
00000670  13C5 00C00007           1162mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000676                          1163mm     ENDC
00000676                          1164mm     
00000676                 FALSE    1165mm     IFNE DEBUG
00000676                          1166mm     ENDC
00000676                          1167mm 
00000676                          1168mm     ENDM
00000676                          1169mm         HEX2BIN D5,D5,A4
00000676  49F9 00000E03           1170mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000067C  0405 0030               1171mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000680  CABC 000000FF           1172mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000686  1A34 5000               1173mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000068A                          1174mm     ENDM
0000068A  8205                    1175m         OR.B D5,D1
0000068C  5307                    1176m         SUB.B #1,D7
0000068E                          1177m     ENDW
0000068E  6096                    1178ms     BRA _1000000A
00000690                          1179ms _1000000B
00000690                          1180m     
00000690  7A00                    1181m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000692  1A01                    1182m     MOVE.B D1,D5
00000694  D481                    1183m     ADD.L D1,D2
00000696                          1184m 
00000696                          1185m     ENDM
00000696                          1186                          
00000696  14C1                    1187                  MOVE.B D1,(A2)+                     ; store it!
00000698                          1188  
00000698  5303                    1189                  SUB.B #1,D3                     ; 1 less byte to go
0000069A                          1190              ENDW
0000069A  6000 FF7E               1191s     BRA _10000008
0000069E                          1192s _10000009
0000069E                          1193          
0000069E  47F8 0360               1194              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
000006A2                          1195          ELSE
000006A2  6000 01F0               1196s     BRA _00000007
000006A6                          1197s _00000005
000006A6                          1198              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006A6  B23C 0038               1199s     CMP.B   #'8',D1
000006AA  6600 016C               1200s     BNE.L   _00000008
000006AE  7800                    1201                  MOVE.L #0,D4                    ; read the 24 bit start address
000006B0                          1202m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
000006B0  1E3C 0002               1203m     MOVE.B #2,D7
000006B4                          1204m     WHILE.B D7 <GT> 0 DO
000006B4                          1205ms _1000000C
000006B4  BE38 0000               1206ms     CMP.B   0,D7
000006B8  6F00 0064               1207ms     BLE _1000000D
000006BC  E98C                    1208m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000006BE                          1209mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006BE                          1210mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BE                          1211mm 
000006BE  1A39 00C00003           1212mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000006C4  0805 0000               1213mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006C8  6700 0010               1214mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
000006CC                          1215mm  
000006CC                          1216mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006CC                 TRUE     1217mmm     IFEQ DEBUG
000006CC  1A39 00C00007           1218mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006D2                          1219mmm     ENDC
000006D2                 FALSE    1220mmm     IFNE DEBUG
000006D2                          1221mmm     ENDC
000006D2                          1222mmm      
000006D2  BA3C 001B               1223mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006D6  6700 F930               1224mmm     BEQ START
000006DA                          1225mmm     ENDM
000006DA                          1226mm CONTINUE_72
000006DA  1A39 00C00013           1227mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006E0  0805 0000               1228mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006E4  67D8                    1229mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
000006E6                          1230mm     
000006E6  1A39 00C00017           1231mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006EC  13C5 00E00001           1232mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006F2                          1233mm     
000006F2                          1234mm     ENDM
000006F2                          1235mm         PRINT_CHAR D5,D6
000006F2                          1236mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006F2                 TRUE     1237mm     IFEQ DEBUG
000006F2  1C39 00C00003           1238mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006F8  0806 0002               1239mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006FC  67F4                    1240mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
000006FE  13C5 00C00007           1241mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000704                          1242mm     ENDC
00000704                          1243mm     
00000704                 FALSE    1244mm     IFNE DEBUG
00000704                          1245mm     ENDC
00000704                          1246mm 
00000704                          1247mm     ENDM
00000704                          1248mm         HEX2BIN D5,D5,A4
00000704  49F9 00000E03           1249mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000070A  0405 0030               1250mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070E  CABC 000000FF           1251mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000714  1A34 5000               1252mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000718                          1253mm     ENDM
00000718  8805                    1254m         OR.B D5,D4
0000071A  5307                    1255m         SUB.B #1,D7
0000071C                          1256m     ENDW
0000071C  6096                    1257ms     BRA _1000000C
0000071E                          1258ms _1000000D
0000071E                          1259m     
0000071E  7A00                    1260m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000720  1A04                    1261m     MOVE.B D4,D5
00000722  D484                    1262m     ADD.L D4,D2
00000724                          1263m 
00000724                          1264m     ENDM
00000724                          1265m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
00000724  1E3C 0002               1266m     MOVE.B #2,D7
00000728                          1267m     WHILE.B D7 <GT> 0 DO
00000728                          1268ms _1000000E
00000728  BE38 0000               1269ms     CMP.B   0,D7
0000072C  6F00 0064               1270ms     BLE _1000000F
00000730  E98C                    1271m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000732                          1272mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000732                          1273mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000732                          1274mm 
00000732  1A39 00C00003           1275mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000738  0805 0000               1276mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000073C  6700 0010               1277mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000740                          1278mm  
00000740                          1279mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000740                 TRUE     1280mmm     IFEQ DEBUG
00000740  1A39 00C00007           1281mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000746                          1282mmm     ENDC
00000746                 FALSE    1283mmm     IFNE DEBUG
00000746                          1284mmm     ENDC
00000746                          1285mmm      
00000746  BA3C 001B               1286mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000074A  6700 F8BC               1287mmm     BEQ START
0000074E                          1288mmm     ENDM
0000074E                          1289mm CONTINUE_77
0000074E  1A39 00C00013           1290mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000754  0805 0000               1291mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  67D8                    1292mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000075A                          1293mm     
0000075A  1A39 00C00017           1294mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000760  13C5 00E00001           1295mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000766                          1296mm     
00000766                          1297mm     ENDM
00000766                          1298mm         PRINT_CHAR D5,D6
00000766                          1299mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000766                 TRUE     1300mm     IFEQ DEBUG
00000766  1C39 00C00003           1301mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000076C  0806 0002               1302mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000770  67F4                    1303mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
00000772  13C5 00C00007           1304mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000778                          1305mm     ENDC
00000778                          1306mm     
00000778                 FALSE    1307mm     IFNE DEBUG
00000778                          1308mm     ENDC
00000778                          1309mm 
00000778                          1310mm     ENDM
00000778                          1311mm         HEX2BIN D5,D5,A4
00000778  49F9 00000E03           1312mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0000077E  0405 0030               1313mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000782  CABC 000000FF           1314mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000788  1A34 5000               1315mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000078C                          1316mm     ENDM
0000078C  8805                    1317m         OR.B D5,D4
0000078E  5307                    1318m         SUB.B #1,D7
00000790                          1319m     ENDW
00000790  6096                    1320ms     BRA _1000000E
00000792                          1321ms _1000000F
00000792                          1322m     
00000792  7A00                    1323m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000794  1A04                    1324m     MOVE.B D4,D5
00000796  D484                    1325m     ADD.L D4,D2
00000798                          1326m 
00000798                          1327m     ENDM
00000798                          1328m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000798  1E3C 0002               1329m     MOVE.B #2,D7
0000079C                          1330m     WHILE.B D7 <GT> 0 DO
0000079C                          1331ms _10000010
0000079C  BE38 0000               1332ms     CMP.B   0,D7
000007A0  6F00 0064               1333ms     BLE _10000011
000007A4  E98C                    1334m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000007A6                          1335mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007A6                          1336mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A6                          1337mm 
000007A6  1A39 00C00003           1338mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000007AC  0805 0000               1339mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007B0  6700 0010               1340mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
000007B4                          1341mm  
000007B4                          1342mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007B4                 TRUE     1343mmm     IFEQ DEBUG
000007B4  1A39 00C00007           1344mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007BA                          1345mmm     ENDC
000007BA                 FALSE    1346mmm     IFNE DEBUG
000007BA                          1347mmm     ENDC
000007BA                          1348mmm      
000007BA  BA3C 001B               1349mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007BE  6700 F848               1350mmm     BEQ START
000007C2                          1351mmm     ENDM
000007C2                          1352mm CONTINUE_82
000007C2  1A39 00C00013           1353mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007C8  0805 0000               1354mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CC  67D8                    1355mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
000007CE                          1356mm     
000007CE  1A39 00C00017           1357mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007D4  13C5 00E00001           1358mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007DA                          1359mm     
000007DA                          1360mm     ENDM
000007DA                          1361mm         PRINT_CHAR D5,D6
000007DA                          1362mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DA                 TRUE     1363mm     IFEQ DEBUG
000007DA  1C39 00C00003           1364mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007E0  0806 0002               1365mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007E4  67F4                    1366mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
000007E6  13C5 00C00007           1367mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007EC                          1368mm     ENDC
000007EC                          1369mm     
000007EC                 FALSE    1370mm     IFNE DEBUG
000007EC                          1371mm     ENDC
000007EC                          1372mm 
000007EC                          1373mm     ENDM
000007EC                          1374mm         HEX2BIN D5,D5,A4
000007EC  49F9 00000E03           1375mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000007F2  0405 0030               1376mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007F6  CABC 000000FF           1377mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007FC  1A34 5000               1378mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000800                          1379mm     ENDM
00000800  8805                    1380m         OR.B D5,D4
00000802  5307                    1381m         SUB.B #1,D7
00000804                          1382m     ENDW
00000804  6096                    1383ms     BRA _10000010
00000806                          1384ms _10000011
00000806                          1385m     
00000806  7A00                    1386m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000808  1A04                    1387m     MOVE.B D4,D5
0000080A  D484                    1388m     ADD.L D4,D2
0000080C                          1389m 
0000080C                          1390m     ENDM
0000080C                          1391                    
0000080C  2044                    1392                  MOVE.L D4,A0                    ; start address -> A0
0000080E                          1393                  
0000080E  47F9 000009CA           1394                  LEA DOWNLOAD_DONE,A3            ; next place to go
00000814                          1395              ELSE
00000814  6000 007E               1396s     BRA _00000009
00000818                          1397s _00000008
00000818                          1398m                 PRINT_CRLF D5,A4
00000818  49F9 00000E2E           1399m     LEA CRLF,A4
0000081E                          1400mm     PRINT_STR A4,D5
0000081E                          1401mm LOOP_87
0000081E  0C14 0000               1402mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000822  6700 0016               1403mm     BEQ EXIT_87
00000826                          1404mmm     PRINT_CHAR (A4)+,D5
00000826                          1405mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1406mmm     IFEQ DEBUG
00000826  1A39 00C00003           1407mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1408mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1409mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
00000832  13DC 00C00007           1410mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000838                          1411mmm     ENDC
00000838                          1412mmm     
00000838                 FALSE    1413mmm     IFNE DEBUG
00000838                          1414mmm     ENDC
00000838                          1415mmm 
00000838                          1416mmm     ENDM
00000838  60E4                    1417mm     BRA LOOP_87
0000083A                          1418mm EXIT_87
0000083A                          1419mm     ENDM
0000083A                          1420m     ENDM
0000083A                          1421              
0000083A  49F9 00000DB8           1422                  LEA UNREC,A4                    ; warn for unrecognised type
00000840                          1423m                 PRINT_STR A4,D5
00000840                          1424m LOOP_89
00000840  0C14 0000               1425m     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000844  6700 0016               1426m     BEQ EXIT_89
00000848                          1427mm     PRINT_CHAR (A4)+,D5
00000848                          1428mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000848                 TRUE     1429mm     IFEQ DEBUG
00000848  1A39 00C00003           1430mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000084E  0805 0002               1431mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000852  67F4                    1432mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
00000854  13DC 00C00007           1433mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000085A                          1434mm     ENDC
0000085A                          1435mm     
0000085A                 FALSE    1436mm     IFNE DEBUG
0000085A                          1437mm     ENDC
0000085A                          1438mm 
0000085A                          1439mm     ENDM
0000085A  60E4                    1440m     BRA LOOP_89
0000085C                          1441m EXIT_89
0000085C                          1442m     ENDM
0000085C                          1443m                 PRINT_CHAR D1,D5
0000085C                          1444m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085C                 TRUE     1445m     IFEQ DEBUG
0000085C  1A39 00C00003           1446m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000862  0805 0002               1447m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000866  67F4                    1448m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000868  13C1 00C00007           1449m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000086E                          1450m     ENDC
0000086E                          1451m     
0000086E                 FALSE    1452m     IFNE DEBUG
0000086E                          1453m     ENDC
0000086E                          1454m 
0000086E                          1455m     ENDM
0000086E                          1456m                 PRINT_CRLF D5,A4
0000086E  49F9 00000E2E           1457m     LEA CRLF,A4
00000874                          1458mm     PRINT_STR A4,D5
00000874                          1459mm LOOP_93
00000874  0C14 0000               1460mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000878  6700 0016               1461mm     BEQ EXIT_93
0000087C                          1462mmm     PRINT_CHAR (A4)+,D5
0000087C                          1463mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087C                 TRUE     1464mmm     IFEQ DEBUG
0000087C  1A39 00C00003           1465mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000882  0805 0002               1466mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000886  67F4                    1467mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000888  13DC 00C00007           1468mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000088E                          1469mmm     ENDC
0000088E                          1470mmm     
0000088E                 FALSE    1471mmm     IFNE DEBUG
0000088E                          1472mmm     ENDC
0000088E                          1473mmm 
0000088E                          1474mmm     ENDM
0000088E  60E4                    1475mm     BRA LOOP_93
00000890                          1476mm EXIT_93
00000890                          1477mm     ENDM
00000890                          1478m     ENDM
00000890                          1479              
00000890  6000 FACE               1480                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
00000894                          1481              ENDI
00000894                          1482s _00000009
00000894                          1483          ENDI
00000894                          1484s _00000007
00000894                          1485      ENDI
00000894                          1486s _00000003
00000894                          1487      
00000894                          1488m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
00000894  1E3C 0002               1489m     MOVE.B #2,D7
00000898                          1490m     WHILE.B D7 <GT> 0 DO
00000898                          1491ms _10000012
00000898  BE38 0000               1492ms     CMP.B   0,D7
0000089C  6F00 0064               1493ms     BLE _10000013
000008A0  E98C                    1494m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000008A2                          1495mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008A2                          1496mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A2                          1497mm 
000008A2  1A39 00C00003           1498mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000008A8  0805 0000               1499mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008AC  6700 0010               1500mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
000008B0                          1501mm  
000008B0                          1502mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000008B0                 TRUE     1503mmm     IFEQ DEBUG
000008B0  1A39 00C00007           1504mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008B6                          1505mmm     ENDC
000008B6                 FALSE    1506mmm     IFNE DEBUG
000008B6                          1507mmm     ENDC
000008B6                          1508mmm      
000008B6  BA3C 001B               1509mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000008BA  6700 F74C               1510mmm     BEQ START
000008BE                          1511mmm     ENDM
000008BE                          1512mm CONTINUE_96
000008BE  1A39 00C00013           1513mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008C4  0805 0000               1514mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C8  67D8                    1515mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
000008CA                          1516mm     
000008CA  1A39 00C00017           1517mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008D0  13C5 00E00001           1518mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008D6                          1519mm     
000008D6                          1520mm     ENDM
000008D6                          1521mm         PRINT_CHAR D5,D6
000008D6                          1522mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                 TRUE     1523mm     IFEQ DEBUG
000008D6  1C39 00C00003           1524mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008DC  0806 0002               1525mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008E0  67F4                    1526mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000008E2  13C5 00C00007           1527mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008E8                          1528mm     ENDC
000008E8                          1529mm     
000008E8                 FALSE    1530mm     IFNE DEBUG
000008E8                          1531mm     ENDC
000008E8                          1532mm 
000008E8                          1533mm     ENDM
000008E8                          1534mm         HEX2BIN D5,D5,A4
000008E8  49F9 00000E03           1535mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
000008EE  0405 0030               1536mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008F2  CABC 000000FF           1537mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008F8  1A34 5000               1538mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008FC                          1539mm     ENDM
000008FC  8805                    1540m         OR.B D5,D4
000008FE  5307                    1541m         SUB.B #1,D7
00000900                          1542m     ENDW
00000900  6096                    1543ms     BRA _10000012
00000902                          1544ms _10000013
00000902                          1545m     
00000902  7A00                    1546m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000904  1A04                    1547m     MOVE.B D4,D5
00000906  D484                    1548m     ADD.L D4,D2
00000908                          1549m 
00000908                          1550m     ENDM
00000908                          1551m     PRINT_CRLF D5,A4
00000908  49F9 00000E2E           1552m     LEA CRLF,A4
0000090E                          1553mm     PRINT_STR A4,D5
0000090E                          1554mm LOOP_101
0000090E  0C14 0000               1555mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000912  6700 0016               1556mm     BEQ EXIT_101
00000916                          1557mmm     PRINT_CHAR (A4)+,D5
00000916                          1558mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                 TRUE     1559mmm     IFEQ DEBUG
00000916  1A39 00C00003           1560mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000091C  0805 0002               1561mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000920  67F4                    1562mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000922  13DC 00C00007           1563mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000928                          1564mmm     ENDC
00000928                          1565mmm     
00000928                 FALSE    1566mmm     IFNE DEBUG
00000928                          1567mmm     ENDC
00000928                          1568mmm 
00000928                          1569mmm     ENDM
00000928  60E4                    1570mm     BRA LOOP_101
0000092A                          1571mm EXIT_101
0000092A                          1572mm     ENDM
0000092A                          1573m     ENDM
0000092A                          1574          
0000092A                          1575      IF.B D2 <NE> #$FF THEN.L
0000092A  B43C 00FF               1576s     CMP.B   #$FF,D2
0000092E  6700 0098               1577s     BEQ.L   _0000000A
00000932  49F9 00000DCF           1578          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000938                          1579m         PRINT_STR A4,D5
00000938                          1580m LOOP_103
00000938  0C14 0000               1581m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000093C  6700 0016               1582m     BEQ EXIT_103
00000940                          1583mm     PRINT_CHAR (A4)+,D5
00000940                          1584mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000940                 TRUE     1585mm     IFEQ DEBUG
00000940  1A39 00C00003           1586mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000946  0805 0002               1587mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000094A  67F4                    1588mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000094C  13DC 00C00007           1589mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000952                          1590mm     ENDC
00000952                          1591mm     
00000952                 FALSE    1592mm     IFNE DEBUG
00000952                          1593mm     ENDC
00000952                          1594mm 
00000952                          1595mm     ENDM
00000952  60E4                    1596m     BRA LOOP_103
00000954                          1597m EXIT_103
00000954                          1598m     ENDM
00000954                          1599m         PRINT_REG D0,D5,D2,D6,A4
00000954  49F9 00000E34           1600m     LEA OX,A4
0000095A                          1601mm     PRINT_STR A4,D5
0000095A                          1602mm LOOP_106
0000095A  0C14 0000               1603mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000095E  6700 0016               1604mm     BEQ EXIT_106
00000962                          1605mmm     PRINT_CHAR (A4)+,D5
00000962                          1606mmm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1607mmm     IFEQ DEBUG
00000962  1A39 00C00003           1608mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000968  0805 0002               1609mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1610mmm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096E  13DC 00C00007           1611mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000974                          1612mmm     ENDC
00000974                          1613mmm     
00000974                 FALSE    1614mmm     IFNE DEBUG
00000974                          1615mmm     ENDC
00000974                          1616mmm 
00000974                          1617mmm     ENDM
00000974  60E4                    1618mm     BRA LOOP_106
00000976                          1619mm EXIT_106
00000976                          1620mm     ENDM
00000976  7C07                    1621m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000978                          1622m LOOP_105
00000978                          1623mm     BIN2HEX D0,D2,A4
00000978  49F9 00000DF3           1624mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
0000097E  E998                    1625mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000980  1400                    1626mm     MOVE.B D0,D2
00000982  0282 0000000F           1627mm     ANDI.L #$F,D2
00000988  1434 2000               1628mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000098C                          1629mm     ENDM
0000098C                          1630mm     PRINT_CHAR D2,D5
0000098C                          1631mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                 TRUE     1632mm     IFEQ DEBUG
0000098C  1A39 00C00003           1633mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000992  0805 0002               1634mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000996  67F4                    1635mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000998  13C2 00C00007           1636mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000099E                          1637mm     ENDC
0000099E                          1638mm     
0000099E                 FALSE    1639mm     IFNE DEBUG
0000099E                          1640mm     ENDC
0000099E                          1641mm 
0000099E                          1642mm     ENDM
0000099E  57CE FFD8               1643m     DBEQ D6,LOOP_105
000009A2                          1644m     ENDM
000009A2                          1645m         PRINT_CRLF D5,A4
000009A2  49F9 00000E2E           1646m     LEA CRLF,A4
000009A8                          1647mm     PRINT_STR A4,D5
000009A8                          1648mm LOOP_111
000009A8  0C14 0000               1649mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000009AC  6700 0016               1650mm     BEQ EXIT_111
000009B0                          1651mmm     PRINT_CHAR (A4)+,D5
000009B0                          1652mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1653mmm     IFEQ DEBUG
000009B0  1A39 00C00003           1654mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009B6  0805 0002               1655mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1656mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
000009BC  13DC 00C00007           1657mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009C2                          1658mmm     ENDC
000009C2                          1659mmm     
000009C2                 FALSE    1660mmm     IFNE DEBUG
000009C2                          1661mmm     ENDC
000009C2                          1662mmm 
000009C2                          1663mmm     ENDM
000009C2  60E4                    1664mm     BRA LOOP_111
000009C4                          1665mm EXIT_111
000009C4                          1666mm     ENDM
000009C4                          1667m     ENDM
000009C4  6000 F772               1668          BRA MAIN_LOOP
000009C8                          1669      ENDI
000009C8                          1670s _0000000A
000009C8                          1671      
000009C8  4ED3                    1672      JMP (A3)
000009CA                          1673  DOWNLOAD_DONE
000009CA                          1674m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009CA  43F9 00000E34           1675m     LEA OX,A1
000009D0                          1676mm     PRINT_STR A1,D5
000009D0                          1677mm LOOP_114
000009D0  0C11 0000               1678mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009D4  6700 0016               1679mm     BEQ EXIT_114
000009D8                          1680mmm     PRINT_CHAR (A1)+,D5
000009D8                          1681mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D8                 TRUE     1682mmm     IFEQ DEBUG
000009D8  1A39 00C00003           1683mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009DE  0805 0002               1684mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009E2  67F4                    1685mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009E4  13D9 00C00007           1686mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009EA                          1687mmm     ENDC
000009EA                          1688mmm     
000009EA                 FALSE    1689mmm     IFNE DEBUG
000009EA                          1690mmm     ENDC
000009EA                          1691mmm 
000009EA                          1692mmm     ENDM
000009EA  60E4                    1693mm     BRA LOOP_114
000009EC                          1694mm EXIT_114
000009EC                          1695mm     ENDM
000009EC  7407                    1696m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009EE                          1697m LOOP_113
000009EE                          1698mm     BIN2HEX D0,D6,A1
000009EE  43F9 00000DF3           1699mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
000009F4  E998                    1700mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009F6  1C00                    1701mm     MOVE.B D0,D6
000009F8  0286 0000000F           1702mm     ANDI.L #$F,D6
000009FE  1C31 6000               1703mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A02                          1704mm     ENDM
00000A02                          1705mm     PRINT_CHAR D6,D5
00000A02                          1706mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A02                 TRUE     1707mm     IFEQ DEBUG
00000A02  1A39 00C00003           1708mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A08  0805 0002               1709mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0C  67F4                    1710mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00000A0E  13C6 00C00007           1711mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A14                          1712mm     ENDC
00000A14                          1713mm     
00000A14                 FALSE    1714mm     IFNE DEBUG
00000A14                          1715mm     ENDC
00000A14                          1716mm 
00000A14                          1717mm     ENDM
00000A14  57CA FFD8               1718m     DBEQ D2,LOOP_113
00000A18                          1719m     ENDM
00000A18  43F9 00000D96           1720      LEA READ,A1
00000A1E                          1721m     PRINT_STR A1,D5
00000A1E                          1722m LOOP_118
00000A1E  0C11 0000               1723m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A22  6700 0016               1724m     BEQ EXIT_118
00000A26                          1725mm     PRINT_CHAR (A1)+,D5
00000A26                          1726mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1727mm     IFEQ DEBUG
00000A26  1A39 00C00003           1728mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A2C  0805 0002               1729mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1730mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A32  13D9 00C00007           1731mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A38                          1732mm     ENDC
00000A38                          1733mm     
00000A38                 FALSE    1734mm     IFNE DEBUG
00000A38                          1735mm     ENDC
00000A38                          1736mm 
00000A38                          1737mm     ENDM
00000A38  60E4                    1738m     BRA LOOP_118
00000A3A                          1739m EXIT_118
00000A3A                          1740m     ENDM
00000A3A  2E08                    1741      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A3C                          1742m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A3C  43F9 00000E34           1743m     LEA OX,A1
00000A42                          1744mm     PRINT_STR A1,D5
00000A42                          1745mm LOOP_121
00000A42  0C11 0000               1746mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A46  6700 0016               1747mm     BEQ EXIT_121
00000A4A                          1748mmm     PRINT_CHAR (A1)+,D5
00000A4A                          1749mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4A                 TRUE     1750mmm     IFEQ DEBUG
00000A4A  1A39 00C00003           1751mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A50  0805 0002               1752mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A54  67F4                    1753mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000A56  13D9 00C00007           1754mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A5C                          1755mmm     ENDC
00000A5C                          1756mmm     
00000A5C                 FALSE    1757mmm     IFNE DEBUG
00000A5C                          1758mmm     ENDC
00000A5C                          1759mmm 
00000A5C                          1760mmm     ENDM
00000A5C  60E4                    1761mm     BRA LOOP_121
00000A5E                          1762mm EXIT_121
00000A5E                          1763mm     ENDM
00000A5E  7407                    1764m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A60                          1765m LOOP_120
00000A60                          1766mm     BIN2HEX D7,D6,A1
00000A60  43F9 00000DF3           1767mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000A66  E99F                    1768mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A68  1C07                    1769mm     MOVE.B D7,D6
00000A6A  0286 0000000F           1770mm     ANDI.L #$F,D6
00000A70  1C31 6000               1771mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A74                          1772mm     ENDM
00000A74                          1773mm     PRINT_CHAR D6,D5
00000A74                          1774mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A74                 TRUE     1775mm     IFEQ DEBUG
00000A74  1A39 00C00003           1776mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A7A  0805 0002               1777mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A7E  67F4                    1778mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A80  13C6 00C00007           1779mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A86                          1780mm     ENDC
00000A86                          1781mm     
00000A86                 FALSE    1782mm     IFNE DEBUG
00000A86                          1783mm     ENDC
00000A86                          1784mm 
00000A86                          1785mm     ENDM
00000A86  57CA FFD8               1786m     DBEQ D2,LOOP_120
00000A8A                          1787m     ENDM
00000A8A                          1788m     PRINT_CRLF D5,A4     
00000A8A  49F9 00000E2E           1789m     LEA CRLF,A4
00000A90                          1790mm     PRINT_STR A4,D5
00000A90                          1791mm LOOP_126
00000A90  0C14 0000               1792mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A94  6700 0016               1793mm     BEQ EXIT_126
00000A98                          1794mmm     PRINT_CHAR (A4)+,D5
00000A98                          1795mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A98                 TRUE     1796mmm     IFEQ DEBUG
00000A98  1A39 00C00003           1797mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9E  0805 0002               1798mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA2  67F4                    1799mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000AA4  13DC 00C00007           1800mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AAA                          1801mmm     ENDC
00000AAA                          1802mmm     
00000AAA                 FALSE    1803mmm     IFNE DEBUG
00000AAA                          1804mmm     ENDC
00000AAA                          1805mmm 
00000AAA                          1806mmm     ENDM
00000AAA  60E4                    1807mm     BRA LOOP_126
00000AAC                          1808mm EXIT_126
00000AAC                          1809mm     ENDM
00000AAC                          1810m     ENDM
00000AAC                          1811          
00000AAC  6000 F68A               1812      BRA MAIN_LOOP
00000AB0                          1813      
00000AB0                          1814  G
00000AB0  2047                    1815      MOVE.L D7,A0                                    ; address accumulator -> address register
00000AB2  3E3C 0000               1816      MOVE #0,D7                                      ; clear the now used address accumulator
00000AB6  4ED0                    1817      JMP (A0)                                        ; jump to it!
00000AB8                          1818      
00000AB8                          1819  Z
00000AB8  207C 00200000           1820      MOVE.L #RAM,A0                                  ; address of RAM
00000ABE                          1821      
00000ABE                          1822      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000ABE  7000                    1823s     MOVE.L  #0,D0
00000AC0  6000 0012               1824s     BRA _20000005
00000AC4                          1825s _20000004
00000AC4  2200                    1826          MOVE.L D0,D1                              ; progress update
00000AC6  E089                    1827          LSR.L #8,D1 
00000AC8  E089                    1828          LSR.L #8,D1
00000ACA  13C1 00E00001           1829          MOVE.B D1,DISPLAY
00000AD0                          1830  
00000AD0  20C0                    1831          MOVE.L D0,(A0)+
00000AD2                          1832      ENDF
00000AD2  5880                    1833s     ADD.L   #4,D0
00000AD4                          1834s _20000005
00000AD4  B0BC 00040000           1835s     CMP.L   #$40000,D0
00000ADA  6FE8                    1836s     BLE _20000004
00000ADC                          1837   
00000ADC  207C 00200000           1838      MOVE.L #RAM,A0                                    ; address of RAM
00000AE2                          1839     
00000AE2                          1840      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000AE2  7000                    1841s     MOVE.L  #0,D0
00000AE4  6000 00AE               1842s     BRA _20000007
00000AE8                          1843s _20000006
00000AE8  2200                    1844          MOVE.L D0,D1                              ; progress update
00000AEA  E089                    1845          LSR.L #8,D1
00000AEC  E089                    1846          LSR.L #8,D1
00000AEE  13C1 00E00001           1847          MOVE.B D1,DISPLAY
00000AF4                          1848  
00000AF4  2218                    1849          MOVE.L (A0)+,D1
00000AF6                          1850            
00000AF6                          1851          IF.L D0 <NE> D1 THEN      
00000AF6  B081                    1852s     CMP.L   D1,D0
00000AF8  6700 0098               1853s     BEQ _0000000B
00000AFC  43F9 00000DE1           1854              LEA RAM_ERROR,A1
00000B02                          1855m             PRINT_STR A1,D1
00000B02                          1856m LOOP_128
00000B02  0C11 0000               1857m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B06  6700 0016               1858m     BEQ EXIT_128
00000B0A                          1859mm     PRINT_CHAR (A1)+,D1
00000B0A                          1860mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0A                 TRUE     1861mm     IFEQ DEBUG
00000B0A  1239 00C00003           1862mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000B10  0801 0002               1863mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000B14  67F4                    1864mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B16  13D9 00C00007           1865mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B1C                          1866mm     ENDC
00000B1C                          1867mm     
00000B1C                 FALSE    1868mm     IFNE DEBUG
00000B1C                          1869mm     ENDC
00000B1C                          1870mm 
00000B1C                          1871mm     ENDM
00000B1C  60E4                    1872m     BRA LOOP_128
00000B1E                          1873m EXIT_128
00000B1E                          1874m     ENDM
00000B1E  2208                    1875              MOVE.L A0,D1
00000B20  5981                    1876              SUB.L #4,D1
00000B22                          1877m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B22  43F9 00000E34           1878m     LEA OX,A1
00000B28                          1879mm     PRINT_STR A1,D3
00000B28                          1880mm LOOP_131
00000B28  0C11 0000               1881mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B2C  6700 0016               1882mm     BEQ EXIT_131
00000B30                          1883mmm     PRINT_CHAR (A1)+,D3
00000B30                          1884mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1885mmm     IFEQ DEBUG
00000B30  1639 00C00003           1886mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1887mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1888mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000B3C  13D9 00C00007           1889mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B42                          1890mmm     ENDC
00000B42                          1891mmm     
00000B42                 FALSE    1892mmm     IFNE DEBUG
00000B42                          1893mmm     ENDC
00000B42                          1894mmm 
00000B42                          1895mmm     ENDM
00000B42  60E4                    1896mm     BRA LOOP_131
00000B44                          1897mm EXIT_131
00000B44                          1898mm     ENDM
00000B44  7C07                    1899m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B46                          1900m LOOP_130
00000B46                          1901mm     BIN2HEX D1,D2,A1
00000B46  43F9 00000DF3           1902mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B4C  E999                    1903mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B4E  1401                    1904mm     MOVE.B D1,D2
00000B50  0282 0000000F           1905mm     ANDI.L #$F,D2
00000B56  1431 2000               1906mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B5A                          1907mm     ENDM
00000B5A                          1908mm     PRINT_CHAR D2,D3
00000B5A                          1909mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     1910mm     IFEQ DEBUG
00000B5A  1639 00C00003           1911mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B60  0803 0002               1912mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B64  67F4                    1913mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B66  13C2 00C00007           1914mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B6C                          1915mm     ENDC
00000B6C                          1916mm     
00000B6C                 FALSE    1917mm     IFNE DEBUG
00000B6C                          1918mm     ENDC
00000B6C                          1919mm 
00000B6C                          1920mm     ENDM
00000B6C  57CE FFD8               1921m     DBEQ D6,LOOP_130
00000B70                          1922m     ENDM
00000B70                          1923m             PRINT_CRLF D3,A1
00000B70  43F9 00000E2E           1924m     LEA CRLF,A1
00000B76                          1925mm     PRINT_STR A1,D3
00000B76                          1926mm LOOP_136
00000B76  0C11 0000               1927mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B7A  6700 0016               1928mm     BEQ EXIT_136
00000B7E                          1929mmm     PRINT_CHAR (A1)+,D3
00000B7E                          1930mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7E                 TRUE     1931mmm     IFEQ DEBUG
00000B7E  1639 00C00003           1932mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B84  0803 0002               1933mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B88  67F4                    1934mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000B8A  13D9 00C00007           1935mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B90                          1936mmm     ENDC
00000B90                          1937mmm     
00000B90                 FALSE    1938mmm     IFNE DEBUG
00000B90                          1939mmm     ENDC
00000B90                          1940mmm 
00000B90                          1941mmm     ENDM
00000B90  60E4                    1942mm     BRA LOOP_136
00000B92                          1943mm EXIT_136
00000B92                          1944mm     ENDM
00000B92                          1945m     ENDM
00000B92                          1946          ENDI 
00000B92                          1947s _0000000B
00000B92                          1948      ENDF
00000B92  5880                    1949s     ADD.L   #4,D0
00000B94                          1950s _20000007
00000B94  B0BC 00040000           1951s     CMP.L   #$40000,D0
00000B9A  6F00 FF4C               1952s     BLE _20000006
00000B9E                          1953      
00000B9E  6000 F598               1954      BRA MAIN_LOOP
00000BA2                          1955    
00000BA2                          1956  L
00000BA2  7A00                    1957      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000BA4                          1958  
00000BA4                          1959      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000BA4  3C3C 0000               1960s     MOVE.W  #0,D6
00000BA8  6000 0048               1961s     BRA _20000009
00000BAC                          1962s _20000008
00000BAC  E98D                    1963          LSL.L #4,D5                                 ; make what we have so far more significant
00000BAE                          1964m         WAIT_CHAR D2,D3                             ; next character -> D2
00000BAE                          1965m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAE                 TRUE     1966m     IFEQ DEBUG
00000BAE  1639 00C00003           1967m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BB4  0803 0000               1968m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000BB8  67F4                    1969m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000BBA                          1970m     ENDC
00000BBA                          1971m     
00000BBA                          1972mm     READ_CHAR D2
00000BBA                 TRUE     1973mm     IFEQ DEBUG
00000BBA  1439 00C00007           1974mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000BC0                          1975mm     ENDC
00000BC0                 FALSE    1976mm     IFNE DEBUG
00000BC0                          1977mm     ENDC
00000BC0                          1978mm      
00000BC0  B43C 001B               1979mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000BC4  6700 F442               1980mm     BEQ START
00000BC8                          1981mm     ENDM
00000BC8                          1982m 
00000BC8                 TRUE     1983m     IFEQ DEBUG
00000BC8                          1984mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000BC8                          1985mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1986mm     IFEQ DEBUG
00000BC8  1639 00C00003           1987mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BCE  0803 0002               1988mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1989mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000BD4  13C2 00C00007           1990mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BDA                          1991mm     ENDC
00000BDA                          1992mm     
00000BDA                 FALSE    1993mm     IFNE DEBUG
00000BDA                          1994mm     ENDC
00000BDA                          1995mm 
00000BDA                          1996mm     ENDM
00000BDA                          1997m     ENDC
00000BDA                          1998m     ENDM
00000BDA                          1999m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000BDA  41F9 00000E03           2000m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000BE0  0402 0030               2001m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BE4  C4BC 000000FF           2002m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000BEA  1430 2000               2003m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000BEE                          2004m     ENDM
00000BEE  8A02                    2005          OR.B D2,D5
00000BF0                          2006      ENDF
00000BF0  5246                    2007s     ADD.W   #1,D6
00000BF2                          2008s _20000009
00000BF2  BC7C 0003               2009s     CMP.W   #3,D6
00000BF6  6FB4                    2010s     BLE _20000008
00000BF8                          2011            
00000BF8                          2012m     PRINT_CRLF D3,A0
00000BF8  41F9 00000E2E           2013m     LEA CRLF,A0
00000BFE                          2014mm     PRINT_STR A0,D3
00000BFE                          2015mm LOOP_143
00000BFE  0C10 0000               2016mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000C02  6700 0016               2017mm     BEQ EXIT_143
00000C06                          2018mmm     PRINT_CHAR (A0)+,D3
00000C06                          2019mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     2020mmm     IFEQ DEBUG
00000C06  1639 00C00003           2021mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C0C  0803 0002               2022mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C10  67F4                    2023mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000C12  13D8 00C00007           2024mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C18                          2025mmm     ENDC
00000C18                          2026mmm     
00000C18                 FALSE    2027mmm     IFNE DEBUG
00000C18                          2028mmm     ENDC
00000C18                          2029mmm 
00000C18                          2030mmm     ENDM
00000C18  60E4                    2031mm     BRA LOOP_143
00000C1A                          2032mm EXIT_143
00000C1A                          2033mm     ENDM
00000C1A                          2034m     ENDM
00000C1A                          2035  
00000C1A  207C 00000000           2036      MOVE.L #ROM,A0                                  ; start of ROM
00000C20                          2037      
00000C20  2247                    2038      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C22  7E00                    2039      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C24                          2040      
00000C24  31FC AAAA 2AAA          2041      MOVE.W #$AAAA,$2AAA
00000C2A  31FC 5555 1554          2042      MOVE.W #$5555,$1554
00000C30  31FC 8080 2AAA          2043      MOVE.W #$8080,$2AAA
00000C36  31FC AAAA 2AAA          2044      MOVE.W #$AAAA,$2AAA
00000C3C  31FC 5555 1554          2045      MOVE.W #$5555,$1554
00000C42  31FC 2020 2AAA          2046      MOVE.W #$2020,$2AAA
00000C48                          2047      
00000C48  45F9 00000E1A           2048      LEA LOADING,A2                              ; important for timing
00000C4E                          2049m     PRINT_STR A2,D3
00000C4E                          2050m LOOP_145
00000C4E  0C12 0000               2051m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000C52  6700 0016               2052m     BEQ EXIT_145
00000C56                          2053mm     PRINT_CHAR (A2)+,D3
00000C56                          2054mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C56                 TRUE     2055mm     IFEQ DEBUG
00000C56  1639 00C00003           2056mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5C  0803 0002               2057mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C60  67F4                    2058mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C62  13DA 00C00007           2059mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C68                          2060mm     ENDC
00000C68                          2061mm     
00000C68                 FALSE    2062mm     IFNE DEBUG
00000C68                          2063mm     ENDC
00000C68                          2064mm 
00000C68                          2065mm     ENDM
00000C68  60E4                    2066m     BRA LOOP_145
00000C6A                          2067m EXIT_145
00000C6A                          2068m     ENDM
00000C6A                          2069      
00000C6A                          2070      WHILE D5 <GT> #0 DO
00000C6A                          2071s _10000014
00000C6A  BA7C 0000               2072s     CMP.W   #0,D5
00000C6E  6F00 001C               2073s     BLE _10000015
00000C72  5585                    2074          SUB.L #2,D5
00000C74                          2075            
00000C74  13D1 00E00001           2076          MOVE.B (A1),DISPLAY
00000C7A  3091                    2077          MOVE.W (A1),(A0)                            ; write the data
00000C7C                          2078        
00000C7C                          2079  WAIT_FOR_COMPLETE
00000C7C  3410                    2080          MOVE.W (A0),D2
00000C7E                          2081  
00000C7E                          2082          IF D2 <NE> (A1) THEN
00000C7E  B451                    2083s     CMP.W   (A1),D2
00000C80  6700 0004               2084s     BEQ _0000000C
00000C84  60F6                    2085              BRA WAIT_FOR_COMPLETE
00000C86                          2086          ENDI
00000C86                          2087s _0000000C
00000C86                          2088        
00000C86  5488                    2089          ADD.L #2,A0
00000C88  5489                    2090          ADD.L #2,A1
00000C8A                          2091       ENDW    
00000C8A  60DE                    2092s     BRA _10000014
00000C8C                          2093s _10000015
00000C8C                          2094      
00000C8C  31FC AAAA 2AAA          2095      MOVE.W #$AAAA,$2AAA
00000C92  31FC 5555 1554          2096      MOVE.W #$5555,$1554
00000C98  31FC A0A0 2AAA          2097      MOVE.W #$A0A0,$2AAA
00000C9E                          2098              
00000C9E  6000 F498               2099      BRA MAIN_LOOP
00000CA2                          2100          
00000CA2                          2101  HEX_DIGIT
00000CA2  E98F                    2102      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000CA4                          2103m     HEX2BIN D2,D2,A0
00000CA4  41F9 00000E03           2104m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00000CAA  0402 0030               2105m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CAE  C4BC 000000FF           2106m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000CB4  1430 2000               2107m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000CB8                          2108m     ENDM
00000CB8  8E02                    2109      OR.B D2,D7  
00000CBA  6000 F49E               2110      BRA GET_INPUT
00000CBE                          2111  
00000CBE  FFFF FFFF               2112      SIMHALT                                         ; halt simulator
00000CC2                          2113  
00000CC2                          2114  ; strings
00000CC2= 4D 44 46 2D 6D 6F ...   2115  VERSION DC.B 'MDF-mon V1.57 (10/04/2021)',CR,LF,NULL
00000CDF= 3F 09 09 09 68 65 ...   2116  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000CE9= 5B 76 5D 09 09 09 ...   2117          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000CF8= 78 78 78 78 78 78 ...   2118          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000D10= 78 78 78 78 78 78 ...   2119          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000D30= 5B 73 5D 09 09 09 ...   2120          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000D4A= 78 78 78 78 78 78 ...   2121          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000D5B= 5B 7A 5D 09 09 09 ...   2122          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000D6D= 78 78 78 78 78 78 ...   2123          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000D8F= 48 75 68 3F 0D 0A 00    2124  HUH     DC.B 'Huh?',CR,LF,NULL
00000D96= 20 53 20 72 65 63 ...   2125  READ    DC.B ' S records read, start address = ',NULL
00000DB8= 57 3A 20 55 6E 6B ...   2126  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000DCF= 57 3A 20 43 53 20 ...   2127  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000DE1= 57 3A 20 52 41 4D ...   2128  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000DF3= 30 31 32 33 34 35 ...   2129  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000E03= 00 01 02 03 04 05 ...   2130  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000E1A= 4C 6F 61 64 69 6E ...   2131  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000E2E= 0D 0A 00                2132  CRLF    DC.B CR,LF,NULL
00000E31= 3E 20 00                2133  PROMPT  DC.B '> ',NULL
00000E34= 30 78 00                2134  ox      DC.B '0x',NULL
00000E37                          2135      
00000E37                          2136      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         DF3
CONTINUE_37         37C
CONTINUE_40         3CC
CONTINUE_44         422
CONTINUE_52         4DA
CONTINUE_57         54E
CONTINUE_62         5CC
CONTINUE_67         64C
CONTINUE_72         6DA
CONTINUE_77         74E
CONTINUE_82         7C2
CONTINUE_96         8BE
CR                  D
CRLF                E2E
CS_FAILURE          DCF
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            93A
DOWNLOAD_BYTE       C1F
DOWNLOAD_DONE       9CA
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             15A
EXIT_101            92A
EXIT_103            954
EXIT_106            976
EXIT_111            9C4
EXIT_114            9EC
EXIT_118            A3A
EXIT_121            A5E
EXIT_126            AAC
EXIT_128            B1E
EXIT_131            B44
EXIT_136            B92
EXIT_143            C1A
EXIT_145            C6A
EXIT_16             1E0
EXIT_18             232
EXIT_20             262
EXIT_23             28E
EXIT_28             2DC
EXIT_3              EA
EXIT_35             354
EXIT_49             496
EXIT_5              10C
EXIT_8              12E
EXIT_87             83A
EXIT_89             85C
EXIT_93             890
G                   AB0
GET_INPUT           15A
H                   236
HELP                CDF
HEX2BIN             134
HEX2BIN_LUT         E03
HEX_DIGIT           CA2
HUH                 D8F
L                   BA2
LF                  A
LOADING             E1A
LOOP_10             13E
LOOP_101            90E
LOOP_103            938
LOOP_105            978
LOOP_106            95A
LOOP_111            9A8
LOOP_113            9EE
LOOP_114            9D0
LOOP_118            A1E
LOOP_120            A60
LOOP_121            A42
LOOP_126            A90
LOOP_128            B02
LOOP_130            B46
LOOP_131            B28
LOOP_136            B76
LOOP_143            BFE
LOOP_145            C4E
LOOP_16             1C4
LOOP_18             216
LOOP_20             246
LOOP_22             290
LOOP_23             272
LOOP_28             2C0
LOOP_3              CE
LOOP_35             338
LOOP_49             47A
LOOP_5              F0
LOOP_8              112
LOOP_87             81E
LOOP_89             840
LOOP_93             874
MAIN_LOOP           138
NULL                0
OX                  E34
PRINTSTR            246
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           555
PRINT_STR           4CD
PROMPT              E31
R                   266
RAM                 200000
RAM_ERROR           DE1
READ                D96
READ_CHAR           7D4
READ_DATA_TO_POKE   2E4
RESET               4
ROM                 0
S                   358
STACK               0
START               8
TAB                 9
UNREC               DB8
V                   240
VERSION             CC2
W                   2E0
WAIT_CHAR           625
WAIT_FOR_COMPLETE   C7C
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_102  916
WAIT_FOR_READY_104  940
WAIT_FOR_READY_107  962
WAIT_FOR_READY_109  98C
WAIT_FOR_READY_11   146
WAIT_FOR_READY_112  9B0
WAIT_FOR_READY_115  9D8
WAIT_FOR_READY_117  A02
WAIT_FOR_READY_119  A26
WAIT_FOR_READY_12   15A
WAIT_FOR_READY_122  A4A
WAIT_FOR_READY_124  A74
WAIT_FOR_READY_127  A98
WAIT_FOR_READY_129  B0A
WAIT_FOR_READY_132  B30
WAIT_FOR_READY_134  B5A
WAIT_FOR_READY_137  B7E
WAIT_FOR_READY_138  BAE
WAIT_FOR_READY_14   174
WAIT_FOR_READY_140  BC8
WAIT_FOR_READY_144  C06
WAIT_FOR_READY_146  C56
WAIT_FOR_READY_17   1CC
WAIT_FOR_READY_19   21E
WAIT_FOR_READY_21   24E
WAIT_FOR_READY_24   27A
WAIT_FOR_READY_26   2A4
WAIT_FOR_READY_29   2C8
WAIT_FOR_READY_30   2E6
WAIT_FOR_READY_32   300
WAIT_FOR_READY_36   340
WAIT_FOR_READY_37   360
WAIT_FOR_READY_39   39A
WAIT_FOR_READY_4    D6
WAIT_FOR_READY_40   3B0
WAIT_FOR_READY_42   3E4
WAIT_FOR_READY_44   406
WAIT_FOR_READY_46   43A
WAIT_FOR_READY_50   482
WAIT_FOR_READY_52   4BE
WAIT_FOR_READY_54   4F2
WAIT_FOR_READY_57   532
WAIT_FOR_READY_59   566
WAIT_FOR_READY_6    F8
WAIT_FOR_READY_62   5B0
WAIT_FOR_READY_64   5E4
WAIT_FOR_READY_67   630
WAIT_FOR_READY_69   664
WAIT_FOR_READY_72   6BE
WAIT_FOR_READY_74   6F2
WAIT_FOR_READY_77   732
WAIT_FOR_READY_79   766
WAIT_FOR_READY_82   7A6
WAIT_FOR_READY_84   7DA
WAIT_FOR_READY_88   826
WAIT_FOR_READY_9    11A
WAIT_FOR_READY_90   848
WAIT_FOR_READY_91   85C
WAIT_FOR_READY_94   87C
WAIT_FOR_READY_96   8A2
WAIT_FOR_READY_98   8D6
WAIT_FOR_SRECORD    360
Z                   AB8
_00000000           19A
_00000001           1AE
_00000002           49E
_00000003           894
_00000004           4AC
_00000005           6A6
_00000006           616
_00000007           894
_00000008           818
_00000009           894
_0000000A           9C8
_0000000B           B92
_0000000C           C86
_10000000           3FC
_10000001           466
_10000002           4B4
_10000003           51E
_10000004           528
_10000005           592
_10000006           5A6
_10000007           610
_10000008           61A
_10000009           69E
_1000000A           626
_1000000B           690
_1000000C           6B4
_1000000D           71E
_1000000E           728
_1000000F           792
_10000010           79C
_10000011           806
_10000012           898
_10000013           902
_10000014           C6A
_10000015           C8C
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           AC4
_20000005           AD4
_20000006           AE8
_20000007           B94
_20000008           BAC
_20000009           BF2
