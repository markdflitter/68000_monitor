00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 15:28:38

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  
00000000                            12  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            16  ; fix being able to enter random chars when W'ing
00000000                            17  ; ram check at startup?  Not sure if this is a good idea!
00000000                            18  
00000000                            19      ORG  $0
00000000                            20      ;ORG  $200000
00000000                            21  
00000000  =00000000                 22  DEBUG               EQU 0
00000000                            23  
00000000                            24  ; constants
00000000  =00000000                 25  ROM                 EQU $0
00000000  =00200000                 26  RAM                 EQU $200000
00000000                            27     
00000000  =00C00000                 28  DUART_BASE          EQU $C00000
00000000  =00000000                 29  DUART_MRA_          EQU $0
00000000  =00000001                 30  DUART_CSRA_         EQU $1
00000000  =00000001                 31  DUART_SRA_          EQU $1
00000000  =00000002                 32  DUART_CRA_          EQU $2
00000000  =00000003                 33  DUART_TXA_          EQU $3
00000000  =00000003                 34  DUART_RXA_          EQU $3
00000000  =00000004                 35  DUART_ACR_          EQU $4
00000000  =00000005                 36  DUART_IMR_          EQU $5
00000000  =00000008                 37  DUART_MRB_          EQU $8
00000000  =00000009                 38  DUART_CSRB_         EQU $9
00000000  =00000009                 39  DUART_SRB_          EQU $9
00000000  =0000000A                 40  DUART_CRB_          EQU $A
00000000  =0000000B                 41  DUART_TXB_          EQU $B
00000000  =0000000B                 42  DUART_RXB_          EQU $B
00000000  =0000000C                 43  DUART_IVR_          EQU $C
00000000  =0000000D                 44  DUART_OPCR_         EQU $D
00000000  =0000000E                 45  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 46  DUART_RESET_OPR_    EQU $F
00000000                            47  
00000000  =00C00001                 48  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 49  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 50  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 51  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 52  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 53  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            54  
00000000  =00C00011                 55  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 56  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 57  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 58  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 59  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 60  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            61  
00000000  =00C00009                 62  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 63  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 64  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 65  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 66  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 67  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            68  
00000000  =00E00000                 69  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 70  DISPLAY_            EQU $0
00000000  =00E00001                 71  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            72  
00000000                            73  ; macros
00000000                            74  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            75  ; the input register is changed during the process
00000000                            76  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            77  BIN2HEX MACRO
00000000                            78      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            79      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            80      MOVE.B \1,\2
00000000                            81      ANDI.L #$F,\2
00000000                            82      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            83      ENDM
00000000                            84  
00000000                            85  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            86  ; the input register is changed during the process
00000000                            87  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            88  HEX2BIN MACRO
00000000                            89      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            90      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            91      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                            92      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                            93      ENDM
00000000                            94  
00000000                            95  ; send a single char to the serial port
00000000                            96  ; \1 = char to send, \2 = data register to use for status poll
00000000                            97  ; will stamp on D0 and D1 in debug mode
00000000                            98  PRINT_CHAR MACRO
00000000                            99  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           100      IFEQ DEBUG
00000000                           101          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           102          BTST #2,\2                              ; check for space to send
00000000                           103          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           104          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           105      ENDC
00000000                           106      
00000000                           107      IFNE DEBUG
00000000                           108          MOVE.B \1,D1
00000000                           109          MOVE.L #6,D0   
00000000                           110          TRAP #15                                ; write to terminal in simulator
00000000                           111      ENDC
00000000                           112  
00000000                           113      ENDM
00000000                           114  
00000000                           115  ; send CR,LF to the serial port
00000000                           116  ; \1 = data register to use for status poll
00000000                           117  PRINT_CRLF MACRO
00000000                           118      PRINT_CHAR #13,\1                           ; CR
00000000                           119      PRINT_CHAR #10,\1                           ; LF
00000000                           120      ENDM
00000000                           121  
00000000                           122  ; send C-style, zero terminated string to the serial port
00000000                           123  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           124  PRINT_STR MACRO
00000000                           125  LOOP\@
00000000                           126      CMP.B #0,(\1)                               ; 0 -> done
00000000                           127      BEQ EXIT\@
00000000                           128      PRINT_CHAR (\1)+,\2
00000000                           129      BRA LOOP\@
00000000                           130  EXIT\@
00000000                           131      ENDM
00000000                           132    
00000000                           133  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           134  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           135  PRINT_REG MACRO
00000000                           136      PRINT_CHAR #'0',\2                          ;0x header
00000000                           137      PRINT_CHAR #'x',\2
00000000                           138      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           139  LOOP\@
00000000                           140      BIN2HEX \1,\3,\5
00000000                           141      PRINT_CHAR \3,\2
00000000                           142      DBEQ \4,LOOP\@
00000000                           143      ENDM
00000000                           144      
00000000                           145  ; wait for a char from the serial port
00000000                           146  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           147  ; will stamp on D0 and D1 in debug mode
00000000                           148  WAIT_CHAR MACRO
00000000                           149  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           150      IFEQ DEBUG
00000000                           151          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           152          BTST #0,\2                              ; check for character
00000000                           153          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           154      ENDC
00000000                           155      
00000000                           156      READ_CHAR \1
00000000                           157  
00000000                           158      IFEQ DEBUG
00000000                           159          PRINT_CHAR \1,\2                        ; echo it back
00000000                           160      ENDC
00000000                           161      ENDM
00000000                           162      
00000000                           163  ; read a char from the serial port - assumes that there is one!
00000000                           164  ; \ 1= data register for read char
00000000                           165  ; will stamp on D0 and D1 in debug mode
00000000                           166  READ_CHAR MACRO
00000000                           167      IFEQ DEBUG
00000000                           168          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           169      ENDC
00000000                           170      IFNE DEBUG
00000000                           171          MOVE.L #5,D0    
00000000                           172          TRAP #15                                ; read from keyboard in simulator
00000000                           173          MOVE.L D1,\1
00000000                           174      ENDC
00000000                           175       
00000000                           176      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           177      BEQ START
00000000                           178      ENDM
00000000                           179      
00000000                           180      
00000000                           181  ; read data from the download serial port
00000000                           182  ; \ 1= data register for read char
00000000                           183  DOWNLOAD MACRO
00000000                           184  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           185  
00000000                           186      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           187      BTST #0,\1                                  ; check for character
00000000                           188      BEQ CONTINUE\@                              ; nothing, continue
00000000                           189   
00000000                           190      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           191  CONTINUE\@
00000000                           192      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           193      BTST #0,\1                                  ; check for character
00000000                           194      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           195      
00000000                           196      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           197      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           198      
00000000                           199      ENDM
00000000                           200      
00000000                           201  ; read two hex digits from the download serial port and convert to a byte
00000000                           202  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           203  DOWNLOAD_BYTE MACRO
00000000                           204      MOVE.B #2,\4
00000000                           205      WHILE.B \4 <GT> 0 DO
00000000                           206          LSL.L #4,\1                         ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           207          DOWNLOAD \2
00000000                           208          PRINT_CHAR \2,\3
00000000                           209          HEX2BIN \2,\2,\6
00000000                           210          OR.B \2,\1
00000000                           211          SUB.B #1,\4
00000000                           212      ENDW
00000000                           213      
00000000                           214      MOVE.L #0,\2                            ; rextract latest byte of address and add into checksum
00000000                           215      MOVE.B \1,\2
00000000                           216      ADD.L \1,\5
00000000                           217  
00000000                           218      ENDM
00000000                           219      
00000000                           220  
00000000                           221  ; register catalogue
00000000                           222  ; D0 - used for simulator I/O
00000000                           223  ; D1 - used for simulator I/O
00000000                           224  ; D2 - read character
00000000                           225  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           226  ; D6 - working register used in R/W
00000000                           227  ; D7 - address accumulator, reset by download
00000000                           228  ; A0 - address of string to print 
00000000                           229  
00000000                           230  ; start vector
00000000= 00000000                 231  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 232  RESET    DC.L START                             ; RESET
00000008                           233      
00000008                           234  ; start of program  
00000008                           235  START
00000008  13FC 0000 00E00001       236      MOVE.B #0,DISPLAY
00000010                           237  
00000010                           238  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       239      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       240      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     241      NOP
00000022  13FC 0040 00C00005       242      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     243      NOP
0000002C  13FC 0030 00C00005       244      MOVE.B #$30,DUART_CRA
00000034  4E71                     245      NOP
00000036  13FC 0020 00C00005       246      MOVE.B #$20,DUART_CRA
0000003E  4E71                     247      NOP
00000040  13FC 0010 00C00005       248      MOVE.B #$10,DUART_CRA   
00000048                           249  
00000048  13FC 000A 00C00015       250      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       251      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     252      NOP
0000005A  13FC 0040 00C00015       253      MOVE.B #$40,DUART_CRB           
00000062  4E71                     254      NOP
00000064  13FC 0030 00C00015       255      MOVE.B #$30,DUART_CRB
0000006C  4E71                     256      NOP
0000006E  13FC 0020 00C00015       257      MOVE.B #$20,DUART_CRB
00000076  4E71                     258      NOP
00000078  13FC 0010 00C00015       259      MOVE.B #$10,DUART_CRB   
00000080                           260  
00000080                           261  ;initialise UART
00000080  13FC 0000 00C00009       262      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       263      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       264      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           265  
00000098                           266  ; channel A
00000098  13FC 0013 00C00001       267      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       268      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       269      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       270      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           271  
000000B8                           272  ; channel B
000000B8  13FC 0013 00C00011       273      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       274      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       275      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       276      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           277  
000000D8                           278m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           279m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      280m     IFEQ DEBUG
000000D8  1639 00C00003            281m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                282m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     283m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       284m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           285m     ENDC
000000EC                           286m     
000000EC                 FALSE     287m     IFNE DEBUG
000000EC                           288m     ENDC
000000EC                           289m 
000000EC                           290m     ENDM
000000EC                           291  
000000EC  13FC 0001 00E00001       292      MOVE.B #1,DISPLAY
000000F4                           293         
000000F4                           294m     PRINT_CRLF D3
000000F4                           295mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           296mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      297mm     IFEQ DEBUG
000000F4  1639 00C00003            298mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                299mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     300mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       301mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           302mm     ENDC
00000108                           303mm     
00000108                 FALSE     304mm     IFNE DEBUG
00000108                           305mm     ENDC
00000108                           306mm 
00000108                           307mm     ENDM
00000108                           308mm     PRINT_CHAR #10,D3                           ; LF
00000108                           309mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      310mm     IFEQ DEBUG
00000108  1639 00C00003            311mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                312mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     313mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       314mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           315mm     ENDC
0000011C                           316mm     
0000011C                 FALSE     317mm     IFNE DEBUG
0000011C                           318mm     ENDC
0000011C                           319mm 
0000011C                           320mm     ENDM
0000011C                           321m     ENDM
0000011C                           322  
0000011C  41F9 00000E56            323      LEA VERSION,A0
00000122                           324m     PRINT_STR A0,D3
00000122                           325m LOOP_5
00000122  0C10 0000                326m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0016                327m     BEQ EXIT_5
0000012A                           328mm     PRINT_CHAR (A0)+,D3
0000012A                           329mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      330mm     IFEQ DEBUG
0000012A  1639 00C00003            331mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                332mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     333mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            334mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           335mm     ENDC
0000013C                           336mm     
0000013C                 FALSE     337mm     IFNE DEBUG
0000013C                           338mm     ENDC
0000013C                           339mm 
0000013C                           340mm     ENDM
0000013C  60E4                     341m     BRA LOOP_5
0000013E                           342m EXIT_5
0000013E                           343m     ENDM
0000013E                           344m     PRINT_CRLF D3
0000013E                           345mm     PRINT_CHAR #13,D3                           ; CR
0000013E                           346mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      347mm     IFEQ DEBUG
0000013E  1639 00C00003            348mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                349mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     350mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014A  13FC 000D 00C00007       351mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000152                           352mm     ENDC
00000152                           353mm     
00000152                 FALSE     354mm     IFNE DEBUG
00000152                           355mm     ENDC
00000152                           356mm 
00000152                           357mm     ENDM
00000152                           358mm     PRINT_CHAR #10,D3                           ; LF
00000152                           359mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      360mm     IFEQ DEBUG
00000152  1639 00C00003            361mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000158  0803 0002                362mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015C  67F4                     363mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0000015E  13FC 000A 00C00007       364mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000166                           365mm     ENDC
00000166                           366mm     
00000166                 FALSE     367mm     IFNE DEBUG
00000166                           368mm     ENDC
00000166                           369mm 
00000166                           370mm     ENDM
00000166                           371m     ENDM
00000166                           372m     PRINT_CHAR #7,D3
00000166                           373m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000166                 TRUE      374m     IFEQ DEBUG
00000166  1639 00C00003            375m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016C  0803 0002                376m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000170  67F4                     377m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000172  13FC 0007 00C00007       378m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017A                           379m     ENDC
0000017A                           380m     
0000017A                 FALSE     381m     IFNE DEBUG
0000017A                           382m     ENDC
0000017A                           383m 
0000017A                           384m     ENDM
0000017A                           385  
0000017A  7E00                     386      MOVE.L #0,D7                                ; address accumulator
0000017C                           387  
0000017C  13FC 0002 00E00001       388      MOVE.B #2,DISPLAY
00000184                           389  MAIN_LOOP
00000184                           390m     PRINT_CHAR #'>',D3                          ; prompt
00000184                           391m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000184                 TRUE      392m     IFEQ DEBUG
00000184  1639 00C00003            393m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018A  0803 0002                394m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000018E  67F4                     395m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000190  13FC 003E 00C00007       396m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000198                           397m     ENDC
00000198                           398m     
00000198                 FALSE     399m     IFNE DEBUG
00000198                           400m     ENDC
00000198                           401m 
00000198                           402m     ENDM
00000198                           403m     PRINT_CHAR #32,D3                           ; space
00000198                           404m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000198                 TRUE      405m     IFEQ DEBUG
00000198  1639 00C00003            406m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000019E  0803 0002                407m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A2  67F4                     408m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A4  13FC 0020 00C00007       409m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AC                           410m     ENDC
000001AC                           411m     
000001AC                 FALSE     412m     IFNE DEBUG
000001AC                           413m     ENDC
000001AC                           414m 
000001AC                           415m     ENDM
000001AC                           416      
000001AC                           417  GET_INPUT
000001AC                           418m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AC                           419m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AC                 TRUE      420m     IFEQ DEBUG
000001AC  1639 00C00003            421m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B2  0803 0000                422m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B6  67F4                     423m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001B8                           424m     ENDC
000001B8                           425m     
000001B8                           426mm     READ_CHAR D2
000001B8                 TRUE      427mm     IFEQ DEBUG
000001B8  1439 00C00007            428mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001BE                           429mm     ENDC
000001BE                 FALSE     430mm     IFNE DEBUG
000001BE                           431mm     ENDC
000001BE                           432mm      
000001BE  B43C 001B                433mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C2  6700 FE44                434mm     BEQ START
000001C6                           435mm     ENDM
000001C6                           436m 
000001C6                 TRUE      437m     IFEQ DEBUG
000001C6                           438mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C6                           439mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C6                 TRUE      440mm     IFEQ DEBUG
000001C6  1639 00C00003            441mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CC  0803 0002                442mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D0  67F4                     443mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D2  13C2 00C00007            444mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001D8                           445mm     ENDC
000001D8                           446mm     
000001D8                 FALSE     447mm     IFNE DEBUG
000001D8                           448mm     ENDC
000001D8                           449mm 
000001D8                           450mm     ENDM
000001D8                           451m     ENDC
000001D8                           452m     ENDM
000001D8                           453      
000001D8                           454      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001D8  B43C 0030                455s     CMP.B   #'0',D2
000001DC  6D00 000E                456s     BLT _00000000
000001E0  B43C 0039                457s     CMP.B   #'9',D2
000001E4  6E00 0006                458s     BGT _00000000
000001E8  6000 0C4C                459          BRA HEX_DIGIT
000001EC                           460      ENDI
000001EC                           461s _00000000
000001EC                           462      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001EC  B43C 0041                463s     CMP.B   #'A',D2
000001F0  6D00 000E                464s     BLT _00000001
000001F4  B43C 0046                465s     CMP.B   #'F',D2
000001F8  6E00 0006                466s     BGT _00000001
000001FC  6000 0C38                467          BRA HEX_DIGIT
00000200                           468      ENDI
00000200                           469s _00000001
00000200                           470          
00000200  B43C 0077                471      CMP.B #'w',D2
00000204  6700 015A                472      BEQ W
00000208                           473      
00000208  B43C 006C                474      CMP.B #'l',D2
0000020C  6700 0ABC                475      BEQ L 
00000210                           476  
00000210                           477m     PRINT_CRLF D3
00000210                           478mm     PRINT_CHAR #13,D3                           ; CR
00000210                           479mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000210                 TRUE      480mm     IFEQ DEBUG
00000210  1639 00C00003            481mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000216  0803 0002                482mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000021A  67F4                     483mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0000021C  13FC 000D 00C00007       484mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000224                           485mm     ENDC
00000224                           486mm     
00000224                 FALSE     487mm     IFNE DEBUG
00000224                           488mm     ENDC
00000224                           489mm 
00000224                           490mm     ENDM
00000224                           491mm     PRINT_CHAR #10,D3                           ; LF
00000224                           492mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000224                 TRUE      493mm     IFEQ DEBUG
00000224  1639 00C00003            494mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000022A  0803 0002                495mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000022E  67F4                     496mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
00000230  13FC 000A 00C00007       497mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000238                           498mm     ENDC
00000238                           499mm     
00000238                 FALSE     500mm     IFNE DEBUG
00000238                           501mm     ENDC
00000238                           502mm 
00000238                           503mm     ENDM
00000238                           504m     ENDM
00000238                           505   
00000238  B43C 003F                506      CMP.B #'?',D2
0000023C  6700 0050                507      BEQ H
00000240                           508  
00000240  B43C 0076                509      CMP.B #'v',D2
00000244  6700 006E                510      BEQ V
00000248                           511      
00000248  B43C 0072                512      CMP.B #'r',D2
0000024C  6700 008C                513      BEQ R
00000250                           514  
00000250  B43C 0073                515      CMP.B #'s',D2
00000254  6700 01D0                516      BEQ S
00000258                           517  
00000258  B43C 0067                518      CMP.B #'g',D2
0000025C  6700 095E                519      BEQ G   
00000260                           520  
00000260  B43C 007A                521      CMP.B #'z',D2
00000264  6700 095E                522      BEQ Z   
00000268                           523  
00000268  41F9 00000F18            524      LEA HUH,A0
0000026E                           525m     PRINT_STR A0,D3
0000026E                           526m LOOP_19
0000026E  0C10 0000                527m     CMP.B #0,(A0)                               ; 0 -> DONE
00000272  6700 0016                528m     BEQ EXIT_19
00000276                           529mm     PRINT_CHAR (A0)+,D3
00000276                           530mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      531mm     IFEQ DEBUG
00000276  1639 00C00003            532mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000027C  0803 0002                533mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000280  67F4                     534mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
00000282  13D8 00C00007            535mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000288                           536mm     ENDC
00000288                           537mm     
00000288                 FALSE     538mm     IFNE DEBUG
00000288                           539mm     ENDC
00000288                           540mm 
00000288                           541mm     ENDM
00000288  60E4                     542m     BRA LOOP_19
0000028A                           543m EXIT_19
0000028A                           544m     ENDM
0000028A                           545                         
0000028A  6000 FEF8                546      BRA MAIN_LOOP
0000028E                           547      
0000028E                           548  ; commands
0000028E                           549  H   
0000028E  41F9 00000E73            550      LEA HELP,A0
00000294                           551m     PRINT_STR A0,D3
00000294                           552m LOOP_21
00000294  0C10 0000                553m     CMP.B #0,(A0)                               ; 0 -> DONE
00000298  6700 0016                554m     BEQ EXIT_21
0000029C                           555mm     PRINT_CHAR (A0)+,D3
0000029C                           556mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      557mm     IFEQ DEBUG
0000029C  1639 00C00003            558mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002A2  0803 0002                559mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002A6  67F4                     560mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
000002A8  13D8 00C00007            561mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002AE                           562mm     ENDC
000002AE                           563mm     
000002AE                 FALSE     564mm     IFNE DEBUG
000002AE                           565mm     ENDC
000002AE                           566mm 
000002AE                           567mm     ENDM
000002AE  60E4                     568m     BRA LOOP_21
000002B0                           569m EXIT_21
000002B0                           570m     ENDM
000002B0  6000 FED2                571      BRA MAIN_LOOP
000002B4                           572  
000002B4                           573  V   
000002B4  41F9 00000E56            574      LEA VERSION,A0
000002BA                           575m     PRINT_STR A0,D3       
000002BA                           576m LOOP_23
000002BA  0C10 0000                577m     CMP.B #0,(A0)                               ; 0 -> DONE
000002BE  6700 0016                578m     BEQ EXIT_23
000002C2                           579mm     PRINT_CHAR (A0)+,D3
000002C2                           580mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C2                 TRUE      581mm     IFEQ DEBUG
000002C2  1639 00C00003            582mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002C8  0803 0002                583mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002CC  67F4                     584mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
000002CE  13D8 00C00007            585mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002D4                           586mm     ENDC
000002D4                           587mm     
000002D4                 FALSE     588mm     IFNE DEBUG
000002D4                           589mm     ENDC
000002D4                           590mm 
000002D4                           591mm     ENDM
000002D4  60E4                     592m     BRA LOOP_23
000002D6                           593m EXIT_23
000002D6                           594m     ENDM
000002D6  6000 FEAC                595      BRA MAIN_LOOP
000002DA                           596      
000002DA                           597  R   
000002DA  2047                     598      MOVE.L D7,A0                                ; address accumulator -> address register
000002DC  2A10                     599      MOVE.L (A0),D5                              ; read the memory and print it
000002DE                           600m     PRINT_REG D5,D3,D7,D6,A0
000002DE                           601mm     PRINT_CHAR #'0',D3                          ;0X HEADER
000002DE                           602mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      603mm     IFEQ DEBUG
000002DE  1639 00C00003            604mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002E4  0803 0002                605mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002E8  67F4                     606mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
000002EA  13FC 0030 00C00007       607mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
000002F2                           608mm     ENDC
000002F2                           609mm     
000002F2                 FALSE     610mm     IFNE DEBUG
000002F2                           611mm     ENDC
000002F2                           612mm 
000002F2                           613mm     ENDM
000002F2                           614mm     PRINT_CHAR #'x',D3
000002F2                           615mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F2                 TRUE      616mm     IFEQ DEBUG
000002F2  1639 00C00003            617mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002F8  0803 0002                618mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002FC  67F4                     619mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
000002FE  13FC 0078 00C00007       620mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000306                           621mm     ENDC
00000306                           622mm     
00000306                 FALSE     623mm     IFNE DEBUG
00000306                           624mm     ENDC
00000306                           625mm 
00000306                           626mm     ENDM
00000306  7C07                     627m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000308                           628m LOOP_25
00000308                           629mm     BIN2HEX D5,D7,A0
00000308  41F9 00000F7C            630mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000030E  E99D                     631mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000310  1E05                     632mm     MOVE.B D5,D7
00000312  0287 0000000F            633mm     ANDI.L #$F,D7
00000318  1E30 7000                634mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0000031C                           635mm     ENDM
0000031C                           636mm     PRINT_CHAR D7,D3
0000031C                           637mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031C                 TRUE      638mm     IFEQ DEBUG
0000031C  1639 00C00003            639mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000322  0803 0002                640mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000326  67F4                     641mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000328  13C7 00C00007            642mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000032E                           643mm     ENDC
0000032E                           644mm     
0000032E                 FALSE     645mm     IFNE DEBUG
0000032E                           646mm     ENDC
0000032E                           647mm 
0000032E                           648mm     ENDM
0000032E  57CE FFD8                649m     DBEQ D6,LOOP_25
00000332                           650m     ENDM
00000332                           651m     PRINT_CRLF D3
00000332                           652mm     PRINT_CHAR #13,D3                           ; CR
00000332                           653mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000332                 TRUE      654mm     IFEQ DEBUG
00000332  1639 00C00003            655mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000338  0803 0002                656mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000033C  67F4                     657mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
0000033E  13FC 000D 00C00007       658mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000346                           659mm     ENDC
00000346                           660mm     
00000346                 FALSE     661mm     IFNE DEBUG
00000346                           662mm     ENDC
00000346                           663mm 
00000346                           664mm     ENDM
00000346                           665mm     PRINT_CHAR #10,D3                           ; LF
00000346                           666mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000346                 TRUE      667mm     IFEQ DEBUG
00000346  1639 00C00003            668mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000034C  0803 0002                669mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000350  67F4                     670mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
00000352  13FC 000A 00C00007       671mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000035A                           672mm     ENDC
0000035A                           673mm     
0000035A                 FALSE     674mm     IFNE DEBUG
0000035A                           675mm     ENDC
0000035A                           676mm 
0000035A                           677mm     ENDM
0000035A                           678m     ENDM
0000035A  7E00                     679      MOVE.L #0,D7                                ; clear the now used address accumulator
0000035C  6000 FE26                680      BRA MAIN_LOOP
00000360                           681  
00000360                           682  W
00000360  7A00                     683      MOVE.L #0,D5                                ; D5 will be the value to write            
00000362                           684  
00000362                           685m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000362                           686m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000362                 TRUE      687m     IFEQ DEBUG
00000362  1639 00C00003            688m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000368  0803 0000                689m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000036C  67F4                     690m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
0000036E                           691m     ENDC
0000036E                           692m     
0000036E                           693mm     READ_CHAR D2
0000036E                 TRUE      694mm     IFEQ DEBUG
0000036E  1439 00C00007            695mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000374                           696mm     ENDC
00000374                 FALSE     697mm     IFNE DEBUG
00000374                           698mm     ENDC
00000374                           699mm      
00000374  B43C 001B                700mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000378  6700 FC8E                701mm     BEQ START
0000037C                           702mm     ENDM
0000037C                           703m 
0000037C                 TRUE      704m     IFEQ DEBUG
0000037C                           705mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
0000037C                           706mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037C                 TRUE      707mm     IFEQ DEBUG
0000037C  1639 00C00003            708mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000382  0803 0002                709mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000386  67F4                     710mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
00000388  13C2 00C00007            711mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000038E                           712mm     ENDC
0000038E                           713mm     
0000038E                 FALSE     714mm     IFNE DEBUG
0000038E                           715mm     ENDC
0000038E                           716mm 
0000038E                           717mm     ENDM
0000038E                           718m     ENDC
0000038E                           719m     ENDM
0000038E                           720m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
0000038E  41F9 00000F8C            721m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000394  0402 0030                722m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000398  C4BC 000000FF            723m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000039E  1430 2000                724m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003A2                           725m     ENDM
000003A2  1A02                     726      MOVE.B D2,D5                                ; put at bottom of D5
000003A4                           727  
000003A4  3C3C 0006                728      MOVE #6,D6                                  ; 7 bytes left to read
000003A8                           729      
000003A8                           730  READ_DATA_TO_POKE
000003A8  E98D                     731      LSL.L #4,D5                                 ; make what we have so far more significant
000003AA                           732m     WAIT_CHAR D2,D3                             ; next character -> D2
000003AA                           733m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AA                 TRUE      734m     IFEQ DEBUG
000003AA  1639 00C00003            735m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003B0  0803 0000                736m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003B4  67F4                     737m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
000003B6                           738m     ENDC
000003B6                           739m     
000003B6                           740mm     READ_CHAR D2
000003B6                 TRUE      741mm     IFEQ DEBUG
000003B6  1439 00C00007            742mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003BC                           743mm     ENDC
000003BC                 FALSE     744mm     IFNE DEBUG
000003BC                           745mm     ENDC
000003BC                           746mm      
000003BC  B43C 001B                747mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003C0  6700 FC46                748mm     BEQ START
000003C4                           749mm     ENDM
000003C4                           750m 
000003C4                 TRUE      751m     IFEQ DEBUG
000003C4                           752mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003C4                           753mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C4                 TRUE      754mm     IFEQ DEBUG
000003C4  1639 00C00003            755mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003CA  0803 0002                756mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003CE  67F4                     757mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
000003D0  13C2 00C00007            758mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003D6                           759mm     ENDC
000003D6                           760mm     
000003D6                 FALSE     761mm     IFNE DEBUG
000003D6                           762mm     ENDC
000003D6                           763mm 
000003D6                           764mm     ENDM
000003D6                           765m     ENDC
000003D6                           766m     ENDM
000003D6                           767m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003D6  41F9 00000F8C            768m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003DC  0402 0030                769m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003E0  C4BC 000000FF            770m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003E6  1430 2000                771m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000003EA                           772m     ENDM
000003EA  8A02                     773      OR.B D2,D5
000003EC  023C 00FB                774      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
000003F0  57CE FFB6                775      DBEQ D6,READ_DATA_TO_POKE
000003F4                           776      
000003F4  2047                     777      MOVE.L D7,A0                                ; address accumulator -> address register
000003F6  7E00                     778      MOVE.L #0,D7                                ; clear the now used address accumulator
000003F8                           779      
000003F8  2085                     780      MOVE.L D5,(A0)                              ; write the data
000003FA                           781  
000003FA                           782m     PRINT_CRLF D3
000003FA                           783mm     PRINT_CHAR #13,D3                           ; CR
000003FA                           784mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003FA                 TRUE      785mm     IFEQ DEBUG
000003FA  1639 00C00003            786mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000400  0803 0002                787mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000404  67F4                     788mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000406  13FC 000D 00C00007       789mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000040E                           790mm     ENDC
0000040E                           791mm     
0000040E                 FALSE     792mm     IFNE DEBUG
0000040E                           793mm     ENDC
0000040E                           794mm 
0000040E                           795mm     ENDM
0000040E                           796mm     PRINT_CHAR #10,D3                           ; LF
0000040E                           797mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040E                 TRUE      798mm     IFEQ DEBUG
0000040E  1639 00C00003            799mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000414  0803 0002                800mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000418  67F4                     801mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0000041A  13FC 000A 00C00007       802mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000422                           803mm     ENDC
00000422                           804mm     
00000422                 FALSE     805mm     IFNE DEBUG
00000422                           806mm     ENDC
00000422                           807mm 
00000422                           808mm     ENDM
00000422                           809m     ENDM
00000422  6000 FD60                810      BRA MAIN_LOOP
00000426                           811  
00000426                           812  ; register map for S
00000426                           813  ; A0 - start address
00000426                           814  ; A1 - offset
00000426                           815  ; A2 - next address to write
00000426                           816  ; A3 - next location (jmp)
00000426                           817  ; A4 - Working Address Register
00000426                           818  ; D0 - record count
00000426                           819  ; D1 - 'S', record type, data byte
00000426                           820  ; D2 - checksum
00000426                           821  ; D3 - data byte count
00000426                           822  ; D4 - read address, moved into A2
00000426                           823  ; D5 - temp
00000426                           824  ; D6 - temp
00000426                           825  ; D7 - temp
00000426                           826  S
00000426  2078 0000                827      MOVE.L 0,A0                                 ; start address -> A0
0000042A  2247                     828      MOVE.L D7,A1                                ; grab the address accumulator (offset) into A1
0000042C                           829      
0000042C  7000                     830      MOVE.L #0,D0                                ; count of records read -> D0
0000042E                           831          
0000042E                           832  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
0000042E                           833m     DOWNLOAD D1                 
0000042E                           834m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042E                           835m 
0000042E  1239 00C00003            836m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000434  0801 0000                837m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000438  6700 0010                838m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0000043C                           839m  
0000043C                           840mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000043C                 TRUE      841mm     IFEQ DEBUG
0000043C  1239 00C00007            842mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
00000442                           843mm     ENDC
00000442                 FALSE     844mm     IFNE DEBUG
00000442                           845mm     ENDC
00000442                           846mm      
00000442  B23C 001B                847mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000446  6700 FBC0                848mm     BEQ START
0000044A                           849mm     ENDM
0000044A                           850m CONTINUE_44
0000044A  1239 00C00013            851m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
00000450  0801 0000                852m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000454  67D8                     853m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
00000456                           854m     
00000456  1239 00C00017            855m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
0000045C  13C1 00E00001            856m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
00000462                           857m     
00000462                           858m     ENDM
00000462  B23C 0053                859      CMP.B #'S',D1                               ; found S?    
00000466  66C6                     860      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
00000468                           861      
00000468                           862m     PRINT_CHAR #'S',D5                          ; print the S
00000468                           863m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      864m     IFEQ DEBUG
00000468  1A39 00C00003            865m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000046E  0805 0002                866m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000472  67F4                     867m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
00000474  13FC 0053 00C00007       868m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000047C                           869m     ENDC
0000047C                           870m     
0000047C                 FALSE     871m     IFNE DEBUG
0000047C                           872m     ENDC
0000047C                           873m 
0000047C                           874m     ENDM
0000047C  5280                     875      ADD.L #1,D0                                 ; read another S record, increment count
0000047E                           876      
0000047E                           877m     DOWNLOAD D1                                 ; read the record identifier and echo it back
0000047E                           878m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047E                           879m 
0000047E  1239 00C00003            880m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00000484  0801 0000                881m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000488  6700 0010                882m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
0000048C                           883m  
0000048C                           884mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0000048C                 TRUE      885mm     IFEQ DEBUG
0000048C  1239 00C00007            886mm         MOVE.B DUART_RXA,D1                     ; GOT A CHARACTER, READ IT
00000492                           887mm     ENDC
00000492                 FALSE     888mm     IFNE DEBUG
00000492                           889mm     ENDC
00000492                           890mm      
00000492  B23C 001B                891mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00000496  6700 FB70                892mm     BEQ START
0000049A                           893mm     ENDM
0000049A                           894m CONTINUE_47
0000049A  1239 00C00013            895m     MOVE.B DUART_SRB,D1                         ; READ DOWNLOAD STATUS REGISTER
000004A0  0801 0000                896m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000004A4  67D8                     897m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
000004A6                           898m     
000004A6  1239 00C00017            899m     MOVE.B DUART_RXB,D1                         ; GOT A CHARACTER, READ IT
000004AC  13C1 00E00001            900m     MOVE.B D1,DISPLAY                           ; ECHO TO THE DISPLAY
000004B2                           901m     
000004B2                           902m     ENDM
000004B2                           903m     PRINT_CHAR D1,D5
000004B2                           904m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B2                 TRUE      905m     IFEQ DEBUG
000004B2  1A39 00C00003            906m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000004B8  0805 0002                907m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000004BC  67F4                     908m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
000004BE  13C1 00C00007            909m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004C4                           910m     ENDC
000004C4                           911m     
000004C4                 FALSE     912m     IFNE DEBUG
000004C4                           913m     ENDC
000004C4                           914m 
000004C4                           915m     ENDM
000004C4                           916  
000004C4  7400                     917      MOVE.L #0,D2                                ; clear the checksum
000004C6                           918  
000004C6  7600                     919      MOVE.L #0,D3                                ; read the 2 digit byte count -> D3
000004C8                           920m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000004C8  1E3C 0002                921m     MOVE.B #2,D7
000004CC                           922m     WHILE.B D7 <GT> 0 DO
000004CC                           923ms _10000000
000004CC  BE38 0000                924ms     CMP.B   0,D7
000004D0  6F00 0064                925ms     BLE _10000001
000004D4  E98B                     926m         LSL.L #4,D3                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000004D6                           927mm         DOWNLOAD D5
000004D6                           928mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                           929mm 
000004D6  1A39 00C00003            930mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004DC  0805 0000                931mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004E0  6700 0010                932mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
000004E4                           933mm  
000004E4                           934mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004E4                 TRUE      935mmm     IFEQ DEBUG
000004E4  1A39 00C00007            936mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000004EA                           937mmm     ENDC
000004EA                 FALSE     938mmm     IFNE DEBUG
000004EA                           939mmm     ENDC
000004EA                           940mmm      
000004EA  BA3C 001B                941mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004EE  6700 FB18                942mmm     BEQ START
000004F2                           943mmm     ENDM
000004F2                           944mm CONTINUE_51
000004F2  1A39 00C00013            945mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000004F8  0805 0000                946mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004FC  67D8                     947mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
000004FE                           948mm     
000004FE  1A39 00C00017            949mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000504  13C5 00E00001            950mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000050A                           951mm     
0000050A                           952mm     ENDM
0000050A                           953mm         PRINT_CHAR D5,D6
0000050A                           954mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      955mm     IFEQ DEBUG
0000050A  1C39 00C00003            956mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000510  0806 0002                957mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000514  67F4                     958mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00000516  13C5 00C00007            959mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000051C                           960mm     ENDC
0000051C                           961mm     
0000051C                 FALSE     962mm     IFNE DEBUG
0000051C                           963mm     ENDC
0000051C                           964mm 
0000051C                           965mm     ENDM
0000051C                           966mm         HEX2BIN D5,D5,A4
0000051C  49F9 00000F8C            967mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000522  0405 0030                968mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000526  CABC 000000FF            969mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
0000052C  1A34 5000                970mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000530                           971mm     ENDM
00000530  8605                     972m         OR.B D5,D3
00000532  5307                     973m         SUB.B #1,D7
00000534                           974m     ENDW
00000534  6096                     975ms     BRA _10000000
00000536                           976ms _10000001
00000536                           977m     
00000536  7A00                     978m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000538  1A03                     979m     MOVE.B D3,D5
0000053A  D483                     980m     ADD.L D3,D2
0000053C                           981m 
0000053C                           982m     ENDM
0000053C                           983  
0000053C                           984      IF.B D1 <EQ> #'0' THEN.L                    ; header, just ignore it
0000053C  B23C 0030                985s     CMP.B   #'0',D1
00000540  6600 0032                986s     BNE.L   _00000002
00000544                           987m         PRINT_CRLF D5
00000544                           988mm     PRINT_CHAR #13,D5                           ; CR
00000544                           989mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                 TRUE      990mm     IFEQ DEBUG
00000544  1A39 00C00003            991mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000054A  0805 0002                992mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000054E  67F4                     993mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
00000550  13FC 000D 00C00007       994mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000558                           995mm     ENDC
00000558                           996mm     
00000558                 FALSE     997mm     IFNE DEBUG
00000558                           998mm     ENDC
00000558                           999mm 
00000558                          1000mm     ENDM
00000558                          1001mm     PRINT_CHAR #10,D5                           ; LF
00000558                          1002mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1003mm     IFEQ DEBUG
00000558  1A39 00C00003           1004mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000055E  0805 0002               1005mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000562  67F4                    1006mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
00000564  13FC 000A 00C00007      1007mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000056C                          1008mm     ENDC
0000056C                          1009mm     
0000056C                 FALSE    1010mm     IFNE DEBUG
0000056C                          1011mm     ENDC
0000056C                          1012mm 
0000056C                          1013mm     ENDM
0000056C                          1014m     ENDM
0000056C  6000 FEC0               1015          BRA WAIT_FOR_SRECORD
00000570                          1016      ELSE
00000570  6000 0408               1017s     BRA _00000003
00000574                          1018s _00000002
00000574                          1019          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00000574  B23C 0031               1020s     CMP.B   #'1',D1
00000578  6708                    1021s     BEQ.S   _00000004
0000057A  B23C 0032               1022s     CMP.B   #'2',D1
0000057E  6600 0200               1023s     BNE.L   _00000005
00000582                          1024s _00000004
00000582  5783                    1025              SUB.L #3,D3                         ; subtract three bytes for 16 bit address and 1 byte checksum
00000584                          1026      
00000584  7800                    1027              MOVE.L #0,D4                        ; read two bytes of address
00000586                          1028m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
00000586  1E3C 0002               1029m     MOVE.B #2,D7
0000058A                          1030m     WHILE.B D7 <GT> 0 DO
0000058A                          1031ms _10000002
0000058A  BE38 0000               1032ms     CMP.B   0,D7
0000058E  6F00 0064               1033ms     BLE _10000003
00000592  E98C                    1034m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000594                          1035mm         DOWNLOAD D5
00000594                          1036mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                          1037mm 
00000594  1A39 00C00003           1038mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000059A  0805 0000               1039mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000059E  6700 0010               1040mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
000005A2                          1041mm  
000005A2                          1042mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000005A2                 TRUE     1043mmm     IFEQ DEBUG
000005A2  1A39 00C00007           1044mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000005A8                          1045mmm     ENDC
000005A8                 FALSE    1046mmm     IFNE DEBUG
000005A8                          1047mmm     ENDC
000005A8                          1048mmm      
000005A8  BA3C 001B               1049mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005AC  6700 FA5A               1050mmm     BEQ START
000005B0                          1051mmm     ENDM
000005B0                          1052mm CONTINUE_59
000005B0  1A39 00C00013           1053mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000005B6  0805 0000               1054mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000005BA  67D8                    1055mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
000005BC                          1056mm     
000005BC  1A39 00C00017           1057mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000005C2  13C5 00E00001           1058mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000005C8                          1059mm     
000005C8                          1060mm     ENDM
000005C8                          1061mm         PRINT_CHAR D5,D6
000005C8                          1062mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005C8                 TRUE     1063mm     IFEQ DEBUG
000005C8  1C39 00C00003           1064mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005CE  0806 0002               1065mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005D2  67F4                    1066mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
000005D4  13C5 00C00007           1067mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005DA                          1068mm     ENDC
000005DA                          1069mm     
000005DA                 FALSE    1070mm     IFNE DEBUG
000005DA                          1071mm     ENDC
000005DA                          1072mm 
000005DA                          1073mm     ENDM
000005DA                          1074mm         HEX2BIN D5,D5,A4
000005DA  49F9 00000F8C           1075mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000005E0  0405 0030               1076mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005E4  CABC 000000FF           1077mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000005EA  1A34 5000               1078mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000005EE                          1079mm     ENDM
000005EE  8805                    1080m         OR.B D5,D4
000005F0  5307                    1081m         SUB.B #1,D7
000005F2                          1082m     ENDW
000005F2  6096                    1083ms     BRA _10000002
000005F4                          1084ms _10000003
000005F4                          1085m     
000005F4  7A00                    1086m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005F6  1A04                    1087m     MOVE.B D4,D5
000005F8  D484                    1088m     ADD.L D4,D2
000005FA                          1089m 
000005FA                          1090m     ENDM
000005FA                          1091m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
000005FA  1E3C 0002               1092m     MOVE.B #2,D7
000005FE                          1093m     WHILE.B D7 <GT> 0 DO
000005FE                          1094ms _10000004
000005FE  BE38 0000               1095ms     CMP.B   0,D7
00000602  6F00 0064               1096ms     BLE _10000005
00000606  E98C                    1097m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000608                          1098mm         DOWNLOAD D5
00000608                          1099mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1100mm 
00000608  1A39 00C00003           1101mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000060E  0805 0000               1102mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000612  6700 0010               1103mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
00000616                          1104mm  
00000616                          1105mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000616                 TRUE     1106mmm     IFEQ DEBUG
00000616  1A39 00C00007           1107mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000061C                          1108mmm     ENDC
0000061C                 FALSE    1109mmm     IFNE DEBUG
0000061C                          1110mmm     ENDC
0000061C                          1111mmm      
0000061C  BA3C 001B               1112mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000620  6700 F9E6               1113mmm     BEQ START
00000624                          1114mmm     ENDM
00000624                          1115mm CONTINUE_64
00000624  1A39 00C00013           1116mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000062A  0805 0000               1117mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000062E  67D8                    1118mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000630                          1119mm     
00000630  1A39 00C00017           1120mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000636  13C5 00E00001           1121mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000063C                          1122mm     
0000063C                          1123mm     ENDM
0000063C                          1124mm         PRINT_CHAR D5,D6
0000063C                          1125mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063C                 TRUE     1126mm     IFEQ DEBUG
0000063C  1C39 00C00003           1127mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000642  0806 0002               1128mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000646  67F4                    1129mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
00000648  13C5 00C00007           1130mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000064E                          1131mm     ENDC
0000064E                          1132mm     
0000064E                 FALSE    1133mm     IFNE DEBUG
0000064E                          1134mm     ENDC
0000064E                          1135mm 
0000064E                          1136mm     ENDM
0000064E                          1137mm         HEX2BIN D5,D5,A4
0000064E  49F9 00000F8C           1138mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000654  0405 0030               1139mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000658  CABC 000000FF           1140mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
0000065E  1A34 5000               1141mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000662                          1142mm     ENDM
00000662  8805                    1143m         OR.B D5,D4
00000664  5307                    1144m         SUB.B #1,D7
00000666                          1145m     ENDW
00000666  6096                    1146ms     BRA _10000004
00000668                          1147ms _10000005
00000668                          1148m     
00000668  7A00                    1149m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000066A  1A04                    1150m     MOVE.B D4,D5
0000066C  D484                    1151m     ADD.L D4,D2
0000066E                          1152m 
0000066E                          1153m     ENDM
0000066E                          1154              
0000066E                          1155              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
0000066E  B23C 0032               1156s     CMP.B   #'2',D1
00000672  6600 0078               1157s     BNE.L   _00000006
00000676  5383                    1158                  SUB.L #1,D3                     ; subtract an extra bytes for 24 bit address    
00000678                          1159m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00000678  1E3C 0002               1160m     MOVE.B #2,D7
0000067C                          1161m     WHILE.B D7 <GT> 0 DO
0000067C                          1162ms _10000006
0000067C  BE38 0000               1163ms     CMP.B   0,D7
00000680  6F00 0064               1164ms     BLE _10000007
00000684  E98C                    1165m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000686                          1166mm         DOWNLOAD D5
00000686                          1167mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000686                          1168mm 
00000686  1A39 00C00003           1169mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000068C  0805 0000               1170mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000690  6700 0010               1171mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
00000694                          1172mm  
00000694                          1173mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000694                 TRUE     1174mmm     IFEQ DEBUG
00000694  1A39 00C00007           1175mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000069A                          1176mmm     ENDC
0000069A                 FALSE    1177mmm     IFNE DEBUG
0000069A                          1178mmm     ENDC
0000069A                          1179mmm      
0000069A  BA3C 001B               1180mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000069E  6700 F968               1181mmm     BEQ START
000006A2                          1182mmm     ENDM
000006A2                          1183mm CONTINUE_69
000006A2  1A39 00C00013           1184mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000006A8  0805 0000               1185mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000006AC  67D8                    1186mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
000006AE                          1187mm     
000006AE  1A39 00C00017           1188mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000006B4  13C5 00E00001           1189mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000006BA                          1190mm     
000006BA                          1191mm     ENDM
000006BA                          1192mm         PRINT_CHAR D5,D6
000006BA                          1193mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006BA                 TRUE     1194mm     IFEQ DEBUG
000006BA  1C39 00C00003           1195mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006C0  0806 0002               1196mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006C4  67F4                    1197mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
000006C6  13C5 00C00007           1198mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006CC                          1199mm     ENDC
000006CC                          1200mm     
000006CC                 FALSE    1201mm     IFNE DEBUG
000006CC                          1202mm     ENDC
000006CC                          1203mm 
000006CC                          1204mm     ENDM
000006CC                          1205mm         HEX2BIN D5,D5,A4
000006CC  49F9 00000F8C           1206mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000006D2  0405 0030               1207mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006D6  CABC 000000FF           1208mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000006DC  1A34 5000               1209mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000006E0                          1210mm     ENDM
000006E0  8805                    1211m         OR.B D5,D4
000006E2  5307                    1212m         SUB.B #1,D7
000006E4                          1213m     ENDW
000006E4  6096                    1214ms     BRA _10000006
000006E6                          1215ms _10000007
000006E6                          1216m     
000006E6  7A00                    1217m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006E8  1A04                    1218m     MOVE.B D4,D5
000006EA  D484                    1219m     ADD.L D4,D2
000006EC                          1220m 
000006EC                          1221m     ENDM
000006EC                          1222              ENDI
000006EC                          1223s _00000006
000006EC                          1224              
000006EC  2444                    1225              MOVE.L D4,A2                        ; put the address in an address register
000006EE  D5C9                    1226              ADD.L A1,A2                         ; add in the offset
000006F0                          1227  
000006F0                          1228              WHILE.L D3 <GT> #0 DO               ; read the data bytes                
000006F0                          1229s _10000008
000006F0  B6BC 00000000           1230s     CMP.L   #0,D3
000006F6  6F00 0080               1231s     BLE _10000009
000006FA  7200                    1232                  MOVE.L #0,D1                    ; D1 holds the byte
000006FC                          1233m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
000006FC  1E3C 0002               1234m     MOVE.B #2,D7
00000700                          1235m     WHILE.B D7 <GT> 0 DO
00000700                          1236ms _1000000A
00000700  BE38 0000               1237ms     CMP.B   0,D7
00000704  6F00 0064               1238ms     BLE _1000000B
00000708  E989                    1239m         LSL.L #4,D1                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000070A                          1240mm         DOWNLOAD D5
0000070A                          1241mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070A                          1242mm 
0000070A  1A39 00C00003           1243mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000710  0805 0000               1244mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000714  6700 0010               1245mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000718                          1246mm  
00000718                          1247mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000718                 TRUE     1248mmm     IFEQ DEBUG
00000718  1A39 00C00007           1249mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000071E                          1250mmm     ENDC
0000071E                 FALSE    1251mmm     IFNE DEBUG
0000071E                          1252mmm     ENDC
0000071E                          1253mmm      
0000071E  BA3C 001B               1254mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000722  6700 F8E4               1255mmm     BEQ START
00000726                          1256mmm     ENDM
00000726                          1257mm CONTINUE_74
00000726  1A39 00C00013           1258mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000072C  0805 0000               1259mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000730  67D8                    1260mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
00000732                          1261mm     
00000732  1A39 00C00017           1262mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
00000738  13C5 00E00001           1263mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
0000073E                          1264mm     
0000073E                          1265mm     ENDM
0000073E                          1266mm         PRINT_CHAR D5,D6
0000073E                          1267mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000073E                 TRUE     1268mm     IFEQ DEBUG
0000073E  1C39 00C00003           1269mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000744  0806 0002               1270mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000748  67F4                    1271mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
0000074A  13C5 00C00007           1272mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000750                          1273mm     ENDC
00000750                          1274mm     
00000750                 FALSE    1275mm     IFNE DEBUG
00000750                          1276mm     ENDC
00000750                          1277mm 
00000750                          1278mm     ENDM
00000750                          1279mm         HEX2BIN D5,D5,A4
00000750  49F9 00000F8C           1280mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000756  0405 0030               1281mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000075A  CABC 000000FF           1282mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000760  1A34 5000               1283mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000764                          1284mm     ENDM
00000764  8205                    1285m         OR.B D5,D1
00000766  5307                    1286m         SUB.B #1,D7
00000768                          1287m     ENDW
00000768  6096                    1288ms     BRA _1000000A
0000076A                          1289ms _1000000B
0000076A                          1290m     
0000076A  7A00                    1291m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000076C  1A01                    1292m     MOVE.B D1,D5
0000076E  D481                    1293m     ADD.L D1,D2
00000770                          1294m 
00000770                          1295m     ENDM
00000770                          1296                          
00000770  14C1                    1297                  MOVE.B D1,(A2)+                 ; store it!
00000772                          1298  
00000772  5383                    1299                  SUB.L #1,D3                     ; 1 less byte to go
00000774                          1300              ENDW
00000774  6000 FF7A               1301s     BRA _10000008
00000778                          1302s _10000009
00000778                          1303          
00000778  47F8 042E               1304              LEA WAIT_FOR_SRECORD,A3             ; next place to go
0000077C                          1305          ELSE
0000077C  6000 01FC               1306s     BRA _00000007
00000780                          1307s _00000005
00000780                          1308              IF.B D1 <EQ> #'8' THEN.L            ; termination record, exit
00000780  B23C 0038               1309s     CMP.B   #'8',D1
00000784  6600 016C               1310s     BNE.L   _00000008
00000788  7800                    1311                  MOVE.L #0,D4                    ; read the 24 bit start address
0000078A                          1312m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0000078A  1E3C 0002               1313m     MOVE.B #2,D7
0000078E                          1314m     WHILE.B D7 <GT> 0 DO
0000078E                          1315ms _1000000C
0000078E  BE38 0000               1316ms     CMP.B   0,D7
00000792  6F00 0064               1317ms     BLE _1000000D
00000796  E98C                    1318m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000798                          1319mm         DOWNLOAD D5
00000798                          1320mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                          1321mm 
00000798  1A39 00C00003           1322mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000079E  0805 0000               1323mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007A2  6700 0010               1324mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
000007A6                          1325mm  
000007A6                          1326mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000007A6                 TRUE     1327mmm     IFEQ DEBUG
000007A6  1A39 00C00007           1328mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
000007AC                          1329mmm     ENDC
000007AC                 FALSE    1330mmm     IFNE DEBUG
000007AC                          1331mmm     ENDC
000007AC                          1332mmm      
000007AC  BA3C 001B               1333mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000007B0  6700 F856               1334mmm     BEQ START
000007B4                          1335mmm     ENDM
000007B4                          1336mm CONTINUE_79
000007B4  1A39 00C00013           1337mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000007BA  0805 0000               1338mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000007BE  67D8                    1339mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
000007C0                          1340mm     
000007C0  1A39 00C00017           1341mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000007C6  13C5 00E00001           1342mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000007CC                          1343mm     
000007CC                          1344mm     ENDM
000007CC                          1345mm         PRINT_CHAR D5,D6
000007CC                          1346mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CC                 TRUE     1347mm     IFEQ DEBUG
000007CC  1C39 00C00003           1348mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007D2  0806 0002               1349mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007D6  67F4                    1350mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
000007D8  13C5 00C00007           1351mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007DE                          1352mm     ENDC
000007DE                          1353mm     
000007DE                 FALSE    1354mm     IFNE DEBUG
000007DE                          1355mm     ENDC
000007DE                          1356mm 
000007DE                          1357mm     ENDM
000007DE                          1358mm         HEX2BIN D5,D5,A4
000007DE  49F9 00000F8C           1359mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000007E4  0405 0030               1360mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007E8  CABC 000000FF           1361mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000007EE  1A34 5000               1362mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000007F2                          1363mm     ENDM
000007F2  8805                    1364m         OR.B D5,D4
000007F4  5307                    1365m         SUB.B #1,D7
000007F6                          1366m     ENDW
000007F6  6096                    1367ms     BRA _1000000C
000007F8                          1368ms _1000000D
000007F8                          1369m     
000007F8  7A00                    1370m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007FA  1A04                    1371m     MOVE.B D4,D5
000007FC  D484                    1372m     ADD.L D4,D2
000007FE                          1373m 
000007FE                          1374m     ENDM
000007FE                          1375m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
000007FE  1E3C 0002               1376m     MOVE.B #2,D7
00000802                          1377m     WHILE.B D7 <GT> 0 DO
00000802                          1378ms _1000000E
00000802  BE38 0000               1379ms     CMP.B   0,D7
00000806  6F00 0064               1380ms     BLE _1000000F
0000080A  E98C                    1381m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000080C                          1382mm         DOWNLOAD D5
0000080C                          1383mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                          1384mm 
0000080C  1A39 00C00003           1385mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000812  0805 0000               1386mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000816  6700 0010               1387mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
0000081A                          1388mm  
0000081A                          1389mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000081A                 TRUE     1390mmm     IFEQ DEBUG
0000081A  1A39 00C00007           1391mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000820                          1392mmm     ENDC
00000820                 FALSE    1393mmm     IFNE DEBUG
00000820                          1394mmm     ENDC
00000820                          1395mmm      
00000820  BA3C 001B               1396mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000824  6700 F7E2               1397mmm     BEQ START
00000828                          1398mmm     ENDM
00000828                          1399mm CONTINUE_84
00000828  1A39 00C00013           1400mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
0000082E  0805 0000               1401mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000832  67D8                    1402mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
00000834                          1403mm     
00000834  1A39 00C00017           1404mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
0000083A  13C5 00E00001           1405mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
00000840                          1406mm     
00000840                          1407mm     ENDM
00000840                          1408mm         PRINT_CHAR D5,D6
00000840                          1409mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                 TRUE     1410mm     IFEQ DEBUG
00000840  1C39 00C00003           1411mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000846  0806 0002               1412mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000084A  67F4                    1413mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
0000084C  13C5 00C00007           1414mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000852                          1415mm     ENDC
00000852                          1416mm     
00000852                 FALSE    1417mm     IFNE DEBUG
00000852                          1418mm     ENDC
00000852                          1419mm 
00000852                          1420mm     ENDM
00000852                          1421mm         HEX2BIN D5,D5,A4
00000852  49F9 00000F8C           1422mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000858  0405 0030               1423mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000085C  CABC 000000FF           1424mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
00000862  1A34 5000               1425mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
00000866                          1426mm     ENDM
00000866  8805                    1427m         OR.B D5,D4
00000868  5307                    1428m         SUB.B #1,D7
0000086A                          1429m     ENDW
0000086A  6096                    1430ms     BRA _1000000E
0000086C                          1431ms _1000000F
0000086C                          1432m     
0000086C  7A00                    1433m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000086E  1A04                    1434m     MOVE.B D4,D5
00000870  D484                    1435m     ADD.L D4,D2
00000872                          1436m 
00000872                          1437m     ENDM
00000872                          1438m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00000872  1E3C 0002               1439m     MOVE.B #2,D7
00000876                          1440m     WHILE.B D7 <GT> 0 DO
00000876                          1441ms _10000010
00000876  BE38 0000               1442ms     CMP.B   0,D7
0000087A  6F00 0064               1443ms     BLE _10000011
0000087E  E98C                    1444m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000880                          1445mm         DOWNLOAD D5
00000880                          1446mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000880                          1447mm 
00000880  1A39 00C00003           1448mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000886  0805 0000               1449mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000088A  6700 0010               1450mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
0000088E                          1451mm  
0000088E                          1452mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000088E                 TRUE     1453mmm     IFEQ DEBUG
0000088E  1A39 00C00007           1454mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
00000894                          1455mmm     ENDC
00000894                 FALSE    1456mmm     IFNE DEBUG
00000894                          1457mmm     ENDC
00000894                          1458mmm      
00000894  BA3C 001B               1459mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000898  6700 F76E               1460mmm     BEQ START
0000089C                          1461mmm     ENDM
0000089C                          1462mm CONTINUE_89
0000089C  1A39 00C00013           1463mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000008A2  0805 0000               1464mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000008A6  67D8                    1465mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
000008A8                          1466mm     
000008A8  1A39 00C00017           1467mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000008AE  13C5 00E00001           1468mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000008B4                          1469mm     
000008B4                          1470mm     ENDM
000008B4                          1471mm         PRINT_CHAR D5,D6
000008B4                          1472mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B4                 TRUE     1473mm     IFEQ DEBUG
000008B4  1C39 00C00003           1474mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008BA  0806 0002               1475mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008BE  67F4                    1476mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
000008C0  13C5 00C00007           1477mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008C6                          1478mm     ENDC
000008C6                          1479mm     
000008C6                 FALSE    1480mm     IFNE DEBUG
000008C6                          1481mm     ENDC
000008C6                          1482mm 
000008C6                          1483mm     ENDM
000008C6                          1484mm         HEX2BIN D5,D5,A4
000008C6  49F9 00000F8C           1485mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000008CC  0405 0030               1486mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D0  CABC 000000FF           1487mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000008D6  1A34 5000               1488mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000008DA                          1489mm     ENDM
000008DA  8805                    1490m         OR.B D5,D4
000008DC  5307                    1491m         SUB.B #1,D7
000008DE                          1492m     ENDW
000008DE  6096                    1493ms     BRA _10000010
000008E0                          1494ms _10000011
000008E0                          1495m     
000008E0  7A00                    1496m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008E2  1A04                    1497m     MOVE.B D4,D5
000008E4  D484                    1498m     ADD.L D4,D2
000008E6                          1499m 
000008E6                          1500m     ENDM
000008E6                          1501                    
000008E6  2044                    1502                  MOVE.L D4,A0                    ; start address -> A0
000008E8                          1503                  
000008E8  47F9 00000AC4           1504                  LEA DOWNLOAD_DONE,A3            ; next place to go
000008EE                          1505              ELSE
000008EE  6000 008A               1506s     BRA _00000009
000008F2                          1507s _00000008
000008F2                          1508m                 PRINT_CRLF D5
000008F2                          1509mm     PRINT_CHAR #13,D5                           ; CR
000008F2                          1510mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F2                 TRUE     1511mm     IFEQ DEBUG
000008F2  1A39 00C00003           1512mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008F8  0805 0002               1513mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008FC  67F4                    1514mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
000008FE  13FC 000D 00C00007      1515mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000906                          1516mm     ENDC
00000906                          1517mm     
00000906                 FALSE    1518mm     IFNE DEBUG
00000906                          1519mm     ENDC
00000906                          1520mm 
00000906                          1521mm     ENDM
00000906                          1522mm     PRINT_CHAR #10,D5                           ; LF
00000906                          1523mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000906                 TRUE     1524mm     IFEQ DEBUG
00000906  1A39 00C00003           1525mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000090C  0805 0002               1526mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000910  67F4                    1527mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00000912  13FC 000A 00C00007      1528mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000091A                          1529mm     ENDC
0000091A                          1530mm     
0000091A                 FALSE    1531mm     IFNE DEBUG
0000091A                          1532mm     ENDC
0000091A                          1533mm 
0000091A                          1534mm     ENDM
0000091A                          1535m     ENDM
0000091A                          1536              
0000091A  49F9 00000F41           1537                  LEA UNREC,A4                    ; warn for unrecognised type
00000920                          1538m                 PRINT_STR A4,D5
00000920                          1539m LOOP_96
00000920  0C14 0000               1540m     CMP.B #0,(A4)                               ; 0 -> DONE
00000924  6700 0016               1541m     BEQ EXIT_96
00000928                          1542mm     PRINT_CHAR (A4)+,D5
00000928                          1543mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000928                 TRUE     1544mm     IFEQ DEBUG
00000928  1A39 00C00003           1545mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000092E  0805 0002               1546mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000932  67F4                    1547mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
00000934  13DC 00C00007           1548mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000093A                          1549mm     ENDC
0000093A                          1550mm     
0000093A                 FALSE    1551mm     IFNE DEBUG
0000093A                          1552mm     ENDC
0000093A                          1553mm 
0000093A                          1554mm     ENDM
0000093A  60E4                    1555m     BRA LOOP_96
0000093C                          1556m EXIT_96
0000093C                          1557m     ENDM
0000093C                          1558m                 PRINT_CHAR D1,D5
0000093C                          1559m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000093C                 TRUE     1560m     IFEQ DEBUG
0000093C  1A39 00C00003           1561m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000942  0805 0002               1562m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000946  67F4                    1563m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
00000948  13C1 00C00007           1564m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000094E                          1565m     ENDC
0000094E                          1566m     
0000094E                 FALSE    1567m     IFNE DEBUG
0000094E                          1568m     ENDC
0000094E                          1569m 
0000094E                          1570m     ENDM
0000094E                          1571m                 PRINT_CRLF D5
0000094E                          1572mm     PRINT_CHAR #13,D5                           ; CR
0000094E                          1573mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094E                 TRUE     1574mm     IFEQ DEBUG
0000094E  1A39 00C00003           1575mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000954  0805 0002               1576mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000958  67F4                    1577mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
0000095A  13FC 000D 00C00007      1578mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000962                          1579mm     ENDC
00000962                          1580mm     
00000962                 FALSE    1581mm     IFNE DEBUG
00000962                          1582mm     ENDC
00000962                          1583mm 
00000962                          1584mm     ENDM
00000962                          1585mm     PRINT_CHAR #10,D5                           ; LF
00000962                          1586mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1587mm     IFEQ DEBUG
00000962  1A39 00C00003           1588mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000968  0805 0002               1589mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1590mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0000096E  13FC 000A 00C00007      1591mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000976                          1592mm     ENDC
00000976                          1593mm     
00000976                 FALSE    1594mm     IFNE DEBUG
00000976                          1595mm     ENDC
00000976                          1596mm 
00000976                          1597mm     ENDM
00000976                          1598m     ENDM
00000976                          1599              
00000976  6000 FAB6               1600                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0000097A                          1601              ENDI
0000097A                          1602s _00000009
0000097A                          1603          ENDI
0000097A                          1604s _00000007
0000097A                          1605      ENDI
0000097A                          1606s _00000003
0000097A                          1607      
0000097A  7800                    1608      MOVE.L #0,D4                                ; read the checksum from the data stream add to our checksum: should make it FF
0000097C                          1609m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0000097C  1E3C 0002               1610m     MOVE.B #2,D7
00000980                          1611m     WHILE.B D7 <GT> 0 DO
00000980                          1612ms _10000012
00000980  BE38 0000               1613ms     CMP.B   0,D7
00000984  6F00 0064               1614ms     BLE _10000013
00000988  E98C                    1615m         LSL.L #4,D4                         ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000098A                          1616mm         DOWNLOAD D5
0000098A                          1617mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098A                          1618mm 
0000098A  1A39 00C00003           1619mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000990  0805 0000               1620mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000994  6700 0010               1621mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
00000998                          1622mm  
00000998                          1623mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000998                 TRUE     1624mmm     IFEQ DEBUG
00000998  1A39 00C00007           1625mmm         MOVE.B DUART_RXA,D5                     ; GOT A CHARACTER, READ IT
0000099E                          1626mmm     ENDC
0000099E                 FALSE    1627mmm     IFNE DEBUG
0000099E                          1628mmm     ENDC
0000099E                          1629mmm      
0000099E  BA3C 001B               1630mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000009A2  6700 F664               1631mmm     BEQ START
000009A6                          1632mmm     ENDM
000009A6                          1633mm CONTINUE_103
000009A6  1A39 00C00013           1634mm     MOVE.B DUART_SRB,D5                         ; READ DOWNLOAD STATUS REGISTER
000009AC  0805 0000               1635mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000009B0  67D8                    1636mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
000009B2                          1637mm     
000009B2  1A39 00C00017           1638mm     MOVE.B DUART_RXB,D5                         ; GOT A CHARACTER, READ IT
000009B8  13C5 00E00001           1639mm     MOVE.B D5,DISPLAY                           ; ECHO TO THE DISPLAY
000009BE                          1640mm     
000009BE                          1641mm     ENDM
000009BE                          1642mm         PRINT_CHAR D5,D6
000009BE                          1643mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BE                 TRUE     1644mm     IFEQ DEBUG
000009BE  1C39 00C00003           1645mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000009C4  0806 0002               1646mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000009C8  67F4                    1647mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
000009CA  13C5 00C00007           1648mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009D0                          1649mm     ENDC
000009D0                          1650mm     
000009D0                 FALSE    1651mm     IFNE DEBUG
000009D0                          1652mm     ENDC
000009D0                          1653mm 
000009D0                          1654mm     ENDM
000009D0                          1655mm         HEX2BIN D5,D5,A4
000009D0  49F9 00000F8C           1656mm     LEA HEX2BIN_LUT,A4                          ; LOAD THE LOOKUP TABLE
000009D6  0405 0030               1657mm     SUB.B #'0',D5                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009DA  CABC 000000FF           1658mm     AND.L #$FF,D5                               ; IGNORE THE TOP 3 BYTES
000009E0  1A34 5000               1659mm     MOVE.B 0(A4,D5),D5                          ; USE THAT AS AN INDEX INTO THE LUT      
000009E4                          1660mm     ENDM
000009E4  8805                    1661m         OR.B D5,D4
000009E6  5307                    1662m         SUB.B #1,D7
000009E8                          1663m     ENDW
000009E8  6096                    1664ms     BRA _10000012
000009EA                          1665ms _10000013
000009EA                          1666m     
000009EA  7A00                    1667m     MOVE.L #0,D5                            ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009EC  1A04                    1668m     MOVE.B D4,D5
000009EE  D484                    1669m     ADD.L D4,D2
000009F0                          1670m 
000009F0                          1671m     ENDM
000009F0                          1672m     PRINT_CRLF D5
000009F0                          1673mm     PRINT_CHAR #13,D5                           ; CR
000009F0                          1674mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F0                 TRUE     1675mm     IFEQ DEBUG
000009F0  1A39 00C00003           1676mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009F6  0805 0002               1677mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009FA  67F4                    1678mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
000009FC  13FC 000D 00C00007      1679mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A04                          1680mm     ENDC
00000A04                          1681mm     
00000A04                 FALSE    1682mm     IFNE DEBUG
00000A04                          1683mm     ENDC
00000A04                          1684mm 
00000A04                          1685mm     ENDM
00000A04                          1686mm     PRINT_CHAR #10,D5                           ; LF
00000A04                          1687mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A04                 TRUE     1688mm     IFEQ DEBUG
00000A04  1A39 00C00003           1689mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A0A  0805 0002               1690mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A0E  67F4                    1691mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A10  13FC 000A 00C00007      1692mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A18                          1693mm     ENDC
00000A18                          1694mm     
00000A18                 FALSE    1695mm     IFNE DEBUG
00000A18                          1696mm     ENDC
00000A18                          1697mm 
00000A18                          1698mm     ENDM
00000A18                          1699m     ENDM
00000A18                          1700          
00000A18                          1701      IF.B D2 <NE> #$FF THEN.L
00000A18  B43C 00FF               1702s     CMP.B   #$FF,D2
00000A1C  6700 00A4               1703s     BEQ.L   _0000000A
00000A20  49F9 00000F58           1704          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
00000A26                          1705m         PRINT_STR A4,D5
00000A26                          1706m LOOP_110
00000A26  0C14 0000               1707m     CMP.B #0,(A4)                               ; 0 -> DONE
00000A2A  6700 0016               1708m     BEQ EXIT_110
00000A2E                          1709mm     PRINT_CHAR (A4)+,D5
00000A2E                          1710mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2E                 TRUE     1711mm     IFEQ DEBUG
00000A2E  1A39 00C00003           1712mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A34  0805 0002               1713mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A38  67F4                    1714mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A3A  13DC 00C00007           1715mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A40                          1716mm     ENDC
00000A40                          1717mm     
00000A40                 FALSE    1718mm     IFNE DEBUG
00000A40                          1719mm     ENDC
00000A40                          1720mm 
00000A40                          1721mm     ENDM
00000A40  60E4                    1722m     BRA LOOP_110
00000A42                          1723m EXIT_110
00000A42                          1724m     ENDM
00000A42                          1725m         PRINT_REG D0,D5,D2,D6,A4
00000A42                          1726mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000A42                          1727mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A42                 TRUE     1728mm     IFEQ DEBUG
00000A42  1A39 00C00003           1729mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A48  0805 0002               1730mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A4C  67F4                    1731mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000A4E  13FC 0030 00C00007      1732mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A56                          1733mm     ENDC
00000A56                          1734mm     
00000A56                 FALSE    1735mm     IFNE DEBUG
00000A56                          1736mm     ENDC
00000A56                          1737mm 
00000A56                          1738mm     ENDM
00000A56                          1739mm     PRINT_CHAR #'x',D5
00000A56                          1740mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A56                 TRUE     1741mm     IFEQ DEBUG
00000A56  1A39 00C00003           1742mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A5C  0805 0002               1743mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A60  67F4                    1744mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000A62  13FC 0078 00C00007      1745mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000A6A                          1746mm     ENDC
00000A6A                          1747mm     
00000A6A                 FALSE    1748mm     IFNE DEBUG
00000A6A                          1749mm     ENDC
00000A6A                          1750mm 
00000A6A                          1751mm     ENDM
00000A6A  7C07                    1752m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A6C                          1753m LOOP_112
00000A6C                          1754mm     BIN2HEX D0,D2,A4
00000A6C  49F9 00000F7C           1755mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00000A72  E998                    1756mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A74  1400                    1757mm     MOVE.B D0,D2
00000A76  0282 0000000F           1758mm     ANDI.L #$F,D2
00000A7C  1434 2000               1759mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000A80                          1760mm     ENDM
00000A80                          1761mm     PRINT_CHAR D2,D5
00000A80                          1762mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1763mm     IFEQ DEBUG
00000A80  1A39 00C00003           1764mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A86  0805 0002               1765mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1766mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000A8C  13C2 00C00007           1767mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A92                          1768mm     ENDC
00000A92                          1769mm     
00000A92                 FALSE    1770mm     IFNE DEBUG
00000A92                          1771mm     ENDC
00000A92                          1772mm 
00000A92                          1773mm     ENDM
00000A92  57CE FFD8               1774m     DBEQ D6,LOOP_112
00000A96                          1775m     ENDM
00000A96                          1776m         PRINT_CRLF D5
00000A96                          1777mm     PRINT_CHAR #13,D5                           ; CR
00000A96                          1778mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A96                 TRUE     1779mm     IFEQ DEBUG
00000A96  1A39 00C00003           1780mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A9C  0805 0002               1781mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AA0  67F4                    1782mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AA2  13FC 000D 00C00007      1783mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000AAA                          1784mm     ENDC
00000AAA                          1785mm     
00000AAA                 FALSE    1786mm     IFNE DEBUG
00000AAA                          1787mm     ENDC
00000AAA                          1788mm 
00000AAA                          1789mm     ENDM
00000AAA                          1790mm     PRINT_CHAR #10,D5                           ; LF
00000AAA                          1791mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAA                 TRUE     1792mm     IFEQ DEBUG
00000AAA  1A39 00C00003           1793mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000AB0  0805 0002               1794mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AB4  67F4                    1795mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000AB6  13FC 000A 00C00007      1796mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000ABE                          1797mm     ENDC
00000ABE                          1798mm     
00000ABE                 FALSE    1799mm     IFNE DEBUG
00000ABE                          1800mm     ENDC
00000ABE                          1801mm 
00000ABE                          1802mm     ENDM
00000ABE                          1803m     ENDM
00000ABE  6000 F6C4               1804          BRA MAIN_LOOP
00000AC2                          1805      ENDI
00000AC2                          1806s _0000000A
00000AC2                          1807      
00000AC2  4ED3                    1808      JMP (A3)
00000AC4                          1809  DOWNLOAD_DONE
00000AC4                          1810m     PRINT_REG D0,D5,D6,D2,A1                    ; print out number of Srecords read
00000AC4                          1811mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000AC4                          1812mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC4                 TRUE     1813mm     IFEQ DEBUG
00000AC4  1A39 00C00003           1814mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ACA  0805 0002               1815mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000ACE  67F4                    1816mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000AD0  13FC 0030 00C00007      1817mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AD8                          1818mm     ENDC
00000AD8                          1819mm     
00000AD8                 FALSE    1820mm     IFNE DEBUG
00000AD8                          1821mm     ENDC
00000AD8                          1822mm 
00000AD8                          1823mm     ENDM
00000AD8                          1824mm     PRINT_CHAR #'x',D5
00000AD8                          1825mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1826mm     IFEQ DEBUG
00000AD8  1A39 00C00003           1827mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000ADE  0805 0002               1828mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1829mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000AE4  13FC 0078 00C00007      1830mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000AEC                          1831mm     ENDC
00000AEC                          1832mm     
00000AEC                 FALSE    1833mm     IFNE DEBUG
00000AEC                          1834mm     ENDC
00000AEC                          1835mm 
00000AEC                          1836mm     ENDM
00000AEC  7407                    1837m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AEE                          1838m LOOP_120
00000AEE                          1839mm     BIN2HEX D0,D6,A1
00000AEE  43F9 00000F7C           1840mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000AF4  E998                    1841mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AF6  1C00                    1842mm     MOVE.B D0,D6
00000AF8  0286 0000000F           1843mm     ANDI.L #$F,D6
00000AFE  1C31 6000               1844mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000B02                          1845mm     ENDM
00000B02                          1846mm     PRINT_CHAR D6,D5
00000B02                          1847mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B02                 TRUE     1848mm     IFEQ DEBUG
00000B02  1A39 00C00003           1849mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B08  0805 0002               1850mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B0C  67F4                    1851mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B0E  13C6 00C00007           1852mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B14                          1853mm     ENDC
00000B14                          1854mm     
00000B14                 FALSE    1855mm     IFNE DEBUG
00000B14                          1856mm     ENDC
00000B14                          1857mm 
00000B14                          1858mm     ENDM
00000B14  57CA FFD8               1859m     DBEQ D2,LOOP_120
00000B18                          1860m     ENDM
00000B18  43F9 00000F1F           1861      LEA READ,A1
00000B1E                          1862m     PRINT_STR A1,D5
00000B1E                          1863m LOOP_125
00000B1E  0C11 0000               1864m     CMP.B #0,(A1)                               ; 0 -> DONE
00000B22  6700 0016               1865m     BEQ EXIT_125
00000B26                          1866mm     PRINT_CHAR (A1)+,D5
00000B26                          1867mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B26                 TRUE     1868mm     IFEQ DEBUG
00000B26  1A39 00C00003           1869mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B2C  0805 0002               1870mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B30  67F4                    1871mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B32  13D9 00C00007           1872mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B38                          1873mm     ENDC
00000B38                          1874mm     
00000B38                 FALSE    1875mm     IFNE DEBUG
00000B38                          1876mm     ENDC
00000B38                          1877mm 
00000B38                          1878mm     ENDM
00000B38  60E4                    1879m     BRA LOOP_125
00000B3A                          1880m EXIT_125
00000B3A                          1881m     ENDM
00000B3A  2E08                    1882      MOVE.L A0,D7                                ; set address accumulator to start address
00000B3C                          1883m     PRINT_REG D7,D5,D6,D2,A1                    ; print out start address
00000B3C                          1884mm     PRINT_CHAR #'0',D5                          ;0X HEADER
00000B3C                          1885mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     1886mm     IFEQ DEBUG
00000B3C  1A39 00C00003           1887mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B42  0805 0002               1888mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B46  67F4                    1889mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000B48  13FC 0030 00C00007      1890mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B50                          1891mm     ENDC
00000B50                          1892mm     
00000B50                 FALSE    1893mm     IFNE DEBUG
00000B50                          1894mm     ENDC
00000B50                          1895mm 
00000B50                          1896mm     ENDM
00000B50                          1897mm     PRINT_CHAR #'x',D5
00000B50                          1898mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B50                 TRUE     1899mm     IFEQ DEBUG
00000B50  1A39 00C00003           1900mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B56  0805 0002               1901mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B5A  67F4                    1902mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B5C  13FC 0078 00C00007      1903mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B64                          1904mm     ENDC
00000B64                          1905mm     
00000B64                 FALSE    1906mm     IFNE DEBUG
00000B64                          1907mm     ENDC
00000B64                          1908mm 
00000B64                          1909mm     ENDM
00000B64  7407                    1910m     MOVE.L #7,D2                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B66                          1911m LOOP_127
00000B66                          1912mm     BIN2HEX D7,D6,A1
00000B66  43F9 00000F7C           1913mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000B6C  E99F                    1914mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B6E  1C07                    1915mm     MOVE.B D7,D6
00000B70  0286 0000000F           1916mm     ANDI.L #$F,D6
00000B76  1C31 6000               1917mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000B7A                          1918mm     ENDM
00000B7A                          1919mm     PRINT_CHAR D6,D5
00000B7A                          1920mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7A                 TRUE     1921mm     IFEQ DEBUG
00000B7A  1A39 00C00003           1922mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B80  0805 0002               1923mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B84  67F4                    1924mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B86  13C6 00C00007           1925mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B8C                          1926mm     ENDC
00000B8C                          1927mm     
00000B8C                 FALSE    1928mm     IFNE DEBUG
00000B8C                          1929mm     ENDC
00000B8C                          1930mm 
00000B8C                          1931mm     ENDM
00000B8C  57CA FFD8               1932m     DBEQ D2,LOOP_127
00000B90                          1933m     ENDM
00000B90                          1934m     PRINT_CRLF D5     
00000B90                          1935mm     PRINT_CHAR #13,D5                           ; CR
00000B90                          1936mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B90                 TRUE     1937mm     IFEQ DEBUG
00000B90  1A39 00C00003           1938mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000B96  0805 0002               1939mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000B9A  67F4                    1940mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B9C  13FC 000D 00C00007      1941mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BA4                          1942mm     ENDC
00000BA4                          1943mm     
00000BA4                 FALSE    1944mm     IFNE DEBUG
00000BA4                          1945mm     ENDC
00000BA4                          1946mm 
00000BA4                          1947mm     ENDM
00000BA4                          1948mm     PRINT_CHAR #10,D5                           ; LF
00000BA4                          1949mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     1950mm     IFEQ DEBUG
00000BA4  1A39 00C00003           1951mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000BAA  0805 0002               1952mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    1953mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000BB0  13FC 000A 00C00007      1954mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000BB8                          1955mm     ENDC
00000BB8                          1956mm     
00000BB8                 FALSE    1957mm     IFNE DEBUG
00000BB8                          1958mm     ENDC
00000BB8                          1959mm 
00000BB8                          1960mm     ENDM
00000BB8                          1961m     ENDM
00000BB8                          1962          
00000BB8  6000 F5CA               1963      BRA MAIN_LOOP
00000BBC                          1964      
00000BBC                          1965  G
00000BBC  2047                    1966      MOVE.L D7,A0                                ; address accumulator -> address register
00000BBE  3E3C 0000               1967      MOVE #0,D7                                  ; clear the now used address accumulator
00000BC2  4ED0                    1968      JMP (A0)                                    ; jump to it!
00000BC4                          1969      
00000BC4                          1970  Z
00000BC4  207C 00200000           1971      MOVE.L #RAM,A0                              ; address of RAM
00000BCA  7000                    1972      MOVE.L #0,D0                                ; number of bytes
00000BCC                          1973     
00000BCC                          1974      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000BCC                          1975s _10000014
00000BCC  B0BC 00040000           1976s     CMP.L   #$40000,D0
00000BD2  6E00 001A               1977s     BGT _10000015
00000BD6  2200                    1978          MOVE.L D0,D1                            ; progress update
00000BD8  E089                    1979          LSR.L #8,D1 
00000BDA  E089                    1980          LSR.L #8,D1
00000BDC  0281 0000000F           1981          ANDI.L #$F,D1
00000BE2  13C1 00E00001           1982          MOVE.B D1,DISPLAY
00000BE8                          1983  
00000BE8  20C0                    1984          MOVE.L D0,(A0)+ 
00000BEA  5880                    1985          ADD.L #4,D0
00000BEC                          1986      ENDW
00000BEC  60DE                    1987s     BRA _10000014
00000BEE                          1988s _10000015
00000BEE                          1989   
00000BEE  207C 00200000           1990      MOVE.L #RAM,A0                              ; address of RAM
00000BF4  7000                    1991      MOVE.L #0,D0                                ; number of bytes
00000BF6                          1992     
00000BF6                          1993      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000BF6                          1994s _10000016
00000BF6  B0BC 00040000           1995s     CMP.L   #$40000,D0
00000BFC  6E00 00C8               1996s     BGT _10000017
00000C00  2200                    1997          MOVE.L D0,D1                            ; progress update
00000C02  E089                    1998          LSR.L #8,D1
00000C04  E089                    1999          LSR.L #8,D1
00000C06  0281 0000000F           2000          ANDI.L #$F,D1
00000C0C  13C1 00E00001           2001          MOVE.B D1,DISPLAY
00000C12                          2002  
00000C12  2218                    2003          MOVE.L (A0)+,D1
00000C14                          2004            
00000C14                          2005          IF.L D0 <EQ> D1 THEN
00000C14  B081                    2006s     CMP.L   D1,D0
00000C16  6600 0006               2007s     BNE _0000000B
00000C1A  6000 00A4               2008              BRA OK
00000C1E                          2009          ENDI 
00000C1E                          2010s _0000000B
00000C1E                          2011            
00000C1E  43F9 00000F6A           2012          LEA RAM_ERROR,A1
00000C24                          2013m         PRINT_STR A1,D1
00000C24                          2014m LOOP_135
00000C24  0C11 0000               2015m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C28  6700 0016               2016m     BEQ EXIT_135
00000C2C                          2017mm     PRINT_CHAR (A1)+,D1
00000C2C                          2018mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2C                 TRUE     2019mm     IFEQ DEBUG
00000C2C  1239 00C00003           2020mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C32  0801 0002               2021mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C36  67F4                    2022mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C38  13D9 00C00007           2023mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C3E                          2024mm     ENDC
00000C3E                          2025mm     
00000C3E                 FALSE    2026mm     IFNE DEBUG
00000C3E                          2027mm     ENDC
00000C3E                          2028mm 
00000C3E                          2029mm     ENDM
00000C3E  60E4                    2030m     BRA LOOP_135
00000C40                          2031m EXIT_135
00000C40                          2032m     ENDM
00000C40  2208                    2033          MOVE.L A0,D1
00000C42  5981                    2034          SUB.L #4,D1
00000C44                          2035m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C44                          2036mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000C44                          2037mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C44                 TRUE     2038mm     IFEQ DEBUG
00000C44  1639 00C00003           2039mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C4A  0803 0002               2040mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C4E  67F4                    2041mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000C50  13FC 0030 00C00007      2042mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000C58                          2043mm     ENDC
00000C58                          2044mm     
00000C58                 FALSE    2045mm     IFNE DEBUG
00000C58                          2046mm     ENDC
00000C58                          2047mm 
00000C58                          2048mm     ENDM
00000C58                          2049mm     PRINT_CHAR #'x',D3
00000C58                          2050mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C58                 TRUE     2051mm     IFEQ DEBUG
00000C58  1639 00C00003           2052mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C5E  0803 0002               2053mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C62  67F4                    2054mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000C64  13FC 0078 00C00007      2055mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000C6C                          2056mm     ENDC
00000C6C                          2057mm     
00000C6C                 FALSE    2058mm     IFNE DEBUG
00000C6C                          2059mm     ENDC
00000C6C                          2060mm 
00000C6C                          2061mm     ENDM
00000C6C  7C07                    2062m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C6E                          2063m LOOP_137
00000C6E                          2064mm     BIN2HEX D1,D2,A1
00000C6E  43F9 00000F7C           2065mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000C74  E999                    2066mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C76  1401                    2067mm     MOVE.B D1,D2
00000C78  0282 0000000F           2068mm     ANDI.L #$F,D2
00000C7E  1431 2000               2069mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000C82                          2070mm     ENDM
00000C82                          2071mm     PRINT_CHAR D2,D3
00000C82                          2072mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C82                 TRUE     2073mm     IFEQ DEBUG
00000C82  1639 00C00003           2074mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C88  0803 0002               2075mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C8C  67F4                    2076mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000C8E  13C2 00C00007           2077mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000C94                          2078mm     ENDC
00000C94                          2079mm     
00000C94                 FALSE    2080mm     IFNE DEBUG
00000C94                          2081mm     ENDC
00000C94                          2082mm 
00000C94                          2083mm     ENDM
00000C94  57CE FFD8               2084m     DBEQ D6,LOOP_137
00000C98                          2085m     ENDM
00000C98                          2086m         PRINT_CRLF D3
00000C98                          2087mm     PRINT_CHAR #13,D3                           ; CR
00000C98                          2088mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C98                 TRUE     2089mm     IFEQ DEBUG
00000C98  1639 00C00003           2090mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C9E  0803 0002               2091mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CA2  67F4                    2092mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CA4  13FC 000D 00C00007      2093mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000CAC                          2094mm     ENDC
00000CAC                          2095mm     
00000CAC                 FALSE    2096mm     IFNE DEBUG
00000CAC                          2097mm     ENDC
00000CAC                          2098mm 
00000CAC                          2099mm     ENDM
00000CAC                          2100mm     PRINT_CHAR #10,D3                           ; LF
00000CAC                          2101mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAC                 TRUE     2102mm     IFEQ DEBUG
00000CAC  1639 00C00003           2103mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB2  0803 0002               2104mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB6  67F4                    2105mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000CB8  13FC 000A 00C00007      2106mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000CC0                          2107mm     ENDC
00000CC0                          2108mm     
00000CC0                 FALSE    2109mm     IFNE DEBUG
00000CC0                          2110mm     ENDC
00000CC0                          2111mm 
00000CC0                          2112mm     ENDM
00000CC0                          2113m     ENDM
00000CC0                          2114  OK    
00000CC0  5880                    2115          ADD.L #4,D0
00000CC2                          2116      ENDW
00000CC2  6000 FF32               2117s     BRA _10000016
00000CC6                          2118s _10000017
00000CC6                          2119      
00000CC6  6000 F4BC               2120      BRA MAIN_LOOP
00000CCA                          2121    
00000CCA                          2122  L
00000CCA  7A00                    2123      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000CCC                          2124  
00000CCC                          2125m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000CCC                          2126m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                 TRUE     2127m     IFEQ DEBUG
00000CCC  1639 00C00003           2128m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CD2  0803 0000               2129m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000CD6  67F4                    2130m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000CD8                          2131m     ENDC
00000CD8                          2132m     
00000CD8                          2133mm     READ_CHAR D2
00000CD8                 TRUE     2134mm     IFEQ DEBUG
00000CD8  1439 00C00007           2135mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000CDE                          2136mm     ENDC
00000CDE                 FALSE    2137mm     IFNE DEBUG
00000CDE                          2138mm     ENDC
00000CDE                          2139mm      
00000CDE  B43C 001B               2140mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000CE2  6700 F324               2141mm     BEQ START
00000CE6                          2142mm     ENDM
00000CE6                          2143m 
00000CE6                 TRUE     2144m     IFEQ DEBUG
00000CE6                          2145mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000CE6                          2146mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE6                 TRUE     2147mm     IFEQ DEBUG
00000CE6  1639 00C00003           2148mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CEC  0803 0002               2149mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CF0  67F4                    2150mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000CF2  13C2 00C00007           2151mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CF8                          2152mm     ENDC
00000CF8                          2153mm     
00000CF8                 FALSE    2154mm     IFNE DEBUG
00000CF8                          2155mm     ENDC
00000CF8                          2156mm 
00000CF8                          2157mm     ENDM
00000CF8                          2158m     ENDC
00000CF8                          2159m     ENDM
00000CF8                          2160m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000CF8  41F9 00000F8C           2161m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000CFE  0402 0030               2162m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D02  C4BC 000000FF           2163m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D08  1430 2000               2164m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D0C                          2165m     ENDM
00000D0C  1A02                    2166      MOVE.B D2,D5                                ; put at bottom of D5
00000D0E                          2167  
00000D0E  3C3C 0002               2168      MOVE #2,D6                                  ; 3 bytes left to read
00000D12                          2169      
00000D12                          2170  READ_LENGTH
00000D12  E98D                    2171      LSL.L #4,D5                                 ; make what we have so far more significant
00000D14                          2172m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D14                          2173m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D14                 TRUE     2174m     IFEQ DEBUG
00000D14  1639 00C00003           2175m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D1A  0803 0000               2176m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D1E  67F4                    2177m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D20                          2178m     ENDC
00000D20                          2179m     
00000D20                          2180mm     READ_CHAR D2
00000D20                 TRUE     2181mm     IFEQ DEBUG
00000D20  1439 00C00007           2182mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D26                          2183mm     ENDC
00000D26                 FALSE    2184mm     IFNE DEBUG
00000D26                          2185mm     ENDC
00000D26                          2186mm      
00000D26  B43C 001B               2187mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D2A  6700 F2DC               2188mm     BEQ START
00000D2E                          2189mm     ENDM
00000D2E                          2190m 
00000D2E                 TRUE     2191m     IFEQ DEBUG
00000D2E                          2192mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D2E                          2193mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D2E                 TRUE     2194mm     IFEQ DEBUG
00000D2E  1639 00C00003           2195mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D34  0803 0002               2196mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D38  67F4                    2197mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000D3A  13C2 00C00007           2198mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D40                          2199mm     ENDC
00000D40                          2200mm     
00000D40                 FALSE    2201mm     IFNE DEBUG
00000D40                          2202mm     ENDC
00000D40                          2203mm 
00000D40                          2204mm     ENDM
00000D40                          2205m     ENDC
00000D40                          2206m     ENDM
00000D40                          2207m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D40  41F9 00000F8C           2208m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D46  0402 0030               2209m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D4A  C4BC 000000FF           2210m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D50  1430 2000               2211m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D54                          2212m     ENDM
00000D54  8A02                    2213      OR.B D2,D5
00000D56  023C 00FB               2214      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000D5A  57CE FFB6               2215      DBEQ D6,READ_LENGTH
00000D5E                          2216          
00000D5E                          2217m     PRINT_CRLF D3
00000D5E                          2218mm     PRINT_CHAR #13,D3                           ; CR
00000D5E                          2219mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5E                 TRUE     2220mm     IFEQ DEBUG
00000D5E  1639 00C00003           2221mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D64  0803 0002               2222mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D68  67F4                    2223mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000D6A  13FC 000D 00C00007      2224mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D72                          2225mm     ENDC
00000D72                          2226mm     
00000D72                 FALSE    2227mm     IFNE DEBUG
00000D72                          2228mm     ENDC
00000D72                          2229mm 
00000D72                          2230mm     ENDM
00000D72                          2231mm     PRINT_CHAR #10,D3                           ; LF
00000D72                          2232mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     2233mm     IFEQ DEBUG
00000D72  1639 00C00003           2234mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D78  0803 0002               2235mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    2236mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000D7E  13FC 000A 00C00007      2237mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D86                          2238mm     ENDC
00000D86                          2239mm     
00000D86                 FALSE    2240mm     IFNE DEBUG
00000D86                          2241mm     ENDC
00000D86                          2242mm 
00000D86                          2243mm     ENDM
00000D86                          2244m     ENDM
00000D86                          2245  
00000D86  207C 00000000           2246      MOVE.L #ROM,A0                              ; start of ROM
00000D8C                          2247      
00000D8C  2247                    2248      MOVE.L D7,A1                                ; address accumulator -> address register
00000D8E  7E00                    2249      MOVE.L #0,D7                                ; clear the now used address accumulator
00000D90                          2250      
00000D90  267C 00002AAA           2251      MOVE.L #$2AAA,A3
00000D96  36BC AAAA               2252      MOVE.W #$AAAA,(A3)
00000D9A  267C 00001554           2253      MOVE.L #$1554,A3
00000DA0  36BC 5555               2254      MOVE.W #$5555,(A3)
00000DA4  267C 00002AAA           2255      MOVE.L #$2AAA,A3
00000DAA  36BC 8080               2256      MOVE.W #$8080,(A3)
00000DAE  267C 00002AAA           2257      MOVE.L #$2AAA,A3
00000DB4  36BC AAAA               2258      MOVE.W #$AAAA,(A3)
00000DB8  267C 00001554           2259      MOVE.L #$1554,A3
00000DBE  36BC 5555               2260      MOVE.W #$5555,(A3)
00000DC2  267C 00002AAA           2261      MOVE.L #$2AAA,A3
00000DC8  36BC 2020               2262      MOVE.W #$2020,(A3)
00000DCC                          2263      
00000DCC  45F9 00000FA3           2264      LEA LOADING,A2                              ; important for timing
00000DD2                          2265m     PRINT_STR A2,D3
00000DD2                          2266m LOOP_156
00000DD2  0C12 0000               2267m     CMP.B #0,(A2)                               ; 0 -> DONE
00000DD6  6700 0016               2268m     BEQ EXIT_156
00000DDA                          2269mm     PRINT_CHAR (A2)+,D3
00000DDA                          2270mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDA                 TRUE     2271mm     IFEQ DEBUG
00000DDA  1639 00C00003           2272mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DE0  0803 0002               2273mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DE4  67F4                    2274mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000DE6  13DA 00C00007           2275mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000DEC                          2276mm     ENDC
00000DEC                          2277mm     
00000DEC                 FALSE    2278mm     IFNE DEBUG
00000DEC                          2279mm     ENDC
00000DEC                          2280mm 
00000DEC                          2281mm     ENDM
00000DEC  60E4                    2282m     BRA LOOP_156
00000DEE                          2283m EXIT_156
00000DEE                          2284m     ENDM
00000DEE                          2285  
00000DEE  023C 00FB               2286      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DF2                          2287      
00000DF2                          2288      WHILE D5 <GT> #0 DO
00000DF2                          2289s _10000018
00000DF2  BA7C 0000               2290s     CMP.W   #0,D5
00000DF6  6F00 001C               2291s     BLE _10000019
00000DFA  5585                    2292          SUB.L #2,D5
00000DFC                          2293            
00000DFC  13D1 00E00001           2294          MOVE.B (A1),DISPLAY
00000E02  3091                    2295          MOVE.W (A1),(A0)                        ; write the data
00000E04                          2296        
00000E04                          2297  WAIT_FOR_COMPLETE
00000E04  3410                    2298          MOVE.W (A0),D2
00000E06                          2299  
00000E06                          2300          IF D2 <NE> (A1) THEN
00000E06  B451                    2301s     CMP.W   (A1),D2
00000E08  6700 0004               2302s     BEQ _0000000C
00000E0C  60F6                    2303              BRA WAIT_FOR_COMPLETE
00000E0E                          2304          ENDI
00000E0E                          2305s _0000000C
00000E0E                          2306        
00000E0E  5488                    2307          ADD.L #2,A0
00000E10  5489                    2308          ADD.L #2,A1
00000E12                          2309      ENDW  
00000E12  60DE                    2310s     BRA _10000018
00000E14                          2311s _10000019
00000E14                          2312      
00000E14  267C 00002AAA           2313      MOVE.L #$2AAA,A3
00000E1A  36BC AAAA               2314      MOVE.W #$AAAA,(A3)
00000E1E  267C 00001554           2315      MOVE.L #$1554,A3
00000E24  36BC 5555               2316      MOVE.W #$5555,(A3)
00000E28  267C 00002AAA           2317      MOVE.L #$2AAA,A3
00000E2E  36BC A0A0               2318      MOVE.W #$A0A0,(A3)
00000E32                          2319              
00000E32  6000 F350               2320      BRA MAIN_LOOP
00000E36                          2321          
00000E36                          2322  HEX_DIGIT
00000E36  E98F                    2323      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000E38                          2324m     HEX2BIN D2,D2,A0
00000E38  41F9 00000F8C           2325m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000E3E  0402 0030               2326m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E42  C4BC 000000FF           2327m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000E48  1430 2000               2328m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000E4C                          2329m     ENDM
00000E4C  8E02                    2330      OR.B D2,D7  
00000E4E  6000 F35C               2331      BRA GET_INPUT
00000E52                          2332  
00000E52  FFFF FFFF               2333      SIMHALT                                     ; halt simulator
00000E56                          2334  
00000E56                          2335  ; strings
00000E56= 4D 44 46 2D 6D 6F ...   2336  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',13,10,0
00000E73= 3F 20 48 65 6C 70 ...   2337  HELP    DC.B '? Help',13,10,'[v] version',13,10,'xxxxxxxx[r] read long',13,10,'xxxxxxxx[w]xxxxxxxx write long',13,10,'[s] download S records',13,10,'xxxxxxxx[g] go',13,10,'[z] zap memory',10,13,'xxxxxxxx[l]xxxx load to EEPROM',10,13,0
00000F18= 48 75 68 3F 0D 0A 00    2338  HUH     DC.B 'Huh?',13,10,0
00000F1F= 20 53 20 72 65 63 ...   2339  READ    DC.B ' S records read, start address = ',0
00000F41= 57 3A 20 55 6E 6B ...   2340  UNREC   DC.B 'W: Unknown Srec type: ',0
00000F58= 57 3A 20 43 53 20 ...   2341  CS_FAILURE   DC.B 'W: CS failure at ',0
00000F6A= 57 3A 20 52 41 4D ...   2342  RAM_ERROR DC.B 'W: RAM error at: ',0
00000F7C= 30 31 32 33 34 35 ...   2343  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000F8C= 00 01 02 03 04 05 ...   2344  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000FA3= 4C 6F 61 64 69 6E ...   2345  LOADING  DC.B 'Loading EEPROM...',13,11,0
00000FB7                          2346      
00000FB7                          2347      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         F7C
CONTINUE_103        9A6
CONTINUE_44         44A
CONTINUE_47         49A
CONTINUE_51         4F2
CONTINUE_59         5B0
CONTINUE_64         624
CONTINUE_69         6A2
CONTINUE_74         726
CONTINUE_79         7B4
CONTINUE_84         828
CONTINUE_89         89C
CS_FAILURE          F58
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            95E
DOWNLOAD_BYTE       C2F
DOWNLOAD_DONE       AC4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            A42
EXIT_125            B3A
EXIT_135            C40
EXIT_156            DEE
EXIT_19             28A
EXIT_21             2B0
EXIT_23             2D6
EXIT_5              13E
EXIT_96             93C
G                   BBC
GET_INPUT           1AC
H                   28E
HELP                E73
HEX2BIN             134
HEX2BIN_LUT         F8C
HEX_DIGIT           E36
HUH                 F18
L                   CCA
LOADING             FA3
LOOP_110            A26
LOOP_112            A6C
LOOP_120            AEE
LOOP_125            B1E
LOOP_127            B66
LOOP_135            C24
LOOP_137            C6E
LOOP_156            DD2
LOOP_19             26E
LOOP_21             294
LOOP_23             2BA
LOOP_25             308
LOOP_5              122
LOOP_96             920
MAIN_LOOP           184
OK                  CC0
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   2DA
RAM                 200000
RAM_ERROR           F6A
READ                F1F
READ_CHAR           803
READ_DATA_TO_POKE   3A8
READ_LENGTH         D12
RESET               4
ROM                 0
S                   426
STACK               0
START               8
UNREC               F41
V                   2B4
VERSION             E56
W                   360
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E04
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   166
WAIT_FOR_READY_100  94E
WAIT_FOR_READY_101  962
WAIT_FOR_READY_103  98A
WAIT_FOR_READY_105  9BE
WAIT_FOR_READY_108  9F0
WAIT_FOR_READY_109  A04
WAIT_FOR_READY_11   184
WAIT_FOR_READY_111  A2E
WAIT_FOR_READY_113  A42
WAIT_FOR_READY_114  A56
WAIT_FOR_READY_116  A80
WAIT_FOR_READY_118  A96
WAIT_FOR_READY_119  AAA
WAIT_FOR_READY_12   198
WAIT_FOR_READY_121  AC4
WAIT_FOR_READY_122  AD8
WAIT_FOR_READY_124  B02
WAIT_FOR_READY_126  B26
WAIT_FOR_READY_128  B3C
WAIT_FOR_READY_129  B50
WAIT_FOR_READY_13   1AC
WAIT_FOR_READY_131  B7A
WAIT_FOR_READY_133  B90
WAIT_FOR_READY_134  BA4
WAIT_FOR_READY_136  C2C
WAIT_FOR_READY_138  C44
WAIT_FOR_READY_139  C58
WAIT_FOR_READY_141  C82
WAIT_FOR_READY_143  C98
WAIT_FOR_READY_144  CAC
WAIT_FOR_READY_145  CCC
WAIT_FOR_READY_147  CE6
WAIT_FOR_READY_149  D14
WAIT_FOR_READY_15   1C6
WAIT_FOR_READY_151  D2E
WAIT_FOR_READY_154  D5E
WAIT_FOR_READY_155  D72
WAIT_FOR_READY_157  DDA
WAIT_FOR_READY_17   210
WAIT_FOR_READY_18   224
WAIT_FOR_READY_20   276
WAIT_FOR_READY_22   29C
WAIT_FOR_READY_24   2C2
WAIT_FOR_READY_26   2DE
WAIT_FOR_READY_27   2F2
WAIT_FOR_READY_29   31C
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   332
WAIT_FOR_READY_32   346
WAIT_FOR_READY_33   362
WAIT_FOR_READY_35   37C
WAIT_FOR_READY_37   3AA
WAIT_FOR_READY_39   3C4
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   3FA
WAIT_FOR_READY_43   40E
WAIT_FOR_READY_44   42E
WAIT_FOR_READY_46   468
WAIT_FOR_READY_47   47E
WAIT_FOR_READY_49   4B2
WAIT_FOR_READY_51   4D6
WAIT_FOR_READY_53   50A
WAIT_FOR_READY_56   544
WAIT_FOR_READY_57   558
WAIT_FOR_READY_59   594
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   5C8
WAIT_FOR_READY_64   608
WAIT_FOR_READY_66   63C
WAIT_FOR_READY_69   686
WAIT_FOR_READY_71   6BA
WAIT_FOR_READY_74   70A
WAIT_FOR_READY_76   73E
WAIT_FOR_READY_79   798
WAIT_FOR_READY_8    13E
WAIT_FOR_READY_81   7CC
WAIT_FOR_READY_84   80C
WAIT_FOR_READY_86   840
WAIT_FOR_READY_89   880
WAIT_FOR_READY_9    152
WAIT_FOR_READY_91   8B4
WAIT_FOR_READY_94   8F2
WAIT_FOR_READY_95   906
WAIT_FOR_READY_97   928
WAIT_FOR_READY_98   93C
WAIT_FOR_SRECORD    42E
Z                   BC4
_00000000           1EC
_00000001           200
_00000002           574
_00000003           97A
_00000004           582
_00000005           780
_00000006           6EC
_00000007           97A
_00000008           8F2
_00000009           97A
_0000000A           AC2
_0000000B           C1E
_0000000C           E0E
_10000000           4CC
_10000001           536
_10000002           58A
_10000003           5F4
_10000004           5FE
_10000005           668
_10000006           67C
_10000007           6E6
_10000008           6F0
_10000009           778
_1000000A           700
_1000000B           76A
_1000000C           78E
_1000000D           7F8
_1000000E           802
_1000000F           86C
_10000010           876
_10000011           8E0
_10000012           980
_10000013           9EA
_10000014           BCC
_10000015           BEE
_10000016           BF6
_10000017           CC6
_10000018           DF2
_10000019           E14
