00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/04/2021 10:27:28

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; add the offset into the start address
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; something prints 'N' on starting...
00000000                            11  ; press ? for help
00000000                            12  ; use DBLoop?
00000000                            13  
00000000                            14  ; ideas, but no room to do them
00000000                            15  ;------------------------------
00000000                            16  ; keep track of highest address hit during srec download
00000000                            17  ; implement backspace
00000000                            18  ; fix being able to enter random chars when W'ing
00000000                            19  ; ram check at startup?  Not sure if this is a good idea!
00000000                            20  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            21  
00000000                            22      ORG  $0
00000000                            23      ;ORG  $200000
00000000                            24  
00000000  =00000000                 25  DEBUG               EQU 0
00000000                            26  
00000000                            27  ; constants
00000000  =00000000                 28  NULL                EQU 0
00000000  =00000009                 29  TAB                 EQU 9
00000000  =0000000D                 30  CR                  EQU 13
00000000  =0000000A                 31  LF                  EQU 10
00000000                            32  
00000000  =00000000                 33  ROM                 EQU $0
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35     
00000000  =00C00000                 36  DUART_BASE          EQU $C00000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  
00000000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT(PC),\3                      ; load the lookup table
00000000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           110          BTST #2,\2                              ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           113      ENDC
00000000                           114      
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll, /2 = working address register
00000000                           125  PRINT_CRLF MACRO
00000000                           126      LEA CRLF(PC),\2
00000000                           127      PRINT_STR \2,\1
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #NULL,(\1)                            ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      BRA LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           143  PRINT_REG MACRO
00000000                           144      LEA ox(PC),\5
00000000                           145      PRINT_STR \5,\2
00000000                           146      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152      
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           160          BTST #0,\2                              ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           162      ENDC
00000000                           163      
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                            ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170      
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                    ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183       
00000000                           184      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187      
00000000                           188      
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           195      BTST #0,\1                                  ; check for character
00000000                           196      BEQ CONTINUE\@                              ; nothing, continue
00000000                           197   
00000000                           198      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           201      BTST #0,\1                                      ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           206      
00000000                           207      ENDM
00000000                           208      
00000000                           209  ; read two hex digits from the download serial port and convert to a byte
00000000                           210  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           211  DOWNLOAD_BYTE MACRO
00000000                           212      MOVE.B #2,\4
00000000                           213      WHILE.B \4 <GT> 0 DO
00000000                           214          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00000000                           215          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00000000                           216          PRINT_CHAR \2,\3
00000000                           217          HEX2BIN \2,\2,\6
00000000                           218          OR.B \2,\1
00000000                           219          SUB.B #1,\4
00000000                           220      ENDW
00000000                           221      
00000000                           222      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           223      MOVE.B \1,\2
00000000                           224      ADD.L \1,\5
00000000                           225  
00000000                           226      ENDM
00000000                           227      
00000000                           228  
00000000                           229  ; register catalogue
00000000                           230  ; D0 - used for simulator I/O
00000000                           231  ; D1 - used for simulator I/O
00000000                           232  ; D2 - read character
00000000                           233  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           234  ; D6 - working register used in R/W
00000000                           235  ; D7 - address accumulator, reset by download
00000000                           236  ; A0 - address of string to print 
00000000                           237  
00000000                           238  ; start vector
00000000= 00000000                 239  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 240  RESET    DC.L START                             ; RESET
00000008                           241      
00000008                           242  ; start of program  
00000008                           243  START
00000008  13FC 0000 00E00001       244      MOVE.B #0,DISPLAY
00000010                           245  
00000010                           246  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       247      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       248      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           249      
00000020                           250      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                251s     MOVE.W  #$50,D1
00000024  6000 000E                252s     BRA _20000001
00000028                           253s _20000000
00000028  13C1 00C00005            254          MOVE.B D1,DUART_CRA                     ; reset everyting
0000002E  4E71                     255          NOP
00000030                           256      ENDF
00000030  0441 0010                257s     SUB.W   #$10,D1
00000034                           258s _20000001
00000034  B27C 0010                259s     CMP.W   #$10,D1
00000038  6CEE                     260s     BGE _20000000
0000003A                           261  
0000003A                           262      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                263s     MOVE.W  #$50,D1
0000003E  6000 000E                264s     BRA _20000003
00000042                           265s _20000002
00000042  13C1 00C00015            266          MOVE.B D1,DUART_CRB                     ; reset everyting
00000048  4E71                     267          NOP
0000004A                           268      ENDF
0000004A  0441 0010                269s     SUB.W   #$10,D1
0000004E                           270s _20000003
0000004E  B27C 0010                271s     CMP.W   #$10,D1
00000052  6CEE                     272s     BGE _20000002
00000054                           273    
00000054                           274  ;initialise UART
00000054  13FC 0000 00C00009       275      MOVE.B #$0,DUART_ACR            
0000005C  13FC 0000 00C0000B       276      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00000064  13FC 0000 00C0001B       277      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           278  
0000006C                           279  ; channel A
0000006C  13FC 0013 00C00001       280      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       281      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       282      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
00000084  13FC 0005 00C00005       283      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           284  
0000008C                           285  ; channel B
0000008C  13FC 0013 00C00011       286      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       287      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       288      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
000000A4  13FC 0005 00C00015       289      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           290  
000000AC                           291m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
000000AC                           292m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      293m     IFEQ DEBUG
000000AC  1639 00C00003            294m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000B2  0803 0002                295m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000B6  67F4                     296m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000B8  13F8 002E 00C00007       297m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000C0                           298m     ENDC
000000C0                           299m     
000000C0                 FALSE     300m     IFNE DEBUG
000000C0                           301m     ENDC
000000C0                           302m 
000000C0                           303m     ENDM
000000C0                           304  
000000C0  13FC 0001 00E00001       305      MOVE.B #1,DISPLAY
000000C8                           306         
000000C8                           307m     PRINT_CRLF D3,A0
000000C8  41FA 0D0E                308m     LEA CRLF(PC),A0
000000CC                           309mm     PRINT_STR A0,D3
000000CC                           310mm LOOP_3
000000CC  0C10 0000                311mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000D0  6700 0016                312mm     BEQ EXIT_3
000000D4                           313mmm     PRINT_CHAR (A0)+,D3
000000D4                           314mmm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      315mmm     IFEQ DEBUG
000000D4  1639 00C00003            316mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DA  0803 0002                317mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000DE  67F4                     318mmm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
000000E0  13D8 00C00007            319mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000000E6                           320mmm     ENDC
000000E6                           321mmm     
000000E6                 FALSE     322mmm     IFNE DEBUG
000000E6                           323mmm     ENDC
000000E6                           324mmm 
000000E6                           325mmm     ENDM
000000E6  60E4                     326mm     BRA LOOP_3
000000E8                           327mm EXIT_3
000000E8                           328mm     ENDM
000000E8                           329m     ENDM
000000E8                           330  
000000E8  41FA 0B82                331      LEA VERSION(PC),A0
000000EC                           332m     PRINT_STR A0,D3
000000EC                           333m LOOP_5
000000EC  0C10 0000                334m     CMP.B #NULL,(A0)                            ; 0 -> DONE
000000F0  6700 0016                335m     BEQ EXIT_5
000000F4                           336mm     PRINT_CHAR (A0)+,D3
000000F4                           337mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      338mm     IFEQ DEBUG
000000F4  1639 00C00003            339mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                340mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     341mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000100  13D8 00C00007            342mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000106                           343mm     ENDC
00000106                           344mm     
00000106                 FALSE     345mm     IFNE DEBUG
00000106                           346mm     ENDC
00000106                           347mm 
00000106                           348mm     ENDM
00000106  60E4                     349m     BRA LOOP_5
00000108                           350m EXIT_5
00000108                           351m     ENDM
00000108                           352m     PRINT_CRLF D3,A0
00000108  41FA 0CCE                353m     LEA CRLF(PC),A0
0000010C                           354mm     PRINT_STR A0,D3
0000010C                           355mm LOOP_8
0000010C  0C10 0000                356mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000110  6700 0016                357mm     BEQ EXIT_8
00000114                           358mmm     PRINT_CHAR (A0)+,D3
00000114                           359mmm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000114                 TRUE      360mmm     IFEQ DEBUG
00000114  1639 00C00003            361mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000011A  0803 0002                362mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000011E  67F4                     363mmm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000120  13D8 00C00007            364mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000126                           365mmm     ENDC
00000126                           366mmm     
00000126                 FALSE     367mmm     IFNE DEBUG
00000126                           368mmm     ENDC
00000126                           369mmm 
00000126                           370mmm     ENDM
00000126  60E4                     371mm     BRA LOOP_8
00000128                           372mm EXIT_8
00000128                           373mm     ENDM
00000128                           374m     ENDM
00000128                           375  
00000128  7E00                     376      MOVE.L #0,D7                                    ; address accumulator
0000012A                           377  
0000012A  13FC 0002 00E00001       378      MOVE.B #2,DISPLAY
00000132                           379  MAIN_LOOP
00000132  41FA 0CA7                380      LEA PROMPT(PC),A0
00000136                           381m     PRINT_STR A0,D3
00000136                           382m LOOP_10
00000136  0C10 0000                383m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000013A  6700 0016                384m     BEQ EXIT_10
0000013E                           385mm     PRINT_CHAR (A0)+,D3
0000013E                           386mm WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013E                 TRUE      387mm     IFEQ DEBUG
0000013E  1639 00C00003            388mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000144  0803 0002                389mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000148  67F4                     390mm         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
0000014A  13D8 00C00007            391mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000150                           392mm     ENDC
00000150                           393mm     
00000150                 FALSE     394mm     IFNE DEBUG
00000150                           395mm     ENDC
00000150                           396mm 
00000150                           397mm     ENDM
00000150  60E4                     398m     BRA LOOP_10
00000152                           399m EXIT_10
00000152                           400m     ENDM
00000152                           401      
00000152                           402  GET_INPUT
00000152                           403m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00000152                           404m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      405m     IFEQ DEBUG
00000152  1639 00C00003            406m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000158  0803 0000                407m         BTST #0,D3                              ; CHECK FOR CHARACTER
0000015C  67F4                     408m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
0000015E                           409m     ENDC
0000015E                           410m     
0000015E                           411mm     READ_CHAR D2
0000015E                 TRUE      412mm     IFEQ DEBUG
0000015E  1439 00C00007            413mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000164                           414mm     ENDC
00000164                 FALSE     415mm     IFNE DEBUG
00000164                           416mm     ENDC
00000164                           417mm      
00000164  B43C 001B                418mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000168  6700 FE9E                419mm     BEQ START
0000016C                           420mm     ENDM
0000016C                           421m 
0000016C                 TRUE      422m     IFEQ DEBUG
0000016C                           423mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000016C                           424mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000016C                 TRUE      425mm     IFEQ DEBUG
0000016C  1639 00C00003            426mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000172  0803 0002                427mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000176  67F4                     428mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
00000178  13C2 00C00007            429mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017E                           430mm     ENDC
0000017E                           431mm     
0000017E                 FALSE     432mm     IFNE DEBUG
0000017E                           433mm     ENDC
0000017E                           434mm 
0000017E                           435mm     ENDM
0000017E                           436m     ENDC
0000017E                           437m     ENDM
0000017E                           438      
0000017E                           439      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000017E  B43C 0030                440s     CMP.B   #'0',D2
00000182  6D00 000E                441s     BLT _00000000
00000186  B43C 0039                442s     CMP.B   #'9',D2
0000018A  6E00 0006                443s     BGT _00000000
0000018E  6000 0ABE                444          BRA HEX_DIGIT
00000192                           445      ENDI
00000192                           446s _00000000
00000192                           447      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
00000192  B43C 0041                448s     CMP.B   #'A',D2
00000196  6D00 000E                449s     BLT _00000001
0000019A  B43C 0046                450s     CMP.B   #'F',D2
0000019E  6E00 0006                451s     BGT _00000001
000001A2  6000 0AAA                452          BRA HEX_DIGIT
000001A6                           453      ENDI
000001A6                           454s _00000001
000001A6                           455          
000001A6  B43C 0077                456      CMP.B #'w',D2
000001AA  6700 011E                457      BEQ W
000001AE                           458      
000001AE  B43C 006C                459      CMP.B #'l',D2
000001B2  6700 09A0                460      BEQ L 
000001B6                           461  
000001B6                           462m     PRINT_CRLF D3,A0
000001B6  41FA 0C20                463m     LEA CRLF(PC),A0
000001BA                           464mm     PRINT_STR A0,D3
000001BA                           465mm LOOP_16
000001BA  0C10 0000                466mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000001BE  6700 0016                467mm     BEQ EXIT_16
000001C2                           468mmm     PRINT_CHAR (A0)+,D3
000001C2                           469mmm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C2                 TRUE      470mmm     IFEQ DEBUG
000001C2  1639 00C00003            471mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001C8  0803 0002                472mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001CC  67F4                     473mmm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
000001CE  13D8 00C00007            474mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000001D4                           475mmm     ENDC
000001D4                           476mmm     
000001D4                 FALSE     477mmm     IFNE DEBUG
000001D4                           478mmm     ENDC
000001D4                           479mmm 
000001D4                           480mmm     ENDM
000001D4  60E4                     481mm     BRA LOOP_16
000001D6                           482mm EXIT_16
000001D6                           483mm     ENDM
000001D6                           484m     ENDM
000001D6                           485   
000001D6  B43C 003F                486      CMP.B #'?',D2
000001DA  6700 004E                487      BEQ H
000001DE                           488   
000001DE  B43C 0076                489      CMP.B #'v',D2
000001E2  6700 004E                490      BEQ V
000001E6                           491      
000001E6  B43C 0072                492      CMP.B #'r',D2
000001EA  6700 006A                493      BEQ R
000001EE                           494  
000001EE  B43C 0073                495      CMP.B #'s',D2
000001F2  6700 014A                496      BEQ S
000001F6                           497  
000001F6  B43C 0067                498      CMP.B #'g',D2
000001FA  6700 086E                499      BEQ G   
000001FE                           500  
000001FE  B43C 007A                501      CMP.B #'z',D2
00000202  6700 086E                502      BEQ Z   
00000206                           503  
00000206  41FA 0B31                504      LEA HUH(PC),A0
0000020A                           505m     PRINT_STR A0,D3
0000020A                           506m LOOP_18
0000020A  0C10 0000                507m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000020E  6700 0016                508m     BEQ EXIT_18
00000212                           509mm     PRINT_CHAR (A0)+,D3
00000212                           510mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000212                 TRUE      511mm     IFEQ DEBUG
00000212  1639 00C00003            512mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000218  0803 0002                513mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000021C  67F4                     514mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0000021E  13D8 00C00007            515mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000224                           516mm     ENDC
00000224                           517mm     
00000224                 FALSE     518mm     IFNE DEBUG
00000224                           519mm     ENDC
00000224                           520mm 
00000224                           521mm     ENDM
00000224  60E4                     522m     BRA LOOP_18
00000226                           523m EXIT_18
00000226                           524m     ENDM
00000226                           525                         
00000226  6000 FF0A                526      BRA MAIN_LOOP
0000022A                           527      
0000022A                           528  ; commands
0000022A                           529  H   
0000022A  41FA 0A5D                530      LEA HELP(PC),A0
0000022E  6000 0006                531      BRA PRINTSTR
00000232                           532  
00000232                           533  V   
00000232  41FA 0A38                534      LEA VERSION(PC),A0
00000236                           535  PRINTSTR
00000236                           536m     PRINT_STR A0,D3       
00000236                           537m LOOP_20
00000236  0C10 0000                538m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0000023A  6700 0016                539m     BEQ EXIT_20
0000023E                           540mm     PRINT_CHAR (A0)+,D3
0000023E                           541mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000023E                 TRUE      542mm     IFEQ DEBUG
0000023E  1639 00C00003            543mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000244  0803 0002                544mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000248  67F4                     545mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0000024A  13D8 00C00007            546mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000250                           547mm     ENDC
00000250                           548mm     
00000250                 FALSE     549mm     IFNE DEBUG
00000250                           550mm     ENDC
00000250                           551mm 
00000250                           552mm     ENDM
00000250  60E4                     553m     BRA LOOP_20
00000252                           554m EXIT_20
00000252                           555m     ENDM
00000252  6000 FEDE                556      BRA MAIN_LOOP
00000256                           557      
00000256                           558  R   
00000256  2047                     559      MOVE.L D7,A0                                    ; address accumulator -> address register
00000258  7E00                     560      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000025A  2410                     561      MOVE.L (A0),D2                                  ; read the memory and print it
0000025C                           562m     PRINT_REG D2,D3,D4,D5,A0
0000025C  41FA 0B80                563m     LEA OX(PC),A0
00000260                           564mm     PRINT_STR A0,D3
00000260                           565mm LOOP_23
00000260  0C10 0000                566mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000264  6700 0016                567mm     BEQ EXIT_23
00000268                           568mmm     PRINT_CHAR (A0)+,D3
00000268                           569mmm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000268                 TRUE      570mmm     IFEQ DEBUG
00000268  1639 00C00003            571mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000026E  0803 0002                572mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000272  67F4                     573mmm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
00000274  13D8 00C00007            574mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000027A                           575mmm     ENDC
0000027A                           576mmm     
0000027A                 FALSE     577mmm     IFNE DEBUG
0000027A                           578mmm     ENDC
0000027A                           579mmm 
0000027A                           580mmm     ENDM
0000027A  60E4                     581mm     BRA LOOP_23
0000027C                           582mm EXIT_23
0000027C                           583mm     ENDM
0000027C  7A07                     584m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000027E                           585m LOOP_22
0000027E                           586mm     BIN2HEX D2,D4,A0
0000027E  41FA 0B1D                587mm     LEA BIN2HEX_LUT(PC),A0                      ; LOAD THE LOOKUP TABLE
00000282  E99A                     588mm     ROL.L #4,D2                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000284  1802                     589mm     MOVE.B D2,D4
00000286  0284 0000000F            590mm     ANDI.L #$F,D4
0000028C  1830 4000                591mm     MOVE.B 0(A0,D4),D4                          ; USE THAT AS AN INDEX INTO THE LUT
00000290                           592mm     ENDM
00000290                           593mm     PRINT_CHAR D4,D3
00000290                           594mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000290                 TRUE      595mm     IFEQ DEBUG
00000290  1639 00C00003            596mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000296  0803 0002                597mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000029A  67F4                     598mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
0000029C  13C4 00C00007            599mm         MOVE.B D4,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002A2                           600mm     ENDC
000002A2                           601mm     
000002A2                 FALSE     602mm     IFNE DEBUG
000002A2                           603mm     ENDC
000002A2                           604mm 
000002A2                           605mm     ENDM
000002A2  57CD FFDA                606m     DBEQ D5,LOOP_22
000002A6                           607m     ENDM
000002A6                           608m     PRINT_CRLF D3,A0
000002A6  41FA 0B30                609m     LEA CRLF(PC),A0
000002AA                           610mm     PRINT_STR A0,D3
000002AA                           611mm LOOP_28
000002AA  0C10 0000                612mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
000002AE  6700 0016                613mm     BEQ EXIT_28
000002B2                           614mmm     PRINT_CHAR (A0)+,D3
000002B2                           615mmm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B2                 TRUE      616mmm     IFEQ DEBUG
000002B2  1639 00C00003            617mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002B8  0803 0002                618mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002BC  67F4                     619mmm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
000002BE  13D8 00C00007            620mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002C4                           621mmm     ENDC
000002C4                           622mmm     
000002C4                 FALSE     623mmm     IFNE DEBUG
000002C4                           624mmm     ENDC
000002C4                           625mmm 
000002C4                           626mmm     ENDM
000002C4  60E4                     627mm     BRA LOOP_28
000002C6                           628mm EXIT_28
000002C6                           629mm     ENDM
000002C6                           630m     ENDM
000002C6  6000 FE6A                631      BRA MAIN_LOOP
000002CA                           632  
000002CA                           633  W
000002CA  3C3C 0007                634      MOVE #7,D6                                      ; 7 bytes left to read
000002CE                           635      
000002CE                           636  READ_DATA_TO_POKE
000002CE  E98D                     637      LSL.L #4,D5                                     ; make what we have so far more significant
000002D0                           638m     WAIT_CHAR D2,D3                                 ; next character -> D2
000002D0                           639m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D0                 TRUE      640m     IFEQ DEBUG
000002D0  1639 00C00003            641m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002D6  0803 0000                642m         BTST #0,D3                              ; CHECK FOR CHARACTER
000002DA  67F4                     643m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
000002DC                           644m     ENDC
000002DC                           645m     
000002DC                           646mm     READ_CHAR D2
000002DC                 TRUE      647mm     IFEQ DEBUG
000002DC  1439 00C00007            648mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000002E2                           649mm     ENDC
000002E2                 FALSE     650mm     IFNE DEBUG
000002E2                           651mm     ENDC
000002E2                           652mm      
000002E2  B43C 001B                653mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000002E6  6700 FD20                654mm     BEQ START
000002EA                           655mm     ENDM
000002EA                           656m 
000002EA                 TRUE      657m     IFEQ DEBUG
000002EA                           658mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000002EA                           659mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002EA                 TRUE      660mm     IFEQ DEBUG
000002EA  1639 00C00003            661mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002F0  0803 0002                662mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002F4  67F4                     663mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000002F6  13C2 00C00007            664mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000002FC                           665mm     ENDC
000002FC                           666mm     
000002FC                 FALSE     667mm     IFNE DEBUG
000002FC                           668mm     ENDC
000002FC                           669mm 
000002FC                           670mm     ENDM
000002FC                           671m     ENDC
000002FC                           672m     ENDM
000002FC                           673m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000002FC  41FA 0AAF                674m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000300  0402 0030                675m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000304  C4BC 000000FF            676m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000030A  1430 2000                677m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
0000030E                           678m     ENDM
0000030E  8A02                     679      OR.B D2,D5
00000310  57CE FFBC                680      DBEQ D6,READ_DATA_TO_POKE
00000314                           681      
00000314  2047                     682      MOVE.L D7,A0                                    ; address accumulator -> address register
00000316  7E00                     683      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000318                           684      
00000318  2085                     685      MOVE.L D5,(A0)                                  ; write the data
0000031A                           686  
0000031A                           687m     PRINT_CRLF D3,A0
0000031A  41FA 0ABC                688m     LEA CRLF(PC),A0
0000031E                           689mm     PRINT_STR A0,D3
0000031E                           690mm LOOP_35
0000031E  0C10 0000                691mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000322  6700 0016                692mm     BEQ EXIT_35
00000326                           693mmm     PRINT_CHAR (A0)+,D3
00000326                           694mmm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000326                 TRUE      695mmm     IFEQ DEBUG
00000326  1639 00C00003            696mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000032C  0803 0002                697mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000330  67F4                     698mmm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
00000332  13D8 00C00007            699mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000338                           700mmm     ENDC
00000338                           701mmm     
00000338                 FALSE     702mmm     IFNE DEBUG
00000338                           703mmm     ENDC
00000338                           704mmm 
00000338                           705mmm     ENDM
00000338  60E4                     706mm     BRA LOOP_35
0000033A                           707mm EXIT_35
0000033A                           708mm     ENDM
0000033A                           709m     ENDM
0000033A  6000 FDF6                710      BRA MAIN_LOOP
0000033E                           711  
0000033E                           712  ; register map for S
0000033E                           713  ; A0 - start address
0000033E                           714  ; A1 - offset
0000033E                           715  ; A2 - next address to write
0000033E                           716  ; A3 - next location (jmp)
0000033E                           717  ; A4 - Working Address Register
0000033E                           718  ; D0 - record count
0000033E                           719  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000033E                           720  ; D2 - checksum
0000033E                           721  ; D3 - data byte count
0000033E                           722  ; D4 - read address, moved into A2
0000033E                           723  ; D5 - temp
0000033E                           724  ; D6 - temp
0000033E                           725  ; D7 - temp
0000033E                           726  S
0000033E  2078 0000                727      MOVE.L 0,A0                                     ; start address -> A0
00000342  2247                     728      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000344                           729      
00000344  7000                     730      MOVE.L #0,D0                                    ; count of records read -> D0
00000346                           731          
00000346                           732  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000346                           733m     DOWNLOAD D1                 
00000346                           734m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000346                           735m 
00000346  1239 00C00003            736m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0000034C  0801 0000                737m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00000350  6700 0010                738m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
00000354                           739m  
00000354                           740mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
00000354                 TRUE      741mm     IFEQ DEBUG
00000354  1239 00C00007            742mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000035A                           743mm     ENDC
0000035A                 FALSE     744mm     IFNE DEBUG
0000035A                           745mm     ENDC
0000035A                           746mm      
0000035A  B23C 001B                747mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
0000035E  6700 FCA8                748mm     BEQ START
00000362                           749mm     ENDM
00000362                           750m CONTINUE_37
00000362  1239 00C00013            751m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000368  0801 0000                752m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000036C  67D8                     753m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
0000036E                           754m     
0000036E  1239 00C00017            755m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000374  13C1 00E00001            756m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000037A                           757m     
0000037A                           758m     ENDM
0000037A  B23C 0053                759      CMP.B #'S',D1                                   ; found S?    
0000037E  66C6                     760      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000380                           761      
00000380                           762m     PRINT_CHAR #'S',D5                            ; print the S
00000380                           763m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000380                 TRUE      764m     IFEQ DEBUG
00000380  1A39 00C00003            765m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000386  0805 0002                766m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000038A  67F4                     767m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
0000038C  13FC 0053 00C00007       768m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000394                           769m     ENDC
00000394                           770m     
00000394                 FALSE     771m     IFNE DEBUG
00000394                           772m     ENDC
00000394                           773m 
00000394                           774m     ENDM
00000394  5280                     775      ADD.L #1,D0                                     ; read another S record, increment count
00000396                           776      
00000396                           777m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000396                           778m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000396                           779m 
00000396  1239 00C00003            780m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
0000039C  0801 0000                781m     BTST #0,D1                                  ; CHECK FOR CHARACTER
000003A0  6700 0010                782m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
000003A4                           783m  
000003A4                           784mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
000003A4                 TRUE      785mm     IFEQ DEBUG
000003A4  1239 00C00007            786mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000003AA                           787mm     ENDC
000003AA                 FALSE     788mm     IFNE DEBUG
000003AA                           789mm     ENDC
000003AA                           790mm      
000003AA  B23C 001B                791mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
000003AE  6700 FC58                792mm     BEQ START
000003B2                           793mm     ENDM
000003B2                           794m CONTINUE_40
000003B2  1239 00C00013            795m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000003B8  0801 0000                796m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000003BC  67D8                     797m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
000003BE                           798m     
000003BE  1239 00C00017            799m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000003C4  13C1 00E00001            800m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000003CA                           801m     
000003CA                           802m     ENDM
000003CA                           803m     PRINT_CHAR D1,D5
000003CA                           804m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003CA                 TRUE      805m     IFEQ DEBUG
000003CA  1A39 00C00003            806m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000003D0  0805 0002                807m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000003D4  67F4                     808m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
000003D6  13C1 00C00007            809m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003DC                           810m     ENDC
000003DC                           811m     
000003DC                 FALSE     812m     IFNE DEBUG
000003DC                           813m     ENDC
000003DC                           814m 
000003DC                           815m     ENDM
000003DC                           816  
000003DC  7400                     817      MOVE.L #0,D2                                    ; clear the checksum
000003DE                           818  
000003DE                           819m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
000003DE  1E3C 0002                820m     MOVE.B #2,D7
000003E2                           821m     WHILE.B D7 <GT> 0 DO
000003E2                           822ms _10000000
000003E2  BE38 0000                823ms     CMP.B   0,D7
000003E6  6F00 0062                824ms     BLE _10000001
000003EA  E98B                     825m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
000003EC                           826mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000003EC                           827mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EC                           828mm 
000003EC  1A39 00C00003            829mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000003F2  0805 0000                830mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000003F6  6700 0010                831mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
000003FA                           832mm  
000003FA                           833mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000003FA                 TRUE      834mmm     IFEQ DEBUG
000003FA  1A39 00C00007            835mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000400                           836mmm     ENDC
00000400                 FALSE     837mmm     IFNE DEBUG
00000400                           838mmm     ENDC
00000400                           839mmm      
00000400  BA3C 001B                840mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000404  6700 FC02                841mmm     BEQ START
00000408                           842mmm     ENDM
00000408                           843mm CONTINUE_44
00000408  1A39 00C00013            844mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000040E  0805 0000                845mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000412  67D8                     846mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
00000414                           847mm     
00000414  1A39 00C00017            848mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000041A  13C5 00E00001            849mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000420                           850mm     
00000420                           851mm     ENDM
00000420                           852mm         PRINT_CHAR D5,D6
00000420                           853mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000420                 TRUE      854mm     IFEQ DEBUG
00000420  1C39 00C00003            855mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000426  0806 0002                856mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000042A  67F4                     857mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
0000042C  13C5 00C00007            858mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000432                           859mm     ENDC
00000432                           860mm     
00000432                 FALSE     861mm     IFNE DEBUG
00000432                           862mm     ENDC
00000432                           863mm 
00000432                           864mm     ENDM
00000432                           865mm         HEX2BIN D5,D5,A4
00000432  49FA 0979                866mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000436  0405 0030                867mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000043A  CABC 000000FF            868mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000440  1A34 5000                869mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000444                           870mm     ENDM
00000444  8605                     871m         OR.B D5,D3
00000446  5307                     872m         SUB.B #1,D7
00000448                           873m     ENDW
00000448  6098                     874ms     BRA _10000000
0000044A                           875ms _10000001
0000044A                           876m     
0000044A  7A00                     877m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000044C  1A03                     878m     MOVE.B D3,D5
0000044E  D483                     879m     ADD.L D3,D2
00000450                           880m 
00000450                           881m     ENDM
00000450                           882  
00000450                           883      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000450  B23C 0030                884s     CMP.B   #'0',D1
00000454  6600 002A                885s     BNE.L   _00000002
00000458                           886m         PRINT_CRLF D5,A4
00000458  49FA 097E                887m     LEA CRLF(PC),A4
0000045C                           888mm     PRINT_STR A4,D5
0000045C                           889mm LOOP_49
0000045C  0C14 0000                890mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000460  6700 0016                891mm     BEQ EXIT_49
00000464                           892mmm     PRINT_CHAR (A4)+,D5
00000464                           893mmm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000464                 TRUE      894mmm     IFEQ DEBUG
00000464  1A39 00C00003            895mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000046A  0805 0002                896mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000046E  67F4                     897mmm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
00000470  13DC 00C00007            898mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000476                           899mmm     ENDC
00000476                           900mmm     
00000476                 FALSE     901mmm     IFNE DEBUG
00000476                           902mmm     ENDC
00000476                           903mmm 
00000476                           904mmm     ENDM
00000476  60E4                     905mm     BRA LOOP_49
00000478                           906mm EXIT_49
00000478                           907mm     ENDM
00000478                           908m     ENDM
00000478  6000 FECC                909          BRA WAIT_FOR_SRECORD
0000047C                           910      ELSE
0000047C  6000 03DE                911s     BRA _00000003
00000480                           912s _00000002
00000480                           913          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00000480  B23C 0031                914s     CMP.B   #'1',D1
00000484  6708                     915s     BEQ.S   _00000004
00000486  B23C 0032                916s     CMP.B   #'2',D1
0000048A  6600 01F0                917s     BNE.L   _00000005
0000048E                           918s _00000004
0000048E  5783                     919              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000490                           920      
00000490  7800                     921              MOVE.L #0,D4                            ; read two bytes of address
00000492                           922m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; first byte                           
00000492  1E3C 0002                923m     MOVE.B #2,D7
00000496                           924m     WHILE.B D7 <GT> 0 DO
00000496                           925ms _10000002
00000496  BE38 0000                926ms     CMP.B   0,D7
0000049A  6F00 0062                927ms     BLE _10000003
0000049E  E98C                     928m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
000004A0                           929mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004A0                           930mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A0                           931mm 
000004A0  1A39 00C00003            932mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
000004A6  0805 0000                933mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
000004AA  6700 0010                934mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
000004AE                           935mm  
000004AE                           936mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000004AE                 TRUE      937mmm     IFEQ DEBUG
000004AE  1A39 00C00007            938mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004B4                           939mmm     ENDC
000004B4                 FALSE     940mmm     IFNE DEBUG
000004B4                           941mmm     ENDC
000004B4                           942mmm      
000004B4  BA3C 001B                943mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000004B8  6700 FB4E                944mmm     BEQ START
000004BC                           945mmm     ENDM
000004BC                           946mm CONTINUE_52
000004BC  1A39 00C00013            947mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004C2  0805 0000                948mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004C6  67D8                     949mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
000004C8                           950mm     
000004C8  1A39 00C00017            951mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004CE  13C5 00E00001            952mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004D4                           953mm     
000004D4                           954mm     ENDM
000004D4                           955mm         PRINT_CHAR D5,D6
000004D4                           956mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D4                 TRUE      957mm     IFEQ DEBUG
000004D4  1C39 00C00003            958mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000004DA  0806 0002                959mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000004DE  67F4                     960mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
000004E0  13C5 00C00007            961mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000004E6                           962mm     ENDC
000004E6                           963mm     
000004E6                 FALSE     964mm     IFNE DEBUG
000004E6                           965mm     ENDC
000004E6                           966mm 
000004E6                           967mm     ENDM
000004E6                           968mm         HEX2BIN D5,D5,A4
000004E6  49FA 08C5                969mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004EA  0405 0030                970mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004EE  CABC 000000FF            971mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000004F4  1A34 5000                972mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000004F8                           973mm     ENDM
000004F8  8805                     974m         OR.B D5,D4
000004FA  5307                     975m         SUB.B #1,D7
000004FC                           976m     ENDW
000004FC  6098                     977ms     BRA _10000002
000004FE                           978ms _10000003
000004FE                           979m     
000004FE  7A00                     980m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000500  1A04                     981m     MOVE.B D4,D5
00000502  D484                     982m     ADD.L D4,D2
00000504                           983m 
00000504                           984m     ENDM
00000504                           985m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4       ; second one
00000504  1E3C 0002                986m     MOVE.B #2,D7
00000508                           987m     WHILE.B D7 <GT> 0 DO
00000508                           988ms _10000004
00000508  BE38 0000                989ms     CMP.B   0,D7
0000050C  6F00 0062                990ms     BLE _10000005
00000510  E98C                     991m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000512                           992mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000512                           993mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                           994mm 
00000512  1A39 00C00003            995mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000518  0805 0000                996mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000051C  6700 0010                997mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
00000520                           998mm  
00000520                           999mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000520                 TRUE     1000mmm     IFEQ DEBUG
00000520  1A39 00C00007           1001mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000526                          1002mmm     ENDC
00000526                 FALSE    1003mmm     IFNE DEBUG
00000526                          1004mmm     ENDC
00000526                          1005mmm      
00000526  BA3C 001B               1006mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000052A  6700 FADC               1007mmm     BEQ START
0000052E                          1008mmm     ENDM
0000052E                          1009mm CONTINUE_57
0000052E  1A39 00C00013           1010mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000534  0805 0000               1011mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000538  67D8                    1012mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000053A                          1013mm     
0000053A  1A39 00C00017           1014mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000540  13C5 00E00001           1015mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000546                          1016mm     
00000546                          1017mm     ENDM
00000546                          1018mm         PRINT_CHAR D5,D6
00000546                          1019mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000546                 TRUE     1020mm     IFEQ DEBUG
00000546  1C39 00C00003           1021mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0000054C  0806 0002               1022mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000550  67F4                    1023mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
00000552  13C5 00C00007           1024mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000558                          1025mm     ENDC
00000558                          1026mm     
00000558                 FALSE    1027mm     IFNE DEBUG
00000558                          1028mm     ENDC
00000558                          1029mm 
00000558                          1030mm     ENDM
00000558                          1031mm         HEX2BIN D5,D5,A4
00000558  49FA 0853               1032mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000055C  0405 0030               1033mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000560  CABC 000000FF           1034mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000566  1A34 5000               1035mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000056A                          1036mm     ENDM
0000056A  8805                    1037m         OR.B D5,D4
0000056C  5307                    1038m         SUB.B #1,D7
0000056E                          1039m     ENDW
0000056E  6098                    1040ms     BRA _10000004
00000570                          1041ms _10000005
00000570                          1042m     
00000570  7A00                    1043m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000572  1A04                    1044m     MOVE.B D4,D5
00000574  D484                    1045m     ADD.L D4,D2
00000576                          1046m 
00000576                          1047m     ENDM
00000576                          1048              
00000576                          1049              IF.B D1 <EQ> #'2'  THEN.L             ; 24 bit address data record, read another byte
00000576  B23C 0032               1050s     CMP.B   #'2',D1
0000057A  6600 0076               1051s     BNE.L   _00000006
0000057E  5383                    1052                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000580                          1053m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00000580  1E3C 0002               1054m     MOVE.B #2,D7
00000584                          1055m     WHILE.B D7 <GT> 0 DO
00000584                          1056ms _10000006
00000584  BE38 0000               1057ms     CMP.B   0,D7
00000588  6F00 0062               1058ms     BLE _10000007
0000058C  E98C                    1059m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000058E                          1060mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000058E                          1061mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                          1062mm 
0000058E  1A39 00C00003           1063mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000594  0805 0000               1064mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000598  6700 0010               1065mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
0000059C                          1066mm  
0000059C                          1067mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000059C                 TRUE     1068mmm     IFEQ DEBUG
0000059C  1A39 00C00007           1069mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005A2                          1070mmm     ENDC
000005A2                 FALSE    1071mmm     IFNE DEBUG
000005A2                          1072mmm     ENDC
000005A2                          1073mmm      
000005A2  BA3C 001B               1074mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000005A6  6700 FA60               1075mmm     BEQ START
000005AA                          1076mmm     ENDM
000005AA                          1077mm CONTINUE_62
000005AA  1A39 00C00013           1078mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005B0  0805 0000               1079mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005B4  67D8                    1080mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
000005B6                          1081mm     
000005B6  1A39 00C00017           1082mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005BC  13C5 00E00001           1083mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005C2                          1084mm     
000005C2                          1085mm     ENDM
000005C2                          1086mm         PRINT_CHAR D5,D6
000005C2                          1087mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005C2                 TRUE     1088mm     IFEQ DEBUG
000005C2  1C39 00C00003           1089mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000005C8  0806 0002               1090mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000005CC  67F4                    1091mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
000005CE  13C5 00C00007           1092mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000005D4                          1093mm     ENDC
000005D4                          1094mm     
000005D4                 FALSE    1095mm     IFNE DEBUG
000005D4                          1096mm     ENDC
000005D4                          1097mm 
000005D4                          1098mm     ENDM
000005D4                          1099mm         HEX2BIN D5,D5,A4
000005D4  49FA 07D7               1100mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005D8  0405 0030               1101mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005DC  CABC 000000FF           1102mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005E2  1A34 5000               1103mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000005E6                          1104mm     ENDM
000005E6  8805                    1105m         OR.B D5,D4
000005E8  5307                    1106m         SUB.B #1,D7
000005EA                          1107m     ENDW
000005EA  6098                    1108ms     BRA _10000006
000005EC                          1109ms _10000007
000005EC                          1110m     
000005EC  7A00                    1111m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005EE  1A04                    1112m     MOVE.B D4,D5
000005F0  D484                    1113m     ADD.L D4,D2
000005F2                          1114m 
000005F2                          1115m     ENDM
000005F2                          1116              ENDI
000005F2                          1117s _00000006
000005F2                          1118              
000005F2  2444                    1119                  MOVE.L D4,A2                            ; put the address in an address register
000005F4  D5C9                    1120              ADD.L A1,A2                             ; add in the offset
000005F6                          1121  
000005F6                          1122              WHILE.B D3 <GT> #0 DO                   ; read the data bytes                
000005F6                          1123s _10000008
000005F6  B63C 0000               1124s     CMP.B   #0,D3
000005FA  6F00 007A               1125s     BLE _10000009
000005FE                          1126m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
000005FE  1E3C 0002               1127m     MOVE.B #2,D7
00000602                          1128m     WHILE.B D7 <GT> 0 DO
00000602                          1129ms _1000000A
00000602  BE38 0000               1130ms     CMP.B   0,D7
00000606  6F00 0062               1131ms     BLE _1000000B
0000060A  E989                    1132m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
0000060C                          1133mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000060C                          1134mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060C                          1135mm 
0000060C  1A39 00C00003           1136mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000612  0805 0000               1137mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000616  6700 0010               1138mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
0000061A                          1139mm  
0000061A                          1140mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0000061A                 TRUE     1141mmm     IFEQ DEBUG
0000061A  1A39 00C00007           1142mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000620                          1143mmm     ENDC
00000620                 FALSE    1144mmm     IFNE DEBUG
00000620                          1145mmm     ENDC
00000620                          1146mmm      
00000620  BA3C 001B               1147mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000624  6700 F9E2               1148mmm     BEQ START
00000628                          1149mmm     ENDM
00000628                          1150mm CONTINUE_67
00000628  1A39 00C00013           1151mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000062E  0805 0000               1152mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000632  67D8                    1153mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000634                          1154mm     
00000634  1A39 00C00017           1155mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000063A  13C5 00E00001           1156mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000640                          1157mm     
00000640                          1158mm     ENDM
00000640                          1159mm         PRINT_CHAR D5,D6
00000640                          1160mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000640                 TRUE     1161mm     IFEQ DEBUG
00000640  1C39 00C00003           1162mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000646  0806 0002               1163mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0000064A  67F4                    1164mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
0000064C  13C5 00C00007           1165mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000652                          1166mm     ENDC
00000652                          1167mm     
00000652                 FALSE    1168mm     IFNE DEBUG
00000652                          1169mm     ENDC
00000652                          1170mm 
00000652                          1171mm     ENDM
00000652                          1172mm         HEX2BIN D5,D5,A4
00000652  49FA 0759               1173mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000656  0405 0030               1174mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000065A  CABC 000000FF           1175mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000660  1A34 5000               1176mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00000664                          1177mm     ENDM
00000664  8205                    1178m         OR.B D5,D1
00000666  5307                    1179m         SUB.B #1,D7
00000668                          1180m     ENDW
00000668  6098                    1181ms     BRA _1000000A
0000066A                          1182ms _1000000B
0000066A                          1183m     
0000066A  7A00                    1184m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000066C  1A01                    1185m     MOVE.B D1,D5
0000066E  D481                    1186m     ADD.L D1,D2
00000670                          1187m 
00000670                          1188m     ENDM
00000670                          1189                          
00000670  14C1                    1190                  MOVE.B D1,(A2)+                     ; store it!
00000672                          1191  
00000672  5303                    1192                  SUB.B #1,D3                      ; 1 less byte to go
00000674                          1193              ENDW
00000674  6080                    1194s     BRA _10000008
00000676                          1195s _10000009
00000676                          1196          
00000676  7200                    1197              MOVE.L #0,D1                         ; not done yet
00000678                          1198          ELSE
00000678  6000 01E2               1199s     BRA _00000007
0000067C                          1200s _00000005
0000067C                          1201              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000067C  B23C 0038               1202s     CMP.B   #'8',D1
00000680  6600 0164               1203s     BNE.L   _00000008
00000684  7800                    1204                  MOVE.L #0,D4                    ; read the 24 bit start address
00000686                          1205m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
00000686  1E3C 0002               1206m     MOVE.B #2,D7
0000068A                          1207m     WHILE.B D7 <GT> 0 DO
0000068A                          1208ms _1000000C
0000068A  BE38 0000               1209ms     CMP.B   0,D7
0000068E  6F00 0062               1210ms     BLE _1000000D
00000692  E98C                    1211m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000694                          1212mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000694                          1213mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000694                          1214mm 
00000694  1A39 00C00003           1215mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000069A  0805 0000               1216mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0000069E  6700 0010               1217mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
000006A2                          1218mm  
000006A2                          1219mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
000006A2                 TRUE     1220mmm     IFEQ DEBUG
000006A2  1A39 00C00007           1221mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006A8                          1222mmm     ENDC
000006A8                 FALSE    1223mmm     IFNE DEBUG
000006A8                          1224mmm     ENDC
000006A8                          1225mmm      
000006A8  BA3C 001B               1226mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
000006AC  6700 F95A               1227mmm     BEQ START
000006B0                          1228mmm     ENDM
000006B0                          1229mm CONTINUE_72
000006B0  1A39 00C00013           1230mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006B6  0805 0000               1231mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006BA  67D8                    1232mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
000006BC                          1233mm     
000006BC  1A39 00C00017           1234mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006C2  13C5 00E00001           1235mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006C8                          1236mm     
000006C8                          1237mm     ENDM
000006C8                          1238mm         PRINT_CHAR D5,D6
000006C8                          1239mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006C8                 TRUE     1240mm     IFEQ DEBUG
000006C8  1C39 00C00003           1241mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000006CE  0806 0002               1242mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000006D2  67F4                    1243mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
000006D4  13C5 00C00007           1244mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006DA                          1245mm     ENDC
000006DA                          1246mm     
000006DA                 FALSE    1247mm     IFNE DEBUG
000006DA                          1248mm     ENDC
000006DA                          1249mm 
000006DA                          1250mm     ENDM
000006DA                          1251mm         HEX2BIN D5,D5,A4
000006DA  49FA 06D1               1252mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006DE  0405 0030               1253mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006E2  CABC 000000FF           1254mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006E8  1A34 5000               1255mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000006EC                          1256mm     ENDM
000006EC  8805                    1257m         OR.B D5,D4
000006EE  5307                    1258m         SUB.B #1,D7
000006F0                          1259m     ENDW
000006F0  6098                    1260ms     BRA _1000000C
000006F2                          1261ms _1000000D
000006F2                          1262m     
000006F2  7A00                    1263m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006F4  1A04                    1264m     MOVE.B D4,D5
000006F6  D484                    1265m     ADD.L D4,D2
000006F8                          1266m 
000006F8                          1267m     ENDM
000006F8                          1268m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
000006F8  1E3C 0002               1269m     MOVE.B #2,D7
000006FC                          1270m     WHILE.B D7 <GT> 0 DO
000006FC                          1271ms _1000000E
000006FC  BE38 0000               1272ms     CMP.B   0,D7
00000700  6F00 0062               1273ms     BLE _1000000F
00000704  E98C                    1274m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000706                          1275mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000706                          1276mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000706                          1277mm 
00000706  1A39 00C00003           1278mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000070C  0805 0000               1279mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000710  6700 0010               1280mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
00000714                          1281mm  
00000714                          1282mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000714                 TRUE     1283mmm     IFEQ DEBUG
00000714  1A39 00C00007           1284mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000071A                          1285mmm     ENDC
0000071A                 FALSE    1286mmm     IFNE DEBUG
0000071A                          1287mmm     ENDC
0000071A                          1288mmm      
0000071A  BA3C 001B               1289mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0000071E  6700 F8E8               1290mmm     BEQ START
00000722                          1291mmm     ENDM
00000722                          1292mm CONTINUE_77
00000722  1A39 00C00013           1293mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000728  0805 0000               1294mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000072C  67D8                    1295mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
0000072E                          1296mm     
0000072E  1A39 00C00017           1297mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000734  13C5 00E00001           1298mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000073A                          1299mm     
0000073A                          1300mm     ENDM
0000073A                          1301mm         PRINT_CHAR D5,D6
0000073A                          1302mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000073A                 TRUE     1303mm     IFEQ DEBUG
0000073A  1C39 00C00003           1304mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00000740  0806 0002               1305mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00000744  67F4                    1306mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
00000746  13C5 00C00007           1307mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000074C                          1308mm     ENDC
0000074C                          1309mm     
0000074C                 FALSE    1310mm     IFNE DEBUG
0000074C                          1311mm     ENDC
0000074C                          1312mm 
0000074C                          1313mm     ENDM
0000074C                          1314mm         HEX2BIN D5,D5,A4
0000074C  49FA 065F               1315mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000750  0405 0030               1316mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000754  CABC 000000FF           1317mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000075A  1A34 5000               1318mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0000075E                          1319mm     ENDM
0000075E  8805                    1320m         OR.B D5,D4
00000760  5307                    1321m         SUB.B #1,D7
00000762                          1322m     ENDW
00000762  6098                    1323ms     BRA _1000000E
00000764                          1324ms _1000000F
00000764                          1325m     
00000764  7A00                    1326m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000766  1A04                    1327m     MOVE.B D4,D5
00000768  D484                    1328m     ADD.L D4,D2
0000076A                          1329m 
0000076A                          1330m     ENDM
0000076A                          1331m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
0000076A  1E3C 0002               1332m     MOVE.B #2,D7
0000076E                          1333m     WHILE.B D7 <GT> 0 DO
0000076E                          1334ms _10000010
0000076E  BE38 0000               1335ms     CMP.B   0,D7
00000772  6F00 0062               1336ms     BLE _10000011
00000776  E98C                    1337m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00000778                          1338mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000778                          1339mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000778                          1340mm 
00000778  1A39 00C00003           1341mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0000077E  0805 0000               1342mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000782  6700 0010               1343mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
00000786                          1344mm  
00000786                          1345mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000786                 TRUE     1346mmm     IFEQ DEBUG
00000786  1A39 00C00007           1347mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000078C                          1348mmm     ENDC
0000078C                 FALSE    1349mmm     IFNE DEBUG
0000078C                          1350mmm     ENDC
0000078C                          1351mmm      
0000078C  BA3C 001B               1352mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000790  6700 F876               1353mmm     BEQ START
00000794                          1354mmm     ENDM
00000794                          1355mm CONTINUE_82
00000794  1A39 00C00013           1356mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000079A  0805 0000               1357mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000079E  67D8                    1358mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
000007A0                          1359mm     
000007A0  1A39 00C00017           1360mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007A6  13C5 00E00001           1361mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007AC                          1362mm     
000007AC                          1363mm     ENDM
000007AC                          1364mm         PRINT_CHAR D5,D6
000007AC                          1365mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007AC                 TRUE     1366mm     IFEQ DEBUG
000007AC  1C39 00C00003           1367mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000007B2  0806 0002               1368mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000007B6  67F4                    1369mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
000007B8  13C5 00C00007           1370mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007BE                          1371mm     ENDC
000007BE                          1372mm     
000007BE                 FALSE    1373mm     IFNE DEBUG
000007BE                          1374mm     ENDC
000007BE                          1375mm 
000007BE                          1376mm     ENDM
000007BE                          1377mm         HEX2BIN D5,D5,A4
000007BE  49FA 05ED               1378mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007C2  0405 0030               1379mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007C6  CABC 000000FF           1380mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007CC  1A34 5000               1381mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000007D0                          1382mm     ENDM
000007D0  8805                    1383m         OR.B D5,D4
000007D2  5307                    1384m         SUB.B #1,D7
000007D4                          1385m     ENDW
000007D4  6098                    1386ms     BRA _10000010
000007D6                          1387ms _10000011
000007D6                          1388m     
000007D6  7A00                    1389m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007D8  1A04                    1390m     MOVE.B D4,D5
000007DA  D484                    1391m     ADD.L D4,D2
000007DC                          1392m 
000007DC                          1393m     ENDM
000007DC                          1394                            
000007DC  2044                    1395                  MOVE.L D4,A0                    ; start address -> A0
000007DE  D1C9                    1396                  ADD.L A1,A0                         ; add in the offset
000007E0                          1397  
000007E0  72FF                    1398                  MOVE.L #$FFFFFFFF,D1             ; done
000007E2                          1399              ELSE
000007E2  6000 0078               1400s     BRA _00000009
000007E6                          1401s _00000008
000007E6                          1402m                 PRINT_CRLF D5,A4
000007E6  49FA 05F0               1403m     LEA CRLF(PC),A4
000007EA                          1404mm     PRINT_STR A4,D5
000007EA                          1405mm LOOP_87
000007EA  0C14 0000               1406mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000007EE  6700 0016               1407mm     BEQ EXIT_87
000007F2                          1408mmm     PRINT_CHAR (A4)+,D5
000007F2                          1409mmm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F2                 TRUE     1410mmm     IFEQ DEBUG
000007F2  1A39 00C00003           1411mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000007F8  0805 0002               1412mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000007FC  67F4                    1413mmm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
000007FE  13DC 00C00007           1414mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000804                          1415mmm     ENDC
00000804                          1416mmm     
00000804                 FALSE    1417mmm     IFNE DEBUG
00000804                          1418mmm     ENDC
00000804                          1419mmm 
00000804                          1420mmm     ENDM
00000804  60E4                    1421mm     BRA LOOP_87
00000806                          1422mm EXIT_87
00000806                          1423mm     ENDM
00000806                          1424m     ENDM
00000806                          1425              
00000806  49FA 055A               1426                  LEA UNREC(PC),A4                ; warn for unrecognised type
0000080A                          1427m                 PRINT_STR A4,D5
0000080A                          1428m LOOP_89
0000080A  0C14 0000               1429m     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000080E  6700 0016               1430m     BEQ EXIT_89
00000812                          1431mm     PRINT_CHAR (A4)+,D5
00000812                          1432mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000812                 TRUE     1433mm     IFEQ DEBUG
00000812  1A39 00C00003           1434mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000818  0805 0002               1435mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000081C  67F4                    1436mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
0000081E  13DC 00C00007           1437mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000824                          1438mm     ENDC
00000824                          1439mm     
00000824                 FALSE    1440mm     IFNE DEBUG
00000824                          1441mm     ENDC
00000824                          1442mm 
00000824                          1443mm     ENDM
00000824  60E4                    1444m     BRA LOOP_89
00000826                          1445m EXIT_89
00000826                          1446m     ENDM
00000826                          1447m                 PRINT_CHAR D1,D5
00000826                          1448m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000826                 TRUE     1449m     IFEQ DEBUG
00000826  1A39 00C00003           1450m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000082C  0805 0002               1451m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000830  67F4                    1452m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000832  13C1 00C00007           1453m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000838                          1454m     ENDC
00000838                          1455m     
00000838                 FALSE    1456m     IFNE DEBUG
00000838                          1457m     ENDC
00000838                          1458m 
00000838                          1459m     ENDM
00000838                          1460m                 PRINT_CRLF D5,A4
00000838  49FA 059E               1461m     LEA CRLF(PC),A4
0000083C                          1462mm     PRINT_STR A4,D5
0000083C                          1463mm LOOP_93
0000083C  0C14 0000               1464mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000840  6700 0016               1465mm     BEQ EXIT_93
00000844                          1466mmm     PRINT_CHAR (A4)+,D5
00000844                          1467mmm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000844                 TRUE     1468mmm     IFEQ DEBUG
00000844  1A39 00C00003           1469mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0000084A  0805 0002               1470mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000084E  67F4                    1471mmm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
00000850  13DC 00C00007           1472mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000856                          1473mmm     ENDC
00000856                          1474mmm     
00000856                 FALSE    1475mmm     IFNE DEBUG
00000856                          1476mmm     ENDC
00000856                          1477mmm 
00000856                          1478mmm     ENDM
00000856  60E4                    1479mm     BRA LOOP_93
00000858                          1480mm EXIT_93
00000858                          1481mm     ENDM
00000858                          1482m     ENDM
00000858                          1483              
00000858  6000 FAEC               1484                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0000085C                          1485              ENDI
0000085C                          1486s _00000009
0000085C                          1487          ENDI
0000085C                          1488s _00000007
0000085C                          1489      ENDI
0000085C                          1490s _00000003
0000085C                          1491      
0000085C                          1492m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0000085C  1E3C 0002               1493m     MOVE.B #2,D7
00000860                          1494m     WHILE.B D7 <GT> 0 DO
00000860                          1495ms _10000012
00000860  BE38 0000               1496ms     CMP.B   0,D7
00000864  6F00 0062               1497ms     BLE _10000013
00000868  E98C                    1498m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0000086A                          1499mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000086A                          1500mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000086A                          1501mm 
0000086A  1A39 00C00003           1502mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00000870  0805 0000               1503mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00000874  6700 0010               1504mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
00000878                          1505mm  
00000878                          1506mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00000878                 TRUE     1507mmm     IFEQ DEBUG
00000878  1A39 00C00007           1508mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000087E                          1509mmm     ENDC
0000087E                 FALSE    1510mmm     IFNE DEBUG
0000087E                          1511mmm     ENDC
0000087E                          1512mmm      
0000087E  BA3C 001B               1513mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00000882  6700 F784               1514mmm     BEQ START
00000886                          1515mmm     ENDM
00000886                          1516mm CONTINUE_96
00000886  1A39 00C00013           1517mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000088C  0805 0000               1518mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000890  67D8                    1519mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
00000892                          1520mm     
00000892  1A39 00C00017           1521mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000898  13C5 00E00001           1522mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000089E                          1523mm     
0000089E                          1524mm     ENDM
0000089E                          1525mm         PRINT_CHAR D5,D6
0000089E                          1526mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000089E                 TRUE     1527mm     IFEQ DEBUG
0000089E  1C39 00C00003           1528mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
000008A4  0806 0002               1529mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
000008A8  67F4                    1530mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000008AA  13C5 00C00007           1531mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008B0                          1532mm     ENDC
000008B0                          1533mm     
000008B0                 FALSE    1534mm     IFNE DEBUG
000008B0                          1535mm     ENDC
000008B0                          1536mm 
000008B0                          1537mm     ENDM
000008B0                          1538mm         HEX2BIN D5,D5,A4
000008B0  49FA 04FB               1539mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008B4  0405 0030               1540mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B8  CABC 000000FF           1541mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008BE  1A34 5000               1542mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
000008C2                          1543mm     ENDM
000008C2  8805                    1544m         OR.B D5,D4
000008C4  5307                    1545m         SUB.B #1,D7
000008C6                          1546m     ENDW
000008C6  6098                    1547ms     BRA _10000012
000008C8                          1548ms _10000013
000008C8                          1549m     
000008C8  7A00                    1550m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008CA  1A04                    1551m     MOVE.B D4,D5
000008CC  D484                    1552m     ADD.L D4,D2
000008CE                          1553m 
000008CE                          1554m     ENDM
000008CE                          1555m     PRINT_CRLF D5,A4
000008CE  49FA 0508               1556m     LEA CRLF(PC),A4
000008D2                          1557mm     PRINT_STR A4,D5
000008D2                          1558mm LOOP_101
000008D2  0C14 0000               1559mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008D6  6700 0016               1560mm     BEQ EXIT_101
000008DA                          1561mmm     PRINT_CHAR (A4)+,D5
000008DA                          1562mmm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DA                 TRUE     1563mmm     IFEQ DEBUG
000008DA  1A39 00C00003           1564mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000008E0  0805 0002               1565mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000008E4  67F4                    1566mmm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
000008E6  13DC 00C00007           1567mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000008EC                          1568mmm     ENDC
000008EC                          1569mmm     
000008EC                 FALSE    1570mmm     IFNE DEBUG
000008EC                          1571mmm     ENDC
000008EC                          1572mmm 
000008EC                          1573mmm     ENDM
000008EC  60E4                    1574mm     BRA LOOP_101
000008EE                          1575mm EXIT_101
000008EE                          1576mm     ENDM
000008EE                          1577m     ENDM
000008EE                          1578          
000008EE                          1579      IF.B D2 <NE> #$FF THEN.L
000008EE  B43C 00FF               1580s     CMP.B   #$FF,D2
000008F2  6700 0090               1581s     BEQ.L   _0000000A
000008F6  49FA 0481               1582          LEA CS_FAILURE(PC),A4                   ; warn for mismatched checksum
000008FA                          1583m         PRINT_STR A4,D5
000008FA                          1584m LOOP_103
000008FA  0C14 0000               1585m     CMP.B #NULL,(A4)                            ; 0 -> DONE
000008FE  6700 0016               1586m     BEQ EXIT_103
00000902                          1587mm     PRINT_CHAR (A4)+,D5
00000902                          1588mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000902                 TRUE     1589mm     IFEQ DEBUG
00000902  1A39 00C00003           1590mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000908  0805 0002               1591mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000090C  67F4                    1592mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000090E  13DC 00C00007           1593mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000914                          1594mm     ENDC
00000914                          1595mm     
00000914                 FALSE    1596mm     IFNE DEBUG
00000914                          1597mm     ENDC
00000914                          1598mm 
00000914                          1599mm     ENDM
00000914  60E4                    1600m     BRA LOOP_103
00000916                          1601m EXIT_103
00000916                          1602m     ENDM
00000916                          1603m         PRINT_REG D0,D5,D2,D6,A4
00000916  49FA 04C6               1604m     LEA OX(PC),A4
0000091A                          1605mm     PRINT_STR A4,D5
0000091A                          1606mm LOOP_106
0000091A  0C14 0000               1607mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
0000091E  6700 0016               1608mm     BEQ EXIT_106
00000922                          1609mmm     PRINT_CHAR (A4)+,D5
00000922                          1610mmm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000922                 TRUE     1611mmm     IFEQ DEBUG
00000922  1A39 00C00003           1612mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000928  0805 0002               1613mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0000092C  67F4                    1614mmm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000092E  13DC 00C00007           1615mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000934                          1616mmm     ENDC
00000934                          1617mmm     
00000934                 FALSE    1618mmm     IFNE DEBUG
00000934                          1619mmm     ENDC
00000934                          1620mmm 
00000934                          1621mmm     ENDM
00000934  60E4                    1622mm     BRA LOOP_106
00000936                          1623mm EXIT_106
00000936                          1624mm     ENDM
00000936  7C07                    1625m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000938                          1626m LOOP_105
00000938                          1627mm     BIN2HEX D0,D2,A4
00000938  49FA 0463               1628mm     LEA BIN2HEX_LUT(PC),A4                      ; LOAD THE LOOKUP TABLE
0000093C  E998                    1629mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000093E  1400                    1630mm     MOVE.B D0,D2
00000940  0282 0000000F           1631mm     ANDI.L #$F,D2
00000946  1434 2000               1632mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
0000094A                          1633mm     ENDM
0000094A                          1634mm     PRINT_CHAR D2,D5
0000094A                          1635mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094A                 TRUE     1636mm     IFEQ DEBUG
0000094A  1A39 00C00003           1637mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000950  0805 0002               1638mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000954  67F4                    1639mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000956  13C2 00C00007           1640mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000095C                          1641mm     ENDC
0000095C                          1642mm     
0000095C                 FALSE    1643mm     IFNE DEBUG
0000095C                          1644mm     ENDC
0000095C                          1645mm 
0000095C                          1646mm     ENDM
0000095C  57CE FFDA               1647m     DBEQ D6,LOOP_105
00000960                          1648m     ENDM
00000960                          1649m         PRINT_CRLF D5,A4
00000960  49FA 0476               1650m     LEA CRLF(PC),A4
00000964                          1651mm     PRINT_STR A4,D5
00000964                          1652mm LOOP_111
00000964  0C14 0000               1653mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000968  6700 0016               1654mm     BEQ EXIT_111
0000096C                          1655mmm     PRINT_CHAR (A4)+,D5
0000096C                          1656mmm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000096C                 TRUE     1657mmm     IFEQ DEBUG
0000096C  1A39 00C00003           1658mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000972  0805 0002               1659mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000976  67F4                    1660mmm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000978  13DC 00C00007           1661mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000097E                          1662mmm     ENDC
0000097E                          1663mmm     
0000097E                 FALSE    1664mmm     IFNE DEBUG
0000097E                          1665mmm     ENDC
0000097E                          1666mmm 
0000097E                          1667mmm     ENDM
0000097E  60E4                    1668mm     BRA LOOP_111
00000980                          1669mm EXIT_111
00000980                          1670mm     ENDM
00000980                          1671m     ENDM
00000980  6000 F7B0               1672          BRA MAIN_LOOP
00000984                          1673      ENDI
00000984                          1674s _0000000A
00000984                          1675      
00000984                          1676      IF D1 <EQ> #0 THEN
00000984  B27C 0000               1677s     CMP.W   #0,D1
00000988  6600 0006               1678s     BNE _0000000B
0000098C  6000 F9B8               1679        BRA WAIT_FOR_SRECORD            
00000990                          1680      ENDI
00000990                          1681s _0000000B
00000990                          1682  DOWNLOAD_DONE
00000990                          1683m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000990  43FA 044C               1684m     LEA OX(PC),A1
00000994                          1685mm     PRINT_STR A1,D5
00000994                          1686mm LOOP_114
00000994  0C11 0000               1687mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000998  6700 0016               1688mm     BEQ EXIT_114
0000099C                          1689mmm     PRINT_CHAR (A1)+,D5
0000099C                          1690mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099C                 TRUE     1691mmm     IFEQ DEBUG
0000099C  1A39 00C00003           1692mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009A2  0805 0002               1693mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009A6  67F4                    1694mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009A8  13D9 00C00007           1695mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009AE                          1696mmm     ENDC
000009AE                          1697mmm     
000009AE                 FALSE    1698mmm     IFNE DEBUG
000009AE                          1699mmm     ENDC
000009AE                          1700mmm 
000009AE                          1701mmm     ENDM
000009AE  60E4                    1702mm     BRA LOOP_114
000009B0                          1703mm EXIT_114
000009B0                          1704mm     ENDM
000009B0  7407                    1705m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009B2                          1706m LOOP_113
000009B2                          1707mm     BIN2HEX D0,D6,A1
000009B2  43FA 03E9               1708mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
000009B6  E998                    1709mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009B8  1C00                    1710mm     MOVE.B D0,D6
000009BA  0286 0000000F           1711mm     ANDI.L #$F,D6
000009C0  1C31 6000               1712mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
000009C4                          1713mm     ENDM
000009C4                          1714mm     PRINT_CHAR D6,D5
000009C4                          1715mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C4                 TRUE     1716mm     IFEQ DEBUG
000009C4  1A39 00C00003           1717mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009CA  0805 0002               1718mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009CE  67F4                    1719mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
000009D0  13C6 00C00007           1720mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009D6                          1721mm     ENDC
000009D6                          1722mm     
000009D6                 FALSE    1723mm     IFNE DEBUG
000009D6                          1724mm     ENDC
000009D6                          1725mm 
000009D6                          1726mm     ENDM
000009D6  57CA FFDA               1727m     DBEQ D2,LOOP_113
000009DA                          1728m     ENDM
000009DA  43FA 0364               1729      LEA READ(PC),A1
000009DE                          1730m     PRINT_STR A1,D5
000009DE                          1731m LOOP_118
000009DE  0C11 0000               1732m     CMP.B #NULL,(A1)                            ; 0 -> DONE
000009E2  6700 0016               1733m     BEQ EXIT_118
000009E6                          1734mm     PRINT_CHAR (A1)+,D5
000009E6                          1735mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1736mm     IFEQ DEBUG
000009E6  1A39 00C00003           1737mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
000009EC  0805 0002               1738mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1739mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
000009F2  13D9 00C00007           1740mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000009F8                          1741mm     ENDC
000009F8                          1742mm     
000009F8                 FALSE    1743mm     IFNE DEBUG
000009F8                          1744mm     ENDC
000009F8                          1745mm 
000009F8                          1746mm     ENDM
000009F8  60E4                    1747m     BRA LOOP_118
000009FA                          1748m EXIT_118
000009FA                          1749m     ENDM
000009FA  2E08                    1750      MOVE.L A0,D7                                    ; set address accumulator to start address
000009FC                          1751m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
000009FC  43FA 03E0               1752m     LEA OX(PC),A1
00000A00                          1753mm     PRINT_STR A1,D5
00000A00                          1754mm LOOP_121
00000A00  0C11 0000               1755mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000A04  6700 0016               1756mm     BEQ EXIT_121
00000A08                          1757mmm     PRINT_CHAR (A1)+,D5
00000A08                          1758mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A08                 TRUE     1759mmm     IFEQ DEBUG
00000A08  1A39 00C00003           1760mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A0E  0805 0002               1761mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A12  67F4                    1762mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000A14  13D9 00C00007           1763mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A1A                          1764mmm     ENDC
00000A1A                          1765mmm     
00000A1A                 FALSE    1766mmm     IFNE DEBUG
00000A1A                          1767mmm     ENDC
00000A1A                          1768mmm 
00000A1A                          1769mmm     ENDM
00000A1A  60E4                    1770mm     BRA LOOP_121
00000A1C                          1771mm EXIT_121
00000A1C                          1772mm     ENDM
00000A1C  7407                    1773m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A1E                          1774m LOOP_120
00000A1E                          1775mm     BIN2HEX D7,D6,A1
00000A1E  43FA 037D               1776mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000A22  E99F                    1777mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A24  1C07                    1778mm     MOVE.B D7,D6
00000A26  0286 0000000F           1779mm     ANDI.L #$F,D6
00000A2C  1C31 6000               1780mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000A30                          1781mm     ENDM
00000A30                          1782mm     PRINT_CHAR D6,D5
00000A30                          1783mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A30                 TRUE     1784mm     IFEQ DEBUG
00000A30  1A39 00C00003           1785mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A36  0805 0002               1786mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A3A  67F4                    1787mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A3C  13C6 00C00007           1788mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A42                          1789mm     ENDC
00000A42                          1790mm     
00000A42                 FALSE    1791mm     IFNE DEBUG
00000A42                          1792mm     ENDC
00000A42                          1793mm 
00000A42                          1794mm     ENDM
00000A42  57CA FFDA               1795m     DBEQ D2,LOOP_120
00000A46                          1796m     ENDM
00000A46                          1797m     PRINT_CRLF D5,A4     
00000A46  49FA 0390               1798m     LEA CRLF(PC),A4
00000A4A                          1799mm     PRINT_STR A4,D5
00000A4A                          1800mm LOOP_126
00000A4A  0C14 0000               1801mm     CMP.B #NULL,(A4)                            ; 0 -> DONE
00000A4E  6700 0016               1802mm     BEQ EXIT_126
00000A52                          1803mmm     PRINT_CHAR (A4)+,D5
00000A52                          1804mmm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A52                 TRUE     1805mmm     IFEQ DEBUG
00000A52  1A39 00C00003           1806mmm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00000A58  0805 0002               1807mmm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00000A5C  67F4                    1808mmm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00000A5E  13DC 00C00007           1809mmm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000A64                          1810mmm     ENDC
00000A64                          1811mmm     
00000A64                 FALSE    1812mmm     IFNE DEBUG
00000A64                          1813mmm     ENDC
00000A64                          1814mmm 
00000A64                          1815mmm     ENDM
00000A64  60E4                    1816mm     BRA LOOP_126
00000A66                          1817mm EXIT_126
00000A66                          1818mm     ENDM
00000A66                          1819m     ENDM
00000A66                          1820          
00000A66  6000 F6CA               1821      BRA MAIN_LOOP
00000A6A                          1822      
00000A6A                          1823  G
00000A6A  2047                    1824      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A6C  3E3C 0000               1825      MOVE #0,D7                                      ; clear the now used address accumulator
00000A70  4ED0                    1826      JMP (A0)                                        ; jump to it!
00000A72                          1827      
00000A72                          1828  Z
00000A72  207C 00200000           1829      MOVE.L #RAM,A0                                  ; address of RAM
00000A78                          1830      
00000A78                          1831      FOR.L D0 = #0 TO #$40000 BY #4 DO             ; write
00000A78  7000                    1832s     MOVE.L  #0,D0
00000A7A  6000 0012               1833s     BRA _20000005
00000A7E                          1834s _20000004
00000A7E  2200                    1835          MOVE.L D0,D1                              ; progress update
00000A80  E089                    1836          LSR.L #8,D1 
00000A82  E089                    1837          LSR.L #8,D1
00000A84  13C1 00E00001           1838          MOVE.B D1,DISPLAY
00000A8A                          1839  
00000A8A  20C0                    1840          MOVE.L D0,(A0)+
00000A8C                          1841      ENDF
00000A8C  5880                    1842s     ADD.L   #4,D0
00000A8E                          1843s _20000005
00000A8E  B0BC 00040000           1844s     CMP.L   #$40000,D0
00000A94  6FE8                    1845s     BLE _20000004
00000A96                          1846   
00000A96  207C 00200000           1847      MOVE.L #RAM,A0                                    ; address of RAM
00000A9C                          1848     
00000A9C                          1849      FOR.L D0 = #0 TO #$40000 BY #4 DO               ; read back and check 
00000A9C  7000                    1850s     MOVE.L  #0,D0
00000A9E  6000 00A6               1851s     BRA _20000007
00000AA2                          1852s _20000006
00000AA2  2200                    1853          MOVE.L D0,D1                              ; progress update
00000AA4  E089                    1854          LSR.L #8,D1
00000AA6  E089                    1855          LSR.L #8,D1
00000AA8  13C1 00E00001           1856          MOVE.B D1,DISPLAY
00000AAE                          1857  
00000AAE  2218                    1858          MOVE.L (A0)+,D1
00000AB0                          1859            
00000AB0                          1860          IF.L D0 <NE> D1 THEN      
00000AB0  B081                    1861s     CMP.L   D1,D0
00000AB2  6700 0090               1862s     BEQ _0000000C
00000AB6  43FA 02D3               1863              LEA RAM_ERROR(PC),A1
00000ABA                          1864m             PRINT_STR A1,D1
00000ABA                          1865m LOOP_128
00000ABA  0C11 0000               1866m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000ABE  6700 0016               1867m     BEQ EXIT_128
00000AC2                          1868mm     PRINT_CHAR (A1)+,D1
00000AC2                          1869mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC2                 TRUE     1870mm     IFEQ DEBUG
00000AC2  1239 00C00003           1871mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000AC8  0801 0002               1872mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000ACC  67F4                    1873mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000ACE  13D9 00C00007           1874mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AD4                          1875mm     ENDC
00000AD4                          1876mm     
00000AD4                 FALSE    1877mm     IFNE DEBUG
00000AD4                          1878mm     ENDC
00000AD4                          1879mm 
00000AD4                          1880mm     ENDM
00000AD4  60E4                    1881m     BRA LOOP_128
00000AD6                          1882m EXIT_128
00000AD6                          1883m     ENDM
00000AD6  2208                    1884              MOVE.L A0,D1
00000AD8  5981                    1885              SUB.L #4,D1
00000ADA                          1886m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000ADA  43FA 0302               1887m     LEA OX(PC),A1
00000ADE                          1888mm     PRINT_STR A1,D3
00000ADE                          1889mm LOOP_131
00000ADE  0C11 0000               1890mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000AE2  6700 0016               1891mm     BEQ EXIT_131
00000AE6                          1892mmm     PRINT_CHAR (A1)+,D3
00000AE6                          1893mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE6                 TRUE     1894mmm     IFEQ DEBUG
00000AE6  1639 00C00003           1895mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AEC  0803 0002               1896mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AF0  67F4                    1897mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000AF2  13D9 00C00007           1898mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AF8                          1899mmm     ENDC
00000AF8                          1900mmm     
00000AF8                 FALSE    1901mmm     IFNE DEBUG
00000AF8                          1902mmm     ENDC
00000AF8                          1903mmm 
00000AF8                          1904mmm     ENDM
00000AF8  60E4                    1905mm     BRA LOOP_131
00000AFA                          1906mm EXIT_131
00000AFA                          1907mm     ENDM
00000AFA  7C07                    1908m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AFC                          1909m LOOP_130
00000AFC                          1910mm     BIN2HEX D1,D2,A1
00000AFC  43FA 029F               1911mm     LEA BIN2HEX_LUT(PC),A1                      ; LOAD THE LOOKUP TABLE
00000B00  E999                    1912mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B02  1401                    1913mm     MOVE.B D1,D2
00000B04  0282 0000000F           1914mm     ANDI.L #$F,D2
00000B0A  1431 2000               1915mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000B0E                          1916mm     ENDM
00000B0E                          1917mm     PRINT_CHAR D2,D3
00000B0E                          1918mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0E                 TRUE     1919mm     IFEQ DEBUG
00000B0E  1639 00C00003           1920mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B14  0803 0002               1921mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B18  67F4                    1922mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B1A  13C2 00C00007           1923mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B20                          1924mm     ENDC
00000B20                          1925mm     
00000B20                 FALSE    1926mm     IFNE DEBUG
00000B20                          1927mm     ENDC
00000B20                          1928mm 
00000B20                          1929mm     ENDM
00000B20  57CE FFDA               1930m     DBEQ D6,LOOP_130
00000B24                          1931m     ENDM
00000B24                          1932m             PRINT_CRLF D3,A1
00000B24  43FA 02B2               1933m     LEA CRLF(PC),A1
00000B28                          1934mm     PRINT_STR A1,D3
00000B28                          1935mm LOOP_136
00000B28  0C11 0000               1936mm     CMP.B #NULL,(A1)                            ; 0 -> DONE
00000B2C  6700 0016               1937mm     BEQ EXIT_136
00000B30                          1938mmm     PRINT_CHAR (A1)+,D3
00000B30                          1939mmm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                 TRUE     1940mmm     IFEQ DEBUG
00000B30  1639 00C00003           1941mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B36  0803 0002               1942mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B3A  67F4                    1943mmm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00000B3C  13D9 00C00007           1944mmm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B42                          1945mmm     ENDC
00000B42                          1946mmm     
00000B42                 FALSE    1947mmm     IFNE DEBUG
00000B42                          1948mmm     ENDC
00000B42                          1949mmm 
00000B42                          1950mmm     ENDM
00000B42  60E4                    1951mm     BRA LOOP_136
00000B44                          1952mm EXIT_136
00000B44                          1953mm     ENDM
00000B44                          1954m     ENDM
00000B44                          1955          ENDI 
00000B44                          1956s _0000000C
00000B44                          1957      ENDF
00000B44  5880                    1958s     ADD.L   #4,D0
00000B46                          1959s _20000007
00000B46  B0BC 00040000           1960s     CMP.L   #$40000,D0
00000B4C  6F00 FF54               1961s     BLE _20000006
00000B50                          1962      
00000B50  6000 F5E0               1963      BRA MAIN_LOOP
00000B54                          1964    
00000B54                          1965  L
00000B54  7A00                    1966      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00000B56                          1967  
00000B56                          1968      FOR D6 = #0 TO #3 DO                          ; read the length to write
00000B56  3C3C 0000               1969s     MOVE.W  #0,D6
00000B5A  6000 0046               1970s     BRA _20000009
00000B5E                          1971s _20000008
00000B5E  E98D                    1972          LSL.L #4,D5                                 ; make what we have so far more significant
00000B60                          1973m         WAIT_CHAR D2,D3                             ; next character -> D2
00000B60                          1974m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B60                 TRUE     1975m     IFEQ DEBUG
00000B60  1639 00C00003           1976m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B66  0803 0000               1977m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000B6A  67F4                    1978m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00000B6C                          1979m     ENDC
00000B6C                          1980m     
00000B6C                          1981mm     READ_CHAR D2
00000B6C                 TRUE     1982mm     IFEQ DEBUG
00000B6C  1439 00C00007           1983mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000B72                          1984mm     ENDC
00000B72                 FALSE    1985mm     IFNE DEBUG
00000B72                          1986mm     ENDC
00000B72                          1987mm      
00000B72  B43C 001B               1988mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000B76  6700 F490               1989mm     BEQ START
00000B7A                          1990mm     ENDM
00000B7A                          1991m 
00000B7A                 TRUE     1992m     IFEQ DEBUG
00000B7A                          1993mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000B7A                          1994mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7A                 TRUE     1995mm     IFEQ DEBUG
00000B7A  1639 00C00003           1996mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B80  0803 0002               1997mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B84  67F4                    1998mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000B86  13C2 00C00007           1999mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B8C                          2000mm     ENDC
00000B8C                          2001mm     
00000B8C                 FALSE    2002mm     IFNE DEBUG
00000B8C                          2003mm     ENDC
00000B8C                          2004mm 
00000B8C                          2005mm     ENDM
00000B8C                          2006m     ENDC
00000B8C                          2007m     ENDM
00000B8C                          2008m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000B8C  41FA 021F               2009m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000B90  0402 0030               2010m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B94  C4BC 000000FF           2011m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000B9A  1430 2000               2012m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000B9E                          2013m     ENDM
00000B9E  8A02                    2014          OR.B D2,D5
00000BA0                          2015      ENDF
00000BA0  5246                    2016s     ADD.W   #1,D6
00000BA2                          2017s _20000009
00000BA2  BC7C 0003               2018s     CMP.W   #3,D6
00000BA6  6FB6                    2019s     BLE _20000008
00000BA8                          2020            
00000BA8                          2021m     PRINT_CRLF D3,A0
00000BA8  41FA 022E               2022m     LEA CRLF(PC),A0
00000BAC                          2023mm     PRINT_STR A0,D3
00000BAC                          2024mm LOOP_143
00000BAC  0C10 0000               2025mm     CMP.B #NULL,(A0)                            ; 0 -> DONE
00000BB0  6700 0016               2026mm     BEQ EXIT_143
00000BB4                          2027mmm     PRINT_CHAR (A0)+,D3
00000BB4                          2028mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB4                 TRUE     2029mmm     IFEQ DEBUG
00000BB4  1639 00C00003           2030mmm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BBA  0803 0002               2031mmm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BBE  67F4                    2032mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000BC0  13D8 00C00007           2033mmm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000BC6                          2034mmm     ENDC
00000BC6                          2035mmm     
00000BC6                 FALSE    2036mmm     IFNE DEBUG
00000BC6                          2037mmm     ENDC
00000BC6                          2038mmm 
00000BC6                          2039mmm     ENDM
00000BC6  60E4                    2040mm     BRA LOOP_143
00000BC8                          2041mm EXIT_143
00000BC8                          2042mm     ENDM
00000BC8                          2043m     ENDM
00000BC8                          2044  
00000BC8  207C 00000000           2045      MOVE.L #ROM,A0                                  ; start of ROM
00000BCE                          2046      
00000BCE  2247                    2047      MOVE.L D7,A1                                    ; address accumulator -> address register
00000BD0  7E00                    2048      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BD2                          2049      
00000BD2  31FC AAAA 2AAA          2050      MOVE.W #$AAAA,$2AAA
00000BD8  31FC 5555 1554          2051      MOVE.W #$5555,$1554
00000BDE  31FC 8080 2AAA          2052      MOVE.W #$8080,$2AAA
00000BE4  31FC AAAA 2AAA          2053      MOVE.W #$AAAA,$2AAA
00000BEA  31FC 5555 1554          2054      MOVE.W #$5555,$1554
00000BF0  31FC 2020 2AAA          2055      MOVE.W #$2020,$2AAA
00000BF6                          2056      
00000BF6  45FA 01CC               2057      LEA LOADING(PC),A2                          ; important for timing
00000BFA                          2058m     PRINT_STR A2,D3
00000BFA                          2059m LOOP_145
00000BFA  0C12 0000               2060m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00000BFE  6700 0016               2061m     BEQ EXIT_145
00000C02                          2062mm     PRINT_CHAR (A2)+,D3
00000C02                          2063mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C02                 TRUE     2064mm     IFEQ DEBUG
00000C02  1639 00C00003           2065mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C08  0803 0002               2066mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C0C  67F4                    2067mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C0E  13DA 00C00007           2068mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000C14                          2069mm     ENDC
00000C14                          2070mm     
00000C14                 FALSE    2071mm     IFNE DEBUG
00000C14                          2072mm     ENDC
00000C14                          2073mm 
00000C14                          2074mm     ENDM
00000C14  60E4                    2075m     BRA LOOP_145
00000C16                          2076m EXIT_145
00000C16                          2077m     ENDM
00000C16                          2078      
00000C16                          2079      WHILE D5 <GT> #0 DO
00000C16                          2080s _10000014
00000C16  BA7C 0000               2081s     CMP.W   #0,D5
00000C1A  6F00 001C               2082s     BLE _10000015
00000C1E  5585                    2083          SUB.L #2,D5
00000C20                          2084            
00000C20  13D1 00E00001           2085          MOVE.B (A1),DISPLAY
00000C26  3091                    2086          MOVE.W (A1),(A0)                            ; write the data
00000C28                          2087        
00000C28                          2088  WAIT_FOR_COMPLETE
00000C28  3410                    2089          MOVE.W (A0),D2
00000C2A                          2090  
00000C2A                          2091          IF D2 <NE> (A1) THEN
00000C2A  B451                    2092s     CMP.W   (A1),D2
00000C2C  6700 0004               2093s     BEQ _0000000D
00000C30  60F6                    2094              BRA WAIT_FOR_COMPLETE
00000C32                          2095          ENDI
00000C32                          2096s _0000000D
00000C32                          2097        
00000C32  5488                    2098          ADD.L #2,A0
00000C34  5489                    2099          ADD.L #2,A1
00000C36                          2100       ENDW    
00000C36  60DE                    2101s     BRA _10000014
00000C38                          2102s _10000015
00000C38                          2103      
00000C38  31FC AAAA 2AAA          2104      MOVE.W #$AAAA,$2AAA
00000C3E  31FC 5555 1554          2105      MOVE.W #$5555,$1554
00000C44  31FC A0A0 2AAA          2106      MOVE.W #$A0A0,$2AAA
00000C4A                          2107              
00000C4A  6000 F4E6               2108      BRA MAIN_LOOP
00000C4E                          2109          
00000C4E                          2110  HEX_DIGIT
00000C4E  E98F                    2111      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000C50                          2112m     HEX2BIN D2,D2,A0
00000C50  41FA 015B               2113m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C54  0402 0030               2114m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C58  C4BC 000000FF           2115m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000C5E  1430 2000               2116m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00000C62                          2117m     ENDM
00000C62  8E02                    2118      OR.B D2,D7  
00000C64  6000 F4EC               2119      BRA GET_INPUT
00000C68                          2120  
00000C68  FFFF FFFF               2121      SIMHALT                                         ; halt simulator
00000C6C                          2122  
00000C6C                          2123  ; strings
00000C6C= 4D 44 46 2D 6D 6F ...   2124  VERSION DC.B 'MDF-mon V1.59 (11/04/2021)',CR,LF,NULL
00000C89= 3F 09 09 09 68 65 ...   2125  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00000C93= 5B 76 5D 09 09 09 ...   2126          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00000CA2= 78 78 78 78 78 78 ...   2127          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000CBA= 78 78 78 78 78 78 ...   2128          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000CDA= 5B 73 5D 09 09 09 ...   2129          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00000CF4= 78 78 78 78 78 78 ...   2130          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00000D05= 5B 7A 5D 09 09 09 ...   2131          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00000D17= 78 78 78 78 78 78 ...   2132          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00000D39= 48 75 68 3F 0D 0A 00    2133  HUH     DC.B 'Huh?',CR,LF,NULL
00000D40= 20 53 20 72 65 63 ...   2134  READ    DC.B ' S records read, start address = ',NULL
00000D62= 57 3A 20 55 6E 6B ...   2135  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00000D79= 57 3A 20 43 53 20 ...   2136  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00000D8B= 57 3A 20 52 41 4D ...   2137  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00000D9D= 30 31 32 33 34 35 ...   2138  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000DAD= 00 01 02 03 04 05 ...   2139  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000DC4= 4C 6F 61 64 69 6E ...   2140  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000DD8= 0D 0A 00                2141  CRLF    DC.B CR,LF,NULL
00000DDB= 3E 20 00                2142  PROMPT  DC.B '> ',NULL
00000DDE= 30 78 00                2143  ox      DC.B '0x',NULL
00000DE1                          2144      
00000DE1                          2145      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         D9D
CONTINUE_37         362
CONTINUE_40         3B2
CONTINUE_44         408
CONTINUE_52         4BC
CONTINUE_57         52E
CONTINUE_62         5AA
CONTINUE_67         628
CONTINUE_72         6B0
CONTINUE_77         722
CONTINUE_82         794
CONTINUE_96         886
CR                  D
CRLF                DD8
CS_FAILURE          D79
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            948
DOWNLOAD_BYTE       C2D
DOWNLOAD_DONE       990
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_10             152
EXIT_101            8EE
EXIT_103            916
EXIT_106            936
EXIT_111            980
EXIT_114            9B0
EXIT_118            9FA
EXIT_121            A1C
EXIT_126            A66
EXIT_128            AD6
EXIT_131            AFA
EXIT_136            B44
EXIT_143            BC8
EXIT_145            C16
EXIT_16             1D6
EXIT_18             226
EXIT_20             252
EXIT_23             27C
EXIT_28             2C6
EXIT_3              E8
EXIT_35             33A
EXIT_49             478
EXIT_5              108
EXIT_8              128
EXIT_87             806
EXIT_89             826
EXIT_93             858
G                   A6A
GET_INPUT           152
H                   22A
HELP                C89
HEX2BIN             137
HEX2BIN_LUT         DAD
HEX_DIGIT           C4E
HUH                 D39
L                   B54
LF                  A
LOADING             DC4
LOOP_10             136
LOOP_101            8D2
LOOP_103            8FA
LOOP_105            938
LOOP_106            91A
LOOP_111            964
LOOP_113            9B2
LOOP_114            994
LOOP_118            9DE
LOOP_120            A1E
LOOP_121            A00
LOOP_126            A4A
LOOP_128            ABA
LOOP_130            AFC
LOOP_131            ADE
LOOP_136            B28
LOOP_143            BAC
LOOP_145            BFA
LOOP_16             1BA
LOOP_18             20A
LOOP_20             236
LOOP_22             27E
LOOP_23             260
LOOP_28             2AA
LOOP_3              CC
LOOP_35             31E
LOOP_49             45C
LOOP_5              EC
LOOP_8              10C
LOOP_87             7EA
LOOP_89             80A
LOOP_93             83C
MAIN_LOOP           132
NULL                0
OX                  DDE
PRINTSTR            236
PRINT_CHAR          289
PRINT_CRLF          4A3
PRINT_REG           55F
PRINT_STR           4D7
PROMPT              DDB
R                   256
RAM                 200000
RAM_ERROR           D8B
READ                D40
READ_CHAR           7E2
READ_DATA_TO_POKE   2CE
RESET               4
ROM                 0
S                   33E
STACK               0
START               8
TAB                 9
UNREC               D62
V                   232
VERSION             C6C
W                   2CA
WAIT_CHAR           633
WAIT_FOR_COMPLETE   C28
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_102  8DA
WAIT_FOR_READY_104  902
WAIT_FOR_READY_107  922
WAIT_FOR_READY_109  94A
WAIT_FOR_READY_11   13E
WAIT_FOR_READY_112  96C
WAIT_FOR_READY_115  99C
WAIT_FOR_READY_117  9C4
WAIT_FOR_READY_119  9E6
WAIT_FOR_READY_12   152
WAIT_FOR_READY_122  A08
WAIT_FOR_READY_124  A30
WAIT_FOR_READY_127  A52
WAIT_FOR_READY_129  AC2
WAIT_FOR_READY_132  AE6
WAIT_FOR_READY_134  B0E
WAIT_FOR_READY_137  B30
WAIT_FOR_READY_138  B60
WAIT_FOR_READY_14   16C
WAIT_FOR_READY_140  B7A
WAIT_FOR_READY_144  BB4
WAIT_FOR_READY_146  C02
WAIT_FOR_READY_17   1C2
WAIT_FOR_READY_19   212
WAIT_FOR_READY_21   23E
WAIT_FOR_READY_24   268
WAIT_FOR_READY_26   290
WAIT_FOR_READY_29   2B2
WAIT_FOR_READY_30   2D0
WAIT_FOR_READY_32   2EA
WAIT_FOR_READY_36   326
WAIT_FOR_READY_37   346
WAIT_FOR_READY_39   380
WAIT_FOR_READY_4    D4
WAIT_FOR_READY_40   396
WAIT_FOR_READY_42   3CA
WAIT_FOR_READY_44   3EC
WAIT_FOR_READY_46   420
WAIT_FOR_READY_50   464
WAIT_FOR_READY_52   4A0
WAIT_FOR_READY_54   4D4
WAIT_FOR_READY_57   512
WAIT_FOR_READY_59   546
WAIT_FOR_READY_6    F4
WAIT_FOR_READY_62   58E
WAIT_FOR_READY_64   5C2
WAIT_FOR_READY_67   60C
WAIT_FOR_READY_69   640
WAIT_FOR_READY_72   694
WAIT_FOR_READY_74   6C8
WAIT_FOR_READY_77   706
WAIT_FOR_READY_79   73A
WAIT_FOR_READY_82   778
WAIT_FOR_READY_84   7AC
WAIT_FOR_READY_88   7F2
WAIT_FOR_READY_9    114
WAIT_FOR_READY_90   812
WAIT_FOR_READY_91   826
WAIT_FOR_READY_94   844
WAIT_FOR_READY_96   86A
WAIT_FOR_READY_98   89E
WAIT_FOR_SRECORD    346
Z                   A72
_00000000           192
_00000001           1A6
_00000002           480
_00000003           85C
_00000004           48E
_00000005           67C
_00000006           5F2
_00000007           85C
_00000008           7E6
_00000009           85C
_0000000A           984
_0000000B           990
_0000000C           B44
_0000000D           C32
_10000000           3E2
_10000001           44A
_10000002           496
_10000003           4FE
_10000004           508
_10000005           570
_10000006           584
_10000007           5EC
_10000008           5F6
_10000009           676
_1000000A           602
_1000000B           66A
_1000000C           68A
_1000000D           6F2
_1000000E           6FC
_1000000F           764
_10000010           76E
_10000011           7D6
_10000012           860
_10000013           8C8
_10000014           C16
_10000015           C38
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A7E
_20000005           A8E
_20000006           AA2
_20000007           B46
_20000008           B5E
_20000009           BA2
