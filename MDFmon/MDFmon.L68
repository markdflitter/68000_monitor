00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 10:12:51

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; checksum is failing again, sigh
00000000                             9  ; Replace JMP -> BRA, THEN.L
00000000                            10  ; revisit register usage in S record download
00000000                            11  ; should we just preload the LUTs at the start, rather than in each call to convert?
00000000                            12  ; revisit use of bytes and longs
00000000                            13  ; add simpler .W and .B variants of PRINT_REG, will reduce code a bit
00000000                            14  ; Review for any other savings
00000000                            15  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            16  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            17  
00000000                            18  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            19  ; keep track of highest address hit during srec download
00000000                            20  ; fix the reset vector so that it jumps to the start
00000000                            21  ; implement backspace
00000000                            22  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            23  ; fix being able to enter random chars when W'ing
00000000                            24  ; ram check at startup?  Not sure if this is a good idea!
00000000                            25  ; byte W?
00000000                            26  
00000000                            27      ORG  $0
00000000                            28      ;ORG  $200000
00000000                            29  
00000000  =00000000                 30  DEBUG               EQU 0
00000000                            31  
00000000                            32  ; constants
00000000  =00000000                 33  ROM                 EQU $0
00000000  =00200000                 34  RAM                 EQU $200000
00000000                            35     
00000000  =00C00000                 36  DUART_BASE          EQU $C00000
00000000  =00000000                 37  DUART_MRA_          EQU $0
00000000  =00000001                 38  DUART_CSRA_         EQU $1
00000000  =00000001                 39  DUART_SRA_          EQU $1
00000000  =00000002                 40  DUART_CRA_          EQU $2
00000000  =00000003                 41  DUART_TXA_          EQU $3
00000000  =00000003                 42  DUART_RXA_          EQU $3
00000000  =00000004                 43  DUART_ACR_          EQU $4
00000000  =00000005                 44  DUART_IMR_          EQU $5
00000000  =00000008                 45  DUART_MRB_          EQU $8
00000000  =00000009                 46  DUART_CSRB_         EQU $9
00000000  =00000009                 47  DUART_SRB_          EQU $9
00000000  =0000000A                 48  DUART_CRB_          EQU $A
00000000  =0000000B                 49  DUART_TXB_          EQU $B
00000000  =0000000B                 50  DUART_RXB_          EQU $B
00000000  =0000000C                 51  DUART_IVR_          EQU $C
00000000  =0000000D                 52  DUART_OPCR_         EQU $D
00000000  =0000000E                 53  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 54  DUART_RESET_OPR_    EQU $F
00000000                            55  
00000000  =00C00001                 56  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 57  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 58  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 59  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 60  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 61  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            62  
00000000  =00C00011                 63  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 64  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 65  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 66  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 67  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 68  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            69  
00000000  =00C00009                 70  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 71  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00000000                            87      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT,\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                               ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                               ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                          ; use that as an index into the LUT      
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           110          BTST #2,\2                              ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                    ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                     ; send the next character
00000000                           113      ENDC
00000000                           114      
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll
00000000                           125  PRINT_CRLF MACRO
00000000                           126      PRINT_CHAR #13,\1                           ; CR
00000000                           127      PRINT_CHAR #10,\1                           ; LF
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #0,(\1)                               ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      JMP LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           143  PRINT_REG MACRO
00000000                           144      PRINT_CHAR #'0',\2                          ;0x header
00000000                           145      PRINT_CHAR #'x',\2
00000000                           146      MOVE.L #7,\4                                ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152    
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           158  
00000000                           159      IFEQ DEBUG
00000000                           160          MOVE.B DUART_SRA,\2                     ; read status register
00000000                           161          BTST #0,\2                              ; check for character
00000000                           162          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00000000                           163      ENDC
00000000                           164      
00000000                           165      READ_CHAR \1
00000000                           166  
00000000                           167      IFEQ DEBUG
00000000                           168          PRINT_CHAR \1,\2                        ; echo it back
00000000                           169      ENDC
00000000                           170      ENDM
00000000                           171      
00000000                           172  ; read a char from the serial port - assumes that there is one!
00000000                           173  ; \ 1= data register for read char
00000000                           174  ; will stamp on D0 and D1 in debug mode
00000000                           175  READ_CHAR MACRO
00000000                           176      IFEQ DEBUG
00000000                           177          MOVE.B DUART_RXA,\1                     ; got a character, read it
00000000                           178      ENDC
00000000                           179      IFNE DEBUG
00000000                           180          MOVE.L #5,D0    
00000000                           181          TRAP #15                                ; read from keyboard in simulator
00000000                           182          MOVE.L D1,\1
00000000                           183      ENDC
00000000                           184       
00000000                           185      CMP.B #$1B,\1                               ; check for escape and go to start
00000000                           186      BEQ START
00000000                           187      ENDM
00000000                           188      
00000000                           189      
00000000                           190  ; read data from the download serial port
00000000                           191  ; \ 1= data register for read char
00000000                           192  DOWNLOAD MACRO
00000000                           193  WAIT_FOR_READY\@                                ; wait until the there is space to send
00000000                           194  
00000000                           195      MOVE.B DUART_SRA,\1                         ; check for command
00000000                           196      BTST #0,\1                                  ; check for character
00000000                           197      BEQ CONTINUE\@                              ; nothing, continue
00000000                           198   
00000000                           199      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00000000                           200  CONTINUE\@
00000000                           201      MOVE.B DUART_SRB,\1                         ; read download status register
00000000                           202      BTST #0,\1                                  ; check for character
00000000                           203      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           204      
00000000                           205      MOVE.B DUART_RXB,\1                         ; got a character, read it
00000000                           206      MOVE.B \1,DISPLAY                           ; echo to the display
00000000                           207      
00000000                           208      ENDM
00000000                           209      
00000000                           210  ; read two hex digits from the download serial port and convert to a byte
00000000                           211  ; \ 1= data register for read char, \2 result register, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           212  DOWNLOAD_BYTE MACRO
00000000                           213      MOVE.B #2,\4
00000000                           214      WHILE.B \4 <GT> 0 DO
00000000                           215          LSL.L #4,\2                    ; it's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000000                           216          DOWNLOAD \1
00000000                           217          PRINT_CHAR \1,\3
00000000                           218          HEX2BIN \1,\1,\6
00000000                           219          OR.B \1,\2
00000000                           220          SUB.B #1,\4
00000000                           221      ENDW
00000000                           222      
00000000                           223      MOVE.L #0,\1                        ; rextract latest byte of address and add into checksum
00000000                           224      MOVE.B \2,\1
00000000                           225      ADD.L \2,\5
00000000                           226  
00000000                           227      ENDM
00000000                           228      
00000000                           229  
00000000                           230  ; register catalogue
00000000                           231  ; D0 - used for simulator I/O
00000000                           232  ; D1 - used for simulator I/O
00000000                           233  ; D2 - read character
00000000                           234  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           235  ; D4 - count of S records read
00000000                           236  ; D5 - data to write / data read / byte count for S record load
00000000                           237  ; D6 - working register used in R/W and download
00000000                           238  ; D7 - address accumulator / reset by download
00000000                           239  ; A0 - address of string to print 
00000000                           240  
00000000                           241  ; start vector
00000000= 00000000                 242  STACK    DC.L $00000000                         ; STACK
00000004= 00000008                 243  RESET    DC.L START                             ; RESET
00000008                           244      
00000008                           245  ; start of program  
00000008                           246  START
00000008  13FC 0000 00E00001       247      MOVE.B #0,DISPLAY
00000010                           248  
00000010                           249  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       250      MOVE.B #$A,DUART_CRA                        ; disable rx & tx
00000018  13FC 0050 00C00005       251      MOVE.B #$50,DUART_CRA                       ; reset everyting
00000020  4E71                     252      NOP
00000022  13FC 0040 00C00005       253      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     254      NOP
0000002C  13FC 0030 00C00005       255      MOVE.B #$30,DUART_CRA
00000034  4E71                     256      NOP
00000036  13FC 0020 00C00005       257      MOVE.B #$20,DUART_CRA
0000003E  4E71                     258      NOP
00000040  13FC 0010 00C00005       259      MOVE.B #$10,DUART_CRA   
00000048                           260  
00000048  13FC 000A 00C00015       261      MOVE.B #$A,DUART_CRB                        ; disable rx & tx
00000050  13FC 0050 00C00015       262      MOVE.B #$50,DUART_CRB                       ; reset everyting
00000058  4E71                     263      NOP
0000005A  13FC 0040 00C00015       264      MOVE.B #$40,DUART_CRB           
00000062  4E71                     265      NOP
00000064  13FC 0030 00C00015       266      MOVE.B #$30,DUART_CRB
0000006C  4E71                     267      NOP
0000006E  13FC 0020 00C00015       268      MOVE.B #$20,DUART_CRB
00000076  4E71                     269      NOP
00000078  13FC 0010 00C00015       270      MOVE.B #$10,DUART_CRB   
00000080                           271  
00000080                           272  ;initialise UART
00000080  13FC 0000 00C00009       273      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00C0000B       274      MOVE.B #$0,DUART_IMR                        ; no interrupts, please            
00000090  13FC 0000 00C0001B       275      MOVE.B #$0,DUART_OPCR                       ; enable all outputs
00000098                           276  
00000098                           277  ; channel A
00000098  13FC 0013 00C00001       278      MOVE.B #$13,DUART_MRA                       ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00C00001       279      MOVE.B #$07,DUART_MRA                       ; 1 stop bit
000000A8  13FC 00CC 00C00003       280      MOVE.B #$CC,DUART_CSRA                      ; 9600 baud
000000B0  13FC 0005 00C00005       281      MOVE.B #$5,DUART_CRA                        ; enable rx & tx
000000B8                           282  
000000B8                           283  ; channel B
000000B8  13FC 0013 00C00011       284      MOVE.B #$13,DUART_MRB                       ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00C00011       285      MOVE.B #$07,DUART_MRB                       ; 1 stop bit
000000C8  13FC 00CC 00C00013       286      MOVE.B #$CC,DUART_CSRB                      ; 9600 baud
000000D0  13FC 0005 00C00015       287      MOVE.B #$5,DUART_CRB                        ; enable rx & tx
000000D8                           288  
000000D8                           289m     PRINT_CHAR '.',D3                           ; give the serial port chance to settle after reset
000000D8                           290m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      291m     IFEQ DEBUG
000000D8  1639 00C00003            292m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000DE  0803 0002                293m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000E2  67F4                     294m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00C00007       295m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
000000EC                           296m     ENDC
000000EC                           297m     
000000EC                 FALSE     298m     IFNE DEBUG
000000EC                           299m     ENDC
000000EC                           300m 
000000EC                           301m     ENDM
000000EC                           302  
000000EC  13FC 0001 00E00001       303      MOVE.B #1,DISPLAY
000000F4                           304         
000000F4                           305m     PRINT_CRLF D3
000000F4                           306mm     PRINT_CHAR #13,D3                           ; CR
000000F4                           307mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      308mm     IFEQ DEBUG
000000F4  1639 00C00003            309mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000000FA  0803 0002                310mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000000FE  67F4                     311mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00C00007       312mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000108                           313mm     ENDC
00000108                           314mm     
00000108                 FALSE     315mm     IFNE DEBUG
00000108                           316mm     ENDC
00000108                           317mm 
00000108                           318mm     ENDM
00000108                           319mm     PRINT_CHAR #10,D3                           ; LF
00000108                           320mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      321mm     IFEQ DEBUG
00000108  1639 00C00003            322mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000010E  0803 0002                323mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000112  67F4                     324mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00C00007       325mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000011C                           326mm     ENDC
0000011C                           327mm     
0000011C                 FALSE     328mm     IFNE DEBUG
0000011C                           329mm     ENDC
0000011C                           330mm 
0000011C                           331mm     ENDM
0000011C                           332m     ENDM
0000011C                           333  
0000011C  41F9 00000EC2            334      LEA VERSION,A0
00000122                           335m     PRINT_STR A0,D3
00000122                           336m LOOP_5
00000122  0C10 0000                337m     CMP.B #0,(A0)                               ; 0 -> DONE
00000126  6700 0018                338m     BEQ EXIT_5
0000012A                           339mm     PRINT_CHAR (A0)+,D3
0000012A                           340mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      341mm     IFEQ DEBUG
0000012A  1639 00C00003            342mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000130  0803 0002                343mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000134  67F4                     344mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            345mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000013C                           346mm     ENDC
0000013C                           347mm     
0000013C                 FALSE     348mm     IFNE DEBUG
0000013C                           349mm     ENDC
0000013C                           350mm 
0000013C                           351mm     ENDM
0000013C  4EF8 0122                352m     JMP LOOP_5
00000140                           353m EXIT_5
00000140                           354m     ENDM
00000140                           355m     PRINT_CRLF D3
00000140                           356mm     PRINT_CHAR #13,D3                           ; CR
00000140                           357mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      358mm     IFEQ DEBUG
00000140  1639 00C00003            359mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000146  0803 0002                360mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000014A  67F4                     361mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00C00007       362mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000154                           363mm     ENDC
00000154                           364mm     
00000154                 FALSE     365mm     IFNE DEBUG
00000154                           366mm     ENDC
00000154                           367mm 
00000154                           368mm     ENDM
00000154                           369mm     PRINT_CHAR #10,D3                           ; LF
00000154                           370mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      371mm     IFEQ DEBUG
00000154  1639 00C00003            372mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000015A  0803 0002                373mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000015E  67F4                     374mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00C00007       375mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000168                           376mm     ENDC
00000168                           377mm     
00000168                 FALSE     378mm     IFNE DEBUG
00000168                           379mm     ENDC
00000168                           380mm 
00000168                           381mm     ENDM
00000168                           382m     ENDM
00000168                           383m     PRINT_CHAR #7,D3
00000168                           384m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      385m     IFEQ DEBUG
00000168  1639 00C00003            386m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000016E  0803 0002                387m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000172  67F4                     388m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00C00007       389m         MOVE.B #7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000017C                           390m     ENDC
0000017C                           391m     
0000017C                 FALSE     392m     IFNE DEBUG
0000017C                           393m     ENDC
0000017C                           394m 
0000017C                           395m     ENDM
0000017C                           396  
0000017C  7E00                     397      MOVE.L #0,D7                                ; address accumulator
0000017E                           398  
0000017E  13FC 0002 00E00001       399      MOVE.B #2,DISPLAY
00000186                           400  MAIN_LOOP
00000186                           401m     PRINT_CHAR #'>',D3                          ; prompt
00000186                           402m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      403m     IFEQ DEBUG
00000186  1639 00C00003            404m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000018C  0803 0002                405m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000190  67F4                     406m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00C00007       407m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
0000019A                           408m     ENDC
0000019A                           409m     
0000019A                 FALSE     410m     IFNE DEBUG
0000019A                           411m     ENDC
0000019A                           412m 
0000019A                           413m     ENDM
0000019A                           414m     PRINT_CHAR #32,D3                           ; space
0000019A                           415m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      416m     IFEQ DEBUG
0000019A  1639 00C00003            417m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001A0  0803 0002                418m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001A4  67F4                     419m         BEQ WAIT_FOR_READY_12                   ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00C00007       420m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
000001AE                           421m     ENDC
000001AE                           422m     
000001AE                 FALSE     423m     IFNE DEBUG
000001AE                           424m     ENDC
000001AE                           425m 
000001AE                           426m     ENDM
000001AE                           427      
000001AE                           428  GET_INPUT
000001AE                           429m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
000001AE                           430m WAIT_FOR_READY_13                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           431m 
000001AE                 TRUE      432m     IFEQ DEBUG
000001AE  1639 00C00003            433m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001B4  0803 0000                434m         BTST #0,D3                              ; CHECK FOR CHARACTER
000001B8  67F4                     435m         BEQ WAIT_FOR_READY_13                   ; NOTHING, CHECK AGAIN
000001BA                           436m     ENDC
000001BA                           437m     
000001BA                           438mm     READ_CHAR D2
000001BA                 TRUE      439mm     IFEQ DEBUG
000001BA  1439 00C00007            440mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000001C0                           441mm     ENDC
000001C0                 FALSE     442mm     IFNE DEBUG
000001C0                           443mm     ENDC
000001C0                           444mm      
000001C0  B43C 001B                445mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                446mm     BEQ START
000001C8                           447mm     ENDM
000001C8                           448m 
000001C8                 TRUE      449m     IFEQ DEBUG
000001C8                           450mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000001C8                           451mm WAIT_FOR_READY_15                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      452mm     IFEQ DEBUG
000001C8  1639 00C00003            453mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000001CE  0803 0002                454mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000001D2  67F4                     455mm         BEQ WAIT_FOR_READY_15                   ; NO SPACE, CHECK AGAIN
000001D4  13C2 00C00007            456mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000001DA                           457mm     ENDC
000001DA                           458mm     
000001DA                 FALSE     459mm     IFNE DEBUG
000001DA                           460mm     ENDC
000001DA                           461mm 
000001DA                           462mm     ENDM
000001DA                           463m     ENDC
000001DA                           464m     ENDM
000001DA                           465      
000001DA  B43C 0030                466      CMP.B #'0',D2
000001DE  6700 0CC2                467      BEQ HEX_DIGIT
000001E2  B43C 0031                468      CMP.B #'1',D2
000001E6  6700 0CBA                469      BEQ HEX_DIGIT
000001EA  B43C 0032                470      CMP.B #'2',D2
000001EE  6700 0CB2                471      BEQ HEX_DIGIT
000001F2  B43C 0033                472      CMP.B #'3',D2
000001F6  6700 0CAA                473      BEQ HEX_DIGIT
000001FA  B43C 0034                474      CMP.B #'4',D2
000001FE  6700 0CA2                475      BEQ HEX_DIGIT
00000202  B43C 0035                476      CMP.B #'5',D2
00000206  6700 0C9A                477      BEQ HEX_DIGIT
0000020A  B43C 0036                478      CMP.B #'6',D2
0000020E  6700 0C92                479      BEQ HEX_DIGIT
00000212  B43C 0037                480      CMP.B #'7',D2
00000216  6700 0C8A                481      BEQ HEX_DIGIT
0000021A  B43C 0038                482      CMP.B #'8',D2
0000021E  6700 0C82                483      BEQ HEX_DIGIT
00000222  B43C 0039                484      CMP.B #'9',D2
00000226  6700 0C7A                485      BEQ HEX_DIGIT
0000022A  B43C 0041                486      CMP.B #'A',D2
0000022E  6700 0C72                487      BEQ HEX_DIGIT
00000232  B43C 0042                488      CMP.B #'B',D2
00000236  6700 0C6A                489      BEQ HEX_DIGIT
0000023A  B43C 0043                490      CMP.B #'C',D2
0000023E  6700 0C62                491      BEQ HEX_DIGIT
00000242  B43C 0044                492      CMP.B #'D',D2
00000246  6700 0C5A                493      BEQ HEX_DIGIT
0000024A  B43C 0045                494      CMP.B #'E',D2
0000024E  6700 0C52                495      BEQ HEX_DIGIT
00000252  B43C 0046                496      CMP.B #'F',D2
00000256  6700 0C4A                497      BEQ HEX_DIGIT
0000025A                           498      
0000025A  B43C 0057                499      CMP.B #'W',D2
0000025E  6700 0160                500      BEQ W
00000262                           501      
00000262  B43C 004C                502      CMP.B #'L',D2
00000266  6700 0ACA                503      BEQ L 
0000026A                           504  
0000026A                           505m     PRINT_CRLF D3
0000026A                           506mm     PRINT_CHAR #13,D3                           ; CR
0000026A                           507mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      508mm     IFEQ DEBUG
0000026A  1639 00C00003            509mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000270  0803 0002                510mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000274  67F4                     511mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
00000276  13FC 000D 00C00007       512mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000027E                           513mm     ENDC
0000027E                           514mm     
0000027E                 FALSE     515mm     IFNE DEBUG
0000027E                           516mm     ENDC
0000027E                           517mm 
0000027E                           518mm     ENDM
0000027E                           519mm     PRINT_CHAR #10,D3                           ; LF
0000027E                           520mm WAIT_FOR_READY_18                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027E                 TRUE      521mm     IFEQ DEBUG
0000027E  1639 00C00003            522mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000284  0803 0002                523mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000288  67F4                     524mm         BEQ WAIT_FOR_READY_18                   ; NO SPACE, CHECK AGAIN
0000028A  13FC 000A 00C00007       525mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000292                           526mm     ENDC
00000292                           527mm     
00000292                 FALSE     528mm     IFNE DEBUG
00000292                           529mm     ENDC
00000292                           530mm 
00000292                           531mm     ENDM
00000292                           532m     ENDM
00000292                           533   
00000292  B43C 003F                534      CMP.B #'?',D2
00000296  6700 0052                535      BEQ H
0000029A                           536  
0000029A  B43C 0056                537      CMP.B #'V',D2
0000029E  6700 0072                538      BEQ V
000002A2                           539      
000002A2  B43C 0052                540      CMP.B #'R',D2
000002A6  6700 0092                541      BEQ R
000002AA                           542  
000002AA  B43C 0053                543      CMP.B #'S',D2
000002AE  6700 01D6                544      BEQ S
000002B2                           545  
000002B2  B43C 0047                546      CMP.B #'G',D2
000002B6  6700 096A                547      BEQ G   
000002BA                           548  
000002BA  B43C 005A                549      CMP.B #'Z',D2
000002BE  6700 096A                550      BEQ Z   
000002C2                           551  
000002C2  41F9 00000F76            552      LEA HUH,A0
000002C8                           553m     PRINT_STR A0,D3
000002C8                           554m LOOP_19
000002C8  0C10 0000                555m     CMP.B #0,(A0)                               ; 0 -> DONE
000002CC  6700 0018                556m     BEQ EXIT_19
000002D0                           557mm     PRINT_CHAR (A0)+,D3
000002D0                           558mm WAIT_FOR_READY_20                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002D0                 TRUE      559mm     IFEQ DEBUG
000002D0  1639 00C00003            560mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002D6  0803 0002                561mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000002DA  67F4                     562mm         BEQ WAIT_FOR_READY_20                   ; NO SPACE, CHECK AGAIN
000002DC  13D8 00C00007            563mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
000002E2                           564mm     ENDC
000002E2                           565mm     
000002E2                 FALSE     566mm     IFNE DEBUG
000002E2                           567mm     ENDC
000002E2                           568mm 
000002E2                           569mm     ENDM
000002E2  4EF8 02C8                570m     JMP LOOP_19
000002E6                           571m EXIT_19
000002E6                           572m     ENDM
000002E6                           573                         
000002E6  4EF8 0186                574      JMP MAIN_LOOP
000002EA                           575      
000002EA                           576  ; commands
000002EA                           577  H   
000002EA  41F9 00000EDF            578      LEA HELP,A0
000002F0                           579m     PRINT_STR A0,D3
000002F0                           580m LOOP_21
000002F0  0C10 0000                581m     CMP.B #0,(A0)                               ; 0 -> DONE
000002F4  6700 0018                582m     BEQ EXIT_21
000002F8                           583mm     PRINT_CHAR (A0)+,D3
000002F8                           584mm WAIT_FOR_READY_22                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F8                 TRUE      585mm     IFEQ DEBUG
000002F8  1639 00C00003            586mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000002FE  0803 0002                587mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000302  67F4                     588mm         BEQ WAIT_FOR_READY_22                   ; NO SPACE, CHECK AGAIN
00000304  13D8 00C00007            589mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000030A                           590mm     ENDC
0000030A                           591mm     
0000030A                 FALSE     592mm     IFNE DEBUG
0000030A                           593mm     ENDC
0000030A                           594mm 
0000030A                           595mm     ENDM
0000030A  4EF8 02F0                596m     JMP LOOP_21
0000030E                           597m EXIT_21
0000030E                           598m     ENDM
0000030E  4EF8 0186                599      JMP MAIN_LOOP
00000312                           600  
00000312                           601  V   
00000312  41F9 00000EC2            602      LEA VERSION,A0
00000318                           603m     PRINT_STR A0,D3       
00000318                           604m LOOP_23
00000318  0C10 0000                605m     CMP.B #0,(A0)                               ; 0 -> DONE
0000031C  6700 0018                606m     BEQ EXIT_23
00000320                           607mm     PRINT_CHAR (A0)+,D3
00000320                           608mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000320                 TRUE      609mm     IFEQ DEBUG
00000320  1639 00C00003            610mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000326  0803 0002                611mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000032A  67F4                     612mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
0000032C  13D8 00C00007            613mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000332                           614mm     ENDC
00000332                           615mm     
00000332                 FALSE     616mm     IFNE DEBUG
00000332                           617mm     ENDC
00000332                           618mm 
00000332                           619mm     ENDM
00000332  4EF8 0318                620m     JMP LOOP_23
00000336                           621m EXIT_23
00000336                           622m     ENDM
00000336  4EF8 0186                623      JMP MAIN_LOOP
0000033A                           624      
0000033A                           625  R   
0000033A  2047                     626      MOVE.L D7,A0                                ; address accumulator -> address register
0000033C  2A10                     627      MOVE.L (A0),D5                              ; read the memory and print it
0000033E                           628m     PRINT_REG D5,D3,D7,D6,A0
0000033E                           629mm     PRINT_CHAR #'0',D3                          ;0X HEADER
0000033E                           630mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033E                 TRUE      631mm     IFEQ DEBUG
0000033E  1639 00C00003            632mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000344  0803 0002                633mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000348  67F4                     634mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
0000034A  13FC 0030 00C00007       635mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000352                           636mm     ENDC
00000352                           637mm     
00000352                 FALSE     638mm     IFNE DEBUG
00000352                           639mm     ENDC
00000352                           640mm 
00000352                           641mm     ENDM
00000352                           642mm     PRINT_CHAR #'x',D3
00000352                           643mm WAIT_FOR_READY_27                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000352                 TRUE      644mm     IFEQ DEBUG
00000352  1639 00C00003            645mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000358  0803 0002                646mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000035C  67F4                     647mm         BEQ WAIT_FOR_READY_27                   ; NO SPACE, CHECK AGAIN
0000035E  13FC 0078 00C00007       648mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000366                           649mm     ENDC
00000366                           650mm     
00000366                 FALSE     651mm     IFNE DEBUG
00000366                           652mm     ENDC
00000366                           653mm 
00000366                           654mm     ENDM
00000366  7C07                     655m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000368                           656m LOOP_25
00000368                           657mm     BIN2HEX D5,D7,A0
00000368  41F9 00000FDA            658mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000036E  E99D                     659mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000370  1E05                     660mm     MOVE.B D5,D7
00000372  0287 0000000F            661mm     ANDI.L #$F,D7
00000378  1E30 7000                662mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
0000037C                           663mm     ENDM
0000037C                           664mm     PRINT_CHAR D7,D3
0000037C                           665mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037C                 TRUE      666mm     IFEQ DEBUG
0000037C  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000382  0803 0002                668mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000386  67F4                     669mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00000388  13C7 00C00007            670mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000038E                           671mm     ENDC
0000038E                           672mm     
0000038E                 FALSE     673mm     IFNE DEBUG
0000038E                           674mm     ENDC
0000038E                           675mm 
0000038E                           676mm     ENDM
0000038E  57CE FFD8                677m     DBEQ D6,LOOP_25
00000392                           678m     ENDM
00000392                           679m     PRINT_CRLF D3
00000392                           680mm     PRINT_CHAR #13,D3                           ; CR
00000392                           681mm WAIT_FOR_READY_31                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000392                 TRUE      682mm     IFEQ DEBUG
00000392  1639 00C00003            683mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000398  0803 0002                684mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000039C  67F4                     685mm         BEQ WAIT_FOR_READY_31                   ; NO SPACE, CHECK AGAIN
0000039E  13FC 000D 00C00007       686mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003A6                           687mm     ENDC
000003A6                           688mm     
000003A6                 FALSE     689mm     IFNE DEBUG
000003A6                           690mm     ENDC
000003A6                           691mm 
000003A6                           692mm     ENDM
000003A6                           693mm     PRINT_CHAR #10,D3                           ; LF
000003A6                           694mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A6                 TRUE      695mm     IFEQ DEBUG
000003A6  1639 00C00003            696mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003AC  0803 0002                697mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003B0  67F4                     698mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
000003B2  13FC 000A 00C00007       699mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000003BA                           700mm     ENDC
000003BA                           701mm     
000003BA                 FALSE     702mm     IFNE DEBUG
000003BA                           703mm     ENDC
000003BA                           704mm 
000003BA                           705mm     ENDM
000003BA                           706m     ENDM
000003BA  7E00                     707      MOVE.L #0,D7                                ; clear the now used address accumulator
000003BC  4EF8 0186                708      JMP MAIN_LOOP
000003C0                           709  
000003C0                           710  W
000003C0  7A00                     711      MOVE.L #0,D5                                ; D5 will be the value to write            
000003C2                           712  
000003C2                           713m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
000003C2                           714m WAIT_FOR_READY_33                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C2                           715m 
000003C2                 TRUE      716m     IFEQ DEBUG
000003C2  1639 00C00003            717m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003C8  0803 0000                718m         BTST #0,D3                              ; CHECK FOR CHARACTER
000003CC  67F4                     719m         BEQ WAIT_FOR_READY_33                   ; NOTHING, CHECK AGAIN
000003CE                           720m     ENDC
000003CE                           721m     
000003CE                           722mm     READ_CHAR D2
000003CE                 TRUE      723mm     IFEQ DEBUG
000003CE  1439 00C00007            724mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000003D4                           725mm     ENDC
000003D4                 FALSE     726mm     IFNE DEBUG
000003D4                           727mm     ENDC
000003D4                           728mm      
000003D4  B43C 001B                729mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000003D8  6700 FC2E                730mm     BEQ START
000003DC                           731mm     ENDM
000003DC                           732m 
000003DC                 TRUE      733m     IFEQ DEBUG
000003DC                           734mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
000003DC                           735mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      736mm     IFEQ DEBUG
000003DC  1639 00C00003            737mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000003E2  0803 0002                738mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000003E6  67F4                     739mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
000003E8  13C2 00C00007            740mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000003EE                           741mm     ENDC
000003EE                           742mm     
000003EE                 FALSE     743mm     IFNE DEBUG
000003EE                           744mm     ENDC
000003EE                           745mm 
000003EE                           746mm     ENDM
000003EE                           747m     ENDC
000003EE                           748m     ENDM
000003EE                           749m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000003EE  41F9 00000FEA            750m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000003F4  0402 0030                751m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003F8  C4BC 000000FF            752m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000003FE  1430 2000                753m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000402                           754m     ENDM
00000402  1A02                     755      MOVE.B D2,D5                                ; put at bottom of D5
00000404                           756  
00000404  3C3C 0006                757      MOVE #6,D6                                  ; 7 bytes left to read
00000408                           758      
00000408                           759  READ_DATA_TO_POKE
00000408  E98D                     760      LSL.L #4,D5                                 ; make what we have so far more significant
0000040A                           761m     WAIT_CHAR D2,D3                             ; next character -> D2
0000040A                           762m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040A                           763m 
0000040A                 TRUE      764m     IFEQ DEBUG
0000040A  1639 00C00003            765m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000410  0803 0000                766m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000414  67F4                     767m         BEQ WAIT_FOR_READY_37                   ; NOTHING, CHECK AGAIN
00000416                           768m     ENDC
00000416                           769m     
00000416                           770mm     READ_CHAR D2
00000416                 TRUE      771mm     IFEQ DEBUG
00000416  1439 00C00007            772mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000041C                           773mm     ENDC
0000041C                 FALSE     774mm     IFNE DEBUG
0000041C                           775mm     ENDC
0000041C                           776mm      
0000041C  B43C 001B                777mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000420  6700 FBE6                778mm     BEQ START
00000424                           779mm     ENDM
00000424                           780m 
00000424                 TRUE      781m     IFEQ DEBUG
00000424                           782mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000424                           783mm WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000424                 TRUE      784mm     IFEQ DEBUG
00000424  1639 00C00003            785mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000042A  0803 0002                786mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000042E  67F4                     787mm         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00000430  13C2 00C00007            788mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000436                           789mm     ENDC
00000436                           790mm     
00000436                 FALSE     791mm     IFNE DEBUG
00000436                           792mm     ENDC
00000436                           793mm 
00000436                           794mm     ENDM
00000436                           795m     ENDC
00000436                           796m     ENDM
00000436                           797m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000436  41F9 00000FEA            798m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000043C  0402 0030                799m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000440  C4BC 000000FF            800m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000446  1430 2000                801m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000044A                           802m     ENDM
0000044A  8A02                     803      OR.B D2,D5
0000044C  023C 00FB                804      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000450  57CE FFB6                805      DBEQ D6,READ_DATA_TO_POKE
00000454                           806      
00000454  2047                     807      MOVE.L D7,A0                                ; address accumulator -> address register
00000456  7E00                     808      MOVE.L #0,D7                                ; clear the now used address accumulator
00000458                           809      
00000458  2085                     810      MOVE.L D5,(A0)                              ; write the data
0000045A                           811  
0000045A                           812m     PRINT_CRLF D3
0000045A                           813mm     PRINT_CHAR #13,D3                           ; CR
0000045A                           814mm WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000045A                 TRUE      815mm     IFEQ DEBUG
0000045A  1639 00C00003            816mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000460  0803 0002                817mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000464  67F4                     818mm         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
00000466  13FC 000D 00C00007       819mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000046E                           820mm     ENDC
0000046E                           821mm     
0000046E                 FALSE     822mm     IFNE DEBUG
0000046E                           823mm     ENDC
0000046E                           824mm 
0000046E                           825mm     ENDM
0000046E                           826mm     PRINT_CHAR #10,D3                           ; LF
0000046E                           827mm WAIT_FOR_READY_43                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046E                 TRUE      828mm     IFEQ DEBUG
0000046E  1639 00C00003            829mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000474  0803 0002                830mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000478  67F4                     831mm         BEQ WAIT_FOR_READY_43                   ; NO SPACE, CHECK AGAIN
0000047A  13FC 000A 00C00007       832mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000482                           833mm     ENDC
00000482                           834mm     
00000482                 FALSE     835mm     IFNE DEBUG
00000482                           836mm     ENDC
00000482                           837mm 
00000482                           838mm     ENDM
00000482                           839m     ENDM
00000482  4EF8 0186                840      JMP MAIN_LOOP
00000486                           841  
00000486                           842          
00000486                           843  S
00000486  2647                     844      MOVE.L D7,A3                                ; grab the address accumulator
00000488  7800                     845      MOVE.L #0,D4                                ; count of records read -> D4
0000048A  2478 0000                846      MOVE.L 0,A2                                 ; start address -> A2
0000048E                           847      
0000048E                           848  WAIT_FOR_SRECORD                                ; wait for the start of a record, indicated by 'S'
0000048E                           849m     DOWNLOAD D2                 
0000048E                           850m WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048E                           851m 
0000048E  1439 00C00003            852m     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000494  0802 0000                853m     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000498  6700 0010                854m     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
0000049C                           855m  
0000049C                           856mm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000049C                 TRUE      857mm     IFEQ DEBUG
0000049C  1439 00C00007            858mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000004A2                           859mm     ENDC
000004A2                 FALSE     860mm     IFNE DEBUG
000004A2                           861mm     ENDC
000004A2                           862mm      
000004A2  B43C 001B                863mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000004A6  6700 FB60                864mm     BEQ START
000004AA                           865mm     ENDM
000004AA                           866m CONTINUE_44
000004AA  1439 00C00013            867m     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
000004B0  0802 0000                868m     BTST #0,D2                                  ; CHECK FOR CHARACTER
000004B4  67D8                     869m     BEQ WAIT_FOR_READY_44                       ; NOTHING, CHECK AGAIN
000004B6                           870m     
000004B6  1439 00C00017            871m     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
000004BC  13C2 00E00001            872m     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000004C2                           873m     
000004C2                           874m     ENDM
000004C2  B43C 0053                875      CMP.B #'S',D2                               ; found S?    
000004C6  66C6                     876      BNE WAIT_FOR_SRECORD                        ; nope, keep waiting
000004C8                           877      
000004C8                           878m     PRINT_CHAR #'S',D3                          ; print it
000004C8                           879m WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C8                 TRUE      880m     IFEQ DEBUG
000004C8  1639 00C00003            881m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000004CE  0803 0002                882m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000004D2  67F4                     883m         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
000004D4  13FC 0053 00C00007       884m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
000004DC                           885m     ENDC
000004DC                           886m     
000004DC                 FALSE     887m     IFNE DEBUG
000004DC                           888m     ENDC
000004DC                           889m 
000004DC                           890m     ENDM
000004DC  5284                     891      ADD.L #1,D4                                 ; read another S record, increment count
000004DE                           892      
000004DE                           893m     DOWNLOAD D0                                 ; read the record identifier
000004DE                           894m WAIT_FOR_READY_47                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DE                           895m 
000004DE  1039 00C00003            896m     MOVE.B DUART_SRA,D0                         ; CHECK FOR COMMAND
000004E4  0800 0000                897m     BTST #0,D0                                  ; CHECK FOR CHARACTER
000004E8  6700 0010                898m     BEQ CONTINUE_47                             ; NOTHING, CONTINUE
000004EC                           899m  
000004EC                           900mm     READ_CHAR D0                                ; WE're not going to do anything with it, just check for escape
000004EC                 TRUE      901mm     IFEQ DEBUG
000004EC  1039 00C00007            902mm         MOVE.B DUART_RXA,D0                     ; GOT A CHARACTER, READ IT
000004F2                           903mm     ENDC
000004F2                 FALSE     904mm     IFNE DEBUG
000004F2                           905mm     ENDC
000004F2                           906mm      
000004F2  B03C 001B                907mm     CMP.B #$1B,D0                               ; CHECK FOR ESCAPE AND GO TO START
000004F6  6700 FB10                908mm     BEQ START
000004FA                           909mm     ENDM
000004FA                           910m CONTINUE_47
000004FA  1039 00C00013            911m     MOVE.B DUART_SRB,D0                         ; READ DOWNLOAD STATUS REGISTER
00000500  0800 0000                912m     BTST #0,D0                                  ; CHECK FOR CHARACTER
00000504  67D8                     913m     BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000506                           914m     
00000506  1039 00C00017            915m     MOVE.B DUART_RXB,D0                         ; GOT A CHARACTER, READ IT
0000050C  13C0 00E00001            916m     MOVE.B D0,DISPLAY                           ; ECHO TO THE DISPLAY
00000512                           917m     
00000512                           918m     ENDM
00000512                           919m     PRINT_CHAR D0,D3                            ; print it
00000512                           920m WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE      921m     IFEQ DEBUG
00000512  1639 00C00003            922m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000518  0803 0002                923m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000051C  67F4                     924m         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
0000051E  13C0 00C00007            925m         MOVE.B D0,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000524                           926m     ENDC
00000524                           927m     
00000524                 FALSE     928m     IFNE DEBUG
00000524                           929m     ENDC
00000524                           930m 
00000524                           931m     ENDM
00000524                           932  
00000524  7C00                     933      MOVE.L #0,D6                                ; clear the checksum
00000526                           934  
00000526  7A00                     935      MOVE.L #0,D5                                ; read the 2 digit byte count -> D5
00000528                           936m     DOWNLOAD_BYTE D2,D5,D3,D1,D6,A0                                        
00000528  123C 0002                937m     MOVE.B #2,D1
0000052C                           938m     WHILE.B D1 <GT> 0 DO
0000052C                           939ms _10000000
0000052C  B238 0000                940ms     CMP.B   0,D1
00000530  6F00 0064                941ms     BLE _10000001
00000534  E98D                     942m         LSL.L #4,D5                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000536                           943mm         DOWNLOAD D2
00000536                           944mm WAIT_FOR_READY_51                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000536                           945mm 
00000536  1439 00C00003            946mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000053C  0802 0000                947mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000540  6700 0010                948mm     BEQ CONTINUE_51                             ; NOTHING, CONTINUE
00000544                           949mm  
00000544                           950mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000544                 TRUE      951mmm     IFEQ DEBUG
00000544  1439 00C00007            952mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000054A                           953mmm     ENDC
0000054A                 FALSE     954mmm     IFNE DEBUG
0000054A                           955mmm     ENDC
0000054A                           956mmm      
0000054A  B43C 001B                957mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000054E  6700 FAB8                958mmm     BEQ START
00000552                           959mmm     ENDM
00000552                           960mm CONTINUE_51
00000552  1439 00C00013            961mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000558  0802 0000                962mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000055C  67D8                     963mm     BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
0000055E                           964mm     
0000055E  1439 00C00017            965mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000564  13C2 00E00001            966mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000056A                           967mm     
0000056A                           968mm     ENDM
0000056A                           969mm         PRINT_CHAR D2,D3
0000056A                           970mm WAIT_FOR_READY_53                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056A                 TRUE      971mm     IFEQ DEBUG
0000056A  1639 00C00003            972mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000570  0803 0002                973mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000574  67F4                     974mm         BEQ WAIT_FOR_READY_53                   ; NO SPACE, CHECK AGAIN
00000576  13C2 00C00007            975mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000057C                           976mm     ENDC
0000057C                           977mm     
0000057C                 FALSE     978mm     IFNE DEBUG
0000057C                           979mm     ENDC
0000057C                           980mm 
0000057C                           981mm     ENDM
0000057C                           982mm         HEX2BIN D2,D2,A0
0000057C  41F9 00000FEA            983mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000582  0402 0030                984mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000586  C4BC 000000FF            985mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000058C  1430 2000                986mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000590                           987mm     ENDM
00000590  8A02                     988m         OR.B D2,D5
00000592  5301                     989m         SUB.B #1,D1
00000594                           990m     ENDW
00000594  6096                     991ms     BRA _10000000
00000596                           992ms _10000001
00000596                           993m     
00000596  7400                     994m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000598  1405                     995m     MOVE.B D5,D2
0000059A  DC85                     996m     ADD.L D5,D6
0000059C                           997m 
0000059C                           998m     ENDM
0000059C                           999  
0000059C                          1000      IF.B D0 <EQ> #'0' THEN.L                    ; header, just ignore it
0000059C  B03C 0030               1001s     CMP.B   #'0',D0
000005A0  6600 0032               1002s     BNE.L   _00000000
000005A4                          1003m         PRINT_CRLF D3
000005A4                          1004mm     PRINT_CHAR #13,D3                           ; CR
000005A4                          1005mm WAIT_FOR_READY_56                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A4                 TRUE     1006mm     IFEQ DEBUG
000005A4  1639 00C00003           1007mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005AA  0803 0002               1008mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005AE  67F4                    1009mm         BEQ WAIT_FOR_READY_56                   ; NO SPACE, CHECK AGAIN
000005B0  13FC 000D 00C00007      1010mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005B8                          1011mm     ENDC
000005B8                          1012mm     
000005B8                 FALSE    1013mm     IFNE DEBUG
000005B8                          1014mm     ENDC
000005B8                          1015mm 
000005B8                          1016mm     ENDM
000005B8                          1017mm     PRINT_CHAR #10,D3                           ; LF
000005B8                          1018mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B8                 TRUE     1019mm     IFEQ DEBUG
000005B8  1639 00C00003           1020mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000005BE  0803 0002               1021mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000005C2  67F4                    1022mm         BEQ WAIT_FOR_READY_57                   ; NO SPACE, CHECK AGAIN
000005C4  13FC 000A 00C00007      1023mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000005CC                          1024mm     ENDC
000005CC                          1025mm     
000005CC                 FALSE    1026mm     IFNE DEBUG
000005CC                          1027mm     ENDC
000005CC                          1028mm 
000005CC                          1029mm     ENDM
000005CC                          1030m     ENDM
000005CC  6000 FEC0               1031          BRA WAIT_FOR_SRECORD
000005D0                          1032      ELSE
000005D0  6000 040A               1033s     BRA _00000001
000005D4                          1034s _00000000
000005D4                          1035          IF.B D0 <EQ> #'1' OR.B D0 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
000005D4  B03C 0031               1036s     CMP.B   #'1',D0
000005D8  6708                    1037s     BEQ.S   _00000002
000005DA  B03C 0032               1038s     CMP.B   #'2',D0
000005DE  6600 0200               1039s     BNE.L   _00000003
000005E2                          1040s _00000002
000005E2  5785                    1041              SUB.L #3,D5                         ; subtract three bytes for 16 bit address and 1 byte checksum
000005E4                          1042      
000005E4  7E00                    1043              MOVE.L #0,D7                        ; read two bytes of address, we'll stomp on D7 for this since it's sort of like the address accumulator
000005E6                          1044m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; first byte                           
000005E6  123C 0002               1045m     MOVE.B #2,D1
000005EA                          1046m     WHILE.B D1 <GT> 0 DO
000005EA                          1047ms _10000002
000005EA  B238 0000               1048ms     CMP.B   0,D1
000005EE  6F00 0064               1049ms     BLE _10000003
000005F2  E98F                    1050m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000005F4                          1051mm         DOWNLOAD D2
000005F4                          1052mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F4                          1053mm 
000005F4  1439 00C00003           1054mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000005FA  0802 0000               1055mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000005FE  6700 0010               1056mm     BEQ CONTINUE_59                             ; NOTHING, CONTINUE
00000602                          1057mm  
00000602                          1058mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000602                 TRUE     1059mmm     IFEQ DEBUG
00000602  1439 00C00007           1060mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000608                          1061mmm     ENDC
00000608                 FALSE    1062mmm     IFNE DEBUG
00000608                          1063mmm     ENDC
00000608                          1064mmm      
00000608  B43C 001B               1065mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0000060C  6700 F9FA               1066mmm     BEQ START
00000610                          1067mmm     ENDM
00000610                          1068mm CONTINUE_59
00000610  1439 00C00013           1069mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000616  0802 0000               1070mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000061A  67D8                    1071mm     BEQ WAIT_FOR_READY_59                       ; NOTHING, CHECK AGAIN
0000061C                          1072mm     
0000061C  1439 00C00017           1073mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000622  13C2 00E00001           1074mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000628                          1075mm     
00000628                          1076mm     ENDM
00000628                          1077mm         PRINT_CHAR D2,D3
00000628                          1078mm WAIT_FOR_READY_61                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000628                 TRUE     1079mm     IFEQ DEBUG
00000628  1639 00C00003           1080mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000062E  0803 0002               1081mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000632  67F4                    1082mm         BEQ WAIT_FOR_READY_61                   ; NO SPACE, CHECK AGAIN
00000634  13C2 00C00007           1083mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000063A                          1084mm     ENDC
0000063A                          1085mm     
0000063A                 FALSE    1086mm     IFNE DEBUG
0000063A                          1087mm     ENDC
0000063A                          1088mm 
0000063A                          1089mm     ENDM
0000063A                          1090mm         HEX2BIN D2,D2,A0
0000063A  41F9 00000FEA           1091mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000640  0402 0030               1092mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000644  C4BC 000000FF           1093mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000064A  1430 2000               1094mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000064E                          1095mm     ENDM
0000064E  8E02                    1096m         OR.B D2,D7
00000650  5301                    1097m         SUB.B #1,D1
00000652                          1098m     ENDW
00000652  6096                    1099ms     BRA _10000002
00000654                          1100ms _10000003
00000654                          1101m     
00000654  7400                    1102m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000656  1407                    1103m     MOVE.B D7,D2
00000658  DC87                    1104m     ADD.L D7,D6
0000065A                          1105m 
0000065A                          1106m     ENDM
0000065A                          1107m             DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0     ; second one
0000065A  123C 0002               1108m     MOVE.B #2,D1
0000065E                          1109m     WHILE.B D1 <GT> 0 DO
0000065E                          1110ms _10000004
0000065E  B238 0000               1111ms     CMP.B   0,D1
00000662  6F00 0064               1112ms     BLE _10000005
00000666  E98F                    1113m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
00000668                          1114mm         DOWNLOAD D2
00000668                          1115mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000668                          1116mm 
00000668  1439 00C00003           1117mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
0000066E  0802 0000               1118mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000672  6700 0010               1119mm     BEQ CONTINUE_64                             ; NOTHING, CONTINUE
00000676                          1120mm  
00000676                          1121mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000676                 TRUE     1122mmm     IFEQ DEBUG
00000676  1439 00C00007           1123mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000067C                          1124mmm     ENDC
0000067C                 FALSE    1125mmm     IFNE DEBUG
0000067C                          1126mmm     ENDC
0000067C                          1127mmm      
0000067C  B43C 001B               1128mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000680  6700 F986               1129mmm     BEQ START
00000684                          1130mmm     ENDM
00000684                          1131mm CONTINUE_64
00000684  1439 00C00013           1132mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000068A  0802 0000               1133mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000068E  67D8                    1134mm     BEQ WAIT_FOR_READY_64                       ; NOTHING, CHECK AGAIN
00000690                          1135mm     
00000690  1439 00C00017           1136mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000696  13C2 00E00001           1137mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000069C                          1138mm     
0000069C                          1139mm     ENDM
0000069C                          1140mm         PRINT_CHAR D2,D3
0000069C                          1141mm WAIT_FOR_READY_66                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069C                 TRUE     1142mm     IFEQ DEBUG
0000069C  1639 00C00003           1143mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000006A2  0803 0002               1144mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000006A6  67F4                    1145mm         BEQ WAIT_FOR_READY_66                   ; NO SPACE, CHECK AGAIN
000006A8  13C2 00C00007           1146mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000006AE                          1147mm     ENDC
000006AE                          1148mm     
000006AE                 FALSE    1149mm     IFNE DEBUG
000006AE                          1150mm     ENDC
000006AE                          1151mm 
000006AE                          1152mm     ENDM
000006AE                          1153mm         HEX2BIN D2,D2,A0
000006AE  41F9 00000FEA           1154mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000006B4  0402 0030               1155mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B8  C4BC 000000FF           1156mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000006BE  1430 2000               1157mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000006C2                          1158mm     ENDM
000006C2  8E02                    1159m         OR.B D2,D7
000006C4  5301                    1160m         SUB.B #1,D1
000006C6                          1161m     ENDW
000006C6  6096                    1162ms     BRA _10000004
000006C8                          1163ms _10000005
000006C8                          1164m     
000006C8  7400                    1165m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006CA  1407                    1166m     MOVE.B D7,D2
000006CC  DC87                    1167m     ADD.L D7,D6
000006CE                          1168m 
000006CE                          1169m     ENDM
000006CE                          1170              
000006CE                          1171              IF.B D0 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
000006CE  B03C 0032               1172s     CMP.B   #'2',D0
000006D2  6600 0078               1173s     BNE.L   _00000004
000006D6  5385                    1174                  SUB.L #1,D5                     ; subtract an extra bytes for 24 bit address    
000006D8                          1175m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; 3rd byte       
000006D8  123C 0002               1176m     MOVE.B #2,D1
000006DC                          1177m     WHILE.B D1 <GT> 0 DO
000006DC                          1178ms _10000006
000006DC  B238 0000               1179ms     CMP.B   0,D1
000006E0  6F00 0064               1180ms     BLE _10000007
000006E4  E98F                    1181m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000006E6                          1182mm         DOWNLOAD D2
000006E6                          1183mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E6                          1184mm 
000006E6  1439 00C00003           1185mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000006EC  0802 0000               1186mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000006F0  6700 0010               1187mm     BEQ CONTINUE_69                             ; NOTHING, CONTINUE
000006F4                          1188mm  
000006F4                          1189mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000006F4                 TRUE     1190mmm     IFEQ DEBUG
000006F4  1439 00C00007           1191mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000006FA                          1192mmm     ENDC
000006FA                 FALSE    1193mmm     IFNE DEBUG
000006FA                          1194mmm     ENDC
000006FA                          1195mmm      
000006FA  B43C 001B               1196mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000006FE  6700 F908               1197mmm     BEQ START
00000702                          1198mmm     ENDM
00000702                          1199mm CONTINUE_69
00000702  1439 00C00013           1200mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000708  0802 0000               1201mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000070C  67D8                    1202mm     BEQ WAIT_FOR_READY_69                       ; NOTHING, CHECK AGAIN
0000070E                          1203mm     
0000070E  1439 00C00017           1204mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000714  13C2 00E00001           1205mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000071A                          1206mm     
0000071A                          1207mm     ENDM
0000071A                          1208mm         PRINT_CHAR D2,D3
0000071A                          1209mm WAIT_FOR_READY_71                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071A                 TRUE     1210mm     IFEQ DEBUG
0000071A  1639 00C00003           1211mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000720  0803 0002               1212mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000724  67F4                    1213mm         BEQ WAIT_FOR_READY_71                   ; NO SPACE, CHECK AGAIN
00000726  13C2 00C00007           1214mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000072C                          1215mm     ENDC
0000072C                          1216mm     
0000072C                 FALSE    1217mm     IFNE DEBUG
0000072C                          1218mm     ENDC
0000072C                          1219mm 
0000072C                          1220mm     ENDM
0000072C                          1221mm         HEX2BIN D2,D2,A0
0000072C  41F9 00000FEA           1222mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000732  0402 0030               1223mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000736  C4BC 000000FF           1224mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000073C  1430 2000               1225mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000740                          1226mm     ENDM
00000740  8E02                    1227m         OR.B D2,D7
00000742  5301                    1228m         SUB.B #1,D1
00000744                          1229m     ENDW
00000744  6096                    1230ms     BRA _10000006
00000746                          1231ms _10000007
00000746                          1232m     
00000746  7400                    1233m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000748  1407                    1234m     MOVE.B D7,D2
0000074A  DC87                    1235m     ADD.L D7,D6
0000074C                          1236m 
0000074C                          1237m     ENDM
0000074C                          1238              ENDI
0000074C                          1239s _00000004
0000074C                          1240              
0000074C  2247                    1241              MOVE.L D7,A1                        ; put the address in an address register, and we can now re-use D7
0000074E  D3CB                    1242              ADD.L A3,A1                         ; add in the offset
00000750                          1243  
00000750                          1244              WHILE.L D5 <GT> #0 DO               ; read the data bytes                
00000750                          1245s _10000008
00000750  BABC 00000000           1246s     CMP.L   #0,D5
00000756  6F00 0080               1247s     BLE _10000009
0000075A  7E00                    1248                  MOVE.L #0,D7                    ; D7 holds the byte
0000075C                          1249m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; read it                               
0000075C  123C 0002               1250m     MOVE.B #2,D1
00000760                          1251m     WHILE.B D1 <GT> 0 DO
00000760                          1252ms _1000000A
00000760  B238 0000               1253ms     CMP.B   0,D1
00000764  6F00 0064               1254ms     BLE _1000000B
00000768  E98F                    1255m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000076A                          1256mm         DOWNLOAD D2
0000076A                          1257mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076A                          1258mm 
0000076A  1439 00C00003           1259mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000770  0802 0000               1260mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000774  6700 0010               1261mm     BEQ CONTINUE_74                             ; NOTHING, CONTINUE
00000778                          1262mm  
00000778                          1263mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000778                 TRUE     1264mmm     IFEQ DEBUG
00000778  1439 00C00007           1265mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000077E                          1266mmm     ENDC
0000077E                 FALSE    1267mmm     IFNE DEBUG
0000077E                          1268mmm     ENDC
0000077E                          1269mmm      
0000077E  B43C 001B               1270mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000782  6700 F884               1271mmm     BEQ START
00000786                          1272mmm     ENDM
00000786                          1273mm CONTINUE_74
00000786  1439 00C00013           1274mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000078C  0802 0000               1275mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000790  67D8                    1276mm     BEQ WAIT_FOR_READY_74                       ; NOTHING, CHECK AGAIN
00000792                          1277mm     
00000792  1439 00C00017           1278mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000798  13C2 00E00001           1279mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000079E                          1280mm     
0000079E                          1281mm     ENDM
0000079E                          1282mm         PRINT_CHAR D2,D3
0000079E                          1283mm WAIT_FOR_READY_76                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000079E                 TRUE     1284mm     IFEQ DEBUG
0000079E  1639 00C00003           1285mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000007A4  0803 0002               1286mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000007A8  67F4                    1287mm         BEQ WAIT_FOR_READY_76                   ; NO SPACE, CHECK AGAIN
000007AA  13C2 00C00007           1288mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000007B0                          1289mm     ENDC
000007B0                          1290mm     
000007B0                 FALSE    1291mm     IFNE DEBUG
000007B0                          1292mm     ENDC
000007B0                          1293mm 
000007B0                          1294mm     ENDM
000007B0                          1295mm         HEX2BIN D2,D2,A0
000007B0  41F9 00000FEA           1296mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000007B6  0402 0030               1297mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007BA  C4BC 000000FF           1298mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000007C0  1430 2000               1299mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000007C4                          1300mm     ENDM
000007C4  8E02                    1301m         OR.B D2,D7
000007C6  5301                    1302m         SUB.B #1,D1
000007C8                          1303m     ENDW
000007C8  6096                    1304ms     BRA _1000000A
000007CA                          1305ms _1000000B
000007CA                          1306m     
000007CA  7400                    1307m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007CC  1407                    1308m     MOVE.B D7,D2
000007CE  DC87                    1309m     ADD.L D7,D6
000007D0                          1310m 
000007D0                          1311m     ENDM
000007D0                          1312                          
000007D0  12C7                    1313                  MOVE.B D7,(A1)+                 ; store it!
000007D2                          1314  
000007D2  5385                    1315                  SUB.L #1,D5                     ; 1 less byte to go
000007D4                          1316              ENDW
000007D4  6000 FF7A               1317s     BRA _10000008
000007D8                          1318s _10000009
000007D8                          1319          
000007D8  43F8 048E               1320              LEA WAIT_FOR_SRECORD,A1             ; next place to go
000007DC                          1321          ELSE
000007DC  6000 01FE               1322s     BRA _00000005
000007E0                          1323s _00000003
000007E0                          1324              IF.B D0 <EQ> #'8' THEN.L            ; termination record, exit
000007E0  B03C 0038               1325s     CMP.B   #'8',D0
000007E4  6600 016C               1326s     BNE.L   _00000006
000007E8  7E00                    1327                  MOVE.L #0,D7                    ; read the 24 bit start address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007EA                          1328m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; top byte  
000007EA  123C 0002               1329m     MOVE.B #2,D1
000007EE                          1330m     WHILE.B D1 <GT> 0 DO
000007EE                          1331ms _1000000C
000007EE  B238 0000               1332ms     CMP.B   0,D1
000007F2  6F00 0064               1333ms     BLE _1000000D
000007F6  E98F                    1334m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000007F8                          1335mm         DOWNLOAD D2
000007F8                          1336mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F8                          1337mm 
000007F8  1439 00C00003           1338mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000007FE  0802 0000               1339mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000802  6700 0010               1340mm     BEQ CONTINUE_79                             ; NOTHING, CONTINUE
00000806                          1341mm  
00000806                          1342mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
00000806                 TRUE     1343mmm     IFEQ DEBUG
00000806  1439 00C00007           1344mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
0000080C                          1345mmm     ENDC
0000080C                 FALSE    1346mmm     IFNE DEBUG
0000080C                          1347mmm     ENDC
0000080C                          1348mmm      
0000080C  B43C 001B               1349mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000810  6700 F7F6               1350mmm     BEQ START
00000814                          1351mmm     ENDM
00000814                          1352mm CONTINUE_79
00000814  1439 00C00013           1353mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000081A  0802 0000               1354mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
0000081E  67D8                    1355mm     BEQ WAIT_FOR_READY_79                       ; NOTHING, CHECK AGAIN
00000820                          1356mm     
00000820  1439 00C00017           1357mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000826  13C2 00E00001           1358mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
0000082C                          1359mm     
0000082C                          1360mm     ENDM
0000082C                          1361mm         PRINT_CHAR D2,D3
0000082C                          1362mm WAIT_FOR_READY_81                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082C                 TRUE     1363mm     IFEQ DEBUG
0000082C  1639 00C00003           1364mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000832  0803 0002               1365mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000836  67F4                    1366mm         BEQ WAIT_FOR_READY_81                   ; NO SPACE, CHECK AGAIN
00000838  13C2 00C00007           1367mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
0000083E                          1368mm     ENDC
0000083E                          1369mm     
0000083E                 FALSE    1370mm     IFNE DEBUG
0000083E                          1371mm     ENDC
0000083E                          1372mm 
0000083E                          1373mm     ENDM
0000083E                          1374mm         HEX2BIN D2,D2,A0
0000083E  41F9 00000FEA           1375mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000844  0402 0030               1376mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000848  C4BC 000000FF           1377mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
0000084E  1430 2000               1378mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000852                          1379mm     ENDM
00000852  8E02                    1380m         OR.B D2,D7
00000854  5301                    1381m         SUB.B #1,D1
00000856                          1382m     ENDW
00000856  6096                    1383ms     BRA _1000000C
00000858                          1384ms _1000000D
00000858                          1385m     
00000858  7400                    1386m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000085A  1407                    1387m     MOVE.B D7,D2
0000085C  DC87                    1388m     ADD.L D7,D6
0000085E                          1389m 
0000085E                          1390m     ENDM
0000085E                          1391m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; middle byte     
0000085E  123C 0002               1392m     MOVE.B #2,D1
00000862                          1393m     WHILE.B D1 <GT> 0 DO
00000862                          1394ms _1000000E
00000862  B238 0000               1395ms     CMP.B   0,D1
00000866  6F00 0064               1396ms     BLE _1000000F
0000086A  E98F                    1397m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
0000086C                          1398mm         DOWNLOAD D2
0000086C                          1399mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000086C                          1400mm 
0000086C  1439 00C00003           1401mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
00000872  0802 0000               1402mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000876  6700 0010               1403mm     BEQ CONTINUE_84                             ; NOTHING, CONTINUE
0000087A                          1404mm  
0000087A                          1405mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
0000087A                 TRUE     1406mmm     IFEQ DEBUG
0000087A  1439 00C00007           1407mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000880                          1408mmm     ENDC
00000880                 FALSE    1409mmm     IFNE DEBUG
00000880                          1410mmm     ENDC
00000880                          1411mmm      
00000880  B43C 001B               1412mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000884  6700 F782               1413mmm     BEQ START
00000888                          1414mmm     ENDM
00000888                          1415mm CONTINUE_84
00000888  1439 00C00013           1416mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
0000088E  0802 0000               1417mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000892  67D8                    1418mm     BEQ WAIT_FOR_READY_84                       ; NOTHING, CHECK AGAIN
00000894                          1419mm     
00000894  1439 00C00017           1420mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000089A  13C2 00E00001           1421mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
000008A0                          1422mm     
000008A0                          1423mm     ENDM
000008A0                          1424mm         PRINT_CHAR D2,D3
000008A0                          1425mm WAIT_FOR_READY_86                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A0                 TRUE     1426mm     IFEQ DEBUG
000008A0  1639 00C00003           1427mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000008A6  0803 0002               1428mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000008AA  67F4                    1429mm         BEQ WAIT_FOR_READY_86                   ; NO SPACE, CHECK AGAIN
000008AC  13C2 00C00007           1430mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
000008B2                          1431mm     ENDC
000008B2                          1432mm     
000008B2                 FALSE    1433mm     IFNE DEBUG
000008B2                          1434mm     ENDC
000008B2                          1435mm 
000008B2                          1436mm     ENDM
000008B2                          1437mm         HEX2BIN D2,D2,A0
000008B2  41F9 00000FEA           1438mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
000008B8  0402 0030               1439mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008BC  C4BC 000000FF           1440mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
000008C2  1430 2000               1441mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
000008C6                          1442mm     ENDM
000008C6  8E02                    1443m         OR.B D2,D7
000008C8  5301                    1444m         SUB.B #1,D1
000008CA                          1445m     ENDW
000008CA  6096                    1446ms     BRA _1000000E
000008CC                          1447ms _1000000F
000008CC                          1448m     
000008CC  7400                    1449m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008CE  1407                    1450m     MOVE.B D7,D2
000008D0  DC87                    1451m     ADD.L D7,D6
000008D2                          1452m 
000008D2                          1453m     ENDM
000008D2                          1454m                 DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0 ; bottom byte
000008D2  123C 0002               1455m     MOVE.B #2,D1
000008D6                          1456m     WHILE.B D1 <GT> 0 DO
000008D6                          1457ms _10000010
000008D6  B238 0000               1458ms     CMP.B   0,D1
000008DA  6F00 0064               1459ms     BLE _10000011
000008DE  E98F                    1460m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000008E0                          1461mm         DOWNLOAD D2
000008E0                          1462mm WAIT_FOR_READY_89                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E0                          1463mm 
000008E0  1439 00C00003           1464mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000008E6  0802 0000               1465mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000008EA  6700 0010               1466mm     BEQ CONTINUE_89                             ; NOTHING, CONTINUE
000008EE                          1467mm  
000008EE                          1468mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000008EE                 TRUE     1469mmm     IFEQ DEBUG
000008EE  1439 00C00007           1470mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
000008F4                          1471mmm     ENDC
000008F4                 FALSE    1472mmm     IFNE DEBUG
000008F4                          1473mmm     ENDC
000008F4                          1474mmm      
000008F4  B43C 001B               1475mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
000008F8  6700 F70E               1476mmm     BEQ START
000008FC                          1477mmm     ENDM
000008FC                          1478mm CONTINUE_89
000008FC  1439 00C00013           1479mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000902  0802 0000               1480mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000906  67D8                    1481mm     BEQ WAIT_FOR_READY_89                       ; NOTHING, CHECK AGAIN
00000908                          1482mm     
00000908  1439 00C00017           1483mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
0000090E  13C2 00E00001           1484mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000914                          1485mm     
00000914                          1486mm     ENDM
00000914                          1487mm         PRINT_CHAR D2,D3
00000914                          1488mm WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000914                 TRUE     1489mm     IFEQ DEBUG
00000914  1639 00C00003           1490mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000091A  0803 0002               1491mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000091E  67F4                    1492mm         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
00000920  13C2 00C00007           1493mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000926                          1494mm     ENDC
00000926                          1495mm     
00000926                 FALSE    1496mm     IFNE DEBUG
00000926                          1497mm     ENDC
00000926                          1498mm 
00000926                          1499mm     ENDM
00000926                          1500mm         HEX2BIN D2,D2,A0
00000926  41F9 00000FEA           1501mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
0000092C  0402 0030               1502mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000930  C4BC 000000FF           1503mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000936  1430 2000               1504mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
0000093A                          1505mm     ENDM
0000093A  8E02                    1506m         OR.B D2,D7
0000093C  5301                    1507m         SUB.B #1,D1
0000093E                          1508m     ENDW
0000093E  6096                    1509ms     BRA _10000010
00000940                          1510ms _10000011
00000940                          1511m     
00000940  7400                    1512m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000942  1407                    1513m     MOVE.B D7,D2
00000944  DC87                    1514m     ADD.L D7,D6
00000946                          1515m 
00000946                          1516m     ENDM
00000946                          1517                    
00000946  2447                    1518                  MOVE.L D7,A2                    ; start address -> A2
00000948                          1519                  
00000948  43F9 00000B28           1520                  LEA DOWNLOAD_DONE,A1            ; next place to go
0000094E                          1521              ELSE
0000094E  6000 008C               1522s     BRA _00000007
00000952                          1523s _00000006
00000952                          1524m                 PRINT_CRLF D3
00000952                          1525mm     PRINT_CHAR #13,D3                           ; CR
00000952                          1526mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000952                 TRUE     1527mm     IFEQ DEBUG
00000952  1639 00C00003           1528mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000958  0803 0002               1529mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0000095C  67F4                    1530mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
0000095E  13FC 000D 00C00007      1531mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000966                          1532mm     ENDC
00000966                          1533mm     
00000966                 FALSE    1534mm     IFNE DEBUG
00000966                          1535mm     ENDC
00000966                          1536mm 
00000966                          1537mm     ENDM
00000966                          1538mm     PRINT_CHAR #10,D3                           ; LF
00000966                          1539mm WAIT_FOR_READY_95                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000966                 TRUE     1540mm     IFEQ DEBUG
00000966  1639 00C00003           1541mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000096C  0803 0002               1542mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000970  67F4                    1543mm         BEQ WAIT_FOR_READY_95                   ; NO SPACE, CHECK AGAIN
00000972  13FC 000A 00C00007      1544mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
0000097A                          1545mm     ENDC
0000097A                          1546mm     
0000097A                 FALSE    1547mm     IFNE DEBUG
0000097A                          1548mm     ENDC
0000097A                          1549mm 
0000097A                          1550mm     ENDM
0000097A                          1551m     ENDM
0000097A                          1552              
0000097A  41F9 00000F9F           1553                  LEA UNREC,A0                    ; warn for unrecognised type
00000980                          1554m                 PRINT_STR A0,D3
00000980                          1555m LOOP_96
00000980  0C10 0000               1556m     CMP.B #0,(A0)                               ; 0 -> DONE
00000984  6700 0018               1557m     BEQ EXIT_96
00000988                          1558mm     PRINT_CHAR (A0)+,D3
00000988                          1559mm WAIT_FOR_READY_97                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000988                 TRUE     1560mm     IFEQ DEBUG
00000988  1639 00C00003           1561mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0000098E  0803 0002               1562mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000992  67F4                    1563mm         BEQ WAIT_FOR_READY_97                   ; NO SPACE, CHECK AGAIN
00000994  13D8 00C00007           1564mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0000099A                          1565mm     ENDC
0000099A                          1566mm     
0000099A                 FALSE    1567mm     IFNE DEBUG
0000099A                          1568mm     ENDC
0000099A                          1569mm 
0000099A                          1570mm     ENDM
0000099A  4EF8 0980               1571m     JMP LOOP_96
0000099E                          1572m EXIT_96
0000099E                          1573m     ENDM
0000099E                          1574m                 PRINT_CHAR D7,D3
0000099E                          1575m WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099E                 TRUE     1576m     IFEQ DEBUG
0000099E  1639 00C00003           1577m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009A4  0803 0002               1578m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009A8  67F4                    1579m         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
000009AA  13C7 00C00007           1580m         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
000009B0                          1581m     ENDC
000009B0                          1582m     
000009B0                 FALSE    1583m     IFNE DEBUG
000009B0                          1584m     ENDC
000009B0                          1585m 
000009B0                          1586m     ENDM
000009B0                          1587m                 PRINT_CRLF D3
000009B0                          1588mm     PRINT_CHAR #13,D3                           ; CR
000009B0                          1589mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B0                 TRUE     1590mm     IFEQ DEBUG
000009B0  1639 00C00003           1591mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009B6  0803 0002               1592mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009BA  67F4                    1593mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000009BC  13FC 000D 00C00007      1594mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009C4                          1595mm     ENDC
000009C4                          1596mm     
000009C4                 FALSE    1597mm     IFNE DEBUG
000009C4                          1598mm     ENDC
000009C4                          1599mm 
000009C4                          1600mm     ENDM
000009C4                          1601mm     PRINT_CHAR #10,D3                           ; LF
000009C4                          1602mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C4                 TRUE     1603mm     IFEQ DEBUG
000009C4  1639 00C00003           1604mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
000009CA  0803 0002               1605mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
000009CE  67F4                    1606mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
000009D0  13FC 000A 00C00007      1607mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
000009D8                          1608mm     ENDC
000009D8                          1609mm     
000009D8                 FALSE    1610mm     IFNE DEBUG
000009D8                          1611mm     ENDC
000009D8                          1612mm 
000009D8                          1613mm     ENDM
000009D8                          1614m     ENDM
000009D8                          1615              
000009D8  4EF8 048E               1616                  JMP WAIT_FOR_SRECORD            ; ignore any other type    
000009DC                          1617              ENDI
000009DC                          1618s _00000007
000009DC                          1619          ENDI
000009DC                          1620s _00000005
000009DC                          1621      ENDI
000009DC                          1622s _00000001
000009DC                          1623      
000009DC  7E00                    1624      MOVE.L #0,D7                                ; read the checksum from the data stream, and add into the inverted checksum: should make it FF
000009DE                          1625m     DOWNLOAD_BYTE D2,D7,D3,D1,D6,A0                         
000009DE  123C 0002               1626m     MOVE.B #2,D1
000009E2                          1627m     WHILE.B D1 <GT> 0 DO
000009E2                          1628ms _10000012
000009E2  B238 0000               1629ms     CMP.B   0,D1
000009E6  6F00 0064               1630ms     BLE _10000013
000009EA  E98F                    1631m         LSL.L #4,D7                    ; IT's OK to do this first, because we are either starting from 0, or we are reading the next byte along, so need to shift up the previous one
000009EC                          1632mm         DOWNLOAD D2
000009EC                          1633mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EC                          1634mm 
000009EC  1439 00C00003           1635mm     MOVE.B DUART_SRA,D2                         ; CHECK FOR COMMAND
000009F2  0802 0000               1636mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
000009F6  6700 0010               1637mm     BEQ CONTINUE_103                                ; NOTHING, CONTINUE
000009FA                          1638mm  
000009FA                          1639mmm     READ_CHAR D2                                ; WE're not going to do anything with it, just check for escape
000009FA                 TRUE     1640mmm     IFEQ DEBUG
000009FA  1439 00C00007           1641mmm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000A00                          1642mmm     ENDC
00000A00                 FALSE    1643mmm     IFNE DEBUG
00000A00                          1644mmm     ENDC
00000A00                          1645mmm      
00000A00  B43C 001B               1646mmm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000A04  6700 F602               1647mmm     BEQ START
00000A08                          1648mmm     ENDM
00000A08                          1649mm CONTINUE_103
00000A08  1439 00C00013           1650mm     MOVE.B DUART_SRB,D2                         ; READ DOWNLOAD STATUS REGISTER
00000A0E  0802 0000               1651mm     BTST #0,D2                                  ; CHECK FOR CHARACTER
00000A12  67D8                    1652mm     BEQ WAIT_FOR_READY_103                      ; NOTHING, CHECK AGAIN
00000A14                          1653mm     
00000A14  1439 00C00017           1654mm     MOVE.B DUART_RXB,D2                         ; GOT A CHARACTER, READ IT
00000A1A  13C2 00E00001           1655mm     MOVE.B D2,DISPLAY                           ; ECHO TO THE DISPLAY
00000A20                          1656mm     
00000A20                          1657mm     ENDM
00000A20                          1658mm         PRINT_CHAR D2,D3
00000A20                          1659mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A20                 TRUE     1660mm     IFEQ DEBUG
00000A20  1639 00C00003           1661mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A26  0803 0002               1662mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A2A  67F4                    1663mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A2C  13C2 00C00007           1664mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000A32                          1665mm     ENDC
00000A32                          1666mm     
00000A32                 FALSE    1667mm     IFNE DEBUG
00000A32                          1668mm     ENDC
00000A32                          1669mm 
00000A32                          1670mm     ENDM
00000A32                          1671mm         HEX2BIN D2,D2,A0
00000A32  41F9 00000FEA           1672mm     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000A38  0402 0030               1673mm     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A3C  C4BC 000000FF           1674mm     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000A42  1430 2000               1675mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000A46                          1676mm     ENDM
00000A46  8E02                    1677m         OR.B D2,D7
00000A48  5301                    1678m         SUB.B #1,D1
00000A4A                          1679m     ENDW
00000A4A  6096                    1680ms     BRA _10000012
00000A4C                          1681ms _10000013
00000A4C                          1682m     
00000A4C  7400                    1683m     MOVE.L #0,D2                        ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A4E  1407                    1684m     MOVE.B D7,D2
00000A50  DC87                    1685m     ADD.L D7,D6
00000A52                          1686m 
00000A52                          1687m     ENDM
00000A52                          1688m     PRINT_CRLF D3
00000A52                          1689mm     PRINT_CHAR #13,D3                           ; CR
00000A52                          1690mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A52                 TRUE     1691mm     IFEQ DEBUG
00000A52  1639 00C00003           1692mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A58  0803 0002               1693mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A5C  67F4                    1694mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A5E  13FC 000D 00C00007      1695mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A66                          1696mm     ENDC
00000A66                          1697mm     
00000A66                 FALSE    1698mm     IFNE DEBUG
00000A66                          1699mm     ENDC
00000A66                          1700mm 
00000A66                          1701mm     ENDM
00000A66                          1702mm     PRINT_CHAR #10,D3                           ; LF
00000A66                          1703mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                 TRUE     1704mm     IFEQ DEBUG
00000A66  1639 00C00003           1705mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A6C  0803 0002               1706mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A70  67F4                    1707mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000A72  13FC 000A 00C00007      1708mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000A7A                          1709mm     ENDC
00000A7A                          1710mm     
00000A7A                 FALSE    1711mm     IFNE DEBUG
00000A7A                          1712mm     ENDC
00000A7A                          1713mm 
00000A7A                          1714mm     ENDM
00000A7A                          1715m     ENDM
00000A7A                          1716          
00000A7A                          1717      IF.B D6 <NE> #$FF THEN.L
00000A7A  BC3C 00FF               1718s     CMP.B   #$FF,D6
00000A7E  6700 00A6               1719s     BEQ.L   _00000008
00000A82  41F9 00000FB6           1720          LEA CS_FAILURE,A0                       ; warn for mismatched checksum
00000A88                          1721m         PRINT_STR A0,D3
00000A88                          1722m LOOP_110
00000A88  0C10 0000               1723m     CMP.B #0,(A0)                               ; 0 -> DONE
00000A8C  6700 0018               1724m     BEQ EXIT_110
00000A90                          1725mm     PRINT_CHAR (A0)+,D3
00000A90                          1726mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A90                 TRUE     1727mm     IFEQ DEBUG
00000A90  1639 00C00003           1728mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000A96  0803 0002               1729mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000A9A  67F4                    1730mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A9C  13D8 00C00007           1731mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000AA2                          1732mm     ENDC
00000AA2                          1733mm     
00000AA2                 FALSE    1734mm     IFNE DEBUG
00000AA2                          1735mm     ENDC
00000AA2                          1736mm 
00000AA2                          1737mm     ENDM
00000AA2  4EF8 0A88               1738m     JMP LOOP_110
00000AA6                          1739m EXIT_110
00000AA6                          1740m     ENDM
00000AA6                          1741m         PRINT_REG D4,D3,D6,D7,A0
00000AA6                          1742mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000AA6                          1743mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA6                 TRUE     1744mm     IFEQ DEBUG
00000AA6  1639 00C00003           1745mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AAC  0803 0002               1746mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AB0  67F4                    1747mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000AB2  13FC 0030 00C00007      1748mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000ABA                          1749mm     ENDC
00000ABA                          1750mm     
00000ABA                 FALSE    1751mm     IFNE DEBUG
00000ABA                          1752mm     ENDC
00000ABA                          1753mm 
00000ABA                          1754mm     ENDM
00000ABA                          1755mm     PRINT_CHAR #'x',D3
00000ABA                          1756mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ABA                 TRUE     1757mm     IFEQ DEBUG
00000ABA  1639 00C00003           1758mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AC0  0803 0002               1759mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AC4  67F4                    1760mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00000AC6  13FC 0078 00C00007      1761mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000ACE                          1762mm     ENDC
00000ACE                          1763mm     
00000ACE                 FALSE    1764mm     IFNE DEBUG
00000ACE                          1765mm     ENDC
00000ACE                          1766mm 
00000ACE                          1767mm     ENDM
00000ACE  7E07                    1768m     MOVE.L #7,D7                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AD0                          1769m LOOP_112
00000AD0                          1770mm     BIN2HEX D4,D6,A0
00000AD0  41F9 00000FDA           1771mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000AD6  E99C                    1772mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AD8  1C04                    1773mm     MOVE.B D4,D6
00000ADA  0286 0000000F           1774mm     ANDI.L #$F,D6
00000AE0  1C30 6000               1775mm     MOVE.B 0(A0,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00000AE4                          1776mm     ENDM
00000AE4                          1777mm     PRINT_CHAR D6,D3
00000AE4                          1778mm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE4                 TRUE     1779mm     IFEQ DEBUG
00000AE4  1639 00C00003           1780mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000AEA  0803 0002               1781mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000AEE  67F4                    1782mm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000AF0  13C6 00C00007           1783mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000AF6                          1784mm     ENDC
00000AF6                          1785mm     
00000AF6                 FALSE    1786mm     IFNE DEBUG
00000AF6                          1787mm     ENDC
00000AF6                          1788mm 
00000AF6                          1789mm     ENDM
00000AF6  57CF FFD8               1790m     DBEQ D7,LOOP_112
00000AFA                          1791m     ENDM
00000AFA                          1792m         PRINT_CRLF D3
00000AFA                          1793mm     PRINT_CHAR #13,D3                           ; CR
00000AFA                          1794mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFA                 TRUE     1795mm     IFEQ DEBUG
00000AFA  1639 00C00003           1796mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B00  0803 0002               1797mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B04  67F4                    1798mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000B06  13FC 000D 00C00007      1799mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B0E                          1800mm     ENDC
00000B0E                          1801mm     
00000B0E                 FALSE    1802mm     IFNE DEBUG
00000B0E                          1803mm     ENDC
00000B0E                          1804mm 
00000B0E                          1805mm     ENDM
00000B0E                          1806mm     PRINT_CHAR #10,D3                           ; LF
00000B0E                          1807mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0E                 TRUE     1808mm     IFEQ DEBUG
00000B0E  1639 00C00003           1809mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B14  0803 0002               1810mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B18  67F4                    1811mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B1A  13FC 000A 00C00007      1812mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000B22                          1813mm     ENDC
00000B22                          1814mm     
00000B22                 FALSE    1815mm     IFNE DEBUG
00000B22                          1816mm     ENDC
00000B22                          1817mm 
00000B22                          1818mm     ENDM
00000B22                          1819m     ENDM
00000B22  4EF8 0186               1820          JMP MAIN_LOOP
00000B26                          1821      ENDI
00000B26                          1822s _00000008
00000B26                          1823      
00000B26  4ED1                    1824      JMP (A1)
00000B28                          1825  DOWNLOAD_DONE
00000B28                          1826m     PRINT_REG D4,D3,D7,D6,A0                    ; print out number of Srecords read
00000B28                          1827mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000B28                          1828mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B28                 TRUE     1829mm     IFEQ DEBUG
00000B28  1639 00C00003           1830mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B2E  0803 0002               1831mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B32  67F4                    1832mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B34  13FC 0030 00C00007      1833mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B3C                          1834mm     ENDC
00000B3C                          1835mm     
00000B3C                 FALSE    1836mm     IFNE DEBUG
00000B3C                          1837mm     ENDC
00000B3C                          1838mm 
00000B3C                          1839mm     ENDM
00000B3C                          1840mm     PRINT_CHAR #'x',D3
00000B3C                          1841mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     1842mm     IFEQ DEBUG
00000B3C  1639 00C00003           1843mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B42  0803 0002               1844mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B46  67F4                    1845mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000B48  13FC 0078 00C00007      1846mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000B50                          1847mm     ENDC
00000B50                          1848mm     
00000B50                 FALSE    1849mm     IFNE DEBUG
00000B50                          1850mm     ENDC
00000B50                          1851mm 
00000B50                          1852mm     ENDM
00000B50  7C07                    1853m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B52                          1854m LOOP_120
00000B52                          1855mm     BIN2HEX D4,D7,A0
00000B52  41F9 00000FDA           1856mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000B58  E99C                    1857mm     ROL.L #4,D4                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B5A  1E04                    1858mm     MOVE.B D4,D7
00000B5C  0287 0000000F           1859mm     ANDI.L #$F,D7
00000B62  1E30 7000               1860mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
00000B66                          1861mm     ENDM
00000B66                          1862mm     PRINT_CHAR D7,D3
00000B66                          1863mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B66                 TRUE     1864mm     IFEQ DEBUG
00000B66  1639 00C00003           1865mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B6C  0803 0002               1866mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B70  67F4                    1867mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000B72  13C7 00C00007           1868mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000B78                          1869mm     ENDC
00000B78                          1870mm     
00000B78                 FALSE    1871mm     IFNE DEBUG
00000B78                          1872mm     ENDC
00000B78                          1873mm 
00000B78                          1874mm     ENDM
00000B78  57CE FFD8               1875m     DBEQ D6,LOOP_120
00000B7C                          1876m     ENDM
00000B7C  41F9 00000F7D           1877      LEA READ,A0
00000B82                          1878m     PRINT_STR A0,D3
00000B82                          1879m LOOP_125
00000B82  0C10 0000               1880m     CMP.B #0,(A0)                               ; 0 -> DONE
00000B86  6700 0018               1881m     BEQ EXIT_125
00000B8A                          1882mm     PRINT_CHAR (A0)+,D3
00000B8A                          1883mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B8A                 TRUE     1884mm     IFEQ DEBUG
00000B8A  1639 00C00003           1885mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000B90  0803 0002               1886mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000B94  67F4                    1887mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000B96  13D8 00C00007           1888mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000B9C                          1889mm     ENDC
00000B9C                          1890mm     
00000B9C                 FALSE    1891mm     IFNE DEBUG
00000B9C                          1892mm     ENDC
00000B9C                          1893mm 
00000B9C                          1894mm     ENDM
00000B9C  4EF8 0B82               1895m     JMP LOOP_125
00000BA0                          1896m EXIT_125
00000BA0                          1897m     ENDM
00000BA0  2E0A                    1898      MOVE.L A2,D7                                ; set address accumulator to start address
00000BA2                          1899m     PRINT_REG D7,D3,D2,D6,A0                    ; print out start address
00000BA2                          1900mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000BA2                          1901mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA2                 TRUE     1902mm     IFEQ DEBUG
00000BA2  1639 00C00003           1903mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BA8  0803 0002               1904mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BAC  67F4                    1905mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BAE  13FC 0030 00C00007      1906mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BB6                          1907mm     ENDC
00000BB6                          1908mm     
00000BB6                 FALSE    1909mm     IFNE DEBUG
00000BB6                          1910mm     ENDC
00000BB6                          1911mm 
00000BB6                          1912mm     ENDM
00000BB6                          1913mm     PRINT_CHAR #'x',D3
00000BB6                          1914mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB6                 TRUE     1915mm     IFEQ DEBUG
00000BB6  1639 00C00003           1916mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BBC  0803 0002               1917mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BC0  67F4                    1918mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BC2  13FC 0078 00C00007      1919mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000BCA                          1920mm     ENDC
00000BCA                          1921mm     
00000BCA                 FALSE    1922mm     IFNE DEBUG
00000BCA                          1923mm     ENDC
00000BCA                          1924mm 
00000BCA                          1925mm     ENDM
00000BCA  7C07                    1926m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BCC                          1927m LOOP_127
00000BCC                          1928mm     BIN2HEX D7,D2,A0
00000BCC  41F9 00000FDA           1929mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000BD2  E99F                    1930mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BD4  1407                    1931mm     MOVE.B D7,D2
00000BD6  0282 0000000F           1932mm     ANDI.L #$F,D2
00000BDC  1430 2000               1933mm     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000BE0                          1934mm     ENDM
00000BE0                          1935mm     PRINT_CHAR D2,D3
00000BE0                          1936mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE0                 TRUE     1937mm     IFEQ DEBUG
00000BE0  1639 00C00003           1938mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BE6  0803 0002               1939mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000BEA  67F4                    1940mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000BEC  13C2 00C00007           1941mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000BF2                          1942mm     ENDC
00000BF2                          1943mm     
00000BF2                 FALSE    1944mm     IFNE DEBUG
00000BF2                          1945mm     ENDC
00000BF2                          1946mm 
00000BF2                          1947mm     ENDM
00000BF2  57CE FFD8               1948m     DBEQ D6,LOOP_127
00000BF6                          1949m     ENDM
00000BF6                          1950m     PRINT_CRLF D3     
00000BF6                          1951mm     PRINT_CHAR #13,D3                           ; CR
00000BF6                          1952mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF6                 TRUE     1953mm     IFEQ DEBUG
00000BF6  1639 00C00003           1954mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000BFC  0803 0002               1955mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C00  67F4                    1956mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C02  13FC 000D 00C00007      1957mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000C0A                          1958mm     ENDC
00000C0A                          1959mm     
00000C0A                 FALSE    1960mm     IFNE DEBUG
00000C0A                          1961mm     ENDC
00000C0A                          1962mm 
00000C0A                          1963mm     ENDM
00000C0A                          1964mm     PRINT_CHAR #10,D3                           ; LF
00000C0A                          1965mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C0A                 TRUE     1966mm     IFEQ DEBUG
00000C0A  1639 00C00003           1967mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000C10  0803 0002               1968mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000C14  67F4                    1969mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C16  13FC 000A 00C00007      1970mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000C1E                          1971mm     ENDC
00000C1E                          1972mm     
00000C1E                 FALSE    1973mm     IFNE DEBUG
00000C1E                          1974mm     ENDC
00000C1E                          1975mm 
00000C1E                          1976mm     ENDM
00000C1E                          1977m     ENDM
00000C1E                          1978          
00000C1E  4EF8 0186               1979      JMP MAIN_LOOP
00000C22                          1980      
00000C22                          1981  G
00000C22  2047                    1982      MOVE.L D7,A0                                ; address accumulator -> address register
00000C24  3E3C 0000               1983      MOVE #0,D7                                  ; clear the now used address accumulator
00000C28  4ED0                    1984      JMP (A0)                                    ; jump to it!
00000C2A                          1985      
00000C2A                          1986  Z
00000C2A  207C 00200000           1987      MOVE.L #RAM,A0                              ; address of RAM
00000C30  7000                    1988      MOVE.L #0,D0                                ; number of bytes
00000C32                          1989     
00000C32                          1990      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C32                          1991s _10000014
00000C32  B0BC 00040000           1992s     CMP.L   #$40000,D0
00000C38  6E00 001A               1993s     BGT _10000015
00000C3C  2200                    1994          MOVE.L D0,D1                            ; progress update
00000C3E  E089                    1995          LSR.L #8,D1 
00000C40  E089                    1996          LSR.L #8,D1
00000C42  0281 0000000F           1997          ANDI.L #$F,D1
00000C48  13C1 00E00001           1998          MOVE.B D1,DISPLAY
00000C4E                          1999  
00000C4E  20C0                    2000          MOVE.L D0,(A0)+ 
00000C50  5880                    2001          ADD.L #4,D0
00000C52                          2002      ENDW
00000C52  60DE                    2003s     BRA _10000014
00000C54                          2004s _10000015
00000C54                          2005   
00000C54  207C 00200000           2006      MOVE.L #RAM,A0                              ; address of RAM
00000C5A  7000                    2007      MOVE.L #0,D0                                ; number of bytes
00000C5C                          2008     
00000C5C                          2009      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00000C5C                          2010s _10000016
00000C5C  B0BC 00040000           2011s     CMP.L   #$40000,D0
00000C62  6E00 00CA               2012s     BGT _10000017
00000C66  2200                    2013          MOVE.L D0,D1                            ; progress update
00000C68  E089                    2014          LSR.L #8,D1
00000C6A  E089                    2015          LSR.L #8,D1
00000C6C  0281 0000000F           2016          ANDI.L #$F,D1
00000C72  13C1 00E00001           2017          MOVE.B D1,DISPLAY
00000C78                          2018  
00000C78  2218                    2019          MOVE.L (A0)+,D1
00000C7A                          2020            
00000C7A                          2021          IF.L D0 <EQ> D1 THEN
00000C7A  B081                    2022s     CMP.L   D1,D0
00000C7C  6600 0006               2023s     BNE _00000009
00000C80  6000 00A6               2024              BRA OK
00000C84                          2025          ENDI 
00000C84                          2026s _00000009
00000C84                          2027            
00000C84  43F9 00000FC8           2028          LEA RAM_ERROR,A1
00000C8A                          2029m         PRINT_STR A1,D1
00000C8A                          2030m LOOP_135
00000C8A  0C11 0000               2031m     CMP.B #0,(A1)                               ; 0 -> DONE
00000C8E  6700 0018               2032m     BEQ EXIT_135
00000C92                          2033mm     PRINT_CHAR (A1)+,D1
00000C92                          2034mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C92                 TRUE     2035mm     IFEQ DEBUG
00000C92  1239 00C00003           2036mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00000C98  0801 0002               2037mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00000C9C  67F4                    2038mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C9E  13D9 00C00007           2039mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000CA4                          2040mm     ENDC
00000CA4                          2041mm     
00000CA4                 FALSE    2042mm     IFNE DEBUG
00000CA4                          2043mm     ENDC
00000CA4                          2044mm 
00000CA4                          2045mm     ENDM
00000CA4  4EF8 0C8A               2046m     JMP LOOP_135
00000CA8                          2047m EXIT_135
00000CA8                          2048m     ENDM
00000CA8  2208                    2049          MOVE.L A0,D1
00000CAA  5981                    2050          SUB.L #4,D1
00000CAC                          2051m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000CAC                          2052mm     PRINT_CHAR #'0',D3                          ;0X HEADER
00000CAC                          2053mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAC                 TRUE     2054mm     IFEQ DEBUG
00000CAC  1639 00C00003           2055mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CB2  0803 0002               2056mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CB6  67F4                    2057mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000CB8  13FC 0030 00C00007      2058mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CC0                          2059mm     ENDC
00000CC0                          2060mm     
00000CC0                 FALSE    2061mm     IFNE DEBUG
00000CC0                          2062mm     ENDC
00000CC0                          2063mm 
00000CC0                          2064mm     ENDM
00000CC0                          2065mm     PRINT_CHAR #'x',D3
00000CC0                          2066mm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CC0                 TRUE     2067mm     IFEQ DEBUG
00000CC0  1639 00C00003           2068mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CC6  0803 0002               2069mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CCA  67F4                    2070mm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CCC  13FC 0078 00C00007      2071mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00000CD4                          2072mm     ENDC
00000CD4                          2073mm     
00000CD4                 FALSE    2074mm     IFNE DEBUG
00000CD4                          2075mm     ENDC
00000CD4                          2076mm 
00000CD4                          2077mm     ENDM
00000CD4  7C07                    2078m     MOVE.L #7,D6                                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CD6                          2079m LOOP_137
00000CD6                          2080mm     BIN2HEX D1,D2,A1
00000CD6  43F9 00000FDA           2081mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00000CDC  E999                    2082mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CDE  1401                    2083mm     MOVE.B D1,D2
00000CE0  0282 0000000F           2084mm     ANDI.L #$F,D2
00000CE6  1431 2000               2085mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00000CEA                          2086mm     ENDM
00000CEA                          2087mm     PRINT_CHAR D2,D3
00000CEA                          2088mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CEA                 TRUE     2089mm     IFEQ DEBUG
00000CEA  1639 00C00003           2090mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000CF0  0803 0002               2091mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000CF4  67F4                    2092mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CF6  13C2 00C00007           2093mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000CFC                          2094mm     ENDC
00000CFC                          2095mm     
00000CFC                 FALSE    2096mm     IFNE DEBUG
00000CFC                          2097mm     ENDC
00000CFC                          2098mm 
00000CFC                          2099mm     ENDM
00000CFC  57CE FFD8               2100m     DBEQ D6,LOOP_137
00000D00                          2101m     ENDM
00000D00                          2102m         PRINT_CRLF D3
00000D00                          2103mm     PRINT_CHAR #13,D3                           ; CR
00000D00                          2104mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2105mm     IFEQ DEBUG
00000D00  1639 00C00003           2106mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D06  0803 0002               2107mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2108mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000D0C  13FC 000D 00C00007      2109mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D14                          2110mm     ENDC
00000D14                          2111mm     
00000D14                 FALSE    2112mm     IFNE DEBUG
00000D14                          2113mm     ENDC
00000D14                          2114mm 
00000D14                          2115mm     ENDM
00000D14                          2116mm     PRINT_CHAR #10,D3                           ; LF
00000D14                          2117mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D14                 TRUE     2118mm     IFEQ DEBUG
00000D14  1639 00C00003           2119mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D1A  0803 0002               2120mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D1E  67F4                    2121mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D20  13FC 000A 00C00007      2122mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000D28                          2123mm     ENDC
00000D28                          2124mm     
00000D28                 FALSE    2125mm     IFNE DEBUG
00000D28                          2126mm     ENDC
00000D28                          2127mm 
00000D28                          2128mm     ENDM
00000D28                          2129m     ENDM
00000D28                          2130  OK    
00000D28  5880                    2131          ADD.L #4,D0
00000D2A                          2132      ENDW
00000D2A  6000 FF30               2133s     BRA _10000016
00000D2E                          2134s _10000017
00000D2E                          2135      
00000D2E  4EF8 0186               2136      JMP MAIN_LOOP
00000D32                          2137    
00000D32                          2138  L
00000D32  7A00                    2139      MOVE.L #0,D5                                ; D5 will be the length  to write            
00000D34                          2140  
00000D34                          2141m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00000D34                          2142m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D34                          2143m 
00000D34                 TRUE     2144m     IFEQ DEBUG
00000D34  1639 00C00003           2145m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D3A  0803 0000               2146m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D3E  67F4                    2147m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D40                          2148m     ENDC
00000D40                          2149m     
00000D40                          2150mm     READ_CHAR D2
00000D40                 TRUE     2151mm     IFEQ DEBUG
00000D40  1439 00C00007           2152mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D46                          2153mm     ENDC
00000D46                 FALSE    2154mm     IFNE DEBUG
00000D46                          2155mm     ENDC
00000D46                          2156mm      
00000D46  B43C 001B               2157mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D4A  6700 F2BC               2158mm     BEQ START
00000D4E                          2159mm     ENDM
00000D4E                          2160m 
00000D4E                 TRUE     2161m     IFEQ DEBUG
00000D4E                          2162mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D4E                          2163mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4E                 TRUE     2164mm     IFEQ DEBUG
00000D4E  1639 00C00003           2165mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D54  0803 0002               2166mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000D58  67F4                    2167mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D5A  13C2 00C00007           2168mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000D60                          2169mm     ENDC
00000D60                          2170mm     
00000D60                 FALSE    2171mm     IFNE DEBUG
00000D60                          2172mm     ENDC
00000D60                          2173mm 
00000D60                          2174mm     ENDM
00000D60                          2175m     ENDC
00000D60                          2176m     ENDM
00000D60                          2177m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D60  41F9 00000FEA           2178m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000D66  0402 0030               2179m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D6A  C4BC 000000FF           2180m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000D70  1430 2000               2181m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000D74                          2182m     ENDM
00000D74  1A02                    2183      MOVE.B D2,D5                                ; put at bottom of D5
00000D76                          2184  
00000D76  3C3C 0002               2185      MOVE #2,D6                                  ; 3 bytes left to read
00000D7A                          2186      
00000D7A                          2187  READ_LENGTH
00000D7A  E98D                    2188      LSL.L #4,D5                                 ; make what we have so far more significant
00000D7C                          2189m     WAIT_CHAR D2,D3                             ; next character -> D2
00000D7C                          2190m WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                          2191m 
00000D7C                 TRUE     2192m     IFEQ DEBUG
00000D7C  1639 00C00003           2193m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D82  0803 0000               2194m         BTST #0,D3                              ; CHECK FOR CHARACTER
00000D86  67F4                    2195m         BEQ WAIT_FOR_READY_149                      ; NOTHING, CHECK AGAIN
00000D88                          2196m     ENDC
00000D88                          2197m     
00000D88                          2198mm     READ_CHAR D2
00000D88                 TRUE     2199mm     IFEQ DEBUG
00000D88  1439 00C00007           2200mm         MOVE.B DUART_RXA,D2                     ; GOT A CHARACTER, READ IT
00000D8E                          2201mm     ENDC
00000D8E                 FALSE    2202mm     IFNE DEBUG
00000D8E                          2203mm     ENDC
00000D8E                          2204mm      
00000D8E  B43C 001B               2205mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00000D92  6700 F274               2206mm     BEQ START
00000D96                          2207mm     ENDM
00000D96                          2208m 
00000D96                 TRUE     2209m     IFEQ DEBUG
00000D96                          2210mm         PRINT_CHAR D2,D3                        ; ECHO IT BACK
00000D96                          2211mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D96                 TRUE     2212mm     IFEQ DEBUG
00000D96  1639 00C00003           2213mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000D9C  0803 0002               2214mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DA0  67F4                    2215mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DA2  13C2 00C00007           2216mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00000DA8                          2217mm     ENDC
00000DA8                          2218mm     
00000DA8                 FALSE    2219mm     IFNE DEBUG
00000DA8                          2220mm     ENDC
00000DA8                          2221mm 
00000DA8                          2222mm     ENDM
00000DA8                          2223m     ENDC
00000DA8                          2224m     ENDM
00000DA8                          2225m     HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000DA8  41F9 00000FEA           2226m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000DAE  0402 0030               2227m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DB2  C4BC 000000FF           2228m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000DB8  1430 2000               2229m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000DBC                          2230m     ENDM
00000DBC  8A02                    2231      OR.B D2,D5
00000DBE  023C 00FB               2232      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000DC2  57CE FFB6               2233      DBEQ D6,READ_LENGTH
00000DC6                          2234          
00000DC6                          2235m     PRINT_CRLF D3
00000DC6                          2236mm     PRINT_CHAR #13,D3                           ; CR
00000DC6                          2237mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC6                 TRUE     2238mm     IFEQ DEBUG
00000DC6  1639 00C00003           2239mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DCC  0803 0002               2240mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DD0  67F4                    2241mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DD2  13FC 000D 00C00007      2242mm         MOVE.B #13,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DDA                          2243mm     ENDC
00000DDA                          2244mm     
00000DDA                 FALSE    2245mm     IFNE DEBUG
00000DDA                          2246mm     ENDC
00000DDA                          2247mm 
00000DDA                          2248mm     ENDM
00000DDA                          2249mm     PRINT_CHAR #10,D3                           ; LF
00000DDA                          2250mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDA                 TRUE     2251mm     IFEQ DEBUG
00000DDA  1639 00C00003           2252mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000DE0  0803 0002               2253mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000DE4  67F4                    2254mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000DE6  13FC 000A 00C00007      2255mm         MOVE.B #10,DUART_TXA                    ; SEND THE NEXT CHARACTER
00000DEE                          2256mm     ENDC
00000DEE                          2257mm     
00000DEE                 FALSE    2258mm     IFNE DEBUG
00000DEE                          2259mm     ENDC
00000DEE                          2260mm 
00000DEE                          2261mm     ENDM
00000DEE                          2262m     ENDM
00000DEE                          2263  
00000DEE  207C 00000000           2264      MOVE.L #ROM,A0                              ; start of ROM
00000DF4                          2265      
00000DF4  2247                    2266      MOVE.L D7,A1                                ; address accumulator -> address register
00000DF6  7E00                    2267      MOVE.L #0,D7                                ; clear the now used address accumulator
00000DF8                          2268      
00000DF8  267C 00002AAA           2269      MOVE.L #$2AAA,A3
00000DFE  36BC AAAA               2270      MOVE.W #$AAAA,(A3)
00000E02  267C 00001554           2271      MOVE.L #$1554,A3
00000E08  36BC 5555               2272      MOVE.W #$5555,(A3)
00000E0C  267C 00002AAA           2273      MOVE.L #$2AAA,A3
00000E12  36BC 8080               2274      MOVE.W #$8080,(A3)
00000E16  267C 00002AAA           2275      MOVE.L #$2AAA,A3
00000E1C  36BC AAAA               2276      MOVE.W #$AAAA,(A3)
00000E20  267C 00001554           2277      MOVE.L #$1554,A3
00000E26  36BC 5555               2278      MOVE.W #$5555,(A3)
00000E2A  267C 00002AAA           2279      MOVE.L #$2AAA,A3
00000E30  36BC 2020               2280      MOVE.W #$2020,(A3)
00000E34                          2281      
00000E34  45F9 00001001           2282      LEA LOADING,A2                              ; important for timing
00000E3A                          2283m     PRINT_STR A2,D3
00000E3A                          2284m LOOP_156
00000E3A  0C12 0000               2285m     CMP.B #0,(A2)                               ; 0 -> DONE
00000E3E  6700 0018               2286m     BEQ EXIT_156
00000E42                          2287mm     PRINT_CHAR (A2)+,D3
00000E42                          2288mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E42                 TRUE     2289mm     IFEQ DEBUG
00000E42  1639 00C00003           2290mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00000E48  0803 0002               2291mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00000E4C  67F4                    2292mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E4E  13DA 00C00007           2293mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00000E54                          2294mm     ENDC
00000E54                          2295mm     
00000E54                 FALSE    2296mm     IFNE DEBUG
00000E54                          2297mm     ENDC
00000E54                          2298mm 
00000E54                          2299mm     ENDM
00000E54  4EF8 0E3A               2300m     JMP LOOP_156
00000E58                          2301m EXIT_156
00000E58                          2302m     ENDM
00000E58                          2303  
00000E58  023C 00FB               2304      ANDI #$FB,CCR                               ; clear the Z bit if set (from the OR above)
00000E5C                          2305      
00000E5C                          2306      WHILE D5 <GT> #0 DO
00000E5C                          2307s _10000018
00000E5C  BA7C 0000               2308s     CMP.W   #0,D5
00000E60  6F00 001E               2309s     BLE _10000019
00000E64  5585                    2310          SUB.L #2,D5
00000E66                          2311            
00000E66  13D1 00E00001           2312          MOVE.B (A1),DISPLAY
00000E6C  3091                    2313          MOVE.W (A1),(A0)                        ; write the data
00000E6E                          2314        
00000E6E                          2315  WAIT_FOR_COMPLETE
00000E6E  3410                    2316          MOVE.W (A0),D2
00000E70                          2317  
00000E70                          2318          IF D2 <NE> (A1) THEN
00000E70  B451                    2319s     CMP.W   (A1),D2
00000E72  6700 0006               2320s     BEQ _0000000A
00000E76  4EF8 0E6E               2321              JMP WAIT_FOR_COMPLETE
00000E7A                          2322          ENDI
00000E7A                          2323s _0000000A
00000E7A                          2324        
00000E7A  5488                    2325          ADD.L #2,A0
00000E7C  5489                    2326          ADD.L #2,A1
00000E7E                          2327      ENDW  
00000E7E  60DC                    2328s     BRA _10000018
00000E80                          2329s _10000019
00000E80                          2330      
00000E80  267C 00002AAA           2331      MOVE.L #$2AAA,A3
00000E86  36BC AAAA               2332      MOVE.W #$AAAA,(A3)
00000E8A  267C 00001554           2333      MOVE.L #$1554,A3
00000E90  36BC 5555               2334      MOVE.W #$5555,(A3)
00000E94  267C 00002AAA           2335      MOVE.L #$2AAA,A3
00000E9A  36BC A0A0               2336      MOVE.W #$A0A0,(A3)
00000E9E                          2337              
00000E9E  4EF8 0186               2338      JMP MAIN_LOOP
00000EA2                          2339          
00000EA2                          2340  HEX_DIGIT
00000EA2  E98F                    2341      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00000EA4                          2342m     HEX2BIN D2,D2,A0
00000EA4  41F9 00000FEA           2343m     LEA HEX2BIN_LUT,A0                          ; LOAD THE LOOKUP TABLE
00000EAA  0402 0030               2344m     SUB.B #'0',D2                               ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EAE  C4BC 000000FF           2345m     AND.L #$FF,D2                               ; IGNORE THE TOP 3 BYTES
00000EB4  1430 2000               2346m     MOVE.B 0(A0,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT      
00000EB8                          2347m     ENDM
00000EB8  8E02                    2348      OR.B D2,D7  
00000EBA  4EF8 01AE               2349      JMP GET_INPUT
00000EBE                          2350  
00000EBE  FFFF FFFF               2351      SIMHALT                                     ; halt simulator
00000EC2                          2352  
00000EC2                          2353  ; strings
00000EC2= 4D 44 46 2D 6D 6F ...   2354  VERSION DC.B 'MDF-mon V1.48 (10/04/2021)',13,10,0
00000EDF= 3F 20 48 65 6C 70 ...   2355  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'xxxxxxxxG Go',13,10,'Z Zap memory',10,13,'xxxxxxxxLxxxx Load to EEPROM',10,13,0
00000F76= 48 75 68 3F 0D 0A 00    2356  HUH     DC.B 'Huh?',13,10,0
00000F7D= 20 53 20 72 65 63 ...   2357  READ    DC.B ' S records read, start address = ',0
00000F9F= 57 3A 20 55 6E 6B ...   2358  UNREC   DC.B 'W: Unknown Srec type: ',0
00000FB6= 57 3A 20 43 53 20 ...   2359  CS_FAILURE   DC.B 'W: CS failure at ',0
00000FC8= 57 3A 20 52 41 4D ...   2360  RAM_ERROR DC.B 'W: RAM error at: ',0
00000FDA= 30 31 32 33 34 35 ...   2361  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00000FEA= 00 01 02 03 04 05 ...   2362  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001001= 4C 6F 61 64 69 6E ...   2363  LOADING  DC.B 'Loading EEPROM...',13,11,0
00001015                          2364      
00001015                          2365      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         FDA
CONTINUE_103        A08
CONTINUE_44         4AA
CONTINUE_47         4FA
CONTINUE_51         552
CONTINUE_59         610
CONTINUE_64         684
CONTINUE_69         702
CONTINUE_74         786
CONTINUE_79         814
CONTINUE_84         888
CONTINUE_89         8FC
CS_FAILURE          FB6
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            960
DOWNLOAD_BYTE       C31
DOWNLOAD_DONE       B28
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_110            AA6
EXIT_125            BA0
EXIT_135            CA8
EXIT_156            E58
EXIT_19             2E6
EXIT_21             30E
EXIT_23             336
EXIT_5              140
EXIT_96             99E
G                   C22
GET_INPUT           1AE
H                   2EA
HELP                EDF
HEX2BIN             134
HEX2BIN_LUT         FEA
HEX_DIGIT           EA2
HUH                 F76
L                   D32
LOADING             1001
LOOP_110            A88
LOOP_112            AD0
LOOP_120            B52
LOOP_125            B82
LOOP_127            BCC
LOOP_135            C8A
LOOP_137            CD6
LOOP_156            E3A
LOOP_19             2C8
LOOP_21             2F0
LOOP_23             318
LOOP_25             368
LOOP_5              122
LOOP_96             980
MAIN_LOOP           186
OK                  D28
PRINT_CHAR          273
PRINT_CRLF          48D
PRINT_REG           575
PRINT_STR           4EF
R                   33A
RAM                 200000
RAM_ERROR           FC8
READ                F7D
READ_CHAR           805
READ_DATA_TO_POKE   408
READ_LENGTH         D7A
RESET               4
ROM                 0
S                   486
STACK               0
START               8
UNREC               F9F
V                   312
VERSION             EC2
W                   3C0
WAIT_CHAR           665
WAIT_FOR_COMPLETE   E6E
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_100  9B0
WAIT_FOR_READY_101  9C4
WAIT_FOR_READY_103  9EC
WAIT_FOR_READY_105  A20
WAIT_FOR_READY_108  A52
WAIT_FOR_READY_109  A66
WAIT_FOR_READY_11   186
WAIT_FOR_READY_111  A90
WAIT_FOR_READY_113  AA6
WAIT_FOR_READY_114  ABA
WAIT_FOR_READY_116  AE4
WAIT_FOR_READY_118  AFA
WAIT_FOR_READY_119  B0E
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_121  B28
WAIT_FOR_READY_122  B3C
WAIT_FOR_READY_124  B66
WAIT_FOR_READY_126  B8A
WAIT_FOR_READY_128  BA2
WAIT_FOR_READY_129  BB6
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_131  BE0
WAIT_FOR_READY_133  BF6
WAIT_FOR_READY_134  C0A
WAIT_FOR_READY_136  C92
WAIT_FOR_READY_138  CAC
WAIT_FOR_READY_139  CC0
WAIT_FOR_READY_141  CEA
WAIT_FOR_READY_143  D00
WAIT_FOR_READY_144  D14
WAIT_FOR_READY_145  D34
WAIT_FOR_READY_147  D4E
WAIT_FOR_READY_149  D7C
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  D96
WAIT_FOR_READY_154  DC6
WAIT_FOR_READY_155  DDA
WAIT_FOR_READY_157  E42
WAIT_FOR_READY_17   26A
WAIT_FOR_READY_18   27E
WAIT_FOR_READY_20   2D0
WAIT_FOR_READY_22   2F8
WAIT_FOR_READY_24   320
WAIT_FOR_READY_26   33E
WAIT_FOR_READY_27   352
WAIT_FOR_READY_29   37C
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   392
WAIT_FOR_READY_32   3A6
WAIT_FOR_READY_33   3C2
WAIT_FOR_READY_35   3DC
WAIT_FOR_READY_37   40A
WAIT_FOR_READY_39   424
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   45A
WAIT_FOR_READY_43   46E
WAIT_FOR_READY_44   48E
WAIT_FOR_READY_46   4C8
WAIT_FOR_READY_47   4DE
WAIT_FOR_READY_49   512
WAIT_FOR_READY_51   536
WAIT_FOR_READY_53   56A
WAIT_FOR_READY_56   5A4
WAIT_FOR_READY_57   5B8
WAIT_FOR_READY_59   5F4
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   628
WAIT_FOR_READY_64   668
WAIT_FOR_READY_66   69C
WAIT_FOR_READY_69   6E6
WAIT_FOR_READY_71   71A
WAIT_FOR_READY_74   76A
WAIT_FOR_READY_76   79E
WAIT_FOR_READY_79   7F8
WAIT_FOR_READY_8    140
WAIT_FOR_READY_81   82C
WAIT_FOR_READY_84   86C
WAIT_FOR_READY_86   8A0
WAIT_FOR_READY_89   8E0
WAIT_FOR_READY_9    154
WAIT_FOR_READY_91   914
WAIT_FOR_READY_94   952
WAIT_FOR_READY_95   966
WAIT_FOR_READY_97   988
WAIT_FOR_READY_98   99E
WAIT_FOR_SRECORD    48E
Z                   C2A
_00000000           5D4
_00000001           9DC
_00000002           5E2
_00000003           7E0
_00000004           74C
_00000005           9DC
_00000006           952
_00000007           9DC
_00000008           B26
_00000009           C84
_0000000A           E7A
_10000000           52C
_10000001           596
_10000002           5EA
_10000003           654
_10000004           65E
_10000005           6C8
_10000006           6DC
_10000007           746
_10000008           750
_10000009           7D8
_1000000A           760
_1000000B           7CA
_1000000C           7EE
_1000000D           858
_1000000E           862
_1000000F           8CC
_10000010           8D6
_10000011           940
_10000012           9E2
_10000013           A4C
_10000014           C32
_10000015           C54
_10000016           C5C
_10000017           D2E
_10000018           E5C
_10000019           E80
