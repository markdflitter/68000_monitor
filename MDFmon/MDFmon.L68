00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 02/04/2021 19:51:43

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; tidy up layout (indentation and comments)
00000000                             9  ; stop using two registers in download
00000000                            10  ; add a .W and .B variants of PRINT_REG
00000000                            11  ; implement DOWNLOAD_BYTE
00000000                            12  ; fix being able to enter random chars when W'ing
00000000                            13  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            14  
00000000  =00000000                 15  DEBUG               EQU 0
00000000                            16  
00000000                            17  ; constants
00000000  =00E00000                 18  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 19  DISPLAY_            EQU $0
00000000  =00E00001                 20  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            21  
00000000  =00D30000                 22  DUART_BASE          EQU $D30000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000008                 31  DUART_MRB_          EQU $8
00000000  =00000009                 32  DUART_CSRB_         EQU $9
00000000  =00000009                 33  DUART_SRB_          EQU $9
00000000  =0000000A                 34  DUART_CRB_          EQU $A
00000000  =0000000B                 35  DUART_TXB_          EQU $B
00000000  =0000000B                 36  DUART_RXB_          EQU $B
00000000  =0000000C                 37  DUART_IVR_          EQU $C
00000000  =0000000D                 38  DUART_OPCR_         EQU $D
00000000  =0000000E                 39  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 40  DUART_RESET_OPR_    EQU $F
00000000                            41  RRRR
00000000  =00D30001                 42  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00D30003                 43  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00D30003                 44  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00D30005                 45  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00D30007                 46  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00D30007                 47  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            48  
00000000  =00D30011                 49  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00D30013                 50  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00D30013                 51  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00D30015                 52  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00D30017                 53  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00D30017                 54  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            55  
00000000  =00D30009                 56  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00D3000B                 57  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00D30019                 58  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00D3001B                 59  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00D3001D                 60  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00D3001F                 61  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            62  
00000000                            63  ; macros
00000000                            64  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            65  ; the input register is changed during the process
00000000                            66  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00000000                            67  BIN2HEX MACRO
00000000                            68    LEA BIN2HEX_LUT,\3                ; load the lookup table
00000000                            69    ROL.L #4,\1                       ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            70    MOVE.B \1,\2
00000000                            71    ANDI.L #$F,\2
00000000                            72    MOVE.B 0(\3,\2),\2                ; use that as an index into the LUT
00000000                            73    ENDM
00000000                            74  
00000000                            75  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            76  ; the input register is changed during the process
00000000                            77  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            78  HEX2BIN MACRO
00000000                            79    LEA HEX2BIN_LUT,\3                  ; load the lookup table
00000000                            80    SUB.B #'0',\1                       ; work out offset and mask off anything rogue
00000000                            81    AND.L #$FF,\1                       ; ignore the top 3 bytes
00000000                            82    MOVE.B 0(\3,\1),\2                  ; use that as an index into the LUT      
00000000                            83    ENDM
00000000                            84  
00000000                            85  ; send a single char to the serial port
00000000                            86  ; \1 = char to send, \2 = data register to use for status poll
00000000                            87  ; will stamp on D0 and D1 in debug mode
00000000                            88  PRINT_CHAR MACRO
00000000                            89  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                            90      IFEQ DEBUG
00000000                            91        MOVE.B DUART_SRA,\2           ; read status register
00000000                            92        BTST #2,\2                    ; check for space to send
00000000                            93        BEQ WAIT_FOR_READY\@          ; no space, check again
00000000                            94        MOVE.B \1,DUART_TXA           ; send the next character
00000000                            95      ENDC
00000000                            96      
00000000                            97      IFNE DEBUG
00000000                            98        MOVE.B \1,D1
00000000                            99        MOVE.L #6,D0   
00000000                           100        TRAP #15                      ; write to terminal in simulator
00000000                           101      ENDC
00000000                           102  
00000000                           103      ENDM
00000000                           104  
00000000                           105  ; send CR,LF to the serial port
00000000                           106  ; \1 = data register to use for status poll
00000000                           107  PRINT_CRLF MACRO                  
00000000                           108      PRINT_CHAR #13,\1             ; CR
00000000                           109      PRINT_CHAR #10,\1             ; LF
00000000                           110      ENDM
00000000                           111  
00000000                           112  ; send C-style, zero terminated string to the serial port
00000000                           113  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           114  PRINT_STR MACRO
00000000                           115  LOOP\@
00000000                           116      CMP.B #0,(\1)                 ; 0 -> done
00000000                           117      BEQ EXIT\@
00000000                           118      PRINT_CHAR (\1)+,\2
00000000                           119      JMP LOOP\@
00000000                           120  EXIT\@
00000000                           121      ENDM
00000000                           122    
00000000                           123  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           124  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register, 
00000000                           125  PRINT_REG MACRO
00000000                           126      PRINT_CHAR '0',\2           ;0x header
00000000                           127      PRINT_CHAR 'x',\2
00000000                           128      MOVE.L #7,\4                ; loop round all 8 hex characters of 4 bits each
00000000                           129  LOOP\@
00000000                           130      BIN2HEX \1,\3,\5
00000000                           131      PRINT_CHAR \3,\2
00000000                           132      DBEQ \4,LOOP\@
00000000                           133      ENDM
00000000                           134    
00000000                           135  ; wait for a char from the serial port
00000000                           136  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           137  ; will stamp on D0 and D1 in debug mode
00000000                           138  WAIT_CHAR MACRO
00000000                           139  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           140  
00000000                           141      IFEQ DEBUG
00000000                           142        MOVE.B DUART_SRA,\2         ; read status register
00000000                           143        BTST #0,\2                    ; check for character
00000000                           144        BEQ WAIT_FOR_READY\@          ; nothing, check again
00000000                           145      ENDC
00000000                           146      
00000000                           147      READ_CHAR \1
00000000                           148  
00000000                           149      IFEQ DEBUG
00000000                           150        PRINT_CHAR \1,\2            ; echo it back
00000000                           151      ENDC
00000000                           152      ENDM
00000000                           153      
00000000                           154  ; read a char from the serial port - assumes that there is one!
00000000                           155  ; \ 1= data register for read char
00000000                           156  ; will stamp on D0 and D1 in debug mode
00000000                           157  READ_CHAR MACRO
00000000                           158      IFEQ DEBUG
00000000                           159        MOVE.B DUART_RXA,\1         ; got a character, read it
00000000                           160      ENDC
00000000                           161      IFNE DEBUG
00000000                           162        MOVE.L #5,D0    
00000000                           163        TRAP #15                    ; read from keyboard in simulator
00000000                           164        MOVE.L D1,\1
00000000                           165      ENDC
00000000                           166       
00000000                           167      CMP.B #$1B,\1                 ; check for escape and go to start
00000000                           168      BEQ START
00000000                           169      ENDM
00000000                           170      
00000000                           171      
00000000                           172  ; read data from the download serial port
00000000                           173  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           174  DOWNLOAD MACRO
00000000                           175  WAIT_FOR_READY\@                  ; wait until the there is space to send
00000000                           176  
00000000                           177      MOVE.B DUART_SRA,\2           ; check for command
00000000                           178      BTST #0,\2                    ; check for character
00000000                           179      BEQ CONTINUE\@                ; nothing, continue
00000000                           180   
00000000                           181      READ_CHAR \1
00000000                           182  CONTINUE\@
00000000                           183      MOVE.B DUART_SRB,\2         ; read status register
00000000                           184      BTST #0,\2                  ; check for character
00000000                           185      BEQ WAIT_FOR_READY\@        ; nothing, check again
00000000                           186      
00000000                           187      MOVE.B DUART_RXB,\1         ; got a character, read it
00000000                           188      MOVE.B \1,DISPLAY           ; echo to the display
00000000                           189      
00000000                           190      ENDM
00000000                           191  
00000000                           192  
00000000                           193  ; register catalogue
00000000                           194  ; D0 - used for simulator I/O
00000000                           195  ; D1 - used for simulator I/O
00000000                           196  ; D2 - read character
00000000                           197  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           198  ; D4 - count of S records read
00000000                           199  ; D5 - data to write / data read / byte count for S record load
00000000                           200  ; D6 - working register used in R/W and download
00000000                           201  ; D7 - address accumulator / reset by download
00000000                           202  ; A0 - address of string to print 
00000000                           203  
00000000                           204  ; start vector
00000000                           205      ORG  $0
00000000= 00000000                 206      DC.L $00000000              ; PC
00000004= 00000000                 207      DC.L $00000000              ; SP
00000008                           208      
00000008                           209  ; start of program  
00000008                           210  START
00000008  13FC 0000 00E00001       211      MOVE.B #0,DISPLAY
00000010                           212  
00000010                           213  ; reset the UART in case of warm start
00000010  13FC 000A 00D30005       214      MOVE.B #$A,DUART_CRA            ; disable rx & tx
00000018  13FC 0050 00D30005       215      MOVE.B #$50,DUART_CRA           ; reset everyting
00000020  4E71                     216      NOP
00000022  13FC 0040 00D30005       217      MOVE.B #$40,DUART_CRA           
0000002A  4E71                     218      NOP
0000002C  13FC 0030 00D30005       219      MOVE.B #$30,DUART_CRA
00000034  4E71                     220      NOP
00000036  13FC 0020 00D30005       221      MOVE.B #$20,DUART_CRA
0000003E  4E71                     222      NOP
00000040  13FC 0010 00D30005       223      MOVE.B #$10,DUART_CRA   
00000048                           224  
00000048  13FC 000A 00D30015       225      MOVE.B #$A,DUART_CRB            ; disable rx & tx
00000050  13FC 0050 00D30015       226      MOVE.B #$50,DUART_CRB           ; reset everyting
00000058  4E71                     227      NOP
0000005A  13FC 0040 00D30015       228      MOVE.B #$40,DUART_CRB           
00000062  4E71                     229      NOP
00000064  13FC 0030 00D30015       230      MOVE.B #$30,DUART_CRB
0000006C  4E71                     231      NOP
0000006E  13FC 0020 00D30015       232      MOVE.B #$20,DUART_CRB
00000076  4E71                     233      NOP
00000078  13FC 0010 00D30015       234      MOVE.B #$10,DUART_CRB   
00000080                           235  
00000080                           236  ;initialise UART
00000080  13FC 0000 00D30009       237      MOVE.B #$0,DUART_ACR            
00000088  13FC 0000 00D3000B       238      MOVE.B #$0,DUART_IMR            ; no interrupts, please            
00000090  13FC 0000 00D3001B       239      MOVE.B #$0,DUART_OPCR           ; enable all outputs
00000098                           240  
00000098                           241  ; channel A
00000098  13FC 0013 00D30001       242      MOVE.B #$13,DUART_MRA           ; no flow control, no parity, 8 data bits
000000A0  13FC 0007 00D30001       243      MOVE.B #$07,DUART_MRA           ; 1 stop bit
000000A8  13FC 00BB 00D30003       244      MOVE.B #$BB,DUART_CSRA          ; 9600 baud
000000B0  13FC 0005 00D30005       245      MOVE.B #$5,DUART_CRA            ; enable rx & tx
000000B8                           246  
000000B8                           247  ; channel B
000000B8  13FC 0013 00D30011       248      MOVE.B #$13,DUART_MRB           ; no flow control, no parity, 8 data bits
000000C0  13FC 0007 00D30011       249      MOVE.B #$07,DUART_MRB           ; 1 stop bit
000000C8  13FC 00BB 00D30013       250      MOVE.B #$BB,DUART_CSRB          ; 9600 baud
000000D0  13FC 0005 00D30015       251      MOVE.B #$5,DUART_CRB            ; enable rx & tx
000000D8                           252  
000000D8                           253m     PRINT_CHAR '.',D3               ; give the serial port chance to settle after reset
000000D8                           254m WAIT_FOR_READY_1                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D8                 TRUE      255m     IFEQ DEBUG
000000D8  1639 00D30003            256m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000DE  0803 0002                257m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000E2  67F4                     258m       BEQ WAIT_FOR_READY_1          ; NO SPACE, CHECK AGAIN
000000E4  13F8 002E 00D30007       259m       MOVE.B '.',DUART_TXA           ; SEND THE NEXT CHARACTER
000000EC                           260m     ENDC
000000EC                           261m     
000000EC                 FALSE     262m     IFNE DEBUG
000000EC                           263m     ENDC
000000EC                           264m 
000000EC                           265m     ENDM
000000EC                           266  
000000EC  13FC 0001 00E00001       267      MOVE.B #1,DISPLAY
000000F4                           268         
000000F4                           269m     PRINT_CRLF D3
000000F4                           270mm     PRINT_CHAR #13,D3             ; CR
000000F4                           271mm WAIT_FOR_READY_3                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      272mm     IFEQ DEBUG
000000F4  1639 00D30003            273mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000000FA  0803 0002                274mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000000FE  67F4                     275mm       BEQ WAIT_FOR_READY_3          ; NO SPACE, CHECK AGAIN
00000100  13FC 000D 00D30007       276mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000108                           277mm     ENDC
00000108                           278mm     
00000108                 FALSE     279mm     IFNE DEBUG
00000108                           280mm     ENDC
00000108                           281mm 
00000108                           282mm     ENDM
00000108                           283mm     PRINT_CHAR #10,D3             ; LF
00000108                           284mm WAIT_FOR_READY_4                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000108                 TRUE      285mm     IFEQ DEBUG
00000108  1639 00D30003            286mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000010E  0803 0002                287mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000112  67F4                     288mm       BEQ WAIT_FOR_READY_4          ; NO SPACE, CHECK AGAIN
00000114  13FC 000A 00D30007       289mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000011C                           290mm     ENDC
0000011C                           291mm     
0000011C                 FALSE     292mm     IFNE DEBUG
0000011C                           293mm     ENDC
0000011C                           294mm 
0000011C                           295mm     ENDM
0000011C                           296m     ENDM
0000011C                           297  
0000011C  41F9 00000EF6            298      LEA VERSION,A0
00000122                           299m     PRINT_STR A0,D3
00000122                           300m LOOP_5
00000122  0C10 0000                301m     CMP.B #0,(A0)                 ; 0 -> DONE
00000126  6700 0018                302m     BEQ EXIT_5
0000012A                           303mm     PRINT_CHAR (A0)+,D3
0000012A                           304mm WAIT_FOR_READY_6                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      305mm     IFEQ DEBUG
0000012A  1639 00D30003            306mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000130  0803 0002                307mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000134  67F4                     308mm       BEQ WAIT_FOR_READY_6          ; NO SPACE, CHECK AGAIN
00000136  13D8 00D30007            309mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
0000013C                           310mm     ENDC
0000013C                           311mm     
0000013C                 FALSE     312mm     IFNE DEBUG
0000013C                           313mm     ENDC
0000013C                           314mm 
0000013C                           315mm     ENDM
0000013C  4EF8 0122                316m     JMP LOOP_5
00000140                           317m EXIT_5
00000140                           318m     ENDM
00000140                           319m     PRINT_CRLF D3
00000140                           320mm     PRINT_CHAR #13,D3             ; CR
00000140                           321mm WAIT_FOR_READY_8                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000140                 TRUE      322mm     IFEQ DEBUG
00000140  1639 00D30003            323mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000146  0803 0002                324mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000014A  67F4                     325mm       BEQ WAIT_FOR_READY_8          ; NO SPACE, CHECK AGAIN
0000014C  13FC 000D 00D30007       326mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000154                           327mm     ENDC
00000154                           328mm     
00000154                 FALSE     329mm     IFNE DEBUG
00000154                           330mm     ENDC
00000154                           331mm 
00000154                           332mm     ENDM
00000154                           333mm     PRINT_CHAR #10,D3             ; LF
00000154                           334mm WAIT_FOR_READY_9                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000154                 TRUE      335mm     IFEQ DEBUG
00000154  1639 00D30003            336mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000015A  0803 0002                337mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000015E  67F4                     338mm       BEQ WAIT_FOR_READY_9          ; NO SPACE, CHECK AGAIN
00000160  13FC 000A 00D30007       339mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000168                           340mm     ENDC
00000168                           341mm     
00000168                 FALSE     342mm     IFNE DEBUG
00000168                           343mm     ENDC
00000168                           344mm 
00000168                           345mm     ENDM
00000168                           346m     ENDM
00000168                           347m     PRINT_CHAR #7,D3
00000168                           348m WAIT_FOR_READY_10                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000168                 TRUE      349m     IFEQ DEBUG
00000168  1639 00D30003            350m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000016E  0803 0002                351m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000172  67F4                     352m       BEQ WAIT_FOR_READY_10          ; NO SPACE, CHECK AGAIN
00000174  13FC 0007 00D30007       353m       MOVE.B #7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000017C                           354m     ENDC
0000017C                           355m     
0000017C                 FALSE     356m     IFNE DEBUG
0000017C                           357m     ENDC
0000017C                           358m 
0000017C                           359m     ENDM
0000017C                           360  
0000017C  7E00                     361      MOVE.L #0,D7                    ; address accumulator
0000017E                           362  
0000017E  13FC 0002 00E00001       363      MOVE.B #2,DISPLAY
00000186                           364  MAIN_LOOP
00000186                           365m     PRINT_CHAR #'>',D3               ; prompt
00000186                           366m WAIT_FOR_READY_11                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      367m     IFEQ DEBUG
00000186  1639 00D30003            368m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000018C  0803 0002                369m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000190  67F4                     370m       BEQ WAIT_FOR_READY_11          ; NO SPACE, CHECK AGAIN
00000192  13FC 003E 00D30007       371m       MOVE.B #'>',DUART_TXA           ; SEND THE NEXT CHARACTER
0000019A                           372m     ENDC
0000019A                           373m     
0000019A                 FALSE     374m     IFNE DEBUG
0000019A                           375m     ENDC
0000019A                           376m 
0000019A                           377m     ENDM
0000019A                           378m     PRINT_CHAR #32,D3                ; space
0000019A                           379m WAIT_FOR_READY_12                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      380m     IFEQ DEBUG
0000019A  1639 00D30003            381m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001A0  0803 0002                382m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001A4  67F4                     383m       BEQ WAIT_FOR_READY_12          ; NO SPACE, CHECK AGAIN
000001A6  13FC 0020 00D30007       384m       MOVE.B #32,DUART_TXA           ; SEND THE NEXT CHARACTER
000001AE                           385m     ENDC
000001AE                           386m     
000001AE                 FALSE     387m     IFNE DEBUG
000001AE                           388m     ENDC
000001AE                           389m 
000001AE                           390m     ENDM
000001AE                           391      
000001AE                           392  GET_INPUT
000001AE                           393m     WAIT_CHAR D2,D3                  ; fetch character from serial port -> D2
000001AE                           394m WAIT_FOR_READY_13                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001AE                           395m 
000001AE                 TRUE      396m     IFEQ DEBUG
000001AE  1639 00D30003            397m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000001B4  0803 0000                398m       BTST #0,D3                    ; CHECK FOR CHARACTER
000001B8  67F4                     399m       BEQ WAIT_FOR_READY_13          ; NOTHING, CHECK AGAIN
000001BA                           400m     ENDC
000001BA                           401m     
000001BA                           402mm     READ_CHAR D2
000001BA                 TRUE      403mm     IFEQ DEBUG
000001BA  1439 00D30007            404mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000001C0                           405mm     ENDC
000001C0                 FALSE     406mm     IFNE DEBUG
000001C0                           407mm     ENDC
000001C0                           408mm      
000001C0  B43C 001B                409mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000001C4  6700 FE42                410mm     BEQ START
000001C8                           411mm     ENDM
000001C8                           412m 
000001C8                 TRUE      413m     IFEQ DEBUG
000001C8                           414mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000001C8                           415mm WAIT_FOR_READY_15                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001C8                 TRUE      416mm     IFEQ DEBUG
000001C8  1639 00D30003            417mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000001CE  0803 0002                418mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000001D2  67F4                     419mm       BEQ WAIT_FOR_READY_15          ; NO SPACE, CHECK AGAIN
000001D4  13C2 00D30007            420mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000001DA                           421mm     ENDC
000001DA                           422mm     
000001DA                 FALSE     423mm     IFNE DEBUG
000001DA                           424mm     ENDC
000001DA                           425mm 
000001DA                           426mm     ENDM
000001DA                           427m     ENDC
000001DA                           428m     ENDM
000001DA                           429      
000001DA  B43C 0030                430      CMP.B #'0',D2
000001DE  6700 0CF6                431      BEQ HEX_DIGIT
000001E2  B43C 0031                432      CMP.B #'1',D2
000001E6  6700 0CEE                433      BEQ HEX_DIGIT
000001EA  B43C 0032                434      CMP.B #'2',D2
000001EE  6700 0CE6                435      BEQ HEX_DIGIT
000001F2  B43C 0033                436      CMP.B #'3',D2
000001F6  6700 0CDE                437      BEQ HEX_DIGIT
000001FA  B43C 0034                438      CMP.B #'4',D2
000001FE  6700 0CD6                439      BEQ HEX_DIGIT
00000202  B43C 0035                440      CMP.B #'5',D2
00000206  6700 0CCE                441      BEQ HEX_DIGIT
0000020A  B43C 0036                442      CMP.B #'6',D2
0000020E  6700 0CC6                443      BEQ HEX_DIGIT
00000212  B43C 0037                444      CMP.B #'7',D2
00000216  6700 0CBE                445      BEQ HEX_DIGIT
0000021A  B43C 0038                446      CMP.B #'8',D2
0000021E  6700 0CB6                447      BEQ HEX_DIGIT
00000222  B43C 0039                448      CMP.B #'9',D2
00000226  6700 0CAE                449      BEQ HEX_DIGIT
0000022A  B43C 0041                450      CMP.B #'A',D2
0000022E  6700 0CA6                451      BEQ HEX_DIGIT
00000232  B43C 0042                452      CMP.B #'B',D2
00000236  6700 0C9E                453      BEQ HEX_DIGIT
0000023A  B43C 0043                454      CMP.B #'C',D2
0000023E  6700 0C96                455      BEQ HEX_DIGIT
00000242  B43C 0044                456      CMP.B #'D',D2
00000246  6700 0C8E                457      BEQ HEX_DIGIT
0000024A  B43C 0045                458      CMP.B #'E',D2
0000024E  6700 0C86                459      BEQ HEX_DIGIT
00000252  B43C 0046                460      CMP.B #'F',D2
00000256  6700 0C7E                461      BEQ HEX_DIGIT
0000025A                           462      
0000025A  B43C 0057                463      CMP.B #'W',D2
0000025E  6700 0150                464      BEQ W
00000262                           465  
00000262                           466m     PRINT_CRLF D3
00000262                           467mm     PRINT_CHAR #13,D3             ; CR
00000262                           468mm WAIT_FOR_READY_17                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      469mm     IFEQ DEBUG
00000262  1639 00D30003            470mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000268  0803 0002                471mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000026C  67F4                     472mm       BEQ WAIT_FOR_READY_17          ; NO SPACE, CHECK AGAIN
0000026E  13FC 000D 00D30007       473mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000276                           474mm     ENDC
00000276                           475mm     
00000276                 FALSE     476mm     IFNE DEBUG
00000276                           477mm     ENDC
00000276                           478mm 
00000276                           479mm     ENDM
00000276                           480mm     PRINT_CHAR #10,D3             ; LF
00000276                           481mm WAIT_FOR_READY_18                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000276                 TRUE      482mm     IFEQ DEBUG
00000276  1639 00D30003            483mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000027C  0803 0002                484mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000280  67F4                     485mm       BEQ WAIT_FOR_READY_18          ; NO SPACE, CHECK AGAIN
00000282  13FC 000A 00D30007       486mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
0000028A                           487mm     ENDC
0000028A                           488mm     
0000028A                 FALSE     489mm     IFNE DEBUG
0000028A                           490mm     ENDC
0000028A                           491mm 
0000028A                           492mm     ENDM
0000028A                           493m     ENDM
0000028A                           494   
0000028A  B43C 003F                495      CMP.B #'?',D2
0000028E  6700 004A                496      BEQ H
00000292                           497  
00000292  B43C 0056                498      CMP.B #'V',D2
00000296  6700 006A                499      BEQ V
0000029A                           500      
0000029A  B43C 0052                501      CMP.B #'R',D2
0000029E  6700 008A                502      BEQ R
000002A2                           503  
000002A2  B43C 0053                504      CMP.B #'S',D2
000002A6  6700 01CE                505      BEQ S
000002AA                           506  
000002AA  B43C 0047                507      CMP.B #'G',D2
000002AE  6700 0C1E                508      BEQ G   
000002B2                           509  
000002B2  41F9 00000F7D            510      LEA HUH,A0
000002B8                           511m     PRINT_STR A0,D3
000002B8                           512m LOOP_19
000002B8  0C10 0000                513m     CMP.B #0,(A0)                 ; 0 -> DONE
000002BC  6700 0018                514m     BEQ EXIT_19
000002C0                           515mm     PRINT_CHAR (A0)+,D3
000002C0                           516mm WAIT_FOR_READY_20                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      517mm     IFEQ DEBUG
000002C0  1639 00D30003            518mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002C6  0803 0002                519mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002CA  67F4                     520mm       BEQ WAIT_FOR_READY_20          ; NO SPACE, CHECK AGAIN
000002CC  13D8 00D30007            521mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002D2                           522mm     ENDC
000002D2                           523mm     
000002D2                 FALSE     524mm     IFNE DEBUG
000002D2                           525mm     ENDC
000002D2                           526mm 
000002D2                           527mm     ENDM
000002D2  4EF8 02B8                528m     JMP LOOP_19
000002D6                           529m EXIT_19
000002D6                           530m     ENDM
000002D6                           531                         
000002D6  4EF8 0186                532      JMP MAIN_LOOP
000002DA                           533      
000002DA                           534  ; commands
000002DA  41F9 00000F12            535  H   LEA HELP,A0
000002E0                           536m     PRINT_STR A0,D3
000002E0                           537m LOOP_21
000002E0  0C10 0000                538m     CMP.B #0,(A0)                 ; 0 -> DONE
000002E4  6700 0018                539m     BEQ EXIT_21
000002E8                           540mm     PRINT_CHAR (A0)+,D3
000002E8                           541mm WAIT_FOR_READY_22                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      542mm     IFEQ DEBUG
000002E8  1639 00D30003            543mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000002EE  0803 0002                544mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000002F2  67F4                     545mm       BEQ WAIT_FOR_READY_22          ; NO SPACE, CHECK AGAIN
000002F4  13D8 00D30007            546mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
000002FA                           547mm     ENDC
000002FA                           548mm     
000002FA                 FALSE     549mm     IFNE DEBUG
000002FA                           550mm     ENDC
000002FA                           551mm 
000002FA                           552mm     ENDM
000002FA  4EF8 02E0                553m     JMP LOOP_21
000002FE                           554m EXIT_21
000002FE                           555m     ENDM
000002FE  4EF8 0186                556      JMP MAIN_LOOP
00000302                           557  
00000302  41F9 00000EF6            558  V   LEA VERSION,A0
00000308                           559m     PRINT_STR A0,D3       
00000308                           560m LOOP_23
00000308  0C10 0000                561m     CMP.B #0,(A0)                 ; 0 -> DONE
0000030C  6700 0018                562m     BEQ EXIT_23
00000310                           563mm     PRINT_CHAR (A0)+,D3
00000310                           564mm WAIT_FOR_READY_24                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000310                 TRUE      565mm     IFEQ DEBUG
00000310  1639 00D30003            566mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000316  0803 0002                567mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000031A  67F4                     568mm       BEQ WAIT_FOR_READY_24          ; NO SPACE, CHECK AGAIN
0000031C  13D8 00D30007            569mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000322                           570mm     ENDC
00000322                           571mm     
00000322                 FALSE     572mm     IFNE DEBUG
00000322                           573mm     ENDC
00000322                           574mm 
00000322                           575mm     ENDM
00000322  4EF8 0308                576m     JMP LOOP_23
00000326                           577m EXIT_23
00000326                           578m     ENDM
00000326  4EF8 0186                579      JMP MAIN_LOOP
0000032A                           580      
0000032A                           581  R   
0000032A  2047                     582      MOVE.L D7,A0                    ; address accumulator -> address register
0000032C  2A10                     583      MOVE.L (A0),D5                  ; read the memory and print it
0000032E                           584m     PRINT_REG D5,D3,D7,D6,A0
0000032E                           585mm     PRINT_CHAR '0',D3           ;0X HEADER
0000032E                           586mm WAIT_FOR_READY_26                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000032E                 TRUE      587mm     IFEQ DEBUG
0000032E  1639 00D30003            588mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000334  0803 0002                589mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000338  67F4                     590mm       BEQ WAIT_FOR_READY_26          ; NO SPACE, CHECK AGAIN
0000033A  13F8 0030 00D30007       591mm       MOVE.B '0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000342                           592mm     ENDC
00000342                           593mm     
00000342                 FALSE     594mm     IFNE DEBUG
00000342                           595mm     ENDC
00000342                           596mm 
00000342                           597mm     ENDM
00000342                           598mm     PRINT_CHAR 'x',D3
00000342                           599mm WAIT_FOR_READY_27                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000342                 TRUE      600mm     IFEQ DEBUG
00000342  1639 00D30003            601mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000348  0803 0002                602mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000034C  67F4                     603mm       BEQ WAIT_FOR_READY_27          ; NO SPACE, CHECK AGAIN
0000034E  13F8 0078 00D30007       604mm       MOVE.B 'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000356                           605mm     ENDC
00000356                           606mm     
00000356                 FALSE     607mm     IFNE DEBUG
00000356                           608mm     ENDC
00000356                           609mm 
00000356                           610mm     ENDM
00000356  7C07                     611m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000358                           612m LOOP_25
00000358                           613mm     BIN2HEX D5,D7,A0
00000358  41F9 00001002            614mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
0000035E  E99D                     615mm   ROL.L #4,D5                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000360  1E05                     616mm   MOVE.B D5,D7
00000362  0287 0000000F            617mm   ANDI.L #$F,D7
00000368  1E30 7000                618mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
0000036C                           619mm   ENDM
0000036C                           620mm     PRINT_CHAR D7,D3
0000036C                           621mm WAIT_FOR_READY_29                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036C                 TRUE      622mm     IFEQ DEBUG
0000036C  1639 00D30003            623mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000372  0803 0002                624mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000376  67F4                     625mm       BEQ WAIT_FOR_READY_29          ; NO SPACE, CHECK AGAIN
00000378  13C7 00D30007            626mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
0000037E                           627mm     ENDC
0000037E                           628mm     
0000037E                 FALSE     629mm     IFNE DEBUG
0000037E                           630mm     ENDC
0000037E                           631mm 
0000037E                           632mm     ENDM
0000037E  57CE FFD8                633m     DBEQ D6,LOOP_25
00000382                           634m     ENDM
00000382                           635m     PRINT_CRLF D3
00000382                           636mm     PRINT_CHAR #13,D3             ; CR
00000382                           637mm WAIT_FOR_READY_31                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000382                 TRUE      638mm     IFEQ DEBUG
00000382  1639 00D30003            639mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000388  0803 0002                640mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000038C  67F4                     641mm       BEQ WAIT_FOR_READY_31          ; NO SPACE, CHECK AGAIN
0000038E  13FC 000D 00D30007       642mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000396                           643mm     ENDC
00000396                           644mm     
00000396                 FALSE     645mm     IFNE DEBUG
00000396                           646mm     ENDC
00000396                           647mm 
00000396                           648mm     ENDM
00000396                           649mm     PRINT_CHAR #10,D3             ; LF
00000396                           650mm WAIT_FOR_READY_32                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000396                 TRUE      651mm     IFEQ DEBUG
00000396  1639 00D30003            652mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000039C  0803 0002                653mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003A0  67F4                     654mm       BEQ WAIT_FOR_READY_32          ; NO SPACE, CHECK AGAIN
000003A2  13FC 000A 00D30007       655mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000003AA                           656mm     ENDC
000003AA                           657mm     
000003AA                 FALSE     658mm     IFNE DEBUG
000003AA                           659mm     ENDC
000003AA                           660mm 
000003AA                           661mm     ENDM
000003AA                           662m     ENDM
000003AA  7E00                     663      MOVE.L #0,D7                    ; clear the now used address accumulator
000003AC  4EF8 0186                664      JMP MAIN_LOOP
000003B0                           665  
000003B0  7A00                     666  W   MOVE.L #0,D5                    ; D5 will be the value to write            
000003B2                           667  
000003B2                           668m     WAIT_CHAR D2,D3                 ; read most significant character -> D2
000003B2                           669m WAIT_FOR_READY_33                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B2                           670m 
000003B2                 TRUE      671m     IFEQ DEBUG
000003B2  1639 00D30003            672m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
000003B8  0803 0000                673m       BTST #0,D3                    ; CHECK FOR CHARACTER
000003BC  67F4                     674m       BEQ WAIT_FOR_READY_33          ; NOTHING, CHECK AGAIN
000003BE                           675m     ENDC
000003BE                           676m     
000003BE                           677mm     READ_CHAR D2
000003BE                 TRUE      678mm     IFEQ DEBUG
000003BE  1439 00D30007            679mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000003C4                           680mm     ENDC
000003C4                 FALSE     681mm     IFNE DEBUG
000003C4                           682mm     ENDC
000003C4                           683mm      
000003C4  B43C 001B                684mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000003C8  6700 FC3E                685mm     BEQ START
000003CC                           686mm     ENDM
000003CC                           687m 
000003CC                 TRUE      688m     IFEQ DEBUG
000003CC                           689mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
000003CC                           690mm WAIT_FOR_READY_35                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003CC                 TRUE      691mm     IFEQ DEBUG
000003CC  1639 00D30003            692mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000003D2  0803 0002                693mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000003D6  67F4                     694mm       BEQ WAIT_FOR_READY_35          ; NO SPACE, CHECK AGAIN
000003D8  13C2 00D30007            695mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000003DE                           696mm     ENDC
000003DE                           697mm     
000003DE                 FALSE     698mm     IFNE DEBUG
000003DE                           699mm     ENDC
000003DE                           700mm 
000003DE                           701mm     ENDM
000003DE                           702m     ENDC
000003DE                           703m     ENDM
000003DE                           704m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
000003DE  41F9 00001012            705m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000003E4  0402 0030                706m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003E8  C4BC 000000FF            707m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000003EE  1430 2000                708m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000003F2                           709m   ENDM
000003F2  1A02                     710      MOVE.B D2,D5                    ; put at bottom of D5
000003F4                           711  
000003F4  3C3C 0006                712      MOVE #6,D6                      ; 7 bytes left to read
000003F8                           713      
000003F8                           714  READ_DATA_TO_POKE
000003F8  E98D                     715      LSL.L #4,D5                     ; make what we have so far more significant
000003FA                           716m     WAIT_CHAR D2,D3                 ; next character -> D2
000003FA                           717m WAIT_FOR_READY_37                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003FA                           718m 
000003FA                 TRUE      719m     IFEQ DEBUG
000003FA  1639 00D30003            720m       MOVE.B DUART_SRA,D3         ; READ STATUS REGISTER
00000400  0803 0000                721m       BTST #0,D3                    ; CHECK FOR CHARACTER
00000404  67F4                     722m       BEQ WAIT_FOR_READY_37          ; NOTHING, CHECK AGAIN
00000406                           723m     ENDC
00000406                           724m     
00000406                           725mm     READ_CHAR D2
00000406                 TRUE      726mm     IFEQ DEBUG
00000406  1439 00D30007            727mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000040C                           728mm     ENDC
0000040C                 FALSE     729mm     IFNE DEBUG
0000040C                           730mm     ENDC
0000040C                           731mm      
0000040C  B43C 001B                732mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000410  6700 FBF6                733mm     BEQ START
00000414                           734mm     ENDM
00000414                           735m 
00000414                 TRUE      736m     IFEQ DEBUG
00000414                           737mm       PRINT_CHAR D2,D3            ; ECHO IT BACK
00000414                           738mm WAIT_FOR_READY_39                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000414                 TRUE      739mm     IFEQ DEBUG
00000414  1639 00D30003            740mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000041A  0803 0002                741mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000041E  67F4                     742mm       BEQ WAIT_FOR_READY_39          ; NO SPACE, CHECK AGAIN
00000420  13C2 00D30007            743mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000426                           744mm     ENDC
00000426                           745mm     
00000426                 FALSE     746mm     IFNE DEBUG
00000426                           747mm     ENDC
00000426                           748mm 
00000426                           749mm     ENDM
00000426                           750m     ENDC
00000426                           751m     ENDM
00000426                           752m     HEX2BIN D2,D2,A0                ; convert to binary -> D2
00000426  41F9 00001012            753m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000042C  0402 0030                754m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000430  C4BC 000000FF            755m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000436  1430 2000                756m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000043A                           757m   ENDM
0000043A  8A02                     758      OR.B D2,D5
0000043C  023C 00FB                759      ANDI #$FB,CCR                   ; clear the Z bit if set (from the OR above)
00000440  57CE FFB6                760      DBEQ D6,READ_DATA_TO_POKE
00000444                           761      
00000444  2047                     762      MOVE.L D7,A0                    ; address accumulator -> address register
00000446  7E00                     763      MOVE.L #0,D7                    ; clear the now used address accumulator
00000448                           764      
00000448  2085                     765      MOVE.L D5,(A0)                  ; write the data
0000044A                           766  
0000044A                           767m     PRINT_CRLF D3
0000044A                           768mm     PRINT_CHAR #13,D3             ; CR
0000044A                           769mm WAIT_FOR_READY_42                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000044A                 TRUE      770mm     IFEQ DEBUG
0000044A  1639 00D30003            771mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000450  0803 0002                772mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000454  67F4                     773mm       BEQ WAIT_FOR_READY_42          ; NO SPACE, CHECK AGAIN
00000456  13FC 000D 00D30007       774mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000045E                           775mm     ENDC
0000045E                           776mm     
0000045E                 FALSE     777mm     IFNE DEBUG
0000045E                           778mm     ENDC
0000045E                           779mm 
0000045E                           780mm     ENDM
0000045E                           781mm     PRINT_CHAR #10,D3             ; LF
0000045E                           782mm WAIT_FOR_READY_43                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000045E                 TRUE      783mm     IFEQ DEBUG
0000045E  1639 00D30003            784mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000464  0803 0002                785mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000468  67F4                     786mm       BEQ WAIT_FOR_READY_43          ; NO SPACE, CHECK AGAIN
0000046A  13FC 000A 00D30007       787mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000472                           788mm     ENDC
00000472                           789mm     
00000472                 FALSE     790mm     IFNE DEBUG
00000472                           791mm     ENDC
00000472                           792mm 
00000472                           793mm     ENDM
00000472                           794m     ENDM
00000472  4EF8 0186                795      JMP MAIN_LOOP
00000476                           796  
00000476                           797  
00000476  7800                     798  S   MOVE.L #0,D4                    ; count of records read -> D4
00000478  2478 0000                799      MOVE.L 0,A2                     ; start address -> A2
0000047C                           800      
0000047C                           801  WAIT_FOR_SRECORD                    ; wait for the start of a record, indicated by 'S'
0000047C                           802m     DOWNLOAD D2,D3                  
0000047C                           803m WAIT_FOR_READY_44                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047C                           804m 
0000047C  1639 00D30003            805m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000482  0803 0000                806m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000486  6700 0010                807m     BEQ CONTINUE_44                ; NOTHING, CONTINUE
0000048A                           808m  
0000048A                           809mm     READ_CHAR D2
0000048A                 TRUE      810mm     IFEQ DEBUG
0000048A  1439 00D30007            811mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000490                           812mm     ENDC
00000490                 FALSE     813mm     IFNE DEBUG
00000490                           814mm     ENDC
00000490                           815mm      
00000490  B43C 001B                816mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000494  6700 FB72                817mm     BEQ START
00000498                           818mm     ENDM
00000498                           819m CONTINUE_44
00000498  1639 00D30013            820m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000049E  0803 0000                821m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004A2  67D8                     822m     BEQ WAIT_FOR_READY_44        ; NOTHING, CHECK AGAIN
000004A4                           823m     
000004A4  1439 00D30017            824m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000004AA  13C2 00E00001            825m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000004B0                           826m     
000004B0                           827m     ENDM
000004B0  B43C 0053                828      CMP.B #'S',D2                   ; found S?    
000004B4  66C6                     829      BNE WAIT_FOR_SRECORD            ; nope, keep waiting
000004B6                           830      
000004B6  5284                     831      ADD.L #1,D4                     ; read another S record, increment count
000004B8                           832      
000004B8                           833m     DOWNLOAD D7,D3                  ; read the record digit
000004B8                           834m WAIT_FOR_READY_46                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B8                           835m 
000004B8  1639 00D30003            836m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004BE  0803 0000                837m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004C2  6700 0010                838m     BEQ CONTINUE_46                ; NOTHING, CONTINUE
000004C6                           839m  
000004C6                           840mm     READ_CHAR D7
000004C6                 TRUE      841mm     IFEQ DEBUG
000004C6  1E39 00D30007            842mm       MOVE.B DUART_RXA,D7         ; GOT A CHARACTER, READ IT
000004CC                           843mm     ENDC
000004CC                 FALSE     844mm     IFNE DEBUG
000004CC                           845mm     ENDC
000004CC                           846mm      
000004CC  BE3C 001B                847mm     CMP.B #$1B,D7                 ; CHECK FOR ESCAPE AND GO TO START
000004D0  6700 FB36                848mm     BEQ START
000004D4                           849mm     ENDM
000004D4                           850m CONTINUE_46
000004D4  1639 00D30013            851m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000004DA  0803 0000                852m     BTST #0,D3                  ; CHECK FOR CHARACTER
000004DE  67D8                     853m     BEQ WAIT_FOR_READY_46        ; NOTHING, CHECK AGAIN
000004E0                           854m     
000004E0  1E39 00D30017            855m     MOVE.B DUART_RXB,D7         ; GOT A CHARACTER, READ IT
000004E6  13C7 00E00001            856m     MOVE.B D7,DISPLAY           ; ECHO TO THE DISPLAY
000004EC                           857m     
000004EC                           858m     ENDM
000004EC                           859  
000004EC  7C00                     860      MOVE.L #0,D6                    ; checksum
000004EE                           861  
000004EE  7A00                     862      MOVE.L #0,D5                    ; read the 2 digit byte count -> D5
000004F0                           863m     DOWNLOAD D2,D3              
000004F0                           864m WAIT_FOR_READY_48                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F0                           865m 
000004F0  1639 00D30003            866m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000004F6  0803 0000                867m     BTST #0,D3                    ; CHECK FOR CHARACTER
000004FA  6700 0010                868m     BEQ CONTINUE_48                ; NOTHING, CONTINUE
000004FE                           869m  
000004FE                           870mm     READ_CHAR D2
000004FE                 TRUE      871mm     IFEQ DEBUG
000004FE  1439 00D30007            872mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000504                           873mm     ENDC
00000504                 FALSE     874mm     IFNE DEBUG
00000504                           875mm     ENDC
00000504                           876mm      
00000504  B43C 001B                877mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000508  6700 FAFE                878mm     BEQ START
0000050C                           879mm     ENDM
0000050C                           880m CONTINUE_48
0000050C  1639 00D30013            881m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000512  0803 0000                882m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000516  67D8                     883m     BEQ WAIT_FOR_READY_48        ; NOTHING, CHECK AGAIN
00000518                           884m     
00000518  1439 00D30017            885m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000051E  13C2 00E00001            886m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000524                           887m     
00000524                           888m     ENDM
00000524                           889m     HEX2BIN D2,D2,A0
00000524  41F9 00001012            890m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000052A  0402 0030                891m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000052E  C4BC 000000FF            892m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000534  1430 2000                893m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000538                           894m   ENDM
00000538  8A82                     895      OR.L D2,D5
0000053A  E98D                     896      LSL.L #4,D5    
0000053C                           897m     DOWNLOAD D2,D3
0000053C                           898m WAIT_FOR_READY_51                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053C                           899m 
0000053C  1639 00D30003            900m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000542  0803 0000                901m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000546  6700 0010                902m     BEQ CONTINUE_51                ; NOTHING, CONTINUE
0000054A                           903m  
0000054A                           904mm     READ_CHAR D2
0000054A                 TRUE      905mm     IFEQ DEBUG
0000054A  1439 00D30007            906mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000550                           907mm     ENDC
00000550                 FALSE     908mm     IFNE DEBUG
00000550                           909mm     ENDC
00000550                           910mm      
00000550  B43C 001B                911mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000554  6700 FAB2                912mm     BEQ START
00000558                           913mm     ENDM
00000558                           914m CONTINUE_51
00000558  1639 00D30013            915m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000055E  0803 0000                916m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000562  67D8                     917m     BEQ WAIT_FOR_READY_51        ; NOTHING, CHECK AGAIN
00000564                           918m     
00000564  1439 00D30017            919m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000056A  13C2 00E00001            920m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000570                           921m     
00000570                           922m     ENDM
00000570                           923m     HEX2BIN D2,D2,A0  
00000570  41F9 00001012            924m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000576  0402 0030                925m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057A  C4BC 000000FF            926m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000580  1430 2000                927m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000584                           928m   ENDM
00000584  8A82                     929      OR.L D2,D5
00000586                           930                  
00000586  DC85                     931      ADD.L D5,D6                     ; add byte count into checksum
00000588                           932  
00000588                           933      IF.B D7 <EQ> #'0' THEN.L        ; header
00000590  7E00                     934          MOVE.L #0,D7                ; read the 16 bit address, just checksum and then ignore
00000592                           935m         DOWNLOAD D2,D3              ; top byte
00000592                           936m WAIT_FOR_READY_54                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000592                           937m 
00000592  1639 00D30003            938m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000598  0803 0000                939m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000059C  6700 0010                940m     BEQ CONTINUE_54                ; NOTHING, CONTINUE
000005A0                           941m  
000005A0                           942mm     READ_CHAR D2
000005A0                 TRUE      943mm     IFEQ DEBUG
000005A0  1439 00D30007            944mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005A6                           945mm     ENDC
000005A6                 FALSE     946mm     IFNE DEBUG
000005A6                           947mm     ENDC
000005A6                           948mm      
000005A6  B43C 001B                949mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005AA  6700 FA5C                950mm     BEQ START
000005AE                           951mm     ENDM
000005AE                           952m CONTINUE_54
000005AE  1639 00D30013            953m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000005B4  0803 0000                954m     BTST #0,D3                  ; CHECK FOR CHARACTER
000005B8  67D8                     955m     BEQ WAIT_FOR_READY_54        ; NOTHING, CHECK AGAIN
000005BA                           956m     
000005BA  1439 00D30017            957m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000005C0  13C2 00E00001            958m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000005C6                           959m     
000005C6                           960m     ENDM
000005C6                           961m         HEX2BIN D2,D2,A0
000005C6  41F9 00001012            962m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000005CC  0402 0030                963m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005D0  C4BC 000000FF            964m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000005D6  1430 2000                965m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000005DA                           966m   ENDM
000005DA  8E82                     967          OR.L D2,D7
000005DC  E98F                     968          LSL.L #4,D7
000005DE                           969m         DOWNLOAD D2,D3         
000005DE                           970m WAIT_FOR_READY_57                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005DE                           971m 
000005DE  1639 00D30003            972m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000005E4  0803 0000                973m     BTST #0,D3                    ; CHECK FOR CHARACTER
000005E8  6700 0010                974m     BEQ CONTINUE_57                ; NOTHING, CONTINUE
000005EC                           975m  
000005EC                           976mm     READ_CHAR D2
000005EC                 TRUE      977mm     IFEQ DEBUG
000005EC  1439 00D30007            978mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000005F2                           979mm     ENDC
000005F2                 FALSE     980mm     IFNE DEBUG
000005F2                           981mm     ENDC
000005F2                           982mm      
000005F2  B43C 001B                983mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000005F6  6700 FA10                984mm     BEQ START
000005FA                           985mm     ENDM
000005FA                           986m CONTINUE_57
000005FA  1639 00D30013            987m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000600  0803 0000                988m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000604  67D8                     989m     BEQ WAIT_FOR_READY_57        ; NOTHING, CHECK AGAIN
00000606                           990m     
00000606  1439 00D30017            991m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000060C  13C2 00E00001            992m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000612                           993m     
00000612                           994m     ENDM
00000612                           995m         HEX2BIN D2,D2,A0
00000612  41F9 00001012            996m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000618  0402 0030                997m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000061C  C4BC 000000FF            998m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000622  1430 2000                999m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000626                          1000m   ENDM
00000626  8E82                    1001          OR.L D2,D7
00000628                          1002          
00000628  DC87                    1003          ADD.L D7,D6                 ; add top byte of address into checksum
0000062A                          1004  
0000062A  E98F                    1005          LSL.L #4,D7                 ; bottom byte
0000062C                          1006m         DOWNLOAD D2,D3
0000062C                          1007m WAIT_FOR_READY_60                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062C                          1008m 
0000062C  1639 00D30003           1009m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000632  0803 0000               1010m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000636  6700 0010               1011m     BEQ CONTINUE_60                ; NOTHING, CONTINUE
0000063A                          1012m  
0000063A                          1013mm     READ_CHAR D2
0000063A                 TRUE     1014mm     IFEQ DEBUG
0000063A  1439 00D30007           1015mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000640                          1016mm     ENDC
00000640                 FALSE    1017mm     IFNE DEBUG
00000640                          1018mm     ENDC
00000640                          1019mm      
00000640  B43C 001B               1020mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000644  6700 F9C2               1021mm     BEQ START
00000648                          1022mm     ENDM
00000648                          1023m CONTINUE_60
00000648  1639 00D30013           1024m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000064E  0803 0000               1025m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000652  67D8                    1026m     BEQ WAIT_FOR_READY_60        ; NOTHING, CHECK AGAIN
00000654                          1027m     
00000654  1439 00D30017           1028m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000065A  13C2 00E00001           1029m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000660                          1030m     
00000660                          1031m     ENDM
00000660                          1032m         HEX2BIN D2,D2,A0
00000660  41F9 00001012           1033m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000666  0402 0030               1034m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000066A  C4BC 000000FF           1035m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000670  1430 2000               1036m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000674                          1037m   ENDM
00000674  8E82                    1038          OR.L D2,D7
00000676  E98F                    1039          LSL.L #4,D7        
00000678                          1040m         DOWNLOAD D2,D3
00000678                          1041m WAIT_FOR_READY_63                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000678                          1042m 
00000678  1639 00D30003           1043m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000067E  0803 0000               1044m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000682  6700 0010               1045m     BEQ CONTINUE_63                ; NOTHING, CONTINUE
00000686                          1046m  
00000686                          1047mm     READ_CHAR D2
00000686                 TRUE     1048mm     IFEQ DEBUG
00000686  1439 00D30007           1049mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
0000068C                          1050mm     ENDC
0000068C                 FALSE    1051mm     IFNE DEBUG
0000068C                          1052mm     ENDC
0000068C                          1053mm      
0000068C  B43C 001B               1054mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000690  6700 F976               1055mm     BEQ START
00000694                          1056mm     ENDM
00000694                          1057m CONTINUE_63
00000694  1639 00D30013           1058m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
0000069A  0803 0000               1059m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000069E  67D8                    1060m     BEQ WAIT_FOR_READY_63        ; NOTHING, CHECK AGAIN
000006A0                          1061m     
000006A0  1439 00D30017           1062m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000006A6  13C2 00E00001           1063m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000006AC                          1064m     
000006AC                          1065m     ENDM
000006AC                          1066m         HEX2BIN D2,D2,A0
000006AC  41F9 00001012           1067m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000006B2  0402 0030               1068m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B6  C4BC 000000FF           1069m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000006BC  1430 2000               1070m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000006C0                          1071m   ENDM
000006C0  8E82                    1072          OR.L D2,D7
000006C2                          1073          
000006C2  7400                    1074          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
000006C4  1407                    1075          MOVE.B D7,D2
000006C6  DC82                    1076          ADD.L D2,D6
000006C8                          1077          
000006C8  5785                    1078          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
000006CA                          1079          WHILE.L D5 <GT> #0 DO       ; read the data bytes
000006D4  5385                    1080            SUB.L #1,D5
000006D6                          1081              
000006D6  7E00                    1082            MOVE.L #0,D7              ; D7 holds the byte
000006D8                          1083              
000006D8                          1084m           DOWNLOAD D2,D3            ; MS 4 bits
000006D8                          1085m WAIT_FOR_READY_66                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D8                          1086m 
000006D8  1639 00D30003           1087m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000006DE  0803 0000               1088m     BTST #0,D3                    ; CHECK FOR CHARACTER
000006E2  6700 0010               1089m     BEQ CONTINUE_66                ; NOTHING, CONTINUE
000006E6                          1090m  
000006E6                          1091mm     READ_CHAR D2
000006E6                 TRUE     1092mm     IFEQ DEBUG
000006E6  1439 00D30007           1093mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000006EC                          1094mm     ENDC
000006EC                 FALSE    1095mm     IFNE DEBUG
000006EC                          1096mm     ENDC
000006EC                          1097mm      
000006EC  B43C 001B               1098mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000006F0  6700 F916               1099mm     BEQ START
000006F4                          1100mm     ENDM
000006F4                          1101m CONTINUE_66
000006F4  1639 00D30013           1102m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000006FA  0803 0000               1103m     BTST #0,D3                  ; CHECK FOR CHARACTER
000006FE  67D8                    1104m     BEQ WAIT_FOR_READY_66        ; NOTHING, CHECK AGAIN
00000700                          1105m     
00000700  1439 00D30017           1106m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000706  13C2 00E00001           1107m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
0000070C                          1108m     
0000070C                          1109m     ENDM
0000070C                          1110m           HEX2BIN D2,D2,A0
0000070C  41F9 00001012           1111m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000712  0402 0030               1112m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000716  C4BC 000000FF           1113m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
0000071C  1430 2000               1114m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000720                          1115m   ENDM
00000720  8E82                    1116            OR.L D2,D7
00000722  E98F                    1117            LSL.L #4,D7
00000724                          1118               
00000724                          1119m           DOWNLOAD D2,D3            ; LS 4 bits    
00000724                          1120m WAIT_FOR_READY_69                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000724                          1121m 
00000724  1639 00D30003           1122m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
0000072A  0803 0000               1123m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000072E  6700 0010               1124m     BEQ CONTINUE_69                ; NOTHING, CONTINUE
00000732                          1125m  
00000732                          1126mm     READ_CHAR D2
00000732                 TRUE     1127mm     IFEQ DEBUG
00000732  1439 00D30007           1128mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000738                          1129mm     ENDC
00000738                 FALSE    1130mm     IFNE DEBUG
00000738                          1131mm     ENDC
00000738                          1132mm      
00000738  B43C 001B               1133mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
0000073C  6700 F8CA               1134mm     BEQ START
00000740                          1135mm     ENDM
00000740                          1136m CONTINUE_69
00000740  1639 00D30013           1137m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000746  0803 0000               1138m     BTST #0,D3                  ; CHECK FOR CHARACTER
0000074A  67D8                    1139m     BEQ WAIT_FOR_READY_69        ; NOTHING, CHECK AGAIN
0000074C                          1140m     
0000074C  1439 00D30017           1141m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000752  13C2 00E00001           1142m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000758                          1143m     
00000758                          1144m     ENDM
00000758                          1145m           HEX2BIN D2,D2,A0
00000758  41F9 00001012           1146m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000075E  0402 0030               1147m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000762  C4BC 000000FF           1148m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000768  1430 2000               1149m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000076C                          1150m   ENDM
0000076C  8E82                    1151            OR.L D2,D7
0000076E                          1152              
0000076E  DC87                    1153            ADD.L D7,D6               ; add into checksum
00000770                          1154            
00000770                          1155m           PRINT_CHAR D7,D3          ; assume ASCII and print it
00000770                          1156m WAIT_FOR_READY_72                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000770                 TRUE     1157m     IFEQ DEBUG
00000770  1639 00D30003           1158m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000776  0803 0002               1159m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000077A  67F4                    1160m       BEQ WAIT_FOR_READY_72          ; NO SPACE, CHECK AGAIN
0000077C  13C7 00D30007           1161m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000782                          1162m     ENDC
00000782                          1163m     
00000782                 FALSE    1164m     IFNE DEBUG
00000782                          1165m     ENDC
00000782                          1166m 
00000782                          1167m     ENDM
00000782                          1168          ENDW
00000786                          1169m         PRINT_CRLF D3
00000786                          1170mm     PRINT_CHAR #13,D3             ; CR
00000786                          1171mm WAIT_FOR_READY_74                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000786                 TRUE     1172mm     IFEQ DEBUG
00000786  1639 00D30003           1173mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000078C  0803 0002               1174mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000790  67F4                    1175mm       BEQ WAIT_FOR_READY_74          ; NO SPACE, CHECK AGAIN
00000792  13FC 000D 00D30007      1176mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
0000079A                          1177mm     ENDC
0000079A                          1178mm     
0000079A                 FALSE    1179mm     IFNE DEBUG
0000079A                          1180mm     ENDC
0000079A                          1181mm 
0000079A                          1182mm     ENDM
0000079A                          1183mm     PRINT_CHAR #10,D3             ; LF
0000079A                          1184mm WAIT_FOR_READY_75                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000079A                 TRUE     1185mm     IFEQ DEBUG
0000079A  1639 00D30003           1186mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007A0  0803 0002               1187mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007A4  67F4                    1188mm       BEQ WAIT_FOR_READY_75          ; NO SPACE, CHECK AGAIN
000007A6  13FC 000A 00D30007      1189mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
000007AE                          1190mm     ENDC
000007AE                          1191mm     
000007AE                 FALSE    1192mm     IFNE DEBUG
000007AE                          1193mm     ENDC
000007AE                          1194mm 
000007AE                          1195mm     ENDM
000007AE                          1196m     ENDM
000007AE  43F8 047C               1197         LEA WAIT_FOR_SRECORD,A1            
000007B2                          1198      ELSE
000007B6                          1199        IF.B D7 <EQ> #'1' THEN.L        ; 16 bit data record
000007BE  7E00                    1200          MOVE.L #0,D7                ; read the 16 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
000007C0                          1201m         DOWNLOAD D2,D3              ; top byte
000007C0                          1202m WAIT_FOR_READY_76                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                          1203m 
000007C0  1639 00D30003           1204m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000007C6  0803 0000               1205m     BTST #0,D3                    ; CHECK FOR CHARACTER
000007CA  6700 0010               1206m     BEQ CONTINUE_76                ; NOTHING, CONTINUE
000007CE                          1207m  
000007CE                          1208mm     READ_CHAR D2
000007CE                 TRUE     1209mm     IFEQ DEBUG
000007CE  1439 00D30007           1210mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000007D4                          1211mm     ENDC
000007D4                 FALSE    1212mm     IFNE DEBUG
000007D4                          1213mm     ENDC
000007D4                          1214mm      
000007D4  B43C 001B               1215mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000007D8  6700 F82E               1216mm     BEQ START
000007DC                          1217mm     ENDM
000007DC                          1218m CONTINUE_76
000007DC  1639 00D30013           1219m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000007E2  0803 0000               1220m     BTST #0,D3                  ; CHECK FOR CHARACTER
000007E6  67D8                    1221m     BEQ WAIT_FOR_READY_76        ; NOTHING, CHECK AGAIN
000007E8                          1222m     
000007E8  1439 00D30017           1223m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000007EE  13C2 00E00001           1224m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000007F4                          1225m     
000007F4                          1226m     ENDM
000007F4                          1227m         PRINT_CHAR D2,D3
000007F4                          1228m WAIT_FOR_READY_78                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F4                 TRUE     1229m     IFEQ DEBUG
000007F4  1639 00D30003           1230m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000007FA  0803 0002               1231m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000007FE  67F4                    1232m       BEQ WAIT_FOR_READY_78          ; NO SPACE, CHECK AGAIN
00000800  13C2 00D30007           1233m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000806                          1234m     ENDC
00000806                          1235m     
00000806                 FALSE    1236m     IFNE DEBUG
00000806                          1237m     ENDC
00000806                          1238m 
00000806                          1239m     ENDM
00000806                          1240m         HEX2BIN D2,D2,A0
00000806  41F9 00001012           1241m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000080C  0402 0030               1242m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000810  C4BC 000000FF           1243m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000816  1430 2000               1244m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
0000081A                          1245m   ENDM
0000081A  8E82                    1246          OR.L D2,D7
0000081C  E98F                    1247          LSL.L #4,D7
0000081E                          1248m         DOWNLOAD D2,D3         
0000081E                          1249m WAIT_FOR_READY_80                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000081E                          1250m 
0000081E  1639 00D30003           1251m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000824  0803 0000               1252m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000828  6700 0010               1253m     BEQ CONTINUE_80                ; NOTHING, CONTINUE
0000082C                          1254m  
0000082C                          1255mm     READ_CHAR D2
0000082C                 TRUE     1256mm     IFEQ DEBUG
0000082C  1439 00D30007           1257mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000832                          1258mm     ENDC
00000832                 FALSE    1259mm     IFNE DEBUG
00000832                          1260mm     ENDC
00000832                          1261mm      
00000832  B43C 001B               1262mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000836  6700 F7D0               1263mm     BEQ START
0000083A                          1264mm     ENDM
0000083A                          1265m CONTINUE_80
0000083A  1639 00D30013           1266m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000840  0803 0000               1267m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000844  67D8                    1268m     BEQ WAIT_FOR_READY_80        ; NOTHING, CHECK AGAIN
00000846                          1269m     
00000846  1439 00D30017           1270m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000084C  13C2 00E00001           1271m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000852                          1272m     
00000852                          1273m     ENDM
00000852                          1274m         PRINT_CHAR D2,D3
00000852                          1275m WAIT_FOR_READY_82                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000852                 TRUE     1276m     IFEQ DEBUG
00000852  1639 00D30003           1277m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000858  0803 0002               1278m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000085C  67F4                    1279m       BEQ WAIT_FOR_READY_82          ; NO SPACE, CHECK AGAIN
0000085E  13C2 00D30007           1280m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000864                          1281m     ENDC
00000864                          1282m     
00000864                 FALSE    1283m     IFNE DEBUG
00000864                          1284m     ENDC
00000864                          1285m 
00000864                          1286m     ENDM
00000864                          1287m         HEX2BIN D2,D2,A0
00000864  41F9 00001012           1288m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000086A  0402 0030               1289m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000086E  C4BC 000000FF           1290m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000874  1430 2000               1291m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000878                          1292m   ENDM
00000878  8E82                    1293          OR.L D2,D7
0000087A                          1294          
0000087A  DC87                    1295          ADD.L D7,D6                 ; add top byte of address into checksum
0000087C                          1296  
0000087C  E98F                    1297          LSL.L #4,D7                 ; bottom byte
0000087E                          1298m         DOWNLOAD D2,D3
0000087E                          1299m WAIT_FOR_READY_84                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087E                          1300m 
0000087E  1639 00D30003           1301m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000884  0803 0000               1302m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000888  6700 0010               1303m     BEQ CONTINUE_84                ; NOTHING, CONTINUE
0000088C                          1304m  
0000088C                          1305mm     READ_CHAR D2
0000088C                 TRUE     1306mm     IFEQ DEBUG
0000088C  1439 00D30007           1307mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000892                          1308mm     ENDC
00000892                 FALSE    1309mm     IFNE DEBUG
00000892                          1310mm     ENDC
00000892                          1311mm      
00000892  B43C 001B               1312mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000896  6700 F770               1313mm     BEQ START
0000089A                          1314mm     ENDM
0000089A                          1315m CONTINUE_84
0000089A  1639 00D30013           1316m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008A0  0803 0000               1317m     BTST #0,D3                  ; CHECK FOR CHARACTER
000008A4  67D8                    1318m     BEQ WAIT_FOR_READY_84        ; NOTHING, CHECK AGAIN
000008A6                          1319m     
000008A6  1439 00D30017           1320m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000008AC  13C2 00E00001           1321m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000008B2                          1322m     
000008B2                          1323m     ENDM
000008B2                          1324m         PRINT_CHAR D2,D3
000008B2                          1325m WAIT_FOR_READY_86                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B2                 TRUE     1326m     IFEQ DEBUG
000008B2  1639 00D30003           1327m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000008B8  0803 0002               1328m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000008BC  67F4                    1329m       BEQ WAIT_FOR_READY_86          ; NO SPACE, CHECK AGAIN
000008BE  13C2 00D30007           1330m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000008C4                          1331m     ENDC
000008C4                          1332m     
000008C4                 FALSE    1333m     IFNE DEBUG
000008C4                          1334m     ENDC
000008C4                          1335m 
000008C4                          1336m     ENDM
000008C4                          1337m         HEX2BIN D2,D2,A0
000008C4  41F9 00001012           1338m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000008CA  0402 0030               1339m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008CE  C4BC 000000FF           1340m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000008D4  1430 2000               1341m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000008D8                          1342m   ENDM
000008D8  8E82                    1343          OR.L D2,D7
000008DA  E98F                    1344          LSL.L #4,D7        
000008DC                          1345m         DOWNLOAD D2,D3
000008DC                          1346m WAIT_FOR_READY_88                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DC                          1347m 
000008DC  1639 00D30003           1348m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000008E2  0803 0000               1349m     BTST #0,D3                    ; CHECK FOR CHARACTER
000008E6  6700 0010               1350m     BEQ CONTINUE_88                ; NOTHING, CONTINUE
000008EA                          1351m  
000008EA                          1352mm     READ_CHAR D2
000008EA                 TRUE     1353mm     IFEQ DEBUG
000008EA  1439 00D30007           1354mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000008F0                          1355mm     ENDC
000008F0                 FALSE    1356mm     IFNE DEBUG
000008F0                          1357mm     ENDC
000008F0                          1358mm      
000008F0  B43C 001B               1359mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000008F4  6700 F712               1360mm     BEQ START
000008F8                          1361mm     ENDM
000008F8                          1362m CONTINUE_88
000008F8  1639 00D30013           1363m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000008FE  0803 0000               1364m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000902  67D8                    1365m     BEQ WAIT_FOR_READY_88        ; NOTHING, CHECK AGAIN
00000904                          1366m     
00000904  1439 00D30017           1367m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000090A  13C2 00E00001           1368m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000910                          1369m     
00000910                          1370m     ENDM
00000910                          1371m         PRINT_CHAR D2,D3
00000910                          1372m WAIT_FOR_READY_90                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000910                 TRUE     1373m     IFEQ DEBUG
00000910  1639 00D30003           1374m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000916  0803 0002               1375m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000091A  67F4                    1376m       BEQ WAIT_FOR_READY_90          ; NO SPACE, CHECK AGAIN
0000091C  13C2 00D30007           1377m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000922                          1378m     ENDC
00000922                          1379m     
00000922                 FALSE    1380m     IFNE DEBUG
00000922                          1381m     ENDC
00000922                          1382m 
00000922                          1383m     ENDM
00000922                          1384m         HEX2BIN D2,D2,A0
00000922  41F9 00001012           1385m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000928  0402 0030               1386m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000092C  C4BC 000000FF           1387m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000932  1430 2000               1388m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000936                          1389m   ENDM
00000936  8E82                    1390          OR.L D2,D7
00000938                          1391          
00000938  7400                    1392          MOVE.L #0,D2                 ; rextract bottom byte of address and add into checksum
0000093A  1407                    1393          MOVE.B D7,D2
0000093C  DC82                    1394          ADD.L D2,D6
0000093E                          1395          
0000093E  2247                    1396          MOVE.L D7,A1                ; put the address in an address register, and we can now re-use D7
00000940                          1397                 
00000940  5785                    1398          SUB.L #3,D5                 ; subtract three bytes for 16 bit address and 1 byte checksum
00000942                          1399          WHILE.L D5 <GT> #0 DO       ; read the data bytes
0000094C  5385                    1400            SUB.L #1,D5
0000094E                          1401              
0000094E  7E00                    1402            MOVE.L #0,D7              ; D7 holds the byte
00000950                          1403              
00000950                          1404m           DOWNLOAD D2,D3            ; MS 4 bits
00000950                          1405m WAIT_FOR_READY_92                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000950                          1406m 
00000950  1639 00D30003           1407m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000956  0803 0000               1408m     BTST #0,D3                    ; CHECK FOR CHARACTER
0000095A  6700 0010               1409m     BEQ CONTINUE_92                ; NOTHING, CONTINUE
0000095E                          1410m  
0000095E                          1411mm     READ_CHAR D2
0000095E                 TRUE     1412mm     IFEQ DEBUG
0000095E  1439 00D30007           1413mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000964                          1414mm     ENDC
00000964                 FALSE    1415mm     IFNE DEBUG
00000964                          1416mm     ENDC
00000964                          1417mm      
00000964  B43C 001B               1418mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000968  6700 F69E               1419mm     BEQ START
0000096C                          1420mm     ENDM
0000096C                          1421m CONTINUE_92
0000096C  1639 00D30013           1422m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000972  0803 0000               1423m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000976  67D8                    1424m     BEQ WAIT_FOR_READY_92        ; NOTHING, CHECK AGAIN
00000978                          1425m     
00000978  1439 00D30017           1426m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
0000097E  13C2 00E00001           1427m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000984                          1428m     
00000984                          1429m     ENDM
00000984                          1430m           PRINT_CHAR D2,D3
00000984                          1431m WAIT_FOR_READY_94                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000984                 TRUE     1432m     IFEQ DEBUG
00000984  1639 00D30003           1433m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
0000098A  0803 0002               1434m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
0000098E  67F4                    1435m       BEQ WAIT_FOR_READY_94          ; NO SPACE, CHECK AGAIN
00000990  13C2 00D30007           1436m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000996                          1437m     ENDC
00000996                          1438m     
00000996                 FALSE    1439m     IFNE DEBUG
00000996                          1440m     ENDC
00000996                          1441m 
00000996                          1442m     ENDM
00000996                          1443m           HEX2BIN D2,D2,A0
00000996  41F9 00001012           1444m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
0000099C  0402 0030               1445m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009A0  C4BC 000000FF           1446m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
000009A6  1430 2000               1447m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
000009AA                          1448m   ENDM
000009AA  8E82                    1449            OR.L D2,D7
000009AC  E98F                    1450            LSL.L #4,D7
000009AE                          1451               
000009AE                          1452m           DOWNLOAD D2,D3            ; LS 4 bits    
000009AE                          1453m WAIT_FOR_READY_96                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009AE                          1454m 
000009AE  1639 00D30003           1455m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
000009B4  0803 0000               1456m     BTST #0,D3                    ; CHECK FOR CHARACTER
000009B8  6700 0010               1457m     BEQ CONTINUE_96                ; NOTHING, CONTINUE
000009BC                          1458m  
000009BC                          1459mm     READ_CHAR D2
000009BC                 TRUE     1460mm     IFEQ DEBUG
000009BC  1439 00D30007           1461mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
000009C2                          1462mm     ENDC
000009C2                 FALSE    1463mm     IFNE DEBUG
000009C2                          1464mm     ENDC
000009C2                          1465mm      
000009C2  B43C 001B               1466mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
000009C6  6700 F640               1467mm     BEQ START
000009CA                          1468mm     ENDM
000009CA                          1469m CONTINUE_96
000009CA  1639 00D30013           1470m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
000009D0  0803 0000               1471m     BTST #0,D3                  ; CHECK FOR CHARACTER
000009D4  67D8                    1472m     BEQ WAIT_FOR_READY_96        ; NOTHING, CHECK AGAIN
000009D6                          1473m     
000009D6  1439 00D30017           1474m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
000009DC  13C2 00E00001           1475m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
000009E2                          1476m     
000009E2                          1477m     ENDM
000009E2                          1478m           PRINT_CHAR D2,D3
000009E2                          1479m WAIT_FOR_READY_98                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E2                 TRUE     1480m     IFEQ DEBUG
000009E2  1639 00D30003           1481m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
000009E8  0803 0002               1482m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
000009EC  67F4                    1483m       BEQ WAIT_FOR_READY_98          ; NO SPACE, CHECK AGAIN
000009EE  13C2 00D30007           1484m       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
000009F4                          1485m     ENDC
000009F4                          1486m     
000009F4                 FALSE    1487m     IFNE DEBUG
000009F4                          1488m     ENDC
000009F4                          1489m 
000009F4                          1490m     ENDM
000009F4                          1491m           HEX2BIN D2,D2,A0
000009F4  41F9 00001012           1492m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
000009FA  0402 0030               1493m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009FE  C4BC 000000FF           1494m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A04  1430 2000               1495m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A08                          1496m   ENDM
00000A08  8E82                    1497            OR.L D2,D7
00000A0A                          1498              
00000A0A  DC87                    1499            ADD.L D7,D6               ; add into checksum            
00000A0C                          1500          ENDW
00000A10                          1501m         PRINT_CRLF D3
00000A10                          1502mm     PRINT_CHAR #13,D3             ; CR
00000A10                          1503mm WAIT_FOR_READY_101                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A10                 TRUE     1504mm     IFEQ DEBUG
00000A10  1639 00D30003           1505mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A16  0803 0002               1506mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A1A  67F4                    1507mm       BEQ WAIT_FOR_READY_101          ; NO SPACE, CHECK AGAIN
00000A1C  13FC 000D 00D30007      1508mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A24                          1509mm     ENDC
00000A24                          1510mm     
00000A24                 FALSE    1511mm     IFNE DEBUG
00000A24                          1512mm     ENDC
00000A24                          1513mm 
00000A24                          1514mm     ENDM
00000A24                          1515mm     PRINT_CHAR #10,D3             ; LF
00000A24                          1516mm WAIT_FOR_READY_102                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A24                 TRUE     1517mm     IFEQ DEBUG
00000A24  1639 00D30003           1518mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000A2A  0803 0002               1519mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000A2E  67F4                    1520mm       BEQ WAIT_FOR_READY_102          ; NO SPACE, CHECK AGAIN
00000A30  13FC 000A 00D30007      1521mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000A38                          1522mm     ENDC
00000A38                          1523mm     
00000A38                 FALSE    1524mm     IFNE DEBUG
00000A38                          1525mm     ENDC
00000A38                          1526mm 
00000A38                          1527mm     ENDM
00000A38                          1528m     ENDM
00000A38  43F8 047C               1529          LEA WAIT_FOR_SRECORD,A1     ; next place to go
00000A3C                          1530        ELSE
00000A40                          1531          IF.B D7 <EQ> #'8' THEN.L    ; termination record, exit
00000A48  7E00                    1532            MOVE.L #0,D7              ; read the 24 bit address, we'll stomp on D7 for this since it's sort of like the address accumulator
00000A4A                          1533m           DOWNLOAD D2,D3            ; top byte
00000A4A                          1534m WAIT_FOR_READY_103                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4A                          1535m 
00000A4A  1639 00D30003           1536m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A50  0803 0000               1537m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000A54  6700 0010               1538m     BEQ CONTINUE_103                ; NOTHING, CONTINUE
00000A58                          1539m  
00000A58                          1540mm     READ_CHAR D2
00000A58                 TRUE     1541mm     IFEQ DEBUG
00000A58  1439 00D30007           1542mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000A5E                          1543mm     ENDC
00000A5E                 FALSE    1544mm     IFNE DEBUG
00000A5E                          1545mm     ENDC
00000A5E                          1546mm      
00000A5E  B43C 001B               1547mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000A62  6700 F5A4               1548mm     BEQ START
00000A66                          1549mm     ENDM
00000A66                          1550m CONTINUE_103
00000A66  1639 00D30013           1551m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000A6C  0803 0000               1552m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000A70  67D8                    1553m     BEQ WAIT_FOR_READY_103        ; NOTHING, CHECK AGAIN
00000A72                          1554m     
00000A72  1439 00D30017           1555m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000A78  13C2 00E00001           1556m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000A7E                          1557m     
00000A7E                          1558m     ENDM
00000A7E                          1559m           HEX2BIN D2,D2,A0
00000A7E  41F9 00001012           1560m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000A84  0402 0030               1561m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A88  C4BC 000000FF           1562m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000A8E  1430 2000               1563m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000A92                          1564m   ENDM
00000A92  8E82                    1565            OR.L D2,D7
00000A94  E98F                    1566            LSL.L #4,D7
00000A96                          1567m           DOWNLOAD D2,D3         
00000A96                          1568m WAIT_FOR_READY_106                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A96                          1569m 
00000A96  1639 00D30003           1570m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000A9C  0803 0000               1571m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AA0  6700 0010               1572m     BEQ CONTINUE_106                ; NOTHING, CONTINUE
00000AA4                          1573m  
00000AA4                          1574mm     READ_CHAR D2
00000AA4                 TRUE     1575mm     IFEQ DEBUG
00000AA4  1439 00D30007           1576mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AAA                          1577mm     ENDC
00000AAA                 FALSE    1578mm     IFNE DEBUG
00000AAA                          1579mm     ENDC
00000AAA                          1580mm      
00000AAA  B43C 001B               1581mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AAE  6700 F558               1582mm     BEQ START
00000AB2                          1583mm     ENDM
00000AB2                          1584m CONTINUE_106
00000AB2  1639 00D30013           1585m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000AB8  0803 0000               1586m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000ABC  67D8                    1587m     BEQ WAIT_FOR_READY_106        ; NOTHING, CHECK AGAIN
00000ABE                          1588m     
00000ABE  1439 00D30017           1589m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000AC4  13C2 00E00001           1590m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000ACA                          1591m     
00000ACA                          1592m     ENDM
00000ACA                          1593m           HEX2BIN D2,D2,A0
00000ACA  41F9 00001012           1594m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000AD0  0402 0030               1595m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AD4  C4BC 000000FF           1596m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000ADA  1430 2000               1597m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000ADE                          1598m   ENDM
00000ADE  8E82                    1599            OR.L D2,D7
00000AE0                          1600          
00000AE0  DC87                    1601            ADD.L D7,D6               ; add top byte of address into checksum
00000AE2                          1602  
00000AE2  E98F                    1603            LSL.L #4,D7               ; middle byte
00000AE4                          1604m           DOWNLOAD D2,D3
00000AE4                          1605m WAIT_FOR_READY_109                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE4                          1606m 
00000AE4  1639 00D30003           1607m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000AEA  0803 0000               1608m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000AEE  6700 0010               1609m     BEQ CONTINUE_109                ; NOTHING, CONTINUE
00000AF2                          1610m  
00000AF2                          1611mm     READ_CHAR D2
00000AF2                 TRUE     1612mm     IFEQ DEBUG
00000AF2  1439 00D30007           1613mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000AF8                          1614mm     ENDC
00000AF8                 FALSE    1615mm     IFNE DEBUG
00000AF8                          1616mm     ENDC
00000AF8                          1617mm      
00000AF8  B43C 001B               1618mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000AFC  6700 F50A               1619mm     BEQ START
00000B00                          1620mm     ENDM
00000B00                          1621m CONTINUE_109
00000B00  1639 00D30013           1622m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B06  0803 0000               1623m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B0A  67D8                    1624m     BEQ WAIT_FOR_READY_109        ; NOTHING, CHECK AGAIN
00000B0C                          1625m     
00000B0C  1439 00D30017           1626m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B12  13C2 00E00001           1627m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B18                          1628m     
00000B18                          1629m     ENDM
00000B18                          1630m           HEX2BIN D2,D2,A0
00000B18  41F9 00001012           1631m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B1E  0402 0030               1632m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B22  C4BC 000000FF           1633m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B28  1430 2000               1634m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B2C                          1635m   ENDM
00000B2C  8E82                    1636            OR.L D2,D7
00000B2E  E98F                    1637            LSL.L #4,D7        
00000B30                          1638m           DOWNLOAD D2,D3
00000B30                          1639m WAIT_FOR_READY_112                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B30                          1640m 
00000B30  1639 00D30003           1641m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B36  0803 0000               1642m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B3A  6700 0010               1643m     BEQ CONTINUE_112                ; NOTHING, CONTINUE
00000B3E                          1644m  
00000B3E                          1645mm     READ_CHAR D2
00000B3E                 TRUE     1646mm     IFEQ DEBUG
00000B3E  1439 00D30007           1647mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B44                          1648mm     ENDC
00000B44                 FALSE    1649mm     IFNE DEBUG
00000B44                          1650mm     ENDC
00000B44                          1651mm      
00000B44  B43C 001B               1652mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B48  6700 F4BE               1653mm     BEQ START
00000B4C                          1654mm     ENDM
00000B4C                          1655m CONTINUE_112
00000B4C  1639 00D30013           1656m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000B52  0803 0000               1657m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000B56  67D8                    1658m     BEQ WAIT_FOR_READY_112        ; NOTHING, CHECK AGAIN
00000B58                          1659m     
00000B58  1439 00D30017           1660m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000B5E  13C2 00E00001           1661m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000B64                          1662m     
00000B64                          1663m     ENDM
00000B64                          1664m           HEX2BIN D2,D2,A0
00000B64  41F9 00001012           1665m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000B6A  0402 0030               1666m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B6E  C4BC 000000FF           1667m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000B74  1430 2000               1668m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000B78                          1669m   ENDM
00000B78  8E82                    1670            OR.L D2,D7
00000B7A                          1671          
00000B7A  7400                    1672            MOVE.L #0,D2              ; rextract middle byte of address and add into checksum
00000B7C  1407                    1673            MOVE.B D7,D2
00000B7E  DC82                    1674            ADD.L D2,D6
00000B80                          1675            
00000B80  E98F                    1676            LSL.L #4,D7               ; bottom byte
00000B82                          1677m           DOWNLOAD D2,D3
00000B82                          1678m WAIT_FOR_READY_115                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B82                          1679m 
00000B82  1639 00D30003           1680m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000B88  0803 0000               1681m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000B8C  6700 0010               1682m     BEQ CONTINUE_115                ; NOTHING, CONTINUE
00000B90                          1683m  
00000B90                          1684mm     READ_CHAR D2
00000B90                 TRUE     1685mm     IFEQ DEBUG
00000B90  1439 00D30007           1686mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000B96                          1687mm     ENDC
00000B96                 FALSE    1688mm     IFNE DEBUG
00000B96                          1689mm     ENDC
00000B96                          1690mm      
00000B96  B43C 001B               1691mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000B9A  6700 F46C               1692mm     BEQ START
00000B9E                          1693mm     ENDM
00000B9E                          1694m CONTINUE_115
00000B9E  1639 00D30013           1695m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BA4  0803 0000               1696m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BA8  67D8                    1697m     BEQ WAIT_FOR_READY_115        ; NOTHING, CHECK AGAIN
00000BAA                          1698m     
00000BAA  1439 00D30017           1699m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BB0  13C2 00E00001           1700m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000BB6                          1701m     
00000BB6                          1702m     ENDM
00000BB6                          1703m           HEX2BIN D2,D2,A0
00000BB6  41F9 00001012           1704m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000BBC  0402 0030               1705m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BC0  C4BC 000000FF           1706m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000BC6  1430 2000               1707m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000BCA                          1708m   ENDM
00000BCA  8E82                    1709            OR.L D2,D7
00000BCC  E98F                    1710            LSL.L #4,D7        
00000BCE                          1711m           DOWNLOAD D2,D3
00000BCE                          1712m WAIT_FOR_READY_118                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCE                          1713m 
00000BCE  1639 00D30003           1714m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000BD4  0803 0000               1715m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000BD8  6700 0010               1716m     BEQ CONTINUE_118                ; NOTHING, CONTINUE
00000BDC                          1717m  
00000BDC                          1718mm     READ_CHAR D2
00000BDC                 TRUE     1719mm     IFEQ DEBUG
00000BDC  1439 00D30007           1720mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000BE2                          1721mm     ENDC
00000BE2                 FALSE    1722mm     IFNE DEBUG
00000BE2                          1723mm     ENDC
00000BE2                          1724mm      
00000BE2  B43C 001B               1725mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000BE6  6700 F420               1726mm     BEQ START
00000BEA                          1727mm     ENDM
00000BEA                          1728m CONTINUE_118
00000BEA  1639 00D30013           1729m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000BF0  0803 0000               1730m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000BF4  67D8                    1731m     BEQ WAIT_FOR_READY_118        ; NOTHING, CHECK AGAIN
00000BF6                          1732m     
00000BF6  1439 00D30017           1733m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000BFC  13C2 00E00001           1734m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000C02                          1735m     
00000C02                          1736m     ENDM
00000C02                          1737m           HEX2BIN D2,D2,A0
00000C02  41F9 00001012           1738m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000C08  0402 0030               1739m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C0C  C4BC 000000FF           1740m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000C12  1430 2000               1741m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000C16                          1742m   ENDM
00000C16  8E82                    1743            OR.L D2,D7
00000C18                          1744          
00000C18  7400                    1745            MOVE.L #0,D2              ; rextract bottom byte of address and add into checksum
00000C1A  1407                    1746            MOVE.B D7,D2
00000C1C  DC82                    1747            ADD.L D2,D6
00000C1E                          1748            
00000C1E  2447                    1749            MOVE.L D7,A2              ; start address -> A2
00000C20                          1750          
00000C20  43F9 00000DD4           1751            LEA DOWNLOAD_DONE,A1      ; next place to go
00000C26                          1752          ELSE
00000C2A  41F9 00000FB6           1753            LEA UNREC,A0              ; warn for unrecognised type
00000C30                          1754m           PRINT_STR A0,D3
00000C30                          1755m LOOP_121
00000C30  0C10 0000               1756m     CMP.B #0,(A0)                 ; 0 -> DONE
00000C34  6700 0018               1757m     BEQ EXIT_121
00000C38                          1758mm     PRINT_CHAR (A0)+,D3
00000C38                          1759mm WAIT_FOR_READY_122                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C38                 TRUE     1760mm     IFEQ DEBUG
00000C38  1639 00D30003           1761mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C3E  0803 0002               1762mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C42  67F4                    1763mm       BEQ WAIT_FOR_READY_122          ; NO SPACE, CHECK AGAIN
00000C44  13D8 00D30007           1764mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C4A                          1765mm     ENDC
00000C4A                          1766mm     
00000C4A                 FALSE    1767mm     IFNE DEBUG
00000C4A                          1768mm     ENDC
00000C4A                          1769mm 
00000C4A                          1770mm     ENDM
00000C4A  4EF8 0C30               1771m     JMP LOOP_121
00000C4E                          1772m EXIT_121
00000C4E                          1773m     ENDM
00000C4E                          1774m           PRINT_CHAR D7,D3
00000C4E                          1775m WAIT_FOR_READY_123                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4E                 TRUE     1776m     IFEQ DEBUG
00000C4E  1639 00D30003           1777m       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C54  0803 0002               1778m       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C58  67F4                    1779m       BEQ WAIT_FOR_READY_123          ; NO SPACE, CHECK AGAIN
00000C5A  13C7 00D30007           1780m       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C60                          1781m     ENDC
00000C60                          1782m     
00000C60                 FALSE    1783m     IFNE DEBUG
00000C60                          1784m     ENDC
00000C60                          1785m 
00000C60                          1786m     ENDM
00000C60                          1787m           PRINT_CRLF D3
00000C60                          1788mm     PRINT_CHAR #13,D3             ; CR
00000C60                          1789mm WAIT_FOR_READY_125                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C60                 TRUE     1790mm     IFEQ DEBUG
00000C60  1639 00D30003           1791mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C66  0803 0002               1792mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C6A  67F4                    1793mm       BEQ WAIT_FOR_READY_125          ; NO SPACE, CHECK AGAIN
00000C6C  13FC 000D 00D30007      1794mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C74                          1795mm     ENDC
00000C74                          1796mm     
00000C74                 FALSE    1797mm     IFNE DEBUG
00000C74                          1798mm     ENDC
00000C74                          1799mm 
00000C74                          1800mm     ENDM
00000C74                          1801mm     PRINT_CHAR #10,D3             ; LF
00000C74                          1802mm WAIT_FOR_READY_126                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C74                 TRUE     1803mm     IFEQ DEBUG
00000C74  1639 00D30003           1804mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000C7A  0803 0002               1805mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000C7E  67F4                    1806mm       BEQ WAIT_FOR_READY_126          ; NO SPACE, CHECK AGAIN
00000C80  13FC 000A 00D30007      1807mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000C88                          1808mm     ENDC
00000C88                          1809mm     
00000C88                 FALSE    1810mm     IFNE DEBUG
00000C88                          1811mm     ENDC
00000C88                          1812mm 
00000C88                          1813mm     ENDM
00000C88                          1814m     ENDM
00000C88                          1815      
00000C88  4EF8 047C               1816            JMP WAIT_FOR_SRECORD      ; ignore any other type    
00000C8C                          1817          ENDI
00000C8C                          1818        ENDI
00000C8C                          1819      ENDI
00000C8C                          1820      
00000C8C  4686                    1821      NOT.L D6                        ; ones complement the checksum
00000C8E  0286 000000FF           1822      ANDI.L #$FF,D6                  ; and take the LSByte
00000C94                          1823          
00000C94  7E00                    1824      MOVE.L #0,D7                    ; read the checksum from the data stream
00000C96                          1825m     DOWNLOAD D2,D3                  ; top byte
00000C96                          1826m WAIT_FOR_READY_127                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C96                          1827m 
00000C96  1639 00D30003           1828m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000C9C  0803 0000               1829m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CA0  6700 0010               1830m     BEQ CONTINUE_127                ; NOTHING, CONTINUE
00000CA4                          1831m  
00000CA4                          1832mm     READ_CHAR D2
00000CA4                 TRUE     1833mm     IFEQ DEBUG
00000CA4  1439 00D30007           1834mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CAA                          1835mm     ENDC
00000CAA                 FALSE    1836mm     IFNE DEBUG
00000CAA                          1837mm     ENDC
00000CAA                          1838mm      
00000CAA  B43C 001B               1839mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CAE  6700 F358               1840mm     BEQ START
00000CB2                          1841mm     ENDM
00000CB2                          1842m CONTINUE_127
00000CB2  1639 00D30013           1843m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000CB8  0803 0000               1844m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000CBC  67D8                    1845m     BEQ WAIT_FOR_READY_127        ; NOTHING, CHECK AGAIN
00000CBE                          1846m     
00000CBE  1439 00D30017           1847m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000CC4  13C2 00E00001           1848m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000CCA                          1849m     
00000CCA                          1850m     ENDM
00000CCA                          1851m     HEX2BIN D2,D2,A0
00000CCA  41F9 00001012           1852m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000CD0  0402 0030               1853m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CD4  C4BC 000000FF           1854m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000CDA  1430 2000               1855m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000CDE                          1856m   ENDM
00000CDE  8E82                    1857      OR.L D2,D7
00000CE0  E98F                    1858      LSL.L #4,D7
00000CE2                          1859m     DOWNLOAD D2,D3                  ; bottom byte
00000CE2                          1860m WAIT_FOR_READY_130                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE2                          1861m 
00000CE2  1639 00D30003           1862m     MOVE.B DUART_SRA,D3           ; CHECK FOR COMMAND
00000CE8  0803 0000               1863m     BTST #0,D3                    ; CHECK FOR CHARACTER
00000CEC  6700 0010               1864m     BEQ CONTINUE_130                ; NOTHING, CONTINUE
00000CF0                          1865m  
00000CF0                          1866mm     READ_CHAR D2
00000CF0                 TRUE     1867mm     IFEQ DEBUG
00000CF0  1439 00D30007           1868mm       MOVE.B DUART_RXA,D2         ; GOT A CHARACTER, READ IT
00000CF6                          1869mm     ENDC
00000CF6                 FALSE    1870mm     IFNE DEBUG
00000CF6                          1871mm     ENDC
00000CF6                          1872mm      
00000CF6  B43C 001B               1873mm     CMP.B #$1B,D2                 ; CHECK FOR ESCAPE AND GO TO START
00000CFA  6700 F30C               1874mm     BEQ START
00000CFE                          1875mm     ENDM
00000CFE                          1876m CONTINUE_130
00000CFE  1639 00D30013           1877m     MOVE.B DUART_SRB,D3         ; READ STATUS REGISTER
00000D04  0803 0000               1878m     BTST #0,D3                  ; CHECK FOR CHARACTER
00000D08  67D8                    1879m     BEQ WAIT_FOR_READY_130        ; NOTHING, CHECK AGAIN
00000D0A                          1880m     
00000D0A  1439 00D30017           1881m     MOVE.B DUART_RXB,D2         ; GOT A CHARACTER, READ IT
00000D10  13C2 00E00001           1882m     MOVE.B D2,DISPLAY           ; ECHO TO THE DISPLAY
00000D16                          1883m     
00000D16                          1884m     ENDM
00000D16                          1885m     HEX2BIN D2,D2,A0
00000D16  41F9 00001012           1886m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000D1C  0402 0030               1887m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D20  C4BC 000000FF           1888m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000D26  1430 2000               1889m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000D2A                          1890m   ENDM
00000D2A  8E82                    1891      OR.L D2,D7
00000D2C                          1892                  
00000D2C                          1893      IF.B D7 <NE> D6 THEN.L
00000D32  41F9 00000FDC           1894        LEA CS_FAILURE,A0             ; warn for mismatched checksum
00000D38                          1895m       PRINT_STR A0,D3
00000D38                          1896m LOOP_133
00000D38  0C10 0000               1897m     CMP.B #0,(A0)                 ; 0 -> DONE
00000D3C  6700 0018               1898m     BEQ EXIT_133
00000D40                          1899mm     PRINT_CHAR (A0)+,D3
00000D40                          1900mm WAIT_FOR_READY_134                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D40                 TRUE     1901mm     IFEQ DEBUG
00000D40  1639 00D30003           1902mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D46  0803 0002               1903mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D4A  67F4                    1904mm       BEQ WAIT_FOR_READY_134          ; NO SPACE, CHECK AGAIN
00000D4C  13D8 00D30007           1905mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000D52                          1906mm     ENDC
00000D52                          1907mm     
00000D52                 FALSE    1908mm     IFNE DEBUG
00000D52                          1909mm     ENDC
00000D52                          1910mm 
00000D52                          1911mm     ENDM
00000D52  4EF8 0D38               1912m     JMP LOOP_133
00000D56                          1913m EXIT_133
00000D56                          1914m     ENDM
00000D56                          1915m       PRINT_REG D4,D3,D6,D7,A0
00000D56                          1916mm     PRINT_CHAR '0',D3           ;0X HEADER
00000D56                          1917mm WAIT_FOR_READY_136                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D56                 TRUE     1918mm     IFEQ DEBUG
00000D56  1639 00D30003           1919mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D5C  0803 0002               1920mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D60  67F4                    1921mm       BEQ WAIT_FOR_READY_136          ; NO SPACE, CHECK AGAIN
00000D62  13F8 0030 00D30007      1922mm       MOVE.B '0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000D6A                          1923mm     ENDC
00000D6A                          1924mm     
00000D6A                 FALSE    1925mm     IFNE DEBUG
00000D6A                          1926mm     ENDC
00000D6A                          1927mm 
00000D6A                          1928mm     ENDM
00000D6A                          1929mm     PRINT_CHAR 'x',D3
00000D6A                          1930mm WAIT_FOR_READY_137                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6A                 TRUE     1931mm     IFEQ DEBUG
00000D6A  1639 00D30003           1932mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D70  0803 0002               1933mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D74  67F4                    1934mm       BEQ WAIT_FOR_READY_137          ; NO SPACE, CHECK AGAIN
00000D76  13F8 0078 00D30007      1935mm       MOVE.B 'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000D7E                          1936mm     ENDC
00000D7E                          1937mm     
00000D7E                 FALSE    1938mm     IFNE DEBUG
00000D7E                          1939mm     ENDC
00000D7E                          1940mm 
00000D7E                          1941mm     ENDM
00000D7E  7E07                    1942m     MOVE.L #7,D7                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D80                          1943m LOOP_135
00000D80                          1944mm     BIN2HEX D4,D6,A0
00000D80  41F9 00001002           1945mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000D86  E99C                    1946mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D88  1C04                    1947mm   MOVE.B D4,D6
00000D8A  0286 0000000F           1948mm   ANDI.L #$F,D6
00000D90  1C30 6000               1949mm   MOVE.B 0(A0,D6),D6                ; USE THAT AS AN INDEX INTO THE LUT
00000D94                          1950mm   ENDM
00000D94                          1951mm     PRINT_CHAR D6,D3
00000D94                          1952mm WAIT_FOR_READY_139                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D94                 TRUE     1953mm     IFEQ DEBUG
00000D94  1639 00D30003           1954mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000D9A  0803 0002               1955mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000D9E  67F4                    1956mm       BEQ WAIT_FOR_READY_139          ; NO SPACE, CHECK AGAIN
00000DA0  13C6 00D30007           1957mm       MOVE.B D6,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DA6                          1958mm     ENDC
00000DA6                          1959mm     
00000DA6                 FALSE    1960mm     IFNE DEBUG
00000DA6                          1961mm     ENDC
00000DA6                          1962mm 
00000DA6                          1963mm     ENDM
00000DA6  57CF FFD8               1964m     DBEQ D7,LOOP_135
00000DAA                          1965m     ENDM
00000DAA                          1966m       PRINT_CRLF D3     
00000DAA                          1967mm     PRINT_CHAR #13,D3             ; CR
00000DAA                          1968mm WAIT_FOR_READY_141                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DAA                 TRUE     1969mm     IFEQ DEBUG
00000DAA  1639 00D30003           1970mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DB0  0803 0002               1971mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DB4  67F4                    1972mm       BEQ WAIT_FOR_READY_141          ; NO SPACE, CHECK AGAIN
00000DB6  13FC 000D 00D30007      1973mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DBE                          1974mm     ENDC
00000DBE                          1975mm     
00000DBE                 FALSE    1976mm     IFNE DEBUG
00000DBE                          1977mm     ENDC
00000DBE                          1978mm 
00000DBE                          1979mm     ENDM
00000DBE                          1980mm     PRINT_CHAR #10,D3             ; LF
00000DBE                          1981mm WAIT_FOR_READY_142                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBE                 TRUE     1982mm     IFEQ DEBUG
00000DBE  1639 00D30003           1983mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DC4  0803 0002               1984mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DC8  67F4                    1985mm       BEQ WAIT_FOR_READY_142          ; NO SPACE, CHECK AGAIN
00000DCA  13FC 000A 00D30007      1986mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000DD2                          1987mm     ENDC
00000DD2                          1988mm     
00000DD2                 FALSE    1989mm     IFNE DEBUG
00000DD2                          1990mm     ENDC
00000DD2                          1991mm 
00000DD2                          1992mm     ENDM
00000DD2                          1993m     ENDM
00000DD2                          1994      ENDI
00000DD2                          1995      
00000DD2  4ED1                    1996      JMP (A1)
00000DD4                          1997  DOWNLOAD_DONE
00000DD4                          1998m     PRINT_REG D4,D3,D7,D6,A0        ; print out number of Srecords read
00000DD4                          1999mm     PRINT_CHAR '0',D3           ;0X HEADER
00000DD4                          2000mm WAIT_FOR_READY_144                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD4                 TRUE     2001mm     IFEQ DEBUG
00000DD4  1639 00D30003           2002mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DDA  0803 0002               2003mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DDE  67F4                    2004mm       BEQ WAIT_FOR_READY_144          ; NO SPACE, CHECK AGAIN
00000DE0  13F8 0030 00D30007      2005mm       MOVE.B '0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000DE8                          2006mm     ENDC
00000DE8                          2007mm     
00000DE8                 FALSE    2008mm     IFNE DEBUG
00000DE8                          2009mm     ENDC
00000DE8                          2010mm 
00000DE8                          2011mm     ENDM
00000DE8                          2012mm     PRINT_CHAR 'x',D3
00000DE8                          2013mm WAIT_FOR_READY_145                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE8                 TRUE     2014mm     IFEQ DEBUG
00000DE8  1639 00D30003           2015mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000DEE  0803 0002               2016mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000DF2  67F4                    2017mm       BEQ WAIT_FOR_READY_145          ; NO SPACE, CHECK AGAIN
00000DF4  13F8 0078 00D30007      2018mm       MOVE.B 'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000DFC                          2019mm     ENDC
00000DFC                          2020mm     
00000DFC                 FALSE    2021mm     IFNE DEBUG
00000DFC                          2022mm     ENDC
00000DFC                          2023mm 
00000DFC                          2024mm     ENDM
00000DFC  7C07                    2025m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DFE                          2026m LOOP_143
00000DFE                          2027mm     BIN2HEX D4,D7,A0
00000DFE  41F9 00001002           2028mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000E04  E99C                    2029mm   ROL.L #4,D4                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E06  1E04                    2030mm   MOVE.B D4,D7
00000E08  0287 0000000F           2031mm   ANDI.L #$F,D7
00000E0E  1E30 7000               2032mm   MOVE.B 0(A0,D7),D7                ; USE THAT AS AN INDEX INTO THE LUT
00000E12                          2033mm   ENDM
00000E12                          2034mm     PRINT_CHAR D7,D3
00000E12                          2035mm WAIT_FOR_READY_147                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E12                 TRUE     2036mm     IFEQ DEBUG
00000E12  1639 00D30003           2037mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E18  0803 0002               2038mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E1C  67F4                    2039mm       BEQ WAIT_FOR_READY_147          ; NO SPACE, CHECK AGAIN
00000E1E  13C7 00D30007           2040mm       MOVE.B D7,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E24                          2041mm     ENDC
00000E24                          2042mm     
00000E24                 FALSE    2043mm     IFNE DEBUG
00000E24                          2044mm     ENDC
00000E24                          2045mm 
00000E24                          2046mm     ENDM
00000E24  57CE FFD8               2047m     DBEQ D6,LOOP_143
00000E28                          2048m     ENDM
00000E28  41F9 00000F94           2049      LEA READ,A0
00000E2E                          2050m     PRINT_STR A0,D3
00000E2E                          2051m LOOP_148
00000E2E  0C10 0000               2052m     CMP.B #0,(A0)                 ; 0 -> DONE
00000E32  6700 0018               2053m     BEQ EXIT_148
00000E36                          2054mm     PRINT_CHAR (A0)+,D3
00000E36                          2055mm WAIT_FOR_READY_149                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E36                 TRUE     2056mm     IFEQ DEBUG
00000E36  1639 00D30003           2057mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E3C  0803 0002               2058mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E40  67F4                    2059mm       BEQ WAIT_FOR_READY_149          ; NO SPACE, CHECK AGAIN
00000E42  13D8 00D30007           2060mm       MOVE.B (A0)+,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E48                          2061mm     ENDC
00000E48                          2062mm     
00000E48                 FALSE    2063mm     IFNE DEBUG
00000E48                          2064mm     ENDC
00000E48                          2065mm 
00000E48                          2066mm     ENDM
00000E48  4EF8 0E2E               2067m     JMP LOOP_148
00000E4C                          2068m EXIT_148
00000E4C                          2069m     ENDM
00000E4C  2E0A                    2070      MOVE.L A2,D7                    ; set address accumulator to start address
00000E4E                          2071m     PRINT_REG D7,D3,D2,D6,A0        ; print out start address
00000E4E                          2072mm     PRINT_CHAR '0',D3           ;0X HEADER
00000E4E                          2073mm WAIT_FOR_READY_151                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4E                 TRUE     2074mm     IFEQ DEBUG
00000E4E  1639 00D30003           2075mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E54  0803 0002               2076mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E58  67F4                    2077mm       BEQ WAIT_FOR_READY_151          ; NO SPACE, CHECK AGAIN
00000E5A  13F8 0030 00D30007      2078mm       MOVE.B '0',DUART_TXA           ; SEND THE NEXT CHARACTER
00000E62                          2079mm     ENDC
00000E62                          2080mm     
00000E62                 FALSE    2081mm     IFNE DEBUG
00000E62                          2082mm     ENDC
00000E62                          2083mm 
00000E62                          2084mm     ENDM
00000E62                          2085mm     PRINT_CHAR 'x',D3
00000E62                          2086mm WAIT_FOR_READY_152                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E62                 TRUE     2087mm     IFEQ DEBUG
00000E62  1639 00D30003           2088mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E68  0803 0002               2089mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E6C  67F4                    2090mm       BEQ WAIT_FOR_READY_152          ; NO SPACE, CHECK AGAIN
00000E6E  13F8 0078 00D30007      2091mm       MOVE.B 'x',DUART_TXA           ; SEND THE NEXT CHARACTER
00000E76                          2092mm     ENDC
00000E76                          2093mm     
00000E76                 FALSE    2094mm     IFNE DEBUG
00000E76                          2095mm     ENDC
00000E76                          2096mm 
00000E76                          2097mm     ENDM
00000E76  7C07                    2098m     MOVE.L #7,D6                ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E78                          2099m LOOP_150
00000E78                          2100mm     BIN2HEX D7,D2,A0
00000E78  41F9 00001002           2101mm   LEA BIN2HEX_LUT,A0                ; LOAD THE LOOKUP TABLE
00000E7E  E99F                    2102mm   ROL.L #4,D7                       ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E80  1407                    2103mm   MOVE.B D7,D2
00000E82  0282 0000000F           2104mm   ANDI.L #$F,D2
00000E88  1430 2000               2105mm   MOVE.B 0(A0,D2),D2                ; USE THAT AS AN INDEX INTO THE LUT
00000E8C                          2106mm   ENDM
00000E8C                          2107mm     PRINT_CHAR D2,D3
00000E8C                          2108mm WAIT_FOR_READY_154                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E8C                 TRUE     2109mm     IFEQ DEBUG
00000E8C  1639 00D30003           2110mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000E92  0803 0002               2111mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000E96  67F4                    2112mm       BEQ WAIT_FOR_READY_154          ; NO SPACE, CHECK AGAIN
00000E98  13C2 00D30007           2113mm       MOVE.B D2,DUART_TXA           ; SEND THE NEXT CHARACTER
00000E9E                          2114mm     ENDC
00000E9E                          2115mm     
00000E9E                 FALSE    2116mm     IFNE DEBUG
00000E9E                          2117mm     ENDC
00000E9E                          2118mm 
00000E9E                          2119mm     ENDM
00000E9E  57CE FFD8               2120m     DBEQ D6,LOOP_150
00000EA2                          2121m     ENDM
00000EA2                          2122m     PRINT_CRLF D3     
00000EA2                          2123mm     PRINT_CHAR #13,D3             ; CR
00000EA2                          2124mm WAIT_FOR_READY_156                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA2                 TRUE     2125mm     IFEQ DEBUG
00000EA2  1639 00D30003           2126mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EA8  0803 0002               2127mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EAC  67F4                    2128mm       BEQ WAIT_FOR_READY_156          ; NO SPACE, CHECK AGAIN
00000EAE  13FC 000D 00D30007      2129mm       MOVE.B #13,DUART_TXA           ; SEND THE NEXT CHARACTER
00000EB6                          2130mm     ENDC
00000EB6                          2131mm     
00000EB6                 FALSE    2132mm     IFNE DEBUG
00000EB6                          2133mm     ENDC
00000EB6                          2134mm 
00000EB6                          2135mm     ENDM
00000EB6                          2136mm     PRINT_CHAR #10,D3             ; LF
00000EB6                          2137mm WAIT_FOR_READY_157                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB6                 TRUE     2138mm     IFEQ DEBUG
00000EB6  1639 00D30003           2139mm       MOVE.B DUART_SRA,D3           ; READ STATUS REGISTER
00000EBC  0803 0002               2140mm       BTST #2,D3                    ; CHECK FOR SPACE TO SEND
00000EC0  67F4                    2141mm       BEQ WAIT_FOR_READY_157          ; NO SPACE, CHECK AGAIN
00000EC2  13FC 000A 00D30007      2142mm       MOVE.B #10,DUART_TXA           ; SEND THE NEXT CHARACTER
00000ECA                          2143mm     ENDC
00000ECA                          2144mm     
00000ECA                 FALSE    2145mm     IFNE DEBUG
00000ECA                          2146mm     ENDC
00000ECA                          2147mm 
00000ECA                          2148mm     ENDM
00000ECA                          2149m     ENDM
00000ECA                          2150          
00000ECA  4EF8 0186               2151      JMP MAIN_LOOP
00000ECE                          2152      
00000ECE  2047                    2153  G   MOVE.L D7,A0                    ; address accumulator -> address register
00000ED0  3E3C 0000               2154      MOVE #0,D7                      ; clear the now used address accumulator
00000ED4  4ED0                    2155      JMP (A0)                        ; jump to it!
00000ED6                          2156          
00000ED6                          2157  HEX_DIGIT
00000ED6  E98F                    2158      LSL.L #4,D7                    ; add the next digit in the next 4 bits
00000ED8                          2159m     HEX2BIN D2,D2,A0
00000ED8  41F9 00001012           2160m   LEA HEX2BIN_LUT,A0                  ; LOAD THE LOOKUP TABLE
00000EDE  0402 0030               2161m   SUB.B #'0',D2                       ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EE2  C4BC 000000FF           2162m   AND.L #$FF,D2                       ; IGNORE THE TOP 3 BYTES
00000EE8  1430 2000               2163m   MOVE.B 0(A0,D2),D2                  ; USE THAT AS AN INDEX INTO THE LUT      
00000EEC                          2164m   ENDM
00000EEC  8E02                    2165      OR.B D2,D7  
00000EEE  4EF8 01AE               2166      JMP GET_INPUT
00000EF2                          2167  
00000EF2  FFFF FFFF               2168      SIMHALT                         ; halt simulator
00000EF6                          2169  
00000EF6                          2170  ; strings
00000EF6= 4D 44 46 2D 6D 6F ...   2171  VERSION DC.B 'MDF-mon V1.8 (01/04/2021)',13,10,0
00000F12= 3F 20 48 65 6C 70 ...   2172  HELP    DC.B '? Help',13,10,'V Version',13,10,'xxxxxxxxR Read long',13,10,'xxxxxxxxWxxxxxxxx Write long',13,10,'S download S records',13,10,'nnnnnnnnG Go',13,10,0
00000F7D= 48 75 68 3F 0D 0A 00    2173  HUH     DC.B 'Huh?',13,10,0
00000F84= 55 6E 69 6D 70 6C ...   2174  UNIMP   DC.B 'Unimplemented',13,10,0
00000F94= 20 53 20 72 65 63 ...   2175  READ    DC.B ' S records read, start address = ',0
00000FB6= 57 41 52 4E 49 4E ...   2176  UNREC   DC.B 'WARNING: Unrecognised S record type: ',0
00000FDC= 57 41 52 4E 49 4E ...   2177  CS_FAILURE   DC.B 'WARNING: Checksum failure for record ',0
00001002= 30 31 32 33 34 35 ...   2178  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001012= 00 01 02 03 04 05 ...   2179  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001029                          2180      
00001029                          2181      END    START                    ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1002
CONTINUE_103        A66
CONTINUE_106        AB2
CONTINUE_109        B00
CONTINUE_112        B4C
CONTINUE_115        B9E
CONTINUE_118        BEA
CONTINUE_127        CB2
CONTINUE_130        CFE
CONTINUE_44         498
CONTINUE_46         4D4
CONTINUE_48         50C
CONTINUE_51         558
CONTINUE_54         5AE
CONTINUE_57         5FA
CONTINUE_60         648
CONTINUE_63         694
CONTINUE_66         6F4
CONTINUE_69         740
CONTINUE_76         7DC
CONTINUE_80         83A
CONTINUE_84         89A
CONTINUE_88         8F8
CONTINUE_92         96C
CONTINUE_96         9CA
CS_FAILURE          FDC
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            8E5
DOWNLOAD_DONE       DD4
DUART_ACR           D30009
DUART_ACR_          4
DUART_BASE          D30000
DUART_CRA           D30005
DUART_CRA_          2
DUART_CRB           D30015
DUART_CRB_          A
DUART_CSRA          D30003
DUART_CSRA_         1
DUART_CSRB          D30013
DUART_CSRB_         9
DUART_IMR           D3000B
DUART_IMR_          5
DUART_IVR           D30019
DUART_IVR_          C
DUART_MRA           D30001
DUART_MRA_          0
DUART_MRB           D30011
DUART_MRB_          8
DUART_OPCR          D3001B
DUART_OPCR_         D
DUART_RESET_OPR     D3001F
DUART_RESET_OPR_    F
DUART_RXA           D30007
DUART_RXA_          3
DUART_RXB           D30017
DUART_RXB_          B
DUART_SET_OPR       D3001D
DUART_SET_OPR_      E
DUART_SRA           D30003
DUART_SRA_          1
DUART_SRB           D30013
DUART_SRB_          9
DUART_TXA           D30007
DUART_TXA_          3
DUART_TXB           D30017
DUART_TXB_          B
EXIT_121            C4E
EXIT_133            D56
EXIT_148            E4C
EXIT_19             2D6
EXIT_21             2FE
EXIT_23             326
EXIT_5              140
G                   ECE
GET_INPUT           1AE
H                   2DA
HELP                F12
HEX2BIN             12B
HEX2BIN_LUT         1012
HEX_DIGIT           ED6
HUH                 F7D
LOOP_121            C30
LOOP_133            D38
LOOP_135            D80
LOOP_143            DFE
LOOP_148            E2E
LOOP_150            E78
LOOP_19             2B8
LOOP_21             2E0
LOOP_23             308
LOOP_25             358
LOOP_5              122
MAIN_LOOP           186
PRINT_CHAR          258
PRINT_CRLF          451
PRINT_REG           52D
PRINT_STR           4AB
R                   32A
READ                F94
READ_CHAR           79C
READ_DATA_TO_POKE   3F8
RRRR                0
S                   476
START               8
UNIMP               F84
UNREC               FB6
V                   302
VERSION             EF6
W                   3B0
WAIT_CHAR           614
WAIT_FOR_READY_1    D8
WAIT_FOR_READY_10   168
WAIT_FOR_READY_101  A10
WAIT_FOR_READY_102  A24
WAIT_FOR_READY_103  A4A
WAIT_FOR_READY_106  A96
WAIT_FOR_READY_109  AE4
WAIT_FOR_READY_11   186
WAIT_FOR_READY_112  B30
WAIT_FOR_READY_115  B82
WAIT_FOR_READY_118  BCE
WAIT_FOR_READY_12   19A
WAIT_FOR_READY_122  C38
WAIT_FOR_READY_123  C4E
WAIT_FOR_READY_125  C60
WAIT_FOR_READY_126  C74
WAIT_FOR_READY_127  C96
WAIT_FOR_READY_13   1AE
WAIT_FOR_READY_130  CE2
WAIT_FOR_READY_134  D40
WAIT_FOR_READY_136  D56
WAIT_FOR_READY_137  D6A
WAIT_FOR_READY_139  D94
WAIT_FOR_READY_141  DAA
WAIT_FOR_READY_142  DBE
WAIT_FOR_READY_144  DD4
WAIT_FOR_READY_145  DE8
WAIT_FOR_READY_147  E12
WAIT_FOR_READY_149  E36
WAIT_FOR_READY_15   1C8
WAIT_FOR_READY_151  E4E
WAIT_FOR_READY_152  E62
WAIT_FOR_READY_154  E8C
WAIT_FOR_READY_156  EA2
WAIT_FOR_READY_157  EB6
WAIT_FOR_READY_17   262
WAIT_FOR_READY_18   276
WAIT_FOR_READY_20   2C0
WAIT_FOR_READY_22   2E8
WAIT_FOR_READY_24   310
WAIT_FOR_READY_26   32E
WAIT_FOR_READY_27   342
WAIT_FOR_READY_29   36C
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   382
WAIT_FOR_READY_32   396
WAIT_FOR_READY_33   3B2
WAIT_FOR_READY_35   3CC
WAIT_FOR_READY_37   3FA
WAIT_FOR_READY_39   414
WAIT_FOR_READY_4    108
WAIT_FOR_READY_42   44A
WAIT_FOR_READY_43   45E
WAIT_FOR_READY_44   47C
WAIT_FOR_READY_46   4B8
WAIT_FOR_READY_48   4F0
WAIT_FOR_READY_51   53C
WAIT_FOR_READY_54   592
WAIT_FOR_READY_57   5DE
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_60   62C
WAIT_FOR_READY_63   678
WAIT_FOR_READY_66   6D8
WAIT_FOR_READY_69   724
WAIT_FOR_READY_72   770
WAIT_FOR_READY_74   786
WAIT_FOR_READY_75   79A
WAIT_FOR_READY_76   7C0
WAIT_FOR_READY_78   7F4
WAIT_FOR_READY_8    140
WAIT_FOR_READY_80   81E
WAIT_FOR_READY_82   852
WAIT_FOR_READY_84   87E
WAIT_FOR_READY_86   8B2
WAIT_FOR_READY_88   8DC
WAIT_FOR_READY_9    154
WAIT_FOR_READY_90   910
WAIT_FOR_READY_92   950
WAIT_FOR_READY_94   984
WAIT_FOR_READY_96   9AE
WAIT_FOR_READY_98   9E2
WAIT_FOR_SRECORD    47C
_00000000           7B6
_00000001           C8C
_00000002           A40
_00000003           C8C
_00000004           C2A
_00000005           C8C
_00000006           DD2
_10000000           6CA
_10000001           786
_10000002           942
_10000003           A10
