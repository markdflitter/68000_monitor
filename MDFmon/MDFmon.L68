00200008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/04/2021 16:02:44

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : MDFmon 
00000000                             3  * Written by : Mark Flitter
00000000                             4  * Date       : March 2021
00000000                             5  * Description: 68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; Review for any other savings
00000000                             9  ; burn EEPROM to alternative location ($1000) and update the start vector as the very last operation
00000000                            10  ; if the EEPROM programming getas stuck, print out value read back and retry write eventually? 
00000000                            11  ; make the monitor relocatable, so it can run in RAM and ROM
00000000                            12  
00000000                            13  
00000000                            14  ; keep track of highest address hit during srec download
00000000                            15  ; implement backspace
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  ; fix being able to enter random chars when W'ing
00000000                            18  ; ram check at startup?  Not sure if this is a good idea!
00000000                            19  
00000000                            20      ;ORG  $0
00200000                            21      ORG  $200000
00200000                            22  
00200000  =00000000                 23  DEBUG               EQU 0
00200000                            24  
00200000                            25  ; constants
00200000  =00000000                 26  NULL                EQU 0
00200000  =00000009                 27  TAB                 EQU 9
00200000  =0000000D                 28  CR                  EQU 13
00200000  =0000000A                 29  LF                  EQU 10
00200000                            30  
00200000  =00000000                 31  ROM                 EQU $0
00200000  =00200000                 32  RAM                 EQU $200000
00200000                            33     
00200000  =00C00000                 34  DUART_BASE          EQU $C00000
00200000  =00000000                 35  DUART_MRA_          EQU $0
00200000  =00000001                 36  DUART_CSRA_         EQU $1
00200000  =00000001                 37  DUART_SRA_          EQU $1
00200000  =00000002                 38  DUART_CRA_          EQU $2
00200000  =00000003                 39  DUART_TXA_          EQU $3
00200000  =00000003                 40  DUART_RXA_          EQU $3
00200000  =00000004                 41  DUART_ACR_          EQU $4
00200000  =00000005                 42  DUART_IMR_          EQU $5
00200000  =00000008                 43  DUART_MRB_          EQU $8
00200000  =00000009                 44  DUART_CSRB_         EQU $9
00200000  =00000009                 45  DUART_SRB_          EQU $9
00200000  =0000000A                 46  DUART_CRB_          EQU $A
00200000  =0000000B                 47  DUART_TXB_          EQU $B
00200000  =0000000B                 48  DUART_RXB_          EQU $B
00200000  =0000000C                 49  DUART_IVR_          EQU $C
00200000  =0000000D                 50  DUART_OPCR_         EQU $D
00200000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00200000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00200000                            53  
00200000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00200000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00200000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00200000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00200000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00200000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00200000                            60  
00200000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00200000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00200000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00200000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00200000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00200000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00200000                            67  
00200000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00200000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00200000  =00C00019                 70  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00200000  =00C0001B                 71  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00200000  =00C0001D                 72  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00200000  =00C0001F                 73  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00200000                            74  
00200000  =00E00000                 75  DISPLAY_BASE        EQU $E00000
00200000  =00000000                 76  DISPLAY_            EQU $0
00200000  =00E00001                 77  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00200000                            78  
00200000                            79  ; macros
00200000                            80  ; convert top 4 bits of input register from binary to a single hex digit
00200000                            81  ; the input register is changed during the process
00200000                            82  ; \1 input data register containing binary number,  \2 data register for return value, \3 working address register
00200000                            83  BIN2HEX MACRO
00200000                            84      LEA BIN2HEX_LUT,\3                          ; load the lookup table
00200000                            85      ROL.L #4,\1                                 ; shift the top 4 bits down to bottom of the register the and mask off everything else
00200000                            86      MOVE.B \1,\2
00200000                            87      ANDI.L #$F,\2
00200000                            88      MOVE.B 0(\3,\2),\2                          ; use that as an index into the LUT
00200000                            89      ENDM
00200000                            90  
00200000                            91  ; convert single hex digit to 4 bit binary number in LSbits
00200000                            92  ; the input register is changed during the process
00200000                            93  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00200000                            94  HEX2BIN MACRO
00200000                            95      LEA HEX2BIN_LUT,\3                              ; load the lookup table
00200000                            96      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00200000                            97      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00200000                            98      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT      
00200000                            99      ENDM
00200000                           100  
00200000                           101  ; send a single char to the serial port
00200000                           102  ; \1 = char to send, \2 = data register to use for status poll
00200000                           103  ; will stamp on D0 and D1 in debug mode
00200000                           104  PRINT_CHAR MACRO
00200000                           105  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           106      IFEQ DEBUG
00200000                           107          MOVE.B DUART_SRA,\2                     ; read status register
00200000                           108          BTST #2,\2                              ; check for space to send
00200000                           109          BEQ WAIT_FOR_READY\@                    ; no space, check again
00200000                           110          MOVE.B \1,DUART_TXA                     ; send the next character
00200000                           111      ENDC
00200000                           112      
00200000                           113      IFNE DEBUG
00200000                           114          MOVE.B \1,D1
00200000                           115          MOVE.L #6,D0   
00200000                           116          TRAP #15                                ; write to terminal in simulator
00200000                           117      ENDC
00200000                           118  
00200000                           119      ENDM
00200000                           120  
00200000                           121  ; send CR,LF to the serial port
00200000                           122  ; \1 = data register to use for status poll
00200000                           123  PRINT_CRLF MACRO
00200000                           124      PRINT_CHAR #CR,\1                           ; CR
00200000                           125      PRINT_CHAR #LF,\1                           ; LF
00200000                           126      ENDM
00200000                           127  
00200000                           128  ; send C-style, zero terminated string to the serial port
00200000                           129  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00200000                           130  PRINT_STR MACRO
00200000                           131  LOOP\@
00200000                           132      CMP.B #NULL,(\1)                            ; 0 -> done
00200000                           133      BEQ EXIT\@
00200000                           134      PRINT_CHAR (\1)+,\2
00200000                           135      BRA LOOP\@
00200000                           136  EXIT\@
00200000                           137      ENDM
00200000                           138    
00200000                           139  ; send the contents of a data register to the serial port as a 8 digit hex number
00200000                           140  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00200000                           141  PRINT_REG MACRO
00200000                           142      PRINT_CHAR #'0',\2                              ;0x header
00200000                           143      PRINT_CHAR #'x',\2
00200000                           144      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00200000                           145  LOOP\@
00200000                           146      BIN2HEX \1,\3,\5
00200000                           147      PRINT_CHAR \3,\2
00200000                           148      DBEQ \4,LOOP\@
00200000                           149      ENDM
00200000                           150      
00200000                           151  ; wait for a char from the serial port
00200000                           152  ; \ 1= data register for read char, \2 = register to use for status poll
00200000                           153  ; will stamp on D0 and D1 in debug mode
00200000                           154  WAIT_CHAR MACRO
00200000                           155  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           156      IFEQ DEBUG
00200000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00200000                           158          BTST #0,\2                              ; check for character
00200000                           159          BEQ WAIT_FOR_READY\@                    ; nothing, check again
00200000                           160      ENDC
00200000                           161      
00200000                           162      READ_CHAR \1
00200000                           163  
00200000                           164      IFEQ DEBUG
00200000                           165          PRINT_CHAR \1,\2                            ; echo it back
00200000                           166      ENDC
00200000                           167      ENDM
00200000                           168      
00200000                           169  ; read a char from the serial port - assumes that there is one!
00200000                           170  ; \ 1= data register for read char
00200000                           171  ; will stamp on D0 and D1 in debug mode
00200000                           172  READ_CHAR MACRO
00200000                           173      IFEQ DEBUG
00200000                           174          MOVE.B DUART_RXA,\1                         ; got a character, read it
00200000                           175      ENDC
00200000                           176      IFNE DEBUG
00200000                           177          MOVE.L #5,D0    
00200000                           178          TRAP #15                                    ; read from keyboard in simulator
00200000                           179          MOVE.L D1,\1
00200000                           180      ENDC
00200000                           181       
00200000                           182      CMP.B #$1B,\1                               ; check for escape and go to start
00200000                           183      BEQ START
00200000                           184      ENDM
00200000                           185      
00200000                           186      
00200000                           187  ; read data from the download serial port
00200000                           188  ; \ 1= data register for read char
00200000                           189  DOWNLOAD MACRO
00200000                           190  WAIT_FOR_READY\@                                ; wait until the there is space to send
00200000                           191  
00200000                           192      MOVE.B DUART_SRA,\1                         ; check for command
00200000                           193      BTST #0,\1                                  ; check for character
00200000                           194      BEQ CONTINUE\@                              ; nothing, continue
00200000                           195   
00200000                           196      READ_CHAR \1                                ; we're not going to do anything with it, just check for escape
00200000                           197  CONTINUE\@
00200000                           198      MOVE.B DUART_SRB,\1                             ; read download status register
00200000                           199      BTST #0,\1                                      ; check for character
00200000                           200      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00200000                           201      
00200000                           202      MOVE.B DUART_RXB,\1                             ; got a character, read it
00200000                           203      MOVE.B \1,DISPLAY                               ; echo to the display
00200000                           204      
00200000                           205      ENDM
00200000                           206      
00200000                           207  ; read two hex digits from the download serial port and convert to a byte
00200000                           208  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00200000                           209  DOWNLOAD_BYTE MACRO
00200000                           210      MOVE.B #2,\4
00200000                           211      WHILE.B \4 <GT> 0 DO
00200000                           212          LSL.L #4,\1                             ; it's OK to do this first, because we are either starting from 0, 
00200000                           213          DOWNLOAD \2                             ; or we are reading the next byte along, so need to shift up the previous one
00200000                           214          PRINT_CHAR \2,\3
00200000                           215          HEX2BIN \2,\2,\6
00200000                           216          OR.B \2,\1
00200000                           217          SUB.B #1,\4
00200000                           218      ENDW
00200000                           219      
00200000                           220      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00200000                           221      MOVE.B \1,\2
00200000                           222      ADD.L \1,\5
00200000                           223  
00200000                           224      ENDM
00200000                           225      
00200000                           226  
00200000                           227  ; register catalogue
00200000                           228  ; D0 - used for simulator I/O
00200000                           229  ; D1 - used for simulator I/O
00200000                           230  ; D2 - read character
00200000                           231  ; D3 - serial port status poll / task for TRAP in simulator
00200000                           232  ; D6 - working register used in R/W
00200000                           233  ; D7 - address accumulator, reset by download
00200000                           234  ; A0 - address of string to print 
00200000                           235  
00200000                           236  ; start vector
00200000= 00000000                 237  STACK    DC.L $00000000                         ; STACK
00200004= 00200008                 238  RESET    DC.L START                             ; RESET
00200008                           239      
00200008                           240  ; start of program  
00200008                           241  START
00200008  13FC 0000 00E00001       242      MOVE.B #0,DISPLAY
00200010                           243  
00200010                           244  ; reset the UART in case of warm start
00200010  13FC 000A 00C00005       245      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00200018  13FC 0050 00C00005       246      MOVE.B #$50,DUART_CRA                           ; reset everyting
00200020  4E71                     247      NOP
00200022  13FC 0040 00C00005       248      MOVE.B #$40,DUART_CRA           
0020002A  4E71                     249      NOP
0020002C  13FC 0030 00C00005       250      MOVE.B #$30,DUART_CRA
00200034  4E71                     251      NOP
00200036  13FC 0020 00C00005       252      MOVE.B #$20,DUART_CRA
0020003E  4E71                     253      NOP
00200040  13FC 0010 00C00005       254      MOVE.B #$10,DUART_CRA   
00200048                           255  
00200048  13FC 000A 00C00015       256      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00200050  13FC 0050 00C00015       257      MOVE.B #$50,DUART_CRB                           ; reset everyting
00200058  4E71                     258      NOP
0020005A  13FC 0040 00C00015       259      MOVE.B #$40,DUART_CRB           
00200062  4E71                     260      NOP
00200064  13FC 0030 00C00015       261      MOVE.B #$30,DUART_CRB
0020006C  4E71                     262      NOP
0020006E  13FC 0020 00C00015       263      MOVE.B #$20,DUART_CRB
00200076  4E71                     264      NOP
00200078  13FC 0010 00C00015       265      MOVE.B #$10,DUART_CRB   
00200080                           266  
00200080                           267  ;initialise UART
00200080  13FC 0000 00C00009       268      MOVE.B #$0,DUART_ACR            
00200088  13FC 0000 00C0000B       269      MOVE.B #$0,DUART_IMR                            ; no interrupts, please            
00200090  13FC 0000 00C0001B       270      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
00200098                           271  
00200098                           272  ; channel A
00200098  13FC 0013 00C00001       273      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
002000A0  13FC 0007 00C00001       274      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
002000A8  13FC 00CC 00C00003       275      MOVE.B #$CC,DUART_CSRA                          ; 9600 baud
002000B0  13FC 0005 00C00005       276      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
002000B8                           277  
002000B8                           278  ; channel B
002000B8  13FC 0013 00C00011       279      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
002000C0  13FC 0007 00C00011       280      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
002000C8  13FC 00CC 00C00013       281      MOVE.B #$CC,DUART_CSRB                          ; 9600 baud
002000D0  13FC 0005 00C00015       282      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
002000D8                           283  
002000D8                           284m     PRINT_CHAR '.',D3                               ; give the serial port chance to settle after reset
002000D8                           285m WAIT_FOR_READY_1                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000D8                 TRUE      286m     IFEQ DEBUG
002000D8  1639 00C00003            287m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000DE  0803 0002                288m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000E2  67F4                     289m         BEQ WAIT_FOR_READY_1                    ; NO SPACE, CHECK AGAIN
002000E4  13F8 002E 00C00007       290m         MOVE.B '.',DUART_TXA                    ; SEND THE NEXT CHARACTER
002000EC                           291m     ENDC
002000EC                           292m     
002000EC                 FALSE     293m     IFNE DEBUG
002000EC                           294m     ENDC
002000EC                           295m 
002000EC                           296m     ENDM
002000EC                           297  
002000EC  13FC 0001 00E00001       298      MOVE.B #1,DISPLAY
002000F4                           299         
002000F4                           300m     PRINT_CRLF D3
002000F4                           301mm     PRINT_CHAR #CR,D3                           ; CR
002000F4                           302mm WAIT_FOR_READY_3                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
002000F4                 TRUE      303mm     IFEQ DEBUG
002000F4  1639 00C00003            304mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002000FA  0803 0002                305mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002000FE  67F4                     306mm         BEQ WAIT_FOR_READY_3                    ; NO SPACE, CHECK AGAIN
00200100  13FC 000D 00C00007       307mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200108                           308mm     ENDC
00200108                           309mm     
00200108                 FALSE     310mm     IFNE DEBUG
00200108                           311mm     ENDC
00200108                           312mm 
00200108                           313mm     ENDM
00200108                           314mm     PRINT_CHAR #LF,D3                           ; LF
00200108                           315mm WAIT_FOR_READY_4                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200108                 TRUE      316mm     IFEQ DEBUG
00200108  1639 00C00003            317mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020010E  0803 0002                318mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200112  67F4                     319mm         BEQ WAIT_FOR_READY_4                    ; NO SPACE, CHECK AGAIN
00200114  13FC 000A 00C00007       320mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020011C                           321mm     ENDC
0020011C                           322mm     
0020011C                 FALSE     323mm     IFNE DEBUG
0020011C                           324mm     ENDC
0020011C                           325mm 
0020011C                           326mm     ENDM
0020011C                           327m     ENDM
0020011C                           328  
0020011C  41F9 00200DE6            329      LEA VERSION,A0
00200122                           330m     PRINT_STR A0,D3
00200122                           331m LOOP_5
00200122  0C10 0000                332m     CMP.B #NULL,(A0)                            ; 0 -> DONE
00200126  6700 0016                333m     BEQ EXIT_5
0020012A                           334mm     PRINT_CHAR (A0)+,D3
0020012A                           335mm WAIT_FOR_READY_6                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020012A                 TRUE      336mm     IFEQ DEBUG
0020012A  1639 00C00003            337mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200130  0803 0002                338mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200134  67F4                     339mm         BEQ WAIT_FOR_READY_6                    ; NO SPACE, CHECK AGAIN
00200136  13D8 00C00007            340mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
0020013C                           341mm     ENDC
0020013C                           342mm     
0020013C                 FALSE     343mm     IFNE DEBUG
0020013C                           344mm     ENDC
0020013C                           345mm 
0020013C                           346mm     ENDM
0020013C  60E4                     347m     BRA LOOP_5
0020013E                           348m EXIT_5
0020013E                           349m     ENDM
0020013E                           350m     PRINT_CRLF D3
0020013E                           351mm     PRINT_CHAR #CR,D3                           ; CR
0020013E                           352mm WAIT_FOR_READY_8                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020013E                 TRUE      353mm     IFEQ DEBUG
0020013E  1639 00C00003            354mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200144  0803 0002                355mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200148  67F4                     356mm         BEQ WAIT_FOR_READY_8                    ; NO SPACE, CHECK AGAIN
0020014A  13FC 000D 00C00007       357mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200152                           358mm     ENDC
00200152                           359mm     
00200152                 FALSE     360mm     IFNE DEBUG
00200152                           361mm     ENDC
00200152                           362mm 
00200152                           363mm     ENDM
00200152                           364mm     PRINT_CHAR #LF,D3                           ; LF
00200152                           365mm WAIT_FOR_READY_9                                ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200152                 TRUE      366mm     IFEQ DEBUG
00200152  1639 00C00003            367mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200158  0803 0002                368mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020015C  67F4                     369mm         BEQ WAIT_FOR_READY_9                    ; NO SPACE, CHECK AGAIN
0020015E  13FC 000A 00C00007       370mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200166                           371mm     ENDC
00200166                           372mm     
00200166                 FALSE     373mm     IFNE DEBUG
00200166                           374mm     ENDC
00200166                           375mm 
00200166                           376mm     ENDM
00200166                           377m     ENDM
00200166                           378  
00200166  7E00                     379      MOVE.L #0,D7                                    ; address accumulator
00200168                           380  
00200168  13FC 0002 00E00001       381      MOVE.B #2,DISPLAY
00200170                           382  MAIN_LOOP
00200170                           383m     PRINT_CHAR #'>',D3                          ; prompt
00200170                           384m WAIT_FOR_READY_10                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200170                 TRUE      385m     IFEQ DEBUG
00200170  1639 00C00003            386m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200176  0803 0002                387m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020017A  67F4                     388m         BEQ WAIT_FOR_READY_10                   ; NO SPACE, CHECK AGAIN
0020017C  13FC 003E 00C00007       389m         MOVE.B #'>',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200184                           390m     ENDC
00200184                           391m     
00200184                 FALSE     392m     IFNE DEBUG
00200184                           393m     ENDC
00200184                           394m 
00200184                           395m     ENDM
00200184                           396m     PRINT_CHAR #32,D3                           ; space
00200184                           397m WAIT_FOR_READY_11                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200184                 TRUE      398m     IFEQ DEBUG
00200184  1639 00C00003            399m         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020018A  0803 0002                400m         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020018E  67F4                     401m         BEQ WAIT_FOR_READY_11                   ; NO SPACE, CHECK AGAIN
00200190  13FC 0020 00C00007       402m         MOVE.B #32,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200198                           403m     ENDC
00200198                           404m     
00200198                 FALSE     405m     IFNE DEBUG
00200198                           406m     ENDC
00200198                           407m 
00200198                           408m     ENDM
00200198                           409      
00200198                           410  GET_INPUT
00200198                           411m     WAIT_CHAR D2,D3                             ; fetch character from serial port -> D2
00200198                           412m WAIT_FOR_READY_12                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200198                 TRUE      413m     IFEQ DEBUG
00200198  1639 00C00003            414m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0020019E  0803 0000                415m         BTST #0,D3                              ; CHECK FOR CHARACTER
002001A2  67F4                     416m         BEQ WAIT_FOR_READY_12                   ; NOTHING, CHECK AGAIN
002001A4                           417m     ENDC
002001A4                           418m     
002001A4                           419mm     READ_CHAR D2
002001A4                 TRUE      420mm     IFEQ DEBUG
002001A4  1439 00C00007            421mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
002001AA                           422mm     ENDC
002001AA                 FALSE     423mm     IFNE DEBUG
002001AA                           424mm     ENDC
002001AA                           425mm      
002001AA  B43C 001B                426mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
002001AE  6700 FE58                427mm     BEQ START
002001B2                           428mm     ENDM
002001B2                           429m 
002001B2                 TRUE      430m     IFEQ DEBUG
002001B2                           431mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
002001B2                           432mm WAIT_FOR_READY_14                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001B2                 TRUE      433mm     IFEQ DEBUG
002001B2  1639 00C00003            434mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002001B8  0803 0002                435mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002001BC  67F4                     436mm         BEQ WAIT_FOR_READY_14                   ; NO SPACE, CHECK AGAIN
002001BE  13C2 00C00007            437mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
002001C4                           438mm     ENDC
002001C4                           439mm     
002001C4                 FALSE     440mm     IFNE DEBUG
002001C4                           441mm     ENDC
002001C4                           442mm 
002001C4                           443mm     ENDM
002001C4                           444m     ENDC
002001C4                           445m     ENDM
002001C4                           446      
002001C4                           447      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
002001C4  B43C 0030                448s     CMP.B   #'0',D2
002001C8  6D00 000E                449s     BLT _00000000
002001CC  B43C 0039                450s     CMP.B   #'9',D2
002001D0  6E00 0006                451s     BGT _00000000
002001D4  6000 0BF0                452          BRA HEX_DIGIT
002001D8                           453      ENDI
002001D8                           454s _00000000
002001D8                           455      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
002001D8  B43C 0041                456s     CMP.B   #'A',D2
002001DC  6D00 000E                457s     BLT _00000001
002001E0  B43C 0046                458s     CMP.B   #'F',D2
002001E4  6E00 0006                459s     BGT _00000001
002001E8  6000 0BDC                460          BRA HEX_DIGIT
002001EC                           461      ENDI
002001EC                           462s _00000001
002001EC                           463          
002001EC  B43C 0077                464      CMP.B #'w',D2
002001F0  6700 013E                465      BEQ W
002001F4                           466      
002001F4  B43C 006C                467      CMP.B #'l',D2
002001F8  6700 0A60                468      BEQ L 
002001FC                           469  
002001FC                           470m     PRINT_CRLF D3
002001FC                           471mm     PRINT_CHAR #CR,D3                           ; CR
002001FC                           472mm WAIT_FOR_READY_16                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002001FC                 TRUE      473mm     IFEQ DEBUG
002001FC  1639 00C00003            474mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200202  0803 0002                475mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200206  67F4                     476mm         BEQ WAIT_FOR_READY_16                   ; NO SPACE, CHECK AGAIN
00200208  13FC 000D 00C00007       477mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200210                           478mm     ENDC
00200210                           479mm     
00200210                 FALSE     480mm     IFNE DEBUG
00200210                           481mm     ENDC
00200210                           482mm 
00200210                           483mm     ENDM
00200210                           484mm     PRINT_CHAR #LF,D3                           ; LF
00200210                           485mm WAIT_FOR_READY_17                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200210                 TRUE      486mm     IFEQ DEBUG
00200210  1639 00C00003            487mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200216  0803 0002                488mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020021A  67F4                     489mm         BEQ WAIT_FOR_READY_17                   ; NO SPACE, CHECK AGAIN
0020021C  13FC 000A 00C00007       490mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200224                           491mm     ENDC
00200224                           492mm     
00200224                 FALSE     493mm     IFNE DEBUG
00200224                           494mm     ENDC
00200224                           495mm 
00200224                           496mm     ENDM
00200224                           497m     ENDM
00200224                           498   
00200224  B43C 003F                499      CMP.B #'?',D2
00200228  6700 0050                500      BEQ H
0020022C                           501  
0020022C  B43C 0076                502      CMP.B #'v',D2
00200230  6700 0052                503      BEQ V
00200234                           504      
00200234  B43C 0072                505      CMP.B #'r',D2
00200238  6700 0070                506      BEQ R
0020023C                           507  
0020023C  B43C 0073                508      CMP.B #'s',D2
00200240  6700 0172                509      BEQ S
00200244                           510  
00200244  B43C 0067                511      CMP.B #'g',D2
00200248  6700 0902                512      BEQ G   
0020024C                           513  
0020024C  B43C 007A                514      CMP.B #'z',D2
00200250  6700 0902                515      BEQ Z   
00200254                           516  
00200254  41F9 00200EB3            517      LEA HUH,A0
0020025A                           518m     PRINT_STR A0,D3
0020025A                           519m LOOP_18
0020025A  0C10 0000                520m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0020025E  6700 0016                521m     BEQ EXIT_18
00200262                           522mm     PRINT_CHAR (A0)+,D3
00200262                           523mm WAIT_FOR_READY_19                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200262                 TRUE      524mm     IFEQ DEBUG
00200262  1639 00C00003            525mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200268  0803 0002                526mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020026C  67F4                     527mm         BEQ WAIT_FOR_READY_19                   ; NO SPACE, CHECK AGAIN
0020026E  13D8 00C00007            528mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200274                           529mm     ENDC
00200274                           530mm     
00200274                 FALSE     531mm     IFNE DEBUG
00200274                           532mm     ENDC
00200274                           533mm 
00200274                           534mm     ENDM
00200274  60E4                     535m     BRA LOOP_18
00200276                           536m EXIT_18
00200276                           537m     ENDM
00200276                           538                         
00200276  6000 FEF8                539      BRA MAIN_LOOP
0020027A                           540      
0020027A                           541  ; commands
0020027A                           542  H   
0020027A  41F9 00200E03            543      LEA HELP,A0
00200280  6000 0008                544      BRA PRINTSTR
00200284                           545  
00200284                           546  V   
00200284  41F9 00200DE6            547      LEA VERSION,A0
0020028A                           548  PRINTSTR
0020028A                           549m     PRINT_STR A0,D3       
0020028A                           550m LOOP_20
0020028A  0C10 0000                551m     CMP.B #NULL,(A0)                            ; 0 -> DONE
0020028E  6700 0016                552m     BEQ EXIT_20
00200292                           553mm     PRINT_CHAR (A0)+,D3
00200292                           554mm WAIT_FOR_READY_21                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200292                 TRUE      555mm     IFEQ DEBUG
00200292  1639 00C00003            556mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200298  0803 0002                557mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020029C  67F4                     558mm         BEQ WAIT_FOR_READY_21                   ; NO SPACE, CHECK AGAIN
0020029E  13D8 00C00007            559mm         MOVE.B (A0)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002002A4                           560mm     ENDC
002002A4                           561mm     
002002A4                 FALSE     562mm     IFNE DEBUG
002002A4                           563mm     ENDC
002002A4                           564mm 
002002A4                           565mm     ENDM
002002A4  60E4                     566m     BRA LOOP_20
002002A6                           567m EXIT_20
002002A6                           568m     ENDM
002002A6  6000 FEC8                569      BRA MAIN_LOOP
002002AA                           570      
002002AA                           571  R   
002002AA  2047                     572      MOVE.L D7,A0                                    ; address accumulator -> address register
002002AC  2A10                     573      MOVE.L (A0),D5                                  ; read the memory and print it
002002AE                           574m     PRINT_REG D5,D3,D7,D6,A0
002002AE                           575mm     PRINT_CHAR #'0',D3                              ;0X HEADER
002002AE                           576mm WAIT_FOR_READY_23                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002AE                 TRUE      577mm     IFEQ DEBUG
002002AE  1639 00C00003            578mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002B4  0803 0002                579mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002B8  67F4                     580mm         BEQ WAIT_FOR_READY_23                   ; NO SPACE, CHECK AGAIN
002002BA  13FC 0030 00C00007       581mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002C2                           582mm     ENDC
002002C2                           583mm     
002002C2                 FALSE     584mm     IFNE DEBUG
002002C2                           585mm     ENDC
002002C2                           586mm 
002002C2                           587mm     ENDM
002002C2                           588mm     PRINT_CHAR #'x',D3
002002C2                           589mm WAIT_FOR_READY_24                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002C2                 TRUE      590mm     IFEQ DEBUG
002002C2  1639 00C00003            591mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002C8  0803 0002                592mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002CC  67F4                     593mm         BEQ WAIT_FOR_READY_24                   ; NO SPACE, CHECK AGAIN
002002CE  13FC 0078 00C00007       594mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002002D6                           595mm     ENDC
002002D6                           596mm     
002002D6                 FALSE     597mm     IFNE DEBUG
002002D6                           598mm     ENDC
002002D6                           599mm 
002002D6                           600mm     ENDM
002002D6  7C07                     601m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002002D8                           602m LOOP_22
002002D8                           603mm     BIN2HEX D5,D7,A0
002002D8  41F9 00200F17            604mm     LEA BIN2HEX_LUT,A0                          ; LOAD THE LOOKUP TABLE
002002DE  E99D                     605mm     ROL.L #4,D5                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
002002E0  1E05                     606mm     MOVE.B D5,D7
002002E2  0287 0000000F            607mm     ANDI.L #$F,D7
002002E8  1E30 7000                608mm     MOVE.B 0(A0,D7),D7                          ; USE THAT AS AN INDEX INTO THE LUT
002002EC                           609mm     ENDM
002002EC                           610mm     PRINT_CHAR D7,D3
002002EC                           611mm WAIT_FOR_READY_26                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002002EC                 TRUE      612mm     IFEQ DEBUG
002002EC  1639 00C00003            613mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002002F2  0803 0002                614mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002002F6  67F4                     615mm         BEQ WAIT_FOR_READY_26                   ; NO SPACE, CHECK AGAIN
002002F8  13C7 00C00007            616mm         MOVE.B D7,DUART_TXA                     ; SEND THE NEXT CHARACTER
002002FE                           617mm     ENDC
002002FE                           618mm     
002002FE                 FALSE     619mm     IFNE DEBUG
002002FE                           620mm     ENDC
002002FE                           621mm 
002002FE                           622mm     ENDM
002002FE  57CE FFD8                623m     DBEQ D6,LOOP_22
00200302                           624m     ENDM
00200302                           625m     PRINT_CRLF D3
00200302                           626mm     PRINT_CHAR #CR,D3                           ; CR
00200302                           627mm WAIT_FOR_READY_28                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200302                 TRUE      628mm     IFEQ DEBUG
00200302  1639 00C00003            629mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200308  0803 0002                630mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020030C  67F4                     631mm         BEQ WAIT_FOR_READY_28                   ; NO SPACE, CHECK AGAIN
0020030E  13FC 000D 00C00007       632mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200316                           633mm     ENDC
00200316                           634mm     
00200316                 FALSE     635mm     IFNE DEBUG
00200316                           636mm     ENDC
00200316                           637mm 
00200316                           638mm     ENDM
00200316                           639mm     PRINT_CHAR #LF,D3                           ; LF
00200316                           640mm WAIT_FOR_READY_29                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200316                 TRUE      641mm     IFEQ DEBUG
00200316  1639 00C00003            642mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020031C  0803 0002                643mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200320  67F4                     644mm         BEQ WAIT_FOR_READY_29                   ; NO SPACE, CHECK AGAIN
00200322  13FC 000A 00C00007       645mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020032A                           646mm     ENDC
0020032A                           647mm     
0020032A                 FALSE     648mm     IFNE DEBUG
0020032A                           649mm     ENDC
0020032A                           650mm 
0020032A                           651mm     ENDM
0020032A                           652m     ENDM
0020032A  7E00                     653      MOVE.L #0,D7                                    ; clear the now used address accumulator
0020032C  6000 FE42                654      BRA MAIN_LOOP
00200330                           655  
00200330                           656  W
00200330  7A00                     657      MOVE.L #0,D5                                    ; D5 will be the value to write            
00200332                           658  
00200332  3C3C 0007                659      MOVE #7,D6                                      ; 7 bytes left to read
00200336                           660      
00200336                           661  READ_DATA_TO_POKE
00200336  E98D                     662      LSL.L #4,D5                                     ; make what we have so far more significant
00200338                           663m     WAIT_CHAR D2,D3                                 ; next character -> D2
00200338                           664m WAIT_FOR_READY_30                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200338                 TRUE      665m     IFEQ DEBUG
00200338  1639 00C00003            666m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0020033E  0803 0000                667m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200342  67F4                     668m         BEQ WAIT_FOR_READY_30                   ; NOTHING, CHECK AGAIN
00200344                           669m     ENDC
00200344                           670m     
00200344                           671mm     READ_CHAR D2
00200344                 TRUE      672mm     IFEQ DEBUG
00200344  1439 00C00007            673mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0020034A                           674mm     ENDC
0020034A                 FALSE     675mm     IFNE DEBUG
0020034A                           676mm     ENDC
0020034A                           677mm      
0020034A  B43C 001B                678mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
0020034E  6700 FCB8                679mm     BEQ START
00200352                           680mm     ENDM
00200352                           681m 
00200352                 TRUE      682m     IFEQ DEBUG
00200352                           683mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200352                           684mm WAIT_FOR_READY_32                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200352                 TRUE      685mm     IFEQ DEBUG
00200352  1639 00C00003            686mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200358  0803 0002                687mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
0020035C  67F4                     688mm         BEQ WAIT_FOR_READY_32                   ; NO SPACE, CHECK AGAIN
0020035E  13C2 00C00007            689mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200364                           690mm     ENDC
00200364                           691mm     
00200364                 FALSE     692mm     IFNE DEBUG
00200364                           693mm     ENDC
00200364                           694mm 
00200364                           695mm     ENDM
00200364                           696m     ENDC
00200364                           697m     ENDM
00200364                           698m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200364  41F9 00200F27            699m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
0020036A  0402 0030                700m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020036E  C4BC 000000FF            701m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200374  1430 2000                702m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200378                           703m     ENDM
00200378  8A02                     704      OR.B D2,D5
0020037A  023C 00FB                705      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
0020037E  57CE FFB6                706      DBEQ D6,READ_DATA_TO_POKE
00200382                           707      
00200382  2047                     708      MOVE.L D7,A0                                    ; address accumulator -> address register
00200384  7E00                     709      MOVE.L #0,D7                                    ; clear the now used address accumulator
00200386                           710      
00200386  2085                     711      MOVE.L D5,(A0)                                  ; write the data
00200388                           712  
00200388                           713m     PRINT_CRLF D3
00200388                           714mm     PRINT_CHAR #CR,D3                           ; CR
00200388                           715mm WAIT_FOR_READY_35                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200388                 TRUE      716mm     IFEQ DEBUG
00200388  1639 00C00003            717mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
0020038E  0803 0002                718mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200392  67F4                     719mm         BEQ WAIT_FOR_READY_35                   ; NO SPACE, CHECK AGAIN
00200394  13FC 000D 00C00007       720mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
0020039C                           721mm     ENDC
0020039C                           722mm     
0020039C                 FALSE     723mm     IFNE DEBUG
0020039C                           724mm     ENDC
0020039C                           725mm 
0020039C                           726mm     ENDM
0020039C                           727mm     PRINT_CHAR #LF,D3                           ; LF
0020039C                           728mm WAIT_FOR_READY_36                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020039C                 TRUE      729mm     IFEQ DEBUG
0020039C  1639 00C00003            730mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
002003A2  0803 0002                731mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
002003A6  67F4                     732mm         BEQ WAIT_FOR_READY_36                   ; NO SPACE, CHECK AGAIN
002003A8  13FC 000A 00C00007       733mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002003B0                           734mm     ENDC
002003B0                           735mm     
002003B0                 FALSE     736mm     IFNE DEBUG
002003B0                           737mm     ENDC
002003B0                           738mm 
002003B0                           739mm     ENDM
002003B0                           740m     ENDM
002003B0  6000 FDBE                741      BRA MAIN_LOOP
002003B4                           742  
002003B4                           743  ; register map for S
002003B4                           744  ; A0 - start address
002003B4                           745  ; A1 - offset
002003B4                           746  ; A2 - next address to write
002003B4                           747  ; A3 - next location (jmp)
002003B4                           748  ; A4 - Working Address Register
002003B4                           749  ; D0 - record count
002003B4                           750  ; D1 - 'S', record type, data byte
002003B4                           751  ; D2 - checksum
002003B4                           752  ; D3 - data byte count
002003B4                           753  ; D4 - read address, moved into A2
002003B4                           754  ; D5 - temp
002003B4                           755  ; D6 - temp
002003B4                           756  ; D7 - temp
002003B4                           757  S
002003B4  2078 0000                758      MOVE.L 0,A0                                     ; start address -> A0
002003B8  2247                     759      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
002003BA                           760      
002003BA  7000                     761      MOVE.L #0,D0                                    ; count of records read -> D0
002003BC                           762          
002003BC                           763  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
002003BC                           764m     DOWNLOAD D1                 
002003BC                           765m WAIT_FOR_READY_37                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003BC                           766m 
002003BC  1239 00C00003            767m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
002003C2  0801 0000                768m     BTST #0,D1                                  ; CHECK FOR CHARACTER
002003C6  6700 0010                769m     BEQ CONTINUE_37                             ; NOTHING, CONTINUE
002003CA                           770m  
002003CA                           771mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
002003CA                 TRUE      772mm     IFEQ DEBUG
002003CA  1239 00C00007            773mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
002003D0                           774mm     ENDC
002003D0                 FALSE     775mm     IFNE DEBUG
002003D0                           776mm     ENDC
002003D0                           777mm      
002003D0  B23C 001B                778mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
002003D4  6700 FC32                779mm     BEQ START
002003D8                           780mm     ENDM
002003D8                           781m CONTINUE_37
002003D8  1239 00C00013            782m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
002003DE  0801 0000                783m     BTST #0,D1                                      ; CHECK FOR CHARACTER
002003E2  67D8                     784m     BEQ WAIT_FOR_READY_37                           ; NOTHING, CHECK AGAIN
002003E4                           785m     
002003E4  1239 00C00017            786m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
002003EA  13C1 00E00001            787m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
002003F0                           788m     
002003F0                           789m     ENDM
002003F0  B23C 0053                790      CMP.B #'S',D1                                   ; found S?    
002003F4  66C6                     791      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
002003F6                           792      
002003F6                           793m     PRINT_CHAR #'S',D5                          ; print the S
002003F6                           794m WAIT_FOR_READY_39                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002003F6                 TRUE      795m     IFEQ DEBUG
002003F6  1A39 00C00003            796m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002003FC  0805 0002                797m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200400  67F4                     798m         BEQ WAIT_FOR_READY_39                   ; NO SPACE, CHECK AGAIN
00200402  13FC 0053 00C00007       799m         MOVE.B #'S',DUART_TXA                       ; SEND THE NEXT CHARACTER
0020040A                           800m     ENDC
0020040A                           801m     
0020040A                 FALSE     802m     IFNE DEBUG
0020040A                           803m     ENDC
0020040A                           804m 
0020040A                           805m     ENDM
0020040A  5280                     806      ADD.L #1,D0                                     ; read another S record, increment count
0020040C                           807      
0020040C                           808m     DOWNLOAD D1                                 ; read the record identifier and echo it back
0020040C                           809m WAIT_FOR_READY_40                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020040C                           810m 
0020040C  1239 00C00003            811m     MOVE.B DUART_SRA,D1                         ; CHECK FOR COMMAND
00200412  0801 0000                812m     BTST #0,D1                                  ; CHECK FOR CHARACTER
00200416  6700 0010                813m     BEQ CONTINUE_40                             ; NOTHING, CONTINUE
0020041A                           814m  
0020041A                           815mm     READ_CHAR D1                                ; WE're not going to do anything with it, just check for escape
0020041A                 TRUE      816mm     IFEQ DEBUG
0020041A  1239 00C00007            817mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00200420                           818mm     ENDC
00200420                 FALSE     819mm     IFNE DEBUG
00200420                           820mm     ENDC
00200420                           821mm      
00200420  B23C 001B                822mm     CMP.B #$1B,D1                               ; CHECK FOR ESCAPE AND GO TO START
00200424  6700 FBE2                823mm     BEQ START
00200428                           824mm     ENDM
00200428                           825m CONTINUE_40
00200428  1239 00C00013            826m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0020042E  0801 0000                827m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00200432  67D8                     828m     BEQ WAIT_FOR_READY_40                           ; NOTHING, CHECK AGAIN
00200434                           829m     
00200434  1239 00C00017            830m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0020043A  13C1 00E00001            831m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00200440                           832m     
00200440                           833m     ENDM
00200440                           834m     PRINT_CHAR D1,D5
00200440                           835m WAIT_FOR_READY_42                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200440                 TRUE      836m     IFEQ DEBUG
00200440  1A39 00C00003            837m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200446  0805 0002                838m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020044A  67F4                     839m         BEQ WAIT_FOR_READY_42                   ; NO SPACE, CHECK AGAIN
0020044C  13C1 00C00007            840m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200452                           841m     ENDC
00200452                           842m     
00200452                 FALSE     843m     IFNE DEBUG
00200452                           844m     ENDC
00200452                           845m 
00200452                           846m     ENDM
00200452                           847  
00200452  7400                     848      MOVE.L #0,D2                                    ; clear the checksum
00200454                           849  
00200454  7600                     850      MOVE.L #0,D3                                    ; read the 2 digit byte count -> D3
00200456                           851m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4                                        
00200456  1E3C 0002                852m     MOVE.B #2,D7
0020045A                           853m     WHILE.B D7 <GT> 0 DO
0020045A                           854ms _10000000
0020045A  BE38 0000                855ms     CMP.B   0,D7
0020045E  6F00 0064                856ms     BLE _10000001
00200462  E98B                     857m         LSL.L #4,D3                             ; IT's OK to do this first, because we are either starting from 0, 
00200464                           858mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200464                           859mm WAIT_FOR_READY_44                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200464                           860mm 
00200464  1A39 00C00003            861mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020046A  0805 0000                862mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020046E  6700 0010                863mm     BEQ CONTINUE_44                             ; NOTHING, CONTINUE
00200472                           864mm  
00200472                           865mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200472                 TRUE      866mmm     IFEQ DEBUG
00200472  1A39 00C00007            867mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200478                           868mmm     ENDC
00200478                 FALSE     869mmm     IFNE DEBUG
00200478                           870mmm     ENDC
00200478                           871mmm      
00200478  BA3C 001B                872mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020047C  6700 FB8A                873mmm     BEQ START
00200480                           874mmm     ENDM
00200480                           875mm CONTINUE_44
00200480  1A39 00C00013            876mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200486  0805 0000                877mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020048A  67D8                     878mm     BEQ WAIT_FOR_READY_44                           ; NOTHING, CHECK AGAIN
0020048C                           879mm     
0020048C  1A39 00C00017            880mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200492  13C5 00E00001            881mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200498                           882mm     
00200498                           883mm     ENDM
00200498                           884mm         PRINT_CHAR D5,D6
00200498                           885mm WAIT_FOR_READY_46                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200498                 TRUE      886mm     IFEQ DEBUG
00200498  1C39 00C00003            887mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020049E  0806 0002                888mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002004A2  67F4                     889mm         BEQ WAIT_FOR_READY_46                   ; NO SPACE, CHECK AGAIN
002004A4  13C5 00C00007            890mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002004AA                           891mm     ENDC
002004AA                           892mm     
002004AA                 FALSE     893mm     IFNE DEBUG
002004AA                           894mm     ENDC
002004AA                           895mm 
002004AA                           896mm     ENDM
002004AA                           897mm         HEX2BIN D5,D5,A4
002004AA  49F9 00200F27            898mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002004B0  0405 0030                899mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002004B4  CABC 000000FF            900mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002004BA  1A34 5000                901mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002004BE                           902mm     ENDM
002004BE  8605                     903m         OR.B D5,D3
002004C0  5307                     904m         SUB.B #1,D7
002004C2                           905m     ENDW
002004C2  6096                     906ms     BRA _10000000
002004C4                           907ms _10000001
002004C4                           908m     
002004C4  7A00                     909m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002004C6  1A03                     910m     MOVE.B D3,D5
002004C8  D483                     911m     ADD.L D3,D2
002004CA                           912m 
002004CA                           913m     ENDM
002004CA                           914  
002004CA                           915      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
002004CA  B23C 0030                916s     CMP.B   #'0',D1
002004CE  6600 0032                917s     BNE.L   _00000002
002004D2                           918m         PRINT_CRLF D5
002004D2                           919mm     PRINT_CHAR #CR,D5                           ; CR
002004D2                           920mm WAIT_FOR_READY_49                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004D2                 TRUE      921mm     IFEQ DEBUG
002004D2  1A39 00C00003            922mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002004D8  0805 0002                923mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002004DC  67F4                     924mm         BEQ WAIT_FOR_READY_49                   ; NO SPACE, CHECK AGAIN
002004DE  13FC 000D 00C00007       925mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
002004E6                           926mm     ENDC
002004E6                           927mm     
002004E6                 FALSE     928mm     IFNE DEBUG
002004E6                           929mm     ENDC
002004E6                           930mm 
002004E6                           931mm     ENDM
002004E6                           932mm     PRINT_CHAR #LF,D5                           ; LF
002004E6                           933mm WAIT_FOR_READY_50                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002004E6                 TRUE      934mm     IFEQ DEBUG
002004E6  1A39 00C00003            935mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002004EC  0805 0002                936mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002004F0  67F4                     937mm         BEQ WAIT_FOR_READY_50                   ; NO SPACE, CHECK AGAIN
002004F2  13FC 000A 00C00007       938mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002004FA                           939mm     ENDC
002004FA                           940mm     
002004FA                 FALSE     941mm     IFNE DEBUG
002004FA                           942mm     ENDC
002004FA                           943mm 
002004FA                           944mm     ENDM
002004FA                           945m     ENDM
002004FA  6000 FEC0                946          BRA WAIT_FOR_SRECORD
002004FE                           947      ELSE
002004FE  6000 040A                948s     BRA _00000003
00200502                           949s _00000002
00200502                           950          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L ; 16 or 24 bit address data record
00200502  B23C 0031                951s     CMP.B   #'1',D1
00200506  6708                     952s     BEQ.S   _00000004
00200508  B23C 0032                953s     CMP.B   #'2',D1
0020050C  6600 0202                954s     BNE.L   _00000005
00200510                           955s _00000004
00200510  5783                     956              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00200512                           957      
00200512  7800                     958              MOVE.L #0,D4                            ; read two bytes of address
00200514                           959m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; first byte                           
00200514  1E3C 0002                960m     MOVE.B #2,D7
00200518                           961m     WHILE.B D7 <GT> 0 DO
00200518                           962ms _10000002
00200518  BE38 0000                963ms     CMP.B   0,D7
0020051C  6F00 0064                964ms     BLE _10000003
00200520  E98C                     965m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200522                           966mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200522                           967mm WAIT_FOR_READY_52                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200522                           968mm 
00200522  1A39 00C00003            969mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200528  0805 0000                970mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020052C  6700 0010                971mm     BEQ CONTINUE_52                             ; NOTHING, CONTINUE
00200530                           972mm  
00200530                           973mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200530                 TRUE      974mmm     IFEQ DEBUG
00200530  1A39 00C00007            975mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200536                           976mmm     ENDC
00200536                 FALSE     977mmm     IFNE DEBUG
00200536                           978mmm     ENDC
00200536                           979mmm      
00200536  BA3C 001B                980mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020053A  6700 FACC                981mmm     BEQ START
0020053E                           982mmm     ENDM
0020053E                           983mm CONTINUE_52
0020053E  1A39 00C00013            984mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200544  0805 0000                985mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200548  67D8                     986mm     BEQ WAIT_FOR_READY_52                           ; NOTHING, CHECK AGAIN
0020054A                           987mm     
0020054A  1A39 00C00017            988mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200550  13C5 00E00001            989mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200556                           990mm     
00200556                           991mm     ENDM
00200556                           992mm         PRINT_CHAR D5,D6
00200556                           993mm WAIT_FOR_READY_54                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200556                 TRUE      994mm     IFEQ DEBUG
00200556  1C39 00C00003            995mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020055C  0806 0002                996mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200560  67F4                     997mm         BEQ WAIT_FOR_READY_54                   ; NO SPACE, CHECK AGAIN
00200562  13C5 00C00007            998mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200568                           999mm     ENDC
00200568                          1000mm     
00200568                 FALSE    1001mm     IFNE DEBUG
00200568                          1002mm     ENDC
00200568                          1003mm 
00200568                          1004mm     ENDM
00200568                          1005mm         HEX2BIN D5,D5,A4
00200568  49F9 00200F27           1006mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020056E  0405 0030               1007mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200572  CABC 000000FF           1008mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200578  1A34 5000               1009mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0020057C                          1010mm     ENDM
0020057C  8805                    1011m         OR.B D5,D4
0020057E  5307                    1012m         SUB.B #1,D7
00200580                          1013m     ENDW
00200580  6096                    1014ms     BRA _10000002
00200582                          1015ms _10000003
00200582                          1016m     
00200582  7A00                    1017m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200584  1A04                    1018m     MOVE.B D4,D5
00200586  D484                    1019m     ADD.L D4,D2
00200588                          1020m 
00200588                          1021m     ENDM
00200588                          1022m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; second one
00200588  1E3C 0002               1023m     MOVE.B #2,D7
0020058C                          1024m     WHILE.B D7 <GT> 0 DO
0020058C                          1025ms _10000004
0020058C  BE38 0000               1026ms     CMP.B   0,D7
00200590  6F00 0064               1027ms     BLE _10000005
00200594  E98C                    1028m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200596                          1029mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200596                          1030mm WAIT_FOR_READY_57                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200596                          1031mm 
00200596  1A39 00C00003           1032mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020059C  0805 0000               1033mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002005A0  6700 0010               1034mm     BEQ CONTINUE_57                             ; NOTHING, CONTINUE
002005A4                          1035mm  
002005A4                          1036mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002005A4                 TRUE     1037mmm     IFEQ DEBUG
002005A4  1A39 00C00007           1038mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002005AA                          1039mmm     ENDC
002005AA                 FALSE    1040mmm     IFNE DEBUG
002005AA                          1041mmm     ENDC
002005AA                          1042mmm      
002005AA  BA3C 001B               1043mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002005AE  6700 FA58               1044mmm     BEQ START
002005B2                          1045mmm     ENDM
002005B2                          1046mm CONTINUE_57
002005B2  1A39 00C00013           1047mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002005B8  0805 0000               1048mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002005BC  67D8                    1049mm     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
002005BE                          1050mm     
002005BE  1A39 00C00017           1051mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002005C4  13C5 00E00001           1052mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002005CA                          1053mm     
002005CA                          1054mm     ENDM
002005CA                          1055mm         PRINT_CHAR D5,D6
002005CA                          1056mm WAIT_FOR_READY_59                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002005CA                 TRUE     1057mm     IFEQ DEBUG
002005CA  1C39 00C00003           1058mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002005D0  0806 0002               1059mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002005D4  67F4                    1060mm         BEQ WAIT_FOR_READY_59                   ; NO SPACE, CHECK AGAIN
002005D6  13C5 00C00007           1061mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002005DC                          1062mm     ENDC
002005DC                          1063mm     
002005DC                 FALSE    1064mm     IFNE DEBUG
002005DC                          1065mm     ENDC
002005DC                          1066mm 
002005DC                          1067mm     ENDM
002005DC                          1068mm         HEX2BIN D5,D5,A4
002005DC  49F9 00200F27           1069mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002005E2  0405 0030               1070mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002005E6  CABC 000000FF           1071mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002005EC  1A34 5000               1072mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002005F0                          1073mm     ENDM
002005F0  8805                    1074m         OR.B D5,D4
002005F2  5307                    1075m         SUB.B #1,D7
002005F4                          1076m     ENDW
002005F4  6096                    1077ms     BRA _10000004
002005F6                          1078ms _10000005
002005F6                          1079m     
002005F6  7A00                    1080m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002005F8  1A04                    1081m     MOVE.B D4,D5
002005FA  D484                    1082m     ADD.L D4,D2
002005FC                          1083m 
002005FC                          1084m     ENDM
002005FC                          1085              
002005FC                          1086              IF.B D1 <EQ> #'2'  THEN.L           ; 24 bit address data record, read another byte
002005FC  B23C 0032               1087s     CMP.B   #'2',D1
00200600  6600 0078               1088s     BNE.L   _00000006
00200604  5383                    1089                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00200606                          1090m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; 3rd byte       
00200606  1E3C 0002               1091m     MOVE.B #2,D7
0020060A                          1092m     WHILE.B D7 <GT> 0 DO
0020060A                          1093ms _10000006
0020060A  BE38 0000               1094ms     CMP.B   0,D7
0020060E  6F00 0064               1095ms     BLE _10000007
00200612  E98C                    1096m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200614                          1097mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200614                          1098mm WAIT_FOR_READY_62                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200614                          1099mm 
00200614  1A39 00C00003           1100mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020061A  0805 0000               1101mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020061E  6700 0010               1102mm     BEQ CONTINUE_62                             ; NOTHING, CONTINUE
00200622                          1103mm  
00200622                          1104mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200622                 TRUE     1105mmm     IFEQ DEBUG
00200622  1A39 00C00007           1106mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200628                          1107mmm     ENDC
00200628                 FALSE    1108mmm     IFNE DEBUG
00200628                          1109mmm     ENDC
00200628                          1110mmm      
00200628  BA3C 001B               1111mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
0020062C  6700 F9DA               1112mmm     BEQ START
00200630                          1113mmm     ENDM
00200630                          1114mm CONTINUE_62
00200630  1A39 00C00013           1115mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200636  0805 0000               1116mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020063A  67D8                    1117mm     BEQ WAIT_FOR_READY_62                           ; NOTHING, CHECK AGAIN
0020063C                          1118mm     
0020063C  1A39 00C00017           1119mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200642  13C5 00E00001           1120mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200648                          1121mm     
00200648                          1122mm     ENDM
00200648                          1123mm         PRINT_CHAR D5,D6
00200648                          1124mm WAIT_FOR_READY_64                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200648                 TRUE     1125mm     IFEQ DEBUG
00200648  1C39 00C00003           1126mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020064E  0806 0002               1127mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200652  67F4                    1128mm         BEQ WAIT_FOR_READY_64                   ; NO SPACE, CHECK AGAIN
00200654  13C5 00C00007           1129mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020065A                          1130mm     ENDC
0020065A                          1131mm     
0020065A                 FALSE    1132mm     IFNE DEBUG
0020065A                          1133mm     ENDC
0020065A                          1134mm 
0020065A                          1135mm     ENDM
0020065A                          1136mm         HEX2BIN D5,D5,A4
0020065A  49F9 00200F27           1137mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200660  0405 0030               1138mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200664  CABC 000000FF           1139mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0020066A  1A34 5000               1140mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0020066E                          1141mm     ENDM
0020066E  8805                    1142m         OR.B D5,D4
00200670  5307                    1143m         SUB.B #1,D7
00200672                          1144m     ENDW
00200672  6096                    1145ms     BRA _10000006
00200674                          1146ms _10000007
00200674                          1147m     
00200674  7A00                    1148m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200676  1A04                    1149m     MOVE.B D4,D5
00200678  D484                    1150m     ADD.L D4,D2
0020067A                          1151m 
0020067A                          1152m     ENDM
0020067A                          1153              ENDI
0020067A                          1154s _00000006
0020067A                          1155              
0020067A  2444                    1156                  MOVE.L D4,A2                            ; put the address in an address register
0020067C  D5C9                    1157              ADD.L A1,A2                             ; add in the offset
0020067E                          1158  
0020067E                          1159              WHILE.L D3 <GT> #0 DO                   ; read the data bytes                
0020067E                          1160s _10000008
0020067E  B6BC 00000000           1161s     CMP.L   #0,D3
00200684  6F00 0080               1162s     BLE _10000009
00200688  7200                    1163                  MOVE.L #0,D1                        ; D1 holds the byte
0020068A                          1164m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4 ; read it                               
0020068A  1E3C 0002               1165m     MOVE.B #2,D7
0020068E                          1166m     WHILE.B D7 <GT> 0 DO
0020068E                          1167ms _1000000A
0020068E  BE38 0000               1168ms     CMP.B   0,D7
00200692  6F00 0064               1169ms     BLE _1000000B
00200696  E989                    1170m         LSL.L #4,D1                             ; IT's OK to do this first, because we are either starting from 0, 
00200698                          1171mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200698                          1172mm WAIT_FOR_READY_67                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200698                          1173mm 
00200698  1A39 00C00003           1174mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020069E  0805 0000               1175mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002006A2  6700 0010               1176mm     BEQ CONTINUE_67                             ; NOTHING, CONTINUE
002006A6                          1177mm  
002006A6                          1178mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002006A6                 TRUE     1179mmm     IFEQ DEBUG
002006A6  1A39 00C00007           1180mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002006AC                          1181mmm     ENDC
002006AC                 FALSE    1182mmm     IFNE DEBUG
002006AC                          1183mmm     ENDC
002006AC                          1184mmm      
002006AC  BA3C 001B               1185mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002006B0  6700 F956               1186mmm     BEQ START
002006B4                          1187mmm     ENDM
002006B4                          1188mm CONTINUE_67
002006B4  1A39 00C00013           1189mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002006BA  0805 0000               1190mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002006BE  67D8                    1191mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
002006C0                          1192mm     
002006C0  1A39 00C00017           1193mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002006C6  13C5 00E00001           1194mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002006CC                          1195mm     
002006CC                          1196mm     ENDM
002006CC                          1197mm         PRINT_CHAR D5,D6
002006CC                          1198mm WAIT_FOR_READY_69                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002006CC                 TRUE     1199mm     IFEQ DEBUG
002006CC  1C39 00C00003           1200mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002006D2  0806 0002               1201mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002006D6  67F4                    1202mm         BEQ WAIT_FOR_READY_69                   ; NO SPACE, CHECK AGAIN
002006D8  13C5 00C00007           1203mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002006DE                          1204mm     ENDC
002006DE                          1205mm     
002006DE                 FALSE    1206mm     IFNE DEBUG
002006DE                          1207mm     ENDC
002006DE                          1208mm 
002006DE                          1209mm     ENDM
002006DE                          1210mm         HEX2BIN D5,D5,A4
002006DE  49F9 00200F27           1211mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002006E4  0405 0030               1212mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002006E8  CABC 000000FF           1213mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002006EE  1A34 5000               1214mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002006F2                          1215mm     ENDM
002006F2  8205                    1216m         OR.B D5,D1
002006F4  5307                    1217m         SUB.B #1,D7
002006F6                          1218m     ENDW
002006F6  6096                    1219ms     BRA _1000000A
002006F8                          1220ms _1000000B
002006F8                          1221m     
002006F8  7A00                    1222m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002006FA  1A01                    1223m     MOVE.B D1,D5
002006FC  D481                    1224m     ADD.L D1,D2
002006FE                          1225m 
002006FE                          1226m     ENDM
002006FE                          1227                          
002006FE  14C1                    1228                  MOVE.B D1,(A2)+                     ; store it!
00200700                          1229  
00200700  5383                    1230                  SUB.L #1,D3                     ; 1 less byte to go
00200702                          1231              ENDW
00200702  6000 FF7A               1232s     BRA _10000008
00200706                          1233s _10000009
00200706                          1234          
00200706  47F9 002003BC           1235              LEA WAIT_FOR_SRECORD,A3                 ; next place to go
0020070C                          1236          ELSE
0020070C  6000 01FC               1237s     BRA _00000007
00200710                          1238s _00000005
00200710                          1239              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00200710  B23C 0038               1240s     CMP.B   #'8',D1
00200714  6600 016C               1241s     BNE.L   _00000008
00200718  7800                    1242                  MOVE.L #0,D4                    ; read the 24 bit start address
0020071A                          1243m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; top byte  
0020071A  1E3C 0002               1244m     MOVE.B #2,D7
0020071E                          1245m     WHILE.B D7 <GT> 0 DO
0020071E                          1246ms _1000000C
0020071E  BE38 0000               1247ms     CMP.B   0,D7
00200722  6F00 0064               1248ms     BLE _1000000D
00200726  E98C                    1249m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200728                          1250mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200728                          1251mm WAIT_FOR_READY_72                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200728                          1252mm 
00200728  1A39 00C00003           1253mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
0020072E  0805 0000               1254mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200732  6700 0010               1255mm     BEQ CONTINUE_72                             ; NOTHING, CONTINUE
00200736                          1256mm  
00200736                          1257mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200736                 TRUE     1258mmm     IFEQ DEBUG
00200736  1A39 00C00007           1259mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020073C                          1260mmm     ENDC
0020073C                 FALSE    1261mmm     IFNE DEBUG
0020073C                          1262mmm     ENDC
0020073C                          1263mmm      
0020073C  BA3C 001B               1264mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200740  6700 F8C6               1265mmm     BEQ START
00200744                          1266mmm     ENDM
00200744                          1267mm CONTINUE_72
00200744  1A39 00C00013           1268mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020074A  0805 0000               1269mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0020074E  67D8                    1270mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
00200750                          1271mm     
00200750  1A39 00C00017           1272mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200756  13C5 00E00001           1273mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020075C                          1274mm     
0020075C                          1275mm     ENDM
0020075C                          1276mm         PRINT_CHAR D5,D6
0020075C                          1277mm WAIT_FOR_READY_74                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020075C                 TRUE     1278mm     IFEQ DEBUG
0020075C  1C39 00C00003           1279mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200762  0806 0002               1280mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200766  67F4                    1281mm         BEQ WAIT_FOR_READY_74                   ; NO SPACE, CHECK AGAIN
00200768  13C5 00C00007           1282mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
0020076E                          1283mm     ENDC
0020076E                          1284mm     
0020076E                 FALSE    1285mm     IFNE DEBUG
0020076E                          1286mm     ENDC
0020076E                          1287mm 
0020076E                          1288mm     ENDM
0020076E                          1289mm         HEX2BIN D5,D5,A4
0020076E  49F9 00200F27           1290mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200774  0405 0030               1291mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200778  CABC 000000FF           1292mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0020077E  1A34 5000               1293mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200782                          1294mm     ENDM
00200782  8805                    1295m         OR.B D5,D4
00200784  5307                    1296m         SUB.B #1,D7
00200786                          1297m     ENDW
00200786  6096                    1298ms     BRA _1000000C
00200788                          1299ms _1000000D
00200788                          1300m     
00200788  7A00                    1301m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020078A  1A04                    1302m     MOVE.B D4,D5
0020078C  D484                    1303m     ADD.L D4,D2
0020078E                          1304m 
0020078E                          1305m     ENDM
0020078E                          1306m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; middle byte     
0020078E  1E3C 0002               1307m     MOVE.B #2,D7
00200792                          1308m     WHILE.B D7 <GT> 0 DO
00200792                          1309ms _1000000E
00200792  BE38 0000               1310ms     CMP.B   0,D7
00200796  6F00 0064               1311ms     BLE _1000000F
0020079A  E98C                    1312m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020079C                          1313mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020079C                          1314mm WAIT_FOR_READY_77                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020079C                          1315mm 
0020079C  1A39 00C00003           1316mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
002007A2  0805 0000               1317mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
002007A6  6700 0010               1318mm     BEQ CONTINUE_77                             ; NOTHING, CONTINUE
002007AA                          1319mm  
002007AA                          1320mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
002007AA                 TRUE     1321mmm     IFEQ DEBUG
002007AA  1A39 00C00007           1322mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
002007B0                          1323mmm     ENDC
002007B0                 FALSE    1324mmm     IFNE DEBUG
002007B0                          1325mmm     ENDC
002007B0                          1326mmm      
002007B0  BA3C 001B               1327mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
002007B4  6700 F852               1328mmm     BEQ START
002007B8                          1329mmm     ENDM
002007B8                          1330mm CONTINUE_77
002007B8  1A39 00C00013           1331mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
002007BE  0805 0000               1332mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
002007C2  67D8                    1333mm     BEQ WAIT_FOR_READY_77                           ; NOTHING, CHECK AGAIN
002007C4                          1334mm     
002007C4  1A39 00C00017           1335mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
002007CA  13C5 00E00001           1336mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
002007D0                          1337mm     
002007D0                          1338mm     ENDM
002007D0                          1339mm         PRINT_CHAR D5,D6
002007D0                          1340mm WAIT_FOR_READY_79                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002007D0                 TRUE     1341mm     IFEQ DEBUG
002007D0  1C39 00C00003           1342mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
002007D6  0806 0002               1343mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
002007DA  67F4                    1344mm         BEQ WAIT_FOR_READY_79                   ; NO SPACE, CHECK AGAIN
002007DC  13C5 00C00007           1345mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
002007E2                          1346mm     ENDC
002007E2                          1347mm     
002007E2                 FALSE    1348mm     IFNE DEBUG
002007E2                          1349mm     ENDC
002007E2                          1350mm 
002007E2                          1351mm     ENDM
002007E2                          1352mm         HEX2BIN D5,D5,A4
002007E2  49F9 00200F27           1353mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
002007E8  0405 0030               1354mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
002007EC  CABC 000000FF           1355mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
002007F2  1A34 5000               1356mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
002007F6                          1357mm     ENDM
002007F6  8805                    1358m         OR.B D5,D4
002007F8  5307                    1359m         SUB.B #1,D7
002007FA                          1360m     ENDW
002007FA  6096                    1361ms     BRA _1000000E
002007FC                          1362ms _1000000F
002007FC                          1363m     
002007FC  7A00                    1364m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
002007FE  1A04                    1365m     MOVE.B D4,D5
00200800  D484                    1366m     ADD.L D4,D2
00200802                          1367m 
00200802                          1368m     ENDM
00200802                          1369m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4 ; bottom byte
00200802  1E3C 0002               1370m     MOVE.B #2,D7
00200806                          1371m     WHILE.B D7 <GT> 0 DO
00200806                          1372ms _10000010
00200806  BE38 0000               1373ms     CMP.B   0,D7
0020080A  6F00 0064               1374ms     BLE _10000011
0020080E  E98C                    1375m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
00200810                          1376mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00200810                          1377mm WAIT_FOR_READY_82                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200810                          1378mm 
00200810  1A39 00C00003           1379mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200816  0805 0000               1380mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
0020081A  6700 0010               1381mm     BEQ CONTINUE_82                             ; NOTHING, CONTINUE
0020081E                          1382mm  
0020081E                          1383mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
0020081E                 TRUE     1384mmm     IFEQ DEBUG
0020081E  1A39 00C00007           1385mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00200824                          1386mmm     ENDC
00200824                 FALSE    1387mmm     IFNE DEBUG
00200824                          1388mmm     ENDC
00200824                          1389mmm      
00200824  BA3C 001B               1390mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200828  6700 F7DE               1391mmm     BEQ START
0020082C                          1392mmm     ENDM
0020082C                          1393mm CONTINUE_82
0020082C  1A39 00C00013           1394mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00200832  0805 0000               1395mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200836  67D8                    1396mm     BEQ WAIT_FOR_READY_82                           ; NOTHING, CHECK AGAIN
00200838                          1397mm     
00200838  1A39 00C00017           1398mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0020083E  13C5 00E00001           1399mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00200844                          1400mm     
00200844                          1401mm     ENDM
00200844                          1402mm         PRINT_CHAR D5,D6
00200844                          1403mm WAIT_FOR_READY_84                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200844                 TRUE     1404mm     IFEQ DEBUG
00200844  1C39 00C00003           1405mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
0020084A  0806 0002               1406mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
0020084E  67F4                    1407mm         BEQ WAIT_FOR_READY_84                   ; NO SPACE, CHECK AGAIN
00200850  13C5 00C00007           1408mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200856                          1409mm     ENDC
00200856                          1410mm     
00200856                 FALSE    1411mm     IFNE DEBUG
00200856                          1412mm     ENDC
00200856                          1413mm 
00200856                          1414mm     ENDM
00200856                          1415mm         HEX2BIN D5,D5,A4
00200856  49F9 00200F27           1416mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
0020085C  0405 0030               1417mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200860  CABC 000000FF           1418mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200866  1A34 5000               1419mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
0020086A                          1420mm     ENDM
0020086A  8805                    1421m         OR.B D5,D4
0020086C  5307                    1422m         SUB.B #1,D7
0020086E                          1423m     ENDW
0020086E  6096                    1424ms     BRA _10000010
00200870                          1425ms _10000011
00200870                          1426m     
00200870  7A00                    1427m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00200872  1A04                    1428m     MOVE.B D4,D5
00200874  D484                    1429m     ADD.L D4,D2
00200876                          1430m 
00200876                          1431m     ENDM
00200876                          1432                    
00200876  2044                    1433                  MOVE.L D4,A0                    ; start address -> A0
00200878                          1434                  
00200878  47F9 00200A54           1435                  LEA DOWNLOAD_DONE,A3            ; next place to go
0020087E                          1436              ELSE
0020087E  6000 008A               1437s     BRA _00000009
00200882                          1438s _00000008
00200882                          1439m                 PRINT_CRLF D5
00200882                          1440mm     PRINT_CHAR #CR,D5                           ; CR
00200882                          1441mm WAIT_FOR_READY_87                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200882                 TRUE     1442mm     IFEQ DEBUG
00200882  1A39 00C00003           1443mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200888  0805 0002               1444mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020088C  67F4                    1445mm         BEQ WAIT_FOR_READY_87                   ; NO SPACE, CHECK AGAIN
0020088E  13FC 000D 00C00007      1446mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200896                          1447mm     ENDC
00200896                          1448mm     
00200896                 FALSE    1449mm     IFNE DEBUG
00200896                          1450mm     ENDC
00200896                          1451mm 
00200896                          1452mm     ENDM
00200896                          1453mm     PRINT_CHAR #LF,D5                           ; LF
00200896                          1454mm WAIT_FOR_READY_88                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200896                 TRUE     1455mm     IFEQ DEBUG
00200896  1A39 00C00003           1456mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020089C  0805 0002               1457mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008A0  67F4                    1458mm         BEQ WAIT_FOR_READY_88                   ; NO SPACE, CHECK AGAIN
002008A2  13FC 000A 00C00007      1459mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008AA                          1460mm     ENDC
002008AA                          1461mm     
002008AA                 FALSE    1462mm     IFNE DEBUG
002008AA                          1463mm     ENDC
002008AA                          1464mm 
002008AA                          1465mm     ENDM
002008AA                          1466m     ENDM
002008AA                          1467              
002008AA  49F9 00200EDC           1468                  LEA UNREC,A4                    ; warn for unrecognised type
002008B0                          1469m                 PRINT_STR A4,D5
002008B0                          1470m LOOP_89
002008B0  0C14 0000               1471m     CMP.B #NULL,(A4)                            ; 0 -> DONE
002008B4  6700 0016               1472m     BEQ EXIT_89
002008B8                          1473mm     PRINT_CHAR (A4)+,D5
002008B8                          1474mm WAIT_FOR_READY_90                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008B8                 TRUE     1475mm     IFEQ DEBUG
002008B8  1A39 00C00003           1476mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008BE  0805 0002               1477mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008C2  67F4                    1478mm         BEQ WAIT_FOR_READY_90                   ; NO SPACE, CHECK AGAIN
002008C4  13DC 00C00007           1479mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002008CA                          1480mm     ENDC
002008CA                          1481mm     
002008CA                 FALSE    1482mm     IFNE DEBUG
002008CA                          1483mm     ENDC
002008CA                          1484mm 
002008CA                          1485mm     ENDM
002008CA  60E4                    1486m     BRA LOOP_89
002008CC                          1487m EXIT_89
002008CC                          1488m     ENDM
002008CC                          1489m                 PRINT_CHAR D1,D5
002008CC                          1490m WAIT_FOR_READY_91                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008CC                 TRUE     1491m     IFEQ DEBUG
002008CC  1A39 00C00003           1492m         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008D2  0805 0002               1493m         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008D6  67F4                    1494m         BEQ WAIT_FOR_READY_91                   ; NO SPACE, CHECK AGAIN
002008D8  13C1 00C00007           1495m         MOVE.B D1,DUART_TXA                     ; SEND THE NEXT CHARACTER
002008DE                          1496m     ENDC
002008DE                          1497m     
002008DE                 FALSE    1498m     IFNE DEBUG
002008DE                          1499m     ENDC
002008DE                          1500m 
002008DE                          1501m     ENDM
002008DE                          1502m                 PRINT_CRLF D5
002008DE                          1503mm     PRINT_CHAR #CR,D5                           ; CR
002008DE                          1504mm WAIT_FOR_READY_93                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008DE                 TRUE     1505mm     IFEQ DEBUG
002008DE  1A39 00C00003           1506mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008E4  0805 0002               1507mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008E8  67F4                    1508mm         BEQ WAIT_FOR_READY_93                   ; NO SPACE, CHECK AGAIN
002008EA  13FC 000D 00C00007      1509mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
002008F2                          1510mm     ENDC
002008F2                          1511mm     
002008F2                 FALSE    1512mm     IFNE DEBUG
002008F2                          1513mm     ENDC
002008F2                          1514mm 
002008F2                          1515mm     ENDM
002008F2                          1516mm     PRINT_CHAR #LF,D5                           ; LF
002008F2                          1517mm WAIT_FOR_READY_94                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
002008F2                 TRUE     1518mm     IFEQ DEBUG
002008F2  1A39 00C00003           1519mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002008F8  0805 0002               1520mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002008FC  67F4                    1521mm         BEQ WAIT_FOR_READY_94                   ; NO SPACE, CHECK AGAIN
002008FE  13FC 000A 00C00007      1522mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200906                          1523mm     ENDC
00200906                          1524mm     
00200906                 FALSE    1525mm     IFNE DEBUG
00200906                          1526mm     ENDC
00200906                          1527mm 
00200906                          1528mm     ENDM
00200906                          1529m     ENDM
00200906                          1530              
00200906  6000 FAB4               1531                  BRA WAIT_FOR_SRECORD            ; ignore any other type    
0020090A                          1532              ENDI
0020090A                          1533s _00000009
0020090A                          1534          ENDI
0020090A                          1535s _00000007
0020090A                          1536      ENDI
0020090A                          1537s _00000003
0020090A                          1538      
0020090A  7800                    1539      MOVE.L #0,D4                                    ; read the checksum from the data stream add to our checksum: should make it FF
0020090C                          1540m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4                         
0020090C  1E3C 0002               1541m     MOVE.B #2,D7
00200910                          1542m     WHILE.B D7 <GT> 0 DO
00200910                          1543ms _10000012
00200910  BE38 0000               1544ms     CMP.B   0,D7
00200914  6F00 0064               1545ms     BLE _10000013
00200918  E98C                    1546m         LSL.L #4,D4                             ; IT's OK to do this first, because we are either starting from 0, 
0020091A                          1547mm         DOWNLOAD D5                             ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0020091A                          1548mm WAIT_FOR_READY_96                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020091A                          1549mm 
0020091A  1A39 00C00003           1550mm     MOVE.B DUART_SRA,D5                         ; CHECK FOR COMMAND
00200920  0805 0000               1551mm     BTST #0,D5                                  ; CHECK FOR CHARACTER
00200924  6700 0010               1552mm     BEQ CONTINUE_96                             ; NOTHING, CONTINUE
00200928                          1553mm  
00200928                          1554mmm     READ_CHAR D5                                ; WE're not going to do anything with it, just check for escape
00200928                 TRUE     1555mmm     IFEQ DEBUG
00200928  1A39 00C00007           1556mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0020092E                          1557mmm     ENDC
0020092E                 FALSE    1558mmm     IFNE DEBUG
0020092E                          1559mmm     ENDC
0020092E                          1560mmm      
0020092E  BA3C 001B               1561mmm     CMP.B #$1B,D5                               ; CHECK FOR ESCAPE AND GO TO START
00200932  6700 F6D4               1562mmm     BEQ START
00200936                          1563mmm     ENDM
00200936                          1564mm CONTINUE_96
00200936  1A39 00C00013           1565mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0020093C  0805 0000               1566mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00200940  67D8                    1567mm     BEQ WAIT_FOR_READY_96                           ; NOTHING, CHECK AGAIN
00200942                          1568mm     
00200942  1A39 00C00017           1569mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00200948  13C5 00E00001           1570mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0020094E                          1571mm     
0020094E                          1572mm     ENDM
0020094E                          1573mm         PRINT_CHAR D5,D6
0020094E                          1574mm WAIT_FOR_READY_98                               ; WAIT UNTIL THE THERE IS SPACE TO SEND
0020094E                 TRUE     1575mm     IFEQ DEBUG
0020094E  1C39 00C00003           1576mm         MOVE.B DUART_SRA,D6                     ; READ STATUS REGISTER
00200954  0806 0002               1577mm         BTST #2,D6                              ; CHECK FOR SPACE TO SEND
00200958  67F4                    1578mm         BEQ WAIT_FOR_READY_98                   ; NO SPACE, CHECK AGAIN
0020095A  13C5 00C00007           1579mm         MOVE.B D5,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200960                          1580mm     ENDC
00200960                          1581mm     
00200960                 FALSE    1582mm     IFNE DEBUG
00200960                          1583mm     ENDC
00200960                          1584mm 
00200960                          1585mm     ENDM
00200960                          1586mm         HEX2BIN D5,D5,A4
00200960  49F9 00200F27           1587mm     LEA HEX2BIN_LUT,A4                              ; LOAD THE LOOKUP TABLE
00200966  0405 0030               1588mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0020096A  CABC 000000FF           1589mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00200970  1A34 5000               1590mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT      
00200974                          1591mm     ENDM
00200974  8805                    1592m         OR.B D5,D4
00200976  5307                    1593m         SUB.B #1,D7
00200978                          1594m     ENDW
00200978  6096                    1595ms     BRA _10000012
0020097A                          1596ms _10000013
0020097A                          1597m     
0020097A  7A00                    1598m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0020097C  1A04                    1599m     MOVE.B D4,D5
0020097E  D484                    1600m     ADD.L D4,D2
00200980                          1601m 
00200980                          1602m     ENDM
00200980                          1603m     PRINT_CRLF D5
00200980                          1604mm     PRINT_CHAR #CR,D5                           ; CR
00200980                          1605mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200980                 TRUE     1606mm     IFEQ DEBUG
00200980  1A39 00C00003           1607mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200986  0805 0002               1608mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020098A  67F4                    1609mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0020098C  13FC 000D 00C00007      1610mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200994                          1611mm     ENDC
00200994                          1612mm     
00200994                 FALSE    1613mm     IFNE DEBUG
00200994                          1614mm     ENDC
00200994                          1615mm 
00200994                          1616mm     ENDM
00200994                          1617mm     PRINT_CHAR #LF,D5                           ; LF
00200994                          1618mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200994                 TRUE     1619mm     IFEQ DEBUG
00200994  1A39 00C00003           1620mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
0020099A  0805 0002               1621mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
0020099E  67F4                    1622mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
002009A0  13FC 000A 00C00007      1623mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
002009A8                          1624mm     ENDC
002009A8                          1625mm     
002009A8                 FALSE    1626mm     IFNE DEBUG
002009A8                          1627mm     ENDC
002009A8                          1628mm 
002009A8                          1629mm     ENDM
002009A8                          1630m     ENDM
002009A8                          1631          
002009A8                          1632      IF.B D2 <NE> #$FF THEN.L
002009A8  B43C 00FF               1633s     CMP.B   #$FF,D2
002009AC  6700 00A4               1634s     BEQ.L   _0000000A
002009B0  49F9 00200EF3           1635          LEA CS_FAILURE,A4                       ; warn for mismatched checksum
002009B6                          1636m         PRINT_STR A4,D5
002009B6                          1637m LOOP_103
002009B6  0C14 0000               1638m     CMP.B #NULL,(A4)                            ; 0 -> DONE
002009BA  6700 0016               1639m     BEQ EXIT_103
002009BE                          1640mm     PRINT_CHAR (A4)+,D5
002009BE                          1641mm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009BE                 TRUE     1642mm     IFEQ DEBUG
002009BE  1A39 00C00003           1643mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009C4  0805 0002               1644mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009C8  67F4                    1645mm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
002009CA  13DC 00C00007           1646mm         MOVE.B (A4)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
002009D0                          1647mm     ENDC
002009D0                          1648mm     
002009D0                 FALSE    1649mm     IFNE DEBUG
002009D0                          1650mm     ENDC
002009D0                          1651mm 
002009D0                          1652mm     ENDM
002009D0  60E4                    1653m     BRA LOOP_103
002009D2                          1654m EXIT_103
002009D2                          1655m     ENDM
002009D2                          1656m         PRINT_REG D0,D5,D2,D6,A4
002009D2                          1657mm     PRINT_CHAR #'0',D5                              ;0X HEADER
002009D2                          1658mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009D2                 TRUE     1659mm     IFEQ DEBUG
002009D2  1A39 00C00003           1660mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009D8  0805 0002               1661mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009DC  67F4                    1662mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
002009DE  13FC 0030 00C00007      1663mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
002009E6                          1664mm     ENDC
002009E6                          1665mm     
002009E6                 FALSE    1666mm     IFNE DEBUG
002009E6                          1667mm     ENDC
002009E6                          1668mm 
002009E6                          1669mm     ENDM
002009E6                          1670mm     PRINT_CHAR #'x',D5
002009E6                          1671mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
002009E6                 TRUE     1672mm     IFEQ DEBUG
002009E6  1A39 00C00003           1673mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
002009EC  0805 0002               1674mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
002009F0  67F4                    1675mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
002009F2  13FC 0078 00C00007      1676mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
002009FA                          1677mm     ENDC
002009FA                          1678mm     
002009FA                 FALSE    1679mm     IFNE DEBUG
002009FA                          1680mm     ENDC
002009FA                          1681mm 
002009FA                          1682mm     ENDM
002009FA  7C07                    1683m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
002009FC                          1684m LOOP_105
002009FC                          1685mm     BIN2HEX D0,D2,A4
002009FC  49F9 00200F17           1686mm     LEA BIN2HEX_LUT,A4                          ; LOAD THE LOOKUP TABLE
00200A02  E998                    1687mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200A04  1400                    1688mm     MOVE.B D0,D2
00200A06  0282 0000000F           1689mm     ANDI.L #$F,D2
00200A0C  1434 2000               1690mm     MOVE.B 0(A4,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200A10                          1691mm     ENDM
00200A10                          1692mm     PRINT_CHAR D2,D5
00200A10                          1693mm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A10                 TRUE     1694mm     IFEQ DEBUG
00200A10  1A39 00C00003           1695mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A16  0805 0002               1696mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A1A  67F4                    1697mm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00200A1C  13C2 00C00007           1698mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200A22                          1699mm     ENDC
00200A22                          1700mm     
00200A22                 FALSE    1701mm     IFNE DEBUG
00200A22                          1702mm     ENDC
00200A22                          1703mm 
00200A22                          1704mm     ENDM
00200A22  57CE FFD8               1705m     DBEQ D6,LOOP_105
00200A26                          1706m     ENDM
00200A26                          1707m         PRINT_CRLF D5
00200A26                          1708mm     PRINT_CHAR #CR,D5                           ; CR
00200A26                          1709mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A26                 TRUE     1710mm     IFEQ DEBUG
00200A26  1A39 00C00003           1711mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A2C  0805 0002               1712mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A30  67F4                    1713mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00200A32  13FC 000D 00C00007      1714mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A3A                          1715mm     ENDC
00200A3A                          1716mm     
00200A3A                 FALSE    1717mm     IFNE DEBUG
00200A3A                          1718mm     ENDC
00200A3A                          1719mm 
00200A3A                          1720mm     ENDM
00200A3A                          1721mm     PRINT_CHAR #LF,D5                           ; LF
00200A3A                          1722mm WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A3A                 TRUE     1723mm     IFEQ DEBUG
00200A3A  1A39 00C00003           1724mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A40  0805 0002               1725mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A44  67F4                    1726mm         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00200A46  13FC 000A 00C00007      1727mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200A4E                          1728mm     ENDC
00200A4E                          1729mm     
00200A4E                 FALSE    1730mm     IFNE DEBUG
00200A4E                          1731mm     ENDC
00200A4E                          1732mm 
00200A4E                          1733mm     ENDM
00200A4E                          1734m     ENDM
00200A4E  6000 F720               1735          BRA MAIN_LOOP
00200A52                          1736      ENDI
00200A52                          1737s _0000000A
00200A52                          1738      
00200A52  4ED3                    1739      JMP (A3)
00200A54                          1740  DOWNLOAD_DONE
00200A54                          1741m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00200A54                          1742mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200A54                          1743mm WAIT_FOR_READY_114                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A54                 TRUE     1744mm     IFEQ DEBUG
00200A54  1A39 00C00003           1745mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A5A  0805 0002               1746mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A5E  67F4                    1747mm         BEQ WAIT_FOR_READY_114                      ; NO SPACE, CHECK AGAIN
00200A60  13FC 0030 00C00007      1748mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A68                          1749mm     ENDC
00200A68                          1750mm     
00200A68                 FALSE    1751mm     IFNE DEBUG
00200A68                          1752mm     ENDC
00200A68                          1753mm 
00200A68                          1754mm     ENDM
00200A68                          1755mm     PRINT_CHAR #'x',D5
00200A68                          1756mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A68                 TRUE     1757mm     IFEQ DEBUG
00200A68  1A39 00C00003           1758mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A6E  0805 0002               1759mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A72  67F4                    1760mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00200A74  13FC 0078 00C00007      1761mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200A7C                          1762mm     ENDC
00200A7C                          1763mm     
00200A7C                 FALSE    1764mm     IFNE DEBUG
00200A7C                          1765mm     ENDC
00200A7C                          1766mm 
00200A7C                          1767mm     ENDM
00200A7C  7407                    1768m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200A7E                          1769m LOOP_113
00200A7E                          1770mm     BIN2HEX D0,D6,A1
00200A7E  43F9 00200F17           1771mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200A84  E998                    1772mm     ROL.L #4,D0                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200A86  1C00                    1773mm     MOVE.B D0,D6
00200A88  0286 0000000F           1774mm     ANDI.L #$F,D6
00200A8E  1C31 6000               1775mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200A92                          1776mm     ENDM
00200A92                          1777mm     PRINT_CHAR D6,D5
00200A92                          1778mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200A92                 TRUE     1779mm     IFEQ DEBUG
00200A92  1A39 00C00003           1780mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200A98  0805 0002               1781mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200A9C  67F4                    1782mm         BEQ WAIT_FOR_READY_117                      ; NO SPACE, CHECK AGAIN
00200A9E  13C6 00C00007           1783mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200AA4                          1784mm     ENDC
00200AA4                          1785mm     
00200AA4                 FALSE    1786mm     IFNE DEBUG
00200AA4                          1787mm     ENDC
00200AA4                          1788mm 
00200AA4                          1789mm     ENDM
00200AA4  57CA FFD8               1790m     DBEQ D2,LOOP_113
00200AA8                          1791m     ENDM
00200AA8  43F9 00200EBA           1792      LEA READ,A1
00200AAE                          1793m     PRINT_STR A1,D5
00200AAE                          1794m LOOP_118
00200AAE  0C11 0000               1795m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00200AB2  6700 0016               1796m     BEQ EXIT_118
00200AB6                          1797mm     PRINT_CHAR (A1)+,D5
00200AB6                          1798mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AB6                 TRUE     1799mm     IFEQ DEBUG
00200AB6  1A39 00C00003           1800mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200ABC  0805 0002               1801mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AC0  67F4                    1802mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00200AC2  13D9 00C00007           1803mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200AC8                          1804mm     ENDC
00200AC8                          1805mm     
00200AC8                 FALSE    1806mm     IFNE DEBUG
00200AC8                          1807mm     ENDC
00200AC8                          1808mm 
00200AC8                          1809mm     ENDM
00200AC8  60E4                    1810m     BRA LOOP_118
00200ACA                          1811m EXIT_118
00200ACA                          1812m     ENDM
00200ACA  2E08                    1813      MOVE.L A0,D7                                    ; set address accumulator to start address
00200ACC                          1814m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00200ACC                          1815mm     PRINT_CHAR #'0',D5                              ;0X HEADER
00200ACC                          1816mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200ACC                 TRUE     1817mm     IFEQ DEBUG
00200ACC  1A39 00C00003           1818mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AD2  0805 0002               1819mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AD6  67F4                    1820mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00200AD8  13FC 0030 00C00007      1821mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AE0                          1822mm     ENDC
00200AE0                          1823mm     
00200AE0                 FALSE    1824mm     IFNE DEBUG
00200AE0                          1825mm     ENDC
00200AE0                          1826mm 
00200AE0                          1827mm     ENDM
00200AE0                          1828mm     PRINT_CHAR #'x',D5
00200AE0                          1829mm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200AE0                 TRUE     1830mm     IFEQ DEBUG
00200AE0  1A39 00C00003           1831mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200AE6  0805 0002               1832mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200AEA  67F4                    1833mm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00200AEC  13FC 0078 00C00007      1834mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200AF4                          1835mm     ENDC
00200AF4                          1836mm     
00200AF4                 FALSE    1837mm     IFNE DEBUG
00200AF4                          1838mm     ENDC
00200AF4                          1839mm 
00200AF4                          1840mm     ENDM
00200AF4  7407                    1841m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200AF6                          1842m LOOP_120
00200AF6                          1843mm     BIN2HEX D7,D6,A1
00200AF6  43F9 00200F17           1844mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200AFC  E99F                    1845mm     ROL.L #4,D7                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200AFE  1C07                    1846mm     MOVE.B D7,D6
00200B00  0286 0000000F           1847mm     ANDI.L #$F,D6
00200B06  1C31 6000               1848mm     MOVE.B 0(A1,D6),D6                          ; USE THAT AS AN INDEX INTO THE LUT
00200B0A                          1849mm     ENDM
00200B0A                          1850mm     PRINT_CHAR D6,D5
00200B0A                          1851mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B0A                 TRUE     1852mm     IFEQ DEBUG
00200B0A  1A39 00C00003           1853mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B10  0805 0002               1854mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B14  67F4                    1855mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00200B16  13C6 00C00007           1856mm         MOVE.B D6,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200B1C                          1857mm     ENDC
00200B1C                          1858mm     
00200B1C                 FALSE    1859mm     IFNE DEBUG
00200B1C                          1860mm     ENDC
00200B1C                          1861mm 
00200B1C                          1862mm     ENDM
00200B1C  57CA FFD8               1863m     DBEQ D2,LOOP_120
00200B20                          1864m     ENDM
00200B20                          1865m     PRINT_CRLF D5     
00200B20                          1866mm     PRINT_CHAR #CR,D5                           ; CR
00200B20                          1867mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B20                 TRUE     1868mm     IFEQ DEBUG
00200B20  1A39 00C00003           1869mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B26  0805 0002               1870mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B2A  67F4                    1871mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00200B2C  13FC 000D 00C00007      1872mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B34                          1873mm     ENDC
00200B34                          1874mm     
00200B34                 FALSE    1875mm     IFNE DEBUG
00200B34                          1876mm     ENDC
00200B34                          1877mm 
00200B34                          1878mm     ENDM
00200B34                          1879mm     PRINT_CHAR #LF,D5                           ; LF
00200B34                          1880mm WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200B34                 TRUE     1881mm     IFEQ DEBUG
00200B34  1A39 00C00003           1882mm         MOVE.B DUART_SRA,D5                     ; READ STATUS REGISTER
00200B3A  0805 0002               1883mm         BTST #2,D5                              ; CHECK FOR SPACE TO SEND
00200B3E  67F4                    1884mm         BEQ WAIT_FOR_READY_127                      ; NO SPACE, CHECK AGAIN
00200B40  13FC 000A 00C00007      1885mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200B48                          1886mm     ENDC
00200B48                          1887mm     
00200B48                 FALSE    1888mm     IFNE DEBUG
00200B48                          1889mm     ENDC
00200B48                          1890mm 
00200B48                          1891mm     ENDM
00200B48                          1892m     ENDM
00200B48                          1893          
00200B48  6000 F626               1894      BRA MAIN_LOOP
00200B4C                          1895      
00200B4C                          1896  G
00200B4C  2047                    1897      MOVE.L D7,A0                                    ; address accumulator -> address register
00200B4E  3E3C 0000               1898      MOVE #0,D7                                      ; clear the now used address accumulator
00200B52  4ED0                    1899      JMP (A0)                                        ; jump to it!
00200B54                          1900      
00200B54                          1901  Z
00200B54  207C 00200000           1902      MOVE.L #RAM,A0                                  ; address of RAM
00200B5A  7000                    1903      MOVE.L #0,D0                                    ; number of bytes
00200B5C                          1904     
00200B5C                          1905      WHILE.L D0 <LE> #$40000 DO                      ; read the data bytes
00200B5C                          1906s _10000014
00200B5C  B0BC 00040000           1907s     CMP.L   #$40000,D0
00200B62  6E00 001A               1908s     BGT _10000015
00200B66  2200                    1909          MOVE.L D0,D1                                ; progress update
00200B68  E089                    1910          LSR.L #8,D1 
00200B6A  E089                    1911          LSR.L #8,D1
00200B6C  0281 0000000F           1912          ANDI.L #$F,D1
00200B72  13C1 00E00001           1913          MOVE.B D1,DISPLAY
00200B78                          1914  
00200B78  20C0                    1915          MOVE.L D0,(A0)+ 
00200B7A  5880                    1916          ADD.L #4,D0
00200B7C                          1917      ENDW
00200B7C  60DE                    1918s     BRA _10000014
00200B7E                          1919s _10000015
00200B7E                          1920   
00200B7E  207C 00200000           1921      MOVE.L #RAM,A0                                  ; address of RAM
00200B84  7000                    1922      MOVE.L #0,D0                                    ; number of bytes
00200B86                          1923     
00200B86                          1924      WHILE.L D0 <LE> #$40000 DO                  ; read the data bytes
00200B86                          1925s _10000016
00200B86  B0BC 00040000           1926s     CMP.L   #$40000,D0
00200B8C  6E00 00C8               1927s     BGT _10000017
00200B90  2200                    1928          MOVE.L D0,D1                            ; progress update
00200B92  E089                    1929          LSR.L #8,D1
00200B94  E089                    1930          LSR.L #8,D1
00200B96  0281 0000000F           1931          ANDI.L #$F,D1
00200B9C  13C1 00E00001           1932          MOVE.B D1,DISPLAY
00200BA2                          1933  
00200BA2  2218                    1934          MOVE.L (A0)+,D1
00200BA4                          1935            
00200BA4                          1936          IF.L D0 <EQ> D1 THEN
00200BA4  B081                    1937s     CMP.L   D1,D0
00200BA6  6600 0006               1938s     BNE _0000000B
00200BAA  6000 00A4               1939              BRA OK
00200BAE                          1940          ENDI 
00200BAE                          1941s _0000000B
00200BAE                          1942            
00200BAE  43F9 00200F05           1943          LEA RAM_ERROR,A1
00200BB4                          1944m         PRINT_STR A1,D1
00200BB4                          1945m LOOP_128
00200BB4  0C11 0000               1946m     CMP.B #NULL,(A1)                            ; 0 -> DONE
00200BB8  6700 0016               1947m     BEQ EXIT_128
00200BBC                          1948mm     PRINT_CHAR (A1)+,D1
00200BBC                          1949mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BBC                 TRUE     1950mm     IFEQ DEBUG
00200BBC  1239 00C00003           1951mm         MOVE.B DUART_SRA,D1                     ; READ STATUS REGISTER
00200BC2  0801 0002               1952mm         BTST #2,D1                              ; CHECK FOR SPACE TO SEND
00200BC6  67F4                    1953mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00200BC8  13D9 00C00007           1954mm         MOVE.B (A1)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200BCE                          1955mm     ENDC
00200BCE                          1956mm     
00200BCE                 FALSE    1957mm     IFNE DEBUG
00200BCE                          1958mm     ENDC
00200BCE                          1959mm 
00200BCE                          1960mm     ENDM
00200BCE  60E4                    1961m     BRA LOOP_128
00200BD0                          1962m EXIT_128
00200BD0                          1963m     ENDM
00200BD0  2208                    1964          MOVE.L A0,D1
00200BD2  5981                    1965          SUB.L #4,D1
00200BD4                          1966m         PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00200BD4                          1967mm     PRINT_CHAR #'0',D3                              ;0X HEADER
00200BD4                          1968mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BD4                 TRUE     1969mm     IFEQ DEBUG
00200BD4  1639 00C00003           1970mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BDA  0803 0002               1971mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BDE  67F4                    1972mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00200BE0  13FC 0030 00C00007      1973mm         MOVE.B #'0',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BE8                          1974mm     ENDC
00200BE8                          1975mm     
00200BE8                 FALSE    1976mm     IFNE DEBUG
00200BE8                          1977mm     ENDC
00200BE8                          1978mm 
00200BE8                          1979mm     ENDM
00200BE8                          1980mm     PRINT_CHAR #'x',D3
00200BE8                          1981mm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200BE8                 TRUE     1982mm     IFEQ DEBUG
00200BE8  1639 00C00003           1983mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200BEE  0803 0002               1984mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200BF2  67F4                    1985mm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00200BF4  13FC 0078 00C00007      1986mm         MOVE.B #'x',DUART_TXA                       ; SEND THE NEXT CHARACTER
00200BFC                          1987mm     ENDC
00200BFC                          1988mm     
00200BFC                 FALSE    1989mm     IFNE DEBUG
00200BFC                          1990mm     ENDC
00200BFC                          1991mm 
00200BFC                          1992mm     ENDM
00200BFC  7C07                    1993m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00200BFE                          1994m LOOP_130
00200BFE                          1995mm     BIN2HEX D1,D2,A1
00200BFE  43F9 00200F17           1996mm     LEA BIN2HEX_LUT,A1                          ; LOAD THE LOOKUP TABLE
00200C04  E999                    1997mm     ROL.L #4,D1                                 ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00200C06  1401                    1998mm     MOVE.B D1,D2
00200C08  0282 0000000F           1999mm     ANDI.L #$F,D2
00200C0E  1431 2000               2000mm     MOVE.B 0(A1,D2),D2                          ; USE THAT AS AN INDEX INTO THE LUT
00200C12                          2001mm     ENDM
00200C12                          2002mm     PRINT_CHAR D2,D3
00200C12                          2003mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C12                 TRUE     2004mm     IFEQ DEBUG
00200C12  1639 00C00003           2005mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C18  0803 0002               2006mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C1C  67F4                    2007mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00200C1E  13C2 00C00007           2008mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C24                          2009mm     ENDC
00200C24                          2010mm     
00200C24                 FALSE    2011mm     IFNE DEBUG
00200C24                          2012mm     ENDC
00200C24                          2013mm 
00200C24                          2014mm     ENDM
00200C24  57CE FFD8               2015m     DBEQ D6,LOOP_130
00200C28                          2016m     ENDM
00200C28                          2017m         PRINT_CRLF D3
00200C28                          2018mm     PRINT_CHAR #CR,D3                           ; CR
00200C28                          2019mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C28                 TRUE     2020mm     IFEQ DEBUG
00200C28  1639 00C00003           2021mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C2E  0803 0002               2022mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C32  67F4                    2023mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00200C34  13FC 000D 00C00007      2024mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C3C                          2025mm     ENDC
00200C3C                          2026mm     
00200C3C                 FALSE    2027mm     IFNE DEBUG
00200C3C                          2028mm     ENDC
00200C3C                          2029mm 
00200C3C                          2030mm     ENDM
00200C3C                          2031mm     PRINT_CHAR #LF,D3                           ; LF
00200C3C                          2032mm WAIT_FOR_READY_137                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C3C                 TRUE     2033mm     IFEQ DEBUG
00200C3C  1639 00C00003           2034mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C42  0803 0002               2035mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C46  67F4                    2036mm         BEQ WAIT_FOR_READY_137                      ; NO SPACE, CHECK AGAIN
00200C48  13FC 000A 00C00007      2037mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200C50                          2038mm     ENDC
00200C50                          2039mm     
00200C50                 FALSE    2040mm     IFNE DEBUG
00200C50                          2041mm     ENDC
00200C50                          2042mm 
00200C50                          2043mm     ENDM
00200C50                          2044m     ENDM
00200C50                          2045  OK    
00200C50  5880                    2046          ADD.L #4,D0
00200C52                          2047      ENDW
00200C52  6000 FF32               2048s     BRA _10000016
00200C56                          2049s _10000017
00200C56                          2050      
00200C56  6000 F518               2051      BRA MAIN_LOOP
00200C5A                          2052    
00200C5A                          2053  L
00200C5A  7A00                    2054      MOVE.L #0,D5                                    ; D5 will be the length  to write            
00200C5C                          2055  
00200C5C                          2056m     WAIT_CHAR D2,D3                             ; read most significant character -> D2
00200C5C                          2057m WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C5C                 TRUE     2058m     IFEQ DEBUG
00200C5C  1639 00C00003           2059m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200C62  0803 0000               2060m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200C66  67F4                    2061m         BEQ WAIT_FOR_READY_138                      ; NOTHING, CHECK AGAIN
00200C68                          2062m     ENDC
00200C68                          2063m     
00200C68                          2064mm     READ_CHAR D2
00200C68                 TRUE     2065mm     IFEQ DEBUG
00200C68  1439 00C00007           2066mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200C6E                          2067mm     ENDC
00200C6E                 FALSE    2068mm     IFNE DEBUG
00200C6E                          2069mm     ENDC
00200C6E                          2070mm      
00200C6E  B43C 001B               2071mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200C72  6700 F394               2072mm     BEQ START
00200C76                          2073mm     ENDM
00200C76                          2074m 
00200C76                 TRUE     2075m     IFEQ DEBUG
00200C76                          2076mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200C76                          2077mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200C76                 TRUE     2078mm     IFEQ DEBUG
00200C76  1639 00C00003           2079mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200C7C  0803 0002               2080mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200C80  67F4                    2081mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00200C82  13C2 00C00007           2082mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200C88                          2083mm     ENDC
00200C88                          2084mm     
00200C88                 FALSE    2085mm     IFNE DEBUG
00200C88                          2086mm     ENDC
00200C88                          2087mm 
00200C88                          2088mm     ENDM
00200C88                          2089m     ENDC
00200C88                          2090m     ENDM
00200C88                          2091m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200C88  41F9 00200F27           2092m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200C8E  0402 0030               2093m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200C92  C4BC 000000FF           2094m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200C98  1430 2000               2095m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200C9C                          2096m     ENDM
00200C9C  1A02                    2097      MOVE.B D2,D5                                    ; put at bottom of D5
00200C9E                          2098  
00200C9E  3C3C 0002               2099      MOVE #2,D6                                      ; 3 bytes left to read
00200CA2                          2100      
00200CA2                          2101  READ_LENGTH
00200CA2  E98D                    2102      LSL.L #4,D5                                     ; make what we have so far more significant
00200CA4                          2103m     WAIT_CHAR D2,D3                                 ; next character -> D2
00200CA4                          2104m WAIT_FOR_READY_142                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CA4                 TRUE     2105m     IFEQ DEBUG
00200CA4  1639 00C00003           2106m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00200CAA  0803 0000               2107m         BTST #0,D3                              ; CHECK FOR CHARACTER
00200CAE  67F4                    2108m         BEQ WAIT_FOR_READY_142                      ; NOTHING, CHECK AGAIN
00200CB0                          2109m     ENDC
00200CB0                          2110m     
00200CB0                          2111mm     READ_CHAR D2
00200CB0                 TRUE     2112mm     IFEQ DEBUG
00200CB0  1439 00C00007           2113mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00200CB6                          2114mm     ENDC
00200CB6                 FALSE    2115mm     IFNE DEBUG
00200CB6                          2116mm     ENDC
00200CB6                          2117mm      
00200CB6  B43C 001B               2118mm     CMP.B #$1B,D2                               ; CHECK FOR ESCAPE AND GO TO START
00200CBA  6700 F34C               2119mm     BEQ START
00200CBE                          2120mm     ENDM
00200CBE                          2121m 
00200CBE                 TRUE     2122m     IFEQ DEBUG
00200CBE                          2123mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00200CBE                          2124mm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CBE                 TRUE     2125mm     IFEQ DEBUG
00200CBE  1639 00C00003           2126mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CC4  0803 0002               2127mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CC8  67F4                    2128mm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00200CCA  13C2 00C00007           2129mm         MOVE.B D2,DUART_TXA                     ; SEND THE NEXT CHARACTER
00200CD0                          2130mm     ENDC
00200CD0                          2131mm     
00200CD0                 FALSE    2132mm     IFNE DEBUG
00200CD0                          2133mm     ENDC
00200CD0                          2134mm 
00200CD0                          2135mm     ENDM
00200CD0                          2136m     ENDC
00200CD0                          2137m     ENDM
00200CD0                          2138m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00200CD0  41F9 00200F27           2139m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200CD6  0402 0030               2140m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200CDA  C4BC 000000FF           2141m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200CE0  1430 2000               2142m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200CE4                          2143m     ENDM
00200CE4  8A02                    2144      OR.B D2,D5  
00200CE6  023C 00FB               2145      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200CEA  57CE FFB6               2146      DBEQ D6,READ_LENGTH
00200CEE                          2147          
00200CEE                          2148m     PRINT_CRLF D3
00200CEE                          2149mm     PRINT_CHAR #CR,D3                           ; CR
00200CEE                          2150mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200CEE                 TRUE     2151mm     IFEQ DEBUG
00200CEE  1639 00C00003           2152mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200CF4  0803 0002               2153mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200CF8  67F4                    2154mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00200CFA  13FC 000D 00C00007      2155mm         MOVE.B #CR,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D02                          2156mm     ENDC
00200D02                          2157mm     
00200D02                 FALSE    2158mm     IFNE DEBUG
00200D02                          2159mm     ENDC
00200D02                          2160mm 
00200D02                          2161mm     ENDM
00200D02                          2162mm     PRINT_CHAR #LF,D3                           ; LF
00200D02                          2163mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D02                 TRUE     2164mm     IFEQ DEBUG
00200D02  1639 00C00003           2165mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D08  0803 0002               2166mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D0C  67F4                    2167mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00200D0E  13FC 000A 00C00007      2168mm         MOVE.B #LF,DUART_TXA                    ; SEND THE NEXT CHARACTER
00200D16                          2169mm     ENDC
00200D16                          2170mm     
00200D16                 FALSE    2171mm     IFNE DEBUG
00200D16                          2172mm     ENDC
00200D16                          2173mm 
00200D16                          2174mm     ENDM
00200D16                          2175m     ENDM
00200D16                          2176  
00200D16  207C 00000000           2177      MOVE.L #ROM,A0                                  ; start of ROM
00200D1C                          2178      
00200D1C  2247                    2179      MOVE.L D7,A1                                    ; address accumulator -> address register
00200D1E  7E00                    2180      MOVE.L #0,D7                                    ; clear the now used address accumulator
00200D20                          2181      
00200D20  267C 00002AAA           2182      MOVE.L #$2AAA,A3
00200D26  36BC AAAA               2183      MOVE.W #$AAAA,(A3)
00200D2A  267C 00001554           2184      MOVE.L #$1554,A3
00200D30  36BC 5555               2185      MOVE.W #$5555,(A3)
00200D34  267C 00002AAA           2186      MOVE.L #$2AAA,A3
00200D3A  36BC 8080               2187      MOVE.W #$8080,(A3)
00200D3E  267C 00002AAA           2188      MOVE.L #$2AAA,A3
00200D44  36BC AAAA               2189      MOVE.W #$AAAA,(A3)
00200D48  267C 00001554           2190      MOVE.L #$1554,A3
00200D4E  36BC 5555               2191      MOVE.W #$5555,(A3)
00200D52  267C 00002AAA           2192      MOVE.L #$2AAA,A3
00200D58  36BC 2020               2193      MOVE.W #$2020,(A3)
00200D5C                          2194      
00200D5C  45F9 00200F3E           2195      LEA LOADING,A2                              ; important for timing
00200D62                          2196m     PRINT_STR A2,D3
00200D62                          2197m LOOP_149
00200D62  0C12 0000               2198m     CMP.B #NULL,(A2)                            ; 0 -> DONE
00200D66  6700 0016               2199m     BEQ EXIT_149
00200D6A                          2200mm     PRINT_CHAR (A2)+,D3
00200D6A                          2201mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00200D6A                 TRUE     2202mm     IFEQ DEBUG
00200D6A  1639 00C00003           2203mm         MOVE.B DUART_SRA,D3                     ; READ STATUS REGISTER
00200D70  0803 0002               2204mm         BTST #2,D3                              ; CHECK FOR SPACE TO SEND
00200D74  67F4                    2205mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00200D76  13DA 00C00007           2206mm         MOVE.B (A2)+,DUART_TXA                      ; SEND THE NEXT CHARACTER
00200D7C                          2207mm     ENDC
00200D7C                          2208mm     
00200D7C                 FALSE    2209mm     IFNE DEBUG
00200D7C                          2210mm     ENDC
00200D7C                          2211mm 
00200D7C                          2212mm     ENDM
00200D7C  60E4                    2213m     BRA LOOP_149
00200D7E                          2214m EXIT_149
00200D7E                          2215m     ENDM
00200D7E                          2216  
00200D7E  023C 00FB               2217      ANDI #$FB,CCR                                   ; clear the Z bit if set (from the OR above)
00200D82                          2218      
00200D82                          2219      WHILE D5 <GT> #0 DO
00200D82                          2220s _10000018
00200D82  BA7C 0000               2221s     CMP.W   #0,D5
00200D86  6F00 001C               2222s     BLE _10000019
00200D8A  5585                    2223          SUB.L #2,D5
00200D8C                          2224            
00200D8C  13D1 00E00001           2225          MOVE.B (A1),DISPLAY
00200D92  3091                    2226          MOVE.W (A1),(A0)                            ; write the data
00200D94                          2227        
00200D94                          2228  WAIT_FOR_COMPLETE
00200D94  3410                    2229          MOVE.W (A0),D2
00200D96                          2230  
00200D96                          2231          IF D2 <NE> (A1) THEN
00200D96  B451                    2232s     CMP.W   (A1),D2
00200D98  6700 0004               2233s     BEQ _0000000C
00200D9C  60F6                    2234              BRA WAIT_FOR_COMPLETE
00200D9E                          2235          ENDI
00200D9E                          2236s _0000000C
00200D9E                          2237        
00200D9E  5488                    2238          ADD.L #2,A0
00200DA0  5489                    2239          ADD.L #2,A1
00200DA2                          2240      ENDW  
00200DA2  60DE                    2241s     BRA _10000018
00200DA4                          2242s _10000019
00200DA4                          2243      
00200DA4  267C 00002AAA           2244      MOVE.L #$2AAA,A3
00200DAA  36BC AAAA               2245      MOVE.W #$AAAA,(A3)
00200DAE  267C 00001554           2246      MOVE.L #$1554,A3
00200DB4  36BC 5555               2247      MOVE.W #$5555,(A3)
00200DB8  267C 00002AAA           2248      MOVE.L #$2AAA,A3
00200DBE  36BC A0A0               2249      MOVE.W #$A0A0,(A3)
00200DC2                          2250              
00200DC2  6000 F3AC               2251      BRA MAIN_LOOP
00200DC6                          2252          
00200DC6                          2253  HEX_DIGIT
00200DC6  E98F                    2254      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00200DC8                          2255m     HEX2BIN D2,D2,A0
00200DC8  41F9 00200F27           2256m     LEA HEX2BIN_LUT,A0                              ; LOAD THE LOOKUP TABLE
00200DCE  0402 0030               2257m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00200DD2  C4BC 000000FF           2258m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00200DD8  1430 2000               2259m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT      
00200DDC                          2260m     ENDM
00200DDC  8E02                    2261      OR.B D2,D7  
00200DDE  6000 F3B8               2262      BRA GET_INPUT
00200DE2                          2263  
00200DE2  FFFF FFFF               2264      SIMHALT                                         ; halt simulator
00200DE6                          2265  
00200DE6                          2266  ; strings
00200DE6= 4D 44 46 2D 6D 6F ...   2267  VERSION DC.B 'MDF-mon V1.50 (10/04/2021)',CR,LF,NULL
00200E03= 3F 09 09 09 68 65 ...   2268  HELP    DC.B '?',TAB,TAB,TAB,'help',CR,LF
00200E0D= 5B 76 5D 09 09 09 ...   2269          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00200E1C= 78 78 78 78 78 78 ...   2270          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00200E34= 78 78 78 78 78 78 ...   2271          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00200E54= 5B 73 5D 09 09 09 ...   2272          DC.B '[s]',TAB,TAB,TAB,'download S records',CR,LF
00200E6E= 78 78 78 78 78 78 ...   2273          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00200E7F= 5B 7A 5D 09 09 09 ...   2274          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00200E91= 78 78 78 78 78 78 ...   2275          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF,NULL
00200EB3= 48 75 68 3F 0D 0A 00    2276  HUH     DC.B 'Huh?',CR,LF,NULL
00200EBA= 20 53 20 72 65 63 ...   2277  READ    DC.B ' S records read, start address = ',NULL
00200EDC= 57 3A 20 55 6E 6B ...   2278  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00200EF3= 57 3A 20 43 53 20 ...   2279  CS_FAILURE   DC.B 'W: CS failure at ',NULL
00200F05= 57 3A 20 52 41 4D ...   2280  RAM_ERROR DC.B 'W: RAM error at: ',NULL
00200F17= 30 31 32 33 34 35 ...   2281  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00200F27= 00 01 02 03 04 05 ...   2282  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00200F3E= 4C 6F 61 64 69 6E ...   2283  LOADING  DC.B 'Loading EEPROM...',CR,LF,NULL
00200F52                          2284      
00200F52                          2285      END    START                                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         200F17
CONTINUE_37         2003D8
CONTINUE_40         200428
CONTINUE_44         200480
CONTINUE_52         20053E
CONTINUE_57         2005B2
CONTINUE_62         200630
CONTINUE_67         2006B4
CONTINUE_72         200744
CONTINUE_77         2007B8
CONTINUE_82         20082C
CONTINUE_96         200936
CR                  D
CS_FAILURE          200EF3
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            994
DOWNLOAD_BYTE       C79
DOWNLOAD_DONE       200A54
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_103            2009D2
EXIT_118            200ACA
EXIT_128            200BD0
EXIT_149            200D7E
EXIT_18             200276
EXIT_20             2002A6
EXIT_5              20013E
EXIT_89             2008CC
G                   200B4C
GET_INPUT           200198
H                   20027A
HELP                200E03
HEX2BIN             134
HEX2BIN_LUT         200F27
HEX_DIGIT           200DC6
HUH                 200EB3
L                   200C5A
LF                  A
LOADING             200F3E
LOOP_103            2009B6
LOOP_105            2009FC
LOOP_113            200A7E
LOOP_118            200AAE
LOOP_120            200AF6
LOOP_128            200BB4
LOOP_130            200BFE
LOOP_149            200D62
LOOP_18             20025A
LOOP_20             20028A
LOOP_22             2002D8
LOOP_5              200122
LOOP_89             2008B0
MAIN_LOOP           200170
NULL                0
OK                  200C50
PRINTSTR            20028A
PRINT_CHAR          283
PRINT_CRLF          49D
PRINT_REG           587
PRINT_STR           4FF
R                   2002AA
RAM                 200000
RAM_ERROR           200F05
READ                200EBA
READ_CHAR           82E
READ_DATA_TO_POKE   200336
READ_LENGTH         200CA2
RESET               200004
ROM                 0
S                   2003B4
STACK               200000
START               200008
TAB                 9
UNREC               200EDC
V                   200284
VERSION             200DE6
W                   200330
WAIT_CHAR           67F
WAIT_FOR_COMPLETE   200D94
WAIT_FOR_READY_1    2000D8
WAIT_FOR_READY_10   200170
WAIT_FOR_READY_101  200980
WAIT_FOR_READY_102  200994
WAIT_FOR_READY_104  2009BE
WAIT_FOR_READY_106  2009D2
WAIT_FOR_READY_107  2009E6
WAIT_FOR_READY_109  200A10
WAIT_FOR_READY_11   200184
WAIT_FOR_READY_111  200A26
WAIT_FOR_READY_112  200A3A
WAIT_FOR_READY_114  200A54
WAIT_FOR_READY_115  200A68
WAIT_FOR_READY_117  200A92
WAIT_FOR_READY_119  200AB6
WAIT_FOR_READY_12   200198
WAIT_FOR_READY_121  200ACC
WAIT_FOR_READY_122  200AE0
WAIT_FOR_READY_124  200B0A
WAIT_FOR_READY_126  200B20
WAIT_FOR_READY_127  200B34
WAIT_FOR_READY_129  200BBC
WAIT_FOR_READY_131  200BD4
WAIT_FOR_READY_132  200BE8
WAIT_FOR_READY_134  200C12
WAIT_FOR_READY_136  200C28
WAIT_FOR_READY_137  200C3C
WAIT_FOR_READY_138  200C5C
WAIT_FOR_READY_14   2001B2
WAIT_FOR_READY_140  200C76
WAIT_FOR_READY_142  200CA4
WAIT_FOR_READY_144  200CBE
WAIT_FOR_READY_147  200CEE
WAIT_FOR_READY_148  200D02
WAIT_FOR_READY_150  200D6A
WAIT_FOR_READY_16   2001FC
WAIT_FOR_READY_17   200210
WAIT_FOR_READY_19   200262
WAIT_FOR_READY_21   200292
WAIT_FOR_READY_23   2002AE
WAIT_FOR_READY_24   2002C2
WAIT_FOR_READY_26   2002EC
WAIT_FOR_READY_28   200302
WAIT_FOR_READY_29   200316
WAIT_FOR_READY_3    2000F4
WAIT_FOR_READY_30   200338
WAIT_FOR_READY_32   200352
WAIT_FOR_READY_35   200388
WAIT_FOR_READY_36   20039C
WAIT_FOR_READY_37   2003BC
WAIT_FOR_READY_39   2003F6
WAIT_FOR_READY_4    200108
WAIT_FOR_READY_40   20040C
WAIT_FOR_READY_42   200440
WAIT_FOR_READY_44   200464
WAIT_FOR_READY_46   200498
WAIT_FOR_READY_49   2004D2
WAIT_FOR_READY_50   2004E6
WAIT_FOR_READY_52   200522
WAIT_FOR_READY_54   200556
WAIT_FOR_READY_57   200596
WAIT_FOR_READY_59   2005CA
WAIT_FOR_READY_6    20012A
WAIT_FOR_READY_62   200614
WAIT_FOR_READY_64   200648
WAIT_FOR_READY_67   200698
WAIT_FOR_READY_69   2006CC
WAIT_FOR_READY_72   200728
WAIT_FOR_READY_74   20075C
WAIT_FOR_READY_77   20079C
WAIT_FOR_READY_79   2007D0
WAIT_FOR_READY_8    20013E
WAIT_FOR_READY_82   200810
WAIT_FOR_READY_84   200844
WAIT_FOR_READY_87   200882
WAIT_FOR_READY_88   200896
WAIT_FOR_READY_9    200152
WAIT_FOR_READY_90   2008B8
WAIT_FOR_READY_91   2008CC
WAIT_FOR_READY_93   2008DE
WAIT_FOR_READY_94   2008F2
WAIT_FOR_READY_96   20091A
WAIT_FOR_READY_98   20094E
WAIT_FOR_SRECORD    2003BC
Z                   200B54
_00000000           2001D8
_00000001           2001EC
_00000002           200502
_00000003           20090A
_00000004           200510
_00000005           200710
_00000006           20067A
_00000007           20090A
_00000008           200882
_00000009           20090A
_0000000A           200A52
_0000000B           200BAE
_0000000C           200D9E
_10000000           20045A
_10000001           2004C4
_10000002           200518
_10000003           200582
_10000004           20058C
_10000005           2005F6
_10000006           20060A
_10000007           200674
_10000008           20067E
_10000009           200706
_1000000A           20068E
_1000000B           2006F8
_1000000C           20071E
_1000000D           200788
_1000000E           200792
_1000000F           2007FC
_10000010           200806
_10000011           200870
_10000012           200910
_10000013           20097A
_10000014           200B5C
_10000015           200B7E
_10000016           200B86
_10000017           200C56
_10000018           200D82
_10000019           200DA4
