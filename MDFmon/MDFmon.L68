00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 15/04/2021 19:28:42

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 00000000                 270  STACK   DC.L 0                                      ; STACK
00000004= 00000008                 271  RESET   DC.L START                                  ; RESET
00000008                           272  
00000008                           273  ; start of program  
00000008                           274  START
00000008  13FC 0000 00E00001       275      MOVE.B #0,DISPLAY
00000010                           276  
00000010                           277  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       278      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       279      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           280      
00000020                           281      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                282s     MOVE.W  #$50,D1
00000024  6000 000E                283s     BRA _20000001
00000028                           284s _20000000
00000028  13C1 00C00005            285          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     286          NOP
00000030                           287      ENDF
00000030  0441 0010                288s     SUB.W   #$10,D1
00000034                           289s _20000001
00000034  B27C 0010                290s     CMP.W   #$10,D1
00000038  6CEE                     291s     BGE _20000000
0000003A                           292  
0000003A                           293      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                294s     MOVE.W  #$50,D1
0000003E  6000 000E                295s     BRA _20000003
00000042                           296s _20000002
00000042  13C1 00C00015            297          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     298          NOP
0000004A                           299      ENDF
0000004A  0441 0010                300s     SUB.W   #$10,D1
0000004E                           301s _20000003
0000004E  B27C 0010                302s     CMP.W   #$10,D1
00000052  6CEE                     303s     BGE _20000002
00000054                           304      
00000054                           305  ;initialise UART
00000054  13FC 0000 00C00009       306      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       307      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       308      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           309  
0000006C                           310  ; channel A
0000006C  13FC 0013 00C00001       311      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       312      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       313      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       314      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           315  
0000008C                           316  ; channel B
0000008C  13FC 0013 00C00011       317      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       318      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       319      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       320      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           321  
000000AC                           322m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           323m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      324m     IFEQ DEBUG
000000AC  1239 00C00003            325m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                326m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     327m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       328m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           329m     ENDC
000000C0                           330m 
000000C0                 FALSE     331m     IFNE DEBUG
000000C0                           332m     ENDC
000000C0                           333m 
000000C0                           334m     ENDM
000000C0                           335m     PRINT_CHAR #0,D1
000000C0                           336m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      337m     IFEQ DEBUG
000000C0  1239 00C00003            338m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                339m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     340m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       341m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           342m     ENDC
000000D4                           343m 
000000D4                 FALSE     344m     IFNE DEBUG
000000D4                           345m     ENDC
000000D4                           346m 
000000D4                           347m     ENDM
000000D4                           348m     PRINT_CHAR #0,D1
000000D4                           349m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      350m     IFEQ DEBUG
000000D4  1239 00C00003            351m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                352m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     353m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       354m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           355m     ENDC
000000E8                           356m 
000000E8                 FALSE     357m     IFNE DEBUG
000000E8                           358m     ENDC
000000E8                           359m 
000000E8                           360m     ENDM
000000E8                           361  
000000E8  13FC 0001 00E00001       362      MOVE.B #1,DISPLAY
000000F0                           363  
000000F0                           364m     PRINT_CRLF D1,A0
000000F0  41FA 11EC                365m     LEA CRLF(PC),A0
000000F4                           366mm     PRINT_STR A0,D1
000000F4                           367mm LOOP_5
000000F4  0C10 0000                368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                369mm     BEQ EXIT_5
000000FC                           370mmm     PRINT_CHAR (A0)+,D1
000000FC                           371mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      372mmm     IFEQ DEBUG
000000FC  1239 00C00003            373mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                374mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     375mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           377mmm     ENDC
0000010E                           378mmm 
0000010E                 FALSE     379mmm     IFNE DEBUG
0000010E                           380mmm     ENDC
0000010E                           381mmm 
0000010E                           382mmm     ENDM
0000010E  60E4                     383mm     BRA LOOP_5
00000110                           384mm EXIT_5
00000110                           385mm     ENDM
00000110                           386m     ENDM
00000110  41FA 11F0                387      LEA VERSION(PC),A0
00000114                           388m     PRINT_STR A0,D3
00000114                           389m LOOP_7
00000114  0C10 0000                390m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                391m     BEQ EXIT_7
0000011C                           392mm     PRINT_CHAR (A0)+,D3
0000011C                           393mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      394mm     IFEQ DEBUG
0000011C  1639 00C00003            395mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                396mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     397mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            398mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           399mm     ENDC
0000012E                           400mm 
0000012E                 FALSE     401mm     IFNE DEBUG
0000012E                           402mm     ENDC
0000012E                           403mm 
0000012E                           404mm     ENDM
0000012E  60E4                     405m     BRA LOOP_7
00000130                           406m EXIT_7
00000130                           407m     ENDM
00000130                           408  
00000130  41FA 0FE2                409      LEA HELPPROMPT(PC),A0
00000134                           410m     PRINT_STR A0,D3
00000134                           411m LOOP_9
00000134  0C10 0000                412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                413m     BEQ EXIT_9
0000013C                           414mm     PRINT_CHAR (A0)+,D3
0000013C                           415mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      416mm     IFEQ DEBUG
0000013C  1639 00C00003            417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     419mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           421mm     ENDC
0000014E                           422mm 
0000014E                 FALSE     423mm     IFNE DEBUG
0000014E                           424mm     ENDC
0000014E                           425mm 
0000014E                           426mm     ENDM
0000014E  60E4                     427m     BRA LOOP_9
00000150                           428m EXIT_9
00000150                           429m     ENDM
00000150                           430  
00000150                           431m     PRINT_CRLF D3,A0
00000150  41FA 118C                432m     LEA CRLF(PC),A0
00000154                           433mm     PRINT_STR A0,D3
00000154                           434mm LOOP_12
00000154  0C10 0000                435mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                436mm     BEQ EXIT_12
0000015C                           437mmm     PRINT_CHAR (A0)+,D3
0000015C                           438mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      439mmm     IFEQ DEBUG
0000015C  1639 00C00003            440mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                441mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     442mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            443mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           444mmm     ENDC
0000016E                           445mmm 
0000016E                 FALSE     446mmm     IFNE DEBUG
0000016E                           447mmm     ENDC
0000016E                           448mmm 
0000016E                           449mmm     ENDM
0000016E  60E4                     450mm     BRA LOOP_12
00000170                           451mm EXIT_12
00000170                           452mm     ENDM
00000170                           453m     ENDM
00000170                           454  
00000170  7E00                     455      MOVE.L #0,D7                                    ; address accumulator
00000172                           456  
00000172  13FC 0002 00E00001       457      MOVE.B #2,DISPLAY
0000017A                           458  MAIN_LOOP
0000017A  41FA 1165                459      LEA PROMPT(PC),A0
0000017E                           460m     PRINT_STR A0,D3
0000017E                           461m LOOP_14
0000017E  0C10 0000                462m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                463m     BEQ EXIT_14
00000186                           464mm     PRINT_CHAR (A0)+,D3
00000186                           465mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      466mm     IFEQ DEBUG
00000186  1639 00C00003            467mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                468mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     469mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            470mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           471mm     ENDC
00000198                           472mm 
00000198                 FALSE     473mm     IFNE DEBUG
00000198                           474mm     ENDC
00000198                           475mm 
00000198                           476mm     ENDM
00000198  60E4                     477m     BRA LOOP_14
0000019A                           478m EXIT_14
0000019A                           479m     ENDM
0000019A                           480  
0000019A                           481  GET_INPUT
0000019A                           482m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           483m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      484m     IFEQ DEBUG
0000019A  1639 00C00003            485m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                486m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     487m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           488m     ENDC
000001A6                           489m 
000001A6                           490mm     READ_CHAR D2
000001A6                 TRUE      491mm     IFEQ DEBUG
000001A6  1439 00C00007            492mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           493mm     ENDC
000001AC                 FALSE     494mm     IFNE DEBUG
000001AC                           495mm     ENDC
000001AC                           496mm 
000001AC  B43C 001B                497mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                498mm     BEQ START
000001B4                           499mm     ENDM
000001B4                           500m 
000001B4                 TRUE      501m     IFEQ DEBUG
000001B4                           502mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           503mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      504mm     IFEQ DEBUG
000001B4  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                506mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     507mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            508mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           509mm     ENDC
000001C6                           510mm 
000001C6                 FALSE     511mm     IFNE DEBUG
000001C6                           512mm     ENDC
000001C6                           513mm 
000001C6                           514mm     ENDM
000001C6                           515m     ENDC
000001C6                           516m     ENDM
000001C6                           517  
000001C6                           518      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                519s     CMP.B   #'0',D2
000001CA  6D00 000E                520s     BLT _00000000
000001CE  B43C 0039                521s     CMP.B   #'9',D2
000001D2  6E00 0006                522s     BGT _00000000
000001D6  6000 0F1E                523          BRA HEX_DIGIT
000001DA                           524      ENDI
000001DA                           525s _00000000
000001DA                           526      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                527s     CMP.B   #'A',D2
000001DE  6D00 000E                528s     BLT _00000001
000001E2  B43C 0046                529s     CMP.B   #'F',D2
000001E6  6E00 0006                530s     BGT _00000001
000001EA  6000 0F0A                531          BRA HEX_DIGIT
000001EE                           532      ENDI
000001EE                           533s _00000001
000001EE                           534  
000001EE  B43C 0077                535      CMP.B #'w',D2
000001F2  6700 019A                536      BEQ W
000001F6                           537  
000001F6  B43C 006C                538      CMP.B #'l',D2
000001FA  6700 0A2A                539      BEQ L 
000001FE                           540  
000001FE  B43C 0070                541      CMP.B #'p',D2
00000202  6700 0C52                542      BEQ P
00000206                           543  
00000206  B43C 006D                544      CMP.B #'m',D2
0000020A  6700 0E1C                545      BEQ M
0000020E                           546  
0000020E                           547m     PRINT_CRLF D3,A0
0000020E  41FA 10CE                548m     LEA CRLF(PC),A0
00000212                           549mm     PRINT_STR A0,D3
00000212                           550mm LOOP_20
00000212  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                552mm     BEQ EXIT_20
0000021A                           553mmm     PRINT_CHAR (A0)+,D3
0000021A                           554mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      555mmm     IFEQ DEBUG
0000021A  1639 00C00003            556mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                557mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     558mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            559mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           560mmm     ENDC
0000022C                           561mmm 
0000022C                 FALSE     562mmm     IFNE DEBUG
0000022C                           563mmm     ENDC
0000022C                           564mmm 
0000022C                           565mmm     ENDM
0000022C  60E4                     566mm     BRA LOOP_20
0000022E                           567mm EXIT_20
0000022E                           568mm     ENDM
0000022E                           569m     ENDM
0000022E                           570   
0000022E  B43C 003F                571      CMP.B #'?',D2
00000232  6700 0056                572      BEQ H
00000236                           573   
00000236  B43C 0076                574      CMP.B #'v',D2
0000023A  6700 0056                575      BEQ V
0000023E                           576      
0000023E  B43C 0072                577      CMP.B #'r',D2
00000242  6700 0072                578      BEQ R
00000246                           579  
00000246  B43C 0073                580      CMP.B #'s',D2
0000024A  6700 01B6                581      BEQ S
0000024E                           582  
0000024E  B43C 0067                583      CMP.B #'g',D2
00000252  6700 08DA                584      BEQ G   
00000256                           585  
00000256  B43C 007A                586      CMP.B #'z',D2
0000025A  6700 08DA                587      BEQ Z   
0000025E                           588  
0000025E  B43C 006A                589      CMP.B #'j',D2
00000262  6700 0E5C                590      BEQ j
00000266                           591  
00000266  41FA 0FD7                592      LEA HUH(PC),A0
0000026A                           593m     PRINT_STR A0,D3
0000026A                           594m LOOP_22
0000026A  0C10 0000                595m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000026E  6700 0016                596m     BEQ EXIT_22
00000272                           597mm     PRINT_CHAR (A0)+,D3
00000272                           598mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000272                 TRUE      599mm     IFEQ DEBUG
00000272  1639 00C00003            600mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000278  0803 0002                601mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000027C  67F4                     602mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000027E  13D8 00C00007            603mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000284                           604mm     ENDC
00000284                           605mm 
00000284                 FALSE     606mm     IFNE DEBUG
00000284                           607mm     ENDC
00000284                           608mm 
00000284                           609mm     ENDM
00000284  60E4                     610m     BRA LOOP_22
00000286                           611m EXIT_22
00000286                           612m     ENDM
00000286                           613  
00000286  6000 FEF2                614      BRA MAIN_LOOP
0000028A                           615  
0000028A                           616  ; commands
0000028A                           617  H
0000028A  41FA 0E9B                618      LEA HELP(PC),A0
0000028E  6000 0006                619      BRA PRINTSTR
00000292                           620  
00000292                           621  V
00000292  41FA 106E                622      LEA VERSION(PC),A0
00000296                           623  PRINTSTR
00000296                           624m     PRINT_STR A0,D3    
00000296                           625m LOOP_24
00000296  0C10 0000                626m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000029A  6700 0016                627m     BEQ EXIT_24
0000029E                           628mm     PRINT_CHAR (A0)+,D3
0000029E                           629mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029E                 TRUE      630mm     IFEQ DEBUG
0000029E  1639 00C00003            631mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002A4  0803 0002                632mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A8  67F4                     633mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002AA  13D8 00C00007            634mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002B0                           635mm     ENDC
000002B0                           636mm 
000002B0                 FALSE     637mm     IFNE DEBUG
000002B0                           638mm     ENDC
000002B0                           639mm 
000002B0                           640mm     ENDM
000002B0  60E4                     641m     BRA LOOP_24
000002B2                           642m EXIT_24
000002B2                           643m     ENDM
000002B2  6000 FEC6                644      BRA MAIN_LOOP
000002B6                           645  
000002B6                           646  R
000002B6  2047                     647      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B8  7E00                     648      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002BA  2410                     649      MOVE.L (A0),D2                                  ; read the memory and print it
000002BC                           650m     PRINT_REG D2,D3,D4,D5,A0
000002BC  41FA 1026                651m     LEA OX(PC),A0
000002C0                           652mm     PRINT_STR A0,D3
000002C0                           653mm LOOP_27
000002C0  0C10 0000                654mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002C4  6700 0016                655mm     BEQ EXIT_27
000002C8                           656mmm     PRINT_CHAR (A0)+,D3
000002C8                           657mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      658mmm     IFEQ DEBUG
000002C8  1639 00C00003            659mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002CE  0803 0002                660mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002D2  67F4                     661mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            662mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002DA                           663mmm     ENDC
000002DA                           664mmm 
000002DA                 FALSE     665mmm     IFNE DEBUG
000002DA                           666mmm     ENDC
000002DA                           667mmm 
000002DA                           668mmm     ENDM
000002DA  60E4                     669mm     BRA LOOP_27
000002DC                           670mm EXIT_27
000002DC                           671mm     ENDM
000002DC  7A07                     672m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002DE                           673m LOOP_26
000002DE                           674mm     BIN2HEX D2,D4,A0
000002DE  41FA 0FC3                675mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002E2  E99A                     676mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002E4  1802                     677mm     MOVE.B D2,D4
000002E6  0284 0000000F            678mm     ANDI.L #$F,D4
000002EC  1830 4000                679mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002F0                           680mm     ENDM
000002F0                           681mm     PRINT_CHAR D4,D3
000002F0                           682mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      683mm     IFEQ DEBUG
000002F0  1639 00C00003            684mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F6  0803 0002                685mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002FA  67F4                     686mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002FC  13C4 00C00007            687mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000302                           688mm     ENDC
00000302                           689mm 
00000302                 FALSE     690mm     IFNE DEBUG
00000302                           691mm     ENDC
00000302                           692mm 
00000302                           693mm     ENDM
00000302  57CD FFDA                694m     DBEQ D5,LOOP_26
00000306                           695m     ENDM
00000306                           696      
00000306                           697m     PRINT_CHAR #32,D3
00000306                           698m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000306                 TRUE      699m     IFEQ DEBUG
00000306  1639 00C00003            700m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000030C  0803 0002                701m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000310  67F4                     702m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000312  13FC 0020 00C00007       703m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000031A                           704m     ENDC
0000031A                           705m 
0000031A                 FALSE     706m     IFNE DEBUG
0000031A                           707m     ENDC
0000031A                           708m 
0000031A                           709m     ENDM
0000031A                           710  
0000031A  E19A                     711      ROL.L #8,D2
0000031C                           712m     PRINT_CHAR D2,D3
0000031C                           713m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031C                 TRUE      714m     IFEQ DEBUG
0000031C  1639 00C00003            715m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000322  0803 0002                716m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000326  67F4                     717m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000328  13C2 00C00007            718m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000032E                           719m     ENDC
0000032E                           720m 
0000032E                 FALSE     721m     IFNE DEBUG
0000032E                           722m     ENDC
0000032E                           723m 
0000032E                           724m     ENDM
0000032E  E19A                     725      ROL.L #8,D2
00000330                           726m     PRINT_CHAR D2,D3
00000330                           727m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000330                 TRUE      728m     IFEQ DEBUG
00000330  1639 00C00003            729m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000336  0803 0002                730m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000033A  67F4                     731m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000033C  13C2 00C00007            732m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000342                           733m     ENDC
00000342                           734m 
00000342                 FALSE     735m     IFNE DEBUG
00000342                           736m     ENDC
00000342                           737m 
00000342                           738m     ENDM
00000342  E19A                     739      ROL.L #8,D2
00000344                           740m     PRINT_CHAR D2,D3
00000344                           741m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      742m     IFEQ DEBUG
00000344  1639 00C00003            743m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000034A  0803 0002                744m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000034E  67F4                     745m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000350  13C2 00C00007            746m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000356                           747m     ENDC
00000356                           748m 
00000356                 FALSE     749m     IFNE DEBUG
00000356                           750m     ENDC
00000356                           751m 
00000356                           752m     ENDM
00000356  E19A                     753      ROL.L #8,D2
00000358                           754m     PRINT_CHAR D2,D3
00000358                           755m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000358                 TRUE      756m     IFEQ DEBUG
00000358  1639 00C00003            757m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035E  0803 0002                758m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000362  67F4                     759m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000364  13C2 00C00007            760m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000036A                           761m     ENDC
0000036A                           762m 
0000036A                 FALSE     763m     IFNE DEBUG
0000036A                           764m     ENDC
0000036A                           765m 
0000036A                           766m     ENDM
0000036A                           767  
0000036A                           768m     PRINT_CRLF D3,A0
0000036A  41FA 0F72                769m     LEA CRLF(PC),A0
0000036E                           770mm     PRINT_STR A0,D3
0000036E                           771mm LOOP_37
0000036E  0C10 0000                772mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000372  6700 0016                773mm     BEQ EXIT_37
00000376                           774mmm     PRINT_CHAR (A0)+,D3
00000376                           775mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000376                 TRUE      776mmm     IFEQ DEBUG
00000376  1639 00C00003            777mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000037C  0803 0002                778mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000380  67F4                     779mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
00000382  13D8 00C00007            780mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000388                           781mmm     ENDC
00000388                           782mmm 
00000388                 FALSE     783mmm     IFNE DEBUG
00000388                           784mmm     ENDC
00000388                           785mmm 
00000388                           786mmm     ENDM
00000388  60E4                     787mm     BRA LOOP_37
0000038A                           788mm EXIT_37
0000038A                           789mm     ENDM
0000038A                           790m     ENDM
0000038A                           791      
0000038A  6000 FDEE                792      BRA MAIN_LOOP
0000038E                           793  
0000038E                           794  W
0000038E  3C3C 0007                795      MOVE #7,D6                                      ; 7 bytes left to read
00000392                           796      
00000392                           797  READ_DATA_TO_POKE
00000392  E98D                     798      LSL.L #4,D5                                     ; make what we have so far more significant
00000394                           799m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000394                           800m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000394                 TRUE      801m     IFEQ DEBUG
00000394  1639 00C00003            802m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000039A  0803 0000                803m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000039E  67F4                     804m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
000003A0                           805m     ENDC
000003A0                           806m 
000003A0                           807mm     READ_CHAR D2
000003A0                 TRUE      808mm     IFEQ DEBUG
000003A0  1439 00C00007            809mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000003A6                           810mm     ENDC
000003A6                 FALSE     811mm     IFNE DEBUG
000003A6                           812mm     ENDC
000003A6                           813mm 
000003A6  B43C 001B                814mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003AA  6700 FC5C                815mm     BEQ START
000003AE                           816mm     ENDM
000003AE                           817m 
000003AE                 TRUE      818m     IFEQ DEBUG
000003AE                           819mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003AE                           820mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AE                 TRUE      821mm     IFEQ DEBUG
000003AE  1639 00C00003            822mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003B4  0803 0002                823mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B8  67F4                     824mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003BA  13C2 00C00007            825mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003C0                           826mm     ENDC
000003C0                           827mm 
000003C0                 FALSE     828mm     IFNE DEBUG
000003C0                           829mm     ENDC
000003C0                           830mm 
000003C0                           831mm     ENDM
000003C0                           832m     ENDC
000003C0                           833m     ENDM
000003C0                           834m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003C0  41FA 0EF1                835m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003C4  0402 0030                836m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C8  C4BC 000000FF            837m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003CE  1430 2000                838m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003D2                           839m     ENDM
000003D2  8A02                     840      OR.B D2,D5
000003D4  57CE FFBC                841      DBEQ D6,READ_DATA_TO_POKE
000003D8                           842      
000003D8  2047                     843      MOVE.L D7,A0                                    ; address accumulator -> address register
000003DA  7E00                     844      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003DC                           845      
000003DC  2085                     846      MOVE.L D5,(A0)                                  ; write the data
000003DE                           847  
000003DE                           848m     PRINT_CRLF D3,A0
000003DE  41FA 0EFE                849m     LEA CRLF(PC),A0
000003E2                           850mm     PRINT_STR A0,D3
000003E2                           851mm LOOP_44
000003E2  0C10 0000                852mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003E6  6700 0016                853mm     BEQ EXIT_44
000003EA                           854mmm     PRINT_CHAR (A0)+,D3
000003EA                           855mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EA                 TRUE      856mmm     IFEQ DEBUG
000003EA  1639 00C00003            857mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003F0  0803 0002                858mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003F4  67F4                     859mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003F6  13D8 00C00007            860mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003FC                           861mmm     ENDC
000003FC                           862mmm 
000003FC                 FALSE     863mmm     IFNE DEBUG
000003FC                           864mmm     ENDC
000003FC                           865mmm 
000003FC                           866mmm     ENDM
000003FC  60E4                     867mm     BRA LOOP_44
000003FE                           868mm EXIT_44
000003FE                           869mm     ENDM
000003FE                           870m     ENDM
000003FE  6000 FD7A                871      BRA MAIN_LOOP
00000402                           872  
00000402                           873  ; register map for S
00000402                           874  ; A0 - start address
00000402                           875  ; A1 - offset
00000402                           876  ; A2 - next address to write
00000402                           877  ; A3 - next location (jmp)
00000402                           878  ; A4 - Working Address Register
00000402                           879  ; D0 - record count
00000402                           880  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000402                           881  ; D2 - checksum
00000402                           882  ; D3 - data byte count
00000402                           883  ; D4 - read address, moved into A2
00000402                           884  ; D5 - temp
00000402                           885  ; D6 - temp
00000402                           886  ; D7 - temp
00000402                           887  S
00000402  2078 0000                888      MOVE.L 0,A0                                     ; start address -> A0
00000406  2247                     889      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000408                           890      
00000408  7000                     891      MOVE.L #0,D0                                    ; count of records read -> D0
0000040A                           892          
0000040A                           893  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000040A                           894m     DOWNLOAD D1
0000040A                           895m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040A                           896m 
0000040A  1239 00C00003            897m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000410  0801 0000                898m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000414  6700 0010                899m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000418                           900m 
00000418                           901mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000418                 TRUE      902mm     IFEQ DEBUG
00000418  1239 00C00007            903mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000041E                           904mm     ENDC
0000041E                 FALSE     905mm     IFNE DEBUG
0000041E                           906mm     ENDC
0000041E                           907mm 
0000041E  B23C 001B                908mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000422  6700 FBE4                909mm     BEQ START
00000426                           910mm     ENDM
00000426                           911m CONTINUE_46
00000426  1239 00C00013            912m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000042C  0801 0000                913m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000430  67D8                     914m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
00000432                           915m     
00000432  1239 00C00017            916m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000438  13C1 00E00001            917m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000043E                           918m 
0000043E                           919m     ENDM
0000043E  B23C 0053                920      CMP.B #'S',D1                                   ; found S?
00000442  66C6                     921      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000444                           922      
00000444                           923m     PRINT_CHAR #'S',D5                              ; print the S
00000444                           924m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000444                 TRUE      925m     IFEQ DEBUG
00000444  1A39 00C00003            926m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000044A  0805 0002                927m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000044E  67F4                     928m         BEQ WAIT_FOR_READY_48                       ; NO SPACE, CHECK AGAIN
00000450  13FC 0053 00C00007       929m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000458                           930m     ENDC
00000458                           931m 
00000458                 FALSE     932m     IFNE DEBUG
00000458                           933m     ENDC
00000458                           934m 
00000458                           935m     ENDM
00000458  5280                     936      ADD.L #1,D0                                     ; read another S record, increment count
0000045A                           937      
0000045A                           938m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000045A                           939m WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000045A                           940m 
0000045A  1239 00C00003            941m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000460  0801 0000                942m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000464  6700 0010                943m     BEQ CONTINUE_49                                 ; NOTHING, CONTINUE
00000468                           944m 
00000468                           945mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000468                 TRUE      946mm     IFEQ DEBUG
00000468  1239 00C00007            947mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000046E                           948mm     ENDC
0000046E                 FALSE     949mm     IFNE DEBUG
0000046E                           950mm     ENDC
0000046E                           951mm 
0000046E  B23C 001B                952mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000472  6700 FB94                953mm     BEQ START
00000476                           954mm     ENDM
00000476                           955m CONTINUE_49
00000476  1239 00C00013            956m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000047C  0801 0000                957m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000480  67D8                     958m     BEQ WAIT_FOR_READY_49                           ; NOTHING, CHECK AGAIN
00000482                           959m     
00000482  1239 00C00017            960m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000488  13C1 00E00001            961m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000048E                           962m 
0000048E                           963m     ENDM
0000048E                           964m     PRINT_CHAR D1,D5
0000048E                           965m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048E                 TRUE      966m     IFEQ DEBUG
0000048E  1A39 00C00003            967m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000494  0805 0002                968m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000498  67F4                     969m         BEQ WAIT_FOR_READY_51                       ; NO SPACE, CHECK AGAIN
0000049A  13C1 00C00007            970m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004A0                           971m     ENDC
000004A0                           972m 
000004A0                 FALSE     973m     IFNE DEBUG
000004A0                           974m     ENDC
000004A0                           975m 
000004A0                           976m     ENDM
000004A0                           977  
000004A0  7400                     978      MOVE.L #0,D2                                    ; clear the checksum
000004A2                           979  
000004A2                           980m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000004A2  1E3C 0002                981m     MOVE.B #2,D7
000004A6                           982m     WHILE.B D7 <GT> 0 DO
000004A6                           983ms _10000000
000004A6  BE38 0000                984ms     CMP.B   0,D7
000004AA  6F00 0062                985ms     BLE _10000001
000004AE  E98B                     986m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000004B0                           987mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000004B0                           988mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B0                           989mm 
000004B0  1A39 00C00003            990mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000004B6  0805 0000                991mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004BA  6700 0010                992mm     BEQ CONTINUE_53                                 ; NOTHING, CONTINUE
000004BE                           993mm 
000004BE                           994mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000004BE                 TRUE      995mmm     IFEQ DEBUG
000004BE  1A39 00C00007            996mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000004C4                           997mmm     ENDC
000004C4                 FALSE     998mmm     IFNE DEBUG
000004C4                           999mmm     ENDC
000004C4                          1000mmm 
000004C4  BA3C 001B               1001mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000004C8  6700 FB3E               1002mmm     BEQ START
000004CC                          1003mmm     ENDM
000004CC                          1004mm CONTINUE_53
000004CC  1A39 00C00013           1005mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004D2  0805 0000               1006mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004D6  67D8                    1007mm     BEQ WAIT_FOR_READY_53                           ; NOTHING, CHECK AGAIN
000004D8                          1008mm     
000004D8  1A39 00C00017           1009mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004DE  13C5 00E00001           1010mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004E4                          1011mm 
000004E4                          1012mm     ENDM
000004E4                          1013mm         PRINT_CHAR D5,D6
000004E4                          1014mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E4                 TRUE     1015mm     IFEQ DEBUG
000004E4  1C39 00C00003           1016mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000004EA  0806 0002               1017mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000004EE  67F4                    1018mm         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
000004F0  13C5 00C00007           1019mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F6                          1020mm     ENDC
000004F6                          1021mm 
000004F6                 FALSE    1022mm     IFNE DEBUG
000004F6                          1023mm     ENDC
000004F6                          1024mm 
000004F6                          1025mm     ENDM
000004F6                          1026mm         HEX2BIN D5,D5,A4
000004F6  49FA 0DBB               1027mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004FA  0405 0030               1028mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004FE  CABC 000000FF           1029mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000504  1A34 5000               1030mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000508                          1031mm     ENDM
00000508  8605                    1032m         OR.B D5,D3
0000050A  5307                    1033m         SUB.B #1,D7
0000050C                          1034m     ENDW
0000050C  6098                    1035ms     BRA _10000000
0000050E                          1036ms _10000001
0000050E                          1037m 
0000050E  7A00                    1038m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000510  1A03                    1039m     MOVE.B D3,D5
00000512  D483                    1040m     ADD.L D3,D2
00000514                          1041m 
00000514                          1042m     ENDM
00000514                          1043  
00000514                          1044      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000514  B23C 0030               1045s     CMP.B   #'0',D1
00000518  6600 002A               1046s     BNE.L   _00000002
0000051C                          1047m         PRINT_CRLF D5,A4
0000051C  49FA 0DC0               1048m     LEA CRLF(PC),A4
00000520                          1049mm     PRINT_STR A4,D5
00000520                          1050mm LOOP_58
00000520  0C14 0000               1051mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000524  6700 0016               1052mm     BEQ EXIT_58
00000528                          1053mmm     PRINT_CHAR (A4)+,D5
00000528                          1054mmm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000528                 TRUE     1055mmm     IFEQ DEBUG
00000528  1A39 00C00003           1056mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000052E  0805 0002               1057mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000532  67F4                    1058mmm         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000534  13DC 00C00007           1059mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000053A                          1060mmm     ENDC
0000053A                          1061mmm 
0000053A                 FALSE    1062mmm     IFNE DEBUG
0000053A                          1063mmm     ENDC
0000053A                          1064mmm 
0000053A                          1065mmm     ENDM
0000053A  60E4                    1066mm     BRA LOOP_58
0000053C                          1067mm EXIT_58
0000053C                          1068mm     ENDM
0000053C                          1069m     ENDM
0000053C  6000 FECC               1070          BRA WAIT_FOR_SRECORD
00000540                          1071      ELSE
00000540  6000 03DE               1072s     BRA _00000003
00000544                          1073s _00000002
00000544                          1074          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000544  B23C 0031               1075s     CMP.B   #'1',D1
00000548  6708                    1076s     BEQ.S   _00000004
0000054A  B23C 0032               1077s     CMP.B   #'2',D1
0000054E  6600 01F0               1078s     BNE.L   _00000005
00000552                          1079s _00000004
00000552  5783                    1080              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000554                          1081  
00000554  7800                    1082              MOVE.L #0,D4                            ; read two bytes of address
00000556                          1083m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000556  1E3C 0002               1084m     MOVE.B #2,D7
0000055A                          1085m     WHILE.B D7 <GT> 0 DO
0000055A                          1086ms _10000002
0000055A  BE38 0000               1087ms     CMP.B   0,D7
0000055E  6F00 0062               1088ms     BLE _10000003
00000562  E98C                    1089m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000564                          1090mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000564                          1091mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                          1092mm 
00000564  1A39 00C00003           1093mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000056A  0805 0000               1094mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000056E  6700 0010               1095mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000572                          1096mm 
00000572                          1097mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000572                 TRUE     1098mmm     IFEQ DEBUG
00000572  1A39 00C00007           1099mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000578                          1100mmm     ENDC
00000578                 FALSE    1101mmm     IFNE DEBUG
00000578                          1102mmm     ENDC
00000578                          1103mmm 
00000578  BA3C 001B               1104mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000057C  6700 FA8A               1105mmm     BEQ START
00000580                          1106mmm     ENDM
00000580                          1107mm CONTINUE_61
00000580  1A39 00C00013           1108mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000586  0805 0000               1109mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000058A  67D8                    1110mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
0000058C                          1111mm     
0000058C  1A39 00C00017           1112mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000592  13C5 00E00001           1113mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000598                          1114mm 
00000598                          1115mm     ENDM
00000598                          1116mm         PRINT_CHAR D5,D6
00000598                          1117mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000598                 TRUE     1118mm     IFEQ DEBUG
00000598  1C39 00C00003           1119mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000059E  0806 0002               1120mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000005A2  67F4                    1121mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000005A4  13C5 00C00007           1122mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005AA                          1123mm     ENDC
000005AA                          1124mm 
000005AA                 FALSE    1125mm     IFNE DEBUG
000005AA                          1126mm     ENDC
000005AA                          1127mm 
000005AA                          1128mm     ENDM
000005AA                          1129mm         HEX2BIN D5,D5,A4
000005AA  49FA 0D07               1130mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005AE  0405 0030               1131mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005B2  CABC 000000FF           1132mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005B8  1A34 5000               1133mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005BC                          1134mm     ENDM
000005BC  8805                    1135m         OR.B D5,D4
000005BE  5307                    1136m         SUB.B #1,D7
000005C0                          1137m     ENDW
000005C0  6098                    1138ms     BRA _10000002
000005C2                          1139ms _10000003
000005C2                          1140m 
000005C2  7A00                    1141m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005C4  1A04                    1142m     MOVE.B D4,D5
000005C6  D484                    1143m     ADD.L D4,D2
000005C8                          1144m 
000005C8                          1145m     ENDM
000005C8                          1146m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000005C8  1E3C 0002               1147m     MOVE.B #2,D7
000005CC                          1148m     WHILE.B D7 <GT> 0 DO
000005CC                          1149ms _10000004
000005CC  BE38 0000               1150ms     CMP.B   0,D7
000005D0  6F00 0062               1151ms     BLE _10000005
000005D4  E98C                    1152m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005D6                          1153mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005D6                          1154mm WAIT_FOR_READY_66                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D6                          1155mm 
000005D6  1A39 00C00003           1156mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005DC  0805 0000               1157mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005E0  6700 0010               1158mm     BEQ CONTINUE_66                                 ; NOTHING, CONTINUE
000005E4                          1159mm 
000005E4                          1160mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005E4                 TRUE     1161mmm     IFEQ DEBUG
000005E4  1A39 00C00007           1162mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005EA                          1163mmm     ENDC
000005EA                 FALSE    1164mmm     IFNE DEBUG
000005EA                          1165mmm     ENDC
000005EA                          1166mmm 
000005EA  BA3C 001B               1167mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005EE  6700 FA18               1168mmm     BEQ START
000005F2                          1169mmm     ENDM
000005F2                          1170mm CONTINUE_66
000005F2  1A39 00C00013           1171mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F8  0805 0000               1172mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005FC  67D8                    1173mm     BEQ WAIT_FOR_READY_66                           ; NOTHING, CHECK AGAIN
000005FE                          1174mm     
000005FE  1A39 00C00017           1175mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000604  13C5 00E00001           1176mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000060A                          1177mm 
0000060A                          1178mm     ENDM
0000060A                          1179mm         PRINT_CHAR D5,D6
0000060A                          1180mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060A                 TRUE     1181mm     IFEQ DEBUG
0000060A  1C39 00C00003           1182mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000610  0806 0002               1183mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000614  67F4                    1184mm         BEQ WAIT_FOR_READY_68                       ; NO SPACE, CHECK AGAIN
00000616  13C5 00C00007           1185mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000061C                          1186mm     ENDC
0000061C                          1187mm 
0000061C                 FALSE    1188mm     IFNE DEBUG
0000061C                          1189mm     ENDC
0000061C                          1190mm 
0000061C                          1191mm     ENDM
0000061C                          1192mm         HEX2BIN D5,D5,A4
0000061C  49FA 0C95               1193mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000620  0405 0030               1194mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000624  CABC 000000FF           1195mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000062A  1A34 5000               1196mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000062E                          1197mm     ENDM
0000062E  8805                    1198m         OR.B D5,D4
00000630  5307                    1199m         SUB.B #1,D7
00000632                          1200m     ENDW
00000632  6098                    1201ms     BRA _10000004
00000634                          1202ms _10000005
00000634                          1203m 
00000634  7A00                    1204m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000636  1A04                    1205m     MOVE.B D4,D5
00000638  D484                    1206m     ADD.L D4,D2
0000063A                          1207m 
0000063A                          1208m     ENDM
0000063A                          1209  
0000063A                          1210              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000063A  B23C 0032               1211s     CMP.B   #'2',D1
0000063E  6600 0076               1212s     BNE.L   _00000006
00000642  5383                    1213                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000644                          1214m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000644  1E3C 0002               1215m     MOVE.B #2,D7
00000648                          1216m     WHILE.B D7 <GT> 0 DO
00000648                          1217ms _10000006
00000648  BE38 0000               1218ms     CMP.B   0,D7
0000064C  6F00 0062               1219ms     BLE _10000007
00000650  E98C                    1220m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000652                          1221mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000652                          1222mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000652                          1223mm 
00000652  1A39 00C00003           1224mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000658  0805 0000               1225mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000065C  6700 0010               1226mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
00000660                          1227mm 
00000660                          1228mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000660                 TRUE     1229mmm     IFEQ DEBUG
00000660  1A39 00C00007           1230mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000666                          1231mmm     ENDC
00000666                 FALSE    1232mmm     IFNE DEBUG
00000666                          1233mmm     ENDC
00000666                          1234mmm 
00000666  BA3C 001B               1235mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000066A  6700 F99C               1236mmm     BEQ START
0000066E                          1237mmm     ENDM
0000066E                          1238mm CONTINUE_71
0000066E  1A39 00C00013           1239mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000674  0805 0000               1240mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000678  67D8                    1241mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
0000067A                          1242mm     
0000067A  1A39 00C00017           1243mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000680  13C5 00E00001           1244mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000686                          1245mm 
00000686                          1246mm     ENDM
00000686                          1247mm         PRINT_CHAR D5,D6
00000686                          1248mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000686                 TRUE     1249mm     IFEQ DEBUG
00000686  1C39 00C00003           1250mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000068C  0806 0002               1251mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000690  67F4                    1252mm         BEQ WAIT_FOR_READY_73                       ; NO SPACE, CHECK AGAIN
00000692  13C5 00C00007           1253mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000698                          1254mm     ENDC
00000698                          1255mm 
00000698                 FALSE    1256mm     IFNE DEBUG
00000698                          1257mm     ENDC
00000698                          1258mm 
00000698                          1259mm     ENDM
00000698                          1260mm         HEX2BIN D5,D5,A4
00000698  49FA 0C19               1261mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000069C  0405 0030               1262mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006A0  CABC 000000FF           1263mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006A6  1A34 5000               1264mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006AA                          1265mm     ENDM
000006AA  8805                    1266m         OR.B D5,D4
000006AC  5307                    1267m         SUB.B #1,D7
000006AE                          1268m     ENDW
000006AE  6098                    1269ms     BRA _10000006
000006B0                          1270ms _10000007
000006B0                          1271m 
000006B0  7A00                    1272m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006B2  1A04                    1273m     MOVE.B D4,D5
000006B4  D484                    1274m     ADD.L D4,D2
000006B6                          1275m 
000006B6                          1276m     ENDM
000006B6                          1277              ENDI
000006B6                          1278s _00000006
000006B6                          1279  
000006B6  2444                    1280              MOVE.L D4,A2                            ; put the address in an address register
000006B8  D5C9                    1281              ADD.L A1,A2                             ; add in the offset
000006BA                          1282  
000006BA                          1283              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000006BA                          1284s _10000008
000006BA  B63C 0000               1285s     CMP.B   #0,D3
000006BE  6F00 007A               1286s     BLE _10000009
000006C2                          1287m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000006C2  1E3C 0002               1288m     MOVE.B #2,D7
000006C6                          1289m     WHILE.B D7 <GT> 0 DO
000006C6                          1290ms _1000000A
000006C6  BE38 0000               1291ms     CMP.B   0,D7
000006CA  6F00 0062               1292ms     BLE _1000000B
000006CE  E989                    1293m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000006D0                          1294mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006D0                          1295mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D0                          1296mm 
000006D0  1A39 00C00003           1297mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006D6  0805 0000               1298mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DA  6700 0010               1299mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
000006DE                          1300mm 
000006DE                          1301mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006DE                 TRUE     1302mmm     IFEQ DEBUG
000006DE  1A39 00C00007           1303mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006E4                          1304mmm     ENDC
000006E4                 FALSE    1305mmm     IFNE DEBUG
000006E4                          1306mmm     ENDC
000006E4                          1307mmm 
000006E4  BA3C 001B               1308mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006E8  6700 F91E               1309mmm     BEQ START
000006EC                          1310mmm     ENDM
000006EC                          1311mm CONTINUE_76
000006EC  1A39 00C00013           1312mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006F2  0805 0000               1313mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006F6  67D8                    1314mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
000006F8                          1315mm     
000006F8  1A39 00C00017           1316mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006FE  13C5 00E00001           1317mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000704                          1318mm 
00000704                          1319mm     ENDM
00000704                          1320mm         PRINT_CHAR D5,D6
00000704                          1321mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000704                 TRUE     1322mm     IFEQ DEBUG
00000704  1C39 00C00003           1323mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000070A  0806 0002               1324mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000070E  67F4                    1325mm         BEQ WAIT_FOR_READY_78                       ; NO SPACE, CHECK AGAIN
00000710  13C5 00C00007           1326mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000716                          1327mm     ENDC
00000716                          1328mm 
00000716                 FALSE    1329mm     IFNE DEBUG
00000716                          1330mm     ENDC
00000716                          1331mm 
00000716                          1332mm     ENDM
00000716                          1333mm         HEX2BIN D5,D5,A4
00000716  49FA 0B9B               1334mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000071A  0405 0030               1335mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000071E  CABC 000000FF           1336mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000724  1A34 5000               1337mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000728                          1338mm     ENDM
00000728  8205                    1339m         OR.B D5,D1
0000072A  5307                    1340m         SUB.B #1,D7
0000072C                          1341m     ENDW
0000072C  6098                    1342ms     BRA _1000000A
0000072E                          1343ms _1000000B
0000072E                          1344m 
0000072E  7A00                    1345m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000730  1A01                    1346m     MOVE.B D1,D5
00000732  D481                    1347m     ADD.L D1,D2
00000734                          1348m 
00000734                          1349m     ENDM
00000734                          1350   
00000734  14C1                    1351                  MOVE.B D1,(A2)+                     ; store it!
00000736                          1352  
00000736  5303                    1353                  SUB.B #1,D3                         ; 1 less byte to go
00000738                          1354              ENDW
00000738  6080                    1355s     BRA _10000008
0000073A                          1356s _10000009
0000073A                          1357  
0000073A  7200                    1358              MOVE.L #0,D1                            ; not done yet
0000073C                          1359          ELSE
0000073C  6000 01E2               1360s     BRA _00000007
00000740                          1361s _00000005
00000740                          1362              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000740  B23C 0038               1363s     CMP.B   #'8',D1
00000744  6600 0164               1364s     BNE.L   _00000008
00000748  7800                    1365                  MOVE.L #0,D4                        ; read the 24 bit start address
0000074A                          1366m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
0000074A  1E3C 0002               1367m     MOVE.B #2,D7
0000074E                          1368m     WHILE.B D7 <GT> 0 DO
0000074E                          1369ms _1000000C
0000074E  BE38 0000               1370ms     CMP.B   0,D7
00000752  6F00 0062               1371ms     BLE _1000000D
00000756  E98C                    1372m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000758                          1373mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000758                          1374mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000758                          1375mm 
00000758  1A39 00C00003           1376mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075E  0805 0000               1377mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000762  6700 0010               1378mm     BEQ CONTINUE_81                                 ; NOTHING, CONTINUE
00000766                          1379mm 
00000766                          1380mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000766                 TRUE     1381mmm     IFEQ DEBUG
00000766  1A39 00C00007           1382mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000076C                          1383mmm     ENDC
0000076C                 FALSE    1384mmm     IFNE DEBUG
0000076C                          1385mmm     ENDC
0000076C                          1386mmm 
0000076C  BA3C 001B               1387mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000770  6700 F896               1388mmm     BEQ START
00000774                          1389mmm     ENDM
00000774                          1390mm CONTINUE_81
00000774  1A39 00C00013           1391mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000077A  0805 0000               1392mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000077E  67D8                    1393mm     BEQ WAIT_FOR_READY_81                           ; NOTHING, CHECK AGAIN
00000780                          1394mm     
00000780  1A39 00C00017           1395mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000786  13C5 00E00001           1396mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000078C                          1397mm 
0000078C                          1398mm     ENDM
0000078C                          1399mm         PRINT_CHAR D5,D6
0000078C                          1400mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                 TRUE     1401mm     IFEQ DEBUG
0000078C  1C39 00C00003           1402mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000792  0806 0002               1403mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000796  67F4                    1404mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000798  13C5 00C00007           1405mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000079E                          1406mm     ENDC
0000079E                          1407mm 
0000079E                 FALSE    1408mm     IFNE DEBUG
0000079E                          1409mm     ENDC
0000079E                          1410mm 
0000079E                          1411mm     ENDM
0000079E                          1412mm         HEX2BIN D5,D5,A4
0000079E  49FA 0B13               1413mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A2  0405 0030               1414mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007A6  CABC 000000FF           1415mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007AC  1A34 5000               1416mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B0                          1417mm     ENDM
000007B0  8805                    1418m         OR.B D5,D4
000007B2  5307                    1419m         SUB.B #1,D7
000007B4                          1420m     ENDW
000007B4  6098                    1421ms     BRA _1000000C
000007B6                          1422ms _1000000D
000007B6                          1423m 
000007B6  7A00                    1424m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B8  1A04                    1425m     MOVE.B D4,D5
000007BA  D484                    1426m     ADD.L D4,D2
000007BC                          1427m 
000007BC                          1428m     ENDM
000007BC                          1429m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000007BC  1E3C 0002               1430m     MOVE.B #2,D7
000007C0                          1431m     WHILE.B D7 <GT> 0 DO
000007C0                          1432ms _1000000E
000007C0  BE38 0000               1433ms     CMP.B   0,D7
000007C4  6F00 0062               1434ms     BLE _1000000F
000007C8  E98C                    1435m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007CA                          1436mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007CA                          1437mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CA                          1438mm 
000007CA  1A39 00C00003           1439mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007D0  0805 0000               1440mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007D4  6700 0010               1441mm     BEQ CONTINUE_86                                 ; NOTHING, CONTINUE
000007D8                          1442mm 
000007D8                          1443mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007D8                 TRUE     1444mmm     IFEQ DEBUG
000007D8  1A39 00C00007           1445mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007DE                          1446mmm     ENDC
000007DE                 FALSE    1447mmm     IFNE DEBUG
000007DE                          1448mmm     ENDC
000007DE                          1449mmm 
000007DE  BA3C 001B               1450mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007E2  6700 F824               1451mmm     BEQ START
000007E6                          1452mmm     ENDM
000007E6                          1453mm CONTINUE_86
000007E6  1A39 00C00013           1454mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007EC  0805 0000               1455mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007F0  67D8                    1456mm     BEQ WAIT_FOR_READY_86                           ; NOTHING, CHECK AGAIN
000007F2                          1457mm     
000007F2  1A39 00C00017           1458mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007F8  13C5 00E00001           1459mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007FE                          1460mm 
000007FE                          1461mm     ENDM
000007FE                          1462mm         PRINT_CHAR D5,D6
000007FE                          1463mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007FE                 TRUE     1464mm     IFEQ DEBUG
000007FE  1C39 00C00003           1465mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000804  0806 0002               1466mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000808  67F4                    1467mm         BEQ WAIT_FOR_READY_88                       ; NO SPACE, CHECK AGAIN
0000080A  13C5 00C00007           1468mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000810                          1469mm     ENDC
00000810                          1470mm 
00000810                 FALSE    1471mm     IFNE DEBUG
00000810                          1472mm     ENDC
00000810                          1473mm 
00000810                          1474mm     ENDM
00000810                          1475mm         HEX2BIN D5,D5,A4
00000810  49FA 0AA1               1476mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000814  0405 0030               1477mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000818  CABC 000000FF           1478mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000081E  1A34 5000               1479mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000822                          1480mm     ENDM
00000822  8805                    1481m         OR.B D5,D4
00000824  5307                    1482m         SUB.B #1,D7
00000826                          1483m     ENDW
00000826  6098                    1484ms     BRA _1000000E
00000828                          1485ms _1000000F
00000828                          1486m 
00000828  7A00                    1487m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000082A  1A04                    1488m     MOVE.B D4,D5
0000082C  D484                    1489m     ADD.L D4,D2
0000082E                          1490m 
0000082E                          1491m     ENDM
0000082E                          1492m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000082E  1E3C 0002               1493m     MOVE.B #2,D7
00000832                          1494m     WHILE.B D7 <GT> 0 DO
00000832                          1495ms _10000010
00000832  BE38 0000               1496ms     CMP.B   0,D7
00000836  6F00 0062               1497ms     BLE _10000011
0000083A  E98C                    1498m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083C                          1499mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083C                          1500mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083C                          1501mm 
0000083C  1A39 00C00003           1502mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000842  0805 0000               1503mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000846  6700 0010               1504mm     BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
0000084A                          1505mm 
0000084A                          1506mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                 TRUE     1507mmm     IFEQ DEBUG
0000084A  1A39 00C00007           1508mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000850                          1509mmm     ENDC
00000850                 FALSE    1510mmm     IFNE DEBUG
00000850                          1511mmm     ENDC
00000850                          1512mmm 
00000850  BA3C 001B               1513mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F7B2               1514mmm     BEQ START
00000858                          1515mmm     ENDM
00000858                          1516mm CONTINUE_91
00000858  1A39 00C00013           1517mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085E  0805 0000               1518mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  67D8                    1519mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
00000864                          1520mm     
00000864  1A39 00C00017           1521mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086A  13C5 00E00001           1522mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000870                          1523mm 
00000870                          1524mm     ENDM
00000870                          1525mm         PRINT_CHAR D5,D6
00000870                          1526mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1527mm     IFEQ DEBUG
00000870  1C39 00C00003           1528mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000876  0806 0002               1529mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1530mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
0000087C  13C5 00C00007           1531mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000882                          1532mm     ENDC
00000882                          1533mm 
00000882                 FALSE    1534mm     IFNE DEBUG
00000882                          1535mm     ENDC
00000882                          1536mm 
00000882                          1537mm     ENDM
00000882                          1538mm         HEX2BIN D5,D5,A4
00000882  49FA 0A2F               1539mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000886  0405 0030               1540mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000088A  CABC 000000FF           1541mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000890  1A34 5000               1542mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000894                          1543mm     ENDM
00000894  8805                    1544m         OR.B D5,D4
00000896  5307                    1545m         SUB.B #1,D7
00000898                          1546m     ENDW
00000898  6098                    1547ms     BRA _10000010
0000089A                          1548ms _10000011
0000089A                          1549m 
0000089A  7A00                    1550m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000089C  1A04                    1551m     MOVE.B D4,D5
0000089E  D484                    1552m     ADD.L D4,D2
000008A0                          1553m 
000008A0                          1554m     ENDM
000008A0                          1555  
000008A0  2044                    1556                  MOVE.L D4,A0                        ; start address -> A0
000008A2  D1C9                    1557                  ADD.L A1,A0                         ; add in the offset
000008A4                          1558  
000008A4  72FF                    1559                  MOVE.L #$FFFFFFFF,D1                ; done
000008A6                          1560              ELSE
000008A6  6000 0078               1561s     BRA _00000009
000008AA                          1562s _00000008
000008AA                          1563m                 PRINT_CRLF D5,A4
000008AA  49FA 0A32               1564m     LEA CRLF(PC),A4
000008AE                          1565mm     PRINT_STR A4,D5
000008AE                          1566mm LOOP_96
000008AE  0C14 0000               1567mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008B2  6700 0016               1568mm     BEQ EXIT_96
000008B6                          1569mmm     PRINT_CHAR (A4)+,D5
000008B6                          1570mmm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B6                 TRUE     1571mmm     IFEQ DEBUG
000008B6  1A39 00C00003           1572mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008BC  0805 0002               1573mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008C0  67F4                    1574mmm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
000008C2  13DC 00C00007           1575mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008C8                          1576mmm     ENDC
000008C8                          1577mmm 
000008C8                 FALSE    1578mmm     IFNE DEBUG
000008C8                          1579mmm     ENDC
000008C8                          1580mmm 
000008C8                          1581mmm     ENDM
000008C8  60E4                    1582mm     BRA LOOP_96
000008CA                          1583mm EXIT_96
000008CA                          1584mm     ENDM
000008CA                          1585m     ENDM
000008CA                          1586  
000008CA  49FA 099C               1587                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008CE                          1588m                 PRINT_STR A4,D5
000008CE                          1589m LOOP_98
000008CE  0C14 0000               1590m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008D2  6700 0016               1591m     BEQ EXIT_98
000008D6                          1592mm     PRINT_CHAR (A4)+,D5
000008D6                          1593mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                 TRUE     1594mm     IFEQ DEBUG
000008D6  1A39 00C00003           1595mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008DC  0805 0002               1596mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008E0  67F4                    1597mm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
000008E2  13DC 00C00007           1598mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008E8                          1599mm     ENDC
000008E8                          1600mm 
000008E8                 FALSE    1601mm     IFNE DEBUG
000008E8                          1602mm     ENDC
000008E8                          1603mm 
000008E8                          1604mm     ENDM
000008E8  60E4                    1605m     BRA LOOP_98
000008EA                          1606m EXIT_98
000008EA                          1607m     ENDM
000008EA                          1608m                 PRINT_CHAR D1,D5
000008EA                          1609m WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EA                 TRUE     1610m     IFEQ DEBUG
000008EA  1A39 00C00003           1611m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008F0  0805 0002               1612m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008F4  67F4                    1613m         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000008F6  13C1 00C00007           1614m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008FC                          1615m     ENDC
000008FC                          1616m 
000008FC                 FALSE    1617m     IFNE DEBUG
000008FC                          1618m     ENDC
000008FC                          1619m 
000008FC                          1620m     ENDM
000008FC                          1621m                 PRINT_CRLF D5,A4
000008FC  49FA 09E0               1622m     LEA CRLF(PC),A4
00000900                          1623mm     PRINT_STR A4,D5
00000900                          1624mm LOOP_102
00000900  0C14 0000               1625mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000904  6700 0016               1626mm     BEQ EXIT_102
00000908                          1627mmm     PRINT_CHAR (A4)+,D5
00000908                          1628mmm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000908                 TRUE     1629mmm     IFEQ DEBUG
00000908  1A39 00C00003           1630mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000090E  0805 0002               1631mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000912  67F4                    1632mmm         BEQ WAIT_FOR_READY_103                      ; NO SPACE, CHECK AGAIN
00000914  13DC 00C00007           1633mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000091A                          1634mmm     ENDC
0000091A                          1635mmm 
0000091A                 FALSE    1636mmm     IFNE DEBUG
0000091A                          1637mmm     ENDC
0000091A                          1638mmm 
0000091A                          1639mmm     ENDM
0000091A  60E4                    1640mm     BRA LOOP_102
0000091C                          1641mm EXIT_102
0000091C                          1642mm     ENDM
0000091C                          1643m     ENDM
0000091C                          1644  
0000091C  6000 FAEC               1645                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000920                          1646              ENDI
00000920                          1647s _00000009
00000920                          1648          ENDI
00000920                          1649s _00000007
00000920                          1650      ENDI
00000920                          1651s _00000003
00000920                          1652  
00000920                          1653m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000920  1E3C 0002               1654m     MOVE.B #2,D7
00000924                          1655m     WHILE.B D7 <GT> 0 DO
00000924                          1656ms _10000012
00000924  BE38 0000               1657ms     CMP.B   0,D7
00000928  6F00 0062               1658ms     BLE _10000013
0000092C  E98C                    1659m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000092E                          1660mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000092E                          1661mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092E                          1662mm 
0000092E  1A39 00C00003           1663mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000934  0805 0000               1664mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000938  6700 0010               1665mm     BEQ CONTINUE_105                                    ; NOTHING, CONTINUE
0000093C                          1666mm 
0000093C                          1667mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000093C                 TRUE     1668mmm     IFEQ DEBUG
0000093C  1A39 00C00007           1669mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000942                          1670mmm     ENDC
00000942                 FALSE    1671mmm     IFNE DEBUG
00000942                          1672mmm     ENDC
00000942                          1673mmm 
00000942  BA3C 001B               1674mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000946  6700 F6C0               1675mmm     BEQ START
0000094A                          1676mmm     ENDM
0000094A                          1677mm CONTINUE_105
0000094A  1A39 00C00013           1678mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000950  0805 0000               1679mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000954  67D8                    1680mm     BEQ WAIT_FOR_READY_105                          ; NOTHING, CHECK AGAIN
00000956                          1681mm     
00000956  1A39 00C00017           1682mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000095C  13C5 00E00001           1683mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000962                          1684mm 
00000962                          1685mm     ENDM
00000962                          1686mm         PRINT_CHAR D5,D6
00000962                          1687mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000962                 TRUE     1688mm     IFEQ DEBUG
00000962  1C39 00C00003           1689mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000968  0806 0002               1690mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000096C  67F4                    1691mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096E  13C5 00C00007           1692mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000974                          1693mm     ENDC
00000974                          1694mm 
00000974                 FALSE    1695mm     IFNE DEBUG
00000974                          1696mm     ENDC
00000974                          1697mm 
00000974                          1698mm     ENDM
00000974                          1699mm         HEX2BIN D5,D5,A4
00000974  49FA 093D               1700mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000978  0405 0030               1701mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000097C  CABC 000000FF           1702mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000982  1A34 5000               1703mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000986                          1704mm     ENDM
00000986  8805                    1705m         OR.B D5,D4
00000988  5307                    1706m         SUB.B #1,D7
0000098A                          1707m     ENDW
0000098A  6098                    1708ms     BRA _10000012
0000098C                          1709ms _10000013
0000098C                          1710m 
0000098C  7A00                    1711m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000098E  1A04                    1712m     MOVE.B D4,D5
00000990  D484                    1713m     ADD.L D4,D2
00000992                          1714m 
00000992                          1715m     ENDM
00000992                          1716m     PRINT_CRLF D5,A4
00000992  49FA 094A               1717m     LEA CRLF(PC),A4
00000996                          1718mm     PRINT_STR A4,D5
00000996                          1719mm LOOP_110
00000996  0C14 0000               1720mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000099A  6700 0016               1721mm     BEQ EXIT_110
0000099E                          1722mmm     PRINT_CHAR (A4)+,D5
0000099E                          1723mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099E                 TRUE     1724mmm     IFEQ DEBUG
0000099E  1A39 00C00003           1725mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A4  0805 0002               1726mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A8  67F4                    1727mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009AA  13DC 00C00007           1728mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009B0                          1729mmm     ENDC
000009B0                          1730mmm 
000009B0                 FALSE    1731mmm     IFNE DEBUG
000009B0                          1732mmm     ENDC
000009B0                          1733mmm 
000009B0                          1734mmm     ENDM
000009B0  60E4                    1735mm     BRA LOOP_110
000009B2                          1736mm EXIT_110
000009B2                          1737mm     ENDM
000009B2                          1738m     ENDM
000009B2                          1739  
000009B2                          1740      IF.B D2 <NE> #$FF THEN.L
000009B2  B43C 00FF               1741s     CMP.B   #$FF,D2
000009B6  6700 0090               1742s     BEQ.L   _0000000A
000009BA  49FA 08C3               1743          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009BE                          1744m         PRINT_STR A4,D5
000009BE                          1745m LOOP_112
000009BE  0C14 0000               1746m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009C2  6700 0016               1747m     BEQ EXIT_112
000009C6                          1748mm     PRINT_CHAR (A4)+,D5
000009C6                          1749mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C6                 TRUE     1750mm     IFEQ DEBUG
000009C6  1A39 00C00003           1751mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009CC  0805 0002               1752mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009D0  67F4                    1753mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009D2  13DC 00C00007           1754mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009D8                          1755mm     ENDC
000009D8                          1756mm 
000009D8                 FALSE    1757mm     IFNE DEBUG
000009D8                          1758mm     ENDC
000009D8                          1759mm 
000009D8                          1760mm     ENDM
000009D8  60E4                    1761m     BRA LOOP_112
000009DA                          1762m EXIT_112
000009DA                          1763m     ENDM
000009DA                          1764m         PRINT_REG D0,D5,D2,D6,A4
000009DA  49FA 0908               1765m     LEA OX(PC),A4
000009DE                          1766mm     PRINT_STR A4,D5
000009DE                          1767mm LOOP_115
000009DE  0C14 0000               1768mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009E2  6700 0016               1769mm     BEQ EXIT_115
000009E6                          1770mmm     PRINT_CHAR (A4)+,D5
000009E6                          1771mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1772mmm     IFEQ DEBUG
000009E6  1A39 00C00003           1773mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009EC  0805 0002               1774mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1775mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009F2  13DC 00C00007           1776mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F8                          1777mmm     ENDC
000009F8                          1778mmm 
000009F8                 FALSE    1779mmm     IFNE DEBUG
000009F8                          1780mmm     ENDC
000009F8                          1781mmm 
000009F8                          1782mmm     ENDM
000009F8  60E4                    1783mm     BRA LOOP_115
000009FA                          1784mm EXIT_115
000009FA                          1785mm     ENDM
000009FA  7C07                    1786m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009FC                          1787m LOOP_114
000009FC                          1788mm     BIN2HEX D0,D2,A4
000009FC  49FA 08A5               1789mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A00  E998                    1790mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A02  1400                    1791mm     MOVE.B D0,D2
00000A04  0282 0000000F           1792mm     ANDI.L #$F,D2
00000A0A  1434 2000               1793mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000A0E                          1794mm     ENDM
00000A0E                          1795mm     PRINT_CHAR D2,D5
00000A0E                          1796mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A0E                 TRUE     1797mm     IFEQ DEBUG
00000A0E  1A39 00C00003           1798mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A14  0805 0002               1799mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A18  67F4                    1800mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A1A  13C2 00C00007           1801mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A20                          1802mm     ENDC
00000A20                          1803mm 
00000A20                 FALSE    1804mm     IFNE DEBUG
00000A20                          1805mm     ENDC
00000A20                          1806mm 
00000A20                          1807mm     ENDM
00000A20  57CE FFDA               1808m     DBEQ D6,LOOP_114
00000A24                          1809m     ENDM
00000A24                          1810m         PRINT_CRLF D5,A4
00000A24  49FA 08B8               1811m     LEA CRLF(PC),A4
00000A28                          1812mm     PRINT_STR A4,D5
00000A28                          1813mm LOOP_120
00000A28  0C14 0000               1814mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A2C  6700 0016               1815mm     BEQ EXIT_120
00000A30                          1816mmm     PRINT_CHAR (A4)+,D5
00000A30                          1817mmm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A30                 TRUE     1818mmm     IFEQ DEBUG
00000A30  1A39 00C00003           1819mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A36  0805 0002               1820mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A3A  67F4                    1821mmm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A3C  13DC 00C00007           1822mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A42                          1823mmm     ENDC
00000A42                          1824mmm 
00000A42                 FALSE    1825mmm     IFNE DEBUG
00000A42                          1826mmm     ENDC
00000A42                          1827mmm 
00000A42                          1828mmm     ENDM
00000A42  60E4                    1829mm     BRA LOOP_120
00000A44                          1830mm EXIT_120
00000A44                          1831mm     ENDM
00000A44                          1832m     ENDM
00000A44  6000 F734               1833          BRA MAIN_LOOP
00000A48                          1834      ENDI
00000A48                          1835s _0000000A
00000A48                          1836  
00000A48                          1837      IF D1 <EQ> #0 THEN
00000A48  B27C 0000               1838s     CMP.W   #0,D1
00000A4C  6600 0006               1839s     BNE _0000000B
00000A50  6000 F9B8               1840        BRA WAIT_FOR_SRECORD
00000A54                          1841      ENDI
00000A54                          1842s _0000000B
00000A54                          1843  DOWNLOAD_DONE
00000A54                          1844m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A54  43FA 088E               1845m     LEA OX(PC),A1
00000A58                          1846mm     PRINT_STR A1,D5
00000A58                          1847mm LOOP_123
00000A58  0C11 0000               1848mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A5C  6700 0016               1849mm     BEQ EXIT_123
00000A60                          1850mmm     PRINT_CHAR (A1)+,D5
00000A60                          1851mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A60                 TRUE     1852mmm     IFEQ DEBUG
00000A60  1A39 00C00003           1853mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A66  0805 0002               1854mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A6A  67F4                    1855mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A6C  13D9 00C00007           1856mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A72                          1857mmm     ENDC
00000A72                          1858mmm 
00000A72                 FALSE    1859mmm     IFNE DEBUG
00000A72                          1860mmm     ENDC
00000A72                          1861mmm 
00000A72                          1862mmm     ENDM
00000A72  60E4                    1863mm     BRA LOOP_123
00000A74                          1864mm EXIT_123
00000A74                          1865mm     ENDM
00000A74  7407                    1866m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A76                          1867m LOOP_122
00000A76                          1868mm     BIN2HEX D0,D6,A1
00000A76  43FA 082B               1869mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A7A  E998                    1870mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A7C  1C00                    1871mm     MOVE.B D0,D6
00000A7E  0286 0000000F           1872mm     ANDI.L #$F,D6
00000A84  1C31 6000               1873mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A88                          1874mm     ENDM
00000A88                          1875mm     PRINT_CHAR D6,D5
00000A88                          1876mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A88                 TRUE     1877mm     IFEQ DEBUG
00000A88  1A39 00C00003           1878mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A8E  0805 0002               1879mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A92  67F4                    1880mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A94  13C6 00C00007           1881mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A9A                          1882mm     ENDC
00000A9A                          1883mm 
00000A9A                 FALSE    1884mm     IFNE DEBUG
00000A9A                          1885mm     ENDC
00000A9A                          1886mm 
00000A9A                          1887mm     ENDM
00000A9A  57CA FFDA               1888m     DBEQ D2,LOOP_122
00000A9E                          1889m     ENDM
00000A9E  43FA 07A6               1890      LEA READ(PC),A1
00000AA2                          1891m     PRINT_STR A1,D5
00000AA2                          1892m LOOP_127
00000AA2  0C11 0000               1893m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AA6  6700 0016               1894m     BEQ EXIT_127
00000AAA                          1895mm     PRINT_CHAR (A1)+,D5
00000AAA                          1896mm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAA                 TRUE     1897mm     IFEQ DEBUG
00000AAA  1A39 00C00003           1898mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB0  0805 0002               1899mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AB4  67F4                    1900mm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000AB6  13D9 00C00007           1901mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ABC                          1902mm     ENDC
00000ABC                          1903mm 
00000ABC                 FALSE    1904mm     IFNE DEBUG
00000ABC                          1905mm     ENDC
00000ABC                          1906mm 
00000ABC                          1907mm     ENDM
00000ABC  60E4                    1908m     BRA LOOP_127
00000ABE                          1909m EXIT_127
00000ABE                          1910m     ENDM
00000ABE  2E08                    1911      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AC0                          1912m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000AC0  43FA 0822               1913m     LEA OX(PC),A1
00000AC4                          1914mm     PRINT_STR A1,D5
00000AC4                          1915mm LOOP_130
00000AC4  0C11 0000               1916mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AC8  6700 0016               1917mm     BEQ EXIT_130
00000ACC                          1918mmm     PRINT_CHAR (A1)+,D5
00000ACC                          1919mmm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACC                 TRUE     1920mmm     IFEQ DEBUG
00000ACC  1A39 00C00003           1921mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD2  0805 0002               1922mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AD6  67F4                    1923mmm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000AD8  13D9 00C00007           1924mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ADE                          1925mmm     ENDC
00000ADE                          1926mmm 
00000ADE                 FALSE    1927mmm     IFNE DEBUG
00000ADE                          1928mmm     ENDC
00000ADE                          1929mmm 
00000ADE                          1930mmm     ENDM
00000ADE  60E4                    1931mm     BRA LOOP_130
00000AE0                          1932mm EXIT_130
00000AE0                          1933mm     ENDM
00000AE0  7407                    1934m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AE2                          1935m LOOP_129
00000AE2                          1936mm     BIN2HEX D7,D6,A1
00000AE2  43FA 07BF               1937mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AE6  E99F                    1938mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AE8  1C07                    1939mm     MOVE.B D7,D6
00000AEA  0286 0000000F           1940mm     ANDI.L #$F,D6
00000AF0  1C31 6000               1941mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AF4                          1942mm     ENDM
00000AF4                          1943mm     PRINT_CHAR D6,D5
00000AF4                          1944mm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF4                 TRUE     1945mm     IFEQ DEBUG
00000AF4  1A39 00C00003           1946mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AFA  0805 0002               1947mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFE  67F4                    1948mm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B00  13C6 00C00007           1949mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B06                          1950mm     ENDC
00000B06                          1951mm 
00000B06                 FALSE    1952mm     IFNE DEBUG
00000B06                          1953mm     ENDC
00000B06                          1954mm 
00000B06                          1955mm     ENDM
00000B06  57CA FFDA               1956m     DBEQ D2,LOOP_129
00000B0A                          1957m     ENDM
00000B0A                          1958m     PRINT_CRLF D5,A4
00000B0A  49FA 07D2               1959m     LEA CRLF(PC),A4
00000B0E                          1960mm     PRINT_STR A4,D5
00000B0E                          1961mm LOOP_135
00000B0E  0C14 0000               1962mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B12  6700 0016               1963mm     BEQ EXIT_135
00000B16                          1964mmm     PRINT_CHAR (A4)+,D5
00000B16                          1965mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B16                 TRUE     1966mmm     IFEQ DEBUG
00000B16  1A39 00C00003           1967mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B1C  0805 0002               1968mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B20  67F4                    1969mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B22  13DC 00C00007           1970mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B28                          1971mmm     ENDC
00000B28                          1972mmm 
00000B28                 FALSE    1973mmm     IFNE DEBUG
00000B28                          1974mmm     ENDC
00000B28                          1975mmm 
00000B28                          1976mmm     ENDM
00000B28  60E4                    1977mm     BRA LOOP_135
00000B2A                          1978mm EXIT_135
00000B2A                          1979mm     ENDM
00000B2A                          1980m     ENDM
00000B2A                          1981  
00000B2A  6000 F64E               1982      BRA MAIN_LOOP
00000B2E                          1983  
00000B2E                          1984  G
00000B2E  2047                    1985      MOVE.L D7,A0                                    ; address accumulator -> address register
00000B30  3E3C 0000               1986      MOVE #0,D7                                      ; clear the now used address accumulator
00000B34  4ED0                    1987      JMP (A0)                                        ; jump to it!
00000B36                          1988  
00000B36                          1989  Z
00000B36  207C 00200000           1990      MOVE.L #RAM,A0                                  ; address of RAM
00000B3C  D1FC 00100000           1991      ADD.L #$100000,A0
00000B42                          1992  
00000B42                          1993      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000B42  7000                    1994s     MOVE.L  #0,D0
00000B44  6000 0012               1995s     BRA _20000005
00000B48                          1996s _20000004
00000B48  2200                    1997          MOVE.L D0,D1                                ; progress update
00000B4A  E089                    1998          LSR.L #8,D1 
00000B4C  E089                    1999          LSR.L #8,D1
00000B4E  13C1 00E00001           2000          MOVE.B D1,DISPLAY
00000B54                          2001          
00000B54  2108                    2002          MOVE.L A0,-(A0)
00000B56                          2003      ENDF
00000B56  5880                    2004s     ADD.L   #4,D0
00000B58                          2005s _20000005
00000B58  B0BC 000FFFFC           2006s     CMP.L   #$FFFFC,D0
00000B5E  6FE8                    2007s     BLE _20000004
00000B60                          2008  
00000B60  207C 00200000           2009      MOVE.L #RAM,A0                                  ; address of RAM
00000B66  D1FC 00100000           2010      ADD.L #$100000,A0
00000B6C                          2011  
00000B6C                          2012      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000B6C  7000                    2013s     MOVE.L  #0,D0
00000B6E  6000 00A8               2014s     BRA _20000007
00000B72                          2015s _20000006
00000B72  2200                    2016          MOVE.L D0,D1                                ; progress update
00000B74  E089                    2017          LSR.L #8,D1
00000B76  E089                    2018          LSR.L #8,D1
00000B78  13C1 00E00001           2019          MOVE.B D1,DISPLAY
00000B7E                          2020  
00000B7E  2408                    2021          MOVE.L A0,D2
00000B80  2220                    2022          MOVE.L -(A0),D1
00000B82                          2023  
00000B82                          2024          IF.L D2 <NE> D1 THEN
00000B82  B481                    2025s     CMP.L   D1,D2
00000B84  6700 0090               2026s     BEQ _0000000C
00000B88  43FA 0707               2027              LEA RAM_ERROR(PC),A1
00000B8C                          2028m             PRINT_STR A1,D1
00000B8C                          2029m LOOP_137
00000B8C  0C11 0000               2030m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B90  6700 0016               2031m     BEQ EXIT_137
00000B94                          2032mm     PRINT_CHAR (A1)+,D1
00000B94                          2033mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B94                 TRUE     2034mm     IFEQ DEBUG
00000B94  1239 00C00003           2035mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B9A  0801 0002               2036mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B9E  67F4                    2037mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000BA0  13D9 00C00007           2038mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BA6                          2039mm     ENDC
00000BA6                          2040mm 
00000BA6                 FALSE    2041mm     IFNE DEBUG
00000BA6                          2042mm     ENDC
00000BA6                          2043mm 
00000BA6                          2044mm     ENDM
00000BA6  60E4                    2045m     BRA LOOP_137
00000BA8                          2046m EXIT_137
00000BA8                          2047m     ENDM
00000BA8  2208                    2048              MOVE.L A0,D1
00000BAA  5981                    2049              SUB.L #4,D1
00000BAC                          2050m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000BAC  43FA 0736               2051m     LEA OX(PC),A1
00000BB0                          2052mm     PRINT_STR A1,D3
00000BB0                          2053mm LOOP_140
00000BB0  0C11 0000               2054mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BB4  6700 0016               2055mm     BEQ EXIT_140
00000BB8                          2056mmm     PRINT_CHAR (A1)+,D3
00000BB8                          2057mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB8                 TRUE     2058mmm     IFEQ DEBUG
00000BB8  1639 00C00003           2059mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BBE  0803 0002               2060mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BC2  67F4                    2061mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000BC4  13D9 00C00007           2062mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BCA                          2063mmm     ENDC
00000BCA                          2064mmm 
00000BCA                 FALSE    2065mmm     IFNE DEBUG
00000BCA                          2066mmm     ENDC
00000BCA                          2067mmm 
00000BCA                          2068mmm     ENDM
00000BCA  60E4                    2069mm     BRA LOOP_140
00000BCC                          2070mm EXIT_140
00000BCC                          2071mm     ENDM
00000BCC  7C07                    2072m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BCE                          2073m LOOP_139
00000BCE                          2074mm     BIN2HEX D1,D2,A1
00000BCE  43FA 06D3               2075mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BD2  E999                    2076mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BD4  1401                    2077mm     MOVE.B D1,D2
00000BD6  0282 0000000F           2078mm     ANDI.L #$F,D2
00000BDC  1431 2000               2079mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000BE0                          2080mm     ENDM
00000BE0                          2081mm     PRINT_CHAR D2,D3
00000BE0                          2082mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE0                 TRUE     2083mm     IFEQ DEBUG
00000BE0  1639 00C00003           2084mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BE6  0803 0002               2085mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BEA  67F4                    2086mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000BEC  13C2 00C00007           2087mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BF2                          2088mm     ENDC
00000BF2                          2089mm 
00000BF2                 FALSE    2090mm     IFNE DEBUG
00000BF2                          2091mm     ENDC
00000BF2                          2092mm 
00000BF2                          2093mm     ENDM
00000BF2  57CE FFDA               2094m     DBEQ D6,LOOP_139
00000BF6                          2095m     ENDM
00000BF6                          2096m             PRINT_CRLF D3,A1
00000BF6  43FA 06E6               2097m     LEA CRLF(PC),A1
00000BFA                          2098mm     PRINT_STR A1,D3
00000BFA                          2099mm LOOP_145
00000BFA  0C11 0000               2100mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BFE  6700 0016               2101mm     BEQ EXIT_145
00000C02                          2102mmm     PRINT_CHAR (A1)+,D3
00000C02                          2103mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C02                 TRUE     2104mmm     IFEQ DEBUG
00000C02  1639 00C00003           2105mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C08  0803 0002               2106mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C0C  67F4                    2107mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C0E  13D9 00C00007           2108mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C14                          2109mmm     ENDC
00000C14                          2110mmm 
00000C14                 FALSE    2111mmm     IFNE DEBUG
00000C14                          2112mmm     ENDC
00000C14                          2113mmm 
00000C14                          2114mmm     ENDM
00000C14  60E4                    2115mm     BRA LOOP_145
00000C16                          2116mm EXIT_145
00000C16                          2117mm     ENDM
00000C16                          2118m     ENDM
00000C16                          2119          ENDI 
00000C16                          2120s _0000000C
00000C16                          2121      ENDF
00000C16  5880                    2122s     ADD.L   #4,D0
00000C18                          2123s _20000007
00000C18  B0BC 000FFFFC           2124s     CMP.L   #$FFFFC,D0
00000C1E  6F00 FF52               2125s     BLE _20000006
00000C22                          2126  
00000C22  6000 F556               2127      BRA MAIN_LOOP
00000C26                          2128  
00000C26                          2129  L
00000C26  7000                    2130      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C28  7200                    2131      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C2A                          2132  
00000C2A                          2133      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C2A  343C 0000               2134s     MOVE.W  #0,D2
00000C2E  6000 0046               2135s     BRA _20000009
00000C32                          2136s _20000008
00000C32  E989                    2137          LSL.L #4,D1                                 ; make what we have so far more significant
00000C34                          2138m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C34                          2139m WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C34                 TRUE     2140m     IFEQ DEBUG
00000C34  1839 00C00003           2141m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C3A  0804 0000               2142m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000C3E  67F4                    2143m         BEQ WAIT_FOR_READY_147                      ; NOTHING, CHECK AGAIN
00000C40                          2144m     ENDC
00000C40                          2145m 
00000C40                          2146mm     READ_CHAR D3
00000C40                 TRUE     2147mm     IFEQ DEBUG
00000C40  1639 00C00007           2148mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000C46                          2149mm     ENDC
00000C46                 FALSE    2150mm     IFNE DEBUG
00000C46                          2151mm     ENDC
00000C46                          2152mm 
00000C46  B63C 001B               2153mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000C4A  6700 F3BC               2154mm     BEQ START
00000C4E                          2155mm     ENDM
00000C4E                          2156m 
00000C4E                 TRUE     2157m     IFEQ DEBUG
00000C4E                          2158mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000C4E                          2159mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4E                 TRUE     2160mm     IFEQ DEBUG
00000C4E  1839 00C00003           2161mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C54  0804 0002               2162mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000C58  67F4                    2163mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C5A  13C3 00C00007           2164mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C60                          2165mm     ENDC
00000C60                          2166mm 
00000C60                 FALSE    2167mm     IFNE DEBUG
00000C60                          2168mm     ENDC
00000C60                          2169mm 
00000C60                          2170mm     ENDM
00000C60                          2171m     ENDC
00000C60                          2172m     ENDM
00000C60                          2173m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C60  41FA 0651               2174m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C64  0403 0030               2175m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C68  C6BC 000000FF           2176m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000C6E  1630 3000               2177m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C72                          2178m     ENDM
00000C72  8203                    2179          OR.B D3,D1
00000C74                          2180      ENDF
00000C74  5242                    2181s     ADD.W   #1,D2
00000C76                          2182s _20000009
00000C76  B47C 0007               2183s     CMP.W   #7,D2
00000C7A  6FB6                    2184s     BLE _20000008
00000C7C                          2185  
00000C7C  3001                    2186      MOVE.W D1,D0                                    ; extract the LSword for the length
00000C7E  E089                    2187      LSR.L #8,D1                                     ; extract the MSword for the address
00000C80  E089                    2188      LSR.L #8,D1
00000C82                          2189  
00000C82                          2190m     PRINT_CRLF D2,A1
00000C82  43FA 065A               2191m     LEA CRLF(PC),A1
00000C86                          2192mm     PRINT_STR A1,D2
00000C86                          2193mm LOOP_152
00000C86  0C11 0000               2194mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C8A  6700 0016               2195mm     BEQ EXIT_152
00000C8E                          2196mmm     PRINT_CHAR (A1)+,D2
00000C8E                          2197mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     2198mmm     IFEQ DEBUG
00000C8E  1439 00C00003           2199mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C94  0802 0002               2200mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    2201mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000C9A  13D9 00C00007           2202mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA0                          2203mmm     ENDC
00000CA0                          2204mmm 
00000CA0                 FALSE    2205mmm     IFNE DEBUG
00000CA0                          2206mmm     ENDC
00000CA0                          2207mmm 
00000CA0                          2208mmm     ENDM
00000CA0  60E4                    2209mm     BRA LOOP_152
00000CA2                          2210mm EXIT_152
00000CA2                          2211mm     ENDM
00000CA2                          2212m     ENDM
00000CA2                          2213  
00000CA2  2041                    2214      MOVE.L D1,A0                                    ; target address
00000CA4                          2215  
00000CA4  2247                    2216      MOVE.L D7,A1                                    ; address accumulator -> address register
00000CA6  7E00                    2217      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000CA8                          2218  
00000CA8  5089                    2219      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000CAA  5180                    2220      SUB.L #8,D0
00000CAC                          2221  
00000CAC                          2222m     UNPROTECT
00000CAC  31FC AAAA 2AAA          2223m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000CB2  4E71                    2224m     NOP
00000CB4  31FC 5555 1554          2225m     MOVE.W #$5555,$1554
00000CBA  4E71                    2226m     NOP
00000CBC  31FC 8080 2AAA          2227m     MOVE.W #$8080,$2AAA
00000CC2  4E71                    2228m     NOP
00000CC4  31FC AAAA 2AAA          2229m     MOVE.W #$AAAA,$2AAA
00000CCA  4E71                    2230m     NOP
00000CCC  31FC 5555 1554          2231m     MOVE.W #$5555,$1554
00000CD2  4E71                    2232m     NOP
00000CD4  31FC 2020 2AAA          2233m     MOVE.W #$2020,$2AAA
00000CDA                          2234m     ENDM
00000CDA                          2235  
00000CDA  45FA 05EE               2236      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000CDE                          2237m     PRINT_STR A2,D2
00000CDE                          2238m LOOP_155
00000CDE  0C12 0000               2239m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CE2  6700 0016               2240m     BEQ EXIT_155
00000CE6                          2241mm     PRINT_CHAR (A2)+,D2
00000CE6                          2242mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE6                 TRUE     2243mm     IFEQ DEBUG
00000CE6  1439 00C00003           2244mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CEC  0802 0002               2245mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CF0  67F4                    2246mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000CF2  13DA 00C00007           2247mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CF8                          2248mm     ENDC
00000CF8                          2249mm 
00000CF8                 FALSE    2250mm     IFNE DEBUG
00000CF8                          2251mm     ENDC
00000CF8                          2252mm 
00000CF8                          2253mm     ENDM
00000CF8  60E4                    2254m     BRA LOOP_155
00000CFA                          2255m EXIT_155
00000CFA                          2256m     ENDM
00000CFA                          2257  
00000CFA  2409                    2258      MOVE.L A1,D2
00000CFC                          2259m     PRINT_REG D2,D3,D4,D5,A2
00000CFC  45FA 05E6               2260m     LEA OX(PC),A2
00000D00                          2261mm     PRINT_STR A2,D3
00000D00                          2262mm LOOP_158
00000D00  0C12 0000               2263mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D04  6700 0016               2264mm     BEQ EXIT_158
00000D08                          2265mmm     PRINT_CHAR (A2)+,D3
00000D08                          2266mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D08                 TRUE     2267mmm     IFEQ DEBUG
00000D08  1639 00C00003           2268mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D0E  0803 0002               2269mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D12  67F4                    2270mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000D14  13DA 00C00007           2271mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D1A                          2272mmm     ENDC
00000D1A                          2273mmm 
00000D1A                 FALSE    2274mmm     IFNE DEBUG
00000D1A                          2275mmm     ENDC
00000D1A                          2276mmm 
00000D1A                          2277mmm     ENDM
00000D1A  60E4                    2278mm     BRA LOOP_158
00000D1C                          2279mm EXIT_158
00000D1C                          2280mm     ENDM
00000D1C  7A07                    2281m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D1E                          2282m LOOP_157
00000D1E                          2283mm     BIN2HEX D2,D4,A2
00000D1E  45FA 0583               2284mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D22  E99A                    2285mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D24  1802                    2286mm     MOVE.B D2,D4
00000D26  0284 0000000F           2287mm     ANDI.L #$F,D4
00000D2C  1832 4000               2288mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D30                          2289mm     ENDM
00000D30                          2290mm     PRINT_CHAR D4,D3
00000D30                          2291mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D30                 TRUE     2292mm     IFEQ DEBUG
00000D30  1639 00C00003           2293mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D36  0803 0002               2294mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D3A  67F4                    2295mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D3C  13C4 00C00007           2296mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D42                          2297mm     ENDC
00000D42                          2298mm 
00000D42                 FALSE    2299mm     IFNE DEBUG
00000D42                          2300mm     ENDC
00000D42                          2301mm 
00000D42                          2302mm     ENDM
00000D42  57CD FFDA               2303m     DBEQ D5,LOOP_157
00000D46                          2304m     ENDM
00000D46                          2305  
00000D46  45FA 059F               2306      LEA TO(PC),A2
00000D4A                          2307m     PRINT_STR A2,D3
00000D4A                          2308m LOOP_162
00000D4A  0C12 0000               2309m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D4E  6700 0016               2310m     BEQ EXIT_162
00000D52                          2311mm     PRINT_CHAR (A2)+,D3
00000D52                          2312mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D52                 TRUE     2313mm     IFEQ DEBUG
00000D52  1639 00C00003           2314mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D58  0803 0002               2315mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D5C  67F4                    2316mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000D5E  13DA 00C00007           2317mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D64                          2318mm     ENDC
00000D64                          2319mm 
00000D64                 FALSE    2320mm     IFNE DEBUG
00000D64                          2321mm     ENDC
00000D64                          2322mm 
00000D64                          2323mm     ENDM
00000D64  60E4                    2324m     BRA LOOP_162
00000D66                          2325m EXIT_162
00000D66                          2326m     ENDM
00000D66                          2327  
00000D66  2408                    2328      MOVE.L A0,D2
00000D68                          2329m     PRINT_REG D2,D3,D4,D5,A2
00000D68  45FA 057A               2330m     LEA OX(PC),A2
00000D6C                          2331mm     PRINT_STR A2,D3
00000D6C                          2332mm LOOP_165
00000D6C  0C12 0000               2333mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D70  6700 0016               2334mm     BEQ EXIT_165
00000D74                          2335mmm     PRINT_CHAR (A2)+,D3
00000D74                          2336mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D74                 TRUE     2337mmm     IFEQ DEBUG
00000D74  1639 00C00003           2338mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D7A  0803 0002               2339mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D7E  67F4                    2340mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000D80  13DA 00C00007           2341mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D86                          2342mmm     ENDC
00000D86                          2343mmm 
00000D86                 FALSE    2344mmm     IFNE DEBUG
00000D86                          2345mmm     ENDC
00000D86                          2346mmm 
00000D86                          2347mmm     ENDM
00000D86  60E4                    2348mm     BRA LOOP_165
00000D88                          2349mm EXIT_165
00000D88                          2350mm     ENDM
00000D88  7A07                    2351m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D8A                          2352m LOOP_164
00000D8A                          2353mm     BIN2HEX D2,D4,A2
00000D8A  45FA 0517               2354mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D8E  E99A                    2355mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D90  1802                    2356mm     MOVE.B D2,D4
00000D92  0284 0000000F           2357mm     ANDI.L #$F,D4
00000D98  1832 4000               2358mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D9C                          2359mm     ENDM
00000D9C                          2360mm     PRINT_CHAR D4,D3
00000D9C                          2361mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D9C                 TRUE     2362mm     IFEQ DEBUG
00000D9C  1639 00C00003           2363mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA2  0803 0002               2364mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DA6  67F4                    2365mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000DA8  13C4 00C00007           2366mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DAE                          2367mm     ENDC
00000DAE                          2368mm 
00000DAE                 FALSE    2369mm     IFNE DEBUG
00000DAE                          2370mm     ENDC
00000DAE                          2371mm 
00000DAE                          2372mm     ENDM
00000DAE  57CD FFDA               2373m     DBEQ D5,LOOP_164
00000DB2                          2374m     ENDM
00000DB2                          2375  
00000DB2                          2376m     PRINT_CRLF D3,A2
00000DB2  45FA 052A               2377m     LEA CRLF(PC),A2
00000DB6                          2378mm     PRINT_STR A2,D3
00000DB6                          2379mm LOOP_170
00000DB6  0C12 0000               2380mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DBA  6700 0016               2381mm     BEQ EXIT_170
00000DBE                          2382mmm     PRINT_CHAR (A2)+,D3
00000DBE                          2383mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBE                 TRUE     2384mmm     IFEQ DEBUG
00000DBE  1639 00C00003           2385mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC4  0803 0002               2386mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DC8  67F4                    2387mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DCA  13DA 00C00007           2388mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DD0                          2389mmm     ENDC
00000DD0                          2390mmm 
00000DD0                 FALSE    2391mmm     IFNE DEBUG
00000DD0                          2392mmm     ENDC
00000DD0                          2393mmm 
00000DD0                          2394mmm     ENDM
00000DD0  60E4                    2395mm     BRA LOOP_170
00000DD2                          2396mm EXIT_170
00000DD2                          2397mm     ENDM
00000DD2                          2398m     ENDM
00000DD2                          2399  
00000DD2                          2400      WHILE D0 <GT> #0 DO
00000DD2                          2401s _10000014
00000DD2  B07C 0000               2402s     CMP.W   #0,D0
00000DD6  6F00 001C               2403s     BLE _10000015
00000DDA  5580                    2404          SUB.L #2,D0
00000DDC                          2405  
00000DDC  13D1 00E00001           2406          MOVE.B (A1),DISPLAY
00000DE2                          2407m         PROGRAM (A1),(A0),D2
00000DE2  3091                    2408m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000DE4                          2409m 
00000DE4                          2410m WAIT_FOR_COMPLETE_172
00000DE4  3410                    2411m         MOVE.W (A0),D2
00000DE6                          2412m 
00000DE6                          2413m         IF.W D2 <NE> (A1) THEN
00000DE6  B451                    2414ms     CMP.W   (A1),D2
00000DE8  6700 0004               2415ms     BEQ _0000000D
00000DEC  60F6                    2416m             BRA WAIT_FOR_COMPLETE_172
00000DEE                          2417m         ENDI
00000DEE                          2418ms _0000000D
00000DEE                          2419m         ENDM
00000DEE                          2420  
00000DEE  5488                    2421          ADD.L #2,A0
00000DF0  5489                    2422          ADD.L #2,A1
00000DF2                          2423      ENDW
00000DF2  60DE                    2424s     BRA _10000014
00000DF4                          2425s _10000015
00000DF4                          2426  
00000DF4                          2427m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000DF4  31FC 0000 0000          2428m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000DFA                          2429m 
00000DFA                          2430m WAIT_FOR_COMPLETE_173
00000DFA  3438 0000               2431m         MOVE.W $0,D2
00000DFE                          2432m 
00000DFE                          2433m         IF.W D2 <NE> #0 THEN
00000DFE  B47C 0000               2434ms     CMP.W   #0,D2
00000E02  6700 0004               2435ms     BEQ _0000000E
00000E06  60F2                    2436m             BRA WAIT_FOR_COMPLETE_173
00000E08                          2437m         ENDI
00000E08                          2438ms _0000000E
00000E08                          2439m         ENDM
00000E08                          2440m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000E08  31FC 0000 0002          2441m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000E0E                          2442m 
00000E0E                          2443m WAIT_FOR_COMPLETE_174
00000E0E  3438 0002               2444m         MOVE.W $2,D2
00000E12                          2445m 
00000E12                          2446m         IF.W D2 <NE> #0 THEN
00000E12  B47C 0000               2447ms     CMP.W   #0,D2
00000E16  6700 0004               2448ms     BEQ _0000000F
00000E1A  60F2                    2449m             BRA WAIT_FOR_COMPLETE_174
00000E1C                          2450m         ENDI
00000E1C                          2451ms _0000000F
00000E1C                          2452m         ENDM
00000E1C                          2453  
00000E1C                          2454m     PROGRAM D1, $6, D2
00000E1C  31C1 0006               2455m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000E20                          2456m 
00000E20                          2457m WAIT_FOR_COMPLETE_175
00000E20  3438 0006               2458m         MOVE.W $6,D2
00000E24                          2459m 
00000E24                          2460m         IF.W D2 <NE> D1 THEN
00000E24  B441                    2461ms     CMP.W   D1,D2
00000E26  6700 0004               2462ms     BEQ _00000010
00000E2A  60F4                    2463m             BRA WAIT_FOR_COMPLETE_175
00000E2C                          2464m         ENDI
00000E2C                          2465ms _00000010
00000E2C                          2466m         ENDM
00000E2C  E089                    2467      LSR.L #8,D1
00000E2E  E089                    2468      LSR.L #8,D1
00000E30                          2469m     PROGRAM D1, $4, D2
00000E30  31C1 0004               2470m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000E34                          2471m 
00000E34                          2472m WAIT_FOR_COMPLETE_176
00000E34  3438 0004               2473m         MOVE.W $4,D2
00000E38                          2474m 
00000E38                          2475m         IF.W D2 <NE> D1 THEN
00000E38  B441                    2476ms     CMP.W   D1,D2
00000E3A  6700 0004               2477ms     BEQ _00000011
00000E3E  60F4                    2478m             BRA WAIT_FOR_COMPLETE_176
00000E40                          2479m         ENDI
00000E40                          2480ms _00000011
00000E40                          2481m         ENDM
00000E40                          2482  
00000E40                          2483m     PROTECT
00000E40  31FC AAAA 2AAA          2484m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000E46  31FC 5555 1554          2485m     MOVE.W #$5555,$1554
00000E4C  31FC A0A0 2AAA          2486m     MOVE.W #$A0A0,$2AAA
00000E52                          2487m     ENDM
00000E52                          2488  
00000E52  6000 F326               2489      BRA MAIN_LOOP
00000E56                          2490  
00000E56                          2491  P
00000E56  7000                    2492      MOVE.L #0,D0                                    ; D0 will be the data to write
00000E58                          2493  
00000E58                          2494      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000E58  323C 0000               2495s     MOVE.W  #0,D1
00000E5C  6000 0046               2496s     BRA _2000000B
00000E60                          2497s _2000000A
00000E60  E988                    2498          LSL.L #4,D0                                 ; make what we have so far more significant
00000E62                          2499m         WAIT_CHAR D2,D3                             ; next character -> D2
00000E62                          2500m WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E62                 TRUE     2501m     IFEQ DEBUG
00000E62  1639 00C00003           2502m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E68  0803 0000               2503m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000E6C  67F4                    2504m         BEQ WAIT_FOR_READY_178                      ; NOTHING, CHECK AGAIN
00000E6E                          2505m     ENDC
00000E6E                          2506m 
00000E6E                          2507mm     READ_CHAR D2
00000E6E                 TRUE     2508mm     IFEQ DEBUG
00000E6E  1439 00C00007           2509mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000E74                          2510mm     ENDC
00000E74                 FALSE    2511mm     IFNE DEBUG
00000E74                          2512mm     ENDC
00000E74                          2513mm 
00000E74  B43C 001B               2514mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000E78  6700 F18E               2515mm     BEQ START
00000E7C                          2516mm     ENDM
00000E7C                          2517m 
00000E7C                 TRUE     2518m     IFEQ DEBUG
00000E7C                          2519mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000E7C                          2520mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7C                 TRUE     2521mm     IFEQ DEBUG
00000E7C  1639 00C00003           2522mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E82  0803 0002               2523mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E86  67F4                    2524mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000E88  13C2 00C00007           2525mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E8E                          2526mm     ENDC
00000E8E                          2527mm 
00000E8E                 FALSE    2528mm     IFNE DEBUG
00000E8E                          2529mm     ENDC
00000E8E                          2530mm 
00000E8E                          2531mm     ENDM
00000E8E                          2532m     ENDC
00000E8E                          2533m     ENDM
00000E8E                          2534m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000E8E  41FA 0423               2535m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E92  0402 0030               2536m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E96  C4BC 000000FF           2537m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000E9C  1430 2000               2538m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000EA0                          2539m     ENDM
00000EA0  8002                    2540          OR.B D2,D0
00000EA2                          2541      ENDF
00000EA2  5241                    2542s     ADD.W   #1,D1
00000EA4                          2543s _2000000B
00000EA4  B27C 0003               2544s     CMP.W   #3,D1
00000EA8  6FB6                    2545s     BLE _2000000A
00000EAA                          2546  
00000EAA                          2547m     PRINT_CRLF D2,A1
00000EAA  43FA 0432               2548m     LEA CRLF(PC),A1
00000EAE                          2549mm     PRINT_STR A1,D2
00000EAE                          2550mm LOOP_183
00000EAE  0C11 0000               2551mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000EB2  6700 0016               2552mm     BEQ EXIT_183
00000EB6                          2553mmm     PRINT_CHAR (A1)+,D2
00000EB6                          2554mmm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB6                 TRUE     2555mmm     IFEQ DEBUG
00000EB6  1439 00C00003           2556mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EBC  0802 0002               2557mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EC0  67F4                    2558mmm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00000EC2  13D9 00C00007           2559mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EC8                          2560mmm     ENDC
00000EC8                          2561mmm 
00000EC8                 FALSE    2562mmm     IFNE DEBUG
00000EC8                          2563mmm     ENDC
00000EC8                          2564mmm 
00000EC8                          2565mmm     ENDM
00000EC8  60E4                    2566mm     BRA LOOP_183
00000ECA                          2567mm EXIT_183
00000ECA                          2568mm     ENDM
00000ECA                          2569m     ENDM
00000ECA                          2570  
00000ECA  2047                    2571      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000ECC  7E00                    2572      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000ECE                          2573  
00000ECE                          2574m     UNPROTECT
00000ECE  31FC AAAA 2AAA          2575m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000ED4  4E71                    2576m     NOP
00000ED6  31FC 5555 1554          2577m     MOVE.W #$5555,$1554
00000EDC  4E71                    2578m     NOP
00000EDE  31FC 8080 2AAA          2579m     MOVE.W #$8080,$2AAA
00000EE4  4E71                    2580m     NOP
00000EE6  31FC AAAA 2AAA          2581m     MOVE.W #$AAAA,$2AAA
00000EEC  4E71                    2582m     NOP
00000EEE  31FC 5555 1554          2583m     MOVE.W #$5555,$1554
00000EF4  4E71                    2584m     NOP
00000EF6  31FC 2020 2AAA          2585m     MOVE.W #$2020,$2AAA
00000EFC                          2586m     ENDM
00000EFC                          2587               
00000EFC  45FA 03CC               2588      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000F00                          2589m     PRINT_STR A2,D2
00000F00                          2590m LOOP_186
00000F00  0C12 0000               2591m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F04  6700 0016               2592m     BEQ EXIT_186
00000F08                          2593mm     PRINT_CHAR (A2)+,D2
00000F08                          2594mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F08                 TRUE     2595mm     IFEQ DEBUG
00000F08  1439 00C00003           2596mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F0E  0802 0002               2597mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F12  67F4                    2598mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00000F14  13DA 00C00007           2599mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F1A                          2600mm     ENDC
00000F1A                          2601mm 
00000F1A                 FALSE    2602mm     IFNE DEBUG
00000F1A                          2603mm     ENDC
00000F1A                          2604mm 
00000F1A                          2605mm     ENDM
00000F1A  60E4                    2606m     BRA LOOP_186
00000F1C                          2607m EXIT_186
00000F1C                          2608m     ENDM
00000F1C                          2609  
00000F1C                          2610m     PRINT_CHAR '#',D3
00000F1C                          2611m WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F1C                 TRUE     2612m     IFEQ DEBUG
00000F1C  1639 00C00003           2613m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F22  0803 0002               2614m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F26  67F4                    2615m         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000F28  13F8 0023 00C00007      2616m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000F30                          2617m     ENDC
00000F30                          2618m 
00000F30                 FALSE    2619m     IFNE DEBUG
00000F30                          2620m     ENDC
00000F30                          2621m 
00000F30                          2622m     ENDM
00000F30                          2623m     PRINT_REG D0,D3,D4,D5,A2
00000F30  45FA 03B2               2624m     LEA OX(PC),A2
00000F34                          2625mm     PRINT_STR A2,D3
00000F34                          2626mm LOOP_190
00000F34  0C12 0000               2627mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F38  6700 0016               2628mm     BEQ EXIT_190
00000F3C                          2629mmm     PRINT_CHAR (A2)+,D3
00000F3C                          2630mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F3C                 TRUE     2631mmm     IFEQ DEBUG
00000F3C  1639 00C00003           2632mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F42  0803 0002               2633mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F46  67F4                    2634mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
00000F48  13DA 00C00007           2635mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F4E                          2636mmm     ENDC
00000F4E                          2637mmm 
00000F4E                 FALSE    2638mmm     IFNE DEBUG
00000F4E                          2639mmm     ENDC
00000F4E                          2640mmm 
00000F4E                          2641mmm     ENDM
00000F4E  60E4                    2642mm     BRA LOOP_190
00000F50                          2643mm EXIT_190
00000F50                          2644mm     ENDM
00000F50  7A07                    2645m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F52                          2646m LOOP_189
00000F52                          2647mm     BIN2HEX D0,D4,A2
00000F52  45FA 034F               2648mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F56  E998                    2649mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F58  1800                    2650mm     MOVE.B D0,D4
00000F5A  0284 0000000F           2651mm     ANDI.L #$F,D4
00000F60  1832 4000               2652mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F64                          2653mm     ENDM
00000F64                          2654mm     PRINT_CHAR D4,D3
00000F64                          2655mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F64                 TRUE     2656mm     IFEQ DEBUG
00000F64  1639 00C00003           2657mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F6A  0803 0002               2658mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F6E  67F4                    2659mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00000F70  13C4 00C00007           2660mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F76                          2661mm     ENDC
00000F76                          2662mm 
00000F76                 FALSE    2663mm     IFNE DEBUG
00000F76                          2664mm     ENDC
00000F76                          2665mm 
00000F76                          2666mm     ENDM
00000F76  57CD FFDA               2667m     DBEQ D5,LOOP_189
00000F7A                          2668m     ENDM
00000F7A                          2669  
00000F7A  45FA 036B               2670      LEA TO(PC),A2
00000F7E                          2671m     PRINT_STR A2,D3
00000F7E                          2672m LOOP_194
00000F7E  0C12 0000               2673m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F82  6700 0016               2674m     BEQ EXIT_194
00000F86                          2675mm     PRINT_CHAR (A2)+,D3
00000F86                          2676mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F86                 TRUE     2677mm     IFEQ DEBUG
00000F86  1639 00C00003           2678mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F8C  0803 0002               2679mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F90  67F4                    2680mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
00000F92  13DA 00C00007           2681mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F98                          2682mm     ENDC
00000F98                          2683mm 
00000F98                 FALSE    2684mm     IFNE DEBUG
00000F98                          2685mm     ENDC
00000F98                          2686mm 
00000F98                          2687mm     ENDM
00000F98  60E4                    2688m     BRA LOOP_194
00000F9A                          2689m EXIT_194
00000F9A                          2690m     ENDM
00000F9A                          2691  
00000F9A  2408                    2692      MOVE.L A0,D2
00000F9C                          2693m     PRINT_REG D2,D3,D4,D5,A2
00000F9C  45FA 0346               2694m     LEA OX(PC),A2
00000FA0                          2695mm     PRINT_STR A2,D3
00000FA0                          2696mm LOOP_197
00000FA0  0C12 0000               2697mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FA4  6700 0016               2698mm     BEQ EXIT_197
00000FA8                          2699mmm     PRINT_CHAR (A2)+,D3
00000FA8                          2700mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FA8                 TRUE     2701mmm     IFEQ DEBUG
00000FA8  1639 00C00003           2702mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FAE  0803 0002               2703mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FB2  67F4                    2704mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
00000FB4  13DA 00C00007           2705mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FBA                          2706mmm     ENDC
00000FBA                          2707mmm 
00000FBA                 FALSE    2708mmm     IFNE DEBUG
00000FBA                          2709mmm     ENDC
00000FBA                          2710mmm 
00000FBA                          2711mmm     ENDM
00000FBA  60E4                    2712mm     BRA LOOP_197
00000FBC                          2713mm EXIT_197
00000FBC                          2714mm     ENDM
00000FBC  7A07                    2715m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FBE                          2716m LOOP_196
00000FBE                          2717mm     BIN2HEX D2,D4,A2
00000FBE  45FA 02E3               2718mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FC2  E99A                    2719mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FC4  1802                    2720mm     MOVE.B D2,D4
00000FC6  0284 0000000F           2721mm     ANDI.L #$F,D4
00000FCC  1832 4000               2722mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FD0                          2723mm     ENDM
00000FD0                          2724mm     PRINT_CHAR D4,D3
00000FD0                          2725mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD0                 TRUE     2726mm     IFEQ DEBUG
00000FD0  1639 00C00003           2727mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FD6  0803 0002               2728mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FDA  67F4                    2729mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00000FDC  13C4 00C00007           2730mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FE2                          2731mm     ENDC
00000FE2                          2732mm 
00000FE2                 FALSE    2733mm     IFNE DEBUG
00000FE2                          2734mm     ENDC
00000FE2                          2735mm 
00000FE2                          2736mm     ENDM
00000FE2  57CD FFDA               2737m     DBEQ D5,LOOP_196
00000FE6                          2738m     ENDM
00000FE6                          2739  
00000FE6                          2740m     PRINT_CRLF D3,A2
00000FE6  45FA 02F6               2741m     LEA CRLF(PC),A2
00000FEA                          2742mm     PRINT_STR A2,D3
00000FEA                          2743mm LOOP_202
00000FEA  0C12 0000               2744mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FEE  6700 0016               2745mm     BEQ EXIT_202
00000FF2                          2746mmm     PRINT_CHAR (A2)+,D3
00000FF2                          2747mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF2                 TRUE     2748mmm     IFEQ DEBUG
00000FF2  1639 00C00003           2749mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FF8  0803 0002               2750mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FFC  67F4                    2751mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00000FFE  13DA 00C00007           2752mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001004                          2753mmm     ENDC
00001004                          2754mmm 
00001004                 FALSE    2755mmm     IFNE DEBUG
00001004                          2756mmm     ENDC
00001004                          2757mmm 
00001004                          2758mmm     ENDM
00001004  60E4                    2759mm     BRA LOOP_202
00001006                          2760mm EXIT_202
00001006                          2761mm     ENDM
00001006                          2762m     ENDM
00001006                          2763  
00001006                          2764m     PROGRAM D0,(A0),D2
00001006  3080                    2765m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001008                          2766m 
00001008                          2767m WAIT_FOR_COMPLETE_204
00001008  3410                    2768m         MOVE.W (A0),D2
0000100A                          2769m 
0000100A                          2770m         IF.W D2 <NE> D0 THEN
0000100A  B440                    2771ms     CMP.W   D0,D2
0000100C  6700 0004               2772ms     BEQ _00000012
00001010  60F6                    2773m             BRA WAIT_FOR_COMPLETE_204
00001012                          2774m         ENDI
00001012                          2775ms _00000012
00001012                          2776m         ENDM
00001012                          2777  
00001012                          2778m     PROTECT
00001012  31FC AAAA 2AAA          2779m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001018  31FC 5555 1554          2780m     MOVE.W #$5555,$1554
0000101E  31FC A0A0 2AAA          2781m     MOVE.W #$A0A0,$2AAA
00001024                          2782m     ENDM
00001024                          2783  
00001024  6000 F154               2784      BRA MAIN_LOOP
00001028                          2785      
00001028                          2786  M
00001028  7000                    2787      MOVE.L #0,D0                                        ; D0 will be the length to read            
0000102A  7200                    2788      MOVE.L #0,D1                                        ; D1 will be the address to read 
0000102C                          2789  
0000102C                          2790      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
0000102C  343C 0000               2791s     MOVE.W  #0,D2
00001030  6000 0046               2792s     BRA _2000000D
00001034                          2793s _2000000C
00001034  E989                    2794          LSL.L #4,D1                                     ; make what we have so far more significant
00001036                          2795m         WAIT_CHAR D3,D4                                 ; next character -> D2
00001036                          2796m WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001036                 TRUE     2797m     IFEQ DEBUG
00001036  1839 00C00003           2798m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000103C  0804 0000               2799m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001040  67F4                    2800m         BEQ WAIT_FOR_READY_206                      ; NOTHING, CHECK AGAIN
00001042                          2801m     ENDC
00001042                          2802m 
00001042                          2803mm     READ_CHAR D3
00001042                 TRUE     2804mm     IFEQ DEBUG
00001042  1639 00C00007           2805mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001048                          2806mm     ENDC
00001048                 FALSE    2807mm     IFNE DEBUG
00001048                          2808mm     ENDC
00001048                          2809mm 
00001048  B63C 001B               2810mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
0000104C  6700 EFBA               2811mm     BEQ START
00001050                          2812mm     ENDM
00001050                          2813m 
00001050                 TRUE     2814m     IFEQ DEBUG
00001050                          2815mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001050                          2816mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001050                 TRUE     2817mm     IFEQ DEBUG
00001050  1839 00C00003           2818mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001056  0804 0002               2819mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
0000105A  67F4                    2820mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
0000105C  13C3 00C00007           2821mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001062                          2822mm     ENDC
00001062                          2823mm 
00001062                 FALSE    2824mm     IFNE DEBUG
00001062                          2825mm     ENDC
00001062                          2826mm 
00001062                          2827mm     ENDM
00001062                          2828m     ENDC
00001062                          2829m     ENDM
00001062                          2830m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00001062  41FA 024F               2831m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001066  0403 0030               2832m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000106A  C6BC 000000FF           2833m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001070  1630 3000               2834m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001074                          2835m     ENDM
00001074  8203                    2836          OR.B D3,D1
00001076                          2837      ENDF
00001076  5242                    2838s     ADD.W   #1,D2
00001078                          2839s _2000000D
00001078  B47C 0007               2840s     CMP.W   #7,D2
0000107C  6FB6                    2841s     BLE _2000000C
0000107E                          2842m     PRINT_CRLF D2,A1
0000107E  43FA 025E               2843m     LEA CRLF(PC),A1
00001082                          2844mm     PRINT_STR A1,D2
00001082                          2845mm LOOP_211
00001082  0C11 0000               2846mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001086  6700 0016               2847mm     BEQ EXIT_211
0000108A                          2848mmm     PRINT_CHAR (A1)+,D2
0000108A                          2849mmm WAIT_FOR_READY_212                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000108A                 TRUE     2850mmm     IFEQ DEBUG
0000108A  1439 00C00003           2851mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001090  0802 0002               2852mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001094  67F4                    2853mmm         BEQ WAIT_FOR_READY_212                      ; NO SPACE, CHECK AGAIN
00001096  13D9 00C00007           2854mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000109C                          2855mmm     ENDC
0000109C                          2856mmm 
0000109C                 FALSE    2857mmm     IFNE DEBUG
0000109C                          2858mmm     ENDC
0000109C                          2859mmm 
0000109C                          2860mmm     ENDM
0000109C  60E4                    2861mm     BRA LOOP_211
0000109E                          2862mm EXIT_211
0000109E                          2863mm     ENDM
0000109E                          2864m     ENDM
0000109E                          2865  
0000109E  3001                    2866      MOVE.W D1,D0                                        ; extract the LSword for the length
000010A0  E089                    2867      LSR.L #8,D1                                         ; extract the MSword for the address
000010A2  E089                    2868      LSR.L #8,D1
000010A4                          2869  
000010A4  2241                    2870      MOVE.L D1,A1
000010A6                          2871      
000010A6  2047                    2872      MOVE.L D7,A0                                        ; address accumulator -> target address register
000010A8                          2873      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
000010A8                          2874  
000010A8                          2875      WHILE D0 <GT> #0 DO
000010A8                          2876s _10000016
000010A8  B07C 0000               2877s     CMP.W   #0,D0
000010AC  6F00 000E               2878s     BLE _10000017
000010B0  5580                    2879          SUB.L #2,D0
000010B2                          2880  
000010B2  13D1 00E00001           2881          MOVE.B (A1),DISPLAY
000010B8  30D9                    2882          MOVE.W (A1)+,(A0)+
000010BA                          2883      ENDW
000010BA  60EC                    2884s     BRA _10000016
000010BC                          2885s _10000017
000010BC                          2886      
000010BC  6000 F0BC               2887      BRA MAIN_LOOP
000010C0                          2888      
000010C0                          2889  J
000010C0  2047                    2890      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
000010C2  7E00                    2891      MOVE.L #0,D7
000010C4  2E7C 002FFFFC           2892      MOVE.L #$2FFFFC,A7                                  ; set up the stack pointer 
000010CA  2C7C 002FFFFC           2893      MOVE.L #$2FFFFC,A6                                  ; set up the frame pointer
000010D0                          2894  
000010D0  4E90                    2895      JSR (A0)
000010D2                          2896      
000010D2  41FA 0218               2897      LEA BACK(PC),A0
000010D6                          2898m     PRINT_STR A0,D0
000010D6                          2899m LOOP_213
000010D6  0C10 0000               2900m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000010DA  6700 0016               2901m     BEQ EXIT_213
000010DE                          2902mm     PRINT_CHAR (A0)+,D0
000010DE                          2903mm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010DE                 TRUE     2904mm     IFEQ DEBUG
000010DE  1039 00C00003           2905mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000010E4  0800 0002               2906mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000010E8  67F4                    2907mm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
000010EA  13D8 00C00007           2908mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010F0                          2909mm     ENDC
000010F0                          2910mm 
000010F0                 FALSE    2911mm     IFNE DEBUG
000010F0                          2912mm     ENDC
000010F0                          2913mm 
000010F0                          2914mm     ENDM
000010F0  60E4                    2915m     BRA LOOP_213
000010F2                          2916m EXIT_213
000010F2                          2917m     ENDM
000010F2                          2918      
000010F2  6000 F086               2919      BRA MAIN_LOOP
000010F6                          2920  
000010F6                          2921  HEX_DIGIT
000010F6  E98F                    2922      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000010F8                          2923m     HEX2BIN D2,D2,A0
000010F8  41FA 01B9               2924m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000010FC  0402 0030               2925m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001100  C4BC 000000FF           2926m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001106  1430 2000               2927m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000110A                          2928m     ENDM
0000110A  8E02                    2929      OR.B D2,D7  
0000110C  6000 F08C               2930      BRA GET_INPUT
00001110                          2931  
00001110  FFFF FFFF               2932      SIMHALT                                             ; halt simulator
00001114                          2933  
00001114                          2934  ; strings
00001114= 50 72 65 73 73 20 ...   2935  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001127= 5B 3F 5D 09 09 09 ...   2936  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001133= 5B 76 5D 09 09 09 ...   2937          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001142= 78 78 78 78 78 78 ...   2938          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000115A= 78 78 78 78 78 78 ...   2939          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000117A= 78 78 78 78 78 78 ...   2940          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
0000119B= 78 78 78 78 78 78 ...   2941          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000011AC= 5B 7A 5D 09 09 09 ...   2942          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
000011BE= 78 78 78 78 78 78 ...   2943          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000011DF= 78 78 78 78 78 78 ...   2944          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000011FE= 78 78 78 78 78 78 ...   2945          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001222= 78 78 78 78 78 78 ...   2946          DC.B 'xxxxxxxx[j]',TAB,TAB,'JST to C code',CR,LF,NULL
0000123F= 48 75 68 3F 0D 0A 00    2947  HUH  DC.B 'Huh?',CR,LF,NULL
00001246= 20 53 20 72 65 63 ...   2948  READ    DC.B ' S records read, start address = ',NULL
00001268= 57 3A 20 55 6E 6B ...   2949  UNREC   DC.B 'W: Unknown Srec type: ',NULL
0000127F= 57 3A 20 43 53 20 ...   2950  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001291= 57 3A 20 52 41 4D ...   2951  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
000012A3= 30 31 32 33 34 35 ...   2952  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000012B3= 00 01 02 03 04 05 ...   2953  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000012CA= 4C 6F 61 64 69 6E ...   2954  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000012DE= 0D 0A 00                2955  CRLF    DC.B CR,LF,NULL
000012E1= 3E 20 00                2956  PROMPT  DC.B '> ',NULL
000012E4= 30 78 00                2957  ox      DC.B '0x',NULL
000012E7= 20 2D 3E 20 00          2958  to      DC.B ' -> ',NULL
000012EC= 62 61 63 6B 20 66 ...   2959  BACK    DC.B 'back from the dead!',CR,LF,NULL
00001302= 4D 44 46 2D 6D 6F ...   2960  VERSION DC.B 'MDF-mon V1.81 (15/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
0000131F                          2961  
0000131F                          2962      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BACK                12EC
BIN2HEX             0
BIN2HEX_LUT         12A3
CONTINUE_105        94A
CONTINUE_46         426
CONTINUE_49         476
CONTINUE_53         4CC
CONTINUE_61         580
CONTINUE_66         5F2
CONTINUE_71         66E
CONTINUE_76         6EC
CONTINUE_81         774
CONTINUE_86         7E6
CONTINUE_91         858
CR                  D
CRLF                12DE
CS_FAILURE          127F
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A54
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_102            91C
EXIT_110            9B2
EXIT_112            9DA
EXIT_115            9FA
EXIT_12             170
EXIT_120            A44
EXIT_123            A74
EXIT_127            ABE
EXIT_130            AE0
EXIT_135            B2A
EXIT_137            BA8
EXIT_14             19A
EXIT_140            BCC
EXIT_145            C16
EXIT_152            CA2
EXIT_155            CFA
EXIT_158            D1C
EXIT_162            D66
EXIT_165            D88
EXIT_170            DD2
EXIT_183            ECA
EXIT_186            F1C
EXIT_190            F50
EXIT_194            F9A
EXIT_197            FBC
EXIT_20             22E
EXIT_202            1006
EXIT_211            109E
EXIT_213            10F2
EXIT_22             286
EXIT_24             2B2
EXIT_27             2DC
EXIT_37             38A
EXIT_44             3FE
EXIT_5              110
EXIT_58             53C
EXIT_7              130
EXIT_9              150
EXIT_96             8CA
EXIT_98             8EA
G                   B2E
GET_INPUT           19A
H                   28A
HELP                1127
HELPPROMPT          1114
HEX2BIN             10B
HEX2BIN_LUT         12B3
HEX_DIGIT           10F6
HUH                 123F
J                   10C0
L                   C26
LF                  A
LOADING             12CA
LOOP_102            900
LOOP_110            996
LOOP_112            9BE
LOOP_114            9FC
LOOP_115            9DE
LOOP_12             154
LOOP_120            A28
LOOP_122            A76
LOOP_123            A58
LOOP_127            AA2
LOOP_129            AE2
LOOP_130            AC4
LOOP_135            B0E
LOOP_137            B8C
LOOP_139            BCE
LOOP_14             17E
LOOP_140            BB0
LOOP_145            BFA
LOOP_152            C86
LOOP_155            CDE
LOOP_157            D1E
LOOP_158            D00
LOOP_162            D4A
LOOP_164            D8A
LOOP_165            D6C
LOOP_170            DB6
LOOP_183            EAE
LOOP_186            F00
LOOP_189            F52
LOOP_190            F34
LOOP_194            F7E
LOOP_196            FBE
LOOP_197            FA0
LOOP_20             212
LOOP_202            FEA
LOOP_211            1082
LOOP_213            10D6
LOOP_22             26A
LOOP_24             296
LOOP_26             2DE
LOOP_27             2C0
LOOP_37             36E
LOOP_44             3E2
LOOP_5              F4
LOOP_58             520
LOOP_7              114
LOOP_9              134
LOOP_96             8AE
LOOP_98             8CE
M                   1028
MAIN_LOOP           17A
NULL                0
OX                  12E4
P                   E56
PRINTSTR            296
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              12E1
PROTECT             A40
R                   2B6
RAM                 200000
RAM_ERROR           1291
READ                1246
READ_CHAR           62D
READ_DATA_TO_POKE   392
RESET               4
ROM                 0
S                   402
STACK               0
START               8
TAB                 9
TO                  12E7
UNPROTECT           979
UNREC               1268
V                   292
VERSION             1302
W                   38E
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_172  DE4
WAIT_FOR_COMPLETE_173  DFA
WAIT_FOR_COMPLETE_174  E0E
WAIT_FOR_COMPLETE_175  E20
WAIT_FOR_COMPLETE_176  E34
WAIT_FOR_COMPLETE_204  1008
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_100  8EA
WAIT_FOR_READY_103  908
WAIT_FOR_READY_105  92E
WAIT_FOR_READY_107  962
WAIT_FOR_READY_111  99E
WAIT_FOR_READY_113  9C6
WAIT_FOR_READY_116  9E6
WAIT_FOR_READY_118  A0E
WAIT_FOR_READY_121  A30
WAIT_FOR_READY_124  A60
WAIT_FOR_READY_126  A88
WAIT_FOR_READY_128  AAA
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  ACC
WAIT_FOR_READY_133  AF4
WAIT_FOR_READY_136  B16
WAIT_FOR_READY_138  B94
WAIT_FOR_READY_141  BB8
WAIT_FOR_READY_143  BE0
WAIT_FOR_READY_146  C02
WAIT_FOR_READY_147  C34
WAIT_FOR_READY_149  C4E
WAIT_FOR_READY_15   186
WAIT_FOR_READY_153  C8E
WAIT_FOR_READY_156  CE6
WAIT_FOR_READY_159  D08
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_161  D30
WAIT_FOR_READY_163  D52
WAIT_FOR_READY_166  D74
WAIT_FOR_READY_168  D9C
WAIT_FOR_READY_171  DBE
WAIT_FOR_READY_178  E62
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  E7C
WAIT_FOR_READY_184  EB6
WAIT_FOR_READY_187  F08
WAIT_FOR_READY_188  F1C
WAIT_FOR_READY_191  F3C
WAIT_FOR_READY_193  F64
WAIT_FOR_READY_195  F86
WAIT_FOR_READY_198  FA8
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_200  FD0
WAIT_FOR_READY_203  FF2
WAIT_FOR_READY_206  1036
WAIT_FOR_READY_208  1050
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_212  108A
WAIT_FOR_READY_214  10DE
WAIT_FOR_READY_23   272
WAIT_FOR_READY_25   29E
WAIT_FOR_READY_28   2C8
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2F0
WAIT_FOR_READY_31   306
WAIT_FOR_READY_32   31C
WAIT_FOR_READY_33   330
WAIT_FOR_READY_34   344
WAIT_FOR_READY_35   358
WAIT_FOR_READY_38   376
WAIT_FOR_READY_39   394
WAIT_FOR_READY_41   3AE
WAIT_FOR_READY_45   3EA
WAIT_FOR_READY_46   40A
WAIT_FOR_READY_48   444
WAIT_FOR_READY_49   45A
WAIT_FOR_READY_51   48E
WAIT_FOR_READY_53   4B0
WAIT_FOR_READY_55   4E4
WAIT_FOR_READY_59   528
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_61   564
WAIT_FOR_READY_63   598
WAIT_FOR_READY_66   5D6
WAIT_FOR_READY_68   60A
WAIT_FOR_READY_71   652
WAIT_FOR_READY_73   686
WAIT_FOR_READY_76   6D0
WAIT_FOR_READY_78   704
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_81   758
WAIT_FOR_READY_83   78C
WAIT_FOR_READY_86   7CA
WAIT_FOR_READY_88   7FE
WAIT_FOR_READY_91   83C
WAIT_FOR_READY_93   870
WAIT_FOR_READY_97   8B6
WAIT_FOR_READY_99   8D6
WAIT_FOR_SRECORD    40A
Z                   B36
_00000000           1DA
_00000001           1EE
_00000002           544
_00000003           920
_00000004           552
_00000005           740
_00000006           6B6
_00000007           920
_00000008           8AA
_00000009           920
_0000000A           A48
_0000000B           A54
_0000000C           C16
_0000000D           DEE
_0000000E           E08
_0000000F           E1C
_00000010           E2C
_00000011           E40
_00000012           1012
_10000000           4A6
_10000001           50E
_10000002           55A
_10000003           5C2
_10000004           5CC
_10000005           634
_10000006           648
_10000007           6B0
_10000008           6BA
_10000009           73A
_1000000A           6C6
_1000000B           72E
_1000000C           74E
_1000000D           7B6
_1000000E           7C0
_1000000F           828
_10000010           832
_10000011           89A
_10000012           924
_10000013           98C
_10000014           DD2
_10000015           DF4
_10000016           10A8
_10000017           10BC
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           B48
_20000005           B58
_20000006           B72
_20000007           C18
_20000008           C32
_20000009           C76
_2000000A           E60
_2000000B           EA4
_2000000C           1034
_2000000D           1078
